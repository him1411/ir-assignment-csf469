Well, I\'ve tried to understand and read what could cause it but I just can\'t get it:I have somewhere in my code this:Thing is that, when it tries to invoke some method it throws\n InvocationTargetException instead of some other expected exception (specifically ArrayIndexOutOfBoundsException).\n As I actually know what method is invoked I went straight to this method code and added a try-catch block for the line that suppose to throw  ArrayIndexOutOfBoundsException and it really threw ArrayIndexOutOfBoundsException as expected. Yet when going up it\n somehow changes to InvocationTargetException and in the code above catch(Exception e) \n e is InvocationTargetException and not ArrayIndexOutOfBoundsException\n as expected.What could cause such a behavior or how can I check such a thing?You\'ve added an extra level of abstraction by calling the method with reflection. The reflection layer wraps any exception in an InvocationTargetException, which lets you tell the difference between an exception actually caused by a failure in the reflection call (maybe your argument list wasn\'t valid, for example) and a failure within the method called.Just unwrap the cause within the InvocationTargetException and you\'ll get to the original one.The exception is thrown ifInvocationTargetException - if the underlying method throws an exception.So if the method, that has been invoked with reflection API, throws an exception (runtime exception for example), the reflection API will wrap the exception into an InvocationTargetException.Use the getCause() method on the InvocationTargetException to retrieve the original exception.From the Javadoc of Method.invoke()Throws: InvocationTargetException - if the underlying method throws an exception. This exception is thrown if the method called threw an exception.This will print the exact line of code in the specific method, which when invoked, raised the exception:That InvocationTargetException is probably wrapping up your ArrayIndexOutOfBoundsException. There is no telling upfront when using reflection what that method can throw -- so rather than using a throws Exception approach, all the exceptions are being caught and wrapped up in InvocationTargetException.This describes something like,InvocationTargetException is a checked exception that wraps an\n  exception thrown by an invoked method or constructor. As of release\n  1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The "target exception" that is\n  provided at construction time and accessed via the\n  getTargetException() method is now known as the cause, and may be\n  accessed via the Throwable.getCause() method, as well as the\n  aforementioned "legacy method."This exception is thrown if the underlying method(method called using Reflection) throws an exception.So if the method, that has been invoked by reflection API, throws an exception (as for example runtime exception), the reflection API will wrap the exception into an InvocationTargetException.You can compare with the original exception Class using getCause() method like this :I was facing the same problem. I used e.getCause().getCause() then I found that it was because of wrong parameters I was passing. There was nullPointerException in fetching the value of one of the parameters.\nHope this will help you.The error vanished after I did \nClean->Run xDoclet->Run xPackaging.In my workspace, in ecllipse.