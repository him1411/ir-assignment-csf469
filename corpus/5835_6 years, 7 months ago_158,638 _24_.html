I have a question regarding the native Array.forEach implementation of JavaScript: Does it behave asynchronously?\nFor example, if I call:Will this be non-blocking?No, it is blocking. Have a look at the specification of the algorithm.However a maybe easier to understand implementation is given on MDN:If you have to execute a lot of code for each element, you should consider to use a different approach:and then call it with:This would be non-blocking then. The example is taken from High Performance JavaScript.Another option might be web workers.If you need an asynchronous-friendly version of Array.forEach and similar, they\'re available in the Node.js \'async\' module: http://github.com/caolan/async ...as a bonus this module also works in the browser.There is a common pattern for doing a really heavy computation in Node that may be applicable to you...Node is single-threaded (as a deliberate design choice, see What is Node.js?); this means that it can only utilize a single core.  Modern boxes have 8, 16, or even more cores, so this could leave 90+% of the machine idle.  The common pattern for a REST service is to fire up one node process per core, and put these behind a local load balancer like http://nginx.org/.Forking a child - \nFor what you are trying to do, there is another common pattern, forking off a child process to do the heavy lifting.  The upside is that the child process can do heavy computation in the background while your parent process is responsive to other events.  The catch is that you can\'t / shouldn\'t share memory with this child process (not without a LOT of contortions and some native code); you have to pass messages.  This will work beautifully if the size of your input and output data is small compared to the computation that must be performed.  You can even fire up a child node.js process and use the same code you were using previously.For example:Array.forEach is meant for computing stuff not waiting, and there is nothing to be gained making computations asynchronous in an event loop (webworkers add multiprocessing, if you need multi-core computation). If you want to wait for multiple tasks to end, use a counter, which you can wrap in a semaphore class.This is exactly why I am excited about es7, in future you will be able to do something like the code below (some of the specs are not complete so use with caution, I will try to keep this up to date). But basically using the new :: bind operator, you will be able to run a method on an object as if the object\'s prototype contains the method. eg [Object]::[Method] where normally you would call [Object].[ObjectsMethod]Note to do this today (24-July-16) and have it work in all browsers you will need to transpile your code for the following functionality:Import / Export, Arrow functions, Promises, Async / Await and most importantly function bind. The code below could be modfied to use only function bind if nessesary, all this functionality is neatly available today by using babel.YourCode.js (where \'lots of work to do\' must simply return a promise, resolving it when the asynchronous work is done.)ArrayExtensions.jsThis is a short asynchronous function to use without requiring third party libsThere is a package on npm for easy asynchronous for each loops.Also another variation forAllAsyncIt is possible to code even the solution like this for example :On the other hand, it is much slower than a "for".Otherwise, the excellent Async library can do this: https://caolan.github.io/async/docs.html#each