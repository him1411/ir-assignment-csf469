I am looking for a way to convert a long string (from a dump), that represents hex values into a byte array.I couldn\'t have phrased it better than the person that posted the same question here:http://www.experts-exchange.com/Programming/Programming_Languages/Java/Q_21062554.htmlBut to keep it original, I\'ll phrase it my own way: suppose I have a string "00A0BF" that I would like interpreted as the byte[] {0x00,0xA0,0xBf} what should I do?I am a Java novice and ended up using BigInteger and watching out for leading hex zeros. But I think it is ugly and I am sure I am missing something simple... Here\'s a solution that I think is better than any posted so far:Reasons why it is an improvement:Safe with leading zeros (unlike BigInteger) and with negative byte values (unlike Byte.parseByte)Doesn\'t convert the String into a char[], or create StringBuilder and String objects for every single byte.Feel free to add argument checking via assert or exceptions if the argument is not known to be safe.One-liners:Warnings: The Hex class in commons-codec should do that for you.http://commons.apache.org/codec/You can now use BaseEncoding in guava to accomplish this.To reverse it use The HexBinaryAdapter provides the ability to marshal and unmarshal between String and byte[].That\'s just an example I typed in...I actually just use it as is and don\'t need to make a separate method for using it.Actually, I think the BigInteger is solution is very nice:Edit: Not safe for leading zeros, as noted by the poster.One-liners:For those of you interested in the actual code behind the One-liners from FractalizeR (I needed that since javax.xml.bind is not available for Android (by default)), this comes from com.sun.xml.internal.bind.DatatypeConverterImpl.java :Here is a method that actually works (based on several previous semi-correct answers):The only possible issue that I can see is if the input string is extremely long; calling toCharArray() makes a copy of the string\'s internal array.EDIT: Oh, and by the way, bytes are signed in Java, so your input string converts to [0, -96, -65] instead of [0, 160, 191]. But you probably knew that already.In android ,if you are working with hex, you can try okio.simple usage:and result will be EDIT: as pointed out by @mmyers, this method doesn\'t work on input that contains substrings corresponding to bytes with the high bit set ("80" - "FF"). The explanation is at Bug ID: 6259307 Byte.parseByte not working as advertised in the SDK Documentation.The Code presented by Bert Regelink simply does not work. \nTry the following:I\'ve always used a method likethis method splits on space delimited hex values but it wouldn\'t be hard to make it split the string on any other criteria such as into groupings of two characters. I like the Character.digit solution, but here is how I solved itFor what it\'s worth, here\'s another version which supports odd length strings, without resorting to string concatenation.The BigInteger() Method from java.math is very Slow and not recommandable.Integer.parseInt(HEXString, 16)can cause problems with some characters without\nconverting to Digit / Integera Well Working method:Function:Have Fun, Good LuckI found Kernel Panic to have the solution most useful to me, but ran into problems if the hex string was an odd number.  solved it this way:I am adding a number of hex numbers to an array, so i pass the reference to the array I am using, and the int I need converted and returning the relative position of the next hex number.  So the final byte array has [0] number of hex pairs, [1...] hex pairs, then the number of pairs...  Based on the op voted solution, the following should be a bit more efficient:Because: the initial conversion to a char array spares the length checks in charAtMy formal solution:Is like the PHP hex2bin() Function but in Java style.Example:I think will do it for you. I cobbled it together from a similar function that returned the data as a string:For Me this was the solution, HEX="FF01" then split to FF(255) and 01(01) 