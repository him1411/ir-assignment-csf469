I\'m helping a veterinary clinic measuring pressure under a dogs paw. I use Python for my data analysis and now I\'m stuck trying to divide the paws into (anatomical) subregions.I made a 2D array of each paw, that consists of the maximal values for each sensor that has been loaded by the paw over time. Here\'s an example of one paw, where I used Excel to draw the areas I want to \'detect\'. These are 2 by 2 boxes around the sensor with local maxima\'s, that together have the largest sum.So I tried some experimenting and decide to simply look for the maximums of each column and row (can\'t look in one direction due to the shape of the paw). This seems to \'detect\' the location of the separate toes fairly well, but it also marks neighboring sensors. So what would be the best way to tell Python which of these maximums are the ones I want? Note: The 2x2 squares can\'t overlap, since they have to be separate toes!Also I took 2x2 as a convenience, any more advanced solution is welcome, but I\'m simply a human movement scientist, so I\'m neither a real programmer or a mathematician, so please keep it \'simple\'. Here\'s a version that can be loaded with np.loadtxtSo I tried @jextee\'s solution (see the results below). As you can see, it works very on the front paws, but it works less well for the hind legs. More specifically, it can\'t recognize the small peak that\'s the fourth toe. This is obviously inherent to the fact that the loop looks top down towards the lowest value, without taking into account where this is. Would anyone know how to tweak @jextee\'s algorithm, so that it might be able to find the 4th toe too?Since I haven\'t processed any other trials yet, I can\'t supply any other samples. But the data I gave before were the averages of each paw. This file is an array with the maximal data of 9 paws in the order they made contact with the plate.This image shows how they were spatially spread out over the plate.I have set up a blog for anyone interested and I have setup a SkyDrive with all the raw measurements. So to anyone requesting more data: more power to you! So after the help I got with my questions regarding paw detection and paw sorting, I was finally able to check the toe detection for every paw! Turns out, it doesn\'t work so well in anything but paws sized like the one in my own example. Off course in hindsight, it\'s my own fault for choosing the 2x2 so arbitrarily.Here\'s a nice example of where it goes wrong: a nail is being recognized as a toe and the \'heel\' is so wide, it gets recognized twice!The paw is too large, so taking a 2x2 size with no overlap, causes some toes to be detected twice. The other way around, in small dogs it often fails to find a 5th toe, which I suspect is being caused by the 2x2 area being too large.After trying the current solution on all my measurements I came to the staggering conclusion that for nearly all my small dogs it didn\'t find a 5th toe and that in over 50% of the impacts for the large dogs it would find more!So clearly I need to change it. My own guess was changing the size of the neighborhood to something smaller for small dogs and larger for large dogs. But generate_binary_structure wouldn\'t let me change the size of the array. Therefore, I\'m hoping that anyone else has a better suggestion for locating the toes, perhaps having the toe area scale with the paw size?I detected the peaks using a local maximum filter. Here is the result on your first dataset of 4 paws:\nI also ran it on the second dataset of 9 paws and it worked as well.Here is how you do it:All you need to do after is use scipy.ndimage.measurements.label on the mask to label all distinct objects. Then you\'ll be able to play with them individually.Note that the method works well because the background is not noisy. If it were, you would detect a bunch of other unwanted peaks in the background. Another important factor is the size of the neighborhood. You will need to adjust it if the peak size changes (the should remain roughly proportional).Data file: paw.txt. Source code:Output without overlapping squares. It seems that the same areas are selected as in your example.The tricky part is to calculate sums of all 2x2 squares. I assumed you need all of them, so there might be some overlapping. I used slices to cut the first/last columns and rows from the original 2D array, and then overlapping them all together and calculating sums.To understand it better, imaging a 3x3 array:Then you can take its slices:Now imagine you stack them one above the other and sum elements at the same positions. These sums will be exactly the same sums over the 2x2 squares with the top-left corner in the same position:When you have the sums over 2x2 squares, you can use max to find the maximum, or sort, or sorted to find the peaks.To remember positions of the peaks I couple every value (the sum) with its ordinal position in a flattened array (see zip). Then I calculate row/column position again when I print the results.I allowed for the 2x2 squares to overlap. Edited version filters out some of them such that only non-overlapping squares appear in the results.Another problem is how to choose what is likely to be fingers out of all the peaks. I have an idea which may or may not work. I don\'t have time to implement it right now, so just pseudo-code.I noticed that if the front fingers stay on almost a perfect circle, the rear finger should be inside of that circle. Also, the front fingers are more or less equally spaced. We may try to use these heuristic properties to detect the fingers.Pseudo code:This is a brute-force approach. If N is relatively small, then I think it is doable. For N=12, there are C_12^5 = 792 combinations, times 5 ways to select a rear finger, so 3960 cases to evaluate for every paw.This is an image registration problem. The general strategy is:Here\'s a rough and ready approach, "the dumbest thing that could possibly work":To counteract the orientation problem, you could have 8 or so initial settings for the basic directions (North, North East, etc). Run each one individually and throw away any results where two or more toes end up at the same pixel. I\'ll think about this some more, but this kind of thing is still being researched in image processing - there are no right answers!Slightly more complex idea: (weighted) K-means clustering. It\'s not that bad.Then iterate until convergence:This method will almost certainly give much better results, and you get the mass of each cluster which may help in identifying the toes.(Again, you\'ve specified the number of clusters up front. With clustering you have to specify the density one way or another: Either choose the number of clusters, appropriate in this case, or choose a cluster radius and see how many you end up with. An example of the latter is mean-shift.)Sorry about the lack of implementation details or other specifics. I would code this up but I\'ve got a deadline. If nothing else has worked by next week let me know and I\'ll give it a shot.This problem has been studied in some depth by physicists. There is a good implementation in ROOT. Look at the TSpectrum classes (especially TSpectrum2 for your case) and the documentation for them.References:...and for those who don\'t have access to a subscription to NIM:Just a couple of ideas off the top of my head:You might also want to take a look at OpenCV, it\'s got a fairly decent Python API and might have some functions you\'d find useful.Here is an idea: you calculate the (discrete) Laplacian of the image.  I would expect it to be (negative and) large at maxima, in a way that is more dramatic than in the original images.  Thus, maxima could be easier to find.Here is another idea: if you know the typical size of the high-pressure spots, you can first smooth your image by convoluting it with a Gaussian of the same size.  This may give you simpler images to process.Physicist\'s solution:\nDefine 5 paw-markers identified by their positions X_i and init them with random positions.\nDefine some energy function combining some award for location of markers in paws\' positions with some punishment for overlap of markers; let\'s say:(S(X_i) is the mean force in 2x2 square around X_i, alfa is a parameter to be peaked experimentally)Now time to do some Metropolis-Hastings magic:\n  1. Select random marker and move it by one pixel in random direction.\n  2. Calculate dE, the difference of energy this move caused.\n  3. Get an uniform random number from 0-1 and call it r.\n  4. If dE<0 or exp(-beta*dE)>r, accept the move and go to 1; if not, undo the move and go to 1.\nThis should be repeated until the markers will converge to paws. Beta controls the scanning to optimizing tradeoff, so it should be also optimized experimentally; it can be also constantly increased with the time of simulation (simulated annealing).thanks for the raw data.  I\'m on the train and this is as far as I\'ve gotten (my stop is coming up).  I massaged your txt file with regexps and have plopped it into a html page with some javascript for visualization.  I\'m sharing it here because some, like myself, might find it more readily hackable than python.I think a good approach will be scale and rotation invariant, and my next step will be to investigate mixtures of gaussians.  (each paw pad being the center of a gaussian).Heres another approach that I used when doing something similar for a large telescope:1) Search for the highest pixel. \nOnce you have that, search around that for the best fit for 2x2 (maybe maximizing the 2x2 sum), or do a 2d gaussian fit inside the sub region of say 4x4 centered on the highest pixel.Then set those 2x2 pixels you have found to zero (or maybe 3x3) around the peak centergo back to 1) and repeat till the highest peak falls below a noise threshold, or you have all the toes you needIt\'s probably worth to try with neural networks if you are able to create some training data... but this needs many samples annotated by hand.a rough outline...you\'d probably want to use a connected components algorithm to isolate each paw region. wiki has a decent description of this (with some code) here: http://en.wikipedia.org/wiki/Connected_Component_Labelingyou\'ll have to make a decision about whether to use 4 or 8 connectedness. personally, for most problems i prefer 6-connectedness. anyway, once you\'ve separated out each "paw print" as a connected region, it should be easy enough to iterate through the region and find the maxima. once you\'ve found the maxima, you could iteratively enlarge the region until you reach a predetermined threshold in order to identify it as a given "toe". one subtle problem here is that as soon as you start using computer vision techniques to identify something as a right/left/front/rear paw and you start looking at individual toes, you have to start taking rotations, skews, and translations into account. this is accomplished through the analysis of so-called "moments". there are a few different moments to consider in vision applications: central moments: translation invariant\nnormalized moments: scaling and translation invariant\nhu moments: translation, scale, and rotation invariant more information about moments can be found by searching "image moments" on wiki. Well, here\'s some simple and not terribly efficient code, but for this size of a data set it is fine.I basically just make an array with the position of the upper-left and the sum of each 2x2 square and sort it by the sum. I then take the 2x2 square with the highest sum out of contention, put it in the best array, and remove all other 2x2 squares that used any part of this just removed 2x2 square.It seems to work fine except with the last paw (the one with the smallest sum on the far right in your first picture), it turns out that there are two other eligible 2x2 squares with a larger sum (and they have an equal sum to each other). One of them is still selects one square from your 2x2 square, but the other is off to the left. Fortunately, by luck we see to be choosing more of the one that you would want, but this may require some other ideas to be used to get what you actually want all of the time.It seems you can cheat a bit using jetxee\'s algorithm.  He is finding the first three toes fine, and you should be able to guess where the fourth is based off that.Perhaps you can use something like Gaussian Mixture Models. Here\'s a Python package for doing GMMs (just did a Google search)\nhttp://www.ar.media.kyoto-u.ac.jp/members/david/softwares/em/Interesting problem.  The solution I would try is the following.Apply a low pass filter, such as convolution with a 2D gaussian mask.  This will give you a bunch of (probably, but not necessarily floating point) values.Perform a 2D non-maximal suppression using the known approximate radius of each paw pad (or toe).This should give you the maximal positions without having multiple candidates which are close together.  Just to clarify, the radius of the mask in step 1 should also be similar to the radius used in step 2.  This radius could be selectable, or the vet could explicitly measure it beforehand (it will vary with age/breed/etc).Some of the solutions suggested (mean shift, neural nets, and so on) probably will work to some degree, but are overly complicated and probably not ideal.I\'m sure you have enough to go on by now, but I can\'t help but suggest using the k-means clustering method. k-means is an unsupervised clustering algorithm which will take you data (in any number of dimensions - I happen to do this in 3D) and arrange it into k clusters with distinct boundaries. It\'s nice here because you know exactly how many toes these canines (should) have.Additionally, it\'s implemented in Scipy which is really nice (http://docs.scipy.org/doc/scipy/reference/cluster.vq.html). Here\'s an example of what it can do to spatially resolve 3D clusters: What you want to do is a bit different (2D and includes pressure values), but I still think you could give it a shot. Maybe a naive approach is sufficient here: Build a list of all 2x2 squares on your plane, order them by their sum (in descending order). First, select the highest-valued square into your "paw list". Then, iteratively pick 4 of the next-best squares that don\'t intersect with any of the previously found squares. What if you proceed step by step: you first locate the global maximum, process if needed the surrounding points given their value, then set the found region to zero, and repeat for the next one.I am not sure this answers the question, but it seems like you can just look for the n highest peaks that don\'t have neighbors.Here is the gist.  Note that it\'s in Ruby, but the idea should be clear.