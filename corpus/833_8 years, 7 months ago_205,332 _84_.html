If your application requires a database and it comes with built in data, what is the best way to ship that application? Should I:Precreate the SQLite database and include it in the .apk?Include the SQL commands with the application and have it create the database and insert the data on first use?The drawbacks I see are:Possible SQLite version mismatches might cause problems and I currently don\'t know where the database should go and how to access it.It may take a really long time to create and populate the database on the device.Any suggestions? Pointers to the documentation regarding any issues would be greatly appreciated.I just found a way to do this in ReignDesign blog in an article titled Using your own SQLite database in Android applications. Basically you precreate your database, put it in your assets directory in your apk, and on first use copy to "/data/data/YOUR_PACKAGE/databases/" directory.There are two options for creating and updating databases. One is to create a database externally, then place it in the assets folder of the project and then copy the entire database from there.  This is much quicker if the database has a lot of tables and other components.  Upgrades are triggered by changing the database version number in the res/values/strings.xml file. Upgrades would then be accomplished by creating a new database externally, replacing the old database in the assets folder with the new database, saving the old database in internal storage under another name, copying the new database from the assets folder into internal storage, transferring all of the data from the old database (that was renamed earlier) into the new database and finally deleting the old database.  You can create a database originally by using the SQLite Manager FireFox plugin to execute your creation sql statements.The other option is to create a database internally from a sql file.  This is not as quick but the delay would probably be unnoticeable to the users if the database has only a few tables. Upgrades are triggered by changing the database version number in the res/values/strings.xml file.  Upgrades would then be accomplished by processing an upgrade sql file.  The data in the database will remain unchanged except when its container is removed, for example dropping a table.The example below demonstrates how to use either method.Here is a sample create_database.sql file.  It is to be placed in the assets folder of the project for the internal method or copied into the "Execute SQL\' of SQLite Manager to create the database for the external method.  (NOTE: Notice the comment about the table required by Android.)Here is a sample update_database.sql file.  It is to be placed in the assets folder of the project for the internal method or copied into the "Execute SQL\' of SQLite Manager to create the database for the external method.  (NOTE: Notice that all three types of  SQL comments will be ignored by the sql parser that is included in this example.)Here is an entry to add to the /res/values/strings.xml file for the database version number.Here is an activity that accesses the database and then uses it.  (Note: You might want to run the database code in a separate thread if it uses a lot of resources.)Here is the database helper class where the database is created or updated if necessary.  (NOTE: Android requires that you create a class that extends SQLiteOpenHelper in order to work with a Sqlite database.)Here\'s the FileHelper class that contains methods for byte stream copying files and parsing sql files.The SQLiteAssetHelper library makes this task really simple.It\'s easy to add as a gradle dependency (but a Jar is also available for Ant/Eclipse), and together with the documentation it can be found at:\nhttps://github.com/jgilfelt/android-sqlite-asset-helperAs explained in documentation:Add the dependency to your module\'s gradle build file:Copy the database into the assets directory, in a subdirectory called assets/databases. For instance:\nassets/databases/my_database.db(Optionally, you may compress the database in a zip file such as assets/databases/my_database.zip. This isn\'t needed, since the APK is compressed as a whole already.)Create a class, for example:I guess the best and the newest way till today is using SQLiteAssetHelper class. This tutorial guides you perfectly through Importing and Using External Database in AndroidThe Android SQLiteAssetHelper library allows you to build your SQLite\n  database in your desktop computer, and to import and use it in your\n  Android application. Let\'s create a simple application to demonstrate\n  the application of this library.Step 1: Create a database quotes.db using your favorite SQLite\n  database application (DB Browser for SQLite is a portable cross\n  platform freeware, which can be used to create and edit SQLite\n  databases). Create a table \'quotes\' with a single column \'quote\'.\n  Insert some random quotes into the table \'quotes\'.Step 2: The database can be imported into project either directly as\n  it is, or as a compressed file. The compressed file is recommended, if\n  your database is too large in size. You can create either a ZIP\n  compression or a GZ compression.The file name of the compressed db file must be quotes.db.zip, if you\n  are using ZIP compression or quotes.db.gz, if you are using GZ\n  compression.Step 3: Create a new application External Database Demo with a\n  package name com.javahelps.com.javahelps.externaldatabasedemo.Step 4: Open the build.gradle (Module: app) file and add the following\n  dependency.Once you have saved the build.gradle file click on the \'Sync Now\'\n  link to update the project. You can synchronize the build.gradle, by\n  right clicking on the build.gradle file and selecting Synchronize\n  build.gradle option as well.Step 5: Right click on the app folder and create new assets folder.Step 6: Create a new folder \'databases\' inside the assets folder.Step 7: Copy and paste the  quotes.db.zip file inside the\n  assets/databases folder.Step 8: Create a new class DatabaseOpenHelperStep 9: Create a new class DatabaseAccess and enter the code as shown\n  below. More details about this class is available at Advanced Android\n  Database tutorial.update and delete any rows in the database as usual. For more details,\n  follow this link Advanced Android Database.All the database related setups are completed and now we need to\n  create a ListView to display the quotes.Step 10: Add a ListView in your activity_main.xml.Step 11: Find the object of ListView in the onCreate method of MainActivity and feed the quotes which are read\n  form the database.Step 12: Save all the changes and run the application.In addition to this article you can download SQLiteAssetHelper hereMy solution neither uses any third-party library nor forces you to call custom methods on SQLiteOpenHelper subclass to initialize the database on creation. It also takes care of database upgrades as well. All that needs to be done is to subclass SQLiteOpenHelper.Enough said. Here goes the SQLiteOpenHelper subclass:Finally, to get a database connection, just call getReadableDatabase() or getWritableDatabase() on the SQLiteOpenHelper subclass and it will take care of creating a db, copying db contents from the specified file in the \'assets\' folder, if the database does not exist.In short, you can use the SQLiteOpenHelper subclass to access the db shipped in the assets folder  just as you would use for a database that is initialized using SQL queries in the onCreate() method.From what I\'ve seen you should be be shipping a database that already has the tables setup and data. However if you want (and depending on the type of application you have) you can allow "upgrade database option". Then what you do is download the latest sqlite version, get the latest Insert/Create statements of a textfile hosted online, execute the statements and do a data transfer from the old db to the new one.Currently there is no way to precreate an SQLite database to ship with your apk.  The best you can do is save the appropriate SQL as a resource and run them from your application.  Yes, this leads to duplication of data (same information exists as a resrouce and as a database) but there is no other way right now.  The only mitigating factor is the apk file is compressed.  My experience is 908KB compresses to less than 268KB.The thread below has the best discussion/solution I have found with good sample code.http://groups.google.com/group/android-developers/msg/9f455ae93a1cf152I stored my CREATE statement as a string resource to be read with Context.getString() and ran it with SQLiteDatabse.execSQL().I stored the data for my inserts in res/raw/inserts.sql (I created the sql file, 7000+ lines).  Using the technique from the link above I entered a loop, read the file line by line and concactenated the data onto "INSERT INTO tbl VALUE " and did another SQLiteDatabase.execSQL().  No sense in saving 7000 "INSERT INTO tbl VALUE "s when they can just be concactenated on.  It takes about twenty seconds on the emulator, I do not know how long this would take on a real phone, but it only happens once, when the user first starts the application.Finally I did it!! I have used this link help Using your own SQLite database in Android applications, but had to change it a little bit.If you have many packages you should put the master package name here:private static String DB_PATH = "data/data/masterPakageName/databases";I changed the method which copies the database from local folder to emulator folder! It had some problem when that folder didn\'t exist. So first of all, it should check the path  and if it\'s not there, it should create the folder.In the previous code, the copyDatabase method was never called when the database didn\'t exist and the checkDataBase method caused exception. so I changed the code a little bit.If your database does not have a file extension, don\'t use the file name with one.it works nice for me , i hope it whould be usefull for u tooShipping the database inside the apk and then copying it to /data/data/... will double the size of the database (1 in apk, 1 in data/data/...), and will increase the apk size (of course). So your database should not be too big.Android already provides a version-aware approach of database management. This approach has been leveraged in the BARACUS framework for Android applications. It enables you to manage the database along the entire version lifecycle of an app, beeing able to update the sqlite database from any prior version to the current one.Also, it allows you to run hot-backups and hot-recovery of the SQLite.I am not 100% sure, but a hot-recovery for a specific device may enable you to ship a prepared database in your app. But I am not sure about the database binary format which might be specific to certain devices, vendors or device generations.Since the stuff is Apache License 2, feel free to reuse any part of the code, which can be found on githubEDIT : If you only want to ship data, you might consider instantiating and persisting POJOs at the applications first start. BARACUS got a built-in support to this (Built-in key value store for configuration infos, e.g. "APP_FIRST_RUN" plus a after-context-bootstrap hook in order to run post-launch operations on the context). This enables you to have tight coupled data shipped with your app; in most cases this fitted to my use cases.If the required data is not too large (limits I don\xc2\xb4t know, would depend on a lot of things), you might also download the data (in XML, JSON, whatever) from a website/webapp. AFter receiving, execute the SQL statements using the received data creating your tables and inserting the data. If your mobile app contains lots of data, it might be easier later on to update the data in the installed apps with more accurate data or changes.I wrote a library to simplify this process.It will create a dataBase from assets/databases/myDb.db file.\nIn addition  you will get all those functionality:Clone it from github.I\'m using ORMLite and below code worked for mePlease note, The code extracts database file from a zip file in assetsI modified the class and the answers to the question and wrote a class that allows updating the database via DB_VERSION.Using a class.In the activity class, declare variables.In the onCreate method, write the following code.If you add a database file to the folder res/raw then use the following modification of the class.http://blog.harrix.org/article/6784