I\'m learning Elixir and wonder why it has two types of function definitions:Only the second kind of function seems to be a first-class object and can be passed as a parameter to other functions. A function defined in a module needs to be wrapped in a fn. There\'s some syntactic sugar which looks like otherfunction(myfunction(&1, &2)) in order to make that easy, but why is it necessary in the first place? Why can\'t we just do otherfunction(myfunction))? Is it only to allow calling module functions without parenthesis like in Ruby? It seems to have inherited this characteristic from Erlang which also has module functions and funs, so does it actually comes from how the Erlang VM works internally?It there any benefit having two types of functions and converting from one type to another in order to pass them to other functions? Is there a benefit having two different notations to call functions?Just to clarify the naming, they are both functions. One is a named function and the other is an anonymous one. But you are right, they work somewhat differently and I am going to illustrate why they work like that.Let\'s start with the second, fn. fn is a closure, similar to a lambda in Ruby. We can create it as follows:A function can have multiple clauses too:Now, let\'s try something different. Let\'s try to define different clauses expecting a different number of arguments:Oh no! We get an error! We cannot mix clauses that expects a different number of arguments. A function always has a fixed arity.Now, let\'s talk about the named functions:As expected, they have a name and they can also receive some arguments. However, they are not closures:This code will fail to compile because every time you see a def, you get an empty variable scope. That is an important difference between them. I particularly like the fact each named function starts with a clean slate and you don\'t get the variables of different scopes all mixed up together. You have a clear boundary.We could retrieve the named hello function above as an anonymous function. You mentioned about it yourself:And then you asked, why I cannot simply pass it as hello as in other languages? That\'s because functions in Elixir are identified by name and arity. So a function that expects two arguments is a different function than one that expects three, even if they had the same name. So if we simply passed hello, we would have no idea which hello you actually meant. The one with two, three or four arguments? This is exactly the same reason why we can\'t create an anonymous function with clauses with different arities.Since Elixir v0.10.1, we have a syntax to capture named functions:That will capture the local named function hello with arity 1. Throughout the language and its documentation, it is very common to identify functions in this hello/1 syntax.This is also why Elixir uses a dot for calling anonymous functions. Since you can\'t simply pass hello around as a function, instead you need to explicitly capture it, there is a natural distinction between named and anonymous functions and a distinct syntax for calling each makes everything a bit more explicit (Lispers would be familiar with this due to the Lisp 1 vs. Lisp 2 discussion).Overall, those are the reasons why we have two functions and why they behave differently.I don\'t know how useful this will be to anyone else, but the way I finally wrapped my head around the concept was to realize that elixir functions aren\'t Functions. Everything in elixir is an expression. So is not a function but the expression returned by executing the code in my_function. There is actually only one way to get a "Function" that you can pass around as an argument and that is to use the anonymous function notation. It is tempting to refer to the fn or & notation as a function pointer, but it is actually much more. It\'s a closure of the surrounding environment.If you ask yourself:Do I need an execution environment or a data value in this spot?And if you need execution use fn, then most of the difficulties become much \nclearer. I understand the explanation why &f/1 is needed, although it would be nice to have a way to say "all functions f of any arity" and have the rest be done under the covers.Even if the &f/1 is needed to refer to the function itself, I do not understand why is is also necessary to use the ".(args)" variation to invoke that function. Is this because of potential name shadowing, or some other reason?This is something that will have to be repeatedly explained over the lifetime of Elixir. http://joearms.github.io/2013/05/31/a-week-with-elixir.htmlI may be wrong since nobody mentioned it, but I was also under the impression that the reason for this is also the ruby heritage of being able to call functions without brackets.Arity is obviously involved but lets put it aside for a while and use functions without arguments. In a language like javascript where brackets are mandatory, it is easy to make the difference between passing a function as an argument and calling the function. You call it only when you use the brackets.As you can see, naming it or not does not make a big difference. But elixir and ruby allow you to call functions without the brackets. This is a design choice which I personally like but it has this side effect you cannot use just the name without the brackets because it could mean you want to call the function. This is what the & is for. If you leave arity appart for a second, prepending your function name with & means that you explicitly want to use this function as an argument, not what this function returns.Now the anonymous function is bit different in that it is mainly used as an argument. Again this is a design choice but the rational behind it is that it is mainly used by iterators kind of functions which take functions as arguments. So obviously you don\'t need to use & because they are already considered arguments by default. It is their purpose.Now the last problem is that sometimes you have to call them in your code, because they are not always used with an iterator kind of function, or you might be coding an iterator yourself. For the little story, since ruby is object oriented, the main way to do it was to use the call method on the object. That way, you could keep the non-mandatory brackets behaviour consistent.Now somebody came up with a shortcut which basically looks like a method with no name.Again, this is a design choice. Now elixir is not object oriented and therefore call not use the first form for sure. I can\'t speak for Jos\xc3\xa9 but it looks like the second form was used in elixir because it still looks like a function call with an extra character. It\'s close enough to a function call.I did not think about all the pros and cons, but it looks like in both languages you could get away with just the brackets as long as you make brackets mandatory for anonymous functions. It seems like it is:Mandatory brackets VS Slightly different notationIn both cases you make an exception because you make both behave differently. Since there is a difference, you might as well make it obvious and go for the different notation. The mandatory brackets would look natural in most cases but very confusing when things don\'t go as planned.Here you go. Now this might not be the best explanation in the world because I simplified most of the details. Also most of it are design choices and I tried to give a reason for them without judging them. I love elixir, I love ruby, I like the function calls without brackets, but like you, I find the consequences quite misguiding once in a while. And in elixir, it is just this extra dot, whereas in ruby you have blocks on top of this. Blocks are amazing and I am surprised how much you can do with just blocks, but they only work when you need just one anonymous function which is the last argument. Then since you should be able to deal with other scenarios, here comes the whole method/lambda/proc/block confusion.Anyway... this is out of scope.I\'ve never understood why explanations of this are so complicated.It\'s really just an exceptionally small distinction combined with the realities of Ruby-style "function execution without parens".Compare:To:While both of these are just identifiers...Consider what that means when you see fun1 or fun2 in some other expression?  When evaluating that expression, do you call the referenced function or do you just reference a value out of memory?There\'s no good way to know at compile time.  Ruby has the luxury of introspecting the variable namespace to find out if a variable binding has shadowed a function at some point in time.  Elixir, being compiled, can\'t really do this.  That\'s what the dot-notation does, it tells Elixir that it should contain a function reference and that it should be called.And this is really hard.  Imagine that there wasn\'t a dot notation.  Consider this code:Given the above code, I think it\'s pretty clear why you have to give Elixir the hint.  Imagine if every variable de-reference had to check for a function?  Alternatively, imagine what heroics would be necessary to always infer that variable dereference was using a function?There\'s an excellent blog post about this behavior: linkIf a module contains this:You can\xe2\x80\x99t just cut and paste this into the shell and get the same\n  result.It\xe2\x80\x99s because there is a bug in Erlang. Modules in Erlang are sequences\n  of FORMS. The Erlang shell evaluates a sequence of\n  EXPRESSIONS. In Erlang FORMS are not EXPRESSIONS.The two are not the same. This bit of silliness has been Erlang\n  forever but we didn\xe2\x80\x99t notice it and we learned to live with it.In school I learned to call functions by writing f(10) not f.(10) -\n  this is \xe2\x80\x9creally\xe2\x80\x9d a function with a name like Shell.f(10) (it\xe2\x80\x99s a\n  function defined in the shell) The shell part is implicit so it should\n  just be called f(10).If you leave it like this expect to spend the next twenty years of\n  your life explaining why.Only the second kind of function seems to be a first-class object and can be passed as a parameter to other functions. A function defined in a module needs to be wrapped in a fn. There\'s some syntactic sugar which looks like otherfunction(myfunction(&1, &2)) in order to make that easy, but why is it necessary in the first place? Why can\'t we just do otherfunction(myfunction))? You can do otherfunction(&myfunction/2)Since elixir can execute functions without the brackets (like myfunction), using otherfunction(myfunction)) it will try to execute myfunction/0.So, you need to use the capture operator and specify the function, including arity, since you can have different functions with the same name. Thus, &myfunction/2.