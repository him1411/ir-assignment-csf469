Everyone is aware of Dijkstra\'s Letters to the editor: go to statement considered harmful (also here .html transcript and here .pdf) and there has been a formidable push since that time to eschew the goto statement whenever possible. While it\'s possible to use goto to produce unmaintainable, sprawling code, it nevertheless remains in modern programming languages. Even the advanced continuation control structure in Scheme can be described as a sophisticated goto.What circumstances warrant the use of goto? When is it best to avoid?As a followup question: C provides a pair of functions, setjmp and longjmp, that provide the ability to goto not just within the current stack frame but within any of the calling frames. Should these be considered as dangerous as goto? More dangerous?Dijkstra himself regretted that title, for which he was not responsible. At the end of EWD1308 (also here .pdf) he wrote:Finally a short story for the record.\n  In 1968, the Communications of the ACM\n  published a text of mine under the\n  title "The goto statement considered\n  harmful", which in later years would\n  be most frequently referenced,\n  regrettably, however, often by authors\n  who had seen no more of it than its\n  title, which became a cornerstone of\n  my fame by becoming a template: we\n  would see all sorts of articles under\n  the title "X considered harmful" for\n  almost any X, including one titled\n  "Dijkstra considered harmful". But\n  what had happened? I had submitted a\n  paper under the title "A case against\n  the goto statement", which, in order\n  to speed up its publication, the\n  editor had changed into a "letter to\n  the Editor", and in the process he had\n  given it a new title of his own\n  invention! The editor was Niklaus\n  Wirth.A well thought out classic paper about this topic, to be matched to that of Dijkstra, is Structured Programming with go to Statements, by Donald E. Knuth. Reading both helps to reestablish context and a non-dogmatic understanding of the subject. In this paper, Dijkstra\'s opinion on this case is reported and is even more strong:Donald E. Knuth: I believe that by presenting such a\n  view I am not in fact disagreeing\n  sharply with Dijkstra\'s ideas, since\n  he recently wrote the following:\n  "Please don\'t fall into the trap of\n  believing that I am terribly\n  dogmatical about [the go to\n  statement]. I have the uncomfortable\n  feeling that others are making a\n  religion out of it, as if the\n  conceptual problems of programming\n  could be solved by a single trick, by\n  a simple form of coding discipline!"The following statements are generalizations; while it is always possible to plead exception, it usually (in my experience and humble opinion) isn\'t worth the risks.Footnotes to the above:Regarding point 2, consider the following code:At the "do something" point in the code, we can state with high confidence that a is greater than b. (Yes, I\'m ignoring the possibility of untrapped integer overflow. Let\'s not bog down a simple example.)On the other hand, if the code had read this way:The multiplicity of ways to get to label 10 means that we have to work much harder to be confident about the relationships between a and b at that point. (In fact, in the general case it\'s undecideable!)Regarding point 4, the whole notion of "going someplace" in the code is just a metaphor. Nothing is really "going" anywhere inside the CPU except electrons and photons (for the waste heat). Sometimes we give up a metaphor for another, more useful, one. I recall encountering (a few decades ago!) a language wherewas implemented on a virtual machine by compiling action-1 and action-2 as out-of-line parameterless routines, then using a single two-argument VM opcode which used the boolean value of the condition to invoke one or the other. The concept was simply "choose what to invoke now" rather than "go here or go there". Again, just a change of metaphor.http://xkcd.com/292/A coworker of mine said the only reason to use a GOTO is if you programmed yourself so far into a corner that it is the only way out.  In other words, proper design ahead of time and you won\'t need to use a GOTO later.  I thought this comic illustrates that beautifully "I could restructure the program\'s flow, or use one little \'GOTO\' instead."  A GOTO is a weak way out when you have weak design.  Velociraptors prey on the weak.  Sometimes it is valid to use GOTO as an alternative to exception handling within a single function:COM code seems to fall into this pattern fairly often.I can only recall using a goto once.  I had a series of five nested counted loops and I needed to be able to break out of the entire structure from the inside early based on certain conditions:I could just have easily declared a boolean break variable and used it as part of the conditional for each loop, but in this instance I decided a GOTO was just as practical and just as readable.  No velociraptors attacked me.We already had this discussion and I stand by my point.Furthermore, I\'m fed up with people describing higher-level language structures as \xe2\x80\x9cgoto in disguise\xe2\x80\x9d because they clearly haven\'t got the point at all. For example:Even the advanced continuation control structure in Scheme can be described as a sophisticated goto.That is complete nonsense. Every control structure can be implemented in terms of goto but this observation is utterly trivial and useless. goto isn\'t considered harmful because of its positive effects but because of its negative consequences and these have been eliminated by structured programming.Similarly, saying \xe2\x80\x9cGOTO is a tool, and as all tools, it can be used and abused\xe2\x80\x9d is completely off the mark. No modern construction worker would use a rock and claim it \xe2\x80\x9cis a tool.\xe2\x80\x9d Rocks have been replaced by hammers. goto has been replaced by control structures. If the construction worker were stranded in the wild without a hammer, of course he would use a rock instead. If a programmer has to use an inferior programming language that doesn\'t have feature X, well, of course she may have to use goto instead. But if she uses it anywhere else instead of the appropriate language feature she clearly hasn\'t understood the language properly and uses it wrongly. It\'s really as simple as that.Goto is extremely low on my list of things to include in a program just for the sake of it. That doesn\'t mean it\'s unacceptable.Goto can be nice for state machines. A switch statement in a loop is (in order of typical importance): (a) not actually representative of the control flow, (b) ugly, (c) potentially inefficient depending on language and compiler. So you end up writing one function per state, and doing things like "return NEXT_STATE;" which even look like goto.Granted, it is difficult to code state machines in a way which make them easy to understand. However, none of that difficulty is to do with using goto, and none of it can be reduced by using alternative control structures. Unless your language has a \'state machine\' construct. Mine doesn\'t.On those rare occasions when your algorithm really is most comprehensible in terms of a path through a sequence of nodes (states) connected by a limited set of permissible transitions (gotos), rather than by any more specific control flow (loops, conditionals, whatnot), then that should be explicit in the code. And you ought to draw a pretty diagram.setjmp/longjmp can be nice for implementing exceptions or exception-like behaviour. While not universally praised, exceptions are generally considered a "valid" control structure.setjmp/longjmp are \'more dangerous\' than goto in the sense that they\'re harder to use correctly, never mind comprehensibly.There never has been, nor will there\n  ever be, any language in which it is\n  the least bit difficult to write bad\n  code. -- Donald Knuth.Taking goto out of C would not make it any easier to write good code in C. In fact, it would rather miss the point that C is supposed to be capable of acting as a glorified assembler language.Next it\'ll be "pointers considered harmful", then "duck typing considered harmful". Then who will be left to defend you when they come to take away your unsafe programming construct? Eh?In Linux: Using goto In Kernel Code on Kernel Trap, there\'s a discussion with Linus Torvalds and a "new guy" about the use of GOTOs in Linux code. There are some very good points there and Linus dressed in that usual arrogance :)Some passages:Linus: "No, you\'ve been brainwashed by\n  CS people who thought that Niklaus\n  Wirth actually knew what he was\n  talking about. He didn\'t. He doesn\'t\n  have a frigging clue."-Linus: "I think goto\'s are fine, and\n  they are often more readable than\n  large amounts of indentation."-Linus: "Of course, in stupid languages\n  like Pascal, where labels cannot be \n  descriptive, goto\'s can be bad."In C, goto only works within the scope of the current function, which tends to localise any potential bugs. setjmp and longjmp are far more dangerous, being non-local, complicated and implementation-dependent. In practice however, they\'re too obscure and uncommon to cause many problems.I believe that the danger of goto in C is greatly exaggerated. Remember that the original goto arguments took place back in the days of languages like old-fashioned BASIC, where beginners would write spaghetti code like this:Here Linus describes an appropriate use of goto: http://www.kernel.org/doc/Documentation/CodingStyle (chapter 7).Today, it\'s hard to see the big deal about the GOTO statement because the "structured programming" people mostly won the debate and today\'s languages have sufficient control flow structures to avoid GOTO.Count the number of gotos in a modern C program.  Now add the number of break, continue, and return statements.  Furthermore, add the number of times you use if, else, while, switch or case.  That\'s about how many GOTOs your program would have had if you were writing in FORTRAN or BASIC in 1968 when Dijkstra wrote his letter.Programming languages at the time were lacking in control flow.  For example, in the original Dartmouth BASIC:IF statements had no ELSE.  If you wanted one, you had to write:Even if your IF statement didn\'t need an ELSE, it was still limited to a single line, which usually consisted of a GOTO.There was no DO...LOOP statement.  For non-FOR loops, you had to end the loop with an explicit GOTO or IF...GOTO back to the beginning.There was no SELECT CASE.  You had to use ON...GOTO.So, you ended up with a lot of GOTOs in your program.  And you couldn\'t depend on the restriction of GOTOs to within a single subroutine (because GOSUB...RETURN was such a weak concept of subroutines), so these GOTOs could go anywhere.  Obviously, this made control flow hard to follow.This is where the anti-GOTO movement came from.Go To can provide a sort of stand-in for "real" exception handling in certain cases. Consider:Obviously this code was simplified to take up less space, so don\'t get too hung up on the details. But consider an alternative I\'ve seen all too many times in production code by coders going to absurd lengths to avoid using goto:Now functionally this code does the exact same thing. In fact, the code generated by the compiler is nearly identical. However, in the programmer\'s zeal to appease Nogoto (the dreaded god of academic rebuke), this programmer has completely broken the underlying idiom that the while loop represents, and did a real number on the readability of the code. This is not better.So, the moral of the story is, if you find yourself resorting to something really stupid in order to avoid using goto, then don\'t.Donald E. Knuth answered this question in the book "Literate Programming", 1992 CSLI. On p. 17 there is an essay "Structured Programming with goto Statements" (PDF). I think the article might have been published in other books as well.The article describes Dijkstra\'s suggestion and describes the circumstances where this is valid. But he also gives a number of counter examples (problems and algorithms) which cannot be easily reproduced using structured loops only.The article contains a complete description of the problem, the history, examples and counter examples.Attracted by Jay Ballou adding an answer, I\'ll add my \xc2\xa30.02.  If Bruno Ranschaert had not already done so, I\'d have mentioned Knuth\'s "Structured Programming with GOTO Statements" article.One thing that I\'ve not seen discussed is the sort of code that, while not exactly common, was taught in Fortran text books.  Things like the extended range of a DO loop and open-coded subroutines (remember, this would be Fortran II, or Fortran IV, or Fortran 66 - not Fortran 77 or 90).  There\'s at least a chance that the syntactic details are inexact, but the concepts should be accurate enough.  The snippets in each case are inside a single function.Note that the excellent but dated (and out of print) book \'The Elements of Programming Style, 2nd Edn\' by Kernighan & Plauger includes some real-life examples of abuse of GOTO from programming text books of its era (late-70s).  The material below is not from that book, however.One reason for such nonsense was the good old-fashioned punch-card.  You might notice that the labels (nicely out of sequence because that was canonical style!) are in column 1 (actually, they had to be in columns 1-5) and the code is in columns 7-72 (column 6 was the continuation marker column).  Columns 73-80 would be given a sequence number, and there were machines that would sort punch card decks into sequence number order.  If you had your program on sequenced cards and needed to add a few cards (lines) into the middle of a loop, you\'d have to repunch everything after those extra lines.  However, if you replaced one card with the GOTO stuff, you could avoid resequencing all the cards - you just tucked the new cards at the end of the routine with new sequence numbers.  Consider it to be the first attempt at \'green computing\' - a saving of punch cards (or, more specifically, a saving of retyping labour - and a saving of consequential rekeying errors).Oh, you might also note that I\'m cheating and not shouting - Fortran IV was written in all upper-case normally.The GOTO between labels 76 and 54 is a version of computed goto.  If the variable i has the value 1, goto the first label in the list (123); if it has the value 2, goto the second, and so on.  The fragment from 76 to the computed goto is the open-coded subroutine.  It was a piece of code executed rather like a subroutine, but written out in the body of a function.  (Fortran also had statement functions - which were embedded functions that fitted on a single line.)There were worse constructs than the computed goto - you could assign labels to variables and then use an assigned goto.  Googling assigned goto tells me it was deleted from Fortran 95.  Chalk one up for the structured programming revolution which could fairly be said to have started in public with Dijkstra\'s "GOTO Considered Harmful" letter or article.Without some knowledge of the sorts of things that were done in Fortran (and in other languages, most of which have rightly fallen by the wayside), it is hard for us newcomers to understand the scope of the problem which Dijkstra was dealing with.  Heck, I didn\'t start programming until ten years after that letter was published (but I did have the misfortune to program in Fortran IV for a while).Goto considered helpful.I started programming in 1975.  To 1970s-era programmers, the words "goto considered harmful" said more or less that new programming languages with modern control structures were worth trying.  We did try the new languages.  We quickly converted.  We never went back.We never went back, but, if you are younger, then you have never been there in the first place.Now, a background in ancient programming languages may not be very useful except as an indicator of the programmer\'s age.  Notwithstanding, younger programmers lack this background, so they no longer understand the message the slogan "goto considered harmful" conveyed to its intended audience at the time it was introduced.Slogans one does not understand are not very illuminating.  It is probably best to forget such slogans.  Such slogans do not help.This particular slogan however, "Goto considered harmful," has taken on an undead life of its own.Can goto not be abused?  Answer: sure, but so what?  Practically every programming element can be abused.  The humble bool for example is abused more often than some of us would like to believe.By contrast, I cannot remember meeting a single, actual instance of goto abuse since 1990.The biggest problem with goto is probably not technical but social.  Programmers who do not know very much sometimes seem to feel that deprecating goto makes them sound smart.  You might have to satisfy such programmers from time to time.  Such is life.The worst thing about goto today is that it is not used enough.There is no such things as GOTO considered harmful.GOTO is a tool, and as all tools, it can be used and abused.There are, however, many tools in the programming world that have a tendency to be abused more than being used, and GOTO is one of them. the WITH statement of Delphi is another.Personally I don\'t use either in typical code, but I\'ve had the odd usage of both GOTO and WITH that were warranted, and an alternative solution would\'ve contained more code.The best solution would be for the compiler to just warn you that the keyword was tainted, and you\'d have to stuff a couple of pragma directives around the statement to get rid of the warnings.It\'s like telling your kids to not run with scissors. Scissors are not bad, but some usage of them are perhaps not the best way to keep your health.Since I began doing a few things in the linux kernel, gotos don\'t bother me so much as they once did.  At first I was sort of horrified to see they (kernel guys) added gotos into my code.  I\'ve since become accustomed to the use of gotos, in some limited contexts, and will now occasionally use them myself.  Typically, it\'s a goto that jumps to the end of a function to do some kind of cleanup and bail out, rather than duplicating that same cleanup and bailout in several places in the function.  And typically, it\'s not something large enough to hand off to another function -- e.g. freeing some locally (k)malloc\'ed variables is a typical case.I\'ve written code that used setjmp/longjmp only once.  It was in a MIDI drum sequencer program.  Playback happened in a separate process from all user interaction, and the playback process used shared memory with the UI process to get the limited info it needed to do the playback.  When the user wanted to stop playback, the playback process just did a longjmp "back to the beginning" to start over, rather than some complicated unwinding of wherever it happened to be executing when the user wanted it to stop.  It worked great, was simple, and I never had any problems or bugs related to it in that instance.setjmp/longjmp have their place -- but that place is one you\'ll not likely visit but once in a very long while.Edit:  I just looked at the code.  It was actually siglongjmp() that I used, not longjmp (not that it\'s a big deal, but I had forgotten that siglongjmp even existed.)It never was, as long as you were able to think for yourself.If you\'re writing a VM in C, it turns out that using (gcc\'s) computed gotos like this:works much faster than the conventional switch inside a loop.Goto is both a high-level and a low-level control expression, and as a result it just doesn\'t have a appropriate design pattern suitable for most problems.It\'s low-level in the sense that a goto is a primitive operation that implements something higher like while or foreach or something.It\'s high-level in the sense that when used in certain ways it takes code that executes in a clear sequence, in an uninterrupted fashion, except for structured loops, and it changes it into pieces of logic that are, with enough gotos, a grab-bag of logic being dynamically reassembled.So, there is a prosaic and an evil side to goto.The prosaic side is that an upward pointing goto can implement a perfectly reasonable loop and a downward-pointing goto can do a perfectly reasonable break or return. Of course, an actual while, break, or return would be a lot more readable, as the poor human wouldn\'t have to simulate the effect of the goto in order to get the big picture. So, a bad idea in general.The evil side involves a routine not using goto for while, break, or return, but using it for what\'s called spaghetti logic. In this case the goto-happy developer is constructing pieces of code out of a maze of goto\'s, and the only way to understand it is to simulate it mentally as a whole, a terribly tiring task when there are many goto\'s. I mean, imagine the trouble of evaluating code where the else is not precisely an inverse of the if, where nested ifs might allow in some things that were rejected by the outer if, etc, etc.Finally, to really cover the subject, we should note that essentially all early languages except Algol initially made only single statements subject to their versions of if-then-else. So, the only way to do a conditional block was to goto around it using an inverse conditional. Insane, I know, but I\'ve read some old specs. Remember that the first computers were programmed in binary machine code so I suppose any kind of an HLL was a lifesaver; I guess they weren\'t too picky about exactly what HLL features they got.Having said all that I used to stick one goto into every program I wrote "just to annoy the purists".Denying the use of the GOTO statement to programmers is like telling a carpenter not to use a hammer as it Might damage the wall while he is hammering in a nail. A real programmer Knows How and When to use a GOTO. I\xe2\x80\x99ve followed behind some of these so-called \xe2\x80\x98Structured Programs\xe2\x80\x99 I\xe2\x80\x99ve see such Horrid code just to avoid using a GOTO, that I could shoot the programmer. Ok, In defense of the other side, I\xe2\x80\x99ve seen some real spaghetti code too and again, those programmers should be shot too.Here is just one small example of code I\xe2\x80\x99ve found.-----------------------OR----------------------The original paper should be thought of as "Unconditional GOTO Considered Harmful". It was in particular advocating a form of programming based on conditional (if) and iterative (while) constructs, rather than the test-and-jump common to early code. goto is still useful in some languages or circumstances, where no appropriate control structure exists.About the only place I agree Goto could be used is when you need to deal with errors, and each particular point an error occurs requires special handling.For instance, if you\'re grabbing resources and using semaphores or mutexes, you have to grab them in order and you should always release them in the opposite manner.Some code requires a very odd pattern of grabbing these resources, and you can\'t just write an easily maintained and understood control structure to correctly handle both the grabbing and releasing of these resources to avoid deadlock.It\'s always possible to do it right without goto, but in this case and a few others Goto is actually the better solution primarily for readability and maintainability.-Adam"In this link http://kerneltrap.org/node/553/2131"Ironically, eliminating the goto introduced a bug: the spinlock call was omitted.Until C and C++ (amongst other culprits) have labelled breaks and continues, goto will continue to have a role.One modern GOTO usage is by the C# compiler to create state machines for enumerators defined by yield return.GOTO is something that should be used by compilers and not programmers.I avoid it since a coworker/manager will undoubtedly question its use either in a code review or when they stumble across it. While I think it has uses (the error handling case for example) - you\'ll run afoul of some other developer who will have some type of problem with it. It\xe2\x80\x99s not worth it.If GOTO itself were evil, compilers would be evil, because they generate JMPs. If jumping into a block of code, especially following a pointer, were inherently evil, the RETurn instruction would be evil. Rather, the evil is in the potential for abuse.At times I have had to write apps that had to keep track of a number of objects where each object had to follow an intricate sequence of states in response to events, but the whole thing was definitely single-thread. A typical sequence of states, if represented in pseudo-code would be:I\'m sure this is not new, but the way I handled it in C(++) was to define some macros:Then (assuming state is initially 0) the structured state machine above turns into the structured code:With a variation on this, there can be CALL and RETURN, so some state machines can act like subroutines of other state machines.Is it unusual? Yes. Does it take some learning on the part of the maintainer? Yes. Does that learning pay off? I think so. Could it be done without GOTOs that jump into blocks? Nope.I actually found myself forced to use a goto, because I literally couldn\'t think of a better (faster) way to write this code:I had a complex object, and I needed to do some operation on it. If the object was in one state, then I could do a quick version of the operation, otherwise I had to do a slow version of the operation.  The thing was that in some cases, in the middle of the slow operation, it was possible to realise that this could have been done with the fast operation.This was in a speed critical piece of realtime UI code, so I honestly think that a GOTO was justified here.HugoAlmost all situations where a goto can be used, you can do the same using other constructs.  Goto is used by the compiler anyway.I personally never use it explicitly, don\'t ever need to.One thing I\'ve not seen from any of the answers here is that a \'goto\' solution is often more efficient than one of the structured programming solutions often mentioned.Consider the many-nested-loops case, where using \'goto\' instead of a bunch of if(breakVariable) sections is obviously more efficient.  The solution "Put your loops in a function and use return" is often totally unreasonable.  In the likely case that the loops are using local variables, you now have to pass them all through function parameters, potentially handling loads of extra headaches that arise from that.Now consider the cleanup case, which I\'ve used myself quite often, and is so common as to have presumably been responsible for the try{} catch {} structure not available in many languages.  The number of checks and extra variables that are required to accomplish the same thing are far worse than the one or two instructions to make the jump, and again, the additional function solution is not a solution at all.  You can\'t tell me that\'s more manageable or more readable.Now code space, stack usage, and execution time may not matter enough in many situations to many programmers, but when you\'re in an embedded environment with only 2KB of code space to work with, 50 bytes of extra instructions to avoid one clearly defined \'goto\' is just laughable, and this is not as rare a situation as many high-level programmers believe.The statement that \'goto is harmful\' was very helpful in moving towards structured programming, even if it was always an over-generalization.  At this point, we\'ve all heard it enough to be wary of using it (as we should).  When it\'s obviously the right tool for the job, we don\'t need to be scared of it.You can use it for breaking from a deeply nested loop, but most of the time your code can be refactored to be cleaner without deeply nested loops. 