I want to use a track-bar to change a form\'s opacity.This is my code:When I build the application, it gives the following error:Cannot implicitly convert type \'decimal\' to \'double\'.I tried using trans and double but then the control doesn\'t work. This code worked fine in a past VB.NET project. An explicit cast to double isn\'t necessary.Identifying the constant as 5000.0 (or as 5000d) is sufficient:A more generic answer for the generic question "Decimal vs Double?": Decimal for monetary calculations to preserve the precision, Double for scientific calculations that do not get affected by small differences. Since Double is a type which is native to the CPU (internal representation is stored in base 2), calculations made with Double perform better then Decimal (which is represented in base 10 internally).Your code worked fine in VB.NET because it implicitly does any casts, while C# has both implicit and explicit ones.In C# the conversion from decimal to double is explicit as you lose accuracy. For instance 1.1 can\'t be accurately expressed as a double, but can as a decimal (see "Floating point numbers - more inaccurate than you think" for the reason why).In VB the conversion was added for you by the compiler:That (double) has to be explicitly stated in C#, but can be implied by VB\'s more \'forgiving\' compiler.Why are you dividing by 5000? Just set the TrackBar\'s Minimum and Maximum values between 0 and 100 and then divide the Value by 100 for the Opacity percentage. The minimum 20 example below prevents the form from becoming completely invisible:You have two problems.  First, Opacity requires a double, not a decimal value.  The compiler is telling you that while there is a conversion between decimal and double, it is an explicit conversion that you need to specify in order for it to work. The second is that TrackBar.Value is an integer value and dividing an int by an int results in an int no matter what type of variable you assign it to. In this case there is an implicit cast from int to decimal or double - because there is no loss of precision when you do the cast - so the compiler doesn\'t complain, but the value you get is always 0, presumably, since trackBar.Value is always less than 5000.  The solution is to change your code to use double (the native type for Opacity) and do floating point arithmetic by explicitly making the constant a double - which will have the effect of promoting the arithmetic - or casting trackBar.Value to double, which will do the same thing - or both.  Oh, and you don\'t need the intermediate variable unless it used elsewhere. My guess is the compiler would optimize it away, anyway.In my opinion, it is desirable to be as explicit as possible. This adds clarity to the code and aids your fellow programmers who may eventually read it.In addition to (or instead of) appending a .0 to the number, you can use decimal.ToDouble().  Here are some examples:It sounds like this.Opacity is a double value, and the compiler doesn\'t like you trying to cram a decimal value into it.You should use 5000.0 instead of 5000.The Opacity property is of double type:or simply:or:Notice that I am using 5000.0 (or 5000d) to force a double division because trackBar1.Value is an integer and it would perform an integer division and the result would be an integer.Assuming you are using WinForms, Form.Opacity is of type double, so you should use:Unless you need the value elsewhere, it\'s simpler to write:The reason the control doesn\'t work when you changed your code to simply be a double was because you had:which interpreted the 5000 as an integer, so your trans value was always zero. By explicitly making the numeric a floating point value by adding the .0 the compiler can now interpret it as a double and perform the proper calculation.The best solution is:Since Opacity is a double value, I would just use a double from the outset and not cast at all, but be sure to use a double when dividing so you don\'t loose any precision