Using the newer ASP.NET Web API, in Chrome I am seeing XML - how can I change it to request JSON so I can view it in the browser? I do believe it is just part of the request headers, am I correct in that?I just add the following in App_Start / WebApiConfig.cs class in my MVC Web API project.That makes sure you get json on most queries, but you can get xml when you send text/xml.If you need to have the response Content-Type as application/json please check Todd\'s answer below.NameSpace is using System.Net.Http.Headers;If you do this in the WebApiConfig you will get JSON by default, but it will still allow you to return XML if you pass text/xml as the request Accept headerIf you are not using the MVC project type and therefore did not have this class to begin with, see this answer for details on how to incorporate it.I like Felipe Leusin\'s approach best - make sure browsers get JSON without compromising content negotiation from clients that actually want XML. The only missing piece for me was that the response headers still contained content-type: text/html. Why was that a problem? Because I use the JSON Formatter Chrome extension, which inspects content-type, and I don\'t get the pretty formatting I\'m used to. I fixed that with a simple custom formatter that accepts text/html requests and returns application/json responses:Register like so:MVC4 Quick Tip #3\xe2\x80\x93Removing the XML Formatter from ASP.Net Web APIIn Global.asax add the line:like so:Using RequestHeaderMapping works even better, because it also sets the Content-Type = application/json in the response header, which allows Firefox (with JSONView add-on) to format the response as JSON.In the WebApiConfig.cs, add to the end of the Register function:Source.In the Global.asax I am using the code below. My URI to get JSON is http://www.digantakumar.com/api/values?json=trueHave a look at content negotiation in the WebAPI. These (Part 1 & Part 2) wonderfully detailed and thorough blog posts explain how it works. In short, you are right, and just need to set the Accept or Content-Type request headers. Given your Action isn\'t coded to return a specific format, you can set Accept: application/json. As the question is Chrome-specific, you can get the Postman extension which allows you to set the request content type.One quick option is to use the MediaTypeMapping specialization. Here is an example of using  QueryStringMapping in the Application_Start event:Now whenever the url contains the querystring ?a=b in this case, Json response will be shown in the browser.This code makes json my default and allows me to use the XML format as well. I\'ll just append the xml=true.Thanks everyone!Don\'t use your browser to test your API.Instead, try to use an HTTP client that allows you to specify your request, such as CURL, or even Fiddler.The problem with this issue is in the client, not in the API. The web API behaves correctly, according to the browser\'s request.I used a global action filter to remove Accept: application/xml when the User-Agent header contains "Chrome":Seems to work.I found the Chrome app "Advanced REST Client" excellent to work with REST services.  You can set the Content-Type to application/json among other things: \nAdvanced REST clientMost of the above answers makes perfect sense.\nSince you are seeing data being formatted in XML format ,that means XML formatter is applied,SO you can see JSON format just by removing the XMLFormatter from the HttpConfiguration parameter likesince JSON is the default formatHere is a solution similar to jayson.centeno\'s and other answers, but using the built-in extension from System.Net.Http.Formatting.The solution was primarily geared toward supporting $format for OData in the early releases of WebApi, but it also applies to the non-OData implementation, and returns the \nContent-Type: application/json; charset=utf-8 header in the response.It allows you to tack &$format=json or &$format=xml to the end of your uri when testing with a browser. It does not interfere with other expected behavior when using a non-browser client where you can set your own headers.You just change the App_Start/WebApiConfig.cs like this:as per latest version of ASP.net WebApi 2,under WebApiConfig.cs , this will work It\'s unclear to me why there is all of this complexity in the answer.  Sure there are lots of ways you can do this, with QueryStrings, headers and options... but what I believe to be the best practice is simple.  You request a plain URL (ex: http://yourstartup.com/api/cars) and in return you get JSON. You get JSON with the proper response header:In looking for an answer to this very same question, I found this thread, and had to keep going because this accepted answer doesn\'t work exactly.  I did find an answer which I feel is just too simple not to be the best one:Set the default WebAPI formatterI\'ll add my tip here as well.I do have a question of where the defaults (at least the ones I am seeing) come from.  Are they .NET defaults, or perhaps created somewhere else (by someone else on my project).  Anways, hope this helps.Some time has passed since this question was asked (and answered) but another option is to override the Accept header on the server during request processing using a MessageHandler as below:Where someOtherCondition can be anything including browser type, etc. This would be for conditional cases where only sometimes do we want to override the default content negotiation. Otherwise as per other answers, you would simply remove an unnecessary formatter from the configuration.You\'ll need to register it of course. You can either do this globally:or on a route by route basis:And since this is a message handler it will run on both the request and response ends of the pipeline much like an HttpModule. So you could easily acknowledge the override with a custom header:Here is the easiest way that I have used in my applications. Add given below 3 lines of code in App_Start\\\\WebApiConfig.cs in Register functionAsp.net web API will automatically serialize your returning object to JSON and as the application/json is added in the header so the browser or the receiver will understand that you are returning JSON result.Returning the correct format is done by the media-type formatter.\nAs others mentioned, you can do this in the WebApiConfig class:For more, check:In case your actions are returning XML (which is the case by default) and you need just a specific method to return JSON, you can then use an ActionFilterAttribute and apply it to that specific action.Filter attribute:Applying to action:Note that you can omit the word Attribute on the action decoration and use just [JsonOutput] instead of [JsonOutputAttribute].From MSDN Building a Single Page Application with ASP.NET and AngularJS (about 41 mins in).It should be current, I tried it and it worked.WebApiConfig is the place where you can configure whether you want to output in json or xml. by default it is xml. in the register function we can use HttpConfiguration Formatters to format the output .\nSystem.Net.Http.Headers => MediaTypeHeaderValue("text/html") is require to get the output in the json format.\nJust add those two line of code on your WebApiConfig class    easiest way:Appending $format=json to the end of an MVC4+ webapi function does now return the result as json, and $format=xml returns XML.\nThis is fine in Chrome, as it displays JSON data on-screen, but in IE you will be prompted to download the resulting json data.