I have a service, say:And I would like to use foo to control a list that is rendered in HTML:In order for the controller to detect when aService.foo is updated I have cobbled together this pattern where I add aService to the controller\'s $scope and then use $scope.$watch():This feels long-handed, and I\'ve been repeating it in every controller that uses the service\'s variables.  Is there a better way to accomplish watching shared variables?You can always use the good old observer pattern if you want to avoid the tyranny and overhead of $watch.In the service:And in the controller:In a scenario like this, where multiple/unkown objects might be interested in changes, use $rootScope.$broadcast from the item being changed.Rather than creating your own registry of listeners (which have to be cleaned up on various $destroys), you should be able to $broadcast from the service in question.  You must still code the $on handlers in each listener but the pattern is decoupled from multiple calls to $digest and thus avoids the risk of long-running watchers.  This way, also, listeners can come and go from the DOM and/or different child scopes without the service changing its behavior.** update: examples **Broadcasts would make the most sense in "global" services that could impact countless other things in your app.  A good example is a User service where there are a number of events that could take place such as login, logout, update, idle, etc.  I believe this is where broadcasts make the most sense because any scope can listen for an event, without even injecting the service, and it doesn\'t need to evaluate any expressions or cache results to inspect for changes.  It just fires and forgets (so make sure it\'s a fire-and-forget notification, not something that requires action)The service above would broadcast a message to every scope when the save() function completed and the data was valid.  Alternatively, if it\'s a $resource or an ajax submission, move the broadcast call into the callback so it fires when the server has responded.  Broadcasts suit that pattern particularly well because every listener just waits for the event without the need to inspect the scope on every single $digest. The listener would look like:One of the benefits of this is the elimination of multiple watches. If you were combining fields or deriving values like the example above, you\'d have to watch both the firstname and lastname properties. Watching the getUser() function would only work if the user object was replaced on updates, it would not fire if the user object merely had its properties updated.  In which case you\'d have to do a deep watch and that is more intensive.  $broadcast sends the message from the scope it\'s called on down into any child scopes.  So calling it from $rootScope will fire on every scope.  If you were to $broadcast from your controller\'s scope, for example, it would fire only in the scopes that inherit from your controller scope.  $emit goes the opposite direction and behaves similarly to a DOM event in that it bubbles up the scope chain.Keep in mind that there are scenarios where $broadcast makes a lot of sense, and there are scenarios where $watch is a better option - especially if in an isolate scope with a very specific watch expression.I\'m using similar approach as @dtheodot but using angular promise instead of passing callbacksThen wherever just use myService.setFoo(foo) method to update foo on service. In your controller you can use it as:First two arguments of then are success and error callbacks, third one is notify callback.Reference for $q.Without watches or observer callbacks (http://jsfiddle.net/zymotik/853wvv7s/):JavaScript:HTMLThis JavaScript works as we are passing an object back from the service rather than a value. When a JavaScript object is returned from a service, Angular adds watches to all of its properties.Also note that I am using \'var self = this\' as I need to keep a reference to the original object when the $timeout executes, otherwise \'this\' will refer to the window object.As far as I can tell, you dont have to do something as elaborate as that. You have already assigned foo from the service to your scope and since foo is an array ( and in turn an object it is assigned by reference! ). So, all that you need to do is something like this :If some, other variable in this same Ctrl is dependant on foo changing then yes, you would need a watch to observe foo and make changes to that variable. But as long as it is a simple reference watching is unnecessary. Hope this helps. I stumbled upon this question looking for something similar, but I think it deserves a thorough explanation of what\'s going on, as well as my solution.When an angular expression such as the one you used is present in the HTML, Angular automatically sets up a $watch for $scope.foo, and will update the HTML whenever $scope.foo changes.The unsaid issue here is that one of two things are affecting aService.foo  such that the changes are undetected. These two possibilities are:Considering the first possibility, assuming a $digest is being applied, if aService.foo was always the same array, the automatically set $watch would detect the changes, as shown in the code snippet below.As you can see, the ng-repeat supposedly attached to aService.foo does not update when aService.foo changes, but the ng-repeat attached to aService2.foo does. This is because our reference to aService.foo is outdated, but our reference to aService2.foo is not. We created a reference to the initial array with $scope.foo = aService.foo;, which was then discarded by the service on it\'s next update, meaning $scope.foo no longer referenced the array we wanted anymore.However, while there are several ways to make sure the initial reference is kept in tact, sometimes it may be necessary to change the object or array. Or what if the service property references a primitive like a String or Number? In those cases, we cannot simply rely on a reference. So what can we do?Several of the answers given previously already give some solutions to that problem. However, I am personally in favor of using the simple method suggested by thetallweeks in the comments:just reference aService.foo in the html markupMeaning, just do this:HTML:JS:That way, the $watch will resolve aService.foo on each $digest, which will get the correctly updated value.This is kind of what you were trying to do with your workaround, but in a much less round about way. You added an unnecessary $watch in the controller which explicitly puts foo on the $scope whenever it changes. You don\'t need that extra $watch when you attach aService instead of aService.foo to the $scope, and bind explicitly to aService.foo in the markup.Now that\'s all well and good assuming a $digest cycle is being applied. In my examples above, I used Angular\'s $interval service to update the arrays, which automatically kicks off a $digest loop after each update. But what if the service variables (for whatever reason) aren\'t getting updated inside the "Angular world". In other words, we dont have a $digest cycle being activated automatically whenever the service property changes?Many of the solutions here will solve this issue, but I agree with itcouldevenbeaboat:The reason why we\'re using a framework like Angular is to not cook up our own observer patternsTherefore, I would prefer to continue to use the aService.foo reference in the HTML markup as shown in the second example above, and not have to register an additional callback within the Controller.I was surprised no one has yet suggested the use of a setter and getter. This capability was introduced in ECMAScript5, and has thus been around for years now. Of course, that means if, for whatever reason, you need to support really old browsers, then this method will not work, but I feel like getters and setters are vastly underused in JavaScript. In this particular case, they could be quite useful:Here I added a \'private\' variable in the service function: realFoo. This get\'s updated and retrieved using the get foo() and set foo() functions respectively on the service object.Note the use of $rootScope.$apply() in the set function. This ensures that Angular will be aware of any changes to service.foo. If you get \'inprog\' errors see this useful reference page, or if you use Angular >= 1.3 you can just use $rootScope.$applyAsync().Also be wary of this if aService.foo is being updated very frequently, since that could significantly impact performance. If performance would be an issue, you could set up an observer pattern similar to the other answers here using the setter.You can insert the service in $rootScope and watch:In your controller:Other option is to use a external library like: https://github.com/melanke/Watch.JSWorks with: IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Node.JS , Rhino 1.7+You can observe the changes of one, many or all object attributes.Example:You can watch the changes within the factory itself and then broadcast a changeThen in your controller:In this manner you put all the related factory code within its description then you can only rely on the broadcast from outside ==UPDATED==Very simple now in $watch.Pen here.HTML:JavaScript:Building on dtheodor\'s answer you could use something similar to the below to ensure that you don\'t forget to unregister the callback... Some may object to passing the $scope to a service though.Array.remove is an extension method which looks like this:Here\'s my generic approach.In Your Controllerwhile facing a very similar issue I watched a function in scope and had the function return the service variable. I have created a js fiddle. you can find the code below.I came to this question but it turned out my problem was that I was using setInterval when I should have been using the angular $interval provider.  This is also the case for setTimeout (use $timeout instead).  I know it\'s not the answer to the OP\'s question, but it might help some, as it helped me.I have found a really great solution on the other thread with a similar problem but totally different approach. Source: AngularJS : $watch within directive is not working when $rootScope value is changedBasically the solution there tells NOT TO use $watch as it is very heavy solution. Instead they propose to use $emit and $on.My problem was to watch a variable in my service and react in directive. And with the above method it very easy!My module/service example:So basically I watch my user  - whenever it is set to new value I $emit a user:change status.Now in my case, in the directive I used:Now in the directive I listen on the $rootScope and on the given change - I react respectively. Very easy and elegant!For those like me just looking for a simple solution, this does almost exactly what you expect from using normal $watch in controllers.\nThe only difference is, that it evaluates the string in it\'s javascript context and not on a specific scope. You\'ll have to inject $rootScope into your service, although it is only used to hook into the digest cycles properly.// service: (nothing special here)// ctrl:A wee bit ugly, but I\'ve added registration of scope variables to my service for a toggle:And then in the controller:I\'ve seen some terrible observer patterns here that cause memory leaks on large applications.I might be a little late but it\'s as simple as this.The watch function watches for reference changes (primitive types) if you want to watch something like array push simply use:someArray.push(someObj); someArray = someArray.splice(0);This will update the reference and update the watch from anywhere. Including a services getter method.\nAnything that\'s a primitive will be updated automatically.I have written two simple utility services that help me track service properties changes.If you want to skip the long explanation, you can go strait to jsfiddle This service is used in the controller in the following way: \nSuppose you have a service "testService" with the properties \'prop1\', \'prop2\', \'prop3\'. You want to watch and assign to scope \'prop1\' and \'prop2\'. With the watch service it will look like that: I would trigger it in the end of my async code to trigger the $digest loop.\nLike that: So, all of that together will look like that (you can run it or open fiddle):Have a look at this plunker:: this is the simplest example i could think ofhttp://jsfiddle.net/HEdJF/I am late to the part but I found a nicer way to do this than the answer posted above. Instead of assigning a variable to hold the value of the service variable, I created a function attached to the scope, that returns the service variable.controllerI think this will do what you want. My controller keeps checking the value of my service with this implementation. Honestly, this is much simpler than the selected answer.