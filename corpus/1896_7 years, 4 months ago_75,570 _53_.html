I\'m a bit confused about how Java generics handle inheritance / polymorphism.Assume the following hierarchy -Animal (Parent)Dog - Cat (Children)So suppose I have a method doSomething(List<Animal> animals). By all the rules of inheritance and polymorphism, I would assume that a List<Dog> is a List<Animal> and a List<Cat> is a List<Animal> - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subset of Animal by saying doSomething(List<? extends Animal> animals). I understand that this is Java\'s behavior. My question is why? Why is polymorphism generally implicit, but when it comes to generics it must be specified?No, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.Suddenly you have a very confused cat.Now, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. You can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. The reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.What you are looking for is called covariant type parameters.  The problem is that they are not type-safe in the general case, specifically for mutable lists.  Suppose you have a List<Dog>, and it is allowed to function as a List<Animal>.  What happens when you try to add a Cat to this List<Animal> which is really a List<Dog>?  Automatically allowing type parameters to be covariant therefore breaks the type system.It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the ? extends Foo in method declarations, but that does add additional complexity.The reason a List<Dog> is not a List<Animal>, is that, for example, you can insert a Cat into a List<Animal>, but not into a List<Dog>... you can use wildcards to make generics more extensible where possible; for example, reading from  a List<Dog> is the similar to reading from a List<Animal> -- but not writing.The Generics in the Java Language and the Section on Generics from the Java Tutorials have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.I would say the whole point of Generics is that it doesn\'t allow that. Consider the situation with arrays, which do allow that type of covariance:That code compiles fine, but throws a runtime error (java.lang.ArrayStoreException: java.lang.Boolean in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.Now there are times where you need to be more flexible and that is what the ? super Class and ? extends Class are for. The former is when you need to insert into a type Collection (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.A point I think should be added to what other answers mention is that whileList<Dog> isn\'t-a List<Animal> in Javait is also true thatA list of dogs is-a list of animals in English (well, under a reasonable interpretation)The way the OP\'s intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.More generally, OP\'s intuition lends itself towards a language in which operations on objects can change their type, or rather, an object\'s type(s) is a (dynamic) function of its value.The basis logic for such behavior is that Generics follow a mechanism of type erasure. So at run time you have no way if identifying the type of collection unlike arrays where there is no such erasure process. So coming back to your question...So suppose there is a method as given below:Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....The answers given here didn\'t fully convince me. So instead, I make another example.sounds fine, doesn\'t it? But you can only pass Consumers and Suppliers for Animals. If you have a Mammal consumer, but a Duck supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.Instead of the above, we have to define relationships between the types we use.E. g.,makes sure that we can only use a supplier which provides us the right type of object for the consumer.OTOH, we could as well dowhere we go the other way: we define the type of the Supplier and restrict that it can be put into the Consumer.We even can dowhere, having the intuitive relations Life -> Animal -> Mammal -> Dog, Cat etc., we could even put a Mammal into a Life consumer, but not a String into a Life consumer.Actually you can use an interface to achieve what you want.}you can then use the collections usingIf you are sure that the list items are subclasses of that given super type you can cast the list using this approach:This is usefull when you want to pass the list in a constructor or iterate over itThe answer https://stackoverflow.com/a/2745301/4350148 as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note, is that for Collections(Lists,Sets, etc) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.  In most cases we can use Collection<? extends T> rather then Collection<T> and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It  is up for debate as to whether that is always the  best thing to do.  I am  presenting here a class DownCastCollection that can take convert a Collection<? extends T> to a Collection<T> (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use Collection<? extends Object> in this case, but I am keeping it simple to illustrate using DownCastCollection.Now the class:}Lets take the example from JavaSE tutorial So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:So Java "architects" had 2 options which address this problem:do not consider that a subtype is implicitly it\'s supertype, and give a compile error, like it happens nowconsider the subtype to be it\'s supertype and restrict at compile the "add" method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).For obvious reasons, that chose the first way. I have same problem. But generic type support <? extends Y> to fix this problem:Collection<A> aCollection= getAFromDB();\nAUtil.findMetConidition(aCollection);Class:Method declaration: