Is there any way to have multi-line plain-text, constant literals in C++, \xc3\xa0 la Perl? Maybe some parsing trick with #includeing a file? I can\'t think of one, but boy, that would be nice. I know it\'ll be in C++0x.Well ... Sort of. The easiest is to just use the fact that adjacent string literals are concatenated by the compiler:The indentation doesn\'t matter, since it\'s not inside the quotes.You can also do this, as long as you take care to escape the embedded newline. Failure to do so, like my first answer did, will not compile:Again, note those backslashes at the end of each line, they must be immediately before the line ends, they are escaping the newline in the source, so that everything acts as if the newline wasn\'t there. You don\'t get newlines in the string at the locations where you had backslashes. With this form, you obviously can\'t indent the text since the indentation would then become part of the string, garbling it with random spaces.In C++11 you have raw string literals.  Sort of like here-text in shells and script languages like Python and Perl and Ruby.All the spaces and indentation and the newlines in the string are preserved.These can also be utf-8|16|32 or wchar_t (with the usual prefixes).I should point out that the escape sequence, V0G0N, is not actually needed here.  Its presence would allow putting )" inside the string.  In other words, I could have put(note extra quotes) and the string above would still be correct.  Otherwise I could just as well have usedThe parens just inside the quotes are still needed.#define MULTILINE(...) #__VA_ARGS__\nConsumes everything between the parentheses.\nReplaces any number of consecutive whitespace characters by a single space.A probably convenient way to enter multi-line strings is by using macro\'s. This only works if quotes and parentheses are balanced and it does not contain \'top level\' comma\'s:Compiled with gcc 4.6 or g++ 4.6, this produces: [[Using this trick(,) you don\'t need to use quotes. Though newlines and multiple white spaces will be replaced by a single whitespace.]]Note that the , cannot be in the string, unless it is contained within parenthesis or quotes. Single quotes is possible, but creates compiler warnings.Edit: As mentioned in the comments, #define MULTI_LINE_STRING(...) #__VA_ARGS__ allows the use of ,.You can just do this:Since an ounce of experience is worth a ton of theory, I tried a little test program for MULTILINE:Compile this fragment with cpp -P -std=c++11 filename to reproduce.The trick behind #__VA_ARGS__ is that __VA_ARGS__ does not process the comma separator. So you can pass it to the stringizing operator. Leading and trailing spaces are trimmed, and spaces (including newlines) between words are compressed to a single space then. Parentheses need to be balanced. I think these shortcomings explain why the designers of C++11, despite #__VA_ARGS__, saw the need for raw string literals.Just to elucidate a bit on @emsr\'s comment in @unwind\'s answer, if one is not fortunate enough to have a C++11 compiler (say GCC 4.2.1), and one wants to embed the newlines in the string (either char * or class string), one can write something like this:Very obvious, true, but @emsr\'s short comment didn\'t jump out at me when I read this the first time, so I had to discover this for myself.  Hopefully, I\'ve saved someone else a few minutes.