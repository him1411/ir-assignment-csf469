Is there an easy way to determine if a point is inside a triangle? It\'s 2D, not 3D.In general, the simplest (and quite optimal) algorithm is checking on which side of the half-plane created by the edges the point is.Here\'s some high quality info in this topic on GameDev, including performance issues.And here\'s some code to get you started:Solve the following equation system:The point p is inside the triangle if 0 <= s <= 1 and 0 <= t <= 1 and s + t <= 1.s,t and 1 - s - t are called the barycentric coordinates of the point p.I agree with Andreas Brinck, barycentric coordinates are very convenient for this task. Note that there is no need to solve an equation system every time: just evaluate the analytical solution. Using Andreas\' notation, the solution is:where Area is the (signed) area of the triangle:Just evaluate s, t and 1-s-t. The point p is inside the triangle if and only if they are all positive.EDIT: Note that the above expression for the area assumes that the triangle node numbering is counter-clockwise. If the numbering is clockwise, this expression will return a negative area (but with correct magnitude). The test itself (s>0 && t>0 && 1-s-t>0) doesn\'t depend on the direction of the numbering, however, since the expressions above that are multiplied by 1/(2*Area) also change sign if the triangle node orientation changes.EDIT 2: For an even better computational efficiency, see coproc\'s comment below (which  makes the point that if the orientation of the triangle nodes (clockwise or counter-clockwise) is known beforehand, the division by 2*Area in the expressions for s and t can be avoided). See also Perro Azul\'s jsfiddle-code in the comments under Andreas Brinck\'s answer.I wrote this code before a final attempt with Google and finding this page, so I thought I\'d share it. It is basically an optimized version of Kisielewicz answer. I looked into the Barycentric method also but judging from the Wikipedia article I have a hard time seeing how it is more efficient (I\'m guessing there is some deeper equivalence). Anyway, this algorithm has the advantage of not using division; a potential problem is the behavior of the edge detection depending on orientation.In words, the idea is this: Is the point s to the left of or to the right of both the lines AB and AC? If true, it can\'t be inside. If false, it is at least inside the "cones" that satisfy the condition. Now since we know that a point inside a trigon (triangle) must be to the same side of AB as BC (and also CA), we check if they differ. If they do, s can\'t possibly be inside, otherwise s must be inside.Some keywords in the calculations are line half-planes and the determinant (2x2 cross product). Perhaps a more pedagogical way is probably to think of it as a point being inside iff it\'s to the same side (left or right) to each of the lines AB, BC and CA. The above way seemed a better fit for some optimization however.C# version of the barycentric method posted by andreasdr and Perro Azul. Note that the area calculation can be avoided if s and t have opposite signs. I verified correct behavior with a pretty thorough unit test.[edit]accepted suggested modification by @Pierre; see commentsA simple way is to:find the vectors connecting the\n  point to each of the triangle\'s three\n  vertices and sum the angles between\n  those vectors. If the sum of the\n  angles is 2*pi then the point is\n  inside the triangle.Two good sites that explain alternatives are:blackpawn and wolframJava version of barycentric method:The above code will work accurately with integers, assuming no overflows.  It will also work with clockwise and anticlockwise triangles.  It will not work with collinear triangles (but you can check for that by testing det==0).The barycentric version is fastest if you are going to test different points with the same triangle.The barycentric version is not symmetric in the 3 triangle points, so it is likely to be less consistent than Kornel Kisielewicz\'s edge half-plane version, because of floating point rounding errors.Credit: I made the above code from Wikipedia\'s article on barycentric coordinates.What I do is precalculate the three face normals, in 3D by cross product of side vector and the face normal vector.in 2D by simply swapping components and negating one,then inside/outside for any one side is when a dot product of the side normal and the vertex to point vector, change sign. Repeat for other two (or more) sides.Benefits:a lot is precalculated so great for multiple point testing on same triangle.early rejection of common case of more outside than inside points. (also if point distribution weighted to one side, can test that side first.)Here is an efficient Python implementation:and an example output:  By using the analytic solution to the barycentric coordinates (pointed out by Andreas Brinck) and:one can minimize the number of "costy" operations:(code can be pasted in Perro Azul jsfiddle)Leading to:This compares quite well with Kornel Kisielewicz solution (25 recalls, 1 storage, 15 substractions, 6 multiplications, 5 comparisons), and might be even better if clockwise/counter-clockwise detection is needed (which takes 6 recalls, 1 addition, 2 substractions, 2 multiplications and 1 comparison in itself, using the analytic solution determinant, as pointed out by rhgb).If you are looking for speed, here is a procedure that might help you.Sort the triangle vertices on their ordinates. This takes at worst three comparisons. Let Y0, Y1, Y2 be the three sorted values. By drawing three horizontals through them you partition the plane into two half planes and two slabs. Let Y be the ordinate of the query point.Costs two more comparisons. As you see, quick rejection is achieved for points outside of the "bounding slab".Optionally, you can supply a test on the abscissas for quick rejection on the left and on the right (X <= X0\' or X >= X2\'). This will implement a quick bounding box test at the same time, but you\'ll need to sort on the abscissas too.Eventually you will need to compute the sign of the given point with respect to the two sides of the triangle that delimit the relevant slab (upper or lower). The test has the form:The complete discussion of i, j, k combinations (there are six of them, based on the outcome of the sort) is out of the scope of this answer and "left as an exercise to the reader"; for efficiency, they should be hard-coded.If you think that this solution is complex, observe that it mainly involves simple comparisons (some of which can be precomputed), plus 6 subtractions and 4 multiplies in case the bounding box test fails. The latter cost is hard to beat as in the worst case you cannot avoid comparing the test point against two sides (no method in other answers has a lower cost, some make it worse, like 15 subtractions and 6 multiplies, sometimes divisions).UPDATE:\nFaster with a shear transformAs explained just above, you can quickly locate the point inside one of the four horizontal bands delimited by the three vertex ordinates, using two comparisons.You can optionally perform one or two extra X tests to check insideness to the bounding box (dotted lines).Then consider the "shear" transform given by X\'= X - m Y, Y\' = Y, where m is the slope DX/DY for the highest edge. This transform will make this side of the triangle vertical. And since you know on what side of the middle horizontal you are, it suffices to test the sign with respect to a single side of the triangle.Assuming you precomputed the slope m, as well as the X\' for the sheared triangle vertices and the coefficients of the equations of the sides as X = m Y + p, you will need in the worst caseIf you know the co-ordinates of the three vertices and the co-ordinates of the specific point, then you can get the area of the complete triangle. Afterwards, calculate the area of the three triangle segments (one point being the point given and the other two being any two vertices of the triangle). Thus, you will get the area of the three triangle segments. If the sum of these areas are equal to the total area (that you got previously), then, the point should be inside the triangle. Otherwise, the point is not inside the triangle. This should work. If there are any issues, let me know. Thank you.There are pesky edge conditions where a point is exactly on the common edge of two adjacent triangles. The point cannot be in both, or neither of the triangles. You need an arbitrary but consistent way of assigning the point. For example, draw a horizontal line through the point. If the line intersects with the other side of the triangle on the right, the point is treated as though it is inside the triangle. If the intersection is on the left, the point is outside.If the line on which the point lies is horizontal, use above/below.If the point is on the common vertex of multiple triangles, use the triangle with whose center the point forms the smallest angle.More fun: three points can be in a straight line (zero degrees), for example (0,0) - (0,10) - (0,5). In a triangulating algorithm, the "ear" (0,10) must be lopped off, the "triangle" generated being the degenerate case of a straight line.I just want to use some simple vector math to explain the barycentric coordinates solution which Andreas had given, it will be way easier to understand.(1-s)|v0v2| / |v0v2| = tp|v0v1| / |v0v1| we get 1 - s = tp, then 1 = s + tp. If any t > tp, which 1 < s + t where is on the double dash line, the vector is outside the triangle, any t <= tp, which 1 >= s + t where is on single dash line, the vector is inside the triangle. Then if we given any s in [0, 1], the corresponding t must meet 1 >= s + t, for the vector inside triangle. So finally we get v = s * v02 + t * v01, v is inside triangle with condition s, t, s+t belongs to [0, 1]. Then translate to point, we havep - p0 = s * (p1 - p0) + t * (p2 - p0), with s, t, s + t in [0, 1]which is the same as Andreas\' solution to solve equation system\np = p0 + s * (p1 - p0) + t * (p2 - p0), with s, t, s + t belong to [0, 1].\nI needed point in triangle check in "controlable environment" when you\'re absolutely sure that triangles will be clockwise. So, I took Perro Azul\'s jsfiddle and modified it as suggested by coproc for such cases; also removed redundant 0.5 and 2 multiplications because they\'re just cancel each other.http://jsfiddle.net/dog_funtom/H7D7g/Here is equivalent C# code for Unity:Supposedly high-performance code which I adapted in JavaScript(article below):pointInTriangle (p, p0, p1, p2) - for counter-clockwise trianglespointInTriangle (p, p0, p1, p2) - for clockwise trianglesLook in jsFiddle (performance test included), there\'s also winding checking in a separate function\nhttp://jsfiddle.net/z7x0udf7/3/Inspired by this:\nhttp://www.phatcode.net/articles.php?id=459The easiest way and it works with all types of triangles is simply determine the angles of the P point A, B , C points angles. If any of the angles are bigger than 180.0 degree then it is outside, if 180.0 then it is on the circumference and if acos cheating on you and less than 180.0 then it is inside.Take a look for understanding http://math-physics-psychology.blogspot.hu/2015/01/earlish-determination-that-point-is.htmlHonestly it is as simple as Simon P Steven\'s answer however with that approach you don\'t have a solid control on whether you want the points on the edges of the triangle to be included or not.My approach is a little different but very basic. Consider the following triangle;In order to have the point in the triangle we have to satisfy 3 conditionsIn this method you have full control to include or exclude the point on the edges individually. So you may check if a point is in the triangle including only the |AC| edge for instance.So my solution in JavaScript would be as follows;It can not be more efficient than this! Each side of a triangle can have independent position and orientation, hence three calculations: l1, l2 and l3 are definitely needed involving 2 multiplications each. Once l1, l2 and l3 are known, result is just a few basic comparisons and boolean operations away.