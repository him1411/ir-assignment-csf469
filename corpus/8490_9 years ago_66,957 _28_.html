Why was the arguments.callee.caller property deprecated in JavaScript?It was added and then deprecated in JavaScript, but it was omitted altogether by ECMAScript.  Some browser (Mozilla, IE) have always supported it and don\'t have any plans on the map to remove support.  Others (Safari, Opera) have adopted support for it, but support on older browsers is unreliable.Is there a good reason to put this valuable functionality in limbo?(Or alternately, is there a better way to grab a handle on the calling function?)Early versions of JavaScript did not allow named function expressions, and because of that we could not make a recursive function expression:To get around this, arguments.callee was added so we could do:However this was actually a really bad solution as this (in conjunction with other arguments, callee, and caller issues) make inlining and tail recursion impossible in the general case (you can achieve it in select cases through tracing etc, but even the best code is sub optimal due to checks that would not otherwise be necessary).  The other major issue is that the recursive call will get a different this value, for example:Anyhow, EcmaScript 3 resolved these issues by allowing named function expressions, e.g.:This has numerous benefits:The function can be called like any other from inside your code.It does not pollute the namespace.The value of this does not change.It\'s more performant (accessing the arguments object is expensive).Just realised that in addition to everything else the question was about arguments.callee.caller, or more specifically Function.caller.At any point in time you can find the deepest caller of any function on the stack, and as I said above, looking at the call stack has one single major effect: It makes a large number of optimizations impossible, or much much more difficult.Eg. if we can\'t guarantee that a function f will not call an unknown function, then it is not possible to inline f. Basically it means that any call site that may have been trivially inlinable accumulates a large number of guards, take:If the js interpreter cannot guarantee that all the provided arguments are numbers at the point that the call is made, it needs to either insert checks for all the arguments before the inlined code, or it cannot inline the function.Now in this particular case a smart interpreter should be able to rearrange the checks to be more optimal and not check any values that would not be used.  However in many cases that\'s just not possible and therefore it becomes impossible to inline.arguments.callee.caller is not deprecated, though it does make use of the Function.caller property. (arguments.callee will just give you a reference to the current function)So the situation is less than ideal, but if you want to access the calling function in Javascript across all major browsers, you can use the Function.caller property, either accessed directly on a named function reference, or from within an anonymous function via the arguments.callee property.It is better to use named functions than arguments.callee:is better thanThe named function will have access to its caller through the caller property:which is better thanThe deprecation is due to current ECMAScript design principles.there is still an argument for referring to the function without having to hard-code its name.Just an extension. The value of "this" changes during recursion. In the following (modified) example, factorial gets the {foo:true} object.factorial called first time gets the object, but this is not true for recursive calls.