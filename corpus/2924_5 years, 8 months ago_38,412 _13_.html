I was looking for an efficient approach for calculating ab (say a = 2 and b = 50). To start things up, I decided to take a look at the implementation of Math.Pow() function. But in .NET Reflector, all I found was this:What are some of the resources wherein I can see as what\'s going on inside when I call Math.Pow() function?MethodImplOptions.InternalCallThat means that the method is actually implemented in the CLR, written in C++. The just-in-time compiler consults a table with internally implemented methods and compiles the call to the C++ function directly.Having a look at the code requires the source code for the CLR. You can get that from the SSCLI20 distribution. It was written around the .NET 2.0 time frame, I\'ve found the low-level implementations, like Math.Pow() to be still largely accurate for later versions of the CLR.The lookup table is located in clr/src/vm/ecall.cpp. The section that\'s relevant to Math.Pow() looks like this:Searching for "COMDouble" takes you to clr/src/classlibnative/float/comfloat.cpp. I\'ll spare you the code, just have a look for yourself. It basically checks for corner cases, then calls the CRT\'s version of pow().The only other implementation detail that\'s interesting is the FCIntrinsic macro in the table. That\'s a hint that the jitter may implement the function as an intrinsic. In other words, substitute the function call with a floating point machine code instruction. Which is not the case for Pow(), there is no FPU instruction for it. But certainly for the other simple operations. Notable is that this can make floating point math in C# substantially faster than the same code in C++, check this answer for the reason why.By the way, the source code for the CRT is also available if you have the full version of Visual Studio vc/crt/src directory. You\'ll hit the wall on pow() though, Microsoft purchased that code from Intel. Doing a better job than the Intel engineers is unlikely.  Although my high-school book\'s identity was twice as fast when I tried it:But not a true substitute because it accumulates error from 3 floating point operations and doesn\'t deal with the weirdo domain problems that Pow() has.  Like 0^0 and -Infinity raised to any power.Hans Passant\'s answer is great, but I would like to add that if b is an integer, then a^b can be computed very efficiently with binary decomposition.  Here\'s a modified version from Henry Warren\'s Hacker\'s Delight:He notes that this operation is optimal (does the minimum number of arithmetic or logical operations) for all b < 15.  Also there is no known solution to the general problem of finding an optimal sequence of factors to compute a^b for any b other than an extensive search.  It\'s an NP-Hard problem.  So basically that means that the binary decomposition is as good as it gets.If freely available C version of pow is any indication, it does not look like anything you would expect. It would not be of much help to you to find the .NET version, because the problem that you are solving (i.e. the one with integers) is orders of magnitudes simpler, and can be solved in a few lines of C# code with the exponentiation by squaring algorithm.