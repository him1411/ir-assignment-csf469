How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?I have seen the Scheme example given on Wikipedia, but unfortunately it did not help.This page explains closures so that a programmer can understand them — using working JavaScript code. It is not for gurus or functional programmers.Closures are not hard to understand once the core concept is grokked. However, they are impossible to understand by reading any academic papers or academically oriented information about them!This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function:Two one sentence summaries:A closure is one way of supporting first-class functions; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result. Or, a closure is a stack frame which is allocated when a function starts its execution, and not freed after the function returns (as if a \'stack frame\' were allocated on the heap rather than the stack!).The following code returns a reference to a function:Most JavaScript programmers will understand how a reference to a function is returned to a variable (say2) in the above code. If you don\'t, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables say and say2 were each a pointer to a function.There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function as well as a hidden pointer to a closure.The above code has a closure because the anonymous function function() { console.log(text); } is declared inside another function, sayHello2() in this example. In JavaScript, if you use the function keyword inside another function, you are creating a closure.In C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed.In JavaScript, if you declare a function within another function, then the local variables can remain accessible after returning from the function you called. This is demonstrated above, because we call the function say2() after we have returned from sayHello2(). Notice that the code that we call references the variable text, which was a local variable of the function sayHello2().Looking at the output of say2.toString(), we can see that the code refers to the variable text. The anonymous function can reference text which holds the value \'Hello Bob\' because the local variables of sayHello2() are kept in a closure.The magic is that in JavaScript a function reference also has a secret reference to the closure it was created in — similar to how delegates are a method pointer plus a secret reference to an object.For some reason, closures seem really hard to understand when you read about them, but when you see some examples it becomes clear how they work (it took me a while).\nI recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs!This example shows that the local variables are not copied — they are kept by reference. It is kind of like keeping a stack-frame in memory when the outer function exits!All three global functions have a common reference to the same closure because they are all declared within a single call to setupSomeGlobals().The three functions have shared access to the same closure — the local variables of setupSomeGlobals() when the three functions were defined.Note that in the above example, if you call setupSomeGlobals() again, then a new closure (stack-frame!) is created. The old gLogNumber, gIncreaseNumber, gSetNumber variables are overwritten with new functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again each time the outside function is called.)This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure do not act as you might first think.The line result.push( function() {console.log(item + \' \' + list[i])} adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like:Note that when you run the example, "item2 undefined" is alerted three times! This is because just like previous examples, there is only one closure for the local variables for buildList. When the anonymous functions are called on the line fnlist[j](); they all use the same single closure, and they use the current value for i and item within that one closure (where i has a value of 3 because the loop had completed, and item has a value of \'item2\'). Note we are indexing from 0 hence item has a value of item2. And the i++ will increment i to the value 3.This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable alice is actually declared after the anonymous function. The anonymous function is declared first; and when that function is called it can access the alice variable because alice is in the same scope (JavaScript does variable hoisting).\nAlso sayAlice()() just directly calls the function reference returned from sayAlice() — it is exactly the same as what was done previously but without the temporary variable.Tricky: note also that the say variable is also inside the closure, and could be accessed by any other function that might be declared within sayAlice(), or it could be accessed recursively within the inside function.This final example shows that each call creates a separate closure for the local variables. There is not a single closure per function declaration. There is a closure for each call to a function.If everything seems completely unclear then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples.\nMy explanations of closures and stack-frames, etc. are not technically correct — they are gross simplifications intended to help understanding. Once the basic idea is grokked, you can pick up the details later.If you have just learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript — nor on closures.Original post by Morris can be found in the Internet Archive.Whenever you see the function keyword within another function, the inner function has access to variables in the outer function.This will always log 16, because bar can access the x which was defined as an argument to foo, and it can also access tmp from foo.That is a closure. A function doesn\'t have to return in order to be called a closure. Simply accessing variables outside of your immediate lexical scope creates a closure.The above function will also log 16, because bar can still refer to x and tmp, even though it is no longer directly inside the scope.However, since tmp is still hanging around inside bar\'s closure, it is also being incremented. It will be incremented each time you call bar.The simplest example of a closure is this:When a JavaScript function is invoked, a new execution context is created. Together with the function arguments and the parent object, this execution context also receives all the variables declared outside of it (in the above example, both \'a\' and \'b\').It is possible to create more than one closure function, either by returning a list of them or by setting them to global variables. All of these will refer to the same x and the same tmp, they don\'t make their own copies.Here the number x is a literal number. As with other literals in JavaScript, when foo is called, the number x is copied into foo as its argument x.On the other hand, JavaScript always uses references when dealing with objects. If say, you called foo with an object, the closure it returns will reference that original object!As expected, each call to bar(10) will increment x.memb. What might not be expected, is that x is simply referring to the same object as the age variable! After a couple of calls to bar, age.memb will be 2! This referencing is the basis for memory leaks with HTML objects.FOREWORD: this answer was written when the question was:Like the old Albert said : "If you can\'t explain it to a six-year old, you really don\'t understand it yourself.\xe2\x80\x9d. Well I tried to explain JS closures to a 27 years old friend and completely failed.Can anybody consider than I am 6 and strangely interested in that subject ?I\'m pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly & out of place. Hopefully the general idea of the story remains fun for some.I\'m a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.Once upon a time:There was a princess...She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.But she would always have to return back to her dull world of chores and grown-ups.And she would often tell them of her latest amazing adventure as a princess.But all they would see is a little girl......telling stories about magic and fantasy.And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl\'s imagination.But we know the real truth; that the little girl with the princess inside......is really a princess with a little girl inside.Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.  On  Childhood Development: 5 to 7 Years  it says:Your child will be able to follow two-step directions. For example, if you say to your child, "Go to the kitchen and get me a trash bag" they will be able to remember that direction.We can use this example to explain closures, as follows:The kitchen is a closure that has a local variable, called trashBags.  There is a function inside the kitchen called getTrashBag that gets one trash bag and returns it.We can code this in JavaScript like this:Further points that explain why closures are interesting:I need to know how many times a button has been clicked, and do something on every third click...Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations this would be preferable as your outer application might need access to this information. But in this case we are only changing every third click\'s behavior, so it is preferable to enclose this functionality inside the event handler.Notice a few things here.In the above example I am using the closure behavior of JavaScript. This behavior allows any function to have access to the scope in which it was created, indefinitely. To practically apply this, I immediately invoke a function that returns another function, and because the function I\'m returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let\'s dilute it down...A simple one-line closureAll variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.Also this private variable state is fully accessible, for both reading and assigning to its private scoped variables.There you go; you\'re now fully encapsulating this behavior.Full Blog Post (including jQuery considerations)Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that I learned what they do) is to imagine the situation without them:What would happen here if JavaScript didn\'t know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:Now, where\'s the definition of x? We didn\'t define it in the current scope. The only solution is to let plus5 carry its scope (or rather, its parent\'s scope) around. This way, x is well-defined and it is bound to the value 5.This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?Let\'s imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That\'s it. When you turn 27, look at the more detailed explanation or at the example below.Here is how I can convert my plane story into the code.A closure is much like an object. It gets instantiated whenever you call a function. The scope of a closure in JavaScript is lexical, which means that everything that is contained within the function the closure belongs to, has access to any variable that is in it.A variable is contained in the closure if youIf an inner function (a function contained inside another function) accesses such a variable without defining it in its own scope with var, it modifies the content of the variable in the outer closure.A closure outlives the runtime of the function that spawned it. If other functions make it out of the closure/scope in which they are defined (for instance as return values), those will continue to reference that closure.I wrote a blog post a while back explaining closures. Here\'s what I said about closures in terms of why you\'d want one.Closures are a way to let a function\n  have persistent, private variables -\n  that is, variables that only one\n  function knows about, where it can\n  keep track of info from previous times\n  that it was run.In that sense, they let a function act a bit like an object with private attributes.Full post:So what are these closure thingys?How I\'d explain it to a six-year-old:You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn\'t really own anything, right? But its parents own a house, so whenever someone asks the child "Where\'s your home?", he/she can answer "that house!", and point to the house of its parents. A "Closure" is the ability of the child to always (even if abroad) be able to say it has a home, even though it\'s really the parent\'s who own the house.The following simple example covers all the main points of JavaScript closures.*\n Here is a factory that produces calculators that can add and multiply:The key point: Each call to make_calculator creates a new local variable n, which continues to be usable by that calculator\'s add and multiply functions long after make_calculator returns.If you are familiar with stack frames, these calculators seem strange: How can they keep accessing n after make_calculator returns?  The answer is to imagine that JavaScript doesn\'t use "stack frames", but instead uses "heap frames", which can persist after the function call that made them returns.Inner functions like add and multiply, which access variables declared in an outer function**, are called closures.That is pretty much all there is to closures.* For example, it covers all the points in the "Closures for Dummies" article given in another answer, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in the accepted answer, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in this answer but a bit shorter and less abstract. It does not cover the point of this answer or this comment, which is that JavaScript makes it difficult to plug the current value of a loop variable into your inner function: The "plugging in" step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function\'s copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the "plugging in" way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. ** Any outer function, if several are nested, or even in the global context, as this answer points out clearly.I still think Google\'s explanation works very well and is concise:*A C# questionI tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together a jsFiddle that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.In the above code createClosure(n) is invoked in every iteration of the loop. Note that I named the variable n to highlight that it is a new variable created in a new function scope and is not the same variable as index which is bound to the outer scope.This creates a new scope and n is bound to that scope; this means we have 10 separate scopes, one for each iteration.createClosure(n) returns a function that returns the n within that scope.Within each scope n is bound to whatever value it had when createClosure(n) was invoked so the nested function that gets returned will always return the value of n that it had when createClosure(n) was invoked.In the above code the loop was moved within the createClosureArray() function and the function now just returns the completed array, which at first glance seems more intuitive.What might not be obvious is that since createClosureArray() is only invoked once only one scope is created for this function instead of one for every iteration of the loop.Within this function a variable named index is defined. The loop runs and adds functions to the array that return index. Note that index is defined within the createClosureArray function which only ever gets invoked one time.Because there was only one scope within the createClosureArray() function, index is only bound to a value within that scope. In other words, each time the loop changes the value of index, it changes it for everything that references it within that scope.All of the functions added to the array return the SAME index variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.After the loop finished and index was done being modified the end value was 10, therefore every function added to the array returns the value of the single index variable which is now set to 10.CLOSURES DONE RIGHT\n  n = 0\n  n = 1\n  n = 2\n  n = 3\n  n = 4\n  n = 5\n  n = 6\n  n = 7\n  n = 8\n  n = 9  CLOSURES DONE WRONG\n  n = 10\n  n = 10\n  n = 10\n  n = 10\n  n = 10\n  n = 10\n  n = 10\n  n = 10\n  n = 10\n  n = 10  Wikipedia on closures:In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.Technically, in JavaScript, every function is a closure. It always has an access to variables defined in the surrounding scope.Since scope-defining construction in JavaScript is a function, not a code block like in many other languages, what we usually mean by closure in JavaScript is a function working with nonlocal variables defined in already executed surrounding function.Closures are often used for creating functions with some hidden private data (but it\'s not always the case).emsThe example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. mkdb) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don\'t return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.I put together an interactive JavaScript tutorial to explain how closures work.\nWhat\'s a Closure?Here\'s one of the examples:The children will always remember the secrets they have shared with their parents, even after their parents are\n  gone. This is what closures are for functions.The secrets for JavaScript functions are the private variablesEvery time you call it, local variable "name" is created and given name "Mary". And every time the function exits the variable is lost and the name is forgotten.As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called Chamber of Secrets or stack or local scope but it doesn\'t really matter. We know they are there, somewhere, hidden in the memory.But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.So to live, the child has to leave before it\'s too lateAnd now, even though Mary is "no longer running", the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.So, if you call the child "Alice", she will respondThat\'s all there is to tell.I do not understand why the answers are so complex here.Here is a closure:Yes. You probably use that many times a day.There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope from the perspective of where the function was declared (not run).Now what it allows you to do can be more spectacular, see other answers.Example for the first point by dlaliberte:A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.You\'re having a sleep over and you invite Dan.\nYou tell Dan to bring one XBox controller.Dan invites Paul.\nDan asks Paul to bring one controller. How many controllers were brought to the party?I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:A closure is where an inner function has access to variables in its outer function. That\'s probably the simplest one-line explanation you can get for closures.JavaScript functions can access their:If a function accesses its environment, then the function is a closure.Note that outer functions are not required, though they do offer benefits I don\'t discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function\'s local data alive.Example of a closure that uses the global environment:Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity\'s sake, I am referring to StackOverflow\'s Question Vote buttons, not the array of Answer Vote buttons.)When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.All four of these functions are closures as they all access their environment.The author of Closures has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. \nHere is the summary:What if a variable is accessed, but it isn\xe2\x80\x99t local? Like here:In this case, the interpreter finds the variable in the\nouter LexicalEnvironment object.The process consists of two steps:When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.If a variable is read, but can not be found anywhere, an error is generated.Nested functionsFunctions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.So, function g has access to g, a and f.ClosuresA nested function may continue to live after the outer function has finished:Marking up LexicalEnvironments:As we see, this.say is a property in the user object, so it continues to live after User completed.And if you remember, when this.say is created, it (as every function) gets an internal reference this.say.[[Scope]] to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.To summarize:This is called a closure.(You may also want to read What is a practical use for a closure in JavaScript?)As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I\'d suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.INSTRUCTIONSDATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can\'t touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to create touch smell and taste using a computer. It can be made useful by a computer using code.CODE: All the writing above is called code. It is written in JavaScript.JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says "\xd0\xb2\xd1\x81\xd0\xb5 \xd1\x81\xd0\xb0\xd0\xb4\xd1\x8f\xd1\x82\xd1\x81\xd1\x8f", the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means "everybody sit down" - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can\'t sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let\'s say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.I haven\'t got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could \'talk\' to the fridge, and the function could control the robot.A function normally has a name, parentheses and braces. Like this:Note that /*...*/ and // stop code being read by the browser.NAME: You can call a function just about whatever word you want. The example "cookMeal" is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can\'t have a space in it, and it can\'t be a number on its own.PARENTHESES: "Parentheses" or () are the letter box on the JavaScript function factory\'s door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked for example cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime), in which case you know what data you have to give it.BRACES: "Braces" which look like this {} are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can\'t see in.THE LONG CODE EXAMPLE ABOVEOur code begins with the word function, so we know that it is one! Then the name of the function sing - that\'s my own description of what the function is about. Then parentheses (). The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: (person). After this there is a brace like this { . This marks the start of the function sing(). It has a partner which marks the end of sing() like this }So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.Now, after the function sing(), near the end of the code is the lineVARIABLE: The letters var stand for "variable". A variable is like an envelope. On the outside this envelope is marked "person". On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it\'s called a string) that make a phrase reading "an old lady". Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called arrays). Because this variable is written outside of all the braces {}, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a \'global variable\'.GLOBAL VARIABLE: person is a global variable, meaning that if you change its value from "an old lady" to "a young man", the person will keep being a young man until you decide to change it again and that any other function in the code can see that it\'s a young man. Press the F12 button or look at the Options settings to open the developer console of a browser and type "person" to see what this value is. Type person="a young man" to change it and then type "person" again to see that it has changed.After this we have the lineThis line is calling the function, as if it were calling a dog"Come on sing, Come and get person!"When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.Functions define actions  - the main function is about singing. It contains a variable called firstPart which applies to the singing about the person that applies to each of the verses of the song: "There was " + person + " who swallowed". If you type firstPart into the console, you won\'t get an answer because the variable is locked up in a function - the browser can\'t see inside the tinted windows of the braces.CLOSURES: The closures are the smaller functions that are inside the big sing() function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can\'t be seen from the outside. That\'s why the names of the variables (creature and result) can be repeated in the closures but with different values. If you type these variable names in the console window, you won\'t get its value because it\'s hidden by two layers of tinted windows.The closures all know what the sing() function\'s variable called firstPart is, because they can see out from their tinted windows.After the closures come the linesThe sing() function will call each of these functions in the order they are given. Then the sing() function\'s work will be done.Okay, talking with a 6-year old child, I would possibly use following associations.Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother\'s room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy\'s closure; your brother made it up for you, and he is now into outer scope.Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is a jsbin to play around with it.An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don\'t go away. Instead, that parent function "closes." In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.Another really simple way to explain it is in terms of scope:Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.A closure is a function that has access to another function\'s scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function\xe2\x80\x99s scope.ALERT: monkeyIn the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.Now consider the following:ALERT: monkeyreferenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case. ALERT: monkey\nALERT: monkeyBut how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction\xe2\x80\x99s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction\xe2\x80\x99s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction\xe2\x80\x99s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.//////////Two other things about closures to note. First, the closure will always have access to the last values of its containing function.ALERT: gorillaSecond, when a closure is created, it retains a reference to all of its enclosing function\xe2\x80\x99s variables and functions; it doesn\xe2\x80\x99t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.Closures are functions with a state. It is somewhat similar to "this" in the sense that "this" also provides state for a function but function and "this" are separate objects ("this" is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While "this" and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).An example:I\'d simply point them to the Mozilla Closures page. It\'s the best, most concise and simple explanation of closure basics and practical usage that I\'ve found. It is highly recommended to anyone learning JavaScript.And yes, I\'d even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it\'s logical they\'re ready to comprehend the concise and simple explanation provided in the article.