I have an array like this:How can I randomize / shuffle it?The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.See https://github.com/coolaj86/knuth-shuffleYou can see a great visualization here (and the original post linked to this)Some more info about the algorithm used.Here is a JavaScript implementation of the Durstenfeld shuffle, a computer-optimized version of Fisher-Yates:The Fisher-Yates algorithm works by picking one random element for each original array element, and then excluding it from the next draw. Just like randomly picking from a deck of cards.This exclusion is done in a clever way (invented by Durstenfeld for use by computers) by swapping the picked element with the current element, and then picking the next random element from the remainder. For optimal efficiency, the loop runs backwards so that the random pick is simplified (it can always start at 0), and it skips the last element because there are no other choices anymore.The running time of this algorithm is O(n). Note that although it does return the array for convenience, the shuffle is done in-place. So if you do not want to modify the original array, make a copy of it first with .slice(0).The new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature. [community edit: This answer is incorrect; see comments. It is being left here for future reference because the idea is not that rare.]One could (or should) use it as a protoype from Array:From ChristopheD:Use the underscore.js library. The method _.shuffle() is nice for this case.\nHere is an example with the method:NEW!Shorter & probably *faster Fisher-Yates shuffle algorithmscript size (with fy as function name): 90bytes DEMO\nhttp://jsfiddle.net/vvpoma8w/*faster probably on all browsers except chrome.If you have any questions just ask.EDITyes it is fasterPERFORMANCE: http://jsperf.com/fyshuffleusing the top voted functions.EDIT \nThere was a calculation in excess (don\'t need --c+1) and noone noticedshorter(4bytes)&faster(test it!).Caching somewhere else var rnd=Math.random and then use rnd() would also increase slightly the performance on big arrays.http://jsfiddle.net/vvpoma8w/2/Readable version (use the original version. this is slower, vars are useless, like the closures & ";", the code itself is also shorter ... maybe read this How to 'minify' Javascript code , btw you are not able to compress the following code in a javascript minifiers like the above one.)Adding to @Laurens Holsts answer.  This is 50% compressed.A very simple way for small arrays is simply this:It\'s probably not very efficient, but for small arrays this works just fine :) With ES2015 you can use this one:Usage:I found this variant hanging out in the "deleted by author" answers on a duplicate of this question. Unlike some of the other answers that have many upvotes already, this is:Here\'s a jsfiddle showing it in use.Fisher-Yates shuffle in javascript. I\'m posting this here because the use of two utility functions (swap and randInt) clarifies the algorithm compared to the other answers here.First of all, have a look here for a great visual comparison of different sorting methods in javascript.Secondly, if you have a quick look at the link above you\'ll find that the random order sort seems to perform relatively well compared to the other methods, while being extremely easy and fast to implement as shown below:Edit: as pointed out by @gregers, the compare function is called with values rather than indices, which is why you need to use indexOf. Note that this change makes the code less suitable for larger arrays as indexOf runs in O(n) time.based on the Fisher-Yates Shuffle, you can try this reusable array-shuffle component. \nExample:I also like this Lodash function which returns a new array and leaves the original array unchanged:(Proper disclosure: I\'m on the CoCycles team.) yet another implementation of Fisher-Yates, using strict mode:A recursive solution:The spec says to just use 1, -1 and 0 for representing higher, lower and equal value.\nDepending on that the array is being sorted.\nBy providing random values the array will basically be randomly sorted.The algorithm behind Array.prototype.sort() is only checking for positive, negative and equal anyways. Yes someone could use Math.random() * 0.5 but seriously.. equality should be random too.A simple modification of CoolAJ86\'s answer that don\'t modify original arraySome of the answers could be shortened with the latest ES6. ES6 allows us to assign two values at once. This is especially handy in line 4 above, where two variables are swapped in one line of code. If you want to make a more pure function, and leave the original array intact, you can simply duplicate the array and then run the same algorithm.  The algorithm below uses an ascending loop. It is less intuitive, yet short and valid. I used the function bellow to test the reliability of the randomising function. This function prints out the distribution of values in each position. running the test on both getShuffledArray functions, both in chrome and in node,  displayed in the console an even distribution. This is in accordance with what we would expect from a randomizing function.  This variation of Fisher-Yates is slightly more efficient because it avoids swapping an element with itself:Randomize array using array.splice() demoRandomize  arrayJust pass the array to function and in return get the shuffled arrayConsidering apply it to in loco or to a new immutable array, following other solutions, here is a suggested implementation:Ronald Fisher and Frank Yates shuffleES2015 (ES6) releaseJet optimized ES2015 (ES6) releasethe shortest arrayShuffle functionI see no one has yet given a solution that can be concatenated while not extending the Array prototype (which is a bad practice). Using the slightly lesser known reduce() we can easily do shuffling in a way that allows for concatenation:You\'d probably want to pass the second parameter [], as otherwise if you try to do this on an empty array it\'d fail:Let\'s define shuffle as:You can see it in action in JSFiddle or here:From a theoretical point of view, the most elegant way of doing it, in my humble opinion, is to get a single random number between 0 and n!-1 and to compute a one to one mapping from {0, 1, \xe2\x80\xa6, n!-1} to all permutations of (0, 1, 2, \xe2\x80\xa6, n-1). As long as you can use a (pseudo-)random generator reliable enough for getting such a number without any significant bias, you have enough information in it for achieving what you want without needing several other random numbers.When computing with IEEE754 double precision floating numbers, you can expect your random generator to provide about 15 decimals. Since you have 15!=1,307,674,368,000 (with 13 digits), you can use the following functions with arrays containing up to 15 elements and assume there will be no significant bias with arrays containing up to 14 elements. If you work on a fixed-size problem requiring to compute many times this shuffle operation, you may want to try the following code which may be faster than other codes since it uses Math.random only once (it involved several copy operations however).The following function will not be used, but I give it anyway; it returns the index of a given permutation of (0, 1, 2, \xe2\x80\xa6, n-1) according to the one to one mapping used in this message (the most natural one when enumerating permuations); it is intended to work with up to 16 elements:The reciprocal of the previous function (required for your own question) is below; it is intended to work with up to 16 elements; it returns the permutation of order n of (0, 1, 2, \xe2\x80\xa6, s-1):Now, what you want merely is:It should work for up to 16 elements with a little theoretical bias (though unnoticeable from a practical point of view); it can be seen as fully usable for 15 elements; with arrays containing less than 14 elements, you can safely consider there will be absolutely no bias.I was thinking about oneliner to paste in console. All tricks with .sort was giving wrong results, here is my implementation:But don\'t use it in production code, it\'s not optimal and works with strings only.