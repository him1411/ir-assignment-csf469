It seems that many projects slowly come upon a need to do matrix math, and fall into the trap of first building some vector classes and slowly adding in functionality until they get caught building a half-assed custom linear algebra library, and depending on it. I\'d like to avoid that while not building in a dependence on some tangentially related library (e.g. OpenCV, OpenSceneGraph). What are the commonly used matrix math/linear algebra libraries out there, and why would decide to use one over another? Are there any that would be advised against using for some reason? I am specifically using this in a geometric/time context*(2,3,4 Dim)* but may be using higher dimensional data in the future. I\'m looking for differences with respect to any of: API, speed, memory use, breadth/completeness, narrowness/specificness, extensibility, and/or maturity/stability.I ended up using Eigen3 which I am extremely happy with.There are quite a few projects that have settled on the Generic Graphics Toolkit for this.  The GMTL in there is nice - it\'s quite small, very functional, and been used widely enough to be very reliable.   OpenSG, VRJuggler, and other projects have all switched to using this instead of their own hand-rolled vertor/matrix math.I\'ve found it quite nice - it does everything via templates, so it\'s very flexible, and very fast.Edit:After the comments discussion, and edits, I thought I\'d throw out some more information about the benefits and downsides to specific implementations, and why you might choose one over the other, given your situation.GMTL - Benefits: Simple API, specifically designed for graphics engines.  Includes many primitive types geared towards rendering (such as planes, AABB, quatenrions with multiple interpolation, etc) that aren\'t in any other packages.  Very low memory overhead, quite fast, easy to use.Downsides: API is very focused specifically on rendering and graphics.  Doesn\'t include general purpose (NxM) matrices, matrix decomposition and solving, etc, since these are outside the realm of traditional graphics/geometry applications.Eigen -Benefits: Clean API, fairly easy to use.  Includes a Geometry module with quaternions and geometric transforms.  Low memory overhead.  Full, highly performant solving of large NxN matrices and other general purpose mathematical routines.Downsides: May be a bit larger scope than you are wanting (?).  Fewer geometric/rendering specific routines when compared to GMTL (ie: Euler angle definitions, etc).IMSL -Benefits: Very complete numeric library.  Very, very fast (supposedly the fastest solver).  By far the largest, most complete mathematical API.  Commercially supported, mature, and stable.Downsides: Cost - not inexpensive.  Very few geometric/rendering specific methods, so you\'ll need to roll your own on top of their linear algebra classes.NT2 - Benefits: Provides syntax that is more familiar if you\'re used to MATLAB.  Provides full decomposition and solving for large matrices, etc.Downsides: Mathematical, not rendering focused.  Probably not as performant as Eigen.LAPACK -Benefits: Very stable, proven algorithms.  Been around for a long time.  Complete matrix solving, etc.  Many options for obscure mathematics.Downsides: Not as highly performant in some cases.  Ported from Fortran, with odd API for usage.Personally, for me, it comes down to a single question - how are you planning to use this.  If you\'re focus is just on rendering and graphics, I like Generic Graphics Toolkit, since it performs well, and supports many useful rendering operations out of the box without having to implement your own.  If you need general purpose matrix solving (ie: SVD or LU decomposition of large matrices), I\'d go with Eigen, since it handles that, provides some geometric operations, and is very performant with large matrix solutions.  You may need to write more of your own graphics/geometric operations (on top of their matrices/vectors), but that\'s not horrible.So I\'m a pretty critical person, and figure if I\'m going to invest in a library, I\'d better know what I\'m getting myself into. I figure it\'s better to go heavy on the criticism and light on the flattery when scrutinizing; what\'s wrong with it has many more implications for the future than what\'s right. So I\'m going to go overboard here a little bit to provide the kind of answer that would have helped me and I hope will help others who may journey down this path. Keep in mind that this is based on what little reviewing/testing I\'ve done with these libs. Oh and I stole some of the positive description from Reed.I\'ll mention up top that I went with GMTL despite it\'s idiosyncrasies because the Eigen2 unsafeness was too big of a downside. But I\'ve recently learned that the next release of Eigen2 will contain defines that will shut off the alignment code, and make it safe. So I may switch over.Update: I\'ve switched to Eigen3. Despite it\'s idiosyncrasies, its scope and elegance are too hard to ignore, and the optimizations which make it unsafe can be turned off with a define.Benefits: LGPL MPL2, Clean, well designed API, fairly easy to use. Seems to be well maintained with a vibrant community. Low memory overhead. High performance. Made for general linear algebra, but good geometric functionality available as well. All header lib, no linking required. Idiocyncracies/downsides: (Some/all of these can be avoided by some defines that are available in the current development branch Eigen3)Benefits: LGPL, Fairly Simple API, specifically designed for graphics engines.\nIncludes many primitive types geared towards rendering (such as\nplanes, AABB, quatenrions with multiple interpolation, etc) that\naren\'t in any other packages. Very low memory overhead, quite fast,\neasy to use. All header based, no linking necessary.Idiocyncracies/downsides:Can\'t tell because they seem to be more interested in the fractal image header of their web page than the content. Looks more like an academic project than a serious software project. Latest release over 2 years ago.Apparently no documentation in English though supposedly there is something in French somewhere.Cant find a trace of a community around the project.Benefits: Old and mature.Downsides:If you are looking for high performance matrix/linear algebra/optimization on Intel processors, I\'d look at Intel\'s MKL library.  MKL is carefully optimized for fast run-time performance - much of it based on the very mature BLAS/LAPACK fortran standards.  And its performance scales with the number of cores available.  Hands-free scalability with available cores is the future of computing and I wouldn\'t use any math library for a new project doesn\'t support multi-core processors.Very briefly, it includes: A downside is that the MKL API can be quite complex depending on the routines that you need.  You could also take a look at their IPP (Integrated Performance Primitives) library which is geared toward high performance image processing operations, but is nevertheless quite broad.Paul CenterSpace Software ,.NET Math libraries, centerspace.netFor what it\'s worth, I\'ve tried both Eigen and Armadillo.  Below is a brief evaluation.Eigen\nAdvantages:\n1. Completely self-contained -- no dependence on external BLAS or LAPACK.\n2. Documentation decent.\n3. Purportedly fast, although I haven\'t put it to the test.Disadvantage:\nThe QR algorithm returns just a single matrix, with the R matrix embedded in the upper triangle.  No idea where the rest of the matrix comes from, and no Q matrix can be accessed.Armadillo\nAdvantages:\n1. Wide range of decompositions and other functions (including QR).\n2. Reasonably fast (uses expression templates), but again, I haven\'t really pushed it to high dimensions.Disadvantages:\n1. Depends on external BLAS and/or LAPACK for matrix decompositions.\n2. Documentation is lacking IMHO (including the specifics wrt LAPACK, other than changing a #define statement).Would be nice if an open source library were available that is self-contained and straightforward to use.  I have run into this same issue for 10 years, and it gets frustrating.  At one point, I used GSL for C and wrote C++ wrappers around it, but with modern C++ -- especially using the advantages of expression templates -- we shouldn\'t have to mess with C in the 21st century.  Just my tuppencehapenny.I\'ve heard good things about Eigen and NT2, but haven\'t personally used either. There\'s also Boost.UBLAS, which I believe is getting a bit long in the tooth. The developers of NT2 are building the next version with the intention of getting it into Boost, so that might count for somthing.My lin. alg. needs don\'t exteed beyond the 4x4 matrix case, so I can\'t comment on advanced functionality; I\'m just pointing out some options.I\'m new to this topic, so I can\'t say a whole lot, but BLAS is pretty much the standard in scientific computing. BLAS is actually an API standard, which has many implementations. I\'m honestly not sure which implementations are most popular or why.If you want to also be able to do common linear algebra operations (solving systems, least squares regression, decomposition, etc.) look into LAPACK.What about GLM?It\'s  based on the OpenGL Shading Language (GLSL) specification and released under the MIT license.\nClearly aimed at graphics programmersI\'ll add vote for Eigen: I ported a lot of code (3D geometry, linear algebra and differential equations) from different libraries to this one - improving both performance and code readability in almost all cases. One advantage that wasn\'t mentioned: it\'s very easy to use SSE with Eigen, which significantly improves performance of 2D-3D operations (where everything can be padded to 128 bits).Okay, I think I know what you\'re looking for.  It appears that GGT is a pretty good solution, as Reed Copsey suggested.Personally, we rolled our own little library, because we deal with rational points a lot - lots of rational NURBS and Beziers.It turns out that most 3D graphics libraries do computations with projective points that have no basis in projective math, because that\'s what gets you the answer you want.  We ended up using Grassmann points, which have a solid theoretical underpinning and decreased the number of point types.  Grassmann points are basically the same computations people are using now, with the benefit of a robust theory.  Most importantly, it makes things clearer in our minds, so we have fewer bugs.  Ron Goldman wrote a paper on Grassmann points in computer graphics called "On the Algebraic and Geometric Foundations of Computer Graphics".  Not directly related to your question, but an interesting read.FLENShttp://flens.sf.netIt also implements a lot of LAPACK functions.I found this library quite simple and functional (http://kirillsprograms.com/top_Vectors.php). These are bare bone vectors implemented via C++ templates. No fancy stuff - just what you need to do with vectors (add, subtract multiply, dot, etc).