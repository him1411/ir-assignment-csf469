What does the register keyword do in C language?  I have read that it is used for optimizing but is not clearly defined in any standard.  Is it still relevant and if so, when would you use it?It\'s a hint to the compiler that the variable will be heavily used and that you recommend it be kept in a processor register if possible.Most modern compilers do that automatically, and are better at picking them than us humans.I\'m surprised that nobody mentioned that you cannot take an address of register variable, even if compiler decides to keep variable in memory rather than in register.So using register you win nothing (anyway compiler will decide for itself where to put the variable) and lose the & operator - no reason to use it.It tells the compiler to try to use a CPU register, instead of RAM, to store the variable. Registers are in the CPU and much faster to access than RAM. But it\'s only a suggestion to the compiler, and it may not follow through.I know this question is about C, but the same question for C++ was closed as a exact duplicate of this question.  This answer therefore may not apply for C.The latest draft of the C++11 standard, N3485, says this in 7.1.1/3:A register specifier is a hint to the implementation that the variable so declared will be heavily used. [ note: The hint can be ignored and in most implementations it will be ignored if the address of the variable is taken. This use is deprecated ... \xe2\x80\x94end note ]In C++ (but not in C), the standard does not state that you can\'t take the address of a variable declared register; however, because a variable stored in a CPU register throughout its lifetime does not have a memory location associated with it, attempting to take its address would be invalid, and the compiler will ignore the register keyword to allow taking the address.It hasn\'t been relevant for at least 15 years as optimizers make better decisions about this than you can.  Even when it was relevant, it made a lot more sense on a CPU architecture with a lot of registers, like SPARC or M68000 than it did on Intel with its paucity of registers, most of which are reserved by the compiler for its own purposes.Actually, register tells the compiler that the variable does not alias with\nanything else in the program (not even char\'s).That can be exploited by modern compilers in a variety of situations, and can help the compiler quite a bit in complex code - in simple code the compilers can figure this out on their own.Otherwise, it serves no purpose and is not used for register allocation. It does not usually incur performance degradation to specify it, as long as your compiler is modern enough.I have read that it is used for optimizing but is not clearly defined in any standard.In fact it is clearly defined by the C standard. Quoting the N1570 draft section 6.7.1 paragraph 6 (other versions have the same wording):A declaration of an identifier for an object with storage-class\n  specifier register suggests that access to the object be as fast\n  as possible. The extent to which such suggestions are effective is\n  implementation-defined.The unary & operator may not be applied to an object defined with register, and register may not be used in an external declaration.There are a few other (fairly obscure)  rules that are specific to register-qualified objects:There may be a few others; download a draft of the standard and search for "register" if you\'re interested.As the name implies, the original meaning of register was to require an object to be stored in a CPU register. But with improvements in optimizing compilers, this has become less useful. Modern versions of the C standard don\'t refer to CPU registers, because they no longer (need to) assume that there is such a thing (there are architectures that don\'t use registers). The common wisdom is that applying register to an object declaration is more likely to worsen the generated code, because it interferes with the compiler\'s own register allocation. There might still be a few cases where it\'s useful (say, if you really do know how often a variable will be accessed, and your knowledge is better than what a modern optimizing compiler can figure out).The main tangible effect of register is that it prevents any attempt to take an object\'s address. This isn\'t particularly useful as an optimization hint, since it can be applied only to local variables, and an optimizing compiler can see for itself that such an object\'s address isn\'t taken.You are messing with the compiler\'s sophisticated graph-coloring algorithm. This is used for register allocation. Well, mostly. It acts as a hint to the compiler -- that\'s true. But not ignored in its entirety since you are not allowed to take the address of a register variable (remember the compiler, now on your mercy, will try to act differently). Which in a way is telling you not to use it.The keyword was used long, long back. When there were only so few registers that could count them all using your index finger. But, as I said, deprecated doesn\'t mean you cannot use it.During the seventies, at the very beginning of the C language, the register keyword has been introduced in order to allow the programmer to give hints to the compiler, telling it that the variable would be used very often, and that it should be wise to keep it\xe2\x80\x99s value in one of the processor\xe2\x80\x99s internal register.Nowadays, optimizers are much more efficient than programmers to determine  variables  that are more likely to be kept into registers, and the optimizer does not always take the programmer\xe2\x80\x99s hint into account.So many people wrongly recommend not to use the register keyword.Let\xe2\x80\x99s see why!The register keyword has an associated side effect: you can not reference (get the address of) a register type variable.People advising others not to use registers takes wrongly this as an additional argument.However, the simple fact of knowing that you can not take the address of a register variable, allows the compiler (and its optimizer) to know that the value of this variable can not be modified indirectly through a pointer.When at a certain point of the instruction stream, a register variable has its value assigned in a processor\xe2\x80\x99s register, and the register has not been used since to get the value of another variable, the compiler knows that it does not need to re-load the value of the variable in that register.\n This allows to avoid expensive useless memory access.Do your own tests and you will get significant performance improvements in your most inner loops.c_register_side_effect_performance_boostJust a little demo (without any real-world purpose) for comparison: when removing the register keywords before each variable, this piece of code takes 3.41 seconds on my i7 (GCC), with register the same code completes in 0.7 seconds.Register would notify the compiler that the coder believed this variable would be written/read enough to justify its storage in one of the few registers available for variable use.  Reading/writing from registers is usually faster and can require a smaller op-code set.Nowadays, this isn\'t very useful, as most compilers\' optimizers are better than you at determining whether a register should be used for that variable, and for how long.On supported C compilers it tries to optimize the code so that variable\'s value is held in an actual processor register.Microsoft\'s Visual C++ compiler ignores the register keyword when global register-allocation optimization (the /Oe compiler flag) is enabled.See register Keyword on MSDN.Register keyword tells compiler to store the particular variable in CPU registers so that it could be accessible fast. From a programmer\'s point of view register keyword is used for the variables which are heavily used in a program, so that compiler can speedup the code. Although it depends on the compiler whether to keep the variable in CPU registers or main memory.Storytime!C, as a language, is an abstraction of a computer. It allows you to do things, in terms of what a computer does, that is manipulate memory, do math, print things, etc.But C is only an abstraction. And ultimately, what it\'s extracting from you is Assembly language. Assembly is the language that a CPU reads, and if you use it, you do things in terms of the CPU. What does a CPU do? Basically, it reads from memory, does math, and writes to memory. The CPU doesn\'t just do math on numbers in memory. First, you have to move a number from memory to memory inside the CPU called a register. Once you\'re done doing whatever you need to do to this number, you can move it back to normal system memory. Why use system memory at all? Registers are limited in number. You only get about a hundred bytes in modern processors, and older popular processors were even more fantastically limited (The 6502 had 3 8-bit registers for your free use). So, your average math operation looks like:A lot of that is... not math. Those load and store operations can take up to half your processing time. C, being an abstraction of computers, freed the programmer the worry of using and juggling registers, and since the number and type vary between computers, C places the responsibility of register allocation solely on the compiler. With one exception.When you declare a variable register, you are telling the compiler "Yo, I intend for this variable to be used a lot and/or be short lived. If I were you, I\'d try to keep it in a register." When the C standard says compilers don\'t have to actually do anything, that\'s because the C standard doesn\'t know what computer you\'re compiling for, and it might be like the 6502 above, where all 3 registers are needed just to operate, and there\'s no spare register to keep your number. However, when it says you can\'t take the address, that\'s because registers don\'t have addresses. They\'re the processor\'s hands. Since the compiler doesn\'t have to give you an address, and since it can\'t have an address at all ever, several optimizations are now open to the compiler. It could, say, keep the number in a register always. It doesn\'t have to worry about where it\'s stored in computer memory (beyond needing to get it back again). It could even pun it into another variable, give it to another processor, give it a changing location, etc.tl;dr: Short-lived variables that do lots of math. Don\'t declare too many at once.Register indicates to compiler to optimize this code by storing that particular variable in registers then in memory. it is a request to compiler, compiler may or may not consider this request.\nYou can use this facility in case where some of your variable are being accessed very frequently.\nFor ex: A looping.One more thing is that if you declare a variable as register then you can\'t get its address as it is not stored in memory. it gets its allocation in CPU register.