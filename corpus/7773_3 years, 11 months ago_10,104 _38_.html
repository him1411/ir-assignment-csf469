I have a simple question about strings in Java. The following segment of simple code just concatenates two strings and then compares them with ==.The comparison expression concat=="string" returns false as obvious (I understand the difference between equals() and ==).When these two strings are declared final like so,The comparison expression concat=="string", in this case returns true. Why does final make a difference? Does it have to do something with the intern pool or I\'m just being misled?When you declare a String (which is immutable) variable as final, and initialize it with a compile-time constant expression, it also becomes a compile-time constant expression, and its value is inlined by the compiler where it is used. So, in your second code example, after inlining the values, the string concatenation is translated by the compiler to:which when compared to "string" will give you true, because string literals are interned.From JLS ยง4.12.4 - final Variables:A variable of primitive type or type String, that is final and initialized with a compile-time constant expression (\xc2\xa715.28), is called a constant variable.Also from JLS ยง15.28 - Constant Expression:Compile-time constant expressions of type String are always "interned" so as to share unique instances, using the method String#intern().This is not the case in your first code example, where the String variables are not final. So, they are not a compile-time constant expressions. The concatenation operation there will be delayed till runtime, thus leading to the creation of a new String object. You can verify this by comparing byte code of both the codes.The first code example (non-final version) is compiled to the following byte code:Clearly it is storing str and ing in two separate variables, and using StringBuilder to perform the concatenation operation.Whereas, your second code example (final version) looks like this:So it directly inlines the final variable to create String string at compile time, which is loaded by ldc operation in step 0. Then the second string literal is loaded by ldc operation in step 7. It doesn\'t involve creation of any new String object at runtime. The String is already known at compile time, and they are interned.As per my research, all the final String are interned in Java. From one of the blog post:So, if you really need to compare two String using == or != make sure you call String.intern() method before making comparison. Otherwise, always prefer String.equals(String) for String comparison.So it means if you call String.intern() you can compare two strings using == operator. But here String.intern() is not necessary because in Java final String are internally interned.You can find more information String comparision using == operator and Javadoc for String.intern() method.Also refer this Stackoverflow post for more information.If you take a look at this methods and its decompiled with javap -c ClassWithTheseMethods \nversions you will see andSo if Strings are not final compiler will have to use StringBuilder to concatenate str1 and str2 so will be compiled to which means that concat will be created at runtime so will not come from String pool.Also if Strings are final then compiler can assume that they will never change so instead of using StringBuilder it can safely concatenate its values socan be changed toand concatenated intowhich means that concate will become sting literal which will be interned in string pool and then compared with same string literal from that pool in if statement.Stack and string conts pool concept \nLet\'s see some byte code for the final exampleAt 0: and 2:, the String "string" is pushed onto the stack (from the constant pool) and stored into the local variable concat directly. You can deduce that the compiler is creating (concatenating) the String "string" itself at compilation time.The non final byte codeHere you have two String constants, "str" and "ing" which need to be concatenated at runtime with a StringBuilder.Though, when you create using String literal notation of Java, it automatically call intern() method to put that object into String pool, provided it was not present in the pool already. Why does final make a difference?   Compiler knows the final variable never gonna change, when we add these final variables the output  goes to String Pool because of str1 + str2 expression output also never gonna change, So finally compiler calls inter method after output of the above two final variables. In case of non-final variable compiler do not call intern method.