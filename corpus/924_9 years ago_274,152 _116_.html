I have noticed that some browsers (in particular, Firefox and Opera) are very zealous in using cached copies of .css and .js files, even between browser sessions. This leads to a problem when you update one of these files but the user\'s browser keeps on using the cached copy.The question is: what is the most elegant way of forcing the user\'s browser to reload the file when it has changed?Ideally the solution would not force the browser to reload the file on every visit to the page.  I will post my own solution as an answer, but I am curious if anyone has a better solution and I\'ll let your votes decide.Update:After allowing discussion here for a while, I have found John Millikin and da5id\'s suggestion to be useful. It turns out there is a term for this: auto-versioning.I have posted a new answer below which is a combination of my original solution and John\'s suggestion.Another idea which was suggested by SCdF would be to append a bogus query string to the file. (Some Python code to automatically use the timestamp as a bogus query string was submitted by pi.).  However, there is some discussion as to whether or not the browser would cache a file with a query string. (Remember, we want the browser to cache the file and use it on future visits. We only want it to fetch the file again when it has changed.)Since it is not clear what happens with a bogus query string, I am not accepting that answer.Update:  Rewritten to incorporate suggestions from John Millikin and da5id.  This solution is written in PHP, but should be easily adapted to other languages.Update 2: Incorporating comments from Nick Johnson that the original .htaccess regex can cause problems with files like json-1.3.js. Solution is to only rewrite if there are exactly 10 digits at the end. (Because 10 digits covers all timestamps from 9/9/2001 to 11/20/2286.)First, we use the following rewrite rule in .htaccess:Now, we write the following PHP function:Now, wherever you include your CSS, change it from this:To this:This way, you never have to modify the link tag again, and the user will always see the latest CSS.  The browser will be able to cache the CSS file, but when you make any changes to your CSS the browser will see this as a new URL, so it won\'t use the cached copy.This can also work with images, favicons, and JavaScript. Basically anything that is not dynamically generated.Simple Client-side TechniqueIn general, caching is good.. So there are a couple of techniques, depending on whether you\'re fixing the problem for yourself as you develop a website, or whether you\'re trying to control cache in a production environment.General visitors to your website won\'t have the same experience that you\'re having when you\'re developing the site.  Since the average visitor comes to the site less frequently (maybe only a few times each month, unless you\'re a Google or hi5 Networks), then they are less likely to have your files in cache, and that may be enough.  If you want to force a new version into the browser, you can always add a query string to the request, and bump up the version number when you make major changes: This will ensure that everyone gets the new file.  It works because the browser looks at the URL of the file to determine whether it has a copy in cache.  If your server isn\'t set up to do anything with the query string, it will be ignored, but the name will look like a new file to the browser.On the other hand, if you\'re developing a website, you don\'t want to change the version number every time you save a change to your development version.  That would be tedious.So while you\'re developing your site, a good trick would be to automatically generate a query string parameter:Adding a query string to the request is a good way to version a resource, but for a simple website this may be unnecessary.  And remember, caching is a good thing.It\'s also worth noting that the browser isn\'t necessarily stingy about keeping files in cache.  Browsers have policies for this sort of thing, and they are usually playing by the rules laid down in the HTTP specification.  When a browser makes a request to a server, part of the response is an EXPIRES header.. a date which tells the browser how long it should be kept in cache.  The next time the browser comes across a request for the same file, it sees that it has a copy in cache and looks to the EXPIRES date to decide whether it should be used.  So believe it or not, it\'s actually your server that is making that browser cache so persistent.  You could adjust your server settings and change the EXPIRES headers, but the little technique I\'ve written above is probably a much simpler way for you to go about it. Since caching is good, you usually want to set that date far into the future (a "Far-future Expires Header"), and use the technique described above to force a change.If you\'re interested in more info on HTTP or how these requests are made, a good book is "High Performance Web Sites" by Steve Souders.  It\'s a very good introduction to the subject.Google\'s mod_pagespeed plugin for apache will do auto-versioning for you.  It\'s really slick.It parses HTML on its way out of the webserver (works with PHP, rails, python, static HTML -- anything) and rewrites links to CSS, JS, image files so they include an id code.  It serves up the files at the modified URLs with a very long cache control on them.  When the files change, it automatically changes the URLs so the browser has to re-fetch them.  It basically just works, without any changes to your code.  It\'ll even minify your code on the way out too.Instead of changing the version manually, I would recommend you use an MD5 hash of the actual CSS file.So your URL would be something likeYou could still use the rewrite rule to strip out the hash, but the advantage is that now you can set your cache policy to "cache forever", since if the URL is the same, that means that the file is unchanged.You can then write a simple shell script that would compute the hash of the file and update your  tag (you\'d probably want to move it to a separate file for inclusion).Simply run that script every time CSS changes and you\'re good. The browser will ONLY reload your files when they are altered. If you make an edit and then undo it, there\'s no pain in figuring out which version you need to return to in order for your visitors not to re-download.You can just put ?foo=1234 at the end of your css / js import, changing 1234 to be whatever you like. Have a look at the SO html source for an example.The idea there being that the ? parameters are discarded / ignored on the request anyway and you can change that number when you roll out a new version.Note: There is some argument with regard to exactly how this affects caching. I believe the general gist of it is that GET requests, with or without parameters should be cachable, so the above solution should work.However, it is down to both the web server to decide if it wants to adhere to that part of the spec and the browser the user uses, as it can just go right ahead and ask for a fresh version anyway.Not sure why you guys are taking so much pain to implement this solution.All you need to do if get the file\'s modified timestamp and append it as a querystring to the fileIn PHP i would do it as:filemtime is a PHP function that returns the file modified timestamp.I\'ve heard this called "auto versioning". The most common method is to include the static file\'s mtime somewhere in the URL, and strip it out using rewrite handlers or URL confs:See also:Dont use foo.css?version=1! Browsers aren\'t supposed to cache URLs with GET variables. According to http://www.thinkvitamin.com/features/webapps/serving-javascript-fast, though IE and Firefox ignore this, Opera and Safari don\'t! Instead, use foo.v1234.css, and use rewrite rules to strip out the version number.The 30 or so existing answers are great advice for a circa 2008 website.  However, when it comes to a modern, single page application (SPA), it might be time to re-think some fundamental assumptions\xe2\x80\xa6 specifically the idea that it is desirable for the web server to serve only the single, most recent version of a file.Imagine you\'re a user that has version M of a SPA loaded into your browser:If the format of /some.template changed between versions M and N (or the file was renamed or whatever) you probably don\'t want version N of the template sent to the browser that\'s running the old version M of the parser.\xe2\x80\xa0Web apps run into this issue when two conditions are met:Once your app needs to serve up multiple versions in parallel, solving caching and "reloading" becomes trivial:That last step sounds tricky, as it could require calling a URL builder for every URL in your server-side or client-side code.  Or you could just make clever use of the <base> tag and change the current version in one place.\xe2\x80\xa0 One way around this is to be aggressive about forcing the browser to reload everything when a new version is released.  But for the sake of letting any in-progress operations to complete, it may still be easiest to support at least two versions in parallel: v-current and v-previous.The RewriteRule needs a small update for js or css files that contain a dot notation versioning at the end. E.g. json-1.3.js.I added a dot negation class [^.] to the regex so .number. is ignored.Interesting post. Having read all the answers here combined with the fact that I have never had any problems with "bogus" query strings (which I am unsure why everyone is so reluctant to use this) I guess the solution (which removes the need for apache rewrite rules as in the accepted answer) is to compute a short HASH of the CSS file contents (instead of the file datetime) as a bogus querystring.This would result in the following:Of course the datetime solutions also get the job done in the case of editing a CSS file but I think it is about the css file content and not about the file datetime, so why get these mixed up?For ASP.NET 4.5 and greater you can use script bundling.The request http://localhost/MvcBM_time/bundles/AllMyScripts?v=r0sLDicvP58AIXN_mc3QdyVvVj5euZNzdsa2N1PKvb81 is for the bundle AllMyScripts and contains a query string pair v=r0sLDicvP58AIXN_mc3QdyVvVj5euZNzdsa2N1PKvb81. The query string v has a value token that is a unique identifier used for caching. As long as the bundle doesn\'t change, the ASP.NET application will request the AllMyScripts  bundle using this token. If any file in the bundle changes, the ASP.NET optimization framework will generate a new token, guaranteeing that browser requests for the bundle will get the latest bundle.There are other benefits to bundling including increased performance on first time page loads with minification.You can force a "session-wide caching" if you add the session-id as a spureous parameter of the js/css file:If you want a version-wide caching you could add some code to print the file date or similar. If you\'re using Java you can use a custom-tag to generate the link in an elegant way.Say you have a file available at:your can either append a query parameter with version information onto the URI, e.g.:or you can prepend version information, e.g.:IMHO the second method is better for CSS files because they can refer to images using relative URLs which means that if you specify a background-image like so:its URL will effectively be:This means that if you update the version number used the server will treat this as a new resource and not use a cached version. If you base your version number on the Subversion/CVS/etc. revision this means that changes to images referenced in CSS files will be noticed. That isn\'t guaranteed with the first scheme, i.e. the URL images/happy.gif relative to /styles/screen.css?v=1235 is /styles/images/happy.gif which doesn\'t contain any version information.I have implemented a caching solution using this technique with Java servlets and simply handle requests to /v/* with a servlet that delegates to the underlying resource (i.e. /styles/screen.css). In development mode I set caching headers that tell the client to always check the freshness of the resource with the server (this typically results in a 304 if you delegate to Tomcat\'s DefaultServlet and the .css, .js, etc. file hasn\'t changed) while in deployment mode I set headers that say "cache forever".Thanks at Kip for his perfect solution!I extended it to use it as an Zend_view_Helper. Because my client run his page on a virtual host I also extended it for that.Hope it helps someone else too.Cheers and thanks.Here is a pure JavaScript solutionThe above will look for the last time the user visited your site.  If the last visit was before you released new code, it uses location.reload(true) to force page refresh from server.  I usually have this as the very first script within the <head> so it\'s evaluated before any other content loads.  If a reload needs to occurs, it\'s hardly noticeable to the user.I am using local storage to store the last visit timestamp on the browser, but you can add cookies to the mix if you\'re looking to support older versions of IE.I recently solved this using Python. Here the code (should be easy to adopt to other languages):This code basically appends the files time-stamp as a query parameter to the URL. The call of the following functionwill result inThe advantage of course is that you do never have to change your html again, touching the CSS file will automatically trigger a cache invalidation. Works very good and the overhead is not noticeable.You could simply add some random number with the CSS/JS url likeFor ASP.NET I suppose next solution with advanced options (debug/release mode, versions):Js or Css files included by such way:Global.JsPostfix and Global.CssPostfix is calculated by the following way in Global.asax:Have not found the client sided DOM approach creating the script node (or css) element dynamically:I suggest implementing the following process:version your css/js files whenever you deploy, something like: screen.1233.css    (the number can be your SVN revision if you use a versioning system)minify them to optimize loading timesFor my development, I find that chrome has a great solution.https://developer.chrome.com/devtools/docs/tips-and-tricks#hard-reloadWith developer tools open, simply long click the refresh button and let go once you hover over "Empty Cache and Hard Reload".This is my best friend, and is a super light weight way to get what you want!In Laravel (PHP) we can do it in following clear and elegant way (using file modification timestamp):And similar for CSSI put an MD5 hash of the file\'s contents in its URL.  That way I can set a very long expiration date, and don\'t have to worry about users having old JS or CSS.I also calculate this once per file at runtime (or on file system changes) so there\'s nothing funny to do at design time or during the build process.If you\'re using ASP.NET MVC then you can check out the code in my other answer here.If you are using a modern browser, you could use a manifest file to inform the browsers which files need to be updated. This requires no headers, no versions in urls etc...For more details, see:\nSee: https://developer.mozilla.org/nl/docs/Web/HTML/Applicatie_cache_gebruiken#IntroductionI\'m adding this answer as a SilverStripe http://www.silverstripe.org specific answer which I was looking for and never found but have worked out from reading: http://api.silverstripe.org/3.0/source-class-SS_Datetime.html#98-110Hopefully this will help someone using a SilverStripe template and trying to force reload a cached image on each page visit / refresh. In my case it is a gif animation which only plays once and therefor did not replay after it was cached. In my template I simply added:to the end of the file path to create a unique time stamp and to force the browser to treat it as a new file. It seems all answers here suggest some sort of versioning in the naming scheme, which has its downsides.Browsers should be well aware of what to cache and what not to cache by reading the webservers response, in particular the http headers - for how long is this resource valid ? was this resource updated since I last retrieved it ? etcetera. If things are configured \'correctly\', just updating the files of your application should (at some point) refresh the browsers caches. You can for example configure your web server to tell the browser to never cache files (which is a bad idea). A more in-depth explanation of how that works is here\nhttps://www.mnot.net/cache_docs/#WORKMy method to do this is simply to have the link element into a server-side include:where the contents of css-element.txt isso the day you want to link to my-new-css.css or whatever, you just change the include.Sorry for bringing back a dead thread. @TomA is right. Using "querystring" method will not be cached as quoted by Steve Souders below:...that Squid, a popular proxy, doesn\xe2\x80\x99t cache resources with a\n  querystring.@TomA suggestion of using style.TIMESTAMP.css is good, but MD5 would be much better as only when the contents were genuinely changed, the MD5 changes as well.I see a problem with the approach of using a timestamp- or hash-based differentiator in the resource URL which gets stripped out on request at the server. The page that contains the link to e.g. the style sheet might get cached as well. So the cached page might request an older version of the style sheet but will be served the latest version, which might or might not work with the requesting page.To fix this, you either have to guard the requesting page with a no-cache header or meta, to make sure it gets refreshed on every load. Or you have to maintain all versions of the style file that you ever deployed on the server, each as an individual file and with their differentiator intact, so that the requesting page can get at the version of the style file it was designed for. In the latter case you basically tie the versions of the HTML page and the style sheet together, which can be done statically and doesn\'t require any server logic.