I want to use the PI constant and trigonometric functions in some C++ program. I get the trigonometric functions with include <math.h>. However, there doesn\'t seem to be a definition for PI in this header file.How can I get PI without defining it manually?On some (especially older) platforms (see the comments below) you might need toand then include the necessary header file:and the value of pi can be accessed via:In my math.h (2014) it is defined as: but check your math.h for more. An extract from the "old" math.h (in 2009):However:on newer platforms (at least on my 64 bit Ubuntu 14.04) I do not need to define the _USE_MATH_DEFINES On (recent) Linux platforms there are long double values too provided as a GNU Extension:Pi can be calculated as atan(1)*4. You could calculate the value this way and cache it.You could also use boost, which defines important math constants with maximum accuracy for the requested type (i.e. float vs double).  Check out the boost documentation for more examples.I would recommend just typing in pi to the precision you need.  This would add no calculation time to your execution, and it would be portable without using any headers or #defines.  Calculating acos or atan is always more expensive than using a precalculated value.Rather than writingI would recommend using -D_USE_MATH_DEFINES or /D_USE_MATH_DEFINES depending on your compiler.This way you are assured that even in the event of someone including the header before you do (and without the #define) you will still have the constants instead of an obscure compiler error that you will take ages to track down.Get it from the FPU unit on chip instead:Since the official standard library doesn\'t define a constant PI you would have to define it yourself. So the answer to your question "How can I get PI without defining it manually?" is "You don\'t -- or you rely on some compiler-specific extensions.". If you\'re not concerned about portability you could check your compiler\'s manual for this.C++ allows you to writebut the initialization of this constant is not guaranteed to be static. The G++ compiler however handles those math functions as intrinsics and is able to compute this constant expression at compile-time.From the Posix man page of math.h:Standard C++ doesn\'t have a constant for PI.Many C++ compilers define M_PI in cmath (or in math.h for C) as a non-standard extension.  You may have to #define _USE_MATH_DEFINES before you can see it.I generally prefer defining my own: const double PI = 2*acos(0.0); because not all implementations provide it for you.The question of whether this function gets called at runtime or is static\'ed out at compile time is usually not an issue, because it only happens once anyway.I would doorI would not typing in \xcf\x80 to the precision you need. What is that even supposed to mean? The precision you need is the precision of T, but we know nothing about T.You might say: What are you talking about? T will be float, double or long double. So, just type in the precision of long double, i.e.But do you really know that there won\'t be a new floating point type in the standard in the future with an even higher precision than long double? You don\'t.And that\'s why the first solution is beautiful. You can be quite sure that the standard would overload the trigonometric functions for a new type.And please, don\'t say that the evaluation of a trigonometric function at initialization is a performance penalty.I use following in one of my common header in the project that covers all bases:On a side note, all of below compilers define M_PI and M_PIl constants if you include <cmath>. There is no need to add `#define _USE_MATH_DEFINES which is only required for VC++.On windows (cygwin + g++), I\'ve found it necessary to add the flag -D_XOPEN_SOURCE=500 for the preprocessor to process the definition of M_PI in math.h.C++14 lets you do static constexpr auto pi = acos(-1);You can do this:If M_PI is already defined in cmath, this won\'t do anything else than include cmath. If M_PI isn\'t defined (which is the case for example in Visual Studio), it will define it. In both cases, you can use M_PI to get the value of pi.This value of pi comes from Qt Creator\'s qmath.h.