I came across Xamarin claims that their Mono implementation on Android and their C# compiled apps are faster than Java code. Did anyone perform actual benchmarks on very similar Java and C# code on different Android platforms to verify such claims, could post the code and results?Since there was no answer and could not find such benchmarks done by others, decided to do my own tests. Unfortunately, my question remains "locked" so I cannot post this as answer, only edit the question. Please vote to re-open this question. For C#, I used Xamarin.Android ver. 4.7.09001 (beta). The source code, all the data I used for testing, and compiled APK packages are on GitHub:Java: https://github.com/gregko/TtsSetup_JavaC#: https://github.com/gregko/TtsSetup_C_sharpIf someone would like to repeat my tests on other devices or emulators, I\'d be interested to learn the results as well.I ported my sentence extractor class to C# (from my @Voice Aloud Reader app) and run some tests on 10 html files in English, Russian, French, Polish and Czech languages. Each run was performed 5 times on all 10 files, and the total time for 3 different devices and one emulator are posted below. I tested "Release" builds only, without debugging enabled.Java: Grand total time (5 runs): 12361 ms, with file reading total: 13304 msC#: Grand total time (5 runs): 17504 ms, with file reading total: 17956 msJava: Grand total time (5 runs): 8947 ms, with file reading total: 9186 msC#: Grand total time (5 runs): 9884 ms, with file reading total: 10247 msJava: Grand total time (5 runs): 9742 ms, with file reading total: 10111 msC#: Grand total time (5 runs): 10459 ms, with file reading total: 10696 msJava: Grand total time (5 runs): 2699 ms, with file reading total: 3127 msC#: Grand total time (5 runs): 2049 ms, with file reading total: 2182 msJava: Grand total time (5 runs): 2992 ms, with file reading total: 3591 msC#: Grand total time (5 runs): 2049 ms, with file reading total: 2257 msJava: Grand total time (5 runs): 41751 ms, with file reading total: 43866 msC#: Grand total time (5 runs): 44136 ms, with file reading total: 45109 msMy test code contains mainly text parsing, replacing and Regex searches, perhaps for other code (e.g. more numeric operations) the results would be different. On all devices with ARM processors, Java performed better than Xamarin C# code. The largest difference was under Android 2.3, where C# code run at approx. 70% of Java speed.On Intel emulator (with Intel HAX technology, emulator runs in fast virt mode), Xamarin C# code runs my sample code much faster than Java - about 1.35 time faster. Maybe Mono virtual machine code and libraries are much better optimized on Intel than on ARM?I just installed Genymotion Android emulator, which runs in Oracle VirtualBox, and again this one uses native Intel processor, not emulating ARM processor. As with Intel HAX emulator, again C# runs here much faster. Here are my results:Java:\n  Grand total time (5 runs): 2069 ms, with file reading total: 2248 msC#:\n  Grand total time (5 runs): 1543 ms, with file reading total: 1642 msI then noticed that there was an update to Xamarin.Android beta, version 4.7.11, with release notes mentioning some changes in Mono runtime as well. Decided to quickly test some ARM devices, and big surprise - C# numbers improved:Java: Grand total time (5 runs): 8103 ms, with file reading total: 8569 msC#: Grand total time (5 runs): 7951 ms, with file reading total: 8161 msWow! C# is now better than Java? Decided to repeat the test on my Galaxy Note 2:Java: Grand total time (5 runs): 9675 ms, with file reading total: 10028 msC#: Grand total time (5 runs): 9911 ms, with file reading total: 10104 msHere C# seems to be only slightly slower, but these numbers gave me a pause: Why the time is longer than on Nook HD+, even though Note 2 has a faster processor? The answer: power saving mode. On Nook, it was disabled, on Note 2 - enabled. Decided to test with power saving mode disabled (as with enabled, it also limits the processor speed):Java: Grand total time (5 runs): 7153 ms, with file reading total: 7459 msC#: Grand total time (5 runs): 6906 ms, with file reading total: 7070 msNow, surprisingly, C# is slightly faster than Java on ARM processor as well. Big improvement!We all know, that nothing beats native code for speed, and I was not satisfied with the performance of my sentence splitter in Java or C#, particularly that I need to improve it (and thus make it even slower). Decided to re-write it in C++. Here is a small (i.e. a smaller set of files than previous tests, for other reasons) comparison of the speed of native vs. Java on my Galaxy Note 2, with power saving mode disabled:Java:\nGrand total time (5 runs): 3292 ms, with file reading total: 3454 msNative thumb:\nGrand total time (5 runs): 537 ms, with file reading total: 657 msNative arm:\nGrand total time (5 runs): 458 ms, with file reading total: 587 msLooks like for my particular test, the native code is 6 to 7 times faster than Java. Caveat: could not use std::regex class on Android, so had to write my own specialized routines searching for paragraphs breaks or html tags. My initial tests of the same code on a PC using regex, were about 4 to 5 times faster than Java.Phew! Waking raw memory with char* or wchar* pointers again, I instantly felt 20 years younger! :)(Please see below, with edits of 7/30/2013, for much better results with Dot42)With some difficulty I manged to port my C# tests to Dot42 (version 1.0.1.71 beta), another C# platform for Android. Preliminary results show that Dot42 code is about 3x (3 times) slower than Xamarin C# (v. 4.7.11), on an Intel Android emulator. One problem is, that System.Text.RegularExpressions class in Dot42 does not have the Split() function that I used in Xamarin tests, so I used Java.Util.Regex class instead, and Java.Util.Regex.Pattern.Split(), so in this particular place in the code there is this small difference. Should not be a big problem though. Dot42 compiles to Dalvik (DEX) code, so it cooperates with Java on Android natively, does not need expensive interop from C# to Java like Xamarin.Just for comparison, I also run the test on ARM devices - here Dot42 code is "only" 2x slower than Xamarin C#. Here are my results:Java: Grand total time (5 runs): 12187 ms, with file reading total: 13200 msXamarin C#: Grand total time (5 runs): 13935 ms, with file reading total: 14465 msDot42 C#: Grand total time (5 runs): 26000 ms, with file reading total: 27168 msJava: Grand total time (5 runs): 6895 ms, with file reading total: 7275 msXamarin C#: Grand total time (5 runs): 6466 ms, with file reading total: 6720 msDot42 C#: Grand total time (5 runs): 11185 ms, with file reading total: 11843 msJava: Grand total time (5 runs): 2389 ms, with file reading total: 2770 msXamarin C#: Grand total time (5 runs): 1748 ms, with file reading total: 1933 msDot42 C#: Grand total time (5 runs): 5150 ms, with file reading total: 5459 msTo me it was also interesting to note that Xamarin C# is slightly faster than Java on a newer ARM device, and slightly slower on the old Nexus One. If anyone would like to run these tests as well, please let me know and I\'ll update the sources on GitHub. It would be particularly interesting to see results from a real Android device with Intel processor.Just a quick update, re-compiled by benchmark apps with the latest Xamarin.Android 4.8, and also with dot42 1.0.1.72 update released today - no significant changes from the results reported before.Re-tested Dot42 with Robert\'s (from dot42 makers) port of my Java code to C#. In my C# port done initially for Xamarin, I replaced some native Java classes, like ListArray, with List class native to C#, etc. Robert did not have my Dot42 source code, so he ported it again from Java and used original Java classes in such places, which benefits Dot42, I guess because it runs in Dalvik VM, like Java, and not in Mono, like Xamarin. Now Dot42 results are much better. Here is a log from my testing:Dot42, Greg\'s Code using StringBuilder.Replace() (as in Xamarin):\n  Grand total time (5 runs): 3646 ms, with file reading total: 3830 ms Dot42, Greg\'s Code using String.Replace() (as in Java and Robert\'s code):\n  Grand total time (5 runs): 3027 ms, with file reading total: 3206 msDot42, Robert\'s Code:\n  Grand total time (5 runs): 1781 ms, with file reading total: 1999 msXamarin:\n  Grand total time (5 runs): 1373 ms, with file reading total: 1505 msJava:\n  Grand total time (5 runs): 1841 ms, with file reading total: 2044 msDot42, Greg\'s Code using StringBuilder.Replace() (as in Xamarin):\n  Grand total time (5 runs): 10875 ms, with file reading total: 11280 msDot42, Greg\'s Code using String.Replace() (as in Java and Robert\'s code):\n  Grand total time (5 runs): 9710 ms, with file reading total: 10097 msDot42, Robert\'s Code:\n  Grand total time (5 runs): 6279 ms, with file reading total: 6622 msXamarin:\n  Grand total time (5 runs): 6201 ms, with file reading total: 6476 msJava:\n  Grand total time (5 runs): 7141 ms, with file reading total: 7479 msI still think that Dot42 has a long way to go. Having Java-like classes (e.g. ArrayList) and a good performance with them, would make porting code from Java to C# slightly easier. However, this is something I would not be likely to do a lot. I would rather want to use existing C# code (libraries etc.), which will use native C# classes (e.g. List), and that would perform slowly with the current dot42 code, and very well with Xamarin.GregYeah, Xamarin\'s Mono virtual machine is more impressive than Google\'s Dalvik used in Android. I have tested it with HTC Flyer  and Acer Iconia Tab tablets to benchmark the C# port of Android through Mono against Java Dalvik, with the C# implementation of Android well and truly trouncing the Java-based Dalvik.https://medium.com/@harrycheung/mobile-app-performance-redux-e512be94f976#.kfbauchtzHope this information helps.This is another more updated blog post I would like to share with you. He compares Xamarin to native code and Cordova on both IOs and Android.In a nutshell, Xamarin performs sometimes better than native code. He tested the app size, load times, loading a list from Azure service and prime number computation.Enjoy!Edit: I updated the dead link and I noticed that there is a part 2We recently investigated using Xamarin for an app. We utilized the C# code we had already written for the Windows RT version of our app. Some specific details had to be rewritten for the Android version.What we discovered is that I/O in Xamarin C# is approximately 2x slower than Java. Our app is heavily I/O bound. We have not discovered the cause of this yet, but at the moment we are assuming that it is due to marshaling. While we do try to stay inside the Mono VM most of the time, we do not know how Mono actually accesses the disk.It is also telling that our C# code uses SQLite.NET (https://github.com/praeclarum/sqlite-net). Identical fetches using the SQLite.NET code are also 2x slower than using Android\'s Java SQLite wrapper. After looking at the source code, it appears to bind directly to the C .dll, so I do not know why it\'s so much slower. One possibility is that marshaling strings from native to Java may be faster on Android than native to C# is on Xamarin.