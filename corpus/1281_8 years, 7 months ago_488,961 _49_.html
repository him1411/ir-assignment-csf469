I am playing with LINQ to learn about it, but I can\'t figure out how to use Distinct when I do not have a simple list (a simple list of integers is pretty easy to do, this is not the question). What I if want to use Distinct on a list of an Object on one or more properties of the object?Example: If an object is Person, with Property Id. How can I get all Person and use Distinct on them with the property Id of the object?How can I get just Person1 and Person3? Is that possible?If it\'s not possible with LINQ, what would be the best way to have a list of Person depending on some of its properties in .NET 3.5?EDIT: This is now part of MoreLINQ.What you need is a "distinct-by" effectively. I don\'t believe it\'s part of LINQ as it stands, although it\'s fairly easy to write:So to find the distinct values using just the Id property, you could use:And to use multiple properties, you can use anonymous types, which implement equality appropriately:Untested, but it should work (and it now at least compiles).It assumes the default comparer for the keys though - if you want to pass in an equality comparer, just pass it on to the HashSet constructor.What if I want to obtain a distinct list based on one or more properties?Simple! You want to group them and pick a winner out of the group.If you want to define groups on multiple properties, here\'s how:You could also use query syntax if you want it to look all LINQ-like:I think it is enough:Use:The where helps you filter the entries (could be more complex) and the groupby and select perform the distinct function.The following code is functionally equivalent to Jon Skeet\'s answer.Tested on .NET 4.5, should work on any earlier version of LINQ.Incidentially, check out Jon Skeet\'s latest version of DistinctBy.cs on Google Code.You can do this with the standard Linq.ToLookup(). This will create a collection of values for each unique key. Just select the first item in the collectionI\'ve written an article that explains how to extend the Distinct function so that you can do as follows:Here\'s the article: Extending LINQ - Specifying a Property in the Distinct FunctionIn case you need a Distinct method on multiple properties, you can check out my PowerfulExtensions library. Currently it\'s in a very young stage, but already you can use methods like Distinct, Union, Intersect, Except on any number of properties;This is how you use it:You can do it (albeit not lightning-quickly) like so:That is, "select all people where there isn\'t another different person in the list with the same ID."Mind you, in your example, that would just select person 3.  I\'m not sure how to tell which you want, out of the previous two.When we faced such a task in our project we defined a small API to compose comparators.So, the use case was like this:And API itself looks like this:More details is on our site: IEqualityComparer in LINQ.Personally I use the following class:Then, an extension method:Finally, the intended usage:The advantage I found using this approach is the re-usage of LambdaEqualityComparer class for other methods that accept an IEqualityComparer. (Oh, and I leave the yield stuff to the original LINQ implementation...)The best way to do this that will be compatible with other .NET versions is to override Equals and GetHash to handle this (see Stack Overflow question This code returns distinct values. However, what I want is to return a strongly typed collection as opposed to an anonymous type), but if you need something that is generic throughout your code, the solutions in this article are great.Solution first group by your fields then select firstordefault item.You should be able to override Equals on person to actually do Equals on Person.id.  This ought to result in the behavior you\'re after.If you don\'t want to add the MoreLinq library to your project just to get the DistinctBy functionality then you can get the same end result using the overload of Linq\'s Distinct method that takes in an IEqualityComparer argument.You begin by creating a generic custom equality comparer class that uses lambda syntax to perform custom comparison of two instances of a generic class:Then in your main code you use it like so:Voila!  :)The above assumes the following:If the collection could contain nulls then simply rewrite the lambdas to check for null, e.g.:EDITThis approach is similar to the one in Vladimir Nesterovsky\'s answer but simpler. It is also similar to the one in Joel\'s answer but allows for complex comparison logic involving multiple properties. However, if your objects can only ever differ by Id then another user gave the correct answer that all you need to do is override the default implementations of GetHashCode() and Equals() in your Person class and then just use the out-of-the-box Distinct() method of Linq to filter out any duplicates.