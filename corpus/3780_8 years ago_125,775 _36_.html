I\'m using Core Data to locally persist results from a Web Services call. The web service returns the full object model for, let\'s say, "Cars" - could be about 2000 of them (and I can\'t make the Web Service return anything less than 1 or ALL cars.The next time I open my application, I want to refresh the Core Data persisted copy by calling the Web Service for all Cars again, however to prevent duplicates I would need to purge all data in the local cache first.Is there a quicker way to purge ALL instances of a specific entity in the managed object context (e.g. all entities of type "CAR"), or do I need to query them call, then iterate through the results to delete each, then save?Ideally I could just say delete all where entity is Blah.iOS 9 added a new class called NSBatchDeleteRequest that allows you to easily delete objects matching a predicate without having to load them all in to memory. Here\'s how you\'d use it:More information about batch deletions can be found in the "What\'s New in Core Data" session from WWDC 2015 (starting at ~14:10).Fetch \'em all and delete \'em all:A little bit more cleaned and universal : Add this method :For Swift 2.0:Swift:This is a similar question to the one here and someone suggested setting up a relationship delete rule so you only have to delete one object. So if you have or can make an entity with a to-many relationship to the cars and set the delete rule to cascade when you delete the higher entity all the cars will be deleted as well. This may save some processing time since you don\'t have to do the steps involved with loading ALL the cars. In a larger data set this could be absolutely necessary. A good answer was already posted, this is only a recommendation!A good way would be to just add a category to NSManagedObject and implement a method like I did:Header File (e.g. NSManagedObject+Ext.h)Code File: (e.g. NSManagedObject+Ext.m)... the only thing you have to is to get the managedObjectContext from the app delegate, or where every you have it in ;)afterwards you can use it like:one further optimization could be that you remove the parameter for tha entityname and get the name instead from the clazzname. this would lead to the usage:a more clean impl (as category to NSManagedObjectContext):The usage then:Extending Dave Delong\'s answer.Swift Version that takes care of iOS 9 and previous versions as well. I have also covered Error handling in this:let appDelegate: AppDelegate = UIApplication.sharedApplication().delegate as! AppDelegateReset Entity in Swift 3 : Why not fold in the data that you receive with the existing cache? Otherwise it\'s not really \'refreshing\', it\'s \'starting again\' and you might as well drop/delete the SQLLite file and start again (assuming you\'re not persisting other data as well).if the entity contains a lot of entries the best way is like this because it saves memory   iOS 10 and laterWorks with all versions. Pass entity name and iterate through to delete all the entries and save the context.Dave Delongs\'s Swift 2.0 answer was crashing for me (in iOS 9)But this worked:iOS 9.0 and Later :NSBatchDeleteRequest is used to delete records in core data. It works very fast and takes less time to delete all records from an entity. It requires NSFetchRequest in argument. If you want to delete all records from an entity , you can use it and it works for me. let manageObject:NSManagedObjectContext = appDelegateObject.managedObjectContextSwift 3 solution with iOS 9 \'NSBatchDeleteRequest\' and fallback to earlier iOS versions implemented as an extension on \'NSManagedObjectContext\'. Apple reference https://developer.apple.com/library/content/featuredarticles/CoreData_Batch_Guide/BatchDeletes/BatchDeletes.htmlIn Swift 2.0:The quickest way is just reinstall your application on your simulator/ios device