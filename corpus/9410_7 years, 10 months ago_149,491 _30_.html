I have a string vaguely like this:that I want to split by commas -- but I need to ignore commas in quotes. How can I do this? Seems like a regexp approach fails; I suppose I can manually scan and enter a different mode when I see a quote, but it would be nice to use preexisting libraries. (edit: I guess I meant libraries that are already part of the JDK or already part of a commonly-used libraries like Apache Commons.)the above string should split into:note: this is NOT a CSV file, it\'s a single string contained in a file with a larger overall structureTry:Output:In other words: split on the comma only if that comma has zero, or an even number of quotes ahead of it.Or, a bit friendlier for the eyes:which produces the same as the first example.As mentioned by @MikeFHay in the comments:I prefer using Guava\'s Splitter, as it has saner defaults (see discussion above about empty matches being trimmed by String#split(), so I did: While I do like regular expressions in general, for this kind of state-dependent tokenization I believe a simple parser (which in this case is much simpler than that word might make it sound) is probably a cleaner solution, in particular with regards to maintainability, e.g.:If you don\'t care about preserving the commas inside the quotes you could simplify this approach (no handling of start index, no last character special case) by replacing your commas in quotes by something else and then split at commas:http://sourceforge.net/projects/javacsv/https://github.com/pupi1985/JavaCSV-Reloaded\n(fork of the previous library that will allow the generated output to have Windows line terminators \\r\\n when not running Windows)http://opencsv.sourceforge.net/CSV API for JavaCan you recommend a Java library for reading (and possibly writing) CSV files?Java lib or app to convert CSV to XML file?I would not advise a regex answer from Bart, I find parsing solution better in this particular case (as Fabian proposed). I\'ve tried regex solution and own parsing implementation I have found that:My solution and test below.Of course you are free to change switch to else-ifs in this snippet if you feel uncomfortable with its ugliness. Note then lack of break after switch with separator. StringBuilder was chosen instead to StringBuffer by design to increase speed, where thread safety is irrelevant.Try a lookaround like (?!\\"),(?!\\"). This should match , that are not surrounded by ".You\'re in that annoying boundary area where regexps almost won\'t do (as has been pointed out by Bart, escaping the quotes would make life hard) , and yet a full-blown parser seems like overkill. If you are likely to need greater complexity any time soon I would go looking for a parser library. For example this oneI was impatient and chose not to wait for answers... for reference it doesn\'t look that hard to do something like this (which works for my application, I don\'t need to worry about escaped quotes, as the stuff in quotes is limited to a few constrained forms):(exercise for the reader: extend to handling escaped quotes by looking for backslashes also.)Rather than use lookahead and other crazy regex, just pull out the quotes first. That is, for every quote grouping, replace that grouping with __IDENTIFIER_1 or some other indicator, and map that grouping to a map of string,string.After you split on comma, replace all mapped identifiers with the original string values. I would do something like this: