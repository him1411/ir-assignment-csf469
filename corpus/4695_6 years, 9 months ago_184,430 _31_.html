Hibernate throws this exception during SessionFactory creation:org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bagsThis is my test case:Parent.javaChild.javaHow about this problem? What can I do?EDITOK, the problem I have is that another "parent" entity is inside my parent, my real behavior is this:Parent.javaAnotherParent.javaHibernate doesn\'t like two collections with FetchType.EAGER, but this seems to be a bug, I\'m not doing unusual things...Removing FetchType.EAGER from Parent or AnotherParent solves the problem, but I need it, so real solution is to use @LazyCollection(LazyCollectionOption.FALSE) instead of FetchType (thanks to Bozho for the solution).I think a newer version of hibernate (supporting JPA 2.0) should handle this. But otherwise you can work it around by annotating the collection fields with:Remember to remove the fetchType attribute from the @*ToMany annotation.But note that in most cases a Set<Child> is more appropriate than List<Child>, so unless you really need a List - go for SetSimply change from List type to Set type.Alternatively add a Hibernate-specific @Fetch annotation to your code:This should fix the issue, related to Hibernate bug HHH-1718After trying with every single option describe in this posts and others, I came to the conclusion that the the fix is a follows.In every XToMany place @XXXToMany(mappedBy="parent", fetch=FetchType.EAGER)\nand intermediately afterThis worked for meTo fix it simply take Set in place of List for your nested object.and don\'t forget to use fetch=FetchType.EAGERit will work.There is one more concept CollectionId in Hibernate if you want to stick with list only.I found a good Blog post about the behaviour of Hibernate in this kind of object mappings: http://blog.eyallupu.com/2010/06/hibernate-exception-simultaneously.htmlyou can keep booth EAGER lists in JPA and add to at least one of them the JPA annotation @OrderColumn (with obviously the name of a field to be ordered). No need of specific hibernate annotations.\nBut keep in mind it could create empty elements in the list if the chosen field does not have values starting from 0in Children then you should add the orderIndex field When you have too complex objects with saveral collection could not be good idea to have all of them with EAGER fetchType, better use LAZY and when you really need to load the collections use: Hibernate.initialize(parent.child) to fetch the data.You could use a new annotation to solve this:In fact, fetch\'s default value is FetchType.LAZY too.