I\'m trying to combine the slice [1, 2] and the slice [3, 4]. How can I do this in Go?I tried:but got:However, the documentation seems to indicate this is possible, what am I missing?Add dots after the second slice:This is just like any other variadic function.Appending to and copying slicesThe variadic function append appends zero or more values x to s\n  of type S, which must be a slice type, and returns the resulting\n  slice, also of type S. The values x are passed to a parameter of\n  type ...T where T is the element type of S and the respective\n  parameter passing rules apply. As a special case, append also accepts\n  a first argument assignable to type []byte with a second argument of\n  string type followed by .... This form appends the bytes of the\n  string.Passing arguments to ... parametersIf f is variadic with final parameter type ...T, then within the\n  function the argument is equivalent to a parameter of type []T. At\n  each call of f, the argument passed to the final parameter is a new\n  slice of type []T whose successive elements are the actual arguments,\n  which all must be assignable to the type T. The length of the slice is\n  therefore the number of arguments bound to the final parameter and may\n  differ for each call site.The answer to your question is example s3 := append(s2, s0...) in the Go Programming Language Specification. For example,Nothing against the other answers, but I found the brief explanation in the docs more easily understandable than the examples in them:func append(slice []Type, elems ...Type) []Type The append built-in\n  function appends elements to the end of a slice. If it has sufficient\n  capacity, the destination is resliced to accommodate the new elements.\n  If it does not, a new underlying array will be allocated. Append\n  returns the updated slice. It is therefore necessary to store the\n  result of append, often in the variable holding the slice itself:As a special case, it is legal to append a string to a byte slice,\n  like this:I think it\'s important to point out and to know that if the destination slice (the slice you append to) has sufficient capacity, the append will happen "in-place", by reslicing the destination (reslicing to increase its length).This means that if the destination is created by slicing a bigger array or slice which has additional elements beyond the length of the resulting slice, they may get overwritten.To demonstrate, see this example:Output (try it on the Go Playground):We created a "backing" array a with length 10. Then we create the x destination slice by slicing this a array, y slice is created using the composite literal []int{3, 4}. Now when we append y to x, the result is the expected [1 2 3 4], but what may be surprising is that the backing array a also changed, because capacity of x is 10 which is sufficient to append y to it, so x is resliced which will also use the same a backing array, and append() will copy elements of y into there.If you want to avoid this, you may use a full slice expression which has the formwhich constructs a slice and also controls the resulting slice\'s capacity by setting it to max - low.See the modified example (the only difference is that we create x like this: x = a[:2:2]:Output (try it on the Go Playground)As you can see, we get the same x result but the backing array a did not change, because capacity of x was "only" 2 (thanks to the full slice expression a[:2:2]). So to do the append, a new backing array is allocated that can store the elements of both x and y, which is distinct from a.