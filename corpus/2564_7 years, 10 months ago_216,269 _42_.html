In Go, string is a primitive type, it\'s readonly, every manipulation to it will create a new string. So, if I want to concatenate strings many times without knowing the length of the resulting string, what\'s the best way to do it?The naive way would be:but that does not seem very efficient.The best way is to use the bytes package. It has a Buffer type which implements io.Writer. This does it in O(n) time. The most efficient way to concatenate strings is using the builtin function copy. In my tests, that approach is ~3x faster than using bytes.Buffer and much  much faster (~12,000x) than using the operator +. Also, it uses less memory.I\'ve created a test case to prove this and here are the results:Below is code for testing:There is a library function in the strings package called Join: \nhttp://golang.org/pkg/strings/#JoinA look at the code of Join shows a similar approach to Append function Kinopiko wrote: https://golang.org/src/strings/strings.go#L462Usage:I just benchmarked the top answer posted above in my own code (a recursive tree walk) and the simple concat operator is actually faster than the BufferString.This took 0.81s, whereas the following code:only took 0.61s. This is probably due to the overhead of creating the new BufferStrings.Update: I also benchmarked the join function and it ran in 0.54sYou could create a big slice of bytes and copy the bytes of the short strings into it using string slices. There is a function given in "Effective Go":Then when the operations are finished, use string ( ) on the big slice of bytes to convert it into a string again.This is the fastest solution that does not require\nyou to know or calculate the overall buffer size first:By my benchmark, it\'s 20% slower than the copy solution (8.1ns per\nappend rather than 6.72ns) but still 55% faster than using bytes.Buffer.Expanding on cd1\'s answer:\nYou might use append() instead of copy().\nappend() makes ever bigger advance provisions, costing a little more memory, but saving time.\nI added two more benchmarks at the top of yours.\nRun locally with On my thinkpad T400s it yields:My original suggestion wasBut above answer using bytes.Buffer - WriteString() is the most efficient way.My initial suggestion uses reflection and a type switch. See (p *pp) doPrint and (p *pp) printArg\nThere is no universal Stringer() interface for basic types, as I had naively thought.At least though, Sprint() internally uses a bytes.Buffer. Thusis acceptable in terms of memory allocations.=> Sprint() concatenation can be used for quick debug output.\n=> Otherwise use bytes.Buffer ... WriteStringThe benchmark code of @cd1 and other answers are wrong. b.N is not supposed to be set in benchmark function. It\'s set by the go test tool dynamically to determine if the execution time of the test is stable.A benchmark function should run the same test b.N times and the test inside the loop should be the same for each iteration. So I fix it by adding an inner loop. I also add benchmarks for some other solutions:Environment is OS X 10.11.6, 2.2 GHz Intel Core i7Test results:Conclusion:Suggestion:This is actual version of benchmark provided by @cd1 (Go 1.8, linux x86_64) with the fixes of bugs mentioned by @icza and @PickBoy.Bytes.Buffer is only 7 times faster than direct string concatenation via + operator.Timings:Take a look at the golang\'s strconv library giving access to several AppendXX functions, enabling us to concatenate strings with strings and other data types.[Off Topic] Have a look at this blog , for some of golang\'s featuresstrings.Join() from the "strings" packageIf you have a type mismatch(like if you are trying to join an int and a string), you do RANDOMTYPE (thing you want to change)EX: