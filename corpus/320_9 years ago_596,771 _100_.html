What are the lesser-known but useful features of the Python programming language?In case you\'re thinking it\'s doing 1 < x, which comes out as True, and then comparing True < 10, which is also True, then no, that\'s really not what happens (see the last example.) It\'s really translating into 1 < x and x < 10, and x < 10 and 10 < x * 10 and x*10 < 100, but with less typing and each term is only evaluated once.Get the python regex parse tree to debug your regex.Regular expressions are a great feature of python, but debugging them can be a pain, and it\'s all too easy to get a regex wrong.Fortunately, python can print the regex parse tree, by passing the undocumented, experimental, hidden flag re.DEBUG (actually, 128) to re.compile.Once you understand the syntax, you can spot your errors.  There we can see that I forgot to escape the [] in [/font].Of course you can combine it with whatever flags you want, like commented regexes:enumerateWrap an iterable with enumerate and it will yield the item along with its index.For example:References:Creating generators objectsIf you write you can get out the generator and assign it to x. Now it means you can doThe advantage of this is that you don\'t need intermediate storage, which you would need if you didIn some cases this can lead to significant speed up.You can append many if statements to the end of the generator, basically replicating nested for loops:iter() can take a callable argumentFor instance:The iter(callable, until_value) function repeatedly calls callable and yields its result until until_value is returned. Be careful with mutable default argumentsInstead, you should use a sentinel value denoting "not given" and replace with the mutable you\'d like as default:Sending values into generator functions. For example having this function:You can:If you don\'t like using whitespace to denote scopes, you can use the C-style {} by issuing:The step argument in slice operators. For example:The special case x[::-1] is a useful idiom for \'x reversed\'.DecoratorsDecorators allow to wrap a function or method in another function that can add functionality, modify arguments or results, etc. You write decorators one line above the function definition, beginning with an "at" sign (@).Example shows a print_args decorator that prints the decorated function\'s arguments before calling it:The for...else syntax (see http://docs.python.org/ref/for.html )The "else" block will be normally executed at the end of the for loop, unless the break is called.The above code could be emulated as follows:From 2.5 onwards dicts have a special method __missing__ that is invoked for missing items:There is also a dict subclass in collections called defaultdict that does pretty much the same but calls a function without arguments for not existing items:I recommend converting such dicts to regular dicts before passing them to functions that don\'t expect such subclasses.  A lot of code uses d[a_key] and catches KeyErrors to check if an item exists which would add a new item to the dict.In-place value swappingThe right-hand side of the assignment is an expression that creates a new tuple. The left-hand side of the assignment immediately unpacks that (unreferenced) tuple to the names a and b.After the assignment, the new tuple is unreferenced and marked for garbage collection, and the values bound to a and b have been swapped.As noted in the Python tutorial section on data structures,Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.Readable regular expressionsIn Python you can split a regular expression over multiple lines, name your matches and insert comments.Example verbose syntax (from Dive into Python):Example naming matches (from Regular Expression HOWTO)You can also verbosely write a regex without using re.VERBOSE thanks to string literal concatenation.Function argument unpackingYou can unpack a list or a dictionary as function arguments using * and **.For example:Very useful shortcut since lists, tuples and dicts are widely used as containers.ROT13 is a valid encoding for source code, when you use the right coding declaration at the top of the code file:which is exactly the same asProbably not the most useful thing, but nice to know.Edit: Fixed name of new type, should be NewType to be the exact same thing as with class statement.Edit: Adjusted the title to more accurately describe the feature.Context managers and the "with" StatementIntroduced in PEP 343, a context manager is an object that acts as a run-time context for a suite of statements.Since the feature makes use of new keywords, it is introduced gradually: it is available in Python 2.5 via the __future__ directive. Python 2.6 and above (including Python 3) has it available by default.I have used the "with" statement a lot because I think it\'s a very useful construct, here is a quick demo:What\'s happening here behind the scenes, is that the "with" statement calls the special __enter__ and __exit__ methods on the file object. Exception details are also passed to __exit__ if any exception was raised from the with statement body, allowing for exception handling to happen there.What this does for you in this particular case is that it guarantees that the file is closed when execution falls out of scope of the with suite, regardless if that occurs normally or whether an exception was thrown. It is basically a way of abstracting away common exception-handling code.Other common use cases for this include locking with threads and database transactions. Dictionaries have a \'get()\' method. If you do d[\'key\'] and key isn\'t there, you get an exception. If you do d.get(\'key\'), you get back None if \'key\' isn\'t there. You can add a second argument to get that item back instead of None, eg: d.get(\'key\', 0).It\'s great for things like adding up numbers:sum[value] = sum.get(value, 0) + 1They\'re the magic behind a whole bunch of core Python features. When you use dotted access to look up a member (eg, x.y), Python first looks for the member in the instance dictionary. If it\'s not found, it looks for it in the class dictionary. If it finds it in the class dictionary, and the object implements the descriptor protocol, instead of just returning it, Python executes it. A descriptor is any class that implements the __get__, __set__, or __delete__ methods.Here\'s how you\'d implement your own (read-only) version of property using descriptors:and you\'d use it just like the built-in property():Descriptors are used in Python to implement properties, bound methods, static methods, class methods and slots, amongst other things. Understanding them makes it easy to see why a lot of things that previously looked like Python \'quirks\' are the way they are.Raymond Hettinger has an excellent tutorial that does a much better job of describing them than I do.Conditional AssignmentIt does exactly what it sounds like: "assign 3 to x if y is 1, otherwise assign 2 to x". Note that the parens are not necessary, but I like them for readability. You can also chain it if you have something more complicated:Though at a certain point, it goes a little too far.Note that you can use if ... else in any expression. For example:Here func1 will be called if y is 1 and func2, otherwise. In both cases the corresponding function will be called with arguments arg1 and arg2.Analogously, the following is also valid:where class1 and class2 are two classes.Example extracted from the Python documentation:% -formatting takes a dictionary (also applies %i/%s etc. validation).And since locals() is also a dictionary, you can simply pass that as a dict and have % -substitions from your local variables. I think this is frowned upon, but simplifies things..New Style FormattingTo add more python modules (espcially 3rd party ones), most people seem to use PYTHONPATH environment variables or they add symlinks or directories in their site-packages directories. Another way, is to use *.pth files. Here\'s the official python doc\'s explanation:"The most convenient way [to modify\n  python\'s search path] is to add a path\n  configuration file to a directory\n  that\'s already on Python\'s path,\n  usually to the .../site-packages/\n  directory. Path configuration files\n  have an extension of .pth, and each\n  line must contain a single path that\n  will be appended to sys.path. (Because\n  the new paths are appended to\n  sys.path, modules in the added\n  directories will not override standard\n  modules. This means you can\'t use this\n  mechanism for installing fixed\n  versions of standard modules.)"Exception else clause:The use of the else clause is better than adding additional code to the try clause because it avoids accidentally catching an exception that wasn\xe2\x80\x99t raised by the code being protected by the try ... except statement.See http://docs.python.org/tut/node10.htmlRe-raising exceptions:The \'raise\' statement with no arguments inside an error handler tells Python to re-raise the exception with the original traceback intact, allowing you to say "oh, sorry, sorry, I didn\'t mean to catch that, sorry, sorry."If you wish to print, store or fiddle with the original traceback, you can get it with sys.exc_info(), and printing it like Python would is done with the \'traceback\' module.Main messages :)De-cyphered:The Zen of Python, by Tim Peters    Beautiful is better than ugly.\n  Explicit is better than implicit.\n  Simple is better than complex.\n  Complex is better than complicated.\n  Flat is better than nested.\n  Sparse is better than dense.\n  Readability counts.\n  Special cases aren\'t special enough to break the rules.\n  Although practicality beats purity.\n  Errors should never pass silently.\n  Unless explicitly silenced.\n  In the face of ambiguity, refuse the temptation to guess.\n  There should be one-- and preferably only one --obvious way to do it.\n  Although that way may not be obvious at first unless you\'re Dutch.\n  Now is better than never.\n  Although never is often better than right now.\n  If the implementation is hard to explain, it\'s a bad idea.\n  If the implementation is easy to explain, it may be a good idea.\n  Namespaces are one honking great idea -- let\'s do more of those!  Interactive Interpreter Tab CompletionYou will also have to set a PYTHONSTARTUP environment variable.Nested list comprehensions and generator expressions:These can replace huge chunks of nested-loop code.Operator overloading for the set builtin:More detail from the standard library reference: Set Types