Is there a way to use constants in JavaScript?If not, what\'s the common practice for specifying variables that are used as constants?ES2015, the latest version of JavaScript, has a notion of const:This will work in pretty much all browsers except IE 8, 9 and 10. Some may also need strict mode enabled.You could use conventions like ALL_CAPS to show that certain values should not be modified if you are not writing ES2015 code:Are you trying to protect the variables against modification?  If so, then you can use a module pattern:Using this approach, the values cannot be modified.  But, you have to use the get() method on CONFIG :(.If you don\'t need to strictly protect the variables value, then just do as suggested and use a convention of ALL CAPS.The const keyword is in the ECMAScript 6 draft but it thus far only enjoys a smattering of browser support: http://kangax.github.io/compat-table/es6/. The syntax is:IE does support constants, sort of, e.g.:ECMAScript 5 does introduce Object.defineProperty:It\'s supported in every modern browser (as well as IE \xe2\x89\xa5 9).See also: Object.defineProperty in ES5?No, not in general. Firefox implements const but I know IE doesn\'t.@John points to a common naming practice for consts that has been used for years in other languages, I see no reason why you couldn\'t use that. Of course that doesn\'t mean someone will not write over the variable\'s value anyway. :)Sad that IE9 still does not support const. And the reason it\'s absurd:So, what is IE9 doing with const? So\n  far, our decision has been to not\n  support it. It isn\xe2\x80\x99t yet a consensus\n  feature as it has never been available\n  on all browsers....In the end, it seems like the best\n  long term solution for the web is to\n  leave it out and to wait for\n  standardization processes to run their\n  course.They don\'t implement it because other browsers didn\'t implement it correctly?! Too afraid of making it better? Standards definitions or not, a constant is a constant: set once, never changed.And to all the ideas: Every function can be overwritten (XSS etc.). So there is no difference in var or function(){return}. const is the only real constant.Update:\nIE11 supports const:IE11 includes support for the well-defined and commonly used features of the emerging ECMAScript 6 standard including let, const, Map, Set, and WeakMap, as well as __proto__ for improved interoperability.In JavaScript, my preference is to use functions to return constant values.  If you don\'t mind using functions:This approach gives you functions instead of regular variables, but it guarantees* that no one can alter the value once it\'s set.I personally find this rather pleasant, specially after having gotten used to this pattern from knockout observables.*Unless someone redefined the function constant before you called itwith the "new" Object api you can do something like this: take a look at this on the Mozilla MDN for more specifics. It\'s not a first level variable, as it is attached to an object, but if you have a scope, anything, you can attach it to that. this should work as well. \nSo for example doing this in the global scope will declare a pseudo constant value on the window (which is a really bad idea, you shouldn\'t declare global vars carelessly)note: assignment will give you back the assigned value in the console, but the variable\'s value will not changeGroup constants into structures where possible:  Example, in my current game project, I have used below:Assignment:Comparision:More recently I am using, for comparision:IE11 is with new ES6 standard that has \'const\' declaration.\nAbove works in earlier browsers like IE8, IE9 & IE10.You can easily equip your script with a mechanism for constants that can be set but not altered.  An attempt to alter them will generate an error.  Yet there is no exact cross browser predefined way to do it , you can achieve it by controlling the scope of variables as showed on other answers.But i will suggest to use name space to distinguish from other variables. this will reduce the chance of collision to minimum from other variables.Proper namespacing likeso while using it will be iw_constant.name or iw_constant.ageYou can also block adding any new key or changing any key inside iw_constant using Object.freeze method. However its not supported on legacy browser.ex: For older browser you can use polyfill for freeze method.If you are ok with calling function following is best cross browser way to define constant. Scoping your object within a self executing function and returning a get function for your constants\nex://to get the value use\niw_constant(\'name\') or iw_constant(\'age\')** In both example you have to be very careful on name spacing so that your object or function shouldn\'t be replaced through other library.(If object or function itself wil be replaced your whole constant will go)For a while, I specified "constants" (which still weren\'t actually constants) in object literals passed through to with() statements. I thought it was so clever. Here\'s an example:In the past, I also have created a CONST namespace where I would put all of my constants. Again, with the overhead. Sheesh.Now, I just do var MY_CONST = \'whatever\'; to KISS.My opinion (works only with objects).Try! But understand - this is object, but not simple variable.Try also just:Forget IE and use the const keyword.I too have had a problem with this. And after quite a while searching for the answer and looking at all the responses by everybody, I think I\'ve come up with a viable solution to this.It seems that most of the answers that I\'ve come across is using functions to hold the constants. As many of the users of the MANY forums post about, the functions can be easily over written by users on the client side. I was intrigued by Keith Evetts\' answer that the constants object can not be accessed by the outside, but only from the functions on the inside.So I came up with this solution:Put everything inside an anonymous function so that way, the variables, objects, etc. cannot be changed by the client side. Also hide the \'real\' functions by having other functions call the \'real\' functions from the inside. I also thought of using functions to check if a function has been changed by a user on the client side. If the functions have been changed, change them back using variables that are \'protected\' on the inside and cannot be changed.It also seems that security is really a problem and there is not way to \'hide\' you programming from the client side. A good idea for me is to compress your code so that it is really hard for anyone, including you, the programmer, to read and understand it. There is a site you can go to: http://javascriptcompressor.com/. (This is not my site, don\'t worry I\'m not advertising.) This is a site that will let you compress and obfuscate Javascript code for free.Clearly this shows the need for a standardized cross-browser const keyword.But for now:orBoth seem sufficient and anything else is like shooting a fly with a bazooka.Okay, this is ugly, but it gives me a constant in Firefox and Chromium, an inconstant constant (WTF?) in Safari and Opera, and a variable in IE.Of course eval() is evil, but without it, IE throws an error, preventing scripts from running.Safari and Opera support the const keyword, but you can change the const\'s value.In this example, server-side code is writing JavaScript to the page, replacing {0} with a value.What is this good for?  Not much, since it\'s not cross-browser.  At best, maybe a little peace of mind that at least some browsers won\'t let bookmarklets or third-party script modify the value.Tested with Firefox 2, 3, 3.6, 4, Iron 8, Chrome 10, 12, Opera 11, Safari 5, IE 6, 9.If it is worth mentioning, you can define constants in angular using $provide.constant()I use const instead of var in my Greasemonkey scripts, but it is because they will run only on Firefox...\nName convention can be indeed the way to go, too (I do both!).In JavaScript my practice has been to avoid constants as much as I can and use strings instead. Problems with constants appear when you want to expose your constants to the outside world:For example one could implement the following Date API:But it\'s much shorter and more natural to simply write:This way "days" and "hours" really act like constants, because you can\'t change from the outside how many seconds "hours" represents. But it\'s easy to overwrite MyModule.Date.HOUR.This kind of approach will also aid in debugging. If Firebug tells you action === 18 it\'s pretty hard to figure out what it means, but when you see action === "save" then it\'s immediately clear.Introducing constants into JavaScript is at best a hack.A nice way of making persistent and globally accessible values in JavaScript  would be declaring an object literal with some "read-only" properties like this:you\'ll have all your constants grouped in one single "my" accessory object where you can look for your stored values or anything else you may have decided to put there for that matter. Now let\'s test if it works: As we can see, the "my.constant1" property has preserved its original value. You\'ve made yourself some nice \'green\' temporary constants...But of course this will only guard you from accidentally modifying, altering, nullifying, or emptying your property constant value with a direct access as in the given example. Otherwise I still think that constants are for dummies. \nAnd I still think that exchanging your great freedom for a small corner of deceptive security is the worst trade possible.in Javascript already exists constants. You define a constant like this:This cannot change through reassignment.The keyword \'const\' was proposed earlier and now it has been officially included in ES6. By using the const keyword, you can pass a value/string that will act as an immutable string.An improved version of Burke\'s answer that lets you do CONFIG.MY_CONST instead of CONFIG.get(\'MY_CONST\').It requires IE9+ or a real web browser.* The properties are read-only, only if the initial values are immutable.Rhino.js implements const in addition to what was mentioned above.const keyword available in javscript language but it does not support IE browser. Rest all browser supported.Another alternative is something like:Then simply: var foo = constantMap.MY_CONSTANTIf you were to constantMap.MY_CONSTANT = "bar" it would have no effect as we\'re trying to use an assignment operator with a getter, hence constantMap.MY_CONSTANT === "myconstant" would remain true.