Consider:What would the equivalent for loop look like without using the for each syntax?Note that if you need to use i.remove(); in your loop, or access the actual iterator in some way, you cannot use the for ( : ) idiom, since the actual iterator is merely inferred.As was noted by Denis Bueno, this code works for any object that implements the Iterable interface.Also, if the right-hand side of the for (:) idiom is an array rather than an Iterable object, the internal code uses an int index counter and checks against array.length instead. See the Java Language Specification.for each is also valid for arrays. e.g.which is essentially equivalent ofSo, overall summary:\n[nsayer]The following is the longer form of what is happening:Note that if you need to use\n  i.remove(); in your loop, or access\n  the actual iterator in some way, you\n  cannot use the for( : ) idiom, since\n  the actual Iterator is merely\n  inferred.[Denis Bueno]It\'s implied by nsayer\'s answer, but\n  it\'s worth noting that the OPs for(..)\n  syntax will work when "someList" is\n  anything that implements\n  java.lang.Iterable -- it doesn\'t have\n  to be a list, or some collection from\n  java.util. Even your own types,\n  therefore, can be used with this\n  syntax.Here is an answer which does not assume knowledge of Java Iterators. It is less precise but is useful for education. While programming we often write code that looks like the following: The foreach syntax allows this common pattern to be written in a more natural and less syntactically noisy way.Additionally this syntax is valid for objects such as Lists or Sets which do not support array indexing but which do implement the Java Iterable interface. The foreach loop, added in Java 5 (also called the "enhanced for loop"), is equivalent to using a java.util.Iterator--it\'s syntactic sugar for the same thing. Therefore, when reading each element, one by one and in order, a foreach should always be chosen over an iterator, as it is more convenient and concise.There are situations where you must use an Iterator directly. For example, attempting to delete an element while using a foreach can (will?) result in a ConcurrentModificationException.The only practical difference between for and foreach is that, in the case of indexable objects, you do not have access to the index. An example when the basic for loop is required:Although you could manually create a separate index int-variable with foreachit is not recommended, since variable-scope is not ideal, and the basic for loop is simply the standard and expected format for this use-case.When accessing collections, a foreach is significantly faster than the basic for loop\'s array access. When accessing arrays, however--at least with primitive and wrapper-arrays--access via indexes is dramatically faster.Indexes are 23-40 percent faster than iterators when accessing int or Integer arrays. Here is the output from the testing class at the bottom of this post, which sums the numbers in a 100-element primitive-int array (A is iterator, B is index):I also ran this for an Integer array, and indexes are still the clear winner, but only between 18 and 25 percent faster.For a List of Integers, however, iterators are the clear winner. Just change the int-array in the test-class toand make the necssary changes to the test-function (int[] to List<Integer>, length to size(), etc)In one test they\'re almost equivalent, but with collections, iterator wins.This post is based on two answers I wrote on stackexchange:\n   https://stackoverflow.com/questions/22110482/uses-and-syntax-for-for-each-loop-in-java/22110517#22110517\n   Should I use an Iterator or a forloop to iterate?\nSome more information: Which is more efficient, a for-each loop, or an iterator?I created this compare-the-time-it-takes-to-do-any-two-things class after reading this question on stackoverflowThe for-each loop in java uses the underlying iterator mechanism. So it\'s identical to the following:It\'s implied by nsayer\'s answer, but it\'s worth noting that the OPs for(..) syntax will work when "someList" is anything that implements java.lang.Iterable -- it doesn\'t have to be a list, or some collection from java.util.  Even your own types, therefore, can be used with this syntax.In Java 8 features you can use this:The Java "for-each" loop construct will allow iteration over two types of objects:The Iterable<T> interface has only one method: Iterator<T> iterator().  This works on objects of type Collection<T> because the Collection<T> interface extends Iterable<T>.A foreach loop syntax is:EX:Output:WARNING: You can access array elements with the foreach loop, but can NOT initialize them. Use the original for loop for that.\n\nWARNING: You must match the type of the array with the other object.If you want to edit elements, use the original for loop like this:Now if we dump s to the consle, we getThe concept of foreach loop as mentioned in wikipedia is highlighted below:Unlike other for loop constructs, however, foreach loops usually\n  maintain no explicit counter: they essentially say "do this to\n  everything in this set", rather than "do this x times". This avoids\n  potential off-by-one errors and makes code simpler to read.So the concept of foreach loop describes that the loop does not use any explicit counter which means that there is no need of using indexes to traverse in the list thus it saves user from off-by-one error. To describe the general concept of this off-by-one error. Let us take an example of a loop to traverse in a list using indexes.But suppose if the list starts with index 1 then this loop is going to throw an exception as it will found no element at index 0 and this error is called off-by-one error. So to avoid this off-by-one error the concept of foreach loop is used. There may be other advantages too but this is what I think is the main concept and advantage of using foreach loop.As defined in JLS for-each loop can have two forms:If the type of Expression is a subtype of Iterable then translation is as:If the Expression necessarily has an array type T[] then:Java 8 has introduced streams which perform generally better. We can use them as:Here\'s an equivalent expression.Also note that using the "foreach" method in the original question does have some limitations, such as not being able to remove items from the list during the iteration.The new for-loop is easier to read and removes the need for a separate iterator, but is only really usable in read-only iteration passes.It adds beauty to your code by removing all the basic looping clutter. It gives a clean look to your code, justified below.Normal for loop:Using for-each:for-each is a construct over a collection that implements Iterator. Remember that, your collection should implement Iterator; otherwise you can\'t use it with for-each.The following line is read as "for each TimerTask t in list."There is less chance for errors in case of for-each. You don\'t have to worry about initializing the iterator or initializing the loop counter and terminating it (where there is scope for errors).It would look something like this. Very crufty. There is a good writeup on for each in the Sun documentation.As so many good answers said, an object must implement the Iterable interface if it wants to use a for-each loop.I\'ll post a simple example and try to explain in a different way how a for-each loop works.The for-each loop example:Then, if we use javap to decompile this class, we will get this bytecode sample:As we can see from the last line of the sample, the compiler will automatically convert the use of for-each keyword to the use of an Iterator at compile time. That may explain why object, which doesn\'t implement the Iterable interface, will throw an Exception when it tries to use the for-each loop.Alternative forEach in order to avoid your "for each":Varian 1 (plain):Variant 2 (parallel execution (faster)):The Java for-each idiom can only be applied to arrays or objects of type *Iterable. This idiom is implicit as it truly backed by an Iterator. The Iterator is programmed by the programmer and often uses an integer index or a node (depending on the data structure) to keep track of its position. On paper it is slower than a regular for-loop, a least for "linear" structures like arrays and Lists but it provides greater abstraction. 