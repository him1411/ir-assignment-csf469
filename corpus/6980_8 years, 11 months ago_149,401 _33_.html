I have the following code making a GET request on a URL:But the returned result is not always reflected. For example, I made a change in the response that spit out a stack trace but the stack trace did not appear when I clicked on the search button. I looked at the underlying PHP code that controls the ajax response and it had the correct code and visiting the page directly showed the correct result but the output returned by .load was old.If I close the browser and reopen it it works once and then starts to return the stale information. Can I control this by jQuery or do I need to have my PHP script output headers to control caching?You have to use a more complex function like $.ajax() if you want to control caching on a per-request basis. Or, if you just want to turn it off for everything, put this at the top of your script:Here is an example of how to control caching on a per-request basisOne way is to add a unique number to the end of the url:Where you write uniqueId() to return something different each time it\'s called.Another approach to put the below line only when require to get data from server,Append the below line along with your ajax url.\'?_=\'+Math.round(Math.random()*10000)This is of particular annoyance in IE. Basically you have to send \'no-cache\' HTTP headers back with your response from the server.Sasha is good idea,  i use a mix.I create a function And invoke for diferents parts of my page for example on init:Init: function (actionUrl1, actionUrl2, actionUrl3) {var ExampleJS= {ExampleJS.LoadWithoutCache(actionUrl2, "div2");\nExampleJS.LoadWithoutCache(actionUrl3, "div3");\n    }\n },For PHP, add this line to your script which serves the information you want:or, add a unique variable to the query string:Do NOT use timestamp to make an unique URL as for every page you visit is cached in DOM by jquery mobile and you soon run into trouble of running out of memory on mobiles.This code activates before page is loaded, you can use url.indexOf() to determine if the URL is the one you want to cache or not and set the cache parameter accordingly.Do not use window.location = ""; to change URL otherwise you will navigate to the address and pagebeforeload will not fire. In order to get around this problem simply use window.location.hash = "";You can replace the jquery load function with a version that has cache set to false.         Place this somewhere global where it will run after jquery loads and you should be all set.  Your existing load code will no longer be cached.Try this:It works fine when i used it.I noticed that if some servers (like Apache2) are not configured to specifically allow or deny any "caching", then the server may by default send a "cached" response, even if you set the HTTP headers to "no-cache". So make sure that your server is not "caching" anything before it sents a response:In the case of Apache2 you have to1) edit the "disk_cache.conf" file - to disable cache add "CacheDisable /local_files" directive2) load mod_cache modules (On Ubuntu "sudo a2enmod cache" and "sudo a2enmod disk_cache")3) restart the Apache2 (Ubuntu "sudo service apache2 restart");This should do the trick disabling cache on the servers side.\nCheers! :)This code may help youIf you want to stick with Jquery\'s .load() method, add something unique to the URL like a JavaScript timestamp. "+new Date().getTime()". Notice I had to add an "&time=" so it does not alter your pid variable.