I have been using Python more and more, and I keep seeing the variable __all__ set in different __init__.py files.  Can someone explain what this does?It\'s a list of public objects of that module, as interpreted by import *. It overrides the default of hiding everything that begins with an underscore.Linked to, but not explicitly mentioned here, is exactly when __all__ is used. It is a list of strings defining what symbols in a module will be exported when from <module> import * is used on the module.For example, the following code in a foo.py explicitly exports the symbols bar and baz:These symbols can then be imported like so:If the __all__ above is commented out, this code will then execute to completion, as the default behaviour of import * is to import all symbols that do not begin with an underscore, from the given namespace.Reference: https://docs.python.org/3.5/tutorial/modules.html#importing-from-a-packageNOTE: __all__ affects the from <module> import * behavior only. Members that are not mentioned in __all__ are still accessible from outside the module and can be imported with from <module> import <member>.I\'m just adding this to be precise:All other answers refer to modules. The original question explicitely mentioned __all__ in __init__.py files, so this is about python packages.Generally, __all__ only comes into play when the from xxx import * variant of the import statement is used. This applies to packages as well as to modules.The behaviour for modules is explained in the other answers. The exact behaviour for packages is described here in detail.In short, __all__ on package level does approximately the same thing as for modules, except it deals with modules within the package  (in contrast to specifying names within the module). So __all__ specifies all modules that shall be loaded and imported into the current namespace when us use from package import *.The big difference is, that when you omit the declaration of __all__ in a package\'s __init__.py, the statement from package import * will not import anything at all (with exceptions explained in the documentation, see link above). On the other hand, if you omit __all__ in a module, the "starred import" will import all names (not starting with an underscore) defined in the module.It also changes what pydoc will show:module1.pymodule2.py$ pydoc module1$ pydoc module2I declare __all__ in all my modules, as well as underscore internal details, these really help when using things you\'ve never used before in live interpreter sessions.Explain __all__ in Python?I keep seeing the variable __all__ set in different __init__.py files.What does this do?It declares the semantically "public" names from a module. If there is a name in __all__, users are expected to use it, and they can have the expectation that it will not change. It also will have programmatic affects:__all__ in a module, e.g. module.py:means that when you import * from the module, only those names in the __all__ are imported:Documentation and code autocompletion tools may (in fact, should) also inspect the __all__ to determine what names to show as available from a module.From the docs:The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path.In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable.So the __init__.py can declare the __all__ for a package.A package is typically made up of modules that may import one another, but that are necessarily tied together with an __init__.py file. That file is what makes the directory an actual Python package. For example, say you have the following:in the __init__.py you write:and in module_1 you have:and in module_2 you have:And now you have presented a complete api that someone else can use when they import your package, like so: And they won\'t have all the other names you used when creating your modules cluttering up the package namespace.After more work, maybe you\'ve decided that the modules are too big and need to be split up. So you do the following:And in each __init__.py you declare an __all__, e.g. in module_1:And module_2\'s __init__.py:And you can easily add things to your API that you can manage at the subpackage level instead of the subpackage\'s module level. If you want to add a new name to the API, you simply update the __init__.py, e.g. in module_2:And if you\'re not ready to publish Baz in the top level API, in your top level __init__.py you could have:and if your users are aware of the availability of Baz, they can use it:but if they don\'t know about it, other tools (like pydoc) won\'t inform them.You can later change that when Baz is ready for prime time:By default, Python will export all names that do not start with an _. You certainly could rely on this mechanism. Some packages in the Python standard library, in fact, do rely on this, but to do so, they alias their imports, for example, in ctypes/__init__.py:Using the _ convention can be more elegant because it removes the redundancy of naming the names again. But it adds the redundancy for imports (if you have a lot of them) and it is easy to forget to do this consistently - and the last thing you want is to have to indefinitely support something you intended to only be an implementation detail, just because you forgot to prefix an _ when naming a function.I personally write an __all__ early in my development lifecycle for modules so that others who might use my code know what they should use and not use.Most packages in the standard library also use __all__.It makes sense to stick to the _ prefix convention in lieu of __all__ when:The downside of using __all__ is that you have to write the names of functions and classes being exported twice - and the information is kept separate from the definitions. We could use a decorator to solve this problem.I got the idea for such an export decorator from David Beazley\'s talk on packaging. This implementation seems to work well in CPython\'s traditional importer. If you have a special import hook or system, I do not guarantee it, but if you adopt it, it is fairly trivial to back out - you\'ll just need to manually add the names back into the __all__So in, for example, a utility library, you would define the decorator:and then, where you would define an __all__, you do this:And this works fine whether run as main or imported by another function.And API provisioning with import * will work too:From (An Unofficial) Python Reference Wiki:The public names defined by a module are determined by checking the module\'s namespace for a variable named __all__; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in __all__ are all considered public and are required to exist. If __all__ is not defined, the set of public names includes all names found in the module\'s namespace which do not begin with an underscore character ("_"). __all__ should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).As @AaronHall points out, __all__ declares to users and maintainers the "public" features of the module. (And to pydoc, thanks @Longpoke.) The import-asterisk statement below brings only swiss and cheddar into the local namespace, and gouda is hidden.Without __all__, any symbol (that doesn\'t start with an underscore) would have been available. @MartinStettner points out that in the __init__.py of a package, __all__ is a list of public module names.@ToolmakerSteve cites PEP 0008 that wildcard imports confuse humans and bots, and should be avoided.__all__ is used to document the public API of a Python module. Although it is optional, __all__ should be used.Here is the relevant excerpt from the Python language reference:The public names defined by a module are determined by checking the module\xe2\x80\x99s namespace for a variable named __all__; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in __all__ are all considered public and are required to exist. If __all__ is not defined, the set of public names includes all names found in the module\xe2\x80\x99s namespace which do not begin with an underscore character (\'_\'). __all__ should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).PEP 8 uses similar wording, although it also makes it clear that imported names are not part of the public API when __all__ is absent:To better support introspection, modules should explicitly declare the names in their public API using the __all__ attribute. Setting __all__ to an empty list indicates that the module has no public API.[...]Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module\'s API, such as os.path or a package\'s __init__ module that exposes functionality from submodules.Furthermore, as pointed out in other answers, __all__ is used to enable wildcard importing for packages:The import statement uses the following convention: if a package\xe2\x80\x99s __init__.py code defines a list named __all__, it is taken to be the list of module names that should be imported when from package import * is encountered.