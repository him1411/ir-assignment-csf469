Here\'s the Python code to run an arbitrary command returning its stdout data, or raise an exception on non-zero exit codes:communicate is used to wait for the process to exit:The subprocess module does not support timeout--ability to kill a process running for more than X number of seconds--therefore, communicate may take forever to run.What is the simplest way to implement timeouts in a Python program meant to run on Windows and Linux?In Python 3.3+:output is a byte string that contains command\'s merged stdout, stderr data. This code raises CalledProcessError on non-zero exit status as specified in the question\'s text unlike proc.communicate() method.I\'ve removed shell=True because it is often used unnecessarily. You can  always add it back if cmd indeed requires it. If you add shell=True i.e., if the child process spawns its own descendants; check_output() can return much later than the timeout indicates, see Subprocess timeout failure.The timeout feature is available on Python 2.x via the subprocess32 backport of the 3.2+ subprocess module.I don\'t know much about the low level details; but, given that in\npython 2.6 the API offers the ability to wait for threads and\nterminate processes, what about running the process in a separate\nthread?The output of this snippet in my machine is:where it can be seen that, in the first execution, the process\nfinished correctly (return code 0), while the in the second one the\nprocess was terminated (return code -15).I haven\'t tested in windows; but, aside from updating the example\ncommand, I think it should work since I haven\'t found in the\ndocumentation anything that says that thread.join or process.terminate\nis not supported.If you\'re on Unix,jcollado\'s answer can be simplified using the threading.Timer class:Here is Alex Martelli\'s solution as a module with proper process killing. The other approaches do not work because they do not use proc.communicate(). So if you have a process that produces lots of output, it will fill its output buffer and then block until you read something from it.I\'ve modified sussudio answer. Now function returns: (returncode, stdout, stderr, timeout) - stdout and stderr is decoded to utf-8 stringsurprised nobody mentioned using timeouttimeout 5 ping -c 3 somehostThis won\'t for work for every use case obviously, but if your dealing with a simple script, this is hard to beat.Also available as gtimeout in coreutils via homebrew for mac users.Another option is to write to a temporary file to prevent the stdout blocking instead of needing to poll with communicate(). This worked for me where the other answers did not; for example on windows.timeout is now supported by call() and communicate() in the subprocess module (as of Python3.3):This will call the command and raise the exceptionif the command doesn\'t finish after 20 seconds.You can then handle the exception to continue your code, something like:Hope this helps.Here is my solution, I was using Thread and Event:In action:The solution I use is to prefix the shell command with timelimit. If the comand takes too long, timelimit will stop it and Popen will have a returncode set by timelimit. If it is > 128, it means timelimit killed the process.See also python subprocess with timeout and large output (>64K)I added the solution with threading from jcollado to my Python module easyprocess.Install:Example:I\'ve implemented what I could gather from a few of these. This works in Windows, and since this is a community wiki, I figure I would share my code as well:Then from another class or file:if you are using python 2, give it a tryI\'ve used killableprocess successfully on Windows, Linux and Mac. If you are using Cygwin Python, you\'ll need OSAF\'s version of killableprocess because otherwise native Windows processes won\'t get killed.Although I haven\'t looked at it extensively, this decorator I found at ActiveState seems to be quite useful for this sort of thing. Along with subprocess.Popen(..., close_fds=True), at least I\'m ready for shell-scripting in Python.Once you understand full process running machinery in *unix, you will easily find simplier solution:Consider this simple example how to make timeoutable communicate() meth using select.select() (available alsmost everythere on *nix nowadays). This also can be written with epoll/poll/kqueue, but select.select() variant could be a good example for you. And major limitations of select.select() (speed and 1024 max fds) are not applicapable for your task.This works under *nix, does not create threads, does not uses signals, can be lauched from any thread (not only main), and fast enought to read 250mb/s of data from stdout on my machine (i5 2.3ghz).There is a problem in join\'ing stdout/stderr at the end of communicate. If you have huge program output this could lead to big memory usage. But you can call communicate() several times with smaller timeouts.You can do this using selectUnfortunately, I\'m bound by very strict policies on the disclosure of source code by my employer, so I can\'t provide actual code.  But for my taste the best solution is to create a subclass overriding Popen.wait() to poll instead of wait indefinitely, and Popen.__init__ to accept a timeout parameter.  Once you do that, all the other Popen methods (which call wait) will work as expected, including communicate.https://pypi.python.org/pypi/python-subprocess2 provides extensions to the subprocess module which allow you to wait up to a certain period of time, otherwise terminate. So, to wait up to 10 seconds for the process  to terminate, otherwise kill:This is compatible with both windows and unix.  "results" is a dictionary, it contains "returnCode" which is the return of the app (or None if it had to  be killed), as well as "actionTaken". which will be "SUBPROCESS2_PROCESS_COMPLETED" if the process completed normally, or a mask of "SUBPROCESS2_PROCESS_TERMINATED" and SUBPROCESS2_PROCESS_KILLED depending on action taken (see documentation for full details)This solution kills the process tree in case of shell=True, passes parameters to the process (or not), has a timeout and gets the stdout, stderr and process output of the call back (it uses psutil for the kill_proc_tree).  This was based on several solutions posted in SO including jcollado\'s. Posting in response to comments by Anson and jradice in jcollado\'s answer. Tested in Windows Srvr 2012 and Ubuntu 14.04.  Please note that for Ubuntu you need to change the parent.children(...) call to parent.get_children(...).There\'s an idea to subclass the Popen class and extend it with some simple method decorators. Let\'s call it ExpirablePopen.Was just trying to write something simpler.