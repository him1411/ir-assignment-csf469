I have a list of 2-item tuples and I\'d like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.For example:Is there a builtin function that does that?zip is its own inverse! Provided you use the special * operator.The way this works is by calling zip with the arguments:\xe2\x80\xa6 except the arguments are passed to zip directly (after being converted to a tuple), so there\'s no need to worry about the number of arguments getting too big.You could also doIt should scale better. Especially if Python makes good on not expanding the list comprehensions unless needed.(Incidentally, it makes a 2-tuple (pair) of lists, rather than a list of tuples, like zip does.)If generators instead of actual lists are ok, this would do that:The generators don\'t munch through the list until you ask for each element, but on the other hand, they do keep references to the original list.If you have lists that are not the same length, you may not want to use zip as per Patricks answer. This works:But with different length lists, zip truncates each item to the length of the shortest list:You can use map with no function to fill empty results with None:zip() is marginally faster though.I like to use zip(*iterable) (which is the piece of code you\'re looking for) in my programs as so:I find unzip more readable.Gives a tuple of lists as in the question.Unpacks the two lists.It\'s only another way to do it but it helped me a lot so I write it here:Having this data structure:Resulting in:The more pythonic way to unzip it and go back to the original is this one in my opinion:But this return a tuple so if you need an array you can use: