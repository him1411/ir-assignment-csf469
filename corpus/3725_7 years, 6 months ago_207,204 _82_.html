How do I perform the SQL Join equivalent in MongoDB?For example say you have two collections (users and comments) and I want to pull all the comments with pid=444 along with the user info for each. Is there a way to pull all the comments with a certain field (eg. ...find({pid:444}) ) and the user information associated with each comment in one go?At the moment, I am first getting the comments which match my criteria, then figuring out all the uid\'s in that result set, getting the user objects, and merging them with the comment\'s results. Seems like I am doing it wrong. As of Mongo 3.2 the answers to this question are mostly no longer correct. The new $lookup operator added to the aggregation pipeline is essentially identical to a left outer join:https://docs.mongodb.org/master/reference/operator/aggregation/lookup/#pipe._S_lookupFrom the docs:Of course Mongo is not a relational database, and the devs are being careful to recommend specific use cases for $lookup, but at least as of 3.2 doing join is now possible with MongoDB.This page on the official mongodb site addresses exactly this question:http://docs.mongodb.org/ecosystem/tutorial/model-data-for-ruby-on-rails/When we display our list of stories, we\'ll need to show the name of the user who posted the story. If we were using a relational database, we could perform a join on users and stores, and get all our objects in a single query. But MongoDB does not support joins and so, at times, requires bit of denormalization. Here, this means caching the \'username\' attribute.Relational purists may be feeling uneasy already, as if we were violating some universal law. But let\xe2\x80\x99s bear in mind that MongoDB collections are not equivalent to relational tables; each serves a unique design objective. A normalized table provides an atomic, isolated chunk of data. A document, however, more closely represents an object as a whole. In the case of a social news site, it can be argued that a username is intrinsic to the story being posted.We can merge/join all data inside only one collection with a easy function in few lines using the mongodb client console, and now we could be able of perform the desired query.\nBelow a complete example,.- Authors:.- Categories:.- Books.- Book lending.- The magic:.- Get the new collection data:.- Response :)I hope this lines can help you.You have to do it the way you described. MongoDB is a non-relational database and doesn\'t support joins. Here\'s an example of a "join" * Actors and Movies collections:https://github.com/mongodb/cookbook/blob/master/content/patterns/pivot.txtIt makes use of .mapReduce() method* join - an alternative to join in document-oriented databasesAs others have pointed out you are trying to create a relational database from none relational database which you really don\'t want to do but anyways, if you have a case that you have to do this here is a solution you can use. We first do a foreach find on collection A( or in your case users) and then we get each item as an object then we use object property (in your case uid) to lookup in our second collection (in your case comments) if we can find it then we have a match and we can print or do something with it. \nHope this helps you and good luck :)It depends on what you\'re trying to do.You currently have it set up as a normalized database, which is fine, and the way you are doing it is appropriate. However, there are other ways of doing it.You could have a posts collection that has imbedded comments for each post with references to the users that you can iteratively query to get.  You could store the user\'s name with the comments, you could store them all in one document.The thing with NoSQL is it\'s designed for flexible schemas and very fast reading and writing.  In a typical Big Data farm the database is the biggest bottleneck, you have fewer database engines than you do application and front end servers...they\'re more expensive but more powerful, also hard drive space is very cheap comparatively.  Normalization comes from the concept of trying to save space, but it comes with a cost at making your databases perform complicated Joins and verifying the integrity of relationships, performing cascading operations.  All of which saves the developers some headaches if they designed the database properly.With NoSQL, if you accept that redundancy and storage space aren\'t issues because of their cost (both in processor time required to do updates and hard drive costs to store extra data), denormalizing isn\'t an issue (for embedded arrays that become hundreds of thousands of items it can be a performance issue, but most of the time that\'s not a problem).  Additionally you\'ll have several application and front end servers for every database cluster.  Have them do the heavy lifting of the joins and let the database servers stick to reading and writing. TL;DR: What you\'re doing is fine, and there are other ways of doing it.  Check out the mongodb documentation\'s data model patterns for some great examples. http://docs.mongodb.org/manual/data-modeling/There is a specification that a lot of drivers support that\'s called DBRef.DBRef is a more formal specification for creating references between documents.  DBRefs (generally) include a collection name as well as an object id.  Most developers only use DBRefs if the collection can change from one document to the next.  If your referenced collection will always be the same, the manual references outlined above are more efficient.Taken from MongoDB Documentation: Data Models > Data Model Reference > \nDatabase ReferencesYou can join two collection in Mongo by using lookup which is offered in 3.2 version. In your case the query would beor you can also join with respect to users then there will be a little change as given below.It will work just same as left and right join in SQL.You can run SQL queries including join on MongoDB with mongo_fdw from Postgres.Before 3.2.6, Mongodb does not support join query as like mysql. below solution which works for you.   With right combination of $lookup, $project and $match, you can join mutiple tables on multiple parameters. This is because they can be chained multiple times. Suppose we want to do following (reference)Step 1: Link all tablesyou can $lookup as many tables as you want.$lookup - one for each table in query$unwind - because data is denormalised correctly, else wrapped in arraysPython code..Step 2: Define all conditionals$project : define all conditional statements here, plus all the variables you\'d like to select.Python Code..Step 3: Join all the conditionals $match - join all conditions using OR or AND etc. There can be multiples of these. $project: undefine all conditionalsPython Code..Pretty much any combination of tables, conditionals and joins can be done in this manner. MongoDB does not allow joins, but you can use plugins to handle that. Check the mongo-join plugin. It\'s the best and I have already used it. You can install it using npm directly like this npm install mongo-join. You can check out the full documentation with examples.(++) really helpful tool when we need to join (N) collections(--) we can apply conditions just on the top level of the queryExampleplayORM can do it for you using S-SQL(Scalable SQL) which just adds partitioning such that you can do joins within partitions.Nope, it doesn\'t seem like you\'re doing it wrong.  MongoDB joins are "client side".  Pretty much like you said:At the moment, I am first getting the comments which match my criteria, then figuring out all the uid\'s in that result set, getting the user objects, and merging them with the comment\'s results. Seems like I am doing it wrong.It\'s not a "real" join, but it\'s actually alot more useful than a SQL join because you don\'t have to deal with duplicate rows for "many" sided joins, instead your decorating the originally selected set.There is alot of nonsense and FUD on this page.  Turns out 5 years later MongoDB is still a thing.But I\'ve foun that sollution for MOngo on Git\nBy the way, in inserts code - it has movie\'s name, but noi movie\'s ID.You have a collection of Actors with an array of the Movies they\'ve done. You want to generate a collection of Movies with an array of Actors in each.Some sample dataWe need to loop through each movie in the Actor document and emit each Movie individually.The catch here is in the reduce phase. We cannot emit an array from the reduce phase, so we must build an Actors array inside of the "value" document that is returned.Notice how actor_list is actually a javascript object that contains an array. Also notice that map emits the same structure.Run the following to execute the map / reduce, output it to the "pivot" collection and print the result:printjson(db.actors.mapReduce(map, reduce, "pivot"));\n  db.pivot.find().forEach(printjson);Here is the sample output, note that "Pretty Woman" and "Runaway Bride" have both "Richard Gere" and "Julia Roberts".We can merge two collection by using mongoDB sub query. Here is example,\nCommentss--Userss--MongoDB sub query for JOIN--Get result from newly generated Collection--Result--Hope so this will help.