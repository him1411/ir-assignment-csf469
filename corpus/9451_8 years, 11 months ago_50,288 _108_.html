The C++ friend keyword allows a class A to designate class B as its friend.  This allows Class B to access the private/protected members of class A.I\'ve never read anything as to why this was left out of C# (and VB.NET). Most answers to this earlier StackOverflow question seem to be saying it is a useful part of C++ and there are good reasons to use it.  In my experience I\'d have to agree.Another question seems to me to be really asking how to do something similar to friend in a C# application.  While the answers generally revolve around nested classes, it doesn\'t seem quite as elegant as using the friend keyword.The original Design Patterns book uses it regularly throughout its examples.So in summary, why is friend missing from C#, and what is the "best practice" way (or ways) of simulating it in C#?(By the way, the internal keyword is not the same thing, it allows all classes within the entire assembly to access internal members, while friend allows you to give a certain class complete access to exactly one other class)Having friends in programming is more-or-less considered "dirty" and easy to abuse. It breaks the relationships between classes and undermines some fundamental attributes of an OO language.That being said, it is a nice feature and I\'ve used it plenty of times myself in C++; and would like to use it in C# too. But I bet because of C#\'s "pure" OOness (compared to C++\'s pseudo OOness) MS decided that because Java has no friend keyword C# shouldn\'t either (just kidding ;))On a serious note: internal is not as good as friend but it does get the job done. Remember that it is rare that you will be distributing your code to 3rd party developers not though a DLL; so as long as you and your team know about the internal classes and their use you should be fine.EDIT Let me clarify how the friend keyword undermines OOP.Private and protected variables and methods are perhaps one of the most important part of OOP. The idea that objects can hold data or logic that only they can use allows you to write your implementation of functionality independent of your environment - and that your environment cannot alter state information that it is not suited to handle. By using friend you are coupling two classes\' implementations together - which is much worse then if you just coupled their interface. On a side note.\nUsing friend is not about violating the encapsulation, but on the contrary it\'s about enforcing it. Like accessors+mutators, operators overloading, public inheritance, downcasting, etc., it\'s often misused, but it does not mean the keyword has no, or worse, a bad purpose.See Konrad Rudolph\'s message in the other thread, or if you prefer see the relevant entry in the C++ FAQ.For info, another related-but-not-quite-the-same thing in .NET is [InternalsVisibleTo], which lets an assembly designate another assembly (such as a unit test assembly) that (effectively) has "internal" access to types/members in the original assembly.You should be able to accomplish the same sorts of things that "friend" is used for in C++ by using interfaces in C#.  It requires you to explicitly define which members are being passed between the two classes, which is extra work but may also make the code easier to understand.If somebody has an example of a reasonable use of "friend" that cannot be simulated using interfaces, please share it!  I\'d like to better understand the differences between C++ and C#.With friend a C++ designer has precise control over whom the private* members are exposed to.  But, he\'s forced to expose every one of the private members.With internal a C# designer has precise control over the set of private members he\xe2\x80\x99s exposing.  Obviously, he can expose just a single private member.  But, it will get exposed to all classes in the assembly.Typically, a designer desires to expose only a few private methods to selected few other classes.  For example, in a class factory pattern it may be desired that class C1 is instantiated only by class factory CF1.  Therefore class C1 may have a protected constructor and a friend class factory CF1.As you can see, we have 2 dimensions along which encapsulation can be breached.  friend breaches it along one dimension, internal does it along the other.  Which one is a worse breach in the encapsulation concept?  Hard to say.  But it would be nice to have both friend and internal available.  Furthermore, a good addition to these two would be the 3rd type of keyword, which would be used on member-by-member basis (like internal) and specifies the target class (like friend).\n* For brevity I will use "private" instead of "private and/or protected".\n- NickYou can get close to C++ "friend" with the C# keyword "internal".This is actually not an issue with C#.  It\'s a fundamental limitation in IL.  C# is limited by this, as is any other .Net language that seeks to be verifiable.  This limitation also includes managed classes defined in C++/CLI (Spec section 20.5).  That being said I think that Nelson has a good explanation as to why this is a bad thing. Friend is extremely useful when writing unit test.Whilst that comes at a cost of polluting your class declaration slightly, it\'s also a compiler-enforced reminder of what tests actually might care about the internal state of the class.A very useful and clean idiom I\'ve found is when I have factory classes, making them friends of the items they create which have a protected constructor. More specifically, this was when I had a single factory responsible for creating matching rendering objects for report writer objects, rendering to a given environment. In this case you have a single point of knowledge about the relationship between the report-writer classes (things like picture blocks, layout bands, page headers etc.) and their matching rendering objects.C# is missing the "friend" keyword for the same reason its missing deterministic destruction.  Changing conventions makes people feel smart, as if their new ways are superior to someone else\' old ways.  It\'s all about pride.Saying that "friend classes are bad" is as short-sighted as other unqualified statements like "don\'t use gotos" or "Linux is better than Windows".The "friend" keyword combined with a proxy class is a great way to only expose certain parts of a class to specific other class(es).  A proxy class can act as a trusted barrier against all other classes.  "public" doesn\'t allow any such targeting, and using "protected" to get the effect with inheritance is awkward if there really is no conceptual "is a" relationship.In fact, C# gives possibility to get same behavior in pure OOP way without special words - it\'s private interfaces.As far as question What is the C# equivalent of friend? was marked as duplicate to this article and no one there propose really good realization - I will show answer on both question here.Main idea was taking from here: What is a private interface?Let\'s say, we need some class which could manage instances of another classes and call some special methods on them. We don\'t want to give possibility to call this methods to any other classes. This is exactly same thing  what friend c++ keyword do in c++ world.I think good example in real practice could be Full State Machine pattern where some controller update current state object and switch to another state object when necessary.You could: Controller.csProgram.csWell, what about inheritance? We need to use technique described in Since explicit interface member implementations cannot be declared virtual and mark IState as protected to give possibility to derive from Controller too.Controller.csPlayerIdleState.csAnd finally example how to test class Controller throw inheritance:\nControllerTest.csHope I cover all cases and my answer was useful.Stop making excuses for this limitation. friend is bad, but internal is good? they are the same thing, only that friend gives you more precise control over who is allowed to access and who isn\'t.This is to enforce the encapsulation paradigm? so you have to write accessor methods and now what? how are you supposed to stop everyone (except the methods of class B) from calling these methods? you can\'t, because you can\'t control this either, because of missing "friend".No programming language is perfect. C# is one of the best languages I\'ve seen, but making silly excuses for missing features doesn\'t help anyone. In C++, I miss the easy event/delegate system, reflection (+automatic de/serialization) and foreach, but in C# I miss operator overloading (yeah, keep telling me that you didn\'t need it), default parameters, a const that cannot be circumvented, multiple inheritance (yeah, keep telling me that you didn\'t need it and interfaces were a sufficient replacement) and the ability to decide to delete an instance from memory (no, this is not horribly bad unless you are a tinkerer)There is the InternalsVisibleToAttribute since .Net 3 but I suspect they only added it to cater to test assemblies after the rise of unit testing. I can\'t see many other reasons to use it.It works at the assembly level but it does the job where internal doesn\'t; that is, where you want to distribute an assembly but want another non-distributed assembly to have privileged access to it.Quite rightly they require the friend assembly to be strong keyed to avoid someone creating a pretend friend alongside your protected assembly.I have read many smart comments about "friend" keyword & i agree what it is useful thing, but i think what "internal" keyword is less useful, & they both still bad for pure OO programming. What we have? (saying about "friend" I also saying about "internal")yes;is not using "friend" makes code better? Using friend makes some local problems, not using it makes problems for code-library-users.the common good solution for programming language i see like this:What do you think about it? I think it the most common & pure object-oriented solution. You can open access any method you choose to any class you want.I suspect it has something to do with the C# compilation model -- building IL the JIT compiling that at runtime. i.e.: the same reason that C# generics are fundamentally different to C++ generics.If you are working with C++ and you find your self using friend keyword, it is a very strong indication, that you have a design issue, because why the heck a class needs to access the private members of other class??you can keep it private and use reflection to call functions. Test framework can do this if you ask it to test a private functionI used to regularly use friend, and I don\'t think it\'s any violation of OOP or a sign of any design flaw.  There are several places where it is the most efficient means to the proper end with the least amount of code.One concrete example is when creating interface assemblies that provide a communications interface to some other software.  Generally there are a few heavyweight classes that handle the complexity of the protocol and peer peculiarities, and provide a relatively simple connect/read/write/forward/disconnect model involving passing messages and notifications between the client app and the assembly.  Those messages / notifications need to be wrapped in classes.  The attributes generally need to be manipulated by the protocol software as it is their creator, but a lot of stuff has to remain read-only to the outside world.It\'s just plain silly to declare that it\'s a violation of OOP for the protocol / "creator" class to have intimate access to all of the created classes -- the creator class has had to bit munge every bit of data on the way up.  What I\'ve found most important is to minimize all the BS extra lines of code the "OOP for OOP\'s Sake" model usually leads to.  Extra spaghetti just makes more bugs.Do people know that you can apply the internal keyword at the attribute, property, and method level?  It\'s not just for the top level class declaration (though most examples seem to show that.)If you have a C++ class that uses the friend keyword, and want to emulate that in a C# class:\n1.  declare the C# class public\n2.  declare all the attributes/properties/methods that are protected in C++ and thus accessible to friends as internal in C#\n3.  create read only properties for public access to all internal attributes and propertiesI agree it\'s not 100% the same as friend, and unit test is a very valuable example of the need of something like friend (as is protocol analyzer logging code).  However internal provides the exposure to the classes you want to have exposure, and [InternalVisibleTo()] handles the rest -- seems like it was born specifically for unit test.As far as friend "being better because you can explicitely control which classes have access" -- what in heck are a bunch of suspect evil classes doing in the same assembly in the first place?  Partition your assemblies!The friendship may be simulated by separating interfaces and implementations. The idea is: "Require a concrete instance but restrict construction access of that instance".For exampleIn spite of the fact that ItsMeYourFriend() is public only Friend class can access it, since no one else can possibly get a concrete instance of the Friend class. It has a private constructor, while the factory New() method returns an interface.See my article Friends and internal interface members at no cost with coding to interfaces for details.Some have suggested that things can get out of control by using friend. I would agree, but that doesn\'t lessen its usefulness. I\'m not certain that friend necessarily hurts the OO paradigm any more than making all your class members public. Certainly the language will allow you to make all your members public, but it is a disciplined programmer that avoids that type of design pattern. Likewise a disciplined programmer would reserve the use of friend for specific cases where it makes sense. I feel internal exposes too much in some cases. Why expose a class or method to everything in the assembly?I have an ASP.NET page that inherits my own base page, that in turn inherits System.Web.UI.Page. In this page, I have some code that handles end-user error reporting for the application in a protected methodNow, I have a user control that is contained in the page. I want the user control to be able to call the error reporting methods in the page. It can\'t do that if the ReportError method is protected. I can make it internal, but it is exposed to any code in the assembly. I just want it exposed to the UI elements that are part of the current page (including child controls). More specifically, I want my base control class to define the exact same error reporting methods, and simply call methods in the base page.I believe that something like friend could be useful and implemented in the language without making the language less "OO" like, perhaps as attributes, so that you can have classes or methods be friends to specific classes or methods, allowing the developer to provide very specific access. Perhaps something like...(pseudo code)In the case of my previous example perhaps have something like the following (one can argue semantics, but I\'m just trying to get the idea across):As I see it, the friend concept has no more risk to it than making things public, or creating public methods or properties to access members. If anything friend allows another level of granularity in accessibility of data and allows you to narrow that accessibility rather than broadening it with internal or public. B.s.d.It was stated that, friends hurts pure OOness. Which I agree.It was also stated that friends help encapsulation, which I also agree.I think friendship should be added to the OO methodology, but not quite as it in C++. I\'d like to have some fields/methods that my friend class can access, but I\'d NOT like them to access ALL my fields/methods. As in real life, I\'d let my friends access my personal refrigerator but I\'d not let them to access my bank account.One can implement that as followedThat will of course generate a compiler warning, and will hurt the intellisense. But it will do the work.On a side note, I think that a confident programmer should do the testing unit without accessing the private members. this is quite out of the scope, but try to read about TDD.\nhowever, if you still want to do so (having c++ like friends) try something likeso you write all your code without defining UNIT_TESTING and when you want to do the unit testing you add #define UNIT_TESTING to the first line of the file(and write all the code that do the unit testing under #if UNIT_TESTING). That should be handled carefully.Since I think that unit testing is a bad example for the use of friends, I\'d give an example why I think friends can be good. Suppose you have a breaking system (class). With use, the breaking system get worn out and need to get renovated. Now, you want that only a licensed mechanic would fix it. To make the example less trivial I\'d say that the mechanic would use his personal (private) screwdriver to fix it. That\'s why mechanic class should be friend of breakingSystem class.The friendship may also be simulated by using "agents" - some inner classes. Consider following example:It could be alot simpler when used for access only to static members.\nBenefits for such implementation is that all the types are declared in the inner scope of friendship classes and, unlike interfaces, it allows static members to be accessed.Fields that ALL classes can access them are public.Fields that NOT all other classes can access them are private.(if the fields belongs to (declared inside) base class, then they are protected instead)Fields that only their owner class can access them are private, and have no properties and get set methods.Fields that only their owner class and some other classes can access them are private and each has special private get and set methods, and public share methods.The some other classes that can also access these fields will have some private fields of delegate types and special public direct methods.Example:You have to know that using the \'friend\' keyword of the C++ is to allow some classes to share their private members to some other classes directly.Because of that the \'friend\' keyword doesn\'t exist in C#, classes have no way to share their private fields to some other classes directly, but there is way to simulate it indeed as I shown above.Do you know that the \'friend\' keyword of C++ also can allow in the implementation of some functions to access the private members of some instances of some classes types?The answer is yes and I will show you how to simulate this too in C#:Example:I must admit that before I posted this code, I didn\'t know how to find out the MethodInfo of the previous method that called the current method, but Firas Assaad\'s answer helped me, thanks to him too.How can I find the method that called the current method?He suggested to use the System.Diagnostics.StackTrace classHope that you got my idea, and that helps and answers your question.I didn\'t find this answer anywhere in the internet, I thought about this idea by myself using my brain.I will answer only "How" question.There are so many answers here, however I would like to propose kind of "design pattern" to achieve that feature. I will use simple language mechanism, which includes: For example we have 2 main classes: Student and University. Student has GPA which only university allowed to access. Here is the code: