According to this: http://developer.android.com/preview/features/runtime-permissions.html#coding an app can check for runtime permissions and request permissions if it hasn\'t been granted already. The following dialog will be displayed then:In case the user declines an important permission, imo an app should display an explanation why the permission is needed and what impact declining has. That dialog has two options: 1) re-try again (permission is requested again), 2) deny (app will work without that permission).If the user checks "Never ask again" however, the second dialog with the explanation shouldn\'t be shown, especially if the user already declined once before.\nNow the question is: how does my app know whether the user has checked the "Never ask again"? IMO the onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) doesn\'t give me that information.A second question would be: does Google have plans to incorporate a custom message in the permission dialog that would explain why the app needs the permission? That way there would never be a second dialog which would certainly make for a better ux.Developer Preview 2 brings some changes to how permissions are requested by the app (see also http://developer.android.com/preview/support.html#preview2-notes).The first dialog now looks like this:There\'s no "Never show again" check-box (unlike developer preview 1). If the user denies the permission and if the permission is essential for the app it could present another dialog to explain the reason the app asks for that permission, e.g. like this:If the user declines again the app should either shut down if it absolutely needs that permission or keep running with limited functionality. If the user reconsiders (and selects re-try), the permission is requested again. This time the prompt looks like this:The second time the "Never ask again" check-box is shown. If the user denies again and the check-box is ticked nothing more should happen.\nWhether or not the check-box is ticked can be determined by using Activity.shouldShowRequestPermissionRationale(String), e.g. like this:That\'s what the Android documentation says (https://developer.android.com/training/permissions/requesting.html):To help find the situations where you need to provide extra\n  explanation, the system provides the\n  Activity.shouldShowRequestPermissionRationale(String) method. This\n  method returns true if the app has requested this permission\n  previously and the user denied the request. That indicates that you\n  should probably explain to the user why you need the permission.If the user turned down the permission request in the past and chose\n  the Don\'t ask again option in the permission request system dialog,\n  this method returns false. The method also returns false if the device\n  policy prohibits the app from having that permission. To know if the user denied with "never ask again" you can check again the shouldShowRequestPermissionRationale method in your onRequestPermissionsResult when the user did not grant the permission.You can open your app setting with this code:There is no way of sending the user directly to the Authorization page.You can check shouldShowRequestPermissionRationale() in your onRequestPermissionsResult().\nhttps://youtu.be/C8lUdPVSzDk?t=2m23sCheck whether permission was granted or not in onRequestPermissionsResult(). If not then check shouldShowRequestPermissionRationale(). Below is sample code.Apparently, google maps does exactly this for location permission.Here is a nice and easy method to check the current permission status:Caveat: returns BLOCKED_OR_NEVER_ASKED the first app start, before the user accepted/denied the permission through the user prompt (on sdk 23+ devices)Update:The Android support library now also seems to have a very similar class android.support.v4.content.PermissionChecker which contains a checkSelfPermission() which returns:May be useful for someone:--What I have noticed is, if we check the shouldShowRequestPermissionRationale() flag in to onRequestPermissionsResult() callback method, it shows only two states.State 1:-Return true:-- Any time user clicks Deny permissions (including the very first time).State 2:-Returns false :- if user selects \xe2\x80\x9cnever asks again".Link of detailed working exampleIf you want to detect all the "states" (first time denied, just been denied, just been denied with "Never Ask Again" or permanently denied) you can do the following:Create 2 booleansSet the first one before asking for permission:Set the second one inside your onRequestPermissionsResult method:Use the following "table" to do whatever you need in onRequestPermissionsResult() (after checking that you still don\'t have the permission):I had the same problem and I figured it out. To make life much simpler, I wrote an util class to handle runtime permissions.And the PreferenceUtil methods are as follows.Now, all you need is to use the method * checkPermission* with proper arguments. Here is an example,how does my app know whether the user has checked the "Never ask again"?If user checked Never ask again, you\'ll get callback on onPermissionDisabled.Happy coding :)You can determine it by checking if permission rationale is to be shown inside the onRequestPermissionsResult() callback method. And if you find any permission set to never ask again, you can request users to grant permissions from the settings.My full implementation would be like below. It works for both single or multiple permissions requests.I wrote a shorthand for permission request in Android M. This code also handles backwards compatibility to older Android versions.All the ugly code is extracted into a Fragment which attaches and detaches itself to the Activity requesting the permissions.You can use PermissionRequestManager as following:Take a look: https://gist.github.com/crysxd/385b57d74045a8bd67c4110c34ab74aaPlease don\'t throw stones at me for this solution. This works but is a bit "hacky".When you call requestPermissions, register the current time.Then in onRequestPermissionsResult if the result is not granted, check the time again.Since the user did cannot possibly click so fast on the deny button, we know that he selected "never ask again" because the callback is instant.Use at your own risks.I would also like to obtain the information whether or not the user has selected "never ask again". I have achieved a \'almost solution\' with an ugly looking flag, but before I tell you how, I will tell you about my motivation:I would like to offer the permission referring functionality initially. If the user uses it and has no rights, he/she gets the either the 1th dialog from above or both the 2nd and 3rd. When the user has chosen \'Never ask again\' I would like to disable the functionality and to display it differently. - My action is triggered by a spinner text entry, I would also like to add \'(Permission revoked)\' to the label text displayed. This shows to the user: \'There is functionality but I cannot use it, due to my permission settings.\' However, this does not seem to be possible, as I cannot check whether or not \'Never ask again\' has been chosen.I came to a solution I can live with by having my functionality always enabled with an active permission check. I am showing a Toast message in onRequestPermissionsResult() in case of a negative response but only if I have not shown my custom rationale popup. So if the user has chosen \'Never ask again\' he gets a toast message only. If the user is reluctant to chose \'never ask again\' he gets only the custom rationale and the permission request popup by the operation system but not toast, as three notifications in a row would be too much pain.Instead you will receive callback on onRequestPermissionsResult() as PERMISSION_DENIED when you request permission again while falling in false condition of shouldShowRequestPermissionRationale()From Android doc:When the system asks the user to grant a permission, the user has the option of telling the system not to ask for that permission again. In that case, any time an app uses requestPermissions() to ask for that permission again, the system immediately denies the request. The system calls your onRequestPermissionsResult() callback method and passes PERMISSION_DENIED, the same way it would if the user had explicitly rejected your request again. This means that when you call requestPermissions(), you cannot assume that any direct interaction with the user has taken place.}I have to implement dynamic permission for camera. Where 3 possible cases occurs: 1. Allow, 2. Denied, 3. Don\'t ask again.You can use  if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA) method to detect whether never ask is checked or not.For more reference : Check thisTo check for multiple permissions use:explain() methodAbove code will also show dialog, which will redirect user to app settings screen from where he can give permission if had checked never ask again button.The method shouldShowRequestPermissionRationale() can be user to check whether the user selected the \'never asked again\' option and denied the permission.\nThere\'s plenty of code examples, so I would rather explain how to use it for such a purpose, because I think its name and its implementation makes this more complicated that it actually is.As explained in Requesting Permissions at Run Time, that method  returns true if the option \'never ask again\' is visible, false otherwise; so it returns false the very first time a dialog is shown, then from the second time on it returns true, and only if the user deny the permission selecting the option, at that point it returns false again.To detect such a case, either you can detect the sequence false-true-false, or (more simple) you can have a flag which keeps track of the initial time the dialog is shown. After that, that method returns either true or false, where the false will allow you to detect when the option is selected.Expanding on mVck\'s answer above, the following logic determines whether "Never ask again" has been checked for a given Permission Request:which is excerpted from below (for the full example see this answer)