Can anyone provide a good explanation of the volatile keyword in C#? Which problems does it solve and which it doesn\'t? In which cases will it save me the use of locking?I don\'t think there\'s a better person to answer this than Eric Lippert (emphasis in the original): In C#, "volatile" means not only "make sure that the compiler and the\n  jitter do not perform any code reordering or register caching\n  optimizations on this variable". It also means "tell the processors to\n  do whatever it is they need to do to ensure that I am reading the\n  latest value, even if that means halting other processors and making\n  them synchronize main memory with their caches".Actually, that last bit is a lie. The true semantics of volatile reads\n  and writes are considerably more complex than I\'ve outlined here; in\n  fact they do not actually guarantee that every processor stops what it\n  is doing and updates caches to/from main memory. Rather, they provide\n  weaker guarantees about how memory accesses before and after reads and\n  writes may be observed to be ordered with respect to each other.\n  Certain operations such as creating a new thread, entering a lock, or\n  using one of the Interlocked family of methods introduce stronger\n  guarantees about observation of ordering. If you want more details,\n  read sections 3.10 and 10.5.3 of the C# 4.0 specification.Frankly, I discourage you from ever making a volatile field. Volatile\n  fields are a sign that you are doing something downright crazy: you\'re\n  attempting to read and write the same value on two different threads\n  without putting a lock in place. Locks guarantee that memory read or\n  modified inside the lock is observed to be consistent, locks guarantee\n  that only one thread accesses a given chunk of memory at a time, and so\n  on. The number of situations in which a lock is too slow is very\n  small, and the probability that you are going to get the code wrong\n  because you don\'t understand the exact memory model is very large. I\n  don\'t attempt to write any low-lock code except for the most trivial\n  usages of Interlocked operations. I leave the usage of "volatile" to\n  real experts.For further reading see:If you want to get slightly more technical about what the volatile keyword does, consider the following program (I\'m using DevStudio 2005):Using the standard optimised (release) compiler settings, the compiler creates the following assembler (IA32):Looking at the output, the compiler has decided to use the ecx register to store the value of the j variable. For the non-volatile loop (the first) the compiler has assigned i to the eax register. Fairly straightforward. There are a couple of interesting bits though - the lea ebx,[ebx] instruction is effectively a multibyte nop instruction so that the loop jumps to a 16 byte aligned memory address. The other is the use of edx to increment the loop counter instead of using an inc eax instruction. The add reg,reg instruction has lower latency on a few IA32 cores compared to the inc reg instruction, but never has higher latency. Now for the loop with the volatile loop counter. The counter is stored at [esp] and the volatile keyword tells the compiler the value should always be read from/written to memory and never assigned to a register. The compiler even goes so far as to not do a load/increment/store as three distinct steps (load eax, inc eax, save eax) when updating the counter value, instead the memory is directly modified in a single instruction (an add mem,reg). The way the code has been created ensures the value of the loop counter is always up-to-date within the context of a single CPU core. No operation on the data can result in corruption or data loss (hence not using the load/inc/store since the value can change during the inc thus being lost on the store). Since interrupts can only be serviced once the current instruction has completed, the data can never be corrupted, even with unaligned memory.Once you introduce a second CPU to the system, the volatile keyword won\'t guard against the data being updated by another CPU at the same time. In the above example, you would need the data to be unaligned to get a potential corruption. The volatile keyword won\'t prevent potential corruption if the data cannot be handled atomically, for example, if the loop counter was of type long long (64 bits) then it would require two 32 bit operations to update the value, in the middle of which an interrupt can occur and change the data.So, the volatile keyword is only good for aligned data which is less than or equal to the size of the native registers such that operations are always atomic.The volatile keyword was conceived to be used with IO operations where the IO would be constantly changing but had a constant address, such as a memory mapped UART device, and the compiler shouldn\'t keep reusing the first value read from the address.If you\'re handling large data or have multiple CPUs then you\'ll need a higher level (OS) locking system to handle the data access properly.If you are using .NET 1.1, the volatile keyword is needed when doing double checked locking. Why? Because prior to .NET 2.0, the following scenario could cause a second thread to access an non-null, yet not fully constructed object:Prior to .NET 2.0, this.foo could be assigned the new instance of Foo, before the constructor was finished running. In this case, a second thread could come in (during thread 1\'s call to Foo\'s constructor) and experience the following:Prior to .NET 2.0, you could declare this.foo as being volatile to get around this problem. Since .NET 2.0, you no longer need to use the volatile keyword to accomplish double checked locking.Wikipedia actually has a good article on Double Checked Locking, and briefly touches on this topic:\nhttp://en.wikipedia.org/wiki/Double-checked_lockingFrom MSDN:\nThe volatile modifier is usually used for a field that is accessed by multiple threads without using the lock statement to serialize access. Using the volatile modifier ensures that one thread retrieves the most up-to-date value written by another thread.Sometimes, the compiler will optimize a field and use a register to store it. If thread 1 does a write to the field and another thread accesses it, since the update was stored in a register (and not memory), the 2nd thread would get stale data.You can think of the volatile keyword as saying to the compiler "I want you to store this value in memory". This guarantees that the 2nd thread retrieves the latest value.The CLR likes to optimize instructions, so when you access a field in code it might not always access the current value of the field (it might be from the stack, etc). Marking a field as volatile ensures that the current value of the field is accessed by the instruction. This is useful when the value can be modified (in a non-locking scenario) by a concurrent thread in your program or some other code running in the operating system.You obviously lose some optimization, but it does keep the code more simple.The compiler sometimes changes the order of statements in code to optimize it. Normally this is not a problem in single-threaded environment, but it might be an issue in multi-threaded environment. See following example: \nIf you run t1 and t2, you would expect no output or "Value: 10" as the result. It could be that the compiler switches line inside t1 function. If t2 then executes, it could be that _flag has value of 5, but _value has 0. So expected logic could be broken. To fix this you can use volatile keyword that you can apply to the field. This statement disables the compiler optimizations so you can force the correct order in you code.You should use volatile only if you really need it, because it disables certain compiler optimizations, it will hurt performance. It\'s also not supported by all .NET languages (Visual Basic doesn\'t support it), so it hinders language interoperability.multiple threads can access a variable.\nThe latest update will be on the variable