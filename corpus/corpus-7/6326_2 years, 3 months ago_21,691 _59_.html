I have recently started to learn C and I am taking a class with C as the subject. I\'m currently playing around with loops and I\'m running into some odd behaviour which I don\'t know how to explain. On my laptop running Ubuntu 14.04, this code does not break. It runs to completion. On my school\'s computer running CentOS 6.6, it also runs fine. On Windows 8.1, the loop never terminates. What\'s even more strange is that when I edit the condition of the for loop to: i <= 11, the code only terminates on my laptop running Ubuntu. It never terminates in CentOS and Windows. Can anyone explain what\'s happening in the memory and why the different OSes running the same code give different outcomes? EDIT: I know the for loop goes out of bounds. I\'m doing it intentionally. I just can\'t figure out how the behaviour can be different across different OSes and computers. On my laptop running Ubuntu 14.04, this code does not break it runs to completion. On my school\'s computer running CentOS 6.6, it also runs fine. On Windows 8.1, the loop never terminates.What is more strange is when I edit the conditional of the for loop to: i <= 11, the code only terminates on my laptop running Ubuntu. CentOS and Windows never terminates. You\'ve just discovered memory stomping.  You can read more about it here: What is a \xe2\x80\x9cmemory stomp\xe2\x80\x9d?When you allocate int array[10],i;, those variables go into memory (specifically, they\'re allocated on the stack, which is a block of memory associated with the function).  array[] and i are probably adjacent to each other in memory.  It seems that on Windows 8.1, i is located at array[10].  On CentOS, i is located at array[11].  And on Ubuntu, it\'s in neither spot (maybe it\'s at array[-1]?).Try adding these debugging statements to your code.  You should notice that on iteration 10 or 11, array[i] points at i.The bug lies between these pieces of code:Since array only has 10 elements, in the last iteration array[10] = 0; is a buffer overflow. Buffer overflows are UNDEFINED BEHAVIOR, which means they might format your hard drive or cause demons to fly out of your nose.It is fairly common for all stack variables to be laid out adjacent to each other. If i is located where array[10] writes to, then the UB will reset i to 0, thus leading to the unterminated loop.To fix, change the loop condition to i < 10.In what should be the last run of the loop,you write to array[10], but there are only 10 elements in the array, numbered 0 through 9. The C language specification says that this is \xe2\x80\x9cundefined behavior\xe2\x80\x9d. What this means in practice is that your program will attempt to write to the int-sized piece of memory that lies immediately after array in memory. What happens then depends on what does, in fact, lie there, and this depends not only on the operating system but more so on the compiler, on the compiler options (such as optimization settings), on the processor architecture, on the surrounding code, etc. It could even vary from execution to execution, e.g. due to address space randomization (probably not on this toy example, but it does happen in real life). Some possibilities include:What you observed on Windows was that the compiler decided to place the variable i immediately after the array in memory, so array[10] = 0 ended up assigning to i. On Ubuntu and CentOS, the compiler didn\'t place i there. Almost all C implementations do group local variables in memory, on a memory stack, with one major exception: some local variables can be placed entirely in registers. Even if the variable is on the stack, the order of variables is determined by the compiler, and it may depend not only on the order in the source file but also on their types (to avoid wasting memory to alignment constraints that would leave holes), on their names, on some hash value used in a compiler\'s internal data structure, etc.If you want to find out what your compiler decided to do, you can tell it to show you the assembler code. Oh, and learn to decipher assembler (it\'s easier than writing it). With GCC (and some other compilers, especially in the Unix world), pass the option -S to produce assembler code instead of a binary. For example, here\'s the assembler snippet for the loop from compiling with GCC on amd64 with the optimization option -O0 (no optimization), with comments added manually:Here the variable i is 52 bytes below the top of the stack, while the array starts 48 bytes below the top of the stack. So this compiler happens to have placed i just before the array; you\'d overwrite i if you happened to write to array[-1]. If you change array[i]=0 to array[9-i]=0, you\'ll get an infinite loop on this particular platform with these particular compiler options.Now let\'s compile your program with gcc -O1.That\'s shorter! The compiler has not only declined to allocate a stack location for i \xe2\x80\x94 it\'s only ever stored in the register ebx \xe2\x80\x94 but it hasn\'t bothered to allocate any memory for array, or to generate code to set its elements, because it noticed that none of the elements are ever used.To make this example more telling, let\'s ensure that the array assignments are performed by providing the compiler with something it isn\'t able to optimize away. An easy way to do that is to use the array from another file \xe2\x80\x94\xc2\xa0because of separate compilation, the compiler doesn\'t know what happens in another file (unless it optimizes at link time, which gcc -O0 or gcc -O1 doesn\'t). Create a source file use_array.c containingand change your source code toCompile withThis time the assembler code looks like this:Now the array is on the stack, 44 bytes from the top. What about i? It doesn\'t appear anywhere! But the loop counter is kept in the register rbx. It\'s not exactly i, but the address of the array[i]. The compiler has decided that since the value of i was never used directly, there was no point in performing arithmetic to calculate where to store 0 during each run of the loop. Instead that address is the loop variable, and the arithmetic to determine the boundaries was performed partly at compile time (multiply 11 iterations by 4 bytes per array element to get 44) and partly at run time but once and for all before the loop starts (perform a subtraction to get the initial value).Even on this very simple example, we\'ve seen how changing compiler options (turn on optimization) or changing something minor (array[i] to array[9-i]) or even changing something apparently unrelated (adding the call to use_array) can make a significant difference to what the executable program generated by the compiler does. Compiler optimizations can do a lot of things that may appear unintuitive on programs that invoke undefined behavior. That\'s why undefined behavior is left completely undefined. When you deviate ever so slightly from the tracks, in real-world programs, it can be very hard to understand the relationship between what the code does and what it should have done, even for experienced programmers.Unlike Java, C doesn\'t do array boundary check, i.e, there\'s no ArrayIndexOutOfBoundsException, the job of making sure the array index is valid is left to the programmer. Doing this on purpose leads to undefined behavior, anything could happen.For an array:indexes are only valid in the range 0 to 9. However, you are trying to:access array[10] here, change the condition to i < 10You have a bounds violation, and on the non-terminating platforms, I believe you are inadvertently setting i to zero at the end of the loop, so that it starts over again.array[10] is invalid; it contains 10 elements, array[0] through array[9], and array[10] is the 11th.  Your loop should be written to stop before 10, as follows:Where array[10] lands is implementation-defined, and amusingly, on two of your platforms, it lands on i, which those platforms apparently lay out directly after array.  i is set to zero and the loop continues forever.  For your other platforms, i may be located before array, or array may have some padding after it.You declare int array[10] means array has index 0 to 9 (total 10 integer elements it can hold). But the following loop,will loop 0 to 10 means 11 time. Hence when i = 10 it will overflow the buffer and cause Undefined Behavior.So try this:or,Since you created an array of size 10, for loop condition should be as follows:Currently you are trying to access the unassigned location from the memory using array[10] and it is causing the undefined behavior.  Undefined behavior means your program will behave undetermined fashion, so it can give different outputs in each execution.It is undefined at array[10], and gives undefined behavior as described before. Think about it like this:I have 10 items in my grocery cart. They are:0: A box of cereal\n1: Bread\n2: Milk\n3: Pie\n4: Eggs\n5: Cake\n6: A 2 liter of soda\n7: Salad\n8: Burgers\n9: Ice creamcart[10] is undefined, and may give an out of bounds exception in some compilers. But, a lot apparently don\'t. The apparent 11th item is an item not actually in the cart. The 11th item is pointing to, what I\'m going to call, a "poltergeist item." It never existed, but it was there.Why some compilers give i an index of array[10] or array[11] or even array[-1] is because of your initialization/declaration statement. Some compilers interpret this as:Some compilers want things to go quicker, and some compilers prefer safety. It\'s all about the context. If I was developing an app for the ancient BREW OS (the OS of a basic phone), for example, it wouldn\'t care about safety. If I was developing for an iPhone 6, then it could run fast no matter what, so I would need an emphasis on safety. (Seriously, have you read Apple\'s App Store Guidelines, or read up on the development of Swift and Swift 2.0?)Well, C compiler traditionally does not check for bounds.  You can get a segmentation fault in case you refer to a location that does not "belong" to your process.  However, the local variables are allocated on stack and depending on the way the memory is allocated, the area just beyond the array (array[10]) may belong to the process\' memory segment.  Thus, no segmentation fault trap is thrown and that is what you seem to experience.  As others have pointed out, this is undefined behavior in C and your code may be considered erratic.  Since you are learning C, you are better off getting into the habit of checking for bounds in your code.Beyond the possibility that memory might be laid out so that an attempt to write to a[10] actually overwrites i, it would also be possible that an optimizing compiler might determine that the loop test cannot be reached with a value of i greater than ten without code having first accessed the non-existent array element a[10].Since an attempt to access that element would be undefined behavior, the compiler would have no obligations with regard to what the program might do after that point. More specifically, since the compiler would have no obligation to generate code to check the loop index in any case where it might be greater than ten, it would have no obligation to generate code to check it at all; it could instead assume that the <=10 test will always yield true. Note that this would be true even if the code would read a[10] rather than writing it.When you iterate past i==9 you assign zero to the \'array items\' which are actually located past the array, so you\'re overwritnig some other data. Most probably you overwrite the i variable, which is located after a[]. That way you simply reset the i variable to zero and thus restart the loop.You could discover that yourself if you printed i in the loop:  instead of justOf course that result strongly depends on the memory allocation for your variables, which in turn depends on a compiler and its settings, so it is generally Undefined Behavior \xe2\x80\x94 that\'s why results on different machines or different operating systems or on different compilers may differ.the error is in portion array[10] w/c is also address of i (int array[10],i;). \nwhen array[10] is set to 0 then the i would be 0 w/c resets the entire loop and \ncauses the infinite loop. \n    there will be infinite loop if  array[10] is between 0-10.the correct loop should be for (i = 0; i <10 ; i++) {...} \n            int array[10],i;\n            for (i = 0; i <=10 ; i++)\n            array[i]=0;I will suggest something that I dint find above:Try assigning array[i] = 20;I guess this should terminate the code everywhere.. (given you keep i< =10 or ll)If this runs you can firmly decide that the answers specified here already are correct [the answer related to memory stomping one for ex.] There are two things wrong here. The int i is actually an array element, array[10], as seen on the stack. Because you have allowed the indexing to actually make array[10] = 0, the loop index, i, will never exceed 10. Make it for(i=0; i<10; i+=1).i++ is, as K&R would call it, \'bad style\'. It is incrementing i by the size of i, not 1. i++ is for pointer math and i+=1 is for algebra. While this depends on the compiler, it is not a good convention for portability. 