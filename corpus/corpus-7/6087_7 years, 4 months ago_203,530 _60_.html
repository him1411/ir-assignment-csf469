Do you need to dispose of objects and set them to null, or will the garbage collector clean them up when they go out of scope?Objects will be cleaned up when they are no longer being used and when the garbage collector sees fit.  Sometimes, you may need to set an object to null in order to make it go out of scope (such as a static field whose value you no longer need), but overall there is usually no need to set to null.Regarding disposing objects, I agree with @Andre.  If the object is IDisposable it is a good idea to dispose it when you no longer need it, especially if the object uses unmanaged resources. Not disposing unmanaged resources will lead to memory leaks.You can use the using statement to automatically dispose an object once your program leaves the scope of the using statement.Which is functionally equivalent to:Objects never go out of scope in C# as they do in C++. They are dealt with by the Garbage Collector automatically when they are not used anymore. This is a more complicated approach than C++ where the scope of a variable is entirely deterministic. CLR garbage collector actively goes through all objects that have been created and works out if they are being used. An object can go "out of scope" in one function but if its value is returned, then GC would look at whether or not the calling function holds onto the return value.Setting object references to null is unnecessary as garbage collection works by working out which objects are being referenced by other objects. In practice, you don\'t have to worry about destruction, it just works and it\'s great :)Dispose must be called on all objects that implement IDisposable when you are finished working with them. Normally you would use a using block with those objects like so:EDIT On variable scope. Craig has asked whether the variable scope has any effect on the object lifetime. To properly explain that aspect of CLR, I\'ll need to explain a few concepts from C++ and C#.In both languages the variable can only be used in the same scope as it was defined - class, function or a statement block enclosed by braces. The subtle difference, however, is that in C#, variables cannot be redefined in a nested block.In C++, this is perfectly legal:In C#, however you get a a compiler error:This makes sense if you look at generated MSIL - all the variables used by the function are defined at the start of the function. Take a look at this function:Below is the generated IL. Note that iVal2, which is defined inside the if block is actually defined at function level. Effectively this means that C# only has class and function level scope as far as variable lifetime is concerned.Whenever a C++ variable, allocated on the stack, goes out of scope it gets destructed. Remember that in C++ you can create objects on the stack or on the heap. When you create them on the stack, once execution leaves the scope, they get popped off the stack and gets destroyed.When C++ objects are created on the heap, they must be explicitly destroyed, otherwise it is a memory leak. No such problem with stack variables though.In CLR, objects (i.e. reference types) are always created on the managed heap. This is further reinforced by object creation syntax. Consider this code snippet.In C++ this would create an instance on MyClass on the stack and call its default constructor. In C# it would create a reference to class MyClass that doesn\'t point to anything. The only way to create an instance of a class is by using new operator:In a way, C# objects are a lot like objects that are created using new syntax in C++ - they are created on the heap but unlike C++ objects, they are managed by the runtime, so you don\'t have to worry about destructing them.Since the objects are always on the heap the fact that object references (i.e. pointers) go out of scope becomes moot. There are more factors involved in determining if an object is to be collected than simply presence of references to the object.Jon Skeet compared object references in Java to pieces of string that are attached to the balloon, which is the object. Same analogy applies to C# object references. They simply point to a location of the heap that contains the object. Thus, setting it to null has no immediate effect on the object lifetime, the balloon continues to exist, until the GC "pops" it.Continuing down the balloon analogy, it would seem logical that once the balloon has no strings attached to it, it can be destroyed. In fact this is exactly how reference counted objects work in non-managed languages. Except this approach doesn\'t work for circular references very well. Imagine two balloons that are attached together by a string but neither balloon has a string to anything else. Under simple ref counting rules, they both continue to exist, even though the whole balloon group is "orphaned"..NET objects are a lot like helium balloons under a roof. When the roof opens (GC runs) - the unused balloons float away, even though there might be groups of balloons that are tethered together..NET GC uses a combination of generational GC and mark and sweep. Generational approach involves the runtime favouring to inspect objects that have been allocated most recently, as they are more likely to be unused and mark and sweep involves runtime going through the whole object graph and working out if there are object groups that are unused. This adequately deals with circular dependency problem.Also, .NET GC runs on another thread(so called finalizer thread) as it has quite a bit to do and doing that on the main thread would interrupt your program.As others have said you definitely want to call Dispose if the class implements IDisposable. I take a fairly rigid position on this. Some might claim that calling Dispose on DataSet, for example, is pointless because they disassembled it and saw that it did not do anything meaningful. But, I think there are fallacies abound in that argument.Read this for an interesting debate by respected individuals on the subject. Then read my reasoning here why I think Jeffery Richter is in the wrong camp.Now, on to whether or not you should set a reference to null. The answer is no. Let me illustrate my point with the following code.So when do you think the object referenced by a is eligible for collection? If you said after the call to a = null then you are wrong. If you said after the Main method completes then you are also wrong. The correct answer is that it is eligible for collection sometime during the call to DoSomething. That is right. It is eligible before the reference is set to null and perhaps even before the call to DoSomething completes. That is because the JIT compiler can recognize when object references are no longer dereferenced even if they are still rooted.You never need to set objects to null in C#. The compiler and runtime will take care of figuring out when they are no longer in scope.Yes, you should dispose of objects that implement IDisposable.If the object implements IDisposable, then yes, you should dispose it.  The object could be hanging on to native resources (file handles, OS objects) that might not be freed immediately otherwise.  This can lead to resource starvation, file-locking issues, and other subtle bugs that could otherwise be avoided.See also Implementing a Dispose Method on MSDN.I agree with the common answer here that yes you should dispose and no you generally shouldn\'t set the variable to null... but I wanted to point out that dispose is NOT primarily about memory management. Yes, it can help (and sometimes does) with memory management, but it\'s primary purpose is to give you deterministic releasing of scarce resources.For example, if you open a hardware port (serial for example), a TCP/IP socket, a file (in exclusive access mode) or even a database connection you have now prevented any other code from using those items until they are released. Dispose generally releases these items (along with GDI and other "os" handles etc. which there are 1000\'s of available, but are still limited overall). If you don\'t call dipose on the owner object and explicitly release these resources, then try to open the same resource again in the future (or another program does) that open attempt will fail because your undisposed, uncollected object still has the item open. Of course, when the GC collects the item (if the Dispose pattern has been implemented correctly) the resource will get released... but you don\'t know when that will be, so you don\'t know when it\'s safe to re-open that resource. This is the primary issue Dispose  works around. Of course, releasing these handles often releases memory too, and never releasing them may never release that memory... hence all the talk about memory leaks, or delays in memory clean up.I have seen real world examples of this causing problems. For instance, I have seen ASP.Net web applications that eventually fail to connect to the database (albeit for short periods of time, or until the web server process is restarted) because the sql server \'connection pool is full\'... i.e, so many connections have been created and not explicitly released in so short a period of time that no new connections can be created and many of the connections in the pool, although not active, are still referenced by undiposed and uncollected objects and so can\'t be reused. Correctly disposing the database connections where necessary ensures this problem doesn\'t happen (at least not unless you have very high concurrent access).If they implement the IDisposable interface then you should dispose them. The garbage collector will take care of the rest.EDIT: best is to use the using command when working with disposable items:Normally, there\'s no need to set fields to null. I\'d always recommend disposing unmanaged resources however.From experience I\'d also advise you to do the following:I\'ve come across some very hard to find issues that were the direct result of not following the advice above.A good place to do this is in Dispose(), but sooner is usually better.In general, if a reference exists to an object the garbage collector (GC) may take a couple of generations longer to figure out that an object is no longer in use. All the while the object remains in memory.That may not be a problem until you find that your app is using a lot more memory than you\'d expect. When that happens, hook up a memory profiler to see what objects are not being cleaned up. Setting fields referencing other objects to null and clearing collections on disposal can really help the GC figure out what objects it can remove from memory. The GC will reclaim the used memory faster making your app a lot less memory hungry and faster.Always call dispose. It is not worth the risk. Big managed enterprise applications should be treated with respect. No assumptions can be made or else it will come back to bite you.Don\'t listen to leppie.A lot of objects don\'t actually implement IDisposable, so you don\'t have to worry about them. If they genuinely go out of scope they will be freed automatically. Also I have never come across the situation where I have had to set something to null.One thing that can happen is that a lot of objects can be held open. This can greatly increase the memory usage of your application. Sometimes it is hard to work out whether this is actually a memory leak, or whether your application is just doing a lot of stuff.Memory profile tools can help with things like that, but it can be tricky.In addition always unsubscribe from events that are not needed. Also be careful with WPF binding and controls. Not a usual situation, but I came across a situation where I had a WPF control that was being bound to an underlying object. The underlying object was large and took up a large amount of memory. The WPF control was being replaced with a new instance, and the old one was still hanging around for some reason. This caused a large memory leak.In hindsite the code was poorly written, but the point is that you want to make sure that things that are not used go out of scope. That one took a long time to find with a memory profiler as it is hard to know what stuff in memory is valid, and what shouldn\'t be there.When an object implements IDisposable you should call Dispose (or Close, in some cases, that will call Dispose for you). You normally do not have to set objects to null, because the GC will know that an object will not be used anymore.There is one exception when I set objects to null. When I retrieve a lot of objects (from the database) that I need to work on, and store them in a collection (or array). When the "work" is done, I set the object to null, because the GC does not know I\'m finished working with it.Example:I have to answer, too.\nThe JIT generates tables together with the code from it\'s static analysis of variable usage.\nThose table entries are the "GC-Roots" in the current stack frame. As the instruction pointer advances, those table entries become invalid and so ready for garbage collection.\nTherefore: If it is a scoped variable, you don\'t need to set it to null - the GC will collect the object.\nIf it is a member or a static variable, you have to set it to nullThere\'s a good discussion on the subject (along with the history behind the Dispose pattern) in this episode of .NET Rocks!http://www.dotnetrocks.com/default.aspx?showNum=10