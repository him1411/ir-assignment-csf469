I\'m trying to setup AngularJS to communicate with a cross-origin resource where the asset host which delivers my template files is on a different domain and therefore the XHR request that angular performs must be cross-domain. I\'ve added the appropriate CORS header to my server for the HTTP request to make this work, but it doesn\'t seem to work. The problem is that when I inspect the HTTP requests in my browser (chrome) the request sent to the asset file is an OPTIONS request (it should be a GET request).I\'m not sure whether this is a bug in AngularJS or if I need to configure something. From what I understand the XHR wrapper can\'t make an OPTIONS HTTP request so it looks like the browser is trying to figure out if is "allowed" to download the asset first before it performs the GET request. If this is the case, then do I need to set the CORS header (Access-Control-Allow-Origin: http://asset.host...) with the asset host as well?OPTIONS request are by no means an AngularJS bug, this is how Cross-Origin Resource Sharing standard mandates browsers to behave. Please refer to this document: https://developer.mozilla.org/en-US/docs/HTTP_access_control, where in the "Overview" section it says:The Cross-Origin Resource Sharing standard works by adding new HTTP\n  headers that allow servers to describe the set of origins that are\n  permitted to read that information using a web browser. Additionally,\n  for HTTP request methods that can cause side-effects on user data (in\n  particular; for HTTP methods other than GET, or for POST usage with\n  certain MIME types). The specification mandates that browsers\n  "preflight" the request, soliciting supported methods from the server\n  with an HTTP OPTIONS request header, and then, upon "approval" from\n  the server, sending the actual request with the actual HTTP request\n  method.  Servers can also notify clients whether "credentials"\n  (including Cookies and HTTP Authentication data) should be sent with\n  requests.It is very hard to provide a generic solution that would work for all the WWW servers as setup will vary depending on the server itself and HTTP verbs that you intend to support. I would encourage you to get over this excellent article (http://www.html5rocks.com/en/tutorials/cors/) that has much more details on the exact headers that needs to be sent by a server.For Angular 1.2.0rc1+ you need to add a resourceUrlWhitelist.1.2: release version they added a escapeForRegexp function so you no longer have to escape the strings.  You can just add the url directly make sure to add ** for sub folders.  Here is a working jsbin for 1.2:\nhttp://jsbin.com/olavok/145/edit1.2.0rc: If you are still on a rc version, the Angular 1.2.0rc1 the solution looks like:Here is a jsbin example where it works for 1.2.0rc1:\nhttp://jsbin.com/olavok/144/editPre 1.2: For older versions (ref http://better-inter.net/enabling-cors-in-angular-js/) you need to add the following 2 lines to your config:Here is a jsbin example where it works for pre 1.2 versions:\nhttp://jsbin.com/olavok/11/editNOTE: Not sure it works with the latest version of Angular.ORIGINAL:It\'s also possible to override the OPTIONS request (was only tested in Chrome):Your service must answer an OPTIONS request with headers like these:Here is a good doc: http://www.html5rocks.com/en/tutorials/cors/#toc-adding-cors-support-to-the-serverThe same document says Unlike simple requests (discussed above), "preflighted" requests first send an HTTP OPTIONS request header to the resource on the other domain, in order to determine whether the actual request is safe to send.  Cross-site requests are preflighted like this since they may have implications to user data.  In particular, a request is preflighted if:It uses methods other than GET or POST.  Also, if POST is used to send request data with a Content-Type other than application/x-www-form-urlencoded, multipart/form-data, or text/plain, e.g. if the POST request sends an XML payload to the server using application/xml or text/xml, then the request is preflighted.It sets custom headers in the request (e.g. the request uses a header such as X-PINGOTHER)When the original request is Get with no custom headers, the browser should not make Options request which it does now. The problem is it generates a header X-Requested-With which forces the Options request. See https://github.com/angular/angular.js/pull/1454 on how to remove this headerThis fixed my problem:If you are using a nodeJS server, you can use this library, it worked fine for me https://github.com/expressjs/corsand after you can do an npm update.Here is the way I fixed this issue on ASP.NETFirst, you should add the nuget package Microsoft.AspNet.WebApi.Cors Then modify the file App_Start\\WebApiConfig.cs  Add this attribute on your controller classI was able to send json to the action by this wayReference :\nEnabling Cross-Origin Requests in ASP.NET Web API 2Somehow I fixed it by changing Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization"to Access-Control-Allow-Headers "Origin, Content-Type, Accept, Authorization"Perfectly described in pkozlowski\'s comment.\nI had working solution with AngularJS 1.2.6 and ASP.NET Web Api but when I had upgraded AngularJS to 1.3.3 then requests failed.Solution for Web Api server was to add handling of the OPTIONS requests at the beginning of configuration method (more info in this blog post):If you are using Jersey for REST API\'s you can do as below You don\'t have to change your webservices implementation.I will explain for Jersey 2.x 1) First add a ResponseFilter as shown below 2) then in the web.xml , in the jersey servlet declaration add the below I gave up trying to fix this issue.My IIS web.config had the relevant "Access-Control-Allow-Methods" in it, I experimented adding config settings to my Angular code, but after burning a few hours trying to get Chrome to call a cross-domain JSON web service, I gave up miserably.In the end, I added a dumb ASP.Net handler webpage, got that to call my JSON web service, and return the results.  It was up and running in 2 minutes.Here\'s the code I used:And in my Angular controller...I\'m sure there\'s a simpler/more generic way of doing this, but life\'s too short...  This worked for me, and I can get on with doing normal work now !!