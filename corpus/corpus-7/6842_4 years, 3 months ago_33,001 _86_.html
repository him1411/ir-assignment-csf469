I read everywhere that ternary operator is supposed to be faster than, or at least the same as, its equivalent if-else block.However, I did the following test and found out it\'s not the case:My computer took 85 ms to run the code above. But if I comment out the if-else chunk, and uncomment the ternary operator line, it will take about 157 ms.Why is this happening?To answer this question, we\'ll examine the assembly code produced by the X86 and X64 JITs for each of these cases.First: why is the X86 code so much slower than X64?This is due to the following characteristics of the code:Second: why is the ternary operator slower on both X86 and X64?This is due to a subtle difference in the order of operations impacting the JIT\'s optimizer. To JIT the ternary operator, rather than directly coding 2 and 3 in the add machine instructions themselves, the JIT creating an intermediate variable (in a register) to hold the result. This register is then sign-extended from 32-bits to 64-bits before adding it to value. Since all of this is performed in registers for X64, despite the significant increase in complexity for the ternary operator the net impact is somewhat minimized.The X86 JIT on the other hand is impacted to a greater extent because the addition of a new intermediate value in the inner loop causes it to "spill" another value, resulting in at least 2 additional memory accesses in the inner loop (see the accesses to [ebp-14h] in the X86 ternary code).EDIT: All change... see below.I can\'t reproduce your results on the x64 CLR, but I can on x86. On x64 I can see a small difference (less than 10%) between the conditional operator and the if/else, but it\'s much smaller than you\'re seeing.I\'ve made the following potential changes:Results with /platform:x64 (without the "ignore" lines):Results with /platform:x86 (without the "ignore" lines):My system details:So unlike before, I think you are seeing a real difference - and it\'s all to do with the x86 JIT. I wouldn\'t like to say exactly what is causing the difference - I may update the post later on with more details if I can bother to go into cordbg :)Interestingly, without sorting the array first, I end up with tests which take about 4.5x as long, at least on x64. My guess is that this is to do with branch prediction.Code:The difference really doesn\'t have much to do with if/else vs ternary.Looking at the jitted disassemblies (I won\'t repaste here, pls see @280Z28\'s answer), it turns out you\'re comparing apples and oranges.  In one case, you create two different += operations with constant values and which one you pick depends on a condition, and in the other case, you create a += where the value to add depends on a condition.If you want to truly compare if/else vs ternary, this would be a more fair comparison (now both will be equally "slow", or we could even say ternary is a bit faster):vs.Now the disassembly for the if/else becomes as shown below. Note that this is bit worse than the ternary case, since it quit using the registers for the loop variable(i) as well.Edit: Added an example which can be done with the if-else statement but not the conditional operator. Before the answer, please have a look of [Which is faster?] on Mr. Lippert\'s blog. And I think Mr. Ers\xc3\xb6nmez\'s answer is the most correct one here. I\'m trying to mention something we should keep in mind with a high-level programming language. First off, I\'ve never heard that the conditional operator is supposed to be faster or the equally performance with if-else statement in C\xe2\x99\xaf. The reason is simple that what if there\'s no operation with the if-else statement: The requirement of conditional operator is there must be a value with either side, and in C\xe2\x99\xaf it also requires that both side of : has the same type. This just makes it different from the if-else statement. Thus your question becomes a question asking how the instruction of the machine code is generated so that the difference of performance. With the conditional operator, semantically it is: Whatever the expression is evaluated, there\'s a value. But with if-else statement: If the expression is evaluated to true, do something; if not, do another thing. A value is not necessarily involved with if-else statement. Your assumption is only possible with optimization. Another example to demonstrate the difference between them would be like the following: the code above compiles, however, replace if-else statement with the conditional operator just won\'t compile: The conditional operator and the if-else statements are conceptual the same when you do the same thing, it possibly even faster with the conditional operator in C, since C is more closer to the assembly of the platform. For the original code you provided, the conditional operator is used in a foreach-loop, which would mess things up to see the difference between them. So I\'m proposing the following code: and the following are two version of the IL of optimized and not. Since they are long, I\'m using an image to show, the right hand side is the optimized one: (Click to see full-size image.)\n  In both version of code, the IL of the conditional operator looks shorter than the if-else statement, and there still is a doubt of the machine code finally generated. The following are the instructions of both method, and the former image is non-optimized, the latter is the optimized one: Non-optimized instructions: (Click to see full-size image.)\nOptimized instructions: (Click to see full-size image.)\nIn the latter, the yellow block is the code only executed if i<=0, and the blue block is when i>0. In either version of instructions, the if-else statement is shorter. Note that, for different instructions, the [CPI] is not necessarily the same. Logically, for the identical instruction, more instructions cost longer cycle. But if the instruction fetching time and pipe/cache were also take into account, then the real total time of execution is depend on the processor. The processor can also predict the branches. Modern processors have even more cores, things can be more complex with that. If you were an Intel processor user, you might want to have a look of [Intel\xc2\xae 64 and IA-32 Architectures Optimization Reference Manual]. I don\'t know if there was a hardware-implemented CLR, but if yes, you probably get faster with conditional operator because the IL is obviously lesser. Note: All the machine code are of x86. I did what Jon Skeet did and ran through 1 iteration and 1,000 iterations and got a different result from both OP and Jon.  In mine, the ternary is just slightly faster.  Below is the exact code:The output from my program:Elapsed time for If-Else: 00:00:00.0140543Elapsed time for Ternary: 00:00:00.0136723Elapsed time for If-Else: 00:00:14.0167870Elapsed time for Ternary: 00:00:13.9418520Another run in milliseconds:Elapsed time for If-Else: 20Elapsed time for Ternary: 19Elapsed time for If-Else: 13854Elapsed time for Ternary: 13610This is running in 64-bit XP, and I ran without debugging.Edit - Running in x86:There\'s a big difference using x86.  This was done without debugging on and on the same xp 64-bit machine as before, but built for x86 CPUs.  This looks more like OP\'s.Elapsed time for If-Else: 18Elapsed time for Ternary: 35Elapsed time for If-Else: 20512Elapsed time for Ternary: 32673The assembler code generated will tell the story:Generates:Whereas:Generates:So the ternary can be shorter and faster simply due to using fewer instructions and no jumps if you are looking for true/false. If you use values other than 1 and 0, you will get the same code as an if/else, for example:Generates:Which is the same as the if/else.Run without debugging ctrl+F5 it seems the debugger slows down both ifs and ternary significantly but it seems it slows down the ternary operator much more.When I run the following code here are my results. I think the small millisecond difference is caused by the compiler optimizing the max=max and removing it but is probably not making that optimization for the ternary operator. If someone could check the assembly and confirm this it would be awesome.CodeLooking at the IL generated, there are 16 less operations in that than in the if/else statement (copying and pasting @JonSkeet\'s code). However, that doesn\'t mean it should be a quicker process!To summarise the differences in IL, the if/else method translates to pretty much the same as the C# code reads (performing the addition within the branch) whereas the conditional code loads either 2 or 3 onto the stack (depending on the value) and then adds it to value outside of the conditional.The other difference is the branching instruction used. The if/else method uses a brtrue (branch if true) to jump over the first condition, and an unconditional branch to jump from the first out of the if statement. The conditional code uses a bgt (branch if greater than) instead of a brtrue, which could possibly be a slower comparison.Also (having just read about branch prediction) there may be a performance penalty for the branch being smaller. The conditional branch only has 1 instruction within the branch but the if/else has 7. This would also explain why there\'s a difference between using long and int, because changing to an int reduces the number of instructions in the if/else branches by 1 (making the read-ahead less)In the following code if/else seems to be roughly 1.4 times faster than the ternary operator. However, I found that introducing a temporary variable decreases the ternary operator\'s run time approximately 1.4 times:If/Else: 98 ms Ternary: 141 ms Ternary with temp var: 100 ms 