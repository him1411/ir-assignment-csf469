Let\'s say I want iterate on those and write something like processing #n of #m. Is there a way I can find out the value of m without iterating before my main iteration?I hope I made myself clear.IEnumerable doesn\'t support this. This is by design. IEnumerable uses lazy evaluation to get the elements you ask for just before you need them.If you want to know the number of items without iterating over them you can use ICollection<T>, it has a Count property.The System.Linq.Enumerable.Count extension method on IEnumerable<T> has the following implementation:So it tries to cast to ICollection<T>, which has a Count property, and uses that if possible. Otherwise it iterates.So your best bet is to use the Count() extension method on your IEnumerable<T> object, as you will get the best performance possible that way.Just adding extra some info:The Count() extension doesn\'t always iterate. Consider Linq to Sql, where the count goes to the database, but instead of bringing back all the rows, it issues the Sql Count() command and returns that result instead. Additionally, the compiler (or runtime) is smart enough that it will call the objects Count() method if it has one. So it\'s not as other responders say, being completely ignorant and always iterating in order to count elements.In many cases where the programmer is just checking if( enumerable.Count != 0 ) using the Any() extension method, as in if( enumerable.Any() )  is far more efficient with linq\'s lazy evaluation as it can short-circuit once it can determine there are any elements. It\'s also more readableIEnumerable cannot count without iterating.Under "normal" circumstances, it would be possible for classes implementing IEnumerable or IEnumerable<T>, such as List<T>, to implement the Count method by returning the List<T>.Count property.  However, the Count method is not actually a method defined on the IEnumerable<T> or IEnumerable interface.  (The only one that is, in fact, is GetEnumerator.)  And this means that a class-specific implementation cannot be provided for it.Rather, Count it is an extension method, defined on the static class Enumerable.  This means it can be called on any instance of an IEnumerable<T> derived class, regardless of that class\'s implementation.  But it also means it is implemented in a single place, external to any of those classes.  Which of course means that it must be implemented in a way that is completely independent of these class\' internals.  The only such way to do counting is via iteration.A friend of mine has a series of blog posts that provide an illustration for why you can\'t do this.  He creates function that return an IEnumerable where each iteration returns the next prime number, all the way to ulong.MaxValue, and the next item isn\'t calculated until you ask for it.  Quick, pop question: how many items are returned?Here are the posts, but they\'re kind of long:No, not in general. One point in using enumerables is that the actual set of objects in the enumeration is not known (in advance, or even at all).You can use System.Linq.You\'ll get the result \'2\'.Alternatively you can do the following:Going beyond your immediate question (which has been thoroughly answered in the negative), if you\'re looking to report progress whilst processing an enumerable, you might want to look at my blog post Reporting Progress During Linq Queries.It lets you do this:I used such way inside a method to check the passed in IEnumberable contentInside a method like this:Here is a great discussion about lazy evaluation and deferred execution.  Basically you have to materialize the list to get that value.Result of the IEnumerable.Count() function may be wrong. This is a very simple sample to test:Result must be (7,7,3,3) but actual result is (7,7,3,17)It depends on which version of .Net and implementation of your IEnumerable object.\nMicrosoft has fixed the IEnumerable.Count method to check for the implementation, and uses the ICollection.Count or ICollection< TSource >.Count, see details here https://connect.microsoft.com/VisualStudio/feedback/details/454130And below is the MSIL from Ildasm for System.Core, in which the System.Linq resides.You can\'t do it without an internal iteration at least. This will work.The only way to have a fast count is when the original collection has an indexer (like array). In order to create generic code with a minimum requirement you could use IEnumerable but if you need the count also then my prefered way is to use this interface:If your original collection does not have any indexer, your Count implementation could iterate over the collection, with the known hit in performance O(n).If you don\'t want to use something similar to IEnumAndCount, your best bet is to go with Linq.Count for reasons given by Daniel Earwicker near the top of this question.Good luck !No.Do you see that information available anywhere in the code you\'ve written?  You might argue that the compiler can "see" that there are only two, but that would mean that it would need to analyze every iterator method looking just for that specific pathological case.  And even if it did, how would you read it, given the limits of an IEnumerable?I would suggest calling ToList. Yes you are doing the enumeration early, but you still have access to your list of items.It may not yield the best performance, but you can use LINQ to count the elements in an IEnumerable:I use IEnum<string>.ToArray<string>().Length and it works fine.