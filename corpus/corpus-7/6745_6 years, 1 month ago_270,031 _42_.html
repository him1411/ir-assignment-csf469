Take this regular expression: /^[^abc]/. This will match any single character at the beginning of a string, except a, b, or c.If you add a * after it \xe2\x80\x93 /^[^abc]*/ \xe2\x80\x93 the regular expression will continue to add each subsequent character to the result, until it meets either an a, or b, or c.For example, with the source string "qwerty qwerty whatever abc hello", the expression will match up to "qwerty qwerty wh". But what if I wanted the matching string to be "qwerty qwerty whatever " ...In other words, how can I match everything up to (but not including) the exact sequence "abc"?You didn\'t  specify which flavor  of regex  you\'re using, but  this will\nwork in any of the most popular ones that can be considered "complete".The  .+?  part is  the  un-greedy  version of  .+  (one  or more  of\nanything). When we use .+, the engine will basically match everything.\nThen, if there is  something else in the regex it will  go back in steps\ntrying to  match the  following part. This  is the  greedy behavior,\nmeaning as much as possible to satisfy.When using  .+?, instead of  matching all at  once and going  back for\nother conditions (if any), the engine  will match the next characters by\nstep until the  subsequent part of the regex is  matched (again if any).\nThis  is  the un-greedy,  meaning  match  the fewest  possible  to\nsatisfy.Following  that   we  have   (?={contents}),  a   zero  width\nassertion,  a  look around.  This  grouped  construction matches  its\ncontents, but does not count  as characters matched (zero width). It\nonly returns if it is a match or not (assertion).Thus, in other terms the regex /.+?(?=abc)/ means:Match any  characters as  few  as possible  until a  "abc" is  found,\n  without counting the "abc".If you\'re looking to capture everything up to "abc":Explanation:( ) capture the expression inside the parentheses for access using $1, $2, etc.^ match start of line.* match anything, ? non-greedily (match the minimum number of characters required) - [1][1] The reason why this is needed is that otherwise, in the following string:by default, regexes are greedy, meaning it will match as much as possible. Therefore /^.*abc/ would match "whatever whatever something abc something ". Adding the non-greedy quantifier ? makes the regex only match "whatever whatever something ".As @Jared Ng and @Issun pointed out, the key to solve this kind of RegEx like "matching everything up to a certain word or substring" or "matching everything after a certain word or substring" is called "lookaround" zero-length assertions. Read more about them here.In your particular case, it can be solved by a positive look ahead. A picture is worth a thousand words. See the detail explanation in the screenshot.What you need is look around assertion like .+? (?=abc).See: Lookahead and Lookbehind Zero-Length AssertionsBe aware that [abc] isn\'t the same as abc. Inside brackets it\'s not a string - each character is just one of the possibilities. Outside the brackets it becomes the string.For regex in Java, and I believe also in most regex engines, if you want to include the last part this will work:For example, in this line:select all characters until "abc" and also include abcusing our regex, the result will be: I have this very nice senabcTest this out: https://regex101.com/r/mX51ru/1I believe you need subexpressions. If I remember right you can use  the normal () brackets for subexpressions.This part is From grep manual:Do something like ^[^(abc)] should do the trick.This will make sense about regex.("(.*?)")/gHere, we can get the exact word globally which is belonging inside the double quotes.\nFor Example,\nIf our search text is, This is the example for "double quoted" wordsthen we will get "double quoted" from that sentence.The $ marks the end of a string, so something like this should work: [[^abc]*]$ where you\'re looking for anything NOT ENDING in any iteration of abc, but it would have to be at the endAlso if you\'re using a scripting language with regex (like php or js), they have a search function that stops when it first encounters a pattern (and you can specify start from the left or start from the right, or with php, you can do an implode to mirror the string).try this Query : output :  