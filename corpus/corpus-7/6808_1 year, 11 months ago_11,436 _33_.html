I was reading Java\'s ArrayList source code and noticed some comparisons in if-statements.In Java 7, the method grow(int) usesIn Java 6, grow didn\'t exist. The method ensureCapacity(int) however usesWhat was the reason behind the change? Was it a performance issue or just a style? I could imagine that comparing against zero is faster, but performing a complete subtraction just to check whether it\'s negative seems a bit overkill to me. Also in terms of bytecode, this would involve two instructions (ISUB and IF_ICMPGE) instead of one (IFGE).a < b and a - b < 0 can mean two different things. Consider the following code:When run, this will only print a - b < 0. What happens is that a < b is clearly false, but a - b overflows and becomes -1, which is negative.Now, having said that, consider that the array has a length that is really close to Integer.MAX_VALUE. The code in ArrayList goes like this:oldCapacity is really close to Integer.MAX_VALUE so newCapacity (which is oldCapacity + 0.5 * oldCapacity) might overflow and become Integer.MIN_VALUE (i.e. negative). Then, subtracting minCapacity underflows back into a positive number.This check ensures that the if is not executed. If the code were written as if (newCapacity < minCapacity), it would be true in this case (since newCapacity is negative) so the newCapacity would be forced to minCapacity regardless of the oldCapacity.This overflow case is handled by the next if. When newCapacity has overflowed, this will be true: MAX_ARRAY_SIZE is defined as Integer.MAX_VALUE - 8 and Integer.MIN_VALUE - (Integer.MAX_VALUE - 8) > 0 is true. The newCapacity is therefore rightly handled: hugeCapacity method returns MAX_ARRAY_SIZE or Integer.MAX_VALUE.NB: this is what the // overflow-conscious code comment in this method is saying.I found this explanation:On Tue, Mar 9, 2010 at 03:02, Kevin L. Stern  wrote: I did a quick search and it appears that Java is indeed two\'s complement\n    based. Nonetheless, please allow me to point out that, in general, this\n    type of code worries me since I fully expect that at some point someone will\n    come along and do exactly what Dmytro suggested; that is, someone will\n    change:toand the entire ship will sink. I, personally, like to avoid obscurities\n    such as making integer overflow an essential basis for my algorithm unless\n    there is a good reason to do so. I would, in general, prefer to avoid\n    overflow altogether and to make the overflow scenario more explicit:It\'s a good point.In ArrayList we cannot do this (or at least not compatibly), because\n  ensureCapacity is a public API and effectively already accepts\n  negative numbers as requests for a positive capacity that cannot be\n  satisfied.The current API is used like this:If you want to avoid overflow, you would need to change to something\n  less natural likeAnyway, I\'m keeping the overflow-conscious code, but adding more\n  warning comments, and "out-lining" huge array creation so that\n  ArrayList\'s code now looks like:Webrev regenerated.MartinIn Java 6, if you use the API as:And newCount overflows (this becomes negative), if (minCapacity > oldCapacity) will return false and you may mistakenly assume that the ArrayList was increased by len.Looking at the code:If oldCapacity is quite large, this will overflow, and newCapacity will be a negative number. A comparison like newCapacity < oldCapacity will incorrectly evaluate true and the ArrayList will fail to grow.Instead, the code as written (newCapacity - minCapacity < 0 returns false) will allow the negative value of newCapacity to be further evaluated in the next line, resulting in recalculating newCapacity by invoking hugeCapacity (newCapacity = hugeCapacity(minCapacity);) to allow for the ArrayList to grow up to MAX_ARRAY_SIZE.This is what the // overflow-conscious code comment is trying to communicate, though rather obliquely.So, bottom line, the new comparison protects against allocating an ArrayList larger than the predefined MAX_ARRAY_SIZE while allowing it to grow right up to that limit if needed.The two forms behave exactly the same unless the expression a - b overflows, in which case they are opposite.  If a is a large negative, and b is a large positive, then (a < b) is clearly true, but a - b will overflow to become positive, so (a - b < 0) is false.If you\'re familiar with x86 assembly code, consider that (a < b) is implemented by a jge, which branches around the body of the if statement when SF = OF.  On the other hand, (a - b < 0) will act like a jns, which branches when SF = 0.  Hence, these behave differently precisely when OF = 1.