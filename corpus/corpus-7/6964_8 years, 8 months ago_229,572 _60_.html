If I have a Python script that requires at least a particular\nversion of Python, what is the correct way to fail gracefully\nwhen an earlier version of Python is used to launch the script?How do I get control early enough to issue an error message\nand exit?For example, I have a program that uses the ternery operator (new in 2.5) and "with" blocks\n(new in 2.6).  I wrote a simple little interpreter-version\nchecker routine which is the first thing the script would\ncall ... except it doesn\'t get that far. Instead, the\nscript fails during python compilation, before my routines\nare even called. Thus the user of the script sees some very\nobscure synax error tracebacks - which pretty much require\nan expert to deduce that it is simply the case of running\nthe wrong version of Python.I know how to check the version of Python. The issue is that some syntax is illegal in older versions of Python. Consider this program:When run under 2.4, I want this resultand not this result:(Channeling for a coworker.)You can test using eval:Also, with is available in Python 2.5, just add from __future__ import with_statement.EDIT: to get control early enough, you could split it into different .py files and check compatibility in the main file before importing (e.g. in __init__.py in a package):Have a wrapper around your program that does the following.You can also consider using sys.version(), if you plan to encounter people who are using pre-2.0 Python interpreters, but then you have some regular expressions to do.And there might be more elegant ways to do this.Try Should give you a string like "2.3.1". If this is not exactly waht you want there is a rich set of data available through the "platform" build-in. What you want should be in there somewhere. Probably the best way to do do this version comparison is to use the sys.hexversion. This is important because comparing version tuples will not give you the desired result in all python versions.Answer from Nykakin at AskUbuntu:You can also check Python version from code itself using platform module from standard library.There are two functions:Create a file for example: version.py)Easy method to check version:You can also use the eval method:Run the Python file in a command line:The output of Python with CGI via a WAMP Server on Windows 10:Although the question is:\nHow do I get control early enough to issue an error message and exit?The question that I answer is:\nHow do I get control early enough to issue an error message before starting the app?I can answer it a lot differently then the other posts.\nSeems answers so far are trying to solve your question from within Python.I say, do version checking before launching Python. I see your path is Linux or unix.\nHowever I can only offer you a Windows script. I image adapting it to linux scripting syntax wouldn\'t be too hard.Here is the DOS script with version 2.7:This does not run any part of your application and therefore will not raise a Python Exception. It does not create any temp file or add any OS environment variables. And it doesn\'t end your app to an exception due to different version syntax rules. That\'s three less possible security points of access.The "FOR /F" line is the key.\n    FOR /F "tokens=1,2" %%G IN (\'"python.exe -V 2>&1"\') DO ECHO %%H | find "2.7" > NulFor multiple python version check check out url:\nhttp://www.fpschultze.de/modules/smartfaq/faq.php?faqid=17And my hack version:[MS script; Python version check prelaunch of Python module]\nhttp://pastebin.com/aAuJ91FQSets became part of the core language in Python 2.4, in order to stay backwards compatible. I did this back then, which will work for you as well:As noted above, syntax errors occur at compile time, not at run time.  While Python is an "interpreted language", Python code is not actually directly interpreted; it\'s compiled to byte code, which is then interpreted.  There is a compile step that happens when a module is imported (if there is no already-compiled version available in the form of a .pyc or .pyd file) and that\'s when you\'re getting your error, not (quite exactly) when your code is running.  You can put off the compile step and make it happen at run time for a single line of code, if you want to, by using eval, as noted above, but I personally prefer to avoid doing that, because it causes Python to perform potentially unnecessary run-time compilation, for one thing, and for another, it creates what to me feels like code clutter.  (If you want, you can generate code that generates code that generates code - and have an absolutely fabulous time modifying and debugging that in 6 months from now.)  So what I would recommend instead is something more like this:.. which I would do even if I only had one function that used newer syntax and it was very short.  (In fact I would take every reasonable measure to minimize the number and size of such functions.  I might even write a function like ifTrueAElseB(cond, a, b) with that single line of syntax in it.)Another thing that might be worth pointing out (that I\'m a little amazed no one has pointed out yet) is that while earlier versions of Python did not support code like..it did support code likeThat was the old way of writing ternary expressions.  I don\'t have Python 3 installed yet, but as far as I know, that "old" way still works to this day, so you can decide for yourself whether or not it\'s worth it to conditionally use the new syntax, if you need to support the use of older versions of Python.Put the following at the very top of your file:Then continue on with the normal Python code:will be getting answer like this \'2.7.6 (default, Oct 26 2016, 20:30:19) \\n[GCC 4.8.4]\'here 2.7.6 is versionI think the best way is to test for functionality rather than versions. In some cases, this is trivial, not so in others.eg:As long as you\'re specific in enough in using the try/except blocks, you can cover most of your bases.I just found this question after a quick search whilst trying to solve the problem myself and I\'ve come up with a hybrid based on a few of the suggestions above.I like DevPlayer\'s idea of using a wrapper script, but the downside is that you end up maintaining multiple wrappers for different OSes, so I decided to write the wrapper in python, but use the same basic "grab the version by running the exe" logic and came up with this. I think it should work for 2.5 and onwards. I\'ve tested it on 2.66, 2.7.0 and 3.1.2 on Linux and 2.6.1 on OS X so far.Yes, I know the final decode/strip line is horrible, but I just wanted to quickly grab the version number. I\'m going to refine that.This works well enough for me for now, but if anyone can improve it (or tell me why it\'s a terrible idea) that\'d be cool too.How aboutHere\'s a quick and simple way to ensure that a python script will exit cleanly if you don\'t meet version requirements in order to run the scriptYou can also use this method to load cross-compatible libs for your script as well. Do one thing for one python version, another for a different one, etc. The limit is your imagination.The problem is quite simple. You checked if the version was less than 2.4, not less than or equal to. So if the Python version is 2.4, it\'s not less than 2.4.\nWhat you should have had was:, not