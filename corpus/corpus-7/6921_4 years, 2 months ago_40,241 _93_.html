Due to the enormous and ever repeating amount of "How do I sort my unique snowflake of an array?" questions, this is a reference collection of basic sorting methods in PHP. Please close any question which does not markedly differ as a duplicate of this one.How do I sort an array in PHP?\nHow do I sort a complex array in PHP?\nHow do I sort an array of objects in PHP?Basic one dimensional arrays; Incl. Multi dimensional arrays, incl. arrays of objects; Incl. Sorting one array based on anotherSorting with SPLStable sortFor the practical answer using PHP\'s existing functions see 1., for the academic in-detail answer on sorting algorithms (which PHP\'s functions implement and which you may need for really, really complex cases), see 2.Well most basic methods are already covered by deceze I would try to look at other types of sortOutput The SplMaxHeap class provides the main functionalities of a heap, keeping the maximum on the top.The SplMinHeap class provides the main functionalities of a heap, keeping the minimum on the top.From the Wikipedia article on Bubble Sort:Bubble sort, sometimes incorrectly referred to as sinking sort, is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm gets its name from the way smaller elements "bubble" to the top of the list. Because it only uses comparisons to operate on elements, it is a comparison sort. Although the algorithm is simple, most of the other sorting algorithms are more efficient for large lists.From the Wikipedia article on Selection sort:In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.From the Wikipedia article on Insertion sort:Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:From the Wikipedia article on Shellsort:Shellsort, also known as Shell sort or Shell\'s method, is an in-place comparison sort. It generalizes an exchanging sort, such as insertion or bubble sort, by starting the comparison and exchange of elements with elements that are far apart before finishing with neighboring elements. From the Wikipedia article on Comb sort:Comb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz Dobosiewicz in 1980. Later it was rediscovered by Stephen Lacey and Richard Box in 1991. Comb sort improves on bubble sort.From the Wikipedia article on Merge sort:In computer science, a merge sort (also commonly spelled mergesort) is an O(n log n) comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted outputFrom the Wikipedia article on Quicksort:Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare.From the Wikipedia article on Permutation sort:Permutation sort, which proceeds by generating the possible permutations of the input array/list until discovering the sorted one.From the Wikipedia article on Radix sort:In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. Applicable sort functions:The difference between those is merely whether key-value associations are kept (the "a" functions), whether it sorts low-to-high or reverse ("r"), whether it sorts values or keys ("k") and how it compares values ("nat" vs. normal). See http://php.net/manual/en/array.sorting.php for an overview and links to further details.If you want to sort $array by the key \'foo\' of each entry, you need a custom comparison function. The above sort and related functions work on simple values that they know how to compare and sort. PHP does not simply "know" what to do with a complex value like array(\'foo\' => \'bar\', \'baz\' => 42) though; so you need to tell it.To do that, you need to create a comparison function. That function takes two elements and must return 0 if these elements are considered equal, a value lower than 0 if the first value is lower and a value higher than 0 if the first value is higher. That\'s all that\'s needed:Often, you will want to use an anonymous function as the callback. If you want to use a method or static method, see the other ways of specifying a callback in PHP.You then use one of these functions:Again, they only differ in whether they keep key-value associations and sort by values or keys. Read their documentation for details.Example usage:usort will take two items from the array and call your cmp function with them. So cmp() will be called with $a as array(\'foo\' => \'bar\', \'baz\' => 42) and $b as another array(\'foo\' => ..., \'baz\' => ...). The function then returns to usort which of the values was larger or whether they were equal. usort repeats this process passing different values for $a and $b until the array is sorted. The cmp function will be called many times, at least as many times as there are values in $array, with different combinations of values for $a and $b every time.To get used to this idea, try this:All you did was define a custom way to compare two items, that\'s all you need. That works with all sorts of values.By the way, this works on any value, the values don\'t have to be complex arrays. If you have a custom comparison you want to do, you can do it on a simple array of numbers too.Note that the array sorts in place, you do not need to assign the return value to anything. $array = sort($array) will replace the array with true, not with a sorted array. Just sort($array); works.If you want to sort by the baz key, which is numeric, all you need to do is:Thanks to The PoWEr oF MATH this returns a value < 0, 0 or > 0 depending on whether $a is lower than, equal to or larger than $b.Note that this won\'t work well for float values, since they\'ll be reduced to an int and lose precision. Use explicit -1, 0 and 1 return values instead.If you have an array of objects, it works the same way:You can do anything you need inside a comparison function, including calling functions:A shortcut for the first string comparison version:strcmp does exactly what\'s expected of cmp here, it returns -1, 0 or 1.PHP 7 introduced the spaceship operator, which unifies and simplifies equal/smaller/larger than comparisons across types:If you want to sort primarily by foo, but if foo is equal for two elements sort by baz:For those familiar, this is equivalent to an SQL query with ORDER BY foo, baz.\nAlso see this very neat shorthand version and how to create such a comparison function dynamically for an arbitrary number of keys.If you want to sort elements into a "manual order" like "foo", "bar", "baz":For all the above, if you\'re using PHP 5.3 or higher (and you really should), use anonymous functions for shorter code and to avoid having another global function floating around:That\'s how simple sorting a complex multi-dimensional array can be. Again, just think in terms of teaching PHP how to tell which of two items is "greater"; let PHP do the actual sorting.Also for all of the above, to switch between ascending and descending order simply swap the $a and $b arguments around. E.g.:And then there\'s the peculiar array_multisort, which lets you sort one array based on another:The expected result here would be:Use array_multisort to get there:If you have more common cases, feel free to edit this answer.Let\'s say you have an array like this:And now you want to sort on the first letter only:The outcome is this:The sort wasn\'t stable!The keen observer may have noticed that the array sorting algorithm (QuickSort) didn\'t produce a stable outcome and that the original order between words of the same first letter wasn\'t preserved. This case is trivial and we should have compared the whole string, but let\'s assume your use-case is more complicated, such as two consecutive sorts on different fields that shouldn\'t cancel out each other\'s work.The Schwartzian transformThe Schwartzian transform, also referred to as the decorate-sort-undecorate idiom, effects a stable sort with an inherently unstable sorting algorithm.First, you decorate each array element with another array comprising a primary key (the value) and a secondary key (its index or position):This transforms the array into this:Now, we adjust the comparison step; we compare the first letter again, but if they\'re the same, the secondary key is used to retain the original ordering:Afterwards, we undecorate:The final result:What about reuse?You had to rewrite your comparison function to work with the transformed array elements; you may not want to edit your delicate comparison functions, so here\'s a wrapper for the comparison function:Let\'s write the sort step using this function:Voila! Your pristine comparison code is back.As of PHP 5.3 with closures it is also possible to use a closure to determine the order of your sort.For example assuming $array is an array of objects that contain a month property.In .NET, LINQ is frequently used for sorting, which provides a much nicer syntax over comparison functions, especially when objects need to be sorted by multiple fields. There\'re several ports of LINQ to PHP, including YaLinqo library*. With it, arrays can be sorted with a single line without writing complex comparison functions.Comparisons can be further customized by passing a callback as a second argument, for example:Here, \'$v->count\' is a shorthand for function ($v) { return $v->count; } (either can be used). These method chains return iterators, iterators can be transformed to arrays by adding ->toArray() in the end if needed.Internally, orderBy and related methods call appropriate array sorting functions (uasort, krsort, multisort, usort etc.).LINQ contains many more methods inspired by SQL: filtering, grouping, joining, aggregating etc. It\'s best suited for cases when complex transformations on arrays and objects need to be performed without relying on databases.* developed by me, see readme for more details and comparison with other LINQ portsIt is very convenient to sort arrays with sorted function from Nspl:Basic sortingSorting by function resultSorting multidimensional arraySorting array of objectsSorting with a comparison functionYou can see all these examples here.The simplest is to use usort function to sort array without any looping :\nBelow is an example :This will sort in desending order :This will sort in asending order :