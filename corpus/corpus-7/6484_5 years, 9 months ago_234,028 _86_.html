Let\'s say that I have an Javascript array looking as following:  What approach would be appropriate to chunk (split) the array into many smaller arrays with, lets say, 10 elements at its most?The array.slice method can extract a slice from the beginning, middle, or end of an array for whatever purposes you require, without changing the original array.Modified from an answer by dbaseman: https://stackoverflow.com/a/10456344/711085Demo:minor addendum:I should point out that the above is a not-that-elegant (in my mind) workaround to use Array.map. It basically does the following, where ~ is concatenation:It has the same asymptotic running time as the method below, but perhaps a worse constant factor due to building empty lists. One could rewrite this as follows (mostly the same as Blazemonger\'s method, which is why I did not originally submit this answer):More efficient method:My preferred way nowadays is the above, or one of the following:Demo:Or if you don\'t want an Array.range function, it\'s actually just a one-liner (excluding the fluff):orTry to avoid mucking with native prototypes, including Array.prototype, if you don\'t know who will be consuming your code (3rd parties, coworkers, yourself at a later date, etc.).There are ways to safely extend prototypes (but not in all browsers) and there are ways to safely consume objects created from extended prototypes, but a better rule of thumb is to follow the Principle of Least Surprise and avoid these practices altogether.If you have some time, watch Andrew Dupont\'s JSConf 2011 talk, "Everything is Permitted: Extending Built-ins", for a good discussion about this topic. But back to the question, while the solutions above will work, they are overly complex and requiring unnecessary computational overhead. Here is my solution:Old question: New answer! I actually was working with an answer from this question and had a friend improve on it! So here it is: I\'d prefer to use splice method:I tested the different answers into jsperf.com. The result is available there: http://jsperf.com/chunk-mtdsAnd the fastest functio (and that works from IE8) is this one:Here\'s a ES6 version using reduceAnd you\'re ready to chain it into further map/reduce transformations.\nYour input array is left intactNowadays you can use lodash\' chunk function to split the array into smaller arrays https://lodash.com/docs#chunk No need to fiddle with the loops anymore!Ok, let\'s start with a fairly tight one:Which is used like this:Then we have this tight reducer function:Which is used like this:Since a kitten dies when we bind this to a number, we can do manual currying like this instead:Which is used like this:Then the still pretty tight function which does it all in one go:If you use EcmaScript version >= 5.1, you can implement a functional version of chunk() using array.reduce() that has O(N) complexity:Explanation of each // nbr above:Currying based on chunkSize:You can add the chunk() function to the global Array object:One-liner in ECMA 6Created a npm package for this https://www.npmjs.com/package/array.chunkHere\'s my approach using Coffeescript list comprehension. A great article detailing comprehensions in Coffeescript can be found here.EDIT: @mblase75 added more concise code to the earlier answer while I was writing mine, so I recommend going with his solution.You could use code like this:Change the value of arraySize to change the maximum length of the smaller arrays.I changed BlazeMonger\'s slightly to use for a jQuery object..I created the following JSFiddle to demonstrate my approach to your question.First of all, I have two examples: an array with less than eight elements, another with an array with more than eight elements (comment whichever one you do not want to use).I then check for the size of the array, simple but essential to avoid extra computation. From here if the array meets the criteria (array size > delimiter) we move into the splitArray function.The splitArray function takes in the delimiter (meaning 8, since that is what you want to split by), and the array itself. Since we are re-using the array length a lot, I am caching it in a variable, as well as the first and last.first represents the position of the first element in an array. This array is an array made of 8 elements. So in order to determine the first element we use the modulus operator.myArrays is the array of arrays. In it we will store at each index, any sub array of size 8 or below. This is the key strategy in the algorithm below.index represents the index for the myArrays variable. Every time a sub array of 8 elements or less is to be stored, it needs to be stored in the corresponding index. So if we have 27 elements, that means 4 arrays. The first, second and third array will have 8 elements each. The last will have 3 elements only. So index will be 0, 1, 2, and 3 respectively.The tricky part is simply figuring out the math and optimizing it as best as possible. For example else if (delimiter - (i % delimiter) === 1) this is to find the last element that should go in the array, when an array will be full (example: contain 10 elements).This code works for every single scenario, you can even change the delimiter to match any array size you\'d like to get. Pretty sweet right :-)Any questions? Feel free to ask in the comments below.I just wrote this with the help of a groupBy function.ES6 Generator versionHere is neat & optimised implemention of chunk() function. Assuming default chunk size is 10.Well, a nice function for this would be:Usage would be:I commented it so you could understand what was going on. (The formatting is a bit off, I programmed this on mobile)You can use as follows:Result:Here\'s a solution using ImmutableJS, where items is an Immutable List and size is the required grouping size.Try using following snippet Here is a non-mutating solution using only recursion and slice().Then simply use it like splitToChunks([1, 2, 3, 4, 5], 3) to get [[1, 2, 3], [4, 5]].Here is a fiddle for you to try out: https://jsfiddle.net/6wtrbx6k/2/Her is a simple solution using @Blazemonger solutionThis got the pipline flowing for me, hope this helps someone else out there. :)Yet another solution XD, with pure js.And here is a more elegant solution, with a for with steps of the same size of the splitted groups:You may use a function for reusability... results for split in 3 are:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8 ] ]For split in 2 are:[ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 7, 8 ] ]It does not break the initial set of numbers.Here is the fiddle:Fiddle exampleHere\'s another solution with the reduce() method, though slightly different from other examples. Hopefully my explanation is a bit clearer as well.We call a reducer which, for each item in the array, gets the last item of the accumulator with pop(). Remember that this item is an array which groups up to chunkSize number of items (3 in this example).If, and only if, this group has the array length equal to chunksize we need to re-insert the group back into the accumulator and create a new group.We then push the current item into our group array (which may already contain 0, 1 or 2 items from the previous steps). With the current item inserted into the group, we need to re-insert the group back into the larger collection.The process will repeat until we\'ve iterated through all items in arr.Note that we have also provided the reducer with the starting value of an empty array inside an array with [[]].