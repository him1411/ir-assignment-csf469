In .NET, what is the difference between String.Empty and "", and are they interchangable, or is there some underlying reference or Localization issues around equality that String.Empty will ensure are not a problem?In .NET prior to version 2.0, "" creates an object while string.Empty creates no objectref, which makes string.Empty more efficient. In version 2.0 and later of .NET, all occurrences of "" refer to the same string literal, which means "" is equivalent to .Empty, but still not as fast as .Length == 0..Length == 0 is the fastest option, but .Empty makes for slightly cleaner code.See the .NET specification for more information.what is the difference between String.Empty and "", and are they\n  interchangablestring.Empty is a read-only field whereas "" is a compile time constant. Places where they behave differently are: Default Parameter value in C# 4.0 or higherCase expression in switch statementAttribute argumentsThe previous answers were correct for .NET 1.1 (look at the date of the post they linked: 2003).  As of .NET 2.0 and later, there is essentially no difference.  The JIT will end up referencing the same object on the heap anyhow.According to the C# specification, section 2.4.4.5:\nhttp://msdn.microsoft.com/en-us/library/aa691090(VS.71).aspxEach string literal does not necessarily result in a new string instance. When two or more string literals that are equivalent according to the string equality operator (Section 7.9.7) appear in the same assembly, these string literals refer to the same string instance.Someone even mentions this in the comments of Brad Abram\'s postIn summary, the practical result of "" vs. String.Empty is nil. The JIT will figure it out in the end. I have found, personally, that the JIT is way smarter than me and so I try not to get too clever with micro-compiler optimizations like that. The JIT will unfold for() loops, remove redundant code, inline methods, etc better and at more appropriate times than either I or the C# compiler could ever anticipate before hand.  Let the JIT do its job :)String.Empty is a readonly field while "" is a const. This means you can\'t use String.Empty in a switch statement because it is not a constant.Another difference is that String.Empty generates larger CIL code.  While the code for referencing "" and String.Empty is the same length, the compiler doesn\'t optimize string concatenation (see Eric Lippert\'s blog post) for String.Empty arguments.  The following equivalent functions generate this ILThe above answers are technically correct, but what you may really want to use, for best code readability and least chance of an exception is String.IsNullOrEmpty(s)String.Empty does not create an object whereas "" does. The difference, as pointed out here, is trivial, however.All instances of "" are the same, interned string literal (or they should be).  So you really won\'t be throwing a new object on the heap every time you use "" but just creating a reference to the same, interned object.  Having said that, I prefer string.Empty.  I think it makes code more readable. Use String.Empty rather than "". This is more for speed than memory usage but it is a useful tip. The\n  "" is a literal so will act as a literal: on the first use it is\n  created and for the following uses its reference is returned. Only one\n  instance of "" will be stored in memory no matter how many times we\n  use it! I don\'t see any memory penalties here. The problem is that\n  each time the "" is used, a comparing loop is executed to check if the\n  "" is already in the intern pool. On the other side, String.Empty\n  is a reference to a "" stored in the .NET Framework memory zone.\n  String.Empty is pointing to same memory address for VB.NET and C#\n  applications. So why search for a reference each time you need ""\n  when you have that reference in String.Empty?Reference: String.Empty vs ""It just doesn\'t matter!Some past discussion of this:http://www.codinghorror.com/blog/archives/000185.htmlhttp://blogs.msdn.com/brada/archive/2003/04/22/49997.aspxhttp://blogs.msdn.com/brada/archive/2003/04/27/50014.aspxI tend to use String.Empty rather than "" for one simple, yet not obvious reason:\n"\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf\xef\xbb\xbf" and "" are NOT the same, the first one actually has 16 zero width characters in it. Obviously no competent developer is going to put and zero width characters into their code, but if they do get in there, it can be a maintenance nightmare.Notes: I used U+FEFF in this example.Not sure if SO is going to eat those characters, but try it yourself with one of the many zero-width charactersI only came upon this thanks to https://codegolf.stackexchange.com/ldstr pushes a new object reference to a string literal stored in the metadata.ldsfld pushes the value of a static field onto the evaluation stackI tend to use String.Empty instead of "" because IMHO it\'s clearer and less VB-ish.Coming at this from an Entity Framework point of view: EF versions 6.1.3 appears to treat String.Empty and "" differently when validating. string.Empty is treated as a null value for validation purposes and will throw a validation error if it\'s used on a Required (attributed) field; where as "" will pass validation and not throw the error.This problem may be resolved in EF 7+. Reference:\n- https://github.com/aspnet/EntityFramework/issues/2610 ). Edit: [Required(AllowEmptyStrings = true)] will resolve this issue, allowing string.Empty to validate.Since String.Empty is not a compile-time constant you cannot use it as a default value in function definition.Everybody here gave some good theoretical clarification. I had a similar doubt. So I tried a basic coding on it. And I found a difference. Here\'s the difference.So it seems "Null" means absolutely void & "String.Empty" means It contains some kind of value, but it is empty.