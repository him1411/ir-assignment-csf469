By background, I mean none of the application\'s activities are currently visible to the user?There are few ways to detect whether your application is running in the background, but only one of them is completely reliable:The right solution (credits go to Dan, CommonsWare and NeTeInStEiN)\nTrack visibility of your application by yourself using Activity.onPause, Activity.onResume methods. Store "visibility" status in some other class. Good choices are your own implementation of the Application or a Service (there are also a few variations of this solution if you\'d like to check activity visibility from the service).\n \nExample\nImplement custom Application class (note the isActivityVisible() static method):Register your application class in AndroidManifest.xml:Add onPause and onResume to every Activity in the project (you may create a common ancestor for your Activities if you\'d like to, but if your activity is already extended from MapActivity/ListActivity etc. you still need to write the following by hand):  \nUpdate\nActivityLifecycleCallbacks were added in API level 14 (Android 4.0). You can use them to track whether an activity of your application is currently visible to the user. Check Cornstalks\' answer below for the details. The wrong one\nI used to suggest the following solution:You can detect currently foreground/background application with ActivityManager.getRunningAppProcesses() which returns a list of RunningAppProcessInfo records. To determine if your application is on the foreground check RunningAppProcessInfo.importance field for equality to RunningAppProcessInfo.IMPORTANCE_FOREGROUND while RunningAppProcessInfo.processName is equal to your application package name.  Also if you call ActivityManager.getRunningAppProcesses() from your application UI thread it will return importance IMPORTANCE_FOREGROUND for your task no matter whether it is actually in the foreground or not. Call it in the background thread (for example via AsyncTask) and it will return correct results.  While this solution may work (and it indeed works most of the time) I strongly recommend to refrain from using it. And here\'s why. As Dianne Hackborn wrote:These APIs are not there for applications to base their UI flow on, but to do things like show the user the running apps, or a task manager, or such.Yes there is a list kept in memory for these things.  However, it is off in another process, managed by threads running separately from yours, and not something you can count on (a) seeing in time to make the correct decision or (b) have a consistent picture by the time you return. Plus the decision about what the "next" activity to go to is always done at the point where the switch is to happen, and it is not until that exact point (where the activity state is briefly locked down to do the switch) that we actually know for sure what the next thing will be.And the implementation and global behavior here is not guaranteed to remain the same in the future.I wish I had read this before I posted an answer on the SO, but hopefully it\'s not too late to admit my error.Another wrong solution\nDroid-Fu library mentioned in one of the answers uses ActivityManager.getRunningTasks for its isApplicationBroughtToBackground method. See Dianne\'s comment above and don\'t use that method either.The key is using ActivityLifecycleCallbacks (note that this requires Android API level 14 (Android 4.0)). Just check if the number of stopped activities is equal to the number of started activities. If they\'re equal, your application is being backgrounded. If there are more started activities, your application is still visible. If there are more resumed than paused activities, your application is not only visible, but it\'s also in the foreground. There are 3 main states that your activity can be in, then: visible and in the foreground, visible but not in the foreground, and not visible and not in the foreground (i.e. in the background).The really nice thing about this method is that it doesn\'t have the asynchronous issues getRunningTasks() does, but you also don\'t have to modify every Activity in your application to set/unset something in onResumed()/onPaused(). It\'s just a few lines of code that\'s self contained, and it works throughout your whole application. Plus, there are no funky permissions required either.MyLifecycleHandler.java:MyApplication.java:@Mewzer has asked some good questions about this method that I\'d like to respond to in this answer for everyone:onStop() is not called in low memory situations; is that a problem here?No. The docs for onStop() say:Note that this method may never be called, in low memory situations where the system does not have enough memory to keep your activity\'s process running after its onPause() method is called.The key here is "keep your activity\'s process running..." If this low memory situation is ever reached, your process is actually killed (not just your activity). This means that this method of checking for backgrounded-ness is still valid because a) you can\'t check for backgrounding anyway if your process is killed, and b) if your process starts again (because a new activity is created), the member variables (whether static or not) for MyLifecycleHandler will be reset to 0.Does this work for configuration changes?By default, no. You have to explicitly set configChanges=orientation|screensize (| with anything else you want) in your manifest file and handle the configuration changes, or else your activity will be destroyed and recreated. If you do not set this, your activity\'s methods will be called in this order: onCreate -> onStart -> onResume -> (now rotate) -> onPause -> onStop -> onDestroy -> onCreate -> onStart -> onResume. As you can see, there is no overlap (normally, two activities overlap very briefly when switching between the two, which is how this backgrounding-detection method works). In order to get around this, you must set configChanges so that your activity is not destroyed. Fortunately, I\'ve had to set configChanges already in all of my projects because it was undesirable for my entire activity to get destroyed on screen rotate/resize, so I\'ve never found this to be problematic. (thanks to dpimka for refreshing my memory on this and correcting me!)One note:When I\'ve said "background" here in this answer, I\'ve meant "your app is no longer visible." Android activities can be visible yet not in the foreground (for example, if there\'s a transparent notification overlay). That\'s why I\'ve updated this answer to reflect that.It\'s important to know that Android has a weird limbo moment when switching activities where nothing is in the foreground. For this reason, if you check if your application is in the foreground when switching between activities (in the same app), you\'ll be told you\'re not in the foreground (even though your app is still the active app and is visible).You can check if your app is in the foreground in your Activity\'s onPause() method after super.onPause(). Just remember the weird limbo state I just talked about.You can check if your app is visible (i.e. if it\'s not in the background) in your Activity\'s onStop() method after super.onStop().Idolon\'s answer is error prone and much more complicated althought repeatead here check android application is in foreground or not? and here Determining the current foreground application from a background task or serviceThere is a much more simpler approach:On a BaseActivity that all Activities extend:Whenever you need to check if any of your application activities is in foreground just check isVisible();To understand this approach check this answer of side-by-side activity lifecycle: Activity side-by-side lifecycleI tried the recommended solution that uses Application.ActivityLifecycleCallbacks and many others, but they didn\'t work as expected. Thanks to Sarge, I came up with a pretty easy and straightforward solution that I am describing below. They key of the solution is the fact of understanding that if we have ActivityA and ActivityB, and we call ActivityB from ActivityA (and not call ActivityA.finish), then ActivityB\'s onStart() will be called before ActivityA onStop(). That\'s also the main difference between onStop() and onPause() that none did mention in the articles I read.So based on this Activity\'s Lifecycle behavior, you can simply count how many times did onStart() and onPause() got called in your program. Note that for each Activity of your program, you must override onStart() and onStop(), in order to increment/decrement the static variable used for counting. Below is the code implementing this logic. Note that I am using a class that extends Application, so dont forget to declare on Manifest.xml inside Application tag: android:name=".Utilities", although it can be implemented using a simple custom class too.Now on each Activity of our program, we should override onStart() and onStop() and increment/decrement as shown below:With this logic, there are 2 possible cases:Notice: stateCounter < 0 would mean that there are more stopped Activities rather than started, which is impossible. If you encounter this case, then it means that you are not increasing/decreasing the counter as you should.You are ready to go. You should want to check if your application is on background inside onStop().There is no way, short of you tracking it yourself, to determine if any of your activities are visible or not. Perhaps you should consider asking a new StackOverflow question, explaining what it is you are trying to achieve from a user experience, so we can perhaps give you alternative implementation ideas.You can use ComponentCallbacks2 to detect if the app is in background. BTW this callback is only available in API Level 14 (Ice Cream Sandwich) and above.You will get a call to the method:public abstract void onTrimMemory (int level)if the level is ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN then the app is in background.You can implement this interface to an activity, service, etc.Building on @Cornstalks answer to include a couple of useful features.Extra features:App.javaAppLifecycleHandler.javaSince Android API 16 there is a simple way to check if app is in foreground. It may not be foolproof, but no methods on Android are foolproof. This method is good enough to use when your service receives update from server and has to decide whether to show notification, or not (because if UI is foreground, user will notice the update without notification).To piggyback on what CommonsWare and Key have said, you could perhaps extend the Application class and have all of your activities call that on their onPause/onResume methods. This would allow you to know which Activity(ies) are visible, but this could probably be handled better.Can you elaborate on what you have in mind exactly? When you say running in the background do you mean simply having your application still in memory even though it is not currently on screen? Have you looked into using Services as a more persistent way to manage your app when it is not in focus?I did my own implementation of ActivityLifecycleCallbacks. I\'m using SherlockActivity, but for normal Activity class might work.First, I\'m creating an interface that have all methods for track the activities lifecycle:Second, I implemented this interface in my Application\'s class:Third, I\'m creating a class that extends from SherlockActivity: Fourth, all class that extend from SherlockActivity, I replaced for MySherlockActivity:Now, in the logcat you will see the logs programmed in the Interface implementation made in MyApplication.The best solution I have come up with uses timers.You have start a timer in onPause() and cancel the same timer in onResume(), there is 1 instance of the Timer (usually defined in the Application class). The timer itself is set to run a Runnable after 2 seconds (or whatever interval you think is appropriate), when the timer fires you set a flag marking the application as being in the background.In the onResume() method before you cancel the timer, you can query the background flag to perform any startup operations (e.g. start downloads or enable location services).This solution allows you to have several activities on the back stack, and doesn\'t require any permissions to implement.This solution works well if you use an event bus too, as your timer can simply fire an event and various parts of your app can respond accordingly.If you turn on developer settings "Don\'t keep actvities" - check only count of created activites is not enough. You must check also isSaveInstanceState. My custom method isApplicationRunning() check is android app is running:Here my work code:Another solution for this old post (for those that it might help) :See the comment in the onActivityDestroyed function.Works with SDK target version 14> :You should use a shared preference to store the property and act upon it using service binding from your activities. If you use binding only, (that is never use startService), then your service would run only when you bind to it, (bind onResume and unbind onPause) that would make it run on foreground only, and if you do want to work on background you can use the regular start stop service.I think this question should be more clear. When? Where? What is your specific situation you want to konw if your app is in background? I just introduce my solution in my way.\nI get this done by using the field "importance" of RunningAppProcessInfo class in every activity\'s onStop method in my app, which can be simply achieved by providing a BaseActivity for other activities to extend which implements the onStop method to check the value of "importance". Here is the code:Activity gets paused when a Dialog comes above it so all the recommended solutions are half-solutions. You need to create hooks for dialogs as well.I recommend reading through this page: http://developer.android.com/reference/android/app/Activity.htmlIn short, your activity is no longer visible after onStop() has been called.What about using getApplicationState().isInForeground() ?In my activities onResume and onPause I write an isVisible boolean to SharedPrefences. And read it elsewhere when needed via, Maybe not elegant, but it works for me...It might be too late to answer but if somebody comes visiting then here is the solution I suggest,\nThe reason(s) an app wants to know it\'s state of being in background or coming to foreground can be many, a few are,\n1. To show toasts and notifications when the user is in BG.\n2.To perform some tasks for the first time user comes from BG, like a poll, redraw etc.The solution by Idolon and others takes care of the first part, but does not for the second. If there are multiple activities in your app, and the user is switching between them, then by the time you are in second activity, the visible flag will be false. So it cannot be used deterministically.I did something what was suggested by CommonsWare, "If the Service determines that there are no activities visible, and it remains that way for some amount of time, stop the data transfer at the next logical stopping point." The line in bold is important and this can be used to achieve second item. So what I do is once I get the onActivityPaused() , don not change the visible to false directly, instead have a timer of 3 seconds (that is the max that the next activity should be launched), and if there is not onActivityResumed() call in the next 3 seconds, change visible to false. \nSimilarly in onActivityResumed() if there is a timer then I cancel it.\nTo sum up,the visible becomes isAppInBackground.Sorry cannot copy-paste the code...Another simple and accurate solution. Complete gist hereI would like to recommend you to use another way to do this.I guess you want to show start up screen while the program is starting, if it is already running in backend, don\'t show it.Your application can continuously write current time to a specific file.\nWhile your application is starting, check the last timestamp, if current_time-last_time>the time range your specified for writing the latest time, it means your application is stopped, either killed by system or user himself.