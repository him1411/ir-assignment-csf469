I want to understand the external linkage and internal linkage and their difference. I also want to know the meaning ofconst variables internally link by default unless otherwise declared as extern.When you write an implementation file (.cpp, .cxx, etc) your compiler generates a translation unit. This is the object file from your implementation file plus all the headers you #included in it. Internal linkage refers to everything only in scope of a translation unit.External linkage refers to things that exist beyond a particular translation unit. In other words, accessible through the whole program, which is the combination of all translation units (or object files).As dudewat said external linkage means the symbol (function or global variable) is accessible throughout your program and internal linkage means that it\'s only accessible in one translation unit. You can explicitly control the linkage of a symbol by using the extern and static keywords. If the linkage isn\'t specified then the default linkage is extern for non-const symbols and static (internal) for const symbols.Note that instead of using static for internal linkage it is better to use anonymous namespaces into which you can also put classes. The linkage for anonymous namespaces has changed between C++98 and C++11 but the main thing is that they are unreachable from other translation units.Consider following example:NB: The keyword static plays a double role. When used in the definitions of global variables, it specifies internal linkage. When used in the definitions of the local variables, it specifies that the lifetime of the variable is going to be the duration of the program instead of being the duration of the function.Hope that helps!Lets talk about different scope in \'C\'SCOPE: It is basically how long can I see something and how far.Local variable : Scope is only inside a function. It resides in the STACK area of RAM.\n                Which means that every time a function gets called all the variables\n                that are the part of that function, including function arguments are\n                freshly created and are destroyed once the control goes out of the\n                function. (Because the stack is flushed every time function returns)Static variable: Scope of this is for a file. It is accessible every where in the file\n                in which it is declared. It resides in the DATA segment of RAM. Since\n                this can only be accessed inside a file and hence INTERNAL linkage. Any\n                other files cannot see this variable. In fact STATIC keyword is the \n                only way in which we can introduce some level of data or function\n                hiding in \'C\'Global variable: Scope of this is for an entire application. It is accessible form every\n                where of the application. Global variables also resides in DATA segment\n                Since it can be accessed every where in the application and hence \n                EXTERNAL LinkageBy default all functions are global.  In case, if you need to \nhide some functions in a file from outside, you can prefix the static \nkeyword to the function. :-)Before talking about the question, it is better to know the term translation unit, program and some basic concepts of C++ (actually linkage is one of them in general) precisely. You will also have to know what is a scope.I will emphasize some key points, esp. those missing in previous answers.Linkage is a property of a name, which is introduced by a declaration. Different names can denote same entity (typically, an object or a function). So talking about linkage of an entity is usually nonsense, unless you are sure that the entity will only be referred by the unique name from some specific declarations (usually one declaration, though).Note an object is an entity, but a variable is not. While talking about the linkage of a variable, actually the name of the denoted entity (which is introduced by a specific declaration) is concerned. The linkage of the name is in one of the three: no linkage, internal linkage or external linkage.Different translation units can share the same declaration by header/source file (yes, it is the standard\'s wording) inclusion. So you may refer the same name in different translation units. If the name declared has external linkage, the identity of the entity referred by the name is also shared. If the name declared has internal linkage, the same name in different translation units denotes different entities, but you can refer the entity in different scopes of same translation unit. If the name has no linkage, you simply cannot refer the entity from other scope.(Oops... I found what I have typed was somewhat just repeating the standard wording ...)There are also some other confusing points which is not covered by the language specification.The linkage rule of namespace scope const variable is something special (and particularly different to the const object declared in file scope in C language which also has the concept of linkage of identifiers). Since ODR is enforced by C++, it is important to keep no more than one definition of the same variable or function occurred in the whole program except for inline functions. If there is no such special rule of const, a simplest declaration of const variable with initializers (e.g. = xxx) in a header or a source file (often a "header file") included by multiple translation units (or included by one translation unit more than once, though rarely) in a program will violate ODR, which makes to use const variable as replacement of some object-like macros impossible.I think Internal and External Linkage in C++ gives a clear and concise explanation:  A translation unit refers to an implementation (.c/.cpp) file and all\n  header (.h/.hpp) files it includes. If an object or function inside\n  such a translation unit has internal linkage, then that specific\n  symbol is only visible to the linker within that translation unit. If\n  an object or function has external linkage, the linker can also see it\n  when processing other translation units. The static keyword, when used\n  in the global namespace, forces a symbol to have internal linkage. The\n  extern keyword results in a symbol having external linkage.The compiler defaults the linkage of symbols such that:  Non-const global variables have external linkage by default\n  Const global variables have internal linkage by default\n  Functions have external linkage by default