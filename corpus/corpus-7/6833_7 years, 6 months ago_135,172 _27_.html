I\'m using Mercurial locally for a project (it\'s the only repo there\'s no pushing/pulling to/from anywhere else).To date it\'s got a linear history.  However, the current thing I\'m working on I\'ve now realized is a terrible approach and I want to go back to the version before I started it and implement it a different way.I\'m a bit confused with the branch / revert / update -C commands in Mercurial.  Basically I want to revert to version 38 (currently on 45) and have my next commits have 38 as a parent and carry on from there.  I don\'t care if revisions 39-45 are lost for ever or end up in a dead-end branch of their own.Which command / set of commands do I need?If later you commit, you will effectively create a new branch. Then you might continue working only on this branch or eventually merge the existing one into it.Here\'s the cheat sheet on the commands:hg update changes your working copy parent revision and also changes the file content to match this new parent revision. This means that new commits will carry on from the revision you update to.hg revert changes the file content only and leaves the working copy parent revision alone. You typically use hg revert when you decide that you don\'t want to keep the uncommited changes you\'ve made to a file in your working copy.hg branch starts a new named branch. Think of a named branch as a label you assign to the changesets. So if you do hg branch red, then the following changesets will be marked as belonging on the "red" branch. This can be a nice way to organize changesets, especially when different people work on different branches and you later want to see where a changeset originated from. But you don\'t want to use it in your situation.If you use hg update --rev 38, then changesets 39\xe2\x80\x9345 will be left as a dead end \xe2\x80\x94 a dangling head as we call it. You\'ll get a warning when you push since you will be creating "multiple heads" in the repository you push to. The warning is there since it\'s kind of impolite to leave such heads around since they suggest that someone needs to do a merge. But in your case you can just go ahead and hg push --force since you really do want to leave it hanging.If you have not yet pushed revision 39-45 somewhere else, then you can keep them private. It\'s very simple: with hg clone --rev 38 foo foo-38 you will get a new local clone that only contains up to revision 38. You can continue working in foo-38 and push the new (good) changesets you create. You\'ll still have the old (bad) revisions in your foo clone. (You are free to rename the clones however you want, e.g., foo to foo-bad and foo-38 to foo.)Finally, you can also use hg revert --all --rev 38 and then commit. This will create a revision 46 which looks identical to revision 38. You\'ll then continue working from revision 46. This wont create a fork in the history in the same explicit way as hg update did, but on the other hand you wont get complains about having multiple heads. I would use hg revert if I were collaborating with others who have already made their own work based on revision 45. Otherwise, hg update is more explicit.I just encountered a case of needing to revert just one file to previous revision, right after I had done commit and push. Shorthand syntax for specifying these revisions isn\'t covered by the other answers, so here\'s command to do thatThat -2 will revert to the version before last commit, using -1 would just revert current uncommitted changes.IMHO, hg strip -r 39 suits this case better.It requires the mq extension to be enabled and has the same limitations as the "cloning repo method" recommended by Martin Geisler:\nIf the changeset was somehow published, it will (probably) return to your repo at some point in time because you only changed your local repo.After using hg update -r REV it wasn\'t clear in the answer about how to commit that change so that you can then push.If you just try to commit after the update, Mercurial doesn\'t think there are any changes.I had to first make a change to any file (say in a README) so Mercurial recognized that I made a new change, then I could commit that.This then created two heads as mentioned.To get rid of the other head before pushing, I then followed the No-Op Merges step to remedy that situation.I was then able to push.The answers above were most useful and I learned a lot.  However, for my needs the succinct answer is:hg revert --all --rev ${1}hg commit -m "Restoring branch ${1} as default"where ${1} is the number of the revision or the name of the branch.  These two lines are actually part of a bash script, but they work fine on their own if you want to do it manually.This is useful if you need to add a hot fix to a release branch, but need to build from default (until we get our CI tools right and able to build from branches and later do away with release branches as well).