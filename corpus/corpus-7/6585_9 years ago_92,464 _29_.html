What are the biggest pros and cons of Apache Thrift vs Google\'s Protocol Buffers?They both offer many of the same features; however, there are some differences:Basically, they are fairly equivalent (with Protocol Buffers slightly more efficient from what I have read).Another important difference are the languages supported by default.Both could be extended to other platforms, but these are the languages bindings available out-of-the-box.RPC is another key difference. Thrift generates code to implement RPC clients and servers wheres Protocol Buffers seems mostly designed as a data-interchange format alone.For a closer look at the differences, check out the source code diffs at this open source project.As I\'ve said as "Thrift vs Protocol buffers" topic :Referring to Thrift vs Protobuf vs JSON comparison :Additionally, there are plenty of interesting additional tools available for those solutions, which might decide. Here are examples for Protobuf: Protobuf-wireshark , protobufeditor.I was able to get better performance with a text based protocol as compared to protobuff on python. However, no type checking or other fancy utf8 conversion, etc... which protobuff offers.So, if serialization/deserialization is all you need, then you can probably use something else.http://dhruvbird.blogspot.com/2010/05/protocol-buffers-vs-http.htmlProtocol Buffers seems to have a more compact representation, but that\'s only an impression I get from reading the Thrift whitepaper.  In their own words:We decided against some extreme storage optimizations (i.e. packing\n  small integers into ASCII or using a 7-bit continuation format)\n  for the sake of simplicity and clarity in the code. These alterations\n  can easily be made if and when we encounter a performance-critical\n  use case that demands them.Also, it may just be my impression, but Protocol Buffers seems to have some thicker abstractions around struct versioning.  Thrift does have some versioning support, but it takes a bit of effort to make it happen.One obvious thing not yet mentioned is that can be both a pro or con (and is same for both) is that they are binary protocols. This allows for more compact representation and possibly more performance (pros), but with reduced readability (or rather, debuggability), a con.Also, both have bit less tool support than standard formats like xml (and maybe even json).(EDIT) Here\'s an Interesting comparison that tackles both size & performance differences, and includes numbers for some other formats (xml, json) as well.And according to the wiki the Thrift runtime doesn\'t run on Windows.ProtocolBuffers is FASTER.\nThere is a nice benchmark here:\nhttp://code.google.com/p/thrift-protobuf-compare/wiki/BenchmarkingYou might also want to look into Avro, as Avro is even faster.\nMicrosoft has a package here:\nhttp://www.nuget.org/packages/Microsoft.Hadoop.AvroBy the way, the fastest I\'ve ever seen is Cap\'nProto;\nA C# implementation can be found at the Github-repository of Marc Gravell.I think most of these points have missed the basic fact that Thrift is an RPC framework, which happens to have the ability to serialize data using a variety of methods (binary, XML, etc).Protocol Buffers are designed purely for serialization, it\'s not a framework like Thrift. There are some excellent points here and I\'m going to add another one in case someones\' path crosses here.Thrift gives you an option to choose between thrift-binary and thrift-compact (de)serializer, thrift-binary will have an excellent performance but bigger packet size, while thrift-compact will give you good compression but needs more processing power. This is handy because you can always switch between these two modes as easily as changing a line of code (heck, even make it configurable). So if you are not sure how much your application should be optimized for packet size or in processing power, thrift can be an interesting choice.PS: See this excellent benchmark project by thekvs which compares many serializers including thrift-binary, thrift-compact, and protobuf: https://github.com/thekvs/cpp-serializersPS: There is another serializer named YAS which gives this option too but it is schema-less see the link above.