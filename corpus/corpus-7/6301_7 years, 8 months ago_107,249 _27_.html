Why is it not legal to have those two methods in the same class?I get the compilation error Method add(Set) has the same erasure add(Set) as another method in type Test.while I can work around it, I was wondering why javac doesn\'t like this.I can see that in many cases, the logic of those two methods would be very similar and could be replaced by a single method, but this is not always the case.This is extra annoying if you want to have two constructors that takes those arguments because then you can\'t just change the name of one of the constructors.This limitation is part of the language syntax, not the Java runtime itself. Essentially, this rule is intended to avoid conflicts in legacy code that still uses raw types.A compiler like javac will reject this type of overloading, but if you create a class through other means (writing your own compiler, or using a byte-code engineering library like ASM) with signatures that differ only by type parameters, the javac compiler will resolve calls to the correct method in your class.Here\'s an illustration of why this was not allowed, drawn from the JLS. Suppose, before generics were introduced to Java, I wrote some code like this:You extend my class, like this:After the introduction of generics, I decided to update my library.You aren\'t ready to make any updates, so you leave your Overrider class alone. In order to correctly override the toList() method, the language designers decided that a raw type was "override-equivalent" to any generified type. This means that although your method signature is no longer formally equal to my superclass\' signature, your method still overrides.Now, time passes and you decide you are ready to update your class. But you screw up a little, and instead of editing the existing, raw toList() method, you add a new method like this:Because of the override equivalence of raw types, both methods are in a valid form to override the toList(Collection<T>) method. But of course, the compiler needs to resolve a single method. To eliminate this ambiguity, classes are not allowed to have multiple methods that are override-equivalentâ€”that is, multiple methods with the same parameter types after erasure.The key is that this is a language rule designed to permit continued use of raw types, not a limitation arising from the erasure of type parameters. If you eliminate legacy code (for example, by using your own, not-strictly-Java language), this type of overload functions perfectly. Because method resolution occurs at compile-time, before erasure, type reification is not required to make this work.Java generics uses type erasure. The bit in the angle brackets (<Integer> and <String>) gets removed, so you\'d end up with two methods that have an identical signature (the add(Set) you see in the error). That\'s not allowed because the runtime wouldn\'t know which to use for each case.If Java ever gets reified generics, then you could do this, but that\'s probably unlikely now.This is because Java Generics are implemented with Type Erasure.Your methods would be translated, at compile time, to something like:Method resolution occurs at compile time and doesn\'t consider type parameters. (see erickson\'s answer)Both methods have the same signature without the type parameters, hence the error.The problem is that Set<Integer> and Set<String> are actually treated as a Set from the JVM. Selecting a type for the Set (String or Integer in your case) is only syntactic sugar used by the compiler. The JVM can\'t distinguish between Set<String> and Set<Integer>.It could be possible that the compiler translates Set(Integer) to Set(Object) in java byte code. If this is the case, Set(Integer) would be used only at compile phase for syntax checking.Define a single Method without type like void add(Set ii){}You can mention the type while calling the method based on your choice. It will work for any type of set.