When you create an instance of a class with the new operator, memory gets allocated on the heap. When you create an instance of a struct with the new operator where does the memory get allocated, on the heap or on the stack ?Okay, let\'s see if I can make this any clearer.Firstly, Ash is right: the question is not about where value type variables are allocated. That\'s a different question - and one to which the answer isn\'t just "on the stack". It\'s more complicated than that (and made even more complicated by C# 2). I have an article on the topic and will expand on it if requested, but let\'s deal with just the new operator.Secondly, all of this really depends on what level you\'re talking about. I\'m looking at what the compiler does with the source code, in terms of the IL it creates. It\'s more than possible that the JIT compiler will do clever things in terms of optimising away quite a lot of "logical" allocation.Thirdly, I\'m ignoring generics, mostly because I don\'t actually know the answer, and partly because it would complicate things too much.Finally, all of this is just with the current implementation. The C# spec doesn\'t specify much of this - it\'s effectively an implementation detail. There are those who believe that managed code developers really shouldn\'t care. I\'m not sure I\'d go that far, but it\'s worth imagining a world where in fact all local variables live on the heap - which would still conform with the spec.There are two different situations with the new operator on value types: you can either call a parameterless constructor (e.g. new Guid()) or a parameterful constructor (e.g. new Guid(someString)). These generate significantly different IL. To understand why, you need to compare the C# and CLI specs: according to C#, all value types have a parameterless constructor. According to the CLI spec, no value types have parameterless constructors. (Fetch the constructors of a value type with reflection some time - you won\'t find a parameterless one.)It makes sense for C# to treat the "initialize a value with zeroes" as a constructor, because it keeps the language consistent - you can think of new(...) as always calling a constructor. It makes sense for the CLI to think of it differently, as there\'s no real code to call - and certainly no type-specific code.It also makes a difference what you\'re going to do with the value after you\'ve initialized it. The IL used foris different to the IL used for:In addition, if the value is used as an intermediate value, e.g. an argument to a method call, things are slightly different again. To show all these differences, here\'s a short test program. It doesn\'t show the difference between static variables and instance variables: the IL would differ between stfld and stsfld, but that\'s all.Here\'s the IL for the class, excluding irrelevant bits (such as nops):As you can see, there are lots of different instructions used for calling the constructor:I hope this shows how complicated the topic is, while shining a bit of light on it at the same time. In some conceptual senses, every call to new allocates space on the stack - but as we\'ve seen, that isn\'t what really happens even at the IL level. I\'d like to highlight one particular case. Take this method:That "logically" has 4 stack allocations - one for the variable, and one for each of the three new calls - but in fact (for that specific code) the stack is only allocated once, and then the same storage location is reused.EDIT: Just to be clear, this is only true in some cases... in particular, the value of guid won\'t be visible if the Guid constructor throws an exception, which is why the C# compiler is able to reuse the same stack slot. See Eric Lippert\'s blog post on value type construction for more details and a case where it doesn\'t apply.I\'ve learned a lot in writing this answer - please ask for clarification if any of it is unclear!The memory containing a struct\'s fields can be allocated on either the stack or the heap depending on the circumstances. If the struct-type variable is a local variable or parameter that is not captured by some anonymous delegate or iterator class, then it will be allocated on the stack. If the variable is part of some class, then it will be allocated within the class on the heap.If the struct is allocated on the heap, then calling the new operator is not actually necessary to allocate the memory. The only purpose would be to set the field values according to whatever is in the constructor. If the constructor is not called, then all the fields will get their default values (0 or null).Similarly for structs allocated on the stack, except that C# requires all local variables to be set to some value before they are used, so you have to call either a custom constructor or the default constructor (a constructor that takes no parameters is always available for structs).To put it compactly, new is a misnomer for structs, calling new simply calls the constructor. The only storage location for the struct is the location it is defined.If it is a member variable it is stored directly in whatever it is defined in, if it is a local variable or parameter it is stored on the stack.Contrast this to classes, which have a reference wherever the struct would have been stored in its entirety, while the reference points somewhere on the heap. (Member within, local/parameter on stack)It may help to look a bit into C++, where there is not real distinction between class/struct. (There are similar names in the language, but they only refer to the default accessibility of things) When you call new you get a pointer to the heap location, while if you have a non-pointer reference it is stored directly on the stack or within the other object, ala structs in C#.As with all value types, structs always go where they were declared.See this question here for more details on when to use structs.\nAnd this question here for some more info on structs.Edit: I had mistankely answered that they ALWAYS go in the stack. This is incorrect.I\'m probably missing something here but why do we care about allocation?Value types are passed by value ;) and thus can\'t be mutated at a different scope than where they are defined. To be able to mutate the value you have to add the [ref] keyword.Reference types are passed by reference and can be mutated.There are of course immutable reference types strings being the most popular one.Array layout/initialization:\nValue types -> zero memory [name,zip][name,zip]\nReference types -> zero memory -> null [ref][ref]A class or struct declaration is like a blueprint that is used to create instances or objects at run time. If you define a class or struct called Person, Person is the name of the type. If you declare and initialize a variable p of type Person, p is said to be an object or instance of Person. Multiple instances of the same Person type can be created, and each instance can have different values in its properties and fields.A class is a reference type. When an object of the class is created, the variable to which the object is assigned holds only a reference to that memory. When the object reference is assigned to a new variable, the new variable refers to the original object. Changes made through one variable are reflected in the other variable because they both refer to the same data.A struct is a value type. When a struct is created, the variable to which the struct is assigned holds the struct\'s actual data. When the struct is assigned to a new variable, it is copied. The new variable and the original variable therefore contain two separate copies of the same data. Changes made to one copy do not affect the other copy.In general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created. Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created.for more...Pretty much the structs which are considered Value types, are allocated on stack, while objects get allocated on heap, while the object reference (pointer) gets allocated on the stack.Structs get allocated to the stack. Here is a helpful explanation:StructsAdditionally, classes when instantiated within .NET allocate memory on\n  the heap or .NET\'s reserved memory space. Whereas structs yield more\n  efficiency when instantiated due to allocation on the stack.\n  Furthermore, it should be noted that passing parameters within structs\n  are done so by value.