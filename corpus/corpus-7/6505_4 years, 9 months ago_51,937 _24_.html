I have the following code:Now, I\'ve added a comment on the line that ReSharper is suggesting a change. What does it mean, or why would it need to be changed? implicitly captured closure: end, start The warning tells you that the variables end and start stay alive as any of the lambdas inside this method stay alive.Take a look at the short exampleI get an "Implicitly captured closure: g" warning at the first lambda. It is telling me that g cannot be garbage collected as long as the first lambda is in use.The compiler generates a class for both lambda expressions and puts all variables in that class which are used in the lambda expressions.So in my example g and i are held in the same class for execution of my delegates. If g is a heavy object with a lot of resources left behind, the garbage collector couldn\'t reclaim it, because the reference in this class is still alive as long as any of the lambda expressions is in use. So this is a potential memory leak, and that is the reason for the R# warning.@splintor\nAs in C# the anonymous methods are always stored in one class per method there are two ways to avoid this:Use an instance method instead of an anonymous one.Split the creation of the lambda expressions into two methods.Agreed with Peter Mortensen. The C# compiler generates only one type that encapsulates all variables for all lambda expressions in a method.For example, given the source code:The compiler generates a type looks like :And the Capture method is compiled as:Though the second lambda does not use x, it cannot be garbage collected as x is compiled as a  property of the generated class used in the lambda.The warning is valid and displayed in methods that have more than one lambda, and they capture different values.When a method that contains lambdas is invoked, a compiler-generated object is instantiated with:As an example:Examine the generated code for this class (tidied up a little):Note the instance of LambdaHelper created stores both p1 and p2.Imagine that:In this situation, the reference to helper.Lambda1 also indirectly references the string in p2, and this means that the garbage collector will not be able to deallocate it. At worst it is a memory/resource leak. Alternatively it may keep object(s) alive longer than otherwise needed, which can have an impact on GC if they get promoted from gen0 to gen1.For Linq to Sql queries, you may get this warning. The lambda\'s scope may outlive the method due to the fact that the query is often actualized after the method is out of scope. Depending on your situation, you may want to actualize the results (i.e. via .ToList()) within the method to allow for GC on the method\'s instance vars captured in the L2S lambda.