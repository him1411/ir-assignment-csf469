I\'m trying to do something a bit elaborate, but something that should be possible. So here is a challenge for all you experts out there (this forum is a pack of a lot of you guys :) ).I\'m creating a Questionnaire "component", which I want to load on a NavigationContoller (my QuestionManagerViewController). The "component" is an "empty" UIViewController, which can load different views depending on the question that needs to be answered.The way I\'m doing it is:I override the initWithNib of my QuestionManagerViewController to look like this:When I run the code, I\'m getting this error:2009-05-14 15:05:37.152 iMobiDines[17148:20b] *** Terminating app due to uncaught exception \'NSInternalInconsistencyException\', reason: \'-[UIViewController _loadViewFromNibNamed:bundle:] loaded the "Question1View" nib but the view outlet was not set.\'I\'m sure there is a way to load the view using the nib file, without needing to create a viewController class.There is also an easier way to access the view instead of dealing with the nib as an array.1) Create a custom View subclass with any outlets that you want to have access to later. --MyView2) in the UIViewController that you want to load and handle the nib, create an IBOutlet  property that will hold the loaded nib\'s view, for instance in MyViewController (a UIViewController subclass)(dont forget to synthesize it and release it in your .m file)3) open your nib (we\'ll call it \'myViewNib.xib\') in IB, set you file\'s Owner to MyViewController4) now connect your file\'s Owner outlet myViewFromNib to the main view in the nib. 5) Now in MyViewController, write the following line:Now as soon as you do that, calling your property "self.myViewFromNib" will give you access to the view from your nib!Thank you all.\nI did find a way to do what I wanted.The DynamicViewController can run its logic to decide what view/xib to load. Once its made the decission, in the loadView method put something like this:That\'s it!The main bundle\'s loadNibNamed method will take care of initializing the view and creating the connections.Now the ViewController can display a view or another depending on the data in memory, and the "parent" screen doesn\'t need to bother with this logic.I\'m not sure what some of the answers are talking about, but I need to put this answer here for when I search in Google next time. Keywords: "How to load a UIView from a nib" or "How to load a UIView from an NSBundle."Here\'s the code almost 100% straight up from the Apress Beginning iPhone 3 book (page 247, "Using The New Table View Cell"):This supposes you have a UIView subclass called Blah, a nib called Blah which contains a UIView which has its class set to Blah.For all those that need to manage more than one instance of the custom view, that is an Outlet Collection, I merged and customized the @Gonso, @AVeryDev and @Olie answers in this way: Create a custom MyView : UIView and set it as "Custom Class" of the root UIView in the desired XIB;\nCreate all outlets you need in MyView (do it now because after point 3 the IB will propose you to connect outlets to the UIViewController and not to the custom view as we want);\nSet your UIViewController as "File\'s Owner" of the custom view XIB;\nIn the UIViewController add a new UIViews for each instance of MyView you want, and connect them to UIViewController creating an Outlet Collection: these views will act as "wrapper" views for the custom view instances;\nFinally, in the viewDidLoad of your UIViewController add the following lines:I would use UINib to instantiate a custom UIView to be reusedFiles needed in this case are MyCustomView.xib, MyCustomViewClass.h and MyCustomViewClass.m\nNote that [UINib instantiateWithOwner] returns an array, so you should use the element which reflects the UIView you want to re-use. In this case it\'s the first element.You should not be setting the class of your view controller to be a subclass of UIView in Interface Builder. That is most definitely at least part of your problem. Leave that as either UIViewController, some subclass of it, or some other custom class you have.As for loading only a view from a xib, I was under the assumption that you had to have some sort of view controller (even if it doesn\'t extend UIViewController, which may be too heavyweight for your needs) set as the File\'s Owner in Interface Builder if you want to use it to define your interface. I did a little research to confirm this as well. This is because otherwise there would be no way to access any of the interface elements in the UIView, nor would there be a way to have your own methods in code be triggered by events.If you use a UIViewController as your File\'s Owner for your views, you can just use initWithNibName:bundle: to load it and get the view controller object back. In IB, make sure you set the view outlet to the view with your interface in the xib. If you use some other type of object as your File\'s Owner, you\'ll need to use NSBundle\'s loadNibNamed:owner:options: method to load the nib, passing an instance of File\'s Owner to the method. All its properties will be set properly according to the outlets you define in IB.You can also use UIViewController\'s initWithNibName instead of loadNibNamed. It is simpler, I find. Now you just have to create MySubView.xib and MySubView.h/m. In MySubView.xib set the File\'s Owner class to UIViewController and view class to MySubView. You can position and size of the subview using the parent xib file. This is a great question (+1) and the answers were almost helpful ;)  Sorry guys, but I had a heck of a time slogging through this, though both Gonso & AVeryDev gave good hints.  Hopefully, this answer will help others.MyVC is the view controller holding all this stuff.MySubview is the view that we want to load from a xibIn  MyVC.h, haveIn MyVC.m, @synthesize mySubView; and don\'t forget to release it in dealloc.Back in MyVC.m, haveThe tricky bit for me was: the hints in the other answers loaded my view from the xib, but did NOT replace the view in MyVC (duh!) -- I had to swap that out on my own.Also, to get access to mySubview\'s methods, the view property in the .xib file must be set to MySubview.  Otherwise, it comes back as a plain-old UIView.If there\'s a way to load mySubview directly from its own xib, that\'d rock, but this got me where I needed to be.This is something that ought to be easier. I ended up extending UIViewController and adding a loadNib:inPlaceholder: selector. Now I can sayHere\'s the code for the category (it does the same rigamarole as described by Gonso):I too wanted to do something similar, this is what I found:\n(SDK 3.1.3)I have a view controller A (itself owned by a Nav controller) which loads VC B on a button press:In AViewController.mNow VC B has its interface from Bnib, but when a button is pressed, I want to go to an \'edit mode\' which has a separate UI from a different nib, but I don\'t want a new VC for the edit mode, I want the new nib to be associated with my existing B VC.So, in BViewController.m (in button press method)Then on another button press (to exit edit mode):and I\'m back to my original Bnib.This works fine, but note my EditMode.nib has only 1 top level obj in it, a UIView obj.\nIt doesn\'t matter whether the File\'s Owner in this nib is set as BViewController or the default NSObject, BUT make sure the View Outlet in the File\'s Owner is NOT set to anything.\nIf it is, then I get a exc_bad_access crash and xcode proceeds to load 6677 stack frames\nshowing an internal UIView method repeatedly called... so looks like an infinite loop.\n(The View Outlet IS set in my original Bnib however)Hope this helps.I made a category that I like:UIView+NibInitializer.hUIView+NibInitializer.mThen, call like this:Use a nib name if your nib is named something other than the name of your class.To override it in your subclasses for additional behavior, it could look like this:In swiftActually my resolution to this problem was, to load the view in a viewDidLoad in my CustonViewController where I wanted to use the view like that:Don\'t load the view in a loadView() method! The loadView method serves for loading the view for your custom ViewController.I found this blog posting by Aaron Hillegass (author, instructor, Cocoa ninja) to be very enlightening. Even if you don\'t adopt his modified approach to loading NIB files through a designated initializer you will probably at least get a better understanding of the process that\'s going on. I\'ve been using this method lately to great success!The previous answer does not take into account a change in the NIB (XIB) structure that occurred between 2.0 and 2.1 of the iPhone SDK.  User contents now start at index 0 instead of 1.You can use the 2.1 macro which is valid for all version 2.1 and above (that\'s two underscores before IPHONE:We use a technique similar to this for most of our applications.BarneyI had reason to do the same thing (programmatically loading a view from a XIB file), but I needed to do this entirely from the context of a subclass of a subclass of a UIView (i.e. without involving the view controller in any way). To do this I created this utility method:Then I call it from my subclass\' initWithFrame method like so:Posted for general interest; if anyone sees any problems without doing it this way, please let me know.For Swift user with designable option:Rember to set the File\xe2\x80\x99s Owner in the xib with our custom UIView subclass in Indetity Inspector panelIn the xib file now we can build our interface, make constraints, create outlets, actions etc.\nWe need to implement few methods to our custom class to open the xib once initializedclass XibbedView: UIView {}In our custom class we can also define some inspecatable properties to have full control over them from interface builder@IBDesignable\nclass MemeView: XibbedView {}Few examples: \n\nIf we need to add more information the view while is displayed inside a storyboard or another xib, to do that we can implement prepareForInterfaceBuilder(), this method will be executed only while opening the file in interface builder.\nIf you did everything I wrote but nothing is working, the is a way to debug a sigle view by adding breakpoints in its implementation.\n\nHere is the views hierarchy.\nHope this helps a full sample can be downloaded hereHere\'s a way to do it in Swift (currently writing Swift 2.0 in XCode 7 beta 5).From your UIView subclass that you set as "Custom Class" in the Interface Builder create a method like this (my subclass is called RecordingFooterView):Then you can just call it like this:let recordingFooterView = RecordingFooterView.loadFromNib()None of the answers explain how to create the stand alone XIB that is the root of this question.  There is no Xcode 4 option to "Create New XIB File".To do this This may seem simple but it can save you a few minutes poking around for it since the word "XIB" does not appear anywhere.@AVeryDev6) To attach the loaded view to your view controller\'s view:Presumably, it is necessary to remove it from the view to avoid memory leaks.To clarify: the view controller has several IBOutlets, some of which are connected to items in the original nib file (as usual), and some are connected to items in the loaded nib. Both nib\'s have the same owner class. The loaded view overlays the original one.Hint: set the opacity of the main view in the loaded nib to zero, then it won\'t obscure the items from the original nib.After spending many hours, I forged out following solution.\nFollow these steps to create custom UIView.1) Create class myCustomView inherited from UIView.\n 2) Create .xib with name myCustomView.\n 3) Change Class of UIView inside your .xib file, assign myCustomView Class there.\n 4) Create IBOutlets\n 5) Load .xib in myCustomView * customView.\nUse following sample code.  Note: For those who still face issue can comment, I will provide them link\n  of sample project with myCustomViewI have a convention of naming xibs with views in them the same as the view. Same as one would do for a view controller. Then, I don\'t have to write out class names in code. I load a UIView from a nib file with the same name. Example for a class called MyView.In your code, create a new MyView like this:MyView *myView = [MyView nib_viewFromNibWithOwner:owner];Here\'s the category for this:I\'d then wire up buttons with actions from the controller I am using, and set things on labels using the outlets in my custom view subclass.I ended up adding a category to UIView for this:explanation here: viewcontroller is less view loading in ios&mac