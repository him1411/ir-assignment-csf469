I have a map which either changes a value or sets it to nil. I then want to remove the nil entries from the list. The list doesn\'t need to be kept.This is what I currently have:I\'m aware I could just do a loop and conditionally collect in another array like this:But it doesn\'t seem that ruby-esque. Is there a nice way to run a function over a list removing/excluding the nils as you go?You could use compact:I\'d like to remind people that if you\'re getting an array containing nils as the output of a map block, and that block tries to conditionally return values, then you\'ve got code smell and need to rethink your logic. For instance, if you\'re doing something that does this:Then don\'t. Instead, prior to the map, reject the stuff you don\'t want or select what you do want:I consider using compact to clean up a mess as a last-ditch effort to get rid of things we didn\'t handle correctly, usually because we didn\'t know what was coming at us. We should always know what sort of data is being thrown around in our program; Unexpected/unknown data is bad. Anytime I see nils in an array I\'m working on, I dig into why they exist, and see if I can improve the code generating the array, rather than allow Ruby to waste time and memory generating nils then sifting through the array to remove them later. Try using #reduce or #inject!I agree with the accepted answer that we shouldn\'t map and compact, but not for the same reasons!I feel deep inside that map-then-compact is equivalent to select-then-map. Consider: a map is a one-to-one function. If you are mapping from some set of values, and you map, then you want one value in the output set for each value in the input set. If you are having to select before-hand, then you probably don\'t want a map on the set. If you are having to select afterwards (of compact) then you probably don\'t want a map on the set. In either case you are iterating twice over the entire set, when a reduce only needs to go once.Also, in English, you are trying to "reduce a set of integers into a set of even integers".In your example:it does not look like the values have changed other than being replaced with nil. If that is the case, then:will suffice.If you wanted a looser criterion for rejection, for example, to reject empty strings as well as nil, you could use:If you wanted to go further and reject zero values (or apply more complex logic to the process), you could pass a block to reject:@the Tin Man, nice - I din\'t know this method. Well, definitely compact is the best way, but still can be also done with simple substraction:each_with_object is probably the cleanest way to go here:In my opinion, each_with_object is better than inject/reduce in conditional cases because you don\'t have to worry about the return value of the block.One more way to accomplish it will be as shown below. Here, we use Enumerable#each_with_object to collect values, and make use of Object#tap to get rid of temporary variable that is otherwise needed for nil check on result of process_x method.Complete example for illustration:Alternate approach:By looking at the method you are calling process_x url, it is not clear what is the purpose of input x in that method.  If I assume that you are going to process the value of x by passing it some url and determine which of the xs really get processed into valid non-nil results - then, may be Enumerabble.group_by is a better option than Enumerable#map.