I understand the purpose of events, especially within the context of creating user interfaces. I think this is the prototype for creating an event:What do event handlers do, why are they needed, and how do I to create one?To understand event handlers, you need to understand delegates. In C#, you can think of a delegate as a pointer (or a reference) to a method. This is useful because the pointer can be passed around as a value.The central concept of a delegate is its signature, or shape. That is (1) the return type and (2) the input arguments. For example, if we create a delegate void MyDelegate(object sender, EventArgs e), it can only point to methods which return void, and take an object and EventArgs. Kind of like a square hole and a square peg. So we say these methods have the same signature, or shape, as the delegate.So knowing how to create a reference to a method, let\'s think about the purpose of events: we want to cause some code to be executed when something happens elsewhere in the system - or "handle the event". To do this, we create specific methods for the code we want to be executed. The glue between the event and the methods to be executed are the delegates. The event must internally store a "list" of pointers to the methods to call when the event is raised.* Of course, to be able to call a method, we need to know what arguments to pass to it! We use the delegate as the "contract" between the event and all the specific methods that will be called.So the default EventHandler (and many like it) represents a specific shape of method (again, void/object-EventArgs). When you declare an event, you are saying which shape of method (EventHandler) that event will invoke, by specifying a delegate:(*This is the key to events in .NET and peels away the "magic" - an event is really, under the covers, just a list of methods of the same "shape". The list is stored where the event lives. When the event is "raised", it\'s really just "go through this list of methods and call each one, using these values as the parameters". Assigning an event handler is just a prettier, easier way of adding your method to this list of methods to be called).C# knows two terms, delegate and event. Let\'s start with the first one.A delegate is a reference to a method. Just like you can create a reference to an instance:You can use a delegate to create an reference to a method:Now that you have this reference to a method, you can call the method via the reference:But why would you? You can also just call myFactory.GetInstance() directly. In this case you can. However, there are many cases to think about where you don\'t want the rest of the application to have knowledge of myFactory or to call myFactory.GetInstance() directly. An obvious one is if you want to be able to replace myFactory.GetInstance() into myOfflineFakeFactory.GetInstance() from one central place (aka factory method pattern).So, if you have a TheOtherClass class and it needs to use the myFactory.GetInstance(), this is how the code will look like without delegates (you\'ll need to let TheOtherClass know about the type of your myFactory):If you\'d use delegates, you don\'t have to expose the type of my factory:Thus, you can give a delegate to some other class to use, without exposing your type to them. The only thing you\'re exposing is the signature of your method (how many parameters you have and such). "Signature of my method", where did I hear that before? O yes, interfaces!!! interfaces describe the signature of a whole class. Think of delegates as describing the signature of only one method!Another large difference between an interface and a delegate, is that when you\'re writing your class, you don\'t have to say to C# "this method implements that type of delegate". With interfaces you do need to say "this class implements that type of an interface".Further, a delegate reference can (with some restrictions, see below) reference multiple methods (called MulticastDelegate). This means that when you call the delegate, multiple explicitly-attached methods will be executed. An object reference can always only reference to one object. The restrictions for a MulticastDelegate are that the (method/delegate) signature should not have any return value (void) and the keywords out and ref are not used in the signature. Obviously, you can\'t call two methods that return a number, and expect them to return the same number. Once the signature complies, the delegate is automatically a MulticastDelegate.Events are just properties (like the get;set; properties to instance fields) which expose subscription to the delegate from other objects. These properties, however don\'t support get;set;. Instead they support add;remove;So you can have:So, now we know that a delegate is a reference to a method and that we can have an event to let the world know that they can give us their methods to be referenced from our delegate, and we are a UI button, then: we can ask anyone who is interested in whether I was clicked, to register their method with us (via the event we exposed). We can use all those methods that were given to us, and reference them by our delegate. And then, we\'ll wait and wait.... until a user comes and clicks on that button, then we\'ll have enough reason to invoke the delegate. And because the delegate references all those methods given to us, all those methods will be invoked. We don\'t know what those methods do, nor we know which class implements those method. All we do care about is that someone was interested in us being clicked, and gave us a reference to a method that complied with our desired signature.Languages like Java don\'t have delegates. They use interfaces instead. The way they do that is to ask anyone who is interested in \'us being clicked\', to implement a certain interface (with a certain method we can call), then give us the whole instance that implements the interface. We can that keep a list of all objects implementing this interface, and can call their \'certain method we can call\' whenever we get clicked.Here is a code example which may help:That is actually the declaration for an event handler - a method that will get called when an event is fired. To create an event, you\'d write something like this:And then you can subscribe to the event like this:With OnMyEvent() defined like this:Whenever Foo fires off MyEvent, then your OnMyEvent handler will be called.You don\'t always have to use an instance of EventArgs as the second parameter. If you want to include additional information, you can use a class derived from EventArgs (EventArgs is the base by convention). For example, if you look at some of the events defined on Control in WinForms, or FrameworkElement in WPF, you can see examples of events that pass additional information to the event handlers.Just to add to the existing great answers here - building on the code in the accepted one, which uses a delegate void MyEventHandler(string foo)...Because the compiler knows the delegate type of the SomethingHappened event, this:Is totally equivalent to:And handlers can also be unregistered with -= like this:For completeness\' sake, raising the event can be done like this, only in the class that owns the event:The thread-local copy of the handler is needed to make sure the invocation is thread-safe - otherwise a thread could go and unregister the last handler for the event immediately after we checked if it was null, and we would have a "fun" NullReferenceException there.C# 6 introduced a nice short hand for this pattern. It uses the null propagation operator. My understanding of the events is;Delegate: A variable to hold reference to method / methods to be executed. This makes it possible to pass around methods like a variable.Steps for creating and calling the event:The event is an instance of a delegateSince an event is an instance of a delegate, then we have to first define the delegate.Assign the method / methods to be executed when the event is fired (Calling the delegate)Fire the event (Call the delegate)Example:publisher: where the events happen. Publisher should specify which delegate the class is using and generate necessary arguments, pass those arguments and itself to the delegate.subscriber: where the response happen. Subscriber should specify methods to respond to events. These methods should take the same type of arguments as the delegate. Subscriber then add this method to publisher\'s delegate.Therefore, when the event happen in publisher, delegate will receive some event arguments (data, etc), but publisher has no idea what will happen with all these data. Subscribers can create methods in their own class to respond to events in publisher\'s class, so that subscribers can respond to publisher\'s events.I agree with KE50 except that I view the \'event\' keyword as an alias for \'ActionCollection\' since the event holds a collection of actions to be performed (ie. the delegate).