I would like to create some helpers (functions) to avoid repeating code between some views, in L5 style:view.blade.phpThey are basically text formatting functions. Where and how can I put a file with these functions?Create a helpers.php file in your app folder and load it up with composer:After adding that to your composer.json file, run the following command:my initial thought was the composer autoload as well, but it didn\'t feel very Laravel 5ish to me. L5 makes heavy use of Service Providers, they are what bootstraps your application.To start off I created a folder in my app directory called Helpers. Then within the Helpers folder I added files for functions I wanted to add. Having a folder with multiple files allows us to avoid one big file that gets too long and unmanageable.Next I created a HelperServiceProvider.php by running the artisan command:Within the register method I added this snippetlastly register the service provider in your config/app.php in the providers arraynow any file in your Helpers directory is loaded, and ready for use.UPDATE 2016-02-22There are a lot of good options here, but if my answer works for you, I went ahead and made a package for including helpers this way. You can either use the package for inspiration or feel free to download it with Composer as well. It has some built in helpers that I use often (but which are all inactive by default) and allows you to make your own custom helpers with a simple Artisan generator. It also addresses the suggestion one responder had of using a mapper and allows you to explicitly define the custom helpers to load, or by default, automatically load all PHP files in your helper directory. Feedback and PRs are much appreciated!Github: browner12/helpersThis answer is applicable to general custom classes within Laravel. For a more Blade-specific answer, see Custom Blade Directives in Laravel 5.Step 1: Create your Helpers (or other custom class) file and give it a matching namespace.  Write your class and method:Step 2: Create an alias:Step 3: Use it in your Blade template:Extra Credit: Use this class anywhere in your Laravel app:Source: http://www.php-fig.org/psr/psr-4/Why it works: https://github.com/laravel/framework/blob/master/src/Illuminate/Support/ClassLoader.phpWhere autoloading originates from:\nhttp://php.net/manual/en/language.oop5.autoload.phpThis is what is suggested by JeffreyWay in this Laracasts Discussion.Having sifted through a variety of answers on SO and Google, I still couldn\'t find an optimal approach. Most answers suggest we leave the application and rely on 3rd party tool Composer to do the job, but I\'m not convinced coupling to a tool just to include a file is wise.Andrew Brown\'s answer came the closest to how I think it should be approached, but (at least in 5.1), the service provider step is unnecessary. Heisian\'s answer highlights the use of PSR-4 which brings us one step closer. Here\'s my final implementation for helpers in views:First, create a helper file anywhere in your apps directory, with a namespace:  Next, alias your class in config\\app.php, in the aliases array:And that should be all you need to do. PSR-4 and the alias should expose the helper to your views, so in your view, if you type:It should output:Yes, there is another way to do this!Step 1: Register a custom Blade directive:Step 2: Use your custom Blade directive:Outputs:THIS IS MY CUSTOM BLADE DIRECTIVE!!\n\nCustom LinkSource: https://laravel.com/docs/5.1/blade#extending-bladeAdditional Reading: https://mattstauffer.co/blog/custom-conditionals-with-laravels-blade-directivesIf you want to learn how to best make custom classes that you can use anywhere, see Custom Classes in Laravel 5, the Easy WayThis is my HelpersProvider.php file:You should create a folder called Helpers under the app folder, then create file called whatever.php inside and add the string whatever inside the $helpers array.Done!For Custom Helper Libraries in my Laravel project, I have created a folder with name Libraries in my Laravel/App Directory and within Libraries directory, I have created various files for different helper libraries.After creating my helper files I simply include all those files in my composer.json file like thisand execute Since OP asked for best practices, I think we\'re still missing some good advices here.A single helpers.php file is far from a good practice. Firstly because you mix a lot of different kind of functions, so you\'re against the good coding principles. Moreover, this could hurt not only the code documentation but also the code metrics like Cyclomatic Complexity, Maintainability Index and Halstead Volume. The more functions you have the more it gets worse.Code documentation would be Ok using tools like phpDocumentor, but using Sami it won\'t render procedural files. Laravel API documentation is such a case - there\'s no helper functions documentation: https://laravel.com/api/5.4Code metrics can be analyzed with tools like PhpMetrics. Using PhpMetrics version 1.x to analyze Laravel 5.4 framework code will give you very bad CC/MI/HV metrics for both src/Illuminate/Foundation/helpers.php and src/Illuminate/Support/helpers.php files.Multiple contextual helper files (eg. string_helpers.php, array_helpers.php, etc.) would certainly improve those bad metrics resulting in an easier code to mantain. Depending on the code documentation generator used this would be good enough.It can be further improved by using helper classes with static methods so they can be contextualized using namespaces. Just like how Laravel already does with Illuminate\\Support\\Str and Illuminate\\Support\\Arr classes. This improves both code metrics/organization and documentation. Class aliases could be used to make them easier to use.Structuring with classes makes the code organization and documentation better but on the other hand we end up loosing those great short and easy to remember global functions. We can further improve that approach by creating function aliases to those static classes methods. This can be done either manually or dynamically.Laravel internally use the first approach by declaring functions in the procedural helper files that maps to the static classes methods. This might be not the ideal thing as you need to redeclare all the stuff (docblocks/arguments).\nI personally use a dynamic approach with a HelperServiceProvider class that create those functions in the execution time:One can say this is over engineering but I don\'t think so. It works pretty well and contrary to what might be expected it does not cost relevant execution time at least when using PHP 7.x.Here\'s a bash shell script I created to make Laravel 5 facades very quickly.Run this in your Laravel 5 installation directory.Example:If you run that example, it will create the directories Facades and Providers under \'your_laravel_installation_dir/app/MyApp\'.After it is done, it will display a message similar to the following:So update the Providers and Alias list in \'config/app.php\'Run composer -o dumpautoloadThe "./app/MyApp/Facades/Helper.php" will originally look like this:Now just add your methods in "./app/MyApp/Facades/Helper.php".Here is what "./app/MyApp/Facades/Helper.php" looks like after I added a Helper function.This function expects a pattern and can accept an optional second boolean argument.If the current URL matches the pattern passed to it, it will output \'active\' (or \'class="active"\' if you add \'true\' as a second argument to the function call).I use it to highlight the menu that is active.Another Way that I used was:\n1) created a file in app\\FolderName\\fileName.php and had this code inside it i.e2) After that in our blade that\'s it. and it worksBest Practice to write custom helpers is 1) Inside the app directory of the project root, create a folder named Helpers (Just to separate and structure the code).2) Inside the folder write psr-4 files or normal php filesIf the PHP files are in the format of psr-4 then it will be auto loaded, else add the following line in the composer.json which is inside the project root directoryInside the autoload key, create a new key named files to load files at the time of auto load,inside the files object add the path starting from app directory., here is an example.PS : try running composer dump-autoload if the file dosen\'t loaded.in dir bootstrap\\autoload.phpadd this fileIn laravel 5.3 and above, the laravel team moved all procedural files (routes.php) out of the app/ directory, and the entire app/ folder is psr-4 autoloaded. The accepted answer will work in this case but it doesn\'t feel right to me. So what I did was I created a helpers/ directory at the root of my project and put the helper files inside of that, and in my composer.json file I did this:This way my app/ directory is still a psr-4 autoloaded one, and the helpers are a little better organized. Hope this helps someone.There are some great answers here but i think this is the simplest.\nIn Laravel 5.4 (and prob earlier versions too) you can create a class somewhere convenient for you, eg App/Libraries/Helper.phpThen you can simply call it in your Blade template like this:If you don\'t want to use @inject then just make the \'uppercasePara\' function as static and embed the call in your Blade template like this:No need for aliases. Laravel resolves the concrete class automatically.