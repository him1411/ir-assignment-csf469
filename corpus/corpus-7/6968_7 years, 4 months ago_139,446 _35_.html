This question already has an answer here:How do you name different classes / interfaces you create?\nSometimes I don\'t have implementation information to add to the implementation name - like interface FileHandler and class SqlFileHandler.When this happens I usually name the interface in the "normal" name, like Truck and name the actual class TruckClass. How do you name interfaces and classes in this regard?Name your Interface what it is. Truck. Not ITruck because it isn\'t an ITruck it is a Truck. An Interface in Java is a Type. Then you have DumpTruck, TransferTruck, WreckerTruck, CementTruck, etc that implement Truck. When you are using the Interface in place of a sub-class you just cast it to Truck. As in List<Truck>. Putting I in front is just crappy hungarian style notation tautology that adds nothing but more stuff to type to your code.  All modern Java IDE\'s mark Interfaces and Implementations and what not without this silly notation. Don\'t call it TruckClass that is tautology just as bad as the IInterface tautology.  If it is an implementation it is a class. The only real exception to this rule, and there are always exceptions, is AbstractTruck. Since only the sub-classes will ever see this and you should never cast to an Abstract class it does add some information that the class is abstract and to how it should be used. You could still come up with a better name than AbstractTruck and use BaseTruck instead. But since Abstract classes should never be part of any public facing interface it is an acceptable exception to the rule. Making the constructors protected goes a long way to crossing this divide.And the Impl suffix is just more noise as well. More tautology. Anything that isn\'t an interface is an implementation, even abstract classes which are partial implementations. Are you going to put that silly Impl suffix on every name of every Class?  The Interface is a contract on what the public methods and properties have to support, it is also Type information as well. Everything that implements Truck is a Type of Truck.  Look to the Java standard library itself. Do you see IList, ArrayListImpl, LinkedListImpl? No, you see List and ArrayList, and LinkedList. Here is a nice article about this exact question. Any of these silly prefix/suffix naming conventions all violate the DRY principle as well.Also, if you find yourself adding DTO, JDO, BEAN or other silly repetitive suffixes to objects then they probably belong in a package instead of all those suffixes. Properly packaged namespaces are self documenting and reduce all the useless redundant information in these really poorly conceived proprietary naming schemes that most places don\'t even internally adhere to in a consistent manner. If all you can come up with to make your Class name unique is suffixing it with Impl, then you need to rethink having an Interface at all. So when you have a situation where you have an Interface and a single Implementation that is not uniquely specialized from the Interface you probably don\'t need the Interface.I\'ve seen answers here that suggest that if you only have one implementation then you don\'t need an interface.  This flies in the face of the Depencency Injection/Inversion of Control principle (don\'t call us, we\'ll call you!).  So yes, there are situations in which you wish to simplify your code and make it easily testable by relying on injected interface implementations (which may also be proxied - your code doesn\'t know!).  Even if you only have two implementations - one a Mock for testing, and one that gets injected into the actual production code - this doesn\'t make having an interface superfluous.  A well documented interface establishes a contract, which can also be maintained by a strict mock implementation for testing.  in fact, you can establish tests that have mocks implement the most strict interface contract (throwing exceptions for arguments that shouldn\'t be null, etc) and catch errors in testing, using a more efficient implementation in production code (not checking arguments that should not be null for being null since the mock threw exceptions in your tests and you know that the arguments aren\'t null due to fixing the code after these tests, for example).Dependency Injection/IOC can be hard to grasp for a newcomer, but once you understand its potential you\'ll want to use it all over the place and you\'ll find yourself making interfaces all the time - even if there will only be one (actual production) implementation.For this one implementation (you can infer, and you\'d be correct, that I believe the mocks for testing should be called Mock(InterfaceName)), I prefer the name Default(InterfaceName).  If a more specific implementation comes along, it can be named appropriately.  This also avoids the Impl suffix that I particularly dislike (if it\'s not an abstract class, OF COURSE it is an "impl"!).I also prefer "Base(InterfaceName)" as opposed to "Abstract(InterfaceName)" because there are some situations in which you want your base class to become instantiable later, but now you\'re stuck with the name "Abstract(InterfaceName)", and this forces you to rename the class, possibly causing a little minor confusion - but if it was always Base(InterfaceName), removing the abstract modifier doesn\'t change what the class was.The name of the interface should describe the abstract concept the interface represents. Any implementation class should have some sort of specific traits that can be used to give it a more specific name.If there is only one implementation class and you can\'t think of anything that makes it specific (implied by wanting to name it -Impl), then it looks like there is no justification to have an interface at all.I tend to follow the pseudo-conventions established by Java Core/Sun, e.g. in the Collections classes:I used to do the same thing modeling my event classes after the AWT Event/Listener/Adapter paradigm.The standard C# convention, which works well enough in Java too, is to prefix all interfaces with an I - so your file handler interface will be IFileHandler and your truck interface will be ITruck. It\'s consistent, and makes it easy to tell interfaces from classes. I like interface names that indicate what contract an interface describes, such as "Comparable" or "Serializable". Nouns like "Truck" don\'t really describe truck-ness -- what are the Abilities of a truck?Regarding conventions: I have worked on projects where every interface starts with an "I"; while this is somewhat alien to Java conventions, it makes finding interfaces very easy. Apart from that, the "Impl" suffix is a reasonable default name.Some people don\'t like this, and it\'s more of a .NET convention than Java, but you can name your interfaces with a capital I prefix, for example:The people opposed to this naming convention might argue that you shouldn\'t care whether you\'re working with an interface or an object in your code, but I find it easier to read and understand on-the-fly.I wouldn\'t name the implementation class with a "Class" suffix.  That may lead to confusion, because you can actually work with "class" (i.e. Type) objects in your code, but in your case, you\'re not working with the class object, you\'re just working with a plain-old object.TruckClass sounds like it were a class of Truck, I think that recommended solution is to add Impl suffix. In my opinion the best solution is to contain within implementation name some information, what\'s going on in that particular implementation (like we have with List interface and implementations: ArrayList or LinkedList), but sometimes you have just one implementation and have to have interface due to remote usage (for example), then  (as mentioned at the beginning) Impl is the solution. I use both conventions:If the interface is a specific instance of a a well known pattern (e.g. Service, DAO), then it may not need an "I" (e.g UserService, AuditService, UserDao) all work fine without the "I", because the post-fix determines the meta pattern.But, if you have something one-off or two-off (usually for a callback pattern), then it helps to distinguish it from a class (e.g. IAsynchCallbackHandler, IUpdateListener, IComputeDrone).  These are special purpose interfaces designed for internal use, occasionally the IInterface calls out attention to the fact that an operand is actually an interface, so at first glance it is immediately clear.In other cases you can use the I to avoid colliding with other commonly known concrete classes (ISubject, IPrincipal vs Subject or Principal).