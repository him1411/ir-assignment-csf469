Edited:\nI need to change the values of several variables as they run several times thorugh a timer. I need to keep updating the values with every iteration through the timer. I cannot set the values to final as that will prevent me from updating the values however I am getting the error I describe in the initial question below:I had previously written what is below:I am getting the error "cannot refer to a non-final variable inside an inner class defined in a different method".This is happening for the double called price and the Price called priceObject. Do you know why I get this problem. I do not understand why I need to have a final declaration. Also if you can see what it is I am trying to do, what do I have to do to get around this problem.Java doesn\'t support true closures, even though using an anonymous class like you are using here (new TimerTask() { ... }) looks like a kind of closure.edit - See the comments below - the following is not a correct explanation, as KeeperOfTheSoul points out.This is why it doesn\'t work:The variables lastPrice and price are local variables in the main() method. The object that you create with the anonymous class might last until after the main() method returns.When the main() method returns, local variables (such as lastPrice and price) will be cleaned up from the stack, so they won\'t exist anymore after main() returns.But the anonymous class object references these variables. Things would go horribly wrong if the anonymous class object tries to access the variables after they have been cleaned up.By making lastPrice and price final, they are not really variables anymore, but constants. The compiler can then just replace the use of lastPrice and price in the anonymous class with the values of the constants (at compile time, of course), and you won\'t have the problem with accessing non-existent variables anymore.Other programming languages that do support closures do it by treating those variables specially - by making sure they don\'t get destroyed when the method ends, so that the closure can still access the variables.@Ankur: You could do this:To avoid strange side-effects with closures in java variables referenced by an anonymous delegate must be marked as final, so to refer to lastPrice and price within the timer task they need to be marked as final.This obviously won\'t work for you because you wish to change them, in this case you should look at encapsulating them within a class.now just create a new Foo as final and call .tick from the timer.You can only access final variables from the containing class when using an anonymous class.  Therefore you need to declare the variables being used final (which is not an option for you since you are changing lastPrice and price), or don\'t use an anonymous class.So your options are to create an actual inner class, in which you can pass in the variables and use them in a normal fashionor:There is a quick (and in my opinion ugly) hack for your lastPrice and price variable which is to declare it like soand in your anonymous class you can set the value like thisGood explanations for why you can\'t do what you\'re trying to do already provided. As a solution, maybe consider:Seems like probably you could do a better design than that, but the idea is that you could group the updated variables inside a class reference that doesn\'t change.With anonymous classes, you are actually declaring a "nameless" nested class. For nested classes, the compiler generates a new standalone public class with a constructor that will take all the variables it uses as arguments (for "named" nested classes, this is always an instance of the original/enclosing class). This is done because the runtime environment has no notion of nested classes, so there needs to be a (automatic) conversion from a nested to a standalone class. Take this code for example:That won\'t work, because this is what the compiler does under the hood:The original anonymous class is replaced by some standalone class that the compiler generates (code is not exact, but should give you a good idea):As you can see, the standalone class holds a reference to the shared object, remember that everything in java is pass-by-value, so even if the reference variable \'shared\' in EnclosingClass gets changed, the instance it points to is not modified, and all other reference variables pointing to it (like the one in the anonymous class: Enclosing$1), will not be aware of this. This is the main reason the compiler forces you to declare this \'shared\' variables as final, so that this type of behavior won\'t make it into your already running code. Now, this is what happens when you use an instance variable inside an anonymous class (this is what you should do to solve your problem, move your logic to an "instance" method or a constructor of a class):This compiles fine, because the compiler will modify the code, so that the new generated class Enclosing$1 will hold a reference to the instance of EnclosingClass where it was instantiated (this is only a representation, but should get you going):Like this, when the reference variable \'shared\' in EnclosingClass gets reassigned, and this happens before the call to Thread#run(), you\'ll see "other hello" printed twice, because now EnclosingClass$1#enclosing variable will keep a reference to the object of the class where it was declared, so changes to any attribute on that object will be visible to instances of EnclosingClass$1.For more information on the subject, you can see this excelent blog post (not written by me): http://kevinboone.net/java_inner.htmlWhen I stumble upon this issue, I just pass the objects to the inner class through the constructor. If I need to pass primitives or immutable objects (as in this case), a wrapper class is needed.Edit: Actually, I don\'t use an anonymous class at all, but a proper subclass:You cannot refer to non-final variables because Java Language Specification says so. From 8.1.3:\n"Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared final." Whole paragraph.\nI can see only part of your code - according to me scheduling modification of local variables is a strange idea. Local variables cease to exist when you leave the function. Maybe static fields of a class would be better?I just wrote something to handle something along the authors intention. \nI found the best thing to do was to let the constructor take all the objects and then in your implemented method use that constructor objects. However, if you are writing a generic interface class, then you have to pass an Object, or better a list of Objects. This could be done by Object[] or even better, Object ... because it is easier to call.See my example piece just below.Please see this post about Java closures that supports this out of the box:\nhttp://mseifed.blogspot.se/2012/09/closure-implementation-for-java-5-6-and.htmlVersion 1 supports passing of non-final closures with autocasting:\nhttps://github.com/MSeifeddo/Closure-implementation-for-Java-5-6-and-7/blob/master/org/mo/closure/v1/Closure.javaIf you want to change a value in a method call within an anonymous class, that "value" is actually a Future. So, if you use Guava, you can writeOne solution I have noticed isn\'t mentioned (unless I missed it, if I did please correct me), is the use of a class variable. Ran into this issue attempting to run a new thread within a method: new Thread(){ Do Something }. Calling doSomething() from the following will work. You do not necessarily have to declare it final, just need to change the scope of the variable so it is not collected before the innerclass. This is unless of course your process is huge and changing the scope might create some sort of conflict. I didn\'t want to make my variable final as it was in no way a final/constant.If the variable required to be final, cannot be then you can assign the value of the variable to another variable and make THAT final so you can use it instead.use ClassName.this.variableName to reference the non-final variableyou can just declare the variable outside the outer class. After this, you will be able to edit the variable from within the inner class. I sometimes face similar problems while coding in android so I declare the variable as global and it works for me.Can you make lastPrice, priceObject, and price fields of the anonymous inner class?The main concern is whether a variable inside the anonymous class instance can be resolved at run-time. It is not a must to make a variable final as long as it is guaranteed that the variable is inside the run-time scope. For example, please see the two variables _statusMessage and _statusTextView inside updateStatus() method.what worked for me is just define the variable outside this function of your.Just before main function declare i.e.Declare the variable as a static and reference it in the required method using className.variableJust an another explanation. Consider this example belowHere Output will bem1 Completes Thread t runningThread t runningThread t running................Now method m1() completes and we assign reference variable o to null , Now Outer Class Object is eligible for GC but Inner Class Object is still exist who has (Has-A) relationship with Thread object which is running. Without existing Outer class object there is no chance of existing m1() method and without existing m1() method there is no chance of existing its local variable but if Inner Class Object uses the local variable of m1() method then everything is self explanatory.To solve this we have to create a copy of local variable and then have to copy then into the heap with Inner class object, what java does for only final variable because they are not actually variable they are like constants(Everything happens at compile time only not at runtime).To solve the problem above, different languages make different decisions.for Java, the solution is as what we see in this article.for C#, the solution is allow side-effects and capture by reference is the only option.for C++11, the solution is to allow the programmer make the decision. They can choose to capture by value or by reference. If capturing by value, no side-effects would occur because the variable referenced is actually different. If capture by reference, side-effects may occur but the programmer should realize it.Because it\'s confusing if the variable isn\'t final, as the changes to it won\'t be picked up in the anonymous class.Just make the variables \'price\' and \'lastPrice\' final.-- EditOops, and you\'ll also need to not assign to them, obviously, in your function. You\'ll need new local variables. Anyway, I suspect someone has given you a better answer by now.