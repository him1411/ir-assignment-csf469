I just discovered that every request in an ASP.Net web application gets a Session lock at the beginning of a request, and then releases it at the end of the request!In case the implications of this are lost on you, as it was for me at first, this basically means the following:Anytime an ASP.Net webpage is taking a long time to load (maybe due to a slow database call or whatever), and the user decides they want to navigate to a different page because they are tired of waiting, THEY CAN\'T! The ASP.Net session lock forces the new page request to wait until the original request has finished its painfully slow load. Arrrgh.Anytime an UpdatePanel is loading slowly, and the user decides to navigate to a different page before the UpdatePanel has finished updating... THEY CAN\'T! The ASP.net session lock forces the new page request to wait until the original request has finished its painfully slow load. Double Arrrgh!So what are the options?  So far I have come up with:I really can\'t believe that the ASP.Net Microsoft team would have left such a huge performance bottleneck in the framework at version 4.0! Am I missing something obvious? How hard would it be to use a ThreadSafe collection for the Session?If your page does not modify any session variables, you can opt out of most of this lock.If your page does not read any session variables, you can opt out of this lock entirely, for that page.If none of your pages use session variables, just turn off session state in the web.config.I\'m curious, what do you think "a ThreadSafe collection" would do to become thread-safe, if it doesn\'t use locks?Edit: I should probably explain by what I mean by "opt out of most of this lock". Any number of read-only-session or no-session pages can be processed for a given session at the same time without blocking each other. However, a read-write-session page can\'t start processing until all read-only requests have completed, and while it is running it must have exclusive access to that user\'s session in order to maintain consistency. Locking on individual values wouldn\'t work, because what if one page changes a set of related values as a group? How would you ensure that other pages running at the same time would get a consistent view of the user\'s session variables?I would suggest that you try to minimize the modifying of session variables once they have been set, if possible. This would allow you to make the majority of your pages read-only-session pages, increasing the chance that multiple simultaneous requests from the same user would not block each other.OK, so big Props to Joel Muller for all his input. My ultimate solution was to use the Custom SessionStateModule detailed at the end of this MSDN article: http://msdn.microsoft.com/en-us/library/system.web.sessionstate.sessionstateutility.aspx This was:This has made a HUGE difference to the feeling of "snapiness" to our application.  I still can\'t believe the custom implementation of ASP.Net Session locks the session for the whole request.  This adds such a huge amount of sluggishness to websites.  Judging from the amount of online research I had to do (and conversations with several really experienced ASP.Net developers), a lot of people have experienced this issue, but very few people have ever got to the bottom of the cause.  Maybe I will write a letter to Scott Gu...I hope this helps a few people out there! I started using the AngiesList.Redis.RedisSessionStateModule, which aside from using the (very fast) Redis server  for storage (I\'m using the windows port -- though there is also an MSOpenTech port), it does absolutely no locking on the session.In my opinion, if your application is structured in a reasonable way, this is not a problem. If you actually need locked, consistent data as part of the session, you should specifically implement a lock/concurrency check on your own.MS deciding that every ASP.NET session should be locked by default just to handle poor application design is a bad decision, in my opinion. Especially because it seems like most developers didn\'t/don\'t even realize sessions were locked, let alone that apps apparently need to be structured so you can do read-only session state as much as possible (opt-out, where possible). I prepared a library based on links posted in this thread. It uses the examples from MSDN and CodeProject. Thanks to James.I also made modifications advised by Joel Mueller.Code is here:https://github.com/dermeister0/LockFreeSessionStateHashTable module:ScaleOut StateServer module:Custom module:If you want to implement support of Memcached or Redis, install this package. Then inherit the LockFreeSessionStateModule class and implement abstract methods.The code is not tested on production yet. Also need to improve error handling. Exceptions are not caught in current implementation.Some lock-free session providers using Redis:Unless your application has specially needs, I think you have 2 approaches:Session is not only thread-safe but also state-safe, in a way that you know that until the current request is completed, every session variable wont change from another active request. In order for this to happen you must ensure that session WILL BE LOCKED until the current request have completed.You can create a session like behavior by many ways, but if it does not lock the current session, it wont be \'session\'.For the specific problems you mentioned I think you should check HttpContext.Current.Response.IsClientConnected. This can be useful to to prevent unnecessary executions and waits on the client, although it cannot solve this problem entirely, as this can be used only by a pooling way and not async.For ASPNET MVC, we did the following:Create custom ControllerFactory and override GetControllerSessionBehaviour.AcquireSessionLockAttributeHook up the created controller factory in global.asax.csNow, we can have both read-only and read-write session state in a single Controller.Note: ASPNET session state can still be written to even in readonly\n  mode and will not throw any form of exception (It just doesn\'t lock to\n  guarantee consistency) so we have to be careful to mark AcquireSessionLock in controller\'s actions that require writing session state.Marking a controller\'s session state as readonly or disabled will solve the problem.You can decorate a controller with the following attribute to mark it read-only:the System.Web.SessionState.SessionStateBehavior enum has the following values:Just to help anyone with this problem (locking requests when executing another one from the same session)...Today I started to solve this issue and, after some hours of research, I solved it  by removing the Session_Start method (even if empty) from the Global.asax file.This works in all projects I\'ve tested.Change the debug mode to off in your web.config file.Developers usually have it on while processing and building your application for errors.But we don\'t need it while hosting.Actually what happens here is while building a application the developers need the code to be compiled on the browser.However the code received from the server  does not need to be compiled again on the browser as the code received is compiled already on the server itself.Moreover the whole website gets compiled when the application gets started on the server.