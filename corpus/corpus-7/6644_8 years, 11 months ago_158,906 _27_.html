In a J2EE application (like one running in WebSphere), when I use System.out.println(), my text goes to standard out, which is mapped to a file by the WebSphere admin console.In an ASP.NET application (like one running in IIS), where does the output of Console.WriteLine() go?  The IIS process must have a stdin, stdout and stderr; but is stdout mapped to the Windows version of /dev/null or am I missing a key concept here?I\'m not asking if I should log there (I use log4net), but where does the output go?  My best info came from this discussion where they say Console.SetOut() can change the TextWriter, but it still didn\'t answer the question on what the initial value of the Console is, or how to set it in config/outside of runtime code.If you look at the Console class in .NET Reflector, you\'ll find that if a process doesn\'t have an associated console, Console.Out and Console.Error are backed by Stream.Null (wrapped inside a TextWriter), which is a dummy implementation of Stream that basically ignores all input, and gives no output.So it is conceptually equivalent to /dev/null, but the implementation is more streamlined: there\'s no actual I/O taking place with the null device.Also, apart from calling SetOut, there is no way to configure the default.If you use System.Diagnostics.Debug.WriteLine(...) instead of Console.WriteLine(), then you can see the results in the Output window of Visual Studio.I\'ve found this question by trying to change the Log output of the DataContext to the output window. So to anyone else trying to do the same,  what I\'ve done was create this:Annd after that: dc.Log = new DebugTextWriter() and I can see all the queries in the output window (dc is the DataContext).Have a look at this for more info: http://damieng.com/blog/2008/07/30/linq-to-sql-log-to-debug-window-file-memory-or-multiple-writersIf you are using IIS Express and launch it via a command prompt, it will leave the DOS window open, and you will see Console.Write statements there.So for example get a command window open and type:This assumes you have a website directory at C:\\Projects\\Website1. It will start IIS Express and serve the pages in your website directory. It will leave the command windows open, and you will see output information there.  Let\'s say you had a file there, default.aspx, with this code in it:Arrange your browser and command windows so you can see them both on the screen. Now type into your browser: http://localhost:1655/. You will see Hello! on the webpage, but in the command window you will see something likeI made it simple by having the code in a code block in the markup, but any console statements in your code-behind or anywhere else in your code will show here as well.There simply is no console listening by default. Running in debug mode there is a console attached, but in a production environment it is as you suspected, the message just doesn\'t go anywhere because nothing is listening.System.Diagnostics.Debug.WriteLine(...); gets it into the Immediate Window in Visual Studio 2008.Go to menu Debug -> Windows -> Immediate:The TraceContext object in ASP.NET writes to the DefaultTraceListener which outputs to the host process\xe2\x80\x99 standard output. Rather than using Console.Write(), if you use Trace.Write, output will go to the standard output of the process.You could use the System.Diagnostics.Process object to get the ASP.NET process for your site and monitor standard output using the OutputDataRecieved event.Unless you are in a strict console application, I wouldn\'t use it, because you can\'t really see it. I would use Trace.WriteLine() for debugging-type information that can be turned on and off in production.In an ASP.NET application, I think it goes to the Output or Console window which is visible during debugging.If you look in the debug window you will see console.writelines. This is confusing for everyone when it comes IISExpress. There is nothing to read console messages. So for example, in the ASPCORE MVC apps it configures using appsettings.json which does nothing if you are using IISExpress.For right now you can just add loggerFactory.AddDebug(LogLevel.Debug); in your Configure section and it will at least show you your logs in the Debug Output window.Good news CORE 2.0 this will all be changing: https://github.com/aspnet/Announcements/issues/255