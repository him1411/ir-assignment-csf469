I have a generic class in my project with derived classes.Is there any way to find out if a Type object is derived from GenericClass?does not work.Try this code(Reposted due to a massive rewrite)JaredPar\'s code answer is fantastic, but I have a tip that would make it unnecessary if your generic types are not based on value type parameters.  I was hung up on why the "is" operator would not work, so I have also documented the results of my experimentation for future reference.  Please enhance this answer to further enhance its clarity. If you make certain that your GenericClass implementation inherits from an abstract non-generic base class such as GenericClassBase, you could ask the same question without any trouble at all like this:My testing indicates that IsSubclassOf() does not work on parameterless generic types such as whereas it will work with Therefore the following code will work for any derivation of GenericClass<>, assuming you are willing to test based on SomeType:The only time I can imagine that you would want to test by GenericClass<> is in a plug-in framework scenario.At design-time C# does not allow the use of parameterless generics because they are essentially not a complete CLR type at that point.  Therefore, you must declare generic variables with parameters, and that is why the "is" operator is so powerful for working with objects.  Incidentally, the "is" operator also can not evaluate parameterless generic types.The "is" operator will test the entire inheritance chain, including interfaces.  So, given an instance of any object, the following method will do the trick:This is sort of redundant, but I figured I would go ahead and visualize it for everybody.  Given The following lines of code would return true:On the other hand, if you want something specific to GenericClass, you could make it more specific, I suppose, like this:Then you would test like this:I worked through some of these samples and found they were lacking in some cases. This version works with all kinds of generics: types, interfaces and type definitions thereof.Here are the unit tests also:It seems to me that this implementation works in more cases (generic class and interface with or without initiated parameters, regardless of the number of child and parameters):Here are my 70 76 test cases:Classes and interfaces for testing :Here\'s a little method I created for checking that a object is derived from a specific type.  Works great for me!JaredPar\'s code works but only for one level of inheritance.  For unlimited levels of inheritance, use the following codeIt might be overkill but I use extension methods like the following.  They check interfaces as well as subclasses.  It can also return the type that has the specified generic definition.E.g. for the example in the question it can test against generic interface as well as generic class.  The returned type can be used with GetGenericArguments to determine that the generic argument type is "SomeType".Building on the excellent answer above by fir3rpho3nixx and David Schmitt, I have modified their code and added the ShouldInheritOrImplementTypedGenericInterface test (last one).This can all be done easily with linq.  This will find any types that are a subclass of generic base class GenericBaseType.Simple solution: just create and add a second, non-generic interface to the generic class:Then just check for that in any way you like using is, as, IsAssignableFrom, etc.Obviously only possible if you have the ability to edit the generic class (which the OP seems to have), but it\'s a bit more elegant and readable than using a cryptic extension method.Added to @jaredpar\'s answer, here\'s what I use to check for interfaces:Ex:JaredPar,This did not work for me if I pass typeof(type<>) as toCheck.  Here\'s what I changed.You can try this extensionlate to the game on this... i too have yet another permutation of JarodPar\'s answer.here\'s Type.IsSubClassOf(Type) courtesy of reflector:from that, we see that it\'s not doing anything too cray cray and is similar to JaredPar\'s iterative approach. so far, so good.  here\'s my version (disclaimer: not thoroughly tested, so lemme know if you find issues)basically this is just an extension method to System.Type - i did this to intentionally limit the "thisType" Type to concrete Types, as my immediate usage is to LINQ query "where" predicates against Type objects.  i\'m sure all you smart folks out there could bang it down to an efficient, all-purpose static method if you need to :)  the code does a few things the answer\'s code doesn\'tthe rest is basically the same as JaredPar\'s code