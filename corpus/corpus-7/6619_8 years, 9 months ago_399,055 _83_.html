As made clear in update 3 on this answer, this notation:does not actually hash the object X; it actually just converts X to a string (via .toString() if it\'s an object, or some other built-in conversions for various primitive types) and then looks that string up, without hashing it, in "hash". Object equality is also not checked - if two different objects have the same string conversion, they will just overwrite each other.Given this - are there any efficient implementations of hashmaps in javascript? (For example, the 2nd Google result of javascript hashmap yields an implementation which is O(n) for any operation. Various other results ignore the fact that different objects with equivalent string representations overwrite each other.Why not hash your objects yourself manually, and use the resulting strings as keys for a regular JavaScript dictionary? After all you are in the best position to know what makes your objects unique. That\'s what I do.Example:This way you can control indexing done by JavaScript without heavy lifting of memory allocation, and overflow handling.Of course, if you truly want the "industrial-grade solution", you can build a class parameterized by the key function, and with all necessary API of the container, but … we use JavaScript, and trying to be simple and lightweight, so this functional solution is simple and fast.The key function can be as simple as selecting right attributes of the object, e.g., a key, or a set of keys, which are already unique, a combination of keys, which are unique together, or as complex as using some cryptographic hashes like in DojoX Encoding, or DojoX UUID. While the latter solutions may produce unique keys, personally I try to avoid them at all costs, especially, if I know what makes my objects unique.Update in 2014: Answered back in 2008 this simple solution still requires more explanations. Let me clarify the idea in a Q&A form.Your solution doesn\'t have a real hash. Where is it???JavaScript is a high-level language. Its basic primitive\n(Object)\nincludes a hash table to keep properties. This hash table is usually written\nin a low-level language for efficiency. Using a simple object with string keys we use an efficiently implemented hash table with no efforts on our part.How do you know they use hash?There are three major ways to keep a collection of objects addressable by a key:Obviously JavaScript objects use hash tables in some form to handle general cases.Do browser vendors really use hash tables???Really.Do they handle collisions?Yes. See above. If you found a collision on unequal strings, please do not hesitate to file a bug with a vendor.So what is your idea?If you want to hash an object, find what makes it unique and use it as a key. Do not try to calculate real hash or emulate hash tables — it is already efficiently handled by the underlying JavaScript object.Use this key with JavaScript Object to leverage its built-in hash table while steering clear of possible clashes with default properties.Examples to get you started:I used your suggestion and cached all objects using a user name. But some wise guy is named "toString", which is a built-in property! What should I do now?Obviously, if it is even remotely possible that the resulting key will exclusively consists of Latin characters, you should do something about it. For example, add any non-Latin Unicode character you like at the beginning or at the end to un-clash with default properties: "#toString", "#MarySmith". If a composite key is used, separate key components using some kind of non-Latin delimiter: "name,city,state".In general this is the place, where we have to be creative, and select the easiest keys with given limitations (uniqueness, potential clashes with default properties).Note: unique keys do not clash by definition, while potential hash clashes will be handled by the underlying Object.Why don\'t you like industrial solutions?IMHO, the best code is no code at all: it has no errors, requires no maintenance, easy to understand, and executes instantaneously. All "hash tables in JavaScript" I saw were >100 lines of code, and involved multiple objects. Compare it with: dict[key] = value.Another point: is it even possible to beat a performance of a primordial object written in a low-level language, using JavaScript and the very same primordial objects to implement what is already implemented?I still want to hash my objects without any keys!We are in luck: ECMAScript 6 (scheduled for mid 2015 release, give or take 1-2 years after that to become widespread) defines\nmap and\nset.Judging by the definition they can use object\'s address as a key, which makes objects instantly distinct without artificial keys. OTOH, two different, yet identical objects, will be mapped as distinct.JavaScript has no built-in general map type (sometimes called associative array or dictionary) which allows to access arbitrary values by arbitrary keys. JavaScript\'s fundamental data structure is the object, a special type of map which only accepts strings as keys and has special semantics like prototypical inheritance, getters and setters and some further voodoo.When usings objects as maps, you have to remember that the key will be converted to a string value via toString(), which results in mapping 5 and \'5\' to the same value and all objects which don\'t overwrite the toString() method to the value indexed by \'[object Object]\'. You might also involuntarily access its inherited properties if you don\'t check hasOwnProperty().JavaScript\'s built-in array type does not help one bit: JavaScript arrays are not associative arrays, but just objects with a few more special properties. If you want to know why they can\'t be used as maps, look here.Eugene Lazutkin already described the basic idea of using a custom hash function to generate unique strings which can be used to look up the associated values as properties of a dictionary object. This will most likely be the fastest solution, because objects are internally implemented as hash tables.In order to get a unique hash value for arbitrary objects, one possibility is to use a global counter and cache the hash value in the object itself (eg in a property named __hash).A hash function which does this is and works for both primitive values and objects is:This function can be used as described by Eugene. For convenience, we will further wrap it in a Map class.The following implementation will additionally store the key-value-pairs in a doubly linked list in order to allow fast iteration over both keys and values. To supply your own hash function, you can overwrite the instance\'s hash() method after creation.The following scriptgenerates this output:PEZ suggested to overwrite the toString() method, presumably with our hash function. This is not feasible because it doesn\'t work for primitive values (changing toString() for primitives is a very bad idea). If we want toString() to return meaningful values for arbitrary objects, we would have to modify Object.prototype, which some people (myself not included) consider verboten.Edit: The current version of my Map implementation as well as other JavaScript goodies can be obtained from here.I know this question is pretty old, but there are some really great solutions nowadays with external libraries.JavaScript also has its language provided Map as well.Here is an easy and convenient way of using something similar to the java map:And to get the value: You\'d have to store in some internal state couplets of object/value pairsAnd use it as such:Of course, this implementation is also somewhere along the lines of O(n). Eugene\'s examples above are the only way to get a hash that works with any sort of speed you\'d expect from a real hash.Update:Another approach, along the lines of Eugene\'s answer is to somehow attach a unique ID to all objects. One of my favorite approaches is to take one of the built-in methods inherited from the Object superclass, replace it with a custom function passthrough and attach properties to that function object. If you were to rewrite my HashMap method to do this, it would look like:This version appears to be only slightly faster, but in theory it will be significantly faster for large data sets.You can use ES6 WeakMap or Map:WeakMaps are key/value maps in which keys are objects.\nMap objects are simple key/value maps. Any value (both objects and primitive values) may be used as either a key or a value.\nBe aware that neither is widely supported, but you can use ES6 Shim (requires native ES5 or ES5 Shim) to support Map, but not WeakMap (see why).Unfortunately, none of the above answers were good for my case: different key objects may have the same hash code. Therefore, I wrote a simple Java-like HashMap version:Note: key objects must "implement" hashCode() and equals() methods.According to ECMAScript 2015 (ES6) standard javascript has a Map implementation. More about which could be found hereBasic usage:I\'ve implemented a JavaScript HashMap which code can be obtained from http://github.com/lambder/HashMapJS/tree/masterHere is the code:In ECMA6 you can use WeakMap Example:But:Try my JavaScript hash table implementation: http://www.timdown.co.uk/jshashtableIt looks for a hashCode() method of key objects, or you can supply a hashing function when creating a Hashtable object.This looks like a pretty robust solution: https://github.com/flesler/hashmap . It will even work well for functions and objects that look identical. The only hack it uses is adding an obscure member to an object to identify it. If your program doesn\'t overwrite that obscure variable (its something like hashid), you\'re golden.If performance is not critical (e.g. the amount of keys is relatively small) and you don\'t want to pollute your (or maybe not your) objects with additional fields like _hash, _id, etc., then you can make use of the fact that Array.prototype.indexOf employs strict equality. Here is a simple implementation:Example of usage:Comparing to ES6 WeakMap it has two issues: O(n) search time and non-weakness (i.e. it will cause memory leak if you don\'t use delete or clear to release keys).My Map Implementation, derived from Christoph\'s example:Example Usage:Javascript does not build-in Map/hashmap. It should be called associative array.hash["X"] is equals to hash.X, but allow "X" as a string variable.\nIn other words, hash[x] is functionally equals to eval("hash."+x.toString())It is more similar as object.properties rather then key-value mapping.\nIf you are looking for a better Key/value mapping in Javascript, please use Map object which you can find on the web.Adding yet another solution: HashMap is pretty much the first class I ported from Java to Javascript. You could say there is a lot of overhead, but the implementation is almost 100% equal to Java\'s implementation and includes all interfaces and subclasses.The project can be found here: https://github.com/Airblader/jsava\nI\'ll also attach the (current) source code for the HashMap class, but as stated it also depends on the super class etc. The OOP framework used is qooxdoo.Edit: Please note that this code is already out-dated and refer to the github project for the current work. As of writing this, there is also an ArrayList implementation.Yet another map implementation by me. With randomizer, \'generics\' and \'iterator\' =)Example: