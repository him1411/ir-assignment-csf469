I\'ve done a fair bit of work ("Your branch is ahead of \'origin/master\' by 37 commits.") which really should have gone into its own branch rather than into master.  These commits only exist on my local machine and have not been pushed to origin, but the situation is complicated somewhat in that other devs have been pushing to origin/master and I\'ve pulled those changes.How do I retroactively move my 37 local commits onto a new branch?  Based on the docs, it appears that git rebase --onto my-new-branch master or ...origin/master should do this, but both just give me the error "fatal: Needed a single revision".  man git-rebase says nothing about providing a revision to rebase and its examples do not do so, so I have no idea how to resolve this error.(Note that this is not a duplicate of Move existing, uncommited work to a new branch in Git or How to merge my local uncommitted changes into another Git branch? as those questions deal with uncommitted changes in the local working tree, not changes which have been committed locally.)This should be fine, since you haven\'t pushed your commits anywhere else yet, and you\'re free to rewrite the history of your branch after origin/master.  First I would run a git fetch origin to make sure that origin/master is up to date.  Assuming that you\'re currently on master, you should be able to do:... which will replay all of your commits that aren\'t in origin/master onto origin/master.  The default action of rebase is to ignore merge commits (e.g. those that your git pulls probably introduced) and it\'ll just try to apply the patch introduced by each of your commits onto origin/master.  (You may have to resolve some conflicts along the way.)  Then you can create your new branch based on the result:... and then reset your master back to origin/master:When doing this kind of manipulating branches with git branch, git reset, etc. I find it useful to frequently look at the commit graph with gitk --all or a similar tool, just to check that I understand where all the different refs are pointing.Alternatively, you could have just created a topic branch based on where your master is at in the first place (git branch new-work-including-merges) and then reset master as above.  However, since your topic branch will include merges from origin/master and you\'ve not pushed your changes yet, I\'d suggest doing a rebase so that the history is tidier.  (Also, when you eventually merge your topic branch back to master, the changes will be more obvious.)If you have a low # of commits and you don\'t care if these are combined into one mega-commit, this works well:unstage the files (replace 1 with # of commits)create a new branchadd the changesmake a commitOne more way\nassume \nbranch1 - is branch with committed changes\nbranch2 - is desirable branchselect commit ids that you need to moveNow revert unpushed commits from initial branchWhat about:Or will that explode when you try to re-merge the branch?Alternatively, right after you commit to the wrong branch, perform these steps:I can imagine that there is a simpler approach for steps one and two.Checkout fresh copy of you sourcesgit clone  ........Make branch from desired position git checkout {position}\ngit checkout -b {branch-name}Add remote repository  git remote add shared ../{original sources location}.gitGet remote sources git fetch sharedCheckout desired branchgit checkout {branch-name}Merge sources git merge shared/{original branch from shared repository}For me this was the best way: