I keep seeing references to the visitor pattern in blogs but I\'ve got to admit, I just don\'t get it.  I read the wikipedia article for the pattern and I understand its mechanics but I\'m still confused as to when I\'d use it.As someone who just recently really got the decorator pattern and is now seeing uses for it absolutely everywhere I\'d like to be able to really understand intuitively this seemingly handy pattern as well.I\'m not very familiar with the Visitor pattern. Let\'s see if I got it right. Suppose you have a hierarchy of animals(Suppose it is a complex hierarchy with a well-established interface.)Now we want to add a new operation to the hierarchy, namely we want each animal to make its sound. As far as the hierarchy is this simple, you can do it with straight polymorphism:But proceeding in this way, each time you want to add an operation you must modify the interface to every single class of the hierarchy. Now, suppose instead that you are satisfied with the original interface, and that you want to make the fewest possible modifications to it.The Visitor pattern allows you to move each new operation in a suitable class, and you need to extend the hierarchy\'s interface only once. Let\'s do it. First, we define an abstract operation (the "Visitor" class in GoF) which has a method for every class in the hierarchy:Then, we modify the hierarchy in order to accept new operations:Finally, we implement the actual operation, without modifying neither Cat nor Dog:Now you have a way to add operations without modifying the hierarchy anymore.\nHere is how it works:The reason for your confusion is probably that the Visitor is a fatal misnomer. Many (prominent1!) programmers have stumbled over this problem. What it actually does is implement double dispatching in languages that don\'t support it natively (most of them don\'t).1) My favourite example is Scott Meyers, acclaimed author of \xe2\x80\x9cEffective C++\xe2\x80\x9d, who called this one of his most important C++ aha! moments ever.Everyone here is correct, but I think it fails to address the "when". First, from Design Patterns:Visitor lets you define a new\n  operation without changing the classes\n  of the elements on which it operates.Now, let\'s think of a simple class hierarchy. I have classes 1, 2, 3 and 4 and methods A, B, C and D. Lay them out like in a spreadsheet: the classes are lines and the methods are columns.Now, Object Oriented design presumes you are more likely to grow new classes than new methods, so adding more lines, so to speak, is easier. You just add a new class, specify what\'s different in that class, and inherits the rest.Sometimes, though, the classes are relatively static, but you need to add more methods frequently -- adding columns. The standard way in an OO design would be to add such methods to all classes, which can be costly. The Visitor pattern makes this easy.By the way, this is the problem that Scala\'s pattern matches intends to solve.The Visitor design pattern works really well for "recursive" structures like directory trees, XML structures, or document outlines.A Visitor object visits each node in the recursive structure: each directory, each XML tag, whatever.  The Visitor object doesn\'t loop through the structure.  Instead Visitor methods are applied to each node of the structure.  Here\'s a typical recursive node structure.  Could be a directory or an XML tag.\n[If your a Java person, imagine of a lot of extra methods to build and maintain the children list.]The visit method applies a Visitor object to each node in the structure.  In this case, it\'s a top-down visitor.  You can change the structure of the visit method to do bottom-up or some other ordering.Here\'s a superclass for visitors.  It\'s used by the visit method.  It "arrives at" each node in the structure.  Since the visit method calls up and down, the visitor can keep track of the depth.A subclass could do things like count nodes at each level and accumulate a list of nodes, generating a nice path hierarchical section numbers.Here\'s an application.  It builds a tree structure, someTree.  It creates a Visitor, dumpNodes.  Then it applies the dumpNodes to the tree.  The dumpNode object will "visit" each node in the tree.The TreeNode visit algorithm will assure that every TreeNode is used as an argument to the Visitor\'s arrivedAt method.One way to look at it is that the visitor pattern is a way of letting your clients add additional methods to  all of your classes in a particular class hierarchy.It is useful when you have a fairly stable class hierarchy, but you have changing requirements of what needs to be done with that hierarchy.The classic example is for compilers and the like. An Abstract Syntax Tree (AST) can accurately define the structure of the programming language, but the operations you might want to do on the AST will change as your project advances: code-generators, pretty-printers, debuggers, complexity metrics analysis.Without the Visitor Pattern, every time a developer wanted to add a new feature, they would need to add that method to every feature in the base class. This is particularly hard when the base classes appear in a separate library, or are produced by a separate team.(I have heard it argued that the Visitor pattern is in conflict with good OO practices, because it moves the operations of the data away from the data. The Visitor pattern is useful in precisely the situation that the normal OO practices fail.)There are at least three very good reasons for using the Visitor Pattern:Reduce proliferation of code which is only slightly different when data structures change.Apply the same computation to several data structures, without changing the code which implements the computation.Add information to legacy libraries without changing the legacy code.Please have a look at an article I\'ve written about this.As Konrad Rudolph already pointed out, it is suitable for cases where we need double dispatchHere is an example to show a situation where we need double dispatch & how visitor helps us in doing so. Example : Lets say I have 3 types of mobile devices - iPhone, Android, Windows Mobile.All these three devices have a Bluetooth radio installed in them. Lets assume that the blue tooth radio can be from 2 separate OEMs \xe2\x80\x93 Intel & Broadcom. Just to make the example relevant for our discussion, lets also assume that the APIs exposes by Intel radio are different from the ones exposed by Broadcom radio. This is how my classes look \xe2\x80\x93 \nNow, I would like to introduce an operation \xe2\x80\x93 Switching On the Bluetooth on mobile device. Its function signature should like something like this \xe2\x80\x93 So depending upon Right type of device and Depending upon right type of Bluetooth radio, it can be switched on by calling appropriate steps or algorithm. In principal, it becomes a 3 x 2 matrix, where-in I\xe2\x80\x99m trying to vector the right operation depending upon  the right type of objects involved. A polymorphic behaviour depending upon the type of both the arguments.Now, Visitor pattern can be applied to this problem.  Inspiration comes from the Wikipedia page stating \xe2\x80\x93 \xe2\x80\x9cIn essence, the visitor allows one to add new virtual functions to a family of classes without modifying the classes themselves; instead, one creates a visitor class that implements all of the appropriate specializations of the virtual function. The visitor takes the instance reference as input, and implements the goal through double dispatch.\xe2\x80\x9dDouble dispatch is a necessity here due to the 3x2 matrixHere is how the set up will look like - \nI wrote the example to answer another question, the code & its explanation is mentioned here. In my opinion, the amount of work to add a new operation is more or less the same using Visitor Pattern or direct modification of each element structure. Also, if I were to add new element class, say Cow, the Operation interface will be affected and this propagates to all existing class of elements, therefore requiring recompilation of all element classes. So what is the point?I found it easier in following links:In\nhttp://www.remondo.net/visitor-pattern-example-csharp/ I found an example that shows an mock example that shows what is benefit of visitor pattern. Here you have different container classes for Pill:As you see in above, You BilsterPack contain pairs of Pills\' so you need to multiply number of pair\'s by 2. Also you may notice that Bottle use unit which is different datatype and need to be cast.So in main method you may calculate pill count using following code:Notice that above code violate Single Responsibility Principle. That means you must change main method code if you add new type of container. Also making switch longer is bad practice. So by introducing following code:You moved responsibility of counting number of Pills to class called PillCountVisitor (And we removed switch case statement). That mean\'s whenever you need to add new type of pill container you should change only PillCountVisitor class. Also notice IVisitor interface is general for using in another scenarios.By adding Accept method to pill container class:we allow visitor to visit pill container classes.At the end we calculate pill count using following code:That mean\'s: Every pill container allow the PillCountVisitor visitor to see their pills count. He know how to count your pill\'s.At the visitor.Count has the value of pills.In\nhttp://butunclebob.com/ArticleS.UncleBob.IuseVisitor you see real scenario in which you can not use polymorphism (the answer) to follow Single Responsibility Principle. In fact in:the reportQtdHoursAndPay method is for reporting and representation and this violate the Single Responsibility Principle. So it is better to use visitor pattern to overcome the problem.Cay Horstmann has a great example of where to apply Visitor in his OO Design and patterns book. He summarizes the problem:Compound objects often have a complex structure, composed of individual elements. Some elements may again have child elements. ... An operation on an element visits its child elements, applies the operation to them, and combines the results. ... However, it is not easy to add new operations to such a design.  The reason it\'s not easy is because operations are added within the structure classes themselves. For example, imagine you have a File System:Here are some operations (functionalities) we might want to implement with this structure:You could add functions to each class in the FileSystem to implement the operations (and people have done this in the past as it\'s very obvious how to do it). The problem is that whenever you add a new functionality (the "etc." line above), you might need to add more and more methods to the structure classes. At some point, after some number of operations you\'ve added to your software, the methods in those classes don\'t make sense anymore in terms of the classes\' functional cohesion. For example, you have a FileNode that has a method calculateFileColorForFunctionABC() in order to implement the latest visualization functionality on the file system. The Visitor Pattern (like many design patterns) was born from the pain and suffering of developers who knew there was a better way to allow their code to change without requiring a lot of changes everywhere and also respecting good design principles (high cohesion, low coupling). It\'s my opinion that it\'s hard to understand the usefulness of a lot of patterns until you\'ve felt that pain. Explaining the pain (like we attempt to do above with the "etc." functionalities that get added) takes up space in the explanation and is a distraction. Understanding patterns is hard for this reason.Visitor allows us to decouple the functionalities on the data structure (e.g., FileSystemNodes) from the data structures themselves. The pattern allows the design to respect cohesion -- data structure classes are simpler (they have fewer methods) and also the functionalities are encapsulated into Visitor implementations. This is done via double-dispatching (which is the complicated part of the pattern): using accept() methods in the structure classes and visitX() methods in the Visitor (the functionality) classes: This structure allows us to add new functionalities that work on the structure as concrete Visitors (without changing the structure classes). For example, a PrintNameVisitor that implements the directory listing functionality, and a PrintSizeVisitor that implements the version with the size. We could imagine one day having an \'ExportXMLVisitor` that generates the data in XML, or another visitor that generates it in JSON, etc. We could even have a visitor that displays my directory tree using a graphical language such as DOT, to be visualized with another program.As a final note: The complexity of Visitor with its double-dispatch means it is harder to understand, to code and to debug. In short, it has a high geek factor and goes agains the KISS principle. In a survey done by researchers, Visitor was shown to be a controversial pattern (there wasn\'t a consensus about its usefulness). Some experiments even showed it didn\'t make code easier to maintain. Based on the excellent answer of @Federico A. Ramponi.Just imagine you have this hierarchy:What happen if you need to add a "Walk" method here? That will be painful to the whole design.At the same time, adding the "Walk" method generate new questions. What about "Eat" or "Sleep"? Must we really add a new method to the Animal hierarchy for every new action or operation that we want to add? That\'s ugly and most important, we will never be able to close the Animal interface. So, with the visitor pattern, we can add new method to the hierarchy without modifying the hierarchy!So, just check and run this C# example:Visitor Pattern as the same underground implementation to  Aspect Object programming.. For example if you define a new operation without changing the classes of the elements on which it operates VisitorVisitor allows one to add new virtual functions to a family of classes without modifying the classes themselves; instead, one creates a visitor class that implements all of the appropriate specializations of the virtual functionVisitor structure:Use Visitor pattern if:Even though Visitor pattern provides flexibility to add new operation without changing the existing code in Object, this flexibility has come with a drawback. If a new Visitable object has been added, it requires code changes in Visitor & ConcreteVisitor classes. There is a workaround to address this issue : Use reflection, which will have impact on performance. Refer to oodesign articlesourcemaking articleSO Documentation linkfor more detailsDecorator pattern allows behaviour to be added to an individual object, either statically or dynamically, without affecting the behaviour of other objects from the same classRefer to this related SE question for more details:vendingmachinedecorator example in SO documentation pageDecorator Pattern for IOWhile I have understood the how and when, I have never understood the why. In case it helps anyone with a background in a language like C++, you want to read this very carefully.For the lazy, we use the visitor pattern because "while virtual functions are dispatched dynamically in C++, function overloading is done statically".Or, put another way, to make sure that CollideWith(ApolloSpacecraft&) is called when you pass in a SpaceShip reference that is actually bound to an ApolloSpacecraft object.I really like the description and the example from http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Visitor.html.The assumption is that you have a primary class hierarchy that is fixed; perhaps it\xe2\x80\x99s from another vendor and you can\xe2\x80\x99t make changes to that hierarchy. However, your intent is that you\xe2\x80\x99d like to add new polymorphic methods to that hierarchy, which means that normally you\xe2\x80\x99d have to add something to the base class interface. So the dilemma is that you need to add methods to the base class, but you can\xe2\x80\x99t touch the base class. How do you get around this?The design pattern that solves this kind of problem is called a \xe2\x80\x9cvisitor\xe2\x80\x9d (the final one in the Design Patterns book), and it builds on the double dispatching scheme shown in the last section.The visitor pattern allows you to extend the interface of the primary type by creating a separate class hierarchy of type Visitor to virtualize the operations performed upon the primary type. The objects of the primary type simply \xe2\x80\x9caccept\xe2\x80\x9d the visitor, then call the visitor\xe2\x80\x99s dynamically-bound member function.When you want to have function objects on union data types, you will need visitor pattern.You might wonder what function objects and union data types are, then it\'s worth reading  http://www.ccs.neu.edu/home/matthias/htdc.html