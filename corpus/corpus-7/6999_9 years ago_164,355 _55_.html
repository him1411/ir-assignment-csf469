Comparing string in C# is pretty simple.  In fact there are several ways to do it.  I have listed some in the block below.  What I am curious about are the differences between them and when one should be used over the others?  Should one be avoided at all costs?  Are there more I haven\'t listed?  (Note: I am looking for equality in this example, not less than or greater than but feel free to comment on that as well)Here are the rules for how these functions work:stringValue.CompareTo(otherStringValue):stringValue.Equals(otherStringValue):stringValue == otherStringValue:Object.ReferenceEquals(stringValue, otherStringValue):Just checks that references are the same, ie. it isn\'t just two strings with the same contents, you\'re comparing a string object with itself.Note that with the options above that use method calls, there are overloads with more options to specify how to compare.My advice if you just want to check for equality is to make up your mind wether you want to use a culture-dependant comparison or not, and then use .CompareTo or .Equals, depending on the choice.From MSDN:"The CompareTo method was designed primarily for use in sorting or\n  alphabetizing      operations. It should not be used when the primary\n  purpose of the method call is to     determine whether two strings are\n  equivalent. To determine whether two strings are    equivalent, call\n  the Equals method."They suggest using .Equals instead of .CompareTo when looking solely for equality.  I am not sure if there is a difference between .Equals and == for the string class.  I will sometimes use .Equals or Object.ReferenceEquals instead of == for my own classes in case someone comes along at a later time and redefines the == operator for that class.If you are ever curious about differences in BCL methods, Reflector is your friend :-)I follow these guidelines:Exact match: EDIT: I previously always used == operator on the principle that inside Equals(string, string) the object == operator is used to compare the object references but it seems strA.Equals(strB) is still 1-11% faster overall than string.Equals(strA, strB), strA == strB, and string.CompareOrdinal(strA, strB).  I loop tested with a StopWatch on both interned/non-interned string values, with same/different string lengths, and varying sizes (1B to 5MB).Human-readable match (Western cultures, case-insensitive):Human-readable match (All other cultures, insensitive case/accent/kana/etc defined by CultureInfo):Human-readable match with custom rules (All other cultures):As Ed said, CompareTo is used for sorting.There is a difference, however, between .Equals and ==.== resolves to essentially the following code:The simple reason is the following will throw an exception:And the following will not:Good explanation and practices about string comparison issues may be found in the article New Recommendations for Using Strings in Microsoft .NET 2.0 and also in Best Practices for Using Strings in the .NET Framework.Each of mentioned method (and other) has particular purpose. The key difference between them is what sort of StringComparison Enumeration they are using by default. There are several options:Each of above comparison type targets different use case:Note, that StringComparison Enumeration as well as overloads for string comparison methods, exists since .NET 2.0.Is in fact type safe implementation of IComparable.CompareTo Method. Default interpretation: CurrentCulture.Usage:The CompareTo method was designed primarily for use in sorting or alphabetizing operationsThusImplementing the IComparable interface will necessarily use this methodA static member of String Class which has many overloads. Default interpretation: CurrentCulture.Whenever possible, you should call an overload of the Compare method that includes a StringComparison parameter.Overriden from Object class and overloaded for type safety. Default interpretation: Ordinal.\nNotice that:The String class\'s equality methods include the static Equals, the static operator ==, and the instance method Equals.There is also another way to deal with string comparisons especially aims to sorting:You can use the StringComparer class to create a type-specific comparison to sort the elements in a generic collection. Classes such as Hashtable, Dictionary, SortedList, and SortedList use the StringComparer class for sorting purposes.Not that performance usually matters with 99% of the times you need to do this, but if you had to do this in a loop several million times I would highly suggest that you use .Equals or == because as soon as it finds a character that doesn\'t match it throws the whole thing out as false, but if you use the CompareTo it will have to figure out which character is less than the other, leading to slightly worse performance time.If your app will be running in different countries, I\'d recommend that you take a look at the CultureInfo implications and possibly use .Equals. Since I only really write apps for the US (and don\'t care if it doesn\'t work properly by someone), I always just use ==.In the forms you listed here, there\'s not much difference between the two.  CompareTo ends up calling a CompareInfo method that does a comparison using the current culture; Equals is called by the == operator.If you consider overloads, then things get different.  Compare and == can only use the current culture to compare a string.  Equals and String.Compare can take a StringComparison enumeration argument that let you specify culture-insensitive or case-insensitive comparisons.  Only String.Compare allows you to specify a CultureInfo and perform comparisons using a culture other than the default culture.Because of its versatility, I find I use String.Compare more than any other comparison method; it lets me specify exactly what I want.One BIG difference to note is .Equals() will throw an exception if first string is null, Whereas == will not.Using .Equals is also a lot easier to read.CompareTo compares the string with a string object and return an int value. If the value is 0, then it means strings are equal. with .Equals, you also gain the StringComparison options. very handy for ignoring case and other things.btw, this will evaluate to falseSince == compares the values of a and b (which are pointers) this will only evaluate to true if the pointers point to the same object in memory. .Equals dereferences the pointers and compares the values stored at the pointers. \na.Equals(b) would be true here.and if you change b to:then a.Equals(b) is false, butwould be truea.CompareTo(b) calls the string\'s CompareTo function which compares the values at the pointers and returns <0 if the value stored at a is less than the value stored at b, returns 0 if a.Equals(b) is true, and >0 otherwise. However, this is case sensitive, I think there are possibly options for CompareTo to ignore case and such, but don\'t have time to look now. \nAs others have already stated, this would be done for sorting. Comparing for equality in this manner would result in unecessary overhead.I\'m sure I\'m leaving stuff out, but I think this should be enough info to start experimenting if you need more details.