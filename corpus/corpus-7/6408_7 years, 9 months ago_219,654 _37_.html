I have a table with a primary key that is a varchar(255). Some cases have arisen where 255 characters isn\'t enough. I tried changing the field to a text, but I get the following error:how can I fix this?edit: I should also point out this table has a composite primary key with multiple columns.The error happens because MySQL can index only the first N chars of a BLOB or TEXT column. So The error mainly happen when there is a field/column type of TEXT or BLOB or those belongs to TEXT or BLOB types such as TINYBLOB, MEDIUMBLOB, LONGBLOB, TINYTEXT, MEDIUMTEXT, and LONGTEXT that you try to make as primary key or index. With full BLOB or TEXT without the length value, MySQL is unable to guarantee the uniqueness of the column as it\xe2\x80\x99s of variable and dynamic size. So, when using BLOB or TEXT types as index, the value of N must be supplied so that MySQL can determine the key length. However, MySQL doesn\xe2\x80\x99t support a key length limit on TEXT or BLOB. TEXT(88) simply won\xe2\x80\x99t work.The error will also pop up when you try to convert a table column from non-TEXT and non-BLOB type such as VARCHAR and ENUM into TEXT or BLOB type, with the column already been defined as unique constraints or index. The Alter Table SQL command will fail.The solution to the problem is to remove the TEXT or BLOB column from the index or unique constraint, or set another field as primary key. If you can\xe2\x80\x99t do that, and wanting to place a limit on the TEXT or BLOB column, try to use VARCHAR type and place a limit of length on it. By default, VARCHAR is limited to a maximum of 255 characters and its limit must be specified implicitly within a bracket right after its declaration, i.e VARCHAR(200) will limit it to 200 characters long only.Sometimes, even though you don\xe2\x80\x99t use TEXT or BLOB related type in your table, the Error 1170 may also appear. It happens in situation such as when you specify VARCHAR column as primary key, but wrongly set its length or characters size. VARCHAR can only accepts up to 256 characters, so anything such as VARCHAR(512) will force MySQL to auto-convert the VARCHAR(512) to a SMALLTEXT datatype, which subsequently fail with error 1170 on key length if the column is used as primary key or unique or non-unique index. To solve this problem, specify a figure less than 256 as the size for VARCHAR field.Reference: MySQL Error 1170 (42000): BLOB/TEXT Column Used in Key Specification Without a Key LengthYou should define which leading portion of a TEXT column you want to index.InnoDB has a limitation of 768 bytes per index key and you won\'t be able to create an index longer than that.This will work fine:Note that the maximum value of the key size depends on the column charset. It\'s 767 characters for a single-byte charset like LATIN1 and only 255 characters for UTF8 (MySQL only uses BMP which requires at most 3 bytes per character)If you need your whole column to be the PRIMARY KEY, calculate SHA1 or MD5 hash and use it as a PRIMARY KEY.You can specify the key length in the alter table request, something like:MySQL disallows indexing a full value of BLOB, TEXT and long VARCHAR columns because data they contain can be huge, and implicitly DB index will be big, meaning no benefit from index.MySQL requires that you define first N characters to be indexed, and the trick is to choose a number N that\xe2\x80\x99s long enough to give good selectivity, but short enough to save space. The prefix should be long enough to make the index nearly as useful as it would be if you\xe2\x80\x99d indexed the whole column.Before we go further let us define some important terms. Index selectivity is ratio of the total distinct indexed values and total number of rows. Here is one example for test table:If we index only the first character (N=1), then index table will look like the following table:In this case, index selectivity is equal to IS=1/3 = 0.33.Let us now see what will happen if we increase number of indexed characters to two (N=2).In this scenario IS=2/3=0.66 which means we increased index selectivity, but we have also increased the size of index. Trick is to find the minimal number N which will result to maximal index selectivity. There are two approaches you can do calculations for your database table. I will make demonstration on the this database dump.Let\'s say we want to add column last_name in table employees to the index, and we want to define the smallest number N which will produce the best index selectivity.First let us identify the most frequent last names:As you can see, the last name Baba is the most frequent one. Now we are going to find the most frequently occurring last_name prefixes, beginning with five-letter prefixes.There are much more occurrences of every prefix, which means we have to increase number N until the values are almost the same as in the previous example.Here are results for N=9Here are results for N=10.This are very good results. This means that we can make index on column last_name with indexing only first 10 characters. In table definition column last_name is defined as VARCHAR(16), and this means we have saved 6 bytes (or more if there are UTF8 characters in the last name) per entry. In this table there are 1637 distinct values multiplied by 6 bytes is about 9KB, and imagine how this number would grow if our table contains million of rows.You can read other ways of calculating number of N in my post Prefixed indexes in MySQL.NOTE : 767 is the number of characters limit upto which MySQL will index columns while dealing with blob/text indexesRef : http://dev.mysql.com/doc/refman/5.7/en/innodb-restrictions.htmlDon\'t have long values as primary key. That will destroy your performance. See the mysql manual, section 13.6.13 \'InnoDB Performance Tuning and Troubleshooting\'.Instead, have a surrogate int key as primary (with auto_increment), and your loong key as a secondary UNIQUE.Add another varChar(255) column (with default as empty string not null) to hold the overflow when 255 chars are not enough, and change this PK to use both columns. This does not sound like a well designed database schema however, and I would recommend getting a data modeler to look at what you have with a view towards refactoring it for more Normalization.Another excellent way of dealing with this is to create your TEXT field without the unique constraint and add a sibling VARCHAR field that is unique and contains a digest (MD5, SHA1, etc.) of the TEXT field.  Calculate and store the digest over the entire TEXT field when you insert or update the TEXT field then you have a uniqueness constraint over the entire TEXT field (rather than some leading portion) that can be searched quickly.Also, if you want to use index in this field, you should use the MyISAM storage engine and the FULLTEXT index type.