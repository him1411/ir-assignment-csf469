I read the C++ version of this question but didn\'t really understand it.Can someone please explain clearly if it can be done and how?Use .NET 4.0+\'s Tuple:For Example:You cannot do this in C#. What you can do is have a out parameter or return your own class (or struct if you want it to be immutable).You can use three different ways1. ref / out parametersusing ref:using out:2. struct / classusing struct:using class:3. TupleNow that C# 7 has released, you can use the included new Tuples syntaxwhich could then be used like this:You can also provide names to your elements (so they are not "Item1", "Item2" etc). You can do it by adding a name to the signature or the return methods:or They can also be deconstructed, which is a pretty nice new feature:Check out this link to see more examples on what can be done :)If you mean returning multiple values, you can either return a class/struct containing the values you want to return, or use the "out" keyword on your parameters, like so:Previous poster is right. You cannot return multiple values from a C# method. However, you do have a couple of options:The pros and cons here are often hard to figure out. If you return a structure, make sure it\'s small because structs are value type and passed on the stack. If you return an instance of a class, there are some design patterns here that you might want to use to avoid causing problems - members of classes can be modified because C# passes objects by reference (you don\'t have ByVal like you did in VB).Finally you can use output parameters but I would limit the use of this to scenarios when you only have a couple (like 3 or less) of parameters - otherwise things get ugly and hard to maintain. Also, the use of output parameters can be an inhibitor to agility because your method signature will have to change every time you need to add something to the return value whereas returning a struct or class instance you can add members without modifying the method signature.From an architectural standpoint I would recommend against using key-value pairs or dictionaries. I find this style of coding requires "secret knowledge" in code that consumes the method. It must know ahead of time what the keys are going to be and what the values mean and if the developer working on the internal implementation changes the way the dictionary or KVP is created, it could easily create a failure cascade throughout the entire application.You either return a class instance our use out parameters. Here\'s an example of out parameters:Call it like this:There are several ways to do this.  You can use ref parameters:This passes a reference to the function thereby allowing the function to modify the object in the calling code\'s stack.  While this is not technically a "returned" value it is a way to have a function do something similar.  In the code above the function would return an int and (potentially) modify bar.Another similar approach is to use an out parameter.  An out parameter is identical to a ref parameter with an additional, compiler enforced rule.  This rule is that if you pass an out parameter into a function, that function is required to set its value prior to returning.  Besides that rule, an out parameter works just like a ref parameter.  The final approach (and the best in most cases) is to create a type that encapsulates both values and allow the function to return that:This final approach is simpler and easier to read and understand.In C# 4, you will be able to use built-in support for tuples to handle this easily.In the meantime, there are two options.First, you can use ref or out parameters to assign values to your parameters, which get passed back to the calling routine.This looks like:Second, you can wrap up your return values into a structure or class, and pass them back as members of that structure.  KeyValuePair works well for 2 - for more than 2 you would need a custom class or struct.No, you can\'t return multiple values from a function in C# (for versions lower than C# 7), at least not in the way you can do it in Python.However, there are a couple alternatives:You can return an array of type object with the multiple values you want in it.You can use out parameters.you can try this "KeyValuePair"Output :Output : 1, 2Mainly two methods are there.\n1. Use out/ref parameters\n2. Return an Array of objectsClasses, Structures, Collections and Arrays can contain multiple values. Output and reference parameters can also be set in a function. Return multiple values is possible in dynamic and functional languages by means of tuples, but not in C#.Some of these answers stated that use out parameter but I recommend\n  not using this due to they don\xe2\x80\x99t work with async methods. See\n  this for more information.Other answers stated using Tuple, which I would recommend too but using the new feature introduced in C# 7.0.Further information can be found here.In C#7 There is a new Tuple syntax:You can return this as a record:You can also use the new deconstructor syntax:Be careful with serialisation however, all this is syntactic sugar - in the actual compiled code this will be a Tupel<string, int> (as per the accepted answer) with Item1 and Item2 instead of foo and bar. That means that serialisation (or deserialisation) will use those property names instead.So, for serialisation declare a record class and return that instead.Also new in C#7 is an improved syntax for out parameters. You can now declare the out inline, which is better suited in some contexts:However, mostly you\'ll use this in .NET\'s own libraries, rather than in you own functions. Here are basic Two methods:1) Use of \'out\' as parameter\nYou can use \'out\' for both 4.0 and minor versions too.Example of \'out\':Output:Area of Rectangle is 20Perimeter of Rectangle is 18 *Note:*The out-keyword describes parameters whose actual variable locations are copied onto the stack of the called method, where those same locations can be rewritten. This means that the calling method will access the changed parameter.2) Tuple<T> Example of Tuple:Returning Multiple DataType values using Tuple<T>OutputNOTE: Use of Tuple is valid from Framework 4.0 and above.Tuple type is a class. It will be allocated in a separate location on the managed heap in memory. Once you create the Tuple, you cannot change the values of its fields. This makes the Tuple more like a struct.A method taking a delegate can provide multiple values to the caller.  This borrows from my answer here and uses a little bit from Hadas\'s accepted answer.Callers provide a lambda (or a named function) and intellisense helps by copying the variable names from the delegate.Just use in OOP manner a class like this:The function member returns the quotient which most callers are primarily interested in. Additionally it stores the remainder as a data member, which is easily accessible by the caller afterwards.This way you can have many additional "return values", very useful if you implement database or networking calls, where lots of error messages may be needed but only in case an error occurs.I entered this solution also in the C++ question that OP is referring to.From this article, you can use three options as posts above said.KeyValuePair is quickest way.out is at the second.Tuple is the slowest.Anyway, this is depend on what is the best for your scenario. You could use a dynamic object. I think it has better readability than Tuple.Future version of C# is going to include named tuples.\nHave a look at this channel9 session for the demo\nhttps://channel9.msdn.com/Events/Build/2016/B889Skip to 13:00 for the tuple stuff. This will allow stuff like:(incomplete example from video)you can try this Ways to do it:1) KeyValuePair (Best Performance - 0.32 ns):2) Tuple - 5.40 ns:3) out (1.64 ns) or ref\n4) Create your own custom class/structns -> nanosecondsReference: multiple-return-values.You can also use an OperationResult