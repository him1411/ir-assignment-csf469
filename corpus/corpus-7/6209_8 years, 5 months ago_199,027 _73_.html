This is a little subjective I think; I\'m not sure if the opinion will be unanimous (I\'ve seen a lot of code snippets where references are returned).According to a comment toward this question I just asked, regarding initializing references, returning a reference can be evil because, [as I understand] it makes it easier to miss deleting it, which can lead to memory leaks.This worries me, as I have followed examples (unless I\'m imagining things) and done this in a fair few places... Have I misunderstood? Is it evil? If so, just how evil?I feel that because of my mixed bag of pointers and references, combined with the fact that I\'m new to C++, and total confusion over what to use when, my applications must be memory leak hell...Also, I understand that using smart/shared pointers is generally accepted as the best way to avoid memory leaks.In general, returning a reference is perfectly normal and happens all the time.If you mean:That is all sorts of evil. The stack-allocated i will go away and you are referring to nothing. This is also evil:Because now the client has to eventually do the strange:Note that rvalue references are still just references, so all the evil applications remain the same.If you want to allocate something that lives beyond the scope of the function, use a smart pointer (or in general, a container):And now the client stores a smart pointer:References are also okay for accessing things where you know the lifetime is being kept open on a higher-level, e.g.:Here we know it\'s okay to return a reference to i_ because whatever is calling us manages the lifetime of the class instance, so i_ will live at least that long.And of course, there\'s nothing wrong with just:If the lifetime should be left up to the caller, and you\'re just computing the value.Summary: it\'s okay to return a reference if the lifetime of the object won\'t end after the call.No.  No, no, a thousand times no.What is evil is making a reference to a dynamically allocated object and losing the original pointer.  When you new an object you assume an obligation to have a guaranteed delete.But have a look at, eg, operator<<: that must return a reference, or won\'t work.You should return a reference to an existing object that isn\'t going away immediately, and where you don\'t intend any transfer of ownership.Never return a reference to a local variable or some such, because it won\'t be there to be referenced.You can return a reference to something independent of the function, which you don\'t expect the calling function to take the responsibility for deleting.  This is the case for the typical operator[] function.If you are creating something, you should return either a value or a pointer (regular or smart).  You can return a value freely, since it\'s going into a variable or expression in the calling function.  Never return a pointer to a local variable, since it will go away.It\'s not evil. Like many things in C++, it\'s good if used correctly, but there are many pitfalls you should be aware of when using it (like returning a reference to a local variable).There are good things that can be achieved with it (like map[name] = "hello world")"returning a reference is evil because,\n  simply [as I understand] it makes it\n  easier to miss deleting it"Not true.  Returning a reference does not imply ownership semantics.  That is, just because you do this:...does not mean you now own the memory referred to by v;However, this is horrible code:If you are doing something like this because "you don\'t require a pointer on that instance" then: 1) just dereference the pointer if you need a reference, and 2) you will eventually need the pointer, because you have to match a new with a delete, and you need a pointer to call delete.I find the answers not satisfactory so I\'ll add my two cents.Let\'s analyze the following cases:This is obviously errorThis is right, because static variables are existant throughout lifetime of a program.This is also quite common when implementing Singleton patternUsage:Standard library containers depend heavily upon usage of operators which return reference, for examplemay be used in the followingThere are times when & may be used for quick access to internal datawith usage:HOWEVER, this may lead to pitfall such as this:There are two cases:const reference --good idea, sometimes, especially for heavy objects or proxy classes, compiler optimization non-const reference --bad idea, sometimes, breaks encapsulationsBoth share same issue -- can potentially point to destroyed object... I would recommend using smart pointers for many situations where you require to return a reference/pointer.Also,  note the following:There is a formal rule - the C++ Standard (section 13.3.3.1.4 if you are interested) states that a temporary can only be bound to a const reference - if you try to use a non-const reference the compiler must flag this as an error.Not only is it not evil, it is sometimes essential. For example, it would be impossible to implement the [] operator of std::vector without using a reference return value.return reference is usually used in operator overloading in C++ for large Object, because returning a value need copy operation.(in perator overloading, we usually don\'t use pointer as return value)But return reference may cause memory allocation problem. Because a reference to the result will be passed out of the function as a reference to the return value, the return value cannot be an automatic variable.if you want use returning refernce, you may use a buffer of static object.\nfor examplein this way, you could use returning reference safely.But you could always use pointer instead of reference for returning value in functiong. Addition to the accepted answer:I\'d argue that this example is not okay and should be avoided if possible. Why? It is very easy to end-up with a dangling reference. To illustrate the point with an example:entering the danger-zone:i think using reference as the return value of the function is much more straight forward than using pointer as the return value of the function. \nSecondly It would be always safe to use static variable to which the return value refer to. Best thing is to create object and pass it as reference/pointer parameter to a function which allocates this variable. Allocating object in function and returning it as a reference or pointer (pointer is safer however) is bad idea because of freeing memory at the end of function block. Function as lvalue (aka, returning of non-const references) should be removed from C++.  It\'s terribly unintuitive.  Scott Meyers wanted a min() with this behavior.which isn\'t really an improvement onThe latter even makes more sense.I realize that function as lvalue is important for C++ style streams, but it\'s worth pointing out that C++ style streams are terrible.  I\'m not the only one that thinks this... as I recall Alexandrescu had a large article on how to do better, and I believe boost has also tried to create a better type safe I/O method.getPtr function can access dynamic memory after deletion or even a null object. Which can cause Bad Access Exceptions. Instead getter and setter should be implemented and size verified before returning. I ran into a real problem where it was indeed evil. Essentially a developer returned a reference to an object in a vector. That was Bad!!!The full details I wrote about in Janurary: http://developer-resource.blogspot.com/2009/01/pros-and-cons-of-returing-references.htmlAbout horrible code:So, indeed, memory pointer lost after return. But if you use shared_ptr like that:Memory not lost after return and will be freed after assignment.