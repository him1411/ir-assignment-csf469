What happens (behind the curtains) when this is executed?That is, when a variable is post incremented and assigned to itself in one statement? I compiled and executed this. x is still 7 even after the entire statement. In my book, it says that x is incremented!x does get incremented. But you are assigning the old value of x back into itself.x++ increments x and returns its old value. x = assigns the old value back to itself.So in the end, x gets assigned back to its initial value.is equivalent toThe statement:is equivalent to:In short, the statement has no effect.The key points: The value of a Postfix increment/decrement expression is the value of the operand before the increment/decrement takes place.  (In the case of a Prefix form, the value is the value of the operand after the operation,)the RHS of an assignment expression is completely evaluated (including any increments, decrements and/or other side-effects) before the value is assigned to the LHS.Note that unlike C and C++, the order of evaluation of an expression in Java is totally specified and there is no room for platform-specific variation.  Compilers are only allowed to reorder the operations if this does not change the result of executing the code from the perspective of the current thread.  In this case, a compiler would be permitted to optimize away the entire statement because it can be proved that it is a no-op.In case it is not already obvious:Hopefully, code checkers like FindBugs and PMD will flag code like this as suspicious.It has undefined behaviour in C and for Java see this answer. It depends on compiler what happens.A construct like x = x++; indicates you\'re probably misunderstanding what the ++ operator does:Let\'s rewrite this to do the same thing, based on removing the ++ operator:Now, let\'s rewrite it to do (what I think) you wanted:The subtlety here is that the ++ operator modifies the variable x, unlike an expression such as x + x, which would evaluate to an int value but leave the variable x itself unchanged. Consider a construct like the venerable for loop:Notice the i++ in there? It\'s the same operator. We could rewrite this for loop like this and it would behave the same:I also recommend against using the ++ operator in larger expressions in most cases. Because of the subtlety of when it modifies the original variable in pre- versus post-increment (++x and x++, respectively), it is very easy to introduce subtle bugs that are difficult to track down.It\'s incremented after "x = x++;". It would be 8 if you did "x = ++x;".According to Byte code obtained from the class files,Both assignments increment x, but difference is the timing of when the value is pushed onto the stackIn Case1,  Push occurs  (and then later assigned) before the increment (essentially meaning your increment does nothing)In Case2, Increment occurs first (making it 8) and then pushed onto the stack(and then assigned to x)Case 1:Byte Code: Case 2:Byte CodeThe incrementing occurs after x is called, so x still equals 7.  ++x would equal 8 when x is calledWhen you re-assign the value for x it is still 7. Try x = ++x and you will get 8 else dobecause x++ increments the value AFTER assigning it to the variable.\nso on and during the execution of this line:the varialbe x will still have the original value (7), but using x again on another line, such aswill give you 8.if you want to use an incremented value of x on your assignment statement, useThis will increment x by 1, THEN assign that value to the variable x.[Edit]\ninstead of x = x++, it\'s just x++; the former assigns the original value of x to itself, so it actually does nothing on that line.What happens when int x = 7; x = x++;?ans ->  x++ means  first use value of x for expression and then increase it by 1.\nThis is what happens in your case.  The value of x on RHS is copied to variable x on LHS and then value of x is increased by 1.  Similarly ++x  means  -> increase the value of x first by one and then  use in expression .\nSo in your case  if you do  x = ++x ; // where x = 7\n you will get value of 8.   For more clarity try to find out how many printf statement will execute the following code   ++x is pre-increment  -> x is incremented before being used \nx++ is post-increment -> x is incremented after being used Post Increment operator works as follows:So the statementwould be evaluated as follows:So x is indeed increased but since x++ is assigning result back to x so value of x is overridden to its previous value.So this means:\nx++ is not equal to x = x+1 because:and now it seems a bit strange:very compiler dependent!I think this controversy can be resolved without going into code & just thinking.Consider i++ & ++i as functions say Fun1 & Fun2.If i=7;\ni++ function(Fun1) returns 7,  ++i function(Fun2) returns 8 (this everybody knows). Internally both the functions increment i to 8 , but they return different values.So i = i++ calls the function Fun1. Inside the function i increments to 8, but on completion the function returns 7.So ultimately 7 gets allocated to i.  (So in the end i=7; is executed)x = x++; This is the post-increment operator. It should be understood as "Use the operand\'s value and then increment the operand". If you want the reverse to happen i.e "Increment the operand and then use the operand\'s value", you must use the pre-increment operator as shown below.x = ++x;This operator first increments the value of x by 1 and then assigns the value back to x.