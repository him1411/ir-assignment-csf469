What is the best way to use the values stored in an Enum as String literals?\nFor example:Then later I could use Mode.mode1 to return its string representation as mode1. Without having to keep calling Mode.model.toString().You can\'t. I think you have FOUR options here. All four offer a solution but with a slightly different approach...Option One: use the built-in name() on an enumOption Two: add overriding properties to your enums if you want more controlOption Three: use static finals instead of enums: Option Four: interfaces have every field public, static and final:Every enum has both a name() and a valueOf(String) method. The former returns the string name of the enum, and the latter gives the enum value whose name is the string. Is this like what you\'re looking for?There\'s also a static valueOf(Class, String) on Enum itself, so you could also useYou could override the toString() method for each enum value.Example:Usage:mode1.name() or String.valueOf(mode1). It doesn\'t get better than that, I\'m afraidAs Benny Neugebauer mentions, you could overwrite the toString(). However instead overwriting the toString for each enum field I like more something like this:You could also add a static method to retrieve all the fields, to print them all, etc.\nSimply call getValue to obtain the string associated to each Enum itemyou can call like below whereever you want to get value as string from enum.This will return "Mode1" as String.You can use Mode.mode1.name() however you often don\'t need to do this.As far as I know, the only way to get the name would beIf you really need it this way, however, you could do:You can simply use:Enum is just a little bit special class. Enums can store additional fields, implement methods etc. For exampleNow you can say:System.out.println(Modes.mode1.character())and see output: \namy solution for your problem!For my enums I don\'t really like to think of them being allocated with 1 String each.  This is how I implement a toString() method on enums.after many tries I have come with this solutionIt is an easy way without creating interface, class or getter settersThis method should work with any enum:So just to build on some of the above answers.. A lot of times i\'ll use enumerators to represent "types" of things obviously, but then those types also have additional attributes, like an int ID and a string Description. The below solution works well for me to give an enumerator a bit more usefulness for me....and i\'m new to Java btw.. so if there\'s issues with this i\'d love to knowI\'m supprised that non of those anwsers consider Enum with an Attribute. Enum will be easy to readable for a programmer, and Attribute can contain a full name, or "pointer" to translation. That way you can repeat names between enums, and you have no warries for uniquness of string in attribute since they can be very long.Usage: