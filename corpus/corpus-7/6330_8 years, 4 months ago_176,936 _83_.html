Can anyone please give me a good understanding of whats the difference between run-time and compile-time? The difference between compile time and run time is an example of what pointy-headed theorists call the phase distinction.  It is one of the hardest concepts to learn, especially for people without much background in programming languages.  To approach this problem, I find it helpful to askWhat can go wrong are run-time errors:Also there can be errors that are detected by the program itself:I think of it in terms of errors, and when they can be caught.Compile time:A string value can\'t be assigned a variable of type int, so the compiler knows for sure at compile time that this code has a problemRun time:Here the outcome depends on what string was returned by ReadLine(). Some values can be parsed to an int, others can\'t. This can only be determined at run timeCompile-time: the time period in which you, the developer, are compiling your code.Run-time: the time period which a user is running your piece of software.Do you need any clearer definition?(edit: the following applies to C# and similar, strongly-typed programming languages. I\'m not sure if this helps you).For example, the following error will be detected by the compiler (at compile time) before you run a program and will result in a compilation error:On the other hand, an error like the following can not be detected by the compiler. You will receive an error/exception at run-time (when the program is run).Translation of source code into stuff-happening-on-the-[screen|disk|network] can occur in (roughly) two ways; call them compiling and interpreting.In a compiled program (examples are c and fortran):Things that happen in the first step are said to happen at "compile time", things that happen in the second step are said to happen at "run time".In an interpreted program (example MicroSoft basic (on dos) and python (I think)):In this case the difference between compile time and run time is rather harder to pin down, and much less relevant to the programmer or user.Java is a sort of hybrid, where the code is compiled to bytecode, which then runs on a virtual machine which is usually an interpreter for the bytecode.There is also an intermediate case in which the program is compiled to bytecode and run immediately (as in awk or perl).Basically if your compiler can work out what you mean or what a value is "at compile time" it can hardcode this into the runtime code.  Obviously if your runtime code has to do a calculation every time it will run slower, so if you can determine something at compile time it is much better.Eg.Constant folding:If I write:The compiler can perform this calulation at compile time because it knows what 2 is, and what MY_CONSTANT is.  As such it saves itself from performing a calculation every single execution.Following from previous similar answer of question What is the difference between run-time error and compiler error? Compilation/Compile time/Syntax/Semantic errors: Compilation or compile time errors are error occurred due to typing mistake, if we do not follow the proper syntax and semantics of any programming language then compile time errors are thrown by the compiler. They wont let your program to execute a single line until you remove all the syntax errors or until you debug the compile time errors.\nExample: Missing a semicolon in C or mistyping int as Int.Runtime errors: Runtime errors are the errors that are generated when the program is in running state. These types of errors will cause your program to behave unexpectedly or may even kill your program. They are often referred as Exceptions.\nExample: Suppose you are reading a file that doesn\'t exist, will result in a runtime error.   Read more about all programming errors hereThings that are done at compile time incur (almost) no cost when the resulting program is run, but might incur a large cost when you build the program.More or less the exact opposite. Little cost when you build, more cost when the program is run.From the other side; If something is done at compile time, it runs only on your machine and if something is run-time, it run on your users machine.An example of where this is important would be a unit carrying type. A compile time version (like Boost.Units or my version in D) ends up being just as fast as solving the problem with native floating point code while a run-time version ends up having to pack around information about the units that a value are in and perform checks in them along side every operation. On the other hand, the compile time versions requiter that the units of the values be known at compile time and can\'t deal with the case where they come from run-time input.Hmm, ok well, runtime is used to describe something that occurs when a program is running.Compile time is used to describe something that occurs when a program is being built (usually, by a compiler).For example: In a strongly typed language, a type could be checked at compile time or at runtime. At compile time it means, that the compiler complains if the types are not compatible. At runtime means, that you can compile your program just fine but at runtime, it throws an exception.compile time:Developer writes the program in .java format & converts in to the Bytecode which is a class file,during this compilation any error occurs can be defined as compile time error.Run time:The generated .class file is use by the application for its additional functionality & the logic turns out be wrong and throws an error which is a run time errorCompile Time:Things that are done at compile time incur (almost) no cost when the resulting program is run, but might incur a large cost when you build the program.\nRun-Time:More or less the exact opposite. Little cost when you build, more cost when the program is run.From the other side; If something is done at compile time, it runs only on your machine and if something is run-time, it run on your users machine.Here is a quote from Daniel Liang, author of \'Introduction to JAVA programming\', on the subject of compilation: "A program written in a high-level language is called a source program or source code. Because a computer cannot execute a source program, a source program must be translated into machine code for execution. The translation can be done using another programming tool called an interpreter or a compiler." (Daniel Liang, "Introduction to JAVA programming", p8). ...He Continues..."A compiler translates the entire source code into a machine-code file, and the machine-code file is then executed"When we punch in high-level/human-readable code this is, at first, useless! It must be translated into a sequence of \'electronic happenings\' in your tiny little CPU! The first step towards this is compilation. Simply put: a compile-time error happens during this phase, while a run-time error occurs later. Remember: Just because a program is compiled without error does not mean it will run without error.A Run-time error will occur in the ready, running or waiting part of a programs life-cycle while a compile-time error will occur prior to the \'New\' stage of the life cycle. Example of a Compile-time error: A Syntax Error - how can your code be compiled into machine level instructions if they are ambiguous?? Your code needs to conform 100% to the syntactical rules of the language otherwise it cannot be compiled into working machine code. Example of a run-time error:Running out of memory - A call to a recursive function for example might lead to stack overflow given a variable of a particular degree! How can this be anticipated by the compiler!? it cannot. And that is the difference between a compile-time error and a run-time errorHere is an extension to the Answer to the question "difference between run-time and compile-time?" -- Differences in overheads associated with run-time and compile-time? The run-time performance of the product contributes to its quality by delivering results faster. The compile-time performance of the product contributes to its timeliness by shortening the edit-compile-debug cycle. However, both run-time performance and compile-time performance are secondary factors in achieving timely quality. Therefore, one should consider run-time and compile-time performance improvements only when justified by improvements in overall product quality and timeliness.A great source for further reading here:we can classify these under different two broad groups static binding and dynamic binding. It is based on when the binding is done with the corresponding values. If the references are resolved at compile time, then it is static binding and if the references are resolved at runtime then it is dynamic binding. Static binding and dynamic binding also called as early binding and late binding. Sometimes they are also referred as static polymorphism and dynamic polymorphism.Joseph Kulandai\xe2\x80\x8f.Run time means something happens when you run the program.Compile time means something happens when you compile the program.I have always thought of it relative to program processing overhead and how it affects preformance as previously stated. A simple example would be, either defining the absolute memory required for my object in code or not. A defined boolean takes x memory this is then in the compiled program and cannot be changed. When the program runs it knows exactly how much memory to allocate for x. On the other hand if I just define a generic object type (i.e. kind of a undefined place holder or maybe a pointer to some giant blob) the actual memory required for my object is not known until the program is run and I assign something to it, thus it then must be evaluated and memory allocation, etc. will be then handled dynamically at run time (more run time overhead). How it is dynamically handled would then depend on the language, the compiler, the OS, your code, etc.On that note however it would really depends on the context in which you are using run time vs compile time.The major difference between run-time and compile time is:int a = 1 \nint b = a/0;here first line doesn\'t have a semi-colon at the end---> compile time error after executing the program while performing operation b, result is infinite---> run-time error.here\'s a very simple answer:Runtime and compile time are programming terms that refer to different stages of software program development.\nIn order to create a program, a developer first writes source code, which defines how the program will function. Small programs may only contain a few hundred lines of source code, while large programs may contain hundreds of thousands of lines of source code. The source code must be compiled into machine code in order to become and executable program. This compilation process is referred to as compile time.(think of a compiler as a translator)A compiled program can be opened and run by a user. When an application is running, it is called runtime.The terms "runtime" and "compile time" are often used by programmers to refer to different types of errors. A compile time error is a problem such as a syntax error or missing file reference that prevents the program from successfully compiling. The compiler produces compile time errors and usually indicates what line of the source code is causing the problem.If a program\'s source code has already been compiled into an executable program, it may still have bugs that occur while the program is running. Examples include features that don\'t work, unexpected program behavior, or program crashes. These types of problems are called runtime errors since they occur at runtime.The reference It\'s not a good question for S.O. (it\'s not a specific programming question), but it\'s not a bad question in general.If you think it\'s trivial: what about read-time vs compile-time, and when is this a useful distinction to make?  What about languages where the compiler is available at runtime?  Guy Steele (no dummy, he) wrote 7 pages in CLTL2 about EVAL-WHEN, which CL programmers can use to control this.  2 sentences are barely enough for a definition, which itself is far short of an explanation.In general, it\'s a tough problem that language designers have seemed to try to avoid.\nThey often just say "here\'s a compiler, it does compile-time things; everything after that is run-time, have fun".  C is designed to be simple to implement, not the most flexible environment for computation.  When you don\'t have the compiler available at runtime, or the ability to easily control when an expression is evaluated, you tend to end up with hacks in the language to fake common uses of macros, or users come up with Design Patterns to simulate having more powerful constructs.  A simple-to-implement language can definitely be a worthwhile goal, but that doesn\'t mean it\'s the end-all-be-all of programming language design.  (I don\'t use EVAL-WHEN much, but I can\'t imagine life without it.)And the problemspace around compile-time and run-time is huge and still largely unexplored.  That\'s not to say S.O. is the right place to have the discussion, but I encourage people to explore this territory further, especially those who have no preconceived notions of what it should be.  The question is neither simple nor silly, and we could at least point the inquisitor in the right direction.Unfortunately, I don\'t know any good references on this.  CLTL2 talks about it a bit, but it\'s not great for learning about it.