When trying to convert a JPA object that has a bi-directional association into JSON, I keep getting All I found is this thread which basically concludes with recommending to avoid bi-directional associations. Does anyone have an idea for  a workaround for this spring bug?------ EDIT 2010-07-24 16:26:22 -------Codesnippets:Business Object 1:Business Object 2:Controller:JPA-implementation of the trainee DAO:persistence.xmlYou may use @JsonIgnore to break the cycle.Since Jackson 1.6 you can use two annotations to solve the infinite recursion problem without ignoring the getters/setters during serialization: @JsonManagedReference and @JsonBackReference.ExplanationFor Jackson to work well, one of the two sides of the relationship should not be serialized, in order to avoid the infite loop that causes your stackoverflow error.So, Jackson takes the forward part of the reference (your Set<BodyStat> bodyStats in Trainee class), and converts it in a json-like storage format; this is the so-called marshalling process. Then, Jackson looks for the back part of the reference (i.e. Trainee trainee in BodyStat class) and leaves it as it is, not serializing it. This part of the relationship will be re-constructed during the deserialization (unmarshalling) of the forward reference.You can change your code like this (I skip the useless parts):Business Object 1:Business Object 2:Now it all should work properly.If you want more informations, I wrote an article about Json and Jackson Stackoverflow issues on Keenformatics, my blog.EDIT: Another useful annotation you could check is @JsonIdentityInfo: using it, everytime Jackson serializes your object, it will add an ID (or another attribute of your choose) to it, so that it won\'t entirely "scan" it again everytime. This can be useful when you\'ve got a chain loop between more interrelated objects (for example: Order -> OrderLine -> User -> Order and over again).In this case you\'ve got to be careful, since you could need to read your object\'s attributes more than once (for example in a products list with more products that share the same seller), and this annotation prevents you to do so. I suggest to always take a look at firebug logs to check the Json response and see what\'s going on in your code.Sources:Also, using Jackson 2.0+ you can use @JsonIdentityInfo.  This worked much better for my hibernate classes than @JsonBackReference and @JsonManagedReference, which had problems for me and did not solve the issue.  Just add something like:and it should work.the new annotation @JsonIgnoreProperties reslove all problems     check this  it works just like I need \ndocumentation:\nhttp://springquay.blogspot.com/2016/01/new-approach-to-solve-json-recursive.htmlAlso, Jackson 1.6 has support for handling bi-directional references... which seems like \nwhat you are looking for (this blog entry also mentions the feature)And as of July 2011, there is also "jackson-module-hibernate" which might help in some aspects of dealing with Hibernate objects, although not necessarily this particular one (which does require annotations).Now Jackson supports avoiding cycles without ignoring the fields:Jackson - serialization of entities with birectional relationships (avoiding cycles)This worked perfectly fine for me. \nAdd the annotation @JsonIgnore on the child class where you mention the reference to the parent class. There\'s now a Jackson module (for Jackson 2) specifically designed to handle Hibernate lazy initialization problems when serializing.https://github.com/FasterXML/jackson-datatype-hibernateJust add the dependency (note there are different dependencies for Hibernate 3 and Hibernate 4):and then register the module when intializing Jackson\'s ObjectMapper:Documentation currently isn\'t great. See the Hibernate4Module code for available options.In my case it was enough to change relation from:to:another relation stayed as it was:you can use DTO pattern \ncreate class TraineeDTO without any anotation hiberbnate and you can use jackson mapper to convert Trainee to TraineeDTO and bingo the error message disapeare :)Be sure you use com.fasterxml.jackson everywhere. I spent much time to find it out.Then use @JsonManagedReference and @JsonBackReferenceAnd then you can json your model:For me the best solution is to use @JsonView and creating specific filters for the each scenario. You could also use @JsonManagedReference and @JsonBackReference, however it as hardcoded solution to only one situation, where the owner always reference the owning side, and never the opposite. If you have another serialization scenario where you need to re-annotate the attribute differently, you will not be able to.Lets use two classes, Company and Employee where you have a cyclic dependency between them:And the test class that tries to serialize using ObjectMapper (Spring Boot):If you run this code, you\'ll get the:@JsonView enables you to use filters and choose what fields should be included while serializing the objects. A filter is just a class reference used as a identifier. So let\'s first create the filters:Remember, the filters are dummy classes, just used for specifying the fields with the @JsonView annotation, so you can create as many as you want and need. Let\'s see it in action, but first we need to annotate our Company class:and change the Test in order for the serializer to use the View:Now if you run this code, the Infinite Recursion problem is solved, because you have explicitly said that you want just to serialize the attributes that were annotated with @JsonView(Filter.CompanyData.class).When it reaches the back reference for company in the Employee, it checks that it\'s not annotated and ignore the serialization. You also have a powerful and flexible solution to choose which data you want to send through your REST APIs.With Spring you can annotate your REST Controllers methods with the desired @JsonView filter and the serialization is applied transparently to the returning object.Here are the imports used in case you need to check:I had this problem, but I didn\'t want to use annotation in my entities, so I solved by creating a constructor for my class, this constructor must not have a reference back to the entities who references this entity. Let\'s say this scenario.If you try to send to the view the class B or A with @ResponseBody it may cause an infinite loop. You can write a constructor in your class and create a query with your entityManager like this.This is the class with the constructor.However, there are some constrictions about this solution, as you can see, in the constructor I did not make a reference to List bs this is because Hibernate does not allow it, at least in version 3.6.10.Final, so when I need to show both entities in a view I do the following.The other problem with this solution, is that if you add or remove a property you must update your constructor and all your queries.In case you are using Spring Data Rest, issue can be resolved by creating  Repositories for every Entity involved in cyclical references.