Is there a way to create a very basic HTTP server (supporting only GET/POST) in Java using just the Java SE API, without writing code to manually parse HTTP requests and manually format HTTP responses? The Java SE API nicely encapsulates the HTTP client functionality in HttpURLConnection, but is there an analog for HTTP server functionality?Just to be clear, the problem I have with a lot of ServerSocket examples I\'ve seen online is that they do their own request parsing/response formatting and error handling, which is tedious, error-prone, and not likely to be comprehensive, and I\'m trying to avoid it for those reasons.As an example of the manual HTTP manipulation that I\'m trying to avoid:http://java.sun.com/developer/technicalArticles/Networking/Webserver/WebServercode.htmlSince Java SE 6, there\'s a builtin HTTP server in Sun Oracle JRE. The com.sun.net.httpserver package summary outlines the involved classes and contains examples.Here\'s a kickoff example copypasted from their docs, you can just copy\'n\'paste\'n\'run it on Java 6+.Noted should be that the response.length() part in their example is bad, it should have been response.getBytes().length. Even then, the getBytes() method must explicitly specify the charset which you then specify in the response header. Alas, albeit misguiding to starters, it\'s after all just a basic kickoff example.Execute it and go to http://localhost:8000/test and you\'ll see the following response:This is the responseAs to using com.sun.* classes, do note that this is, in contrary to what some developers think, absolutely not forbidden by the well known FAQ Why Developers Should Not Write Programs That Call \'sun\' Packages. That FAQ concerns the sun.* package (such as sun.misc.BASE64Encoder) for internal usage by the Oracle JRE (which would thus kill your application when you run it on a different JRE), not the com.sun.* package. Sun/Oracle also just develop software on top of the Java SE API themselves like as every other company such as Apache and so on. Using com.sun.* classes is only discouraged (but not forbidden) when it concerns an implementation of a certain Java API, such as GlassFish (Java EE impl), Mojarra (JSF impl), Jersey (JAX-RS impl), etc.Check out NanoHttpd"NanoHTTPD is a light-weight HTTP server designed for embedding in other applications, released under a Modified BSD licence.It is being developed at Github and uses Apache Maven for builds & unit testing"The com.sun.net.httpserver solution is not portable across JREs. Its better to use the official webservices API in javax.xml.ws to bootstrap a minimal HTTP server...EDIT: this actually works! The above code looks like Groovy or something. Here is a translation to Java which I tested:Have a look at the "Jetty" web server Jetty. Superb piece of Open Source software that would seem to meet all your requirments.If you insist on rolling your own then have a look at the "httpMessage" class.I like this question because this is an area where there\'s continuous innovation and there\'s always a need to have a light server especially when talking about embedded servers in small(er) devices.  I think answers fall into two broad groups.While I might consider HTTP libraries like: Jetty, Apache Http Components, Netty and others to be more like  a raw HTTP processing facilities. The labelling is very subjective, and depends on the kinds of thing you\'ve been call-on to deliver for small-sites.  I make this distinction in the spirit of the question, particularly the remark about...These raw tools let you do that (as described in other answers).  They don\'t really lend themselves to a ready-set-go style of making a light, embedded or mini-server.  A mini-server is something that can give you similar functionality to a full-function web server (like say, Tomcat) without bells and whistles, low volume, good performance 99% of the time.  A thin-server seems closer to the original phrasing just a bit more than raw perhaps with a limited subset functionality, enough to make you look good 90% of the time.  My idea of raw would be makes me look good 75% - 89% of the time without extra design and coding.  I think if/when you reach the level of WAR files, we\'ve left the "small" for bonsi servers that looks like everything a big server does smaller.Thin-server optionsMini-server options:Among the other things to consider, I\'d include authentication, validation, internationalisation, using something like FreeMaker or other template tool to render page output.  Otherwise managing HTML editing and parameterisation is likely to make working with HTTP look like noughts-n-crosses.   Naturally it all depends on how flexible you need to be.  If it\'s a menu-driven FAX machine it can be very simple.  The more interactions, the \'thicker\' your framework needs to be. Good question, good luck!A very basic web server written in java can be found here\nhttp://library.sourcerabbit.com/v/?id=19Spark is the simplest, here is a quick start guide: http://sparkjava.com/Once upon a time I was looking for something similar - a lightweight yet fully functional HTTP server that I could easily embed and customize. I found two types of potential solutions:So... I set out to write JLHTTP - The Java Lightweight HTTP Server.You can embed it in any project as a single (if rather long) source file, or as a ~50K jar (~35K stripped) with no dependencies. It strives to be RFC-compliant and includes extensive documentation and many useful features while keeping bloat to a minimum.Features include: virtual hosts, file serving from disk, mime type mappings via standard mime.types file, directory index generation, welcome files, support for all HTTP methods, conditional ETags and If-* header support, chunked transfer encoding, gzip/deflate compression, basic HTTPS (as provided by the JVM), partial content (download continuation), multipart/form-data handling for file uploads, multiple context handlers via API or annotations, parameter parsing (query string or multipart/form-data body), etc.I hope others find it useful :-)I can strongly recommend looking into Simple, especially if you don\'t need Servlet capabilities but simply access to the request/reponse objects. If you need REST you can put Jersey on top of it, if you need to output HTML or similar there\'s Freemarker. I really love what you can do with this combination, and there is relatively little API to learn.It\'s possible to create an httpserver that provides basic support for J2EE servlets with just the JDK and the servlet api in a just a few lines of code.  I\'ve found this very useful for unit testing servlets, as it starts much faster than other lightweight containers (we use jetty for production). Most very lightweight httpservers do not provide support for servlets, but we need them, so I thought I\'d share.The below example provides basic servlet support, or throws and UnsupportedOperationException for stuff not yet implemented.  It uses the com.sun.net.httpserver.HttpServer for basic http support.You may also have a look at some NIO application framework such as: This code is better than ours, you only need to add 2 libs: javax.servelet.jar and org.mortbay.jetty.jar. Class Jetty:Servlet class:    checkout Simple. its a pretty simple embeddable server with built in support for quite a variety of operations. I particularly love its threading model..Amazing!Check out takes. Look at https://github.com/yegor256/takes for quick infoHow about Apache Commons HttpCore project? From the web site:...\nHttpCore GoalsYou can write a pretty simple embedded Jetty Java server.Embedded Jetty means that the server (Jetty) shipped together with the application as opposed of deploying the application on external Jetty server.So if in non-embedded approach your webapp built into WAR file which deployed to some external server (Tomcat / Jetty / etc), in embedded Jetty, you write the webapp and instantiate the jetty server in the same code base.An example for embedded Jetty Java server you can git clone and use: https://github.com/stas-slu/embedded-jetty-java-server-example