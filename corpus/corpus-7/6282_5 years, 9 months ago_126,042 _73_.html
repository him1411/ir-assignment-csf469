Can someone explain what isolation & propagation parameters are for in the @Transactional annotation via real world example. Basically when and why I should choose to change their default values. Good question, although not a trivial one to answer. PropagationDefines how transactions relate to each other. Common optionsIsolationDefines the data contract between transactions. The different levels have different performance characteristics in a multi threaded application. I think if you understand the dirty reads concept you will be able to select a good option. Example when a dirty read can occurSo a sane default (if such can be claimed) could be Read Comitted, which only lets you read values which have already been comitted by other running transactions, in combination with a propagation level of Required. Then you can work from there if you application has other needs. A practical example where a new transaction will always be created when entering the provideService routine and completed when leaving. Had we used Required instead the transaction will remain open if the transaction was already open when entering the routine. \nNote also that the result of a rollback could be different as several executions could take part in the same transaction. We can easily verify the behaviour with a test and see how results differ with propagation levelsWith a propagation level ofRequires new we would expect fooService.provideService() was NOT rolled back since it created it\'s own sub-transaction. Required we would expect everything was rolled back and backing store unchanged. PROPAGATION_REQUIRED = 0; If  DataSourceTransactionObject T1 is already started for Method M1.If for another  Method M2 Transaction object is required ,no new  Transaction object is created .Same object T1 is used for M2PROPAGATION_MANDATORY = 2; method must run within a transaction. If no \nexisting transaction is in progress, an exception will be thrownPROPAGATION_REQUIRES_NEW = 3; If  DataSourceTransactionObject T1 is already started for Method M1 and it is in progress(executing  method M1) .If another method M2 start executing then T1 is suspended for the duration of method M2 with new DataSourceTransactionObject T2 for M2.M2  run within its own transaction contextPROPAGATION_NOT_SUPPORTED = 4; If  DataSourceTransactionObject T1 is already started for Method M1.If another method M2 is run concurrently .Then M2 should not run within transaction context. T1 is suspended till M2 is finished.PROPAGATION_NEVER = 5; None of the methods  run in transaction context.An isolation level:\nIt is about  how much a transaction may be impacted by the activities of other concurrent\ntransactions.It a   supports consistency leaving the data across many tables in a consistent state.\nIt involves locking rows and/or tables in a database.The problem with multiple transactionScenario 1.If T1 transaction reads data from table A1 that was written by another concurrent transaction T2.If on the way T2 is rollback,the data obtained by \nT1 is invalid one.E.g a=2 is original data .If T1 read a=1 that was written by T2.If T2 rollback then a=1  will be rollback to  a=2 in DB.But,Now ,T1 has a=1 but in DB \ntable it is changed to a=2.Scenario2.If T1 transaction reads data from table A1.If another concurrent transaction(T2) update data on table A1.Then the data that T1 has read is \ndifferent from table A1.Because T2 has updated the data on table A1.E.g if T1 read a=1 and T2 updated a=2.Then a!=b.Scenario 3.If T1 transaction reads data from table A1 with certain number of rows. If another concurrent transaction(T2) inserts more rows on table A1.The \nnumber of rows read by T1 is different from rows on table A1Scenario 1 is called Dirty readsScenario 2 is called Nonrepeatable reads Scenario 3 is called Phantom reads .So,isolation level is the extend to which Scenario 1 ,Scenario 2 ,Scenario 3 can be prevented.\nYou can obtained complete isolation level by implementing locking.That is preventing concurrent reads and\nwrites to the same data from occurring.But it affects performance .The level of isolation  depends upon application to application how much isolation is \nrequired.ISOLATION_READ_UNCOMMITTED :Allows  to read changes that haven\xe2\x80\x99t yet been committed.It suffer from Scenario 1 ,Scenario 2 ,Scenario 3 ISOLATION_READ_COMMITTED:Allows reads from concurrent transactions that have been com-\nmitted.It may suffer from Scenario 2 ,Scenario 3 . Because other transactions may be updating the data.ISOLATION_REPEATABLE_READ:Multiple reads of the same field will yield the same results untill it is changed by itself.It may suffer from Scenario 3.Because \nother transactions may be inserting the dataISOLATION_SERIALIZABLE: Scenario 1,Scenario 2,Scenario 3 never happens.It is complete isolation.It involves full locking.It affets performace because of \nlocking.You can test using You can debug and see the result with different values for isolation and propagation.Enough explanation about each parameter is given by other answers; However you asked for a real world example, here is the one that clarifies the purpose of different propagation options:You may have noticed that the second service is of propagation type REQUIRES_NEW and moreover chances are it throws an exception (SMTP server down ,invalid e-mail or other reasons).You probably don\'t want the whole process to roll-back, like removing the user information from database or other things; therefore you call the second service in a separate transaction.Meaning that whenever a DAO object, and hence a potential access to db, is created, we need to reassure that the call was made from inside one of our services, implying that a live transaction should exist; otherwise an exception occurs.Therefore the propagation is of type MANDATORY.Isolation level defines how the changes made to some data repository by one transaction affect other simultaneous concurrent transactions, and also how and when that changed data becomes available to other transactions. When we define a transaction using the Spring framework we are also able to configure in which isolation level that same transaction will be executed.READ_UNCOMMITTED isolation level states that a transaction may read data that is still uncommitted by other transactions. READ_COMMITTED isolation level states that a transaction can\'t read data that is not yet committed by other transactions.REPEATABLE_READ isolation level states that if a transaction reads one record from the database multiple times the result of all those reading operations must always be the same.SERIALIZABLE isolation level is the most restrictive of all isolation levels. Transactions are executed with locking at all levels (read, range and write locking) so they appear as if they were executed in a serialized way. Propagation is the ability to decide how the business methods should be encapsulated in both logical or physical transactions.Spring REQUIRED behavior means that the same transaction will be used if there is an already opened transaction in the current bean method execution context.REQUIRES_NEW behavior means that a new physical transaction will always be created by the container.The NESTED behavior makes nested Spring transactions to use the same physical transaction but sets savepoints between nested invocations so inner transactions may also rollback independently of outer transactions.The MANDATORY behavior states that an existing opened transaction must already exist. If not an exception will be thrown by the container.The NEVER behavior states that an existing opened transaction must not already exist. If a transaction exists an exception will be thrown by the container.The NOT_SUPPORTED behavior will execute outside of the scope of any transaction. If an opened transaction already exists it will be paused.The SUPPORTS behavior will execute in the scope of a transaction if an opened transaction already exists. If there isn\'t an already opened transaction the method will execute anyway but in a non-transactional way.You almost never want to use Read Uncommited since it\'s not really ACID compliant. Read Commmited is a good default starting place. Repeatable Read is probably only needed in reporting, rollup or aggregation scenarios. Note that many DBs, postgres included don\'t actually support Repeatable Read, you have to use Serializable instead. Serializable is useful for things that you know have to happen completely independently of anything else; think of it like synchronized in Java. Serializable goes hand in hand with REQUIRES_NEW propagation.I use REQUIRES for all functions that run UPDATE or DELETE queries as well as "service" level functions. For DAO level functions that only run SELECTs, I use SUPPORTS which will participate in a TX if one is already started (i.e. being called from a service function).Transaction Isolation and Transaction Propagation although related but are clearly two  very different concepts. In both cases defaults are customized at client boundary component either by using Declarative transaction management or Programmatic transaction management. Details of each isolation levels and propagation attributes can be found in reference links below.Transaction IsolationFor given two or more running transactions/connections to a database, how and when are changes made by queries in one transaction impact/visible to the queries in a different transaction. It also related to what kind of database record locking will be used to isolate changes in this transaction from other transactions and vice versa. This is typically implemented by database/resource that is participating in transaction..Transaction PropagationIn an enterprise application for any given request/processing there are many components that are involved to get the job done. Some of this components mark the boundaries (start/end) of a transaction that will be used in respective component and it\'s sub components. For this transactional boundary of components, Transaction Propogation specifies if respective component will or will not participate in transaction and what happens if calling component already has or does not have a transaction already created/started. This is same as Java EE Transaction Attributes. This is typically implemented by the client transaction/connection manager.Reference:Spring Transaction ManagementWiki Transaction Isolation (database systems)Oracle on Transaction Isolation LevelsJava EE Transaction Attributes (propagation) Spring Framework Transaction propagationI have run outerMethod,method_1 and method_2 with different propagation mode.Below is the output for different propagation mode.Outer MethodMethod_1Method_2We can add for this:You can use like this:You can use this thing also: