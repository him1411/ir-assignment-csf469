I\'ve been digging through some parts of the Linux kernel, and found calls like this:orI\'ve found the definition of them:I know that they are for optimization, but how do they work? And how much performance/size decrease can be expected from using them? And is it worth the hassle (and losing the portability probably) at least in bottleneck code (in userspace, of course).They are an instruction to the compiler to emit instructions that will cause branch prediction to favour the "likely" side of a jump instruction. This can be a big win, if the prediction is correct it means that the jump instruction is basically free and will take zero cycles. On the other hand if the prediction is wrong, then it means the processor pipeline needs to be flushed and it can cost several cycles. So long as the prediction is correct most of the time, this will tend to be good for performance.Like all such performance optimisations you should only do it after extensive profiling to ensure the code really is in a bottleneck, and probably given the micro nature, that it is being run in a tight loop. Generally the Linux developers are pretty experienced so I would imagine they would have done that. They don\'t really care too much about portability as they only target gcc, and they have a very close idea of the assembly they want it to generate.These are macros that give hints to the compiler about which way a branch may go.  The macros expand to GCC specific extensions, if they\'re available.  GCC uses these to to optimize for branch prediction.  For example, if you have something like the followingThen it can restructure this code to be something more like:The benefit of this is that when the processor takes a branch the first time, there is significant overhead, because it may have been speculatively loading and executing code further ahead.  When it determines it will take the branch, then it has to invalidate that, and start at the branch target.Most modern processors now have some sort of branch prediction, but that only assists when you\'ve been through the branch before, and the branch is still in the branch prediction cache.There are a number of other strategies that the compiler and processor can use in these scenarios.  You can find more details on how branch predictors at Wikipedia: http://en.wikipedia.org/wiki/Branch_predictorLet\'s decompile to see what GCC 4.8 does with itWithout __builtin_expectCompile and decompile with GCC 4.8.2 x86_64 Linux:Output:The instruction order in memory was unchanged: first the printf and then puts and the retq return.With __builtin_expectNow replace if (i) with:and we get:The printf (compiled to __printf_chk) was moved to the very end of the function, after puts and the return to improve branch prediction as mentioned by other answers.So it is basically the same as:This optimization was not done with -O0.But good luck on writing an example that runs faster with __builtin_expect than without, CPUs are really smart those days. My naive attempts are here.They cause the compiler to emit the appropriate branch hints where the hardware supports them. This usually just means twiddling a few bits in the instruction opcode, so code size will not change. The CPU will start fetching instructions from the predicted location, and flush the pipeline and start over if that turns out to be wrong when the branch is reached; in the case where the hint is correct, this will make the branch much faster - precisely how much faster will depend on the hardware; and how much this affects the performance of the code will depend on what proportion of the time hint is correct.For instance, on a PowerPC CPU an unhinted branch might take 16 cycles, a correctly hinted one 8 and an incorrectly hinted one 24. In innermost loops good hinting can make an enormous difference.Portability isn\'t really an issue - presumably the definition is in a per-platform header; you can simply define "likely" and "unlikely" to nothing for platforms that do not support static branch hints.They\'re hints to the compiler to generate the hint prefixes on branches.  On x86/x64, they take up one byte, so you\'ll get at most a one-byte increase for each branch.  As for performance, it entirely depends on the application -- in most cases, the branch predictor on the processor will ignore them, these days.Edit: Forgot about one place they can actually really help with.  It can allow the compiler to reorder the control-flow graph to reduce the number of branches taken for the \'likely\' path.  This can have a marked improvement in loops where you\'re checking multiple exit cases.In many linux release, you can find complier.h in /usr/linux/ , you can include it for use simply. And another opinion, unlikely() is more useful rather than likely(), because it can be optimized as well in many compiler.And by the way, if you want to observe the detail behavior of the code, you can do simply as follow:gcc -c test.c\n  objdump -d test.o > obj.sThen, open obj.s, you can find the answer.(general comment - other answers cover the details)There\'s no reason that you should lose portability by using them.You always have the option of creating a simple nil-effect "inline" or macro that will allow you to compile on other platforms with other compilers.You just won\'t get the benefit of the optimization if you\'re on other platforms.As per the comment by Cody, this has nothing to do with Linux, but is a hint to the compiler.  What happens will depend on the architecture and compiler version.  This particular feature in Linux is somewhat mis-used in drivers.  As osgx points out in semantics of hot attribute, any hot or cold function called with in a block can automatically hint that the condition is likely or not.  For instance, dump_stack() is marked cold so this is redundant,Future versions of gcc may selectively inline a function based on these hints.  There have also been suggestions that it is not boolean, but a score as in most likely, etc.  Generally, it should be preferred to use some alternate mechanism like cold.  There is no reason to use it in any place but hot paths.  What a compiler will do on one architecture can be completely different on another.This construct tells the compiler that the expression EXP\nmost likely will have the value C. The return value is EXP.\n__builtin_expect is meant to be used in an conditional\nexpression. In almost all cases will it be used in the\ncontext of boolean expressions in which case it is much\nmore convenient to define two helper macros:These macros can then be used as inReference: https://www.akkadia.org/drepper/cpumemory.pdfThese are GCC functions for the programmer to give a hint to the compiler about what the most likely branch condition will be in a given expression. This allows the compiler to build the branch instructions so that the most common case takes the fewest number of instructions to execute.How the branch instructions are built are dependent upon the processor architecture.