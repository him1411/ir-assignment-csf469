There are several questions on StackOverflow regarding offsetWidth/clientWidth/scrollWidth (and -Height, respectively), but none give comprehensive explanation of what those values are.Also, there are several sources on the web giving confusing or incorrect information.Can you give a complete explanation including some visual hints?\nAlso, how can those values be used to calculate scroll bar widths?The CSS box model is rather complicated, particularly when it comes to scrolling content. While the browser uses the values from your CSS to draw boxes, determining all the dimensions using JS is not straight-forward if you only have the CSS.That\'s why each element has six DOM properties for your convenience: offsetWidth, offsetHeight, clientWidth, clientHeight, scrollWidth and scrollHeight. These are read-only attributes representing the current visual layout, and all of them are integers (thus possibly subject to rounding errors).Let\'s go through them in detail:Since clientWidth takes the scroll bar width into account, we can use it to calculate the scroll bar width via the formulaUnfortunately, we may get rounding errors, since offsetWidth and clientWidth are always integers, while the actual sizes may be fractional with zoom levels other than 1.Note that thisdoes not work reliably in Chrome, since Chrome returns width with scrollbar already substracted. (Also, Chrome renders paddingBottom to the bottom of the scroll content, while other browsers don\'t)If you want to use scrollWidth to get the "REAL" CONTENT WIDTH/HEIGHT (as content can be BIGGER than the css-defined width/height-Box) the scrollWidth/Height is very UNRELIABLE as some browser seem to "MOVE" the paddingRIGHT & paddingBOTTOM if the content is to big. They then place the paddings at the RIGHT/BOTTOM of the "too broad/high content" (see picture below). ==> Therefore to get the REAL CONTENT WIDTH in some browsers you have to substract BOTH paddings from the scrollwidth and in some browsers you only have to substract the LEFT Padding.I found a solution for this and wanted to add this as a comment, but was not allowed. So I took the picture and made it a bit clearer in the regard of the "moved paddings" and the "unreliable scrollWidth". In the BLUE AREA you find my solution on how to get the "REAL" CONTENT WIDTH!Hope this helps to make things even clearer!There is a good article on MDN that explains the theory behind those concepts:\nhttps://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elementsIt also explains the important conceptual differences between boundingClientRect\'s width/height vs offsetWidth/offsetHeight.Then, to prove the theory right or wrong, you need some tests.\nThat\'s what I did here: https://github.com/lingtalfi/dimensions-cheatsheetIt\'s testing for chrome53, ff49, safari9, edge13 and ie11.The results of the tests prove that the theory is generally right.\nFor the tests, I created 3 divs containing 10 lorem ipsum paragraphs each.\nSome css was applied to them:And here are the results:div1bcr.height: 330 (chrome53, ff49, safari9, edge13, ie11)clientWidth: 505 (chrome53, ff49, safari9)clientHeight: 320 (chrome53, ff49, safari9, edge13, ie11)scrollWidth: 505 (chrome53, safari9, ff49)div2clientHeight: 290 (chrome53, ff49, safari9, edge13, ie11)scrollWidth: 475 (chrome53, safari9, ff49)div3clientHeight: 320 (chrome53, ff49, safari9, edge13, ie11)scrollWidth: 505 (chrome53, safari9, ff49)So, apart from the boundingClientRect\'s height value (299.9999694824219 instead of expected 300) in edge13 and ie11, the results confirm that the theory behind this works.From there, here is my definition of those concepts:Note: the default vertical scroll bar\'s width is 12px in edge13, 15px in chrome53, ff49 and safari9, and 17px in ie11 (done by measurements in photoshop from screenshots, and proven right by the results of the tests).However, in some cases, maybe your app is not using the default vertical scroll bar\'s width.So, given the definitions of those concepts, the vertical scroll bar\'s width should be equal to (in pseudo code):layout dimension: offsetWidth - clientWidth - (borderLeftWidth + borderRightWidth)rendering dimension: boundingClientRect.width - clientWidth - (borderLeftWidth + borderRightWidth)Note, if you don\'t understand layout vs rendering please read the mdn article.Also, if you have another browser (or if you want to see the results of the tests for yourself), you can see my test page here: http://codepen.io/lingtalfi/pen/BLdBdLI created a more comprehensive and cleaner version that some people might find useful for remembering which name corresponds to which value. I used Chrome Dev Tool\'s color code and labels are organized symmetrically to pick up analogies faster:Note 1: clientWidth also includes the width of the vertical scroll\nbar if the direction of the text is set to right-to-left (since the\nbar is displayed to the left in that case)Note 2: the outermost line represents the closest positioned parent\n(an element whose position property is set to a value different than\nstatic or initial). Thus, if the direct container isn\xe2\x80\x99t a positioned\nelement, then the line doesn\xe2\x80\x99t represent the first container in\nthe hierarchy but another element higher in the hierarchy. If no\npositioned parent is found, the browser will take the html or body\nelement as referenceHope somebody finds it useful, just my 2 cents ;)