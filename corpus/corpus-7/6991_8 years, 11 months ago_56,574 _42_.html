I am a big fan of letting the compiler do as much work for you as possible.  When writing a simple class the compiler can give you the following for \'free\':But it cannot seem to give you any comparison operators - such as operator== or operator!=.  For example:Is there a good reason for this?  Why would performing a member-by-member comparison be a problem?  Obviously if the class allocates memory then you\'d want to be careful, but for a simple class surely the compiler could do this for you?The compiler wouldn\'t know whether you wanted a pointer comparison or a deep (internal) comparison.It\'s safer to just not implement it and let the programmer do that themselves. Then they can make all the assumptions they like.The argument that if the compiler can provide a default copy constructor, it should be able to provide a similar default operator==() makes a certain amount of sense.  I think that the reason for the decision to not provide a compiler-generated default for this operator can be guessed by what Stroustrup said about the default copy constructor in "The Design and Evolution of C++" (Section 11.4.1 - Control of Copying):I personally consider it unfortunate\n  that copy operations are defined by\n  default and I prohibit copying of\n  objects of many of my classes. \n  However, C++ inherited its default\n  assignment and copy constructors from\n  C, and they are frequently used.So instead of "why doesn\'t C++ have a default operator==()?", the question should have been "why does C++ have a default assignment and copy constructor?", with the answer being those items were in included reluctantly by Stroustrup for backwards compatibility with C (probably the cause of most of C++\'s warts, but also probably the primary reason for C++\'s popularity).For my own purposes, in my IDE the snippet I use for new classes contains declarations for a private assignment operator and copy constructor so that when I gen up a new class I get no default assignment and copy operations - I have to explicitly remove the declaration of those operations from the private: section if I want the compiler to be able to generate them for me.UPDATE 2: Unfortunately this proposal didn\'t make it to C++17, so nothing is changing in the language with this regard for now.UPDATE: The current version of the proposal which has very high chance to get voted into C++17 is here.There is a recent proposal (N4126) on explicitly defaulted comparison operators, which has had very positive feedback from the standard committee, so hopefully we\'ll see it in some form in C++17.In short, the proposed syntax is:Or in friend form for classes with private fields:Or even in short form:Of course all this may change by the time this proposal is finally accepted.IMHO, there is no "good" reason. The reason there are so many people that agree with this design decision is because they did not learn to master the power of value-based semantics. People need to write a lot of custom copy constructor, comparison operators and destructors because they use raw pointers in their implementation.When using appropriate smart pointers (like std::shared_ptr), the default copy constructor is usually fine and the obvious implementation of the hypothetical default comparison operator would be as fine.It\'s answered C++ didn\'t do == because C didn\'t, and here is why C provides only default = but no == at first place.\nC wanted to keep it simple:\nC implemented = by memcpy; however, == cannot be implemented by memcmp due to padding.\nBecause padding is not initialized, memcmp says they are different even though they are the same.\nThe same problem exists for empty class: memcmp says they are different because size of empty classes are not zero.\nIt can be seen from above that implementing == is more complicated than implementing = in C.\nSome code example regarding this.\nYour correction is appreciated if I\'m wrong.It is not possible to define default ==, but you can define default != via == which you usually should define yourselves.\nFor this you should do following things:You can see http://www.cplusplus.com/reference/std/utility/rel_ops/ for details.In addition if you define operator< , operators for  <=, >, >= can be deduced from it when using std::rel_ops.But you should be careful when you use std::rel_ops because comparison operators can be deduced for the types you are not expected for.More preferred way to deduce related operator from basic one is to use boost::operators.The approach used in boost is better because it define the usage of operator for the class you only want, not for all classes in scope.You can also generate "+" from "+=", - from "-=", etc... (see full list here)In this video Alex Stepanov, the creator of STL addresses this very question at about 13:00. To summarize, having watched the evolution of C++ he argues that:  He then says that in the (distant) future == and != will be implicitly generated.C++0x has had a proposal for default functions, so you could say default operator==;\nWe\'ve learnt that it helps to make these things explicit.Just a note, also provided by the compiler for free:Conceptually it is not easy to define equality. Even for POD data, one could argue that even if the fields are the same, but it is a different object (at a different address) it is not necessarily equal. This actually depends on the usage of the operator. Unfortunately your compiler is not psychic and cannot infer that.Besides this, default functions are excellent ways to shoot oneself in the foot. The defaults you describe are basically there to keep compatibility with POD structs. They do however cause more than enough havoc with developers forgetting about them, or the semantics of the default implementations.I agree, for POD type classes then the compiler could do it for you. However what you might consider simple the compiler might get wrong. So it is better to let the programmer do it. I did have a POD case once where two of the fields were unique - so a comparison would never be considered true. However the comparison I needed only ever compared on the payload - something the compiler would never understand or could ever figure out on it\'s own.Besides - they don\'t take long to write do they?!Is there a good reason for this? Why would performing a member-by-member comparison be a problem?It may not be a problem functionally, but in terms of performance, default member-by-member comparison is liable to be more sub-optimal than default member-by-member assignment/copying. Unlike order of assignment, order of comparison impacts performance because the first unequal member implies the rest can be skipped. So if there are some members that are usually equal you want to compare them last, and the compiler doesn\'t know which members are more likely to be equal.Consider this example, where verboseDescription is a long string selected from a relatively small set of possible weather descriptions.(Of course the compiler would be entitled to disregard the order of comparisons if it recognizes that they have no side-effects, but presumably it would still take its que from the source code where it doesn\'t have better information of its own.)The default comparison operators would be correct a vanishingly small amount of the time; I expect that they would be a source of problems rather than something useful.Also, the default methods you mention are often undesirable.  Seeing code like this to get rid of the default copy constructor and operator= is very common:In a lot of code it is common to see a comment "default copy constructor and operator= OK" to indicate that it is not a mistake that they have been removed or explicitly defined.