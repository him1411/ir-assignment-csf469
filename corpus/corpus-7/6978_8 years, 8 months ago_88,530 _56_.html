Why don\'t more mainstream statically typed languages support function/method overloading by return type?  I can\'t think of any that do.  It seems no less useful or reasonable than supporting overload by parameter type.  How come it\'s so much less popular?Contrary to what others are saying, overloading by return type is possible and is done by some modern languages.  The usual objection is that in code likeyou can\'t tell which func() is being called.  This can be resolved in a few ways:Two of the languages I regularly (ab)use overload by return type: Perl and Haskell.  Let me describe what they do.In Perl, there is a fundamental distinction between scalar and list context (and others, but we\'ll pretend there are two).  Every built-in function in Perl can do different things depending on the context in which it is called.  For example, the join operator forces list context (on the thing being joined) while the scalar operator forces scalar context, so compare:Every operator in Perl does something in scalar context and something in list context, and they may be different, as illustrated.  (This isn\'t just for random operators like localtime.  If you use an array @a in list context, it returns the array, while in scalar context, it returns the number of elements.  So for example print @a prints out the elements, while print 0+@a prints the size.)  Furthermore, every operator can force a context, e.g. addition + forces scalar context.  Every entry in man perlfunc documents this.  For example, here is part of the entry for glob EXPR:In list context, returns a (possibly\n  empty) list of filename expansions on\n  the value of EXPR such as the standard\n  Unix shell /bin/csh would do. In\n  scalar context, glob iterates through\n  such filename expansions, returning\n  undef when the list is exhausted.Now, what\'s the relation between list and scalar context?  Well, man perlfunc saysRemember the following important rule:\n  There is no rule that relates the\n  behavior of an expression in list\n  context to its behavior in scalar\n  context, or vice versa.  It might do\n  two totally different things.  Each\n  operator and function decides which\n  sort of value it would be most\n  appropriate to return in scalar\n  context.  Some operators return the\n  length of the list that would have\n  been returned in list context.  Some\n  operators return the first value in\n  the list.  Some operators return the\n  last value in the list.  Some\n  operators return a count of successful\n  operations.  In general, they do what\n  you want, unless you want consistency.so it\'s not a simple matter of having a single function, and then you do simple conversion at the end.  In fact, I chose the localtime example for that reason.It\'s not just the built-ins that have this behavior.  Any user can define such a function using wantarray, which allows you to distinguish between list, scalar, and void context.  So, for example, you can decide to do nothing if you\'re being called in void context.Now, you may complain that this isn\'t true overloading by return value because you only have one function, which is told the context it\'s called in and then acts on that information.  However, this is clearly equivalent (and analogous to how Perl doesn\'t allow usual overloading literally, but a function can just examine its arguments).  Moreover, it nicely resolves the ambiguous situation mentioned at the beginning of this response.  Perl doesn\'t complain that it doesn\'t know which method to call; it just calls it.  All it has to do is figure out what context the function was called in, which is always possible:(Note: I may sometimes say Perl operator when I mean function.  This is not crucial to this discussion.)Haskell takes the other approach, namely to not have side effects.  It also has a strong type system, and so you can write code like the following:This code reads a floating point number from standard input, and prints its square root.  But what is surprising about this?  Well, the type of readLn is readLn :: Read a => IO a.  What this means is that for any type that can be Read (formally, every type that is an instance of the Read type class), readLn can read it.  How did Haskell know that I wanted to read a floating point number?  Well, the type of sqrt is sqrt :: Floating a => a -> a, which essentially means that sqrt can only accept floating point numbers as inputs, and so Haskell inferred what I wanted.What happens when Haskell can\'t infer what I want?  Well, there a few possibilities.  If I don\'t use the return value at all, Haskell simply won\'t call the function in the first place.  However, if I do use the return value, then Haskell will complain that it can\'t infer the type:I can resolve the ambiguity by specifying the type I want:Anyway, what this whole discussion means is that overloading by return value is possible and is done, which answers part of your question.The other part of your question is why more languages don\'t do it.  I\'ll let others answer that.  However, a few comments: the principle reason is probably that the opportunity for confusion is truly greater here than in overloading by argument type.  You can also look at rationales from individual languages:Ada: "It might appear that the simplest overload resolution rule is to use everything - all information from as wide a context as possible - to resolve the overloaded reference. This rule may be simple, but it is not helpful. It requires the human reader to scan arbitrarily large pieces of text, and to make arbitrarily complex inferences (such as (g) above). We believe that a better rule is one that makes explicit the task a human reader or a compiler must perform, and that makes this task as natural for the human reader as possible."C++ (subsection 7.4.1of Bjarne Stroustrup\'s "The C++ Programming Language"): "Return types are not considered in overload resolution.  The reason is to keep resolution for an individual operator or function call context-independent.  Consider:If the return type were taken into account, it would no longer be possible to look at a call of sqrt() in isolation and determine which function was called."  (Note, for comparison, that in Haskell there are no implicit conversions.)Java (Java Language Specification 9.4.1): "One of the inherited methods must must be return type substitutable for any other inherited method; otherwise, a compile-time error occurs."  (Yes, I know this doesn\'t give a rationale.  I\'m sure the rationale is given by Gosling in "the Java Programming Language".  Maybe someone has a copy?  I bet it\'s the "principle of least surprise" in essence.)  However, fun fact about Java: the JVM allows overloading by return value!  This is used, for example, in Scala, and can be accessed directly through Java as well by playing around with internals.PS.  As a final note, it is actually possible to overload by return value in C++ with a trick.  Witness:If functions were overloaded by the return type and you had these two overloadsthere is no way the compiler could figure out which of those two functions to call upon seeing a call like thisFor this reason, language designers often disallow return-value overloading.Some languages (such as MSIL), however, do allow overloading by return type. They too face the above difficulty of course, but they have workarounds, for which you\'ll have to consult their documentation.In such a language, how would you resolve the following:if f had overloads void f(int) and void f(string) and g had overloads int g(int) and string g(int)? You would need some kind of disambiguator.I think the situations where you might need this would be better served by choosing a new name for the function.To steal a C++ specific answer from another very similar question (dupe?):Function return types don\'t come into play in overload resolution simply because Stroustrup (I assume with input from other C++ architects) wanted overload resolution to be \'context independent\'. See 7.4.1 - "Overloading and Return Type" from the "C++ Programming Language, Third Edition".The reason is to keep resolution for an individual operator or function call context-independent.They wanted it to be based only on how the overload was called - not how the result was used (if it was used at all). Indeed, many functions are called without using the result or the result would be used as part of a larger expression. One factor that I\'m sure came into play when they decided this was that if the return type was part of the resolution there would be many calls to overloaded functions that would need to be resolved with complex rules or would have to have the compiler throw an error that the call was ambiguous.And, Lord knows, C++ overload resolution is complex enough as it stands...In haskell it\'s possible even though it doesn\'t have function overloading. Haskell uses type classes. In a program you could see:Function overloading itself is not so popular. Mostly languages I\'ve seen with it are C++, perhaps java and/or C#. In all dynamic languages it\'s a shorthand for:Therefore there\'s no much point in it. Most people aren\'t interested whether language can help you drop a single line per where ever you use it.Pattern matching is somewhat similar to function overloading, and I guess sometimes work similarly. It\'s not common though because it is useful only for few programs and is tricky to implement on most of languages.You see there\'s infinitely many other better easier-to-implement features to implement into the language, including:Good answers!  A.Rex\'s answer in particular is very detailed and instructive.  As he points out, C++ does consider user-supplied type-conversion operators when compiling lhs = func(); (where func is really the name of a struct).  My workaround is a bit different - not better, just different (although it\'s based on the same basic idea).Whereas I had wanted to write...I ended up with a solution that uses a parameterized struct (with T = the return type):A benefit of this solution is that any code which includes these template definitions can add more specializations for more types.  Also you can do partial specializations of the struct as needed.  For example, if you wanted special handling for pointer types:As a negative, you can\'t write int x = func(); with my solution.  You have to write int x = func<int>();.  You have to explicitly say what the return type is, rather than asking the compiler to suss it out by looking at type conversion operators.  I would say that "my" solution and A.Rex\'s both belong in a pareto-optimal front of ways to tackle this C++ dilemma :)As already shown - ambiguous calls of a function that differs only by return type introduces ambiguity.\nAmbiguity induces defective code.\nDefective code must be avoided.The complexity driven by the attempt to ambiguity shows that this is not a good hack.\nApart from an intellectual exercise - why not use procedures with reference parameters.this overloading feature is not hard to manage,  if you look at it in a slightly different way.  consider the following,if a language did return overloading it would allow parameter overloading, but not duplications.\nthis would solve the problem of:because there is only one f(int choice) to choose from.In .NET, sometimes we use one parameter to indicate the desired output from a generic result, and then made a conversion to get what we expect.Maybe this example could help too:For the record, Octave allows different outcome according to return element being scalar vs array.Cf also Singular Value Decomposition.Most static languages also now support generics, which would solve your problem.  As stated before, without having parameter diffs, there is not way to know which one to call.  So if you want to do this, just use generics and call it a day.