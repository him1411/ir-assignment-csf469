What are the best practices to consider when catching exceptions and re-throwing them? I want to make sure that the Exception object\'s InnerException and stack trace are preserved. Is there a difference between the following code blocks in the way they handle this?Vs:The way to preserve the stack trace is through the use of the throw; This is valid as wellthrow ex; is basically like throwing an exception from that point, so the stack trace would only go to where you are issuing the throw ex; statement.Mike is also correct, assuming the exception allows you to pass an exception (which is recommended).Karl Seguin has a great write up on exception handling in his foundations of programming e-book as well, which is a great read.Edit: Working link to Foundations of Programming pdf. Just search the text for "exception".If you throw a new exception with the initial exception you will preserve the initial stack trace too..Actually, there are some situations which the throw statment will not preserve the StackTrace information. For example, in the code below:The StackTrace will indicate that line 54 raised the exception, although it was raised at line 47.In situations like the one described above, there are two options to preseve the original StackTrace:Calling the Exception.InternalPreserveStackTraceAs it is a private method, it has to be invoked by using reflection: I has a disadvantage of relying on a private method to preserve the StackTrace information. It can be changed in future versions of .NET Framework. The code example above and proposed solution below was extracted from Fabrice MARGUERIE weblog.Calling Exception.SetObjectDataThe technique below was suggested by Anton Tykhyy as answer to In C#, how can I rethrow InnerException without losing stack trace question.Although, it has the advantage of relying in public methods only it also depends on the following exception constructor (which some exceptions developed by 3rd parties do not implement):In my situation, I had to choose the first approach, because the exceptions raised by a 3rd-party library I was using didn\'t implement this constructor.When you throw ex, you\'re essentially throwing a new exception, and will miss out on the original stack trace information.  throw is the preferred method.The rule of thumb is to avoid Catching and Throwing the basic Exception object. This forces you to be a little smarter about exceptions; in other words you should have an explicit catch for a SqlException so that your handling code doesn\'t do something wrong with a NullReferenceException.In the real world though, catching and logging the base exception is also a good practice, but don\'t forget to walk the whole thing to get any InnerExceptions it might have.A few people actually missed a very important point - \'throw\' and \'throw ex\' may do the same thing but they don\'t give you a crucial piece of imformation which is the line where the exception happened.Consider the following code:When you do either a \'throw\' or \'throw ex\' you get the stack trace but the line# is going to be #22 so you can\'t figure out which line exactly was throwing the exception (unless you have only 1 or few lines of code in the try block). To get the expected line #17 in your exception you\'ll have to throw a new exception with the original exception stack trace.You should always use "throw;" to rethrow the exceptions in .NET,Refer this,\nhttp://weblogs.asp.net/bhouse/archive/2004/11/30/272297.aspxBasically MSIL (CIL) has two instructions - "throw" and "rethrow":Basically I can see the reason why "throw ex" overrides the stack trace.Nobody has explained the difference between ExceptionDispatchInfo.Capture( ex ).Throw() and a plain throw, so here it is. However, some people have noticed the problem with throw.The complete way to rethrow a caught exception is to use ExceptionDispatchInfo.Capture( ex ).Throw() (only available from .Net 4.5).Below there are the cases necessary to test this:1.2.3.4.Case 1 and case 2 will give you a stack trace where the source code line number for the CallingMethod method is the line number of the throw new Exception( "TEST" ) line.However, case 3 will give you a stack trace where the source code line number for the CallingMethod method is the line number of the throw call. This means that if the throw new Exception( "TEST" ) line is surrounded by other operations, you have no idea at which line number the exception was actually thrown.Case 4 is similar with case 2 because the line number of the original exception is preserved, but is not a real rethrow because it changes the type of the original exception.I would definitely use:That will preserve your stack.You may also use:And any exceptions thrown will bubble up to the next level that handles them.FYI I just tested this and the stack trace reported by \'throw;\' is not an entirely correct stack trace. Example:The stack trace points to the origin of the exception correctly (reported line number) but the line number reported for foo() is the line of the throw; statement, hence you cannot tell which of the calls to bar() caused the exception.