What is the simplest/cleanest way to implement singleton pattern in JavaScript?I think the easiest way is to declare a simple object literal:If you want private members on your singleton instance, you can do something like this:This is has been called the module pattern, it basically allows you to encapsulate private members on an object, by taking advantage of the use of closures.I think the cleanest approach is something like:Afterwards, you can invoke the function asI\'m not sure I agree with the module pattern being used as a replacement for a singleton pattern. I\'ve often seen singletons used and abused in places where they\'re wholly unnecessary, and I\'m sure the module pattern fills many gaps where programmers would otherwise use a singleton, however the module pattern is not a singleton.Everything initialized in the module pattern happens when Foo is declared. Additionally, the module pattern can be used to initialize a constructor, which could then be instantiated multiple times. While the module pattern is the right tool for many jobs, it\'s not equivalent to a singleton.In both versions of the Singleton pattern that I\'ve provided, the constructor itself can be used as the accessor:If you don\'t feel comfortable using the constructor this way, you can throw an error in the if (instance) statement, and stick to using the long form:I should also mention that the singleton pattern fits well with the implicit constructor function pattern:There is more than one ways to skin a cat :) Depending on your taste or specific need you can apply any of the proposed solutions. I personally go for CMS\' first solution whenever possible (when you don\'t need privacy). Since the question was about the simplest and cleanest, that\'s the winner. Or even:This (quote from my blog) ...doesn\'t make much sense (my blog example doesn\'t either) because it doesn\'t need any private vars, so it\'s pretty much the same as:I deprecate my answer, see my other one.Usually module pattern (see CMS\' answer) which is NOT singleton pattern is good enough. However one of the features of singleton is that its initialization is delayed till object is needed. Module pattern lacks this feature.My proposition (CoffeeScript):Which compiled to this in JavaScript:Then I can do following:I got this example from JavaScript Patterns\nBuild Better Applications with Coding and Design Patterns\nBy Stoyan Stefanov\'s book in case you need some simple implementation class like singltone object you can use immediate function as following:And you can check this example by following test case:This approaches passes all test cases while private static implementation will fail when prototype extension is used (it can be fixed but it will not be simple) and public static implementation less advisable due to instance is exposed to the public.jsFiddly demo.I think I have found the cleanest way to program in JavaScript, but you\'ll need some imagination. I got this idea from a working technique in the book "javascript the good parts".Instead of using the new keyword, you could create a class like this:You can instantiate the above object by saying:Now with this work method in mind you could create a singleton like this:Now you can get your instance by callingI think this is the neatest way as the complete "Class" is not even accessible. Not sure why nobody brought this up, but you could just do:Because non-blocking nature of JavaScript, Singletons in JavaScript are really ugly in use.  Global variables will give you one instance through whole application too without all these callbacks, module pattern gently hides internals behind the interface.  See @CMS answer.But, since you wanted a singleton\xe2\x80\xa6Usage:Singletons give you more than just one instance through whole application: their initialization is delayed till first use.  This is really big thing when you deal with objects whose initialization is expensive.  Expensive usually means I/O and in JavaScript I/O always mean callbacks.Don\'t trust answers which give you interface like instance = singleton.getInstance(), they all miss the point.If they don\'t take callback to be run when instance is ready, then they won\'t work when initializer does I/O.  Yeah, callbacks always look uglier than function call which immediately returns object instance.  But again: when you do I/O, callbacks are obligatory.  If you don\'t want to do any I/O, then instantiation is cheap enough to do it at program start.In this example setTimeout fakes some expensive I/O operation.  This illustrates why singletons in JavaScript really need callbacks.@CMS and @zzzzBov have both given wonderful answers, but just to add my own interpretation based on my having moved into heavy node.js development from PHP/Zend Framework where singleton patterns were common.The following, comment-documented code is based on the following requirements:My code is very similar to @zzzzBov\'s except I\'ve added a prototype chain to the constructor and more comments that should help those coming from PHP or a similar language translate traditional OOP to Javascripts prototypical nature. It may not be the "simplest" but I believe it is the most proper.Note that technically, the self-executing anonymous function is itself a Singleton as demonstrated nicely in the code provided by @CMS. The only catch here is that it is not possible to modify the prototype chain of the constructor when the constructor itself is anonymous.Keep in mind that to Javascript, the concepts of “public” and “private” do not apply as they do in PHP or Java. But we have achieved the same effect by leveraging Javascript’s rules of functional scope availability.can I put my 5 coins. I have a constructor function, ex. What I need to do is just every object created by this CF will be same.testI needed several singletons with:and so this was what I came up with:args must be Array for this to work so if you have empty variables, just\npass in []I used window object in the function but I could have passed in a parameter to create   my own scopename and construct parameters are only String for window[] to work but with some simple type-checking, window.name and window.construct are also possible.What\'s wrong with this?How about this way, just insure the class can not new again.By this, you can use the instanceof op, also, you can use the prototype chain to inherit the class,it\'s a regular class, but can not new it,if yuu want to get the instance just use getInstanceIf you don\'t want to expose the instance member, just put it into a closure.following is the snippet from my walk through to implement a singleton pattern. This occurred to me during an interview process and I felt that I should capture this somewhere.the same can be found on my gist pageIsn\'t this a singleton too?You can do it with decorators like in this example below for TypeScript:Then you use your singleton like this:As of this writing, decorators are not readily available in JavaScript engines. You would need to make sure your JavaScript runtime has decorators actually enabled or use compilers like Babel and TypeScript.Also note that singleton instance is created "lazy", i.e., it is created only when you use it for the first time.Module pattern: in "more readable style". You can see easily which methods are publics and which ones are privatesnow you can use publics methods likemodule.method2(); //-> I\'m calling a private method over a public method alert("hi im a private method")http://jsfiddle.net/ncubica/xMwS9/I like to use a combination of the Singleton with the module pattern, init-time branching with a Global NS check, wrapped within a closure. In a case where the environment isn\'t going to change after the initialization of the singleton; the use of an immediately invoked object-literal to return a module full of utilities that will persist for some duration should be fine. I\'m not passing any dependencies, just invoking the singletons within their own little world - the only goal being to: create a utilities module for event binding / unbinding (device orientation / orientation changes could also work in this case).You did not say "in the browser". Otherwise, you can use NodeJS modules. These are the same for each require call. Basic example:The contents of foo.js:The contents of circle.js:Note that you cannot access circle.PI, as it is not exported.While this does not work in the browser, it is simple and clean.Main key is to Undertand Closure importance behind this.So property even inside the inner function will be private with the help of closure. var Singleton = function () {\n     var instance;};Singleton in javascript is achieved using Module pattern and closures. \nBelow is the code which is pretty much self-explanatory - Singleton:Ensure a class has only one instance and provide a global point of access to it.The Singleton Pattern limits the number of instances of a particular object to just one. This single instance is called the singleton.The Singleton object is implemented as an immediate anonymous function. The function executes immediately by wrapping it in brackets followed by two additional brackets. It is called anonymous because it doesn\'t have a name.Sample Program,\nI believe this is the simplest/cleanest and most intuitive way though it requires ES7:The source code is from: adam-bien.comIn es6: