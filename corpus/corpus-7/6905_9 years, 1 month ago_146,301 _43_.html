What\'s the easiest way to profile a PHP script?I\'d love tacking something on that shows me a dump of all function calls and how long they took but I\'m also OK with putting something around specific functions.I tried experimenting with the microtime function:but that sometimes gives me negative results.  Plus it\'s a lot of trouble to sprinkle that all over my code.The PECL APD extension is used as follows:After, parse the generated file using pprofp.Example output:You want xdebug I think. Install it on the server, turn it on, pump the output through kcachegrind (for linux) or wincachegrind (for windows) and it\'ll show you a few pretty charts that detail the exact timings, counts and memory usage (but you\'ll need another extension for that).It rocks, seriously :DNo extensions are needed, just use these two functions for simple profiling.Here is an example, calling prof_flag() with a description at each checkpoint, and prof_print() at the end:Output looks like this:Start   0.004303Connect to DB   0.003518Perform query   0.000308Retrieve data   0.000009Close DB   0.000049DoneIf subtracting microtimes gives you negative results, try using the function with the argument true (microtime(true)). With true, the function returns a float instead of a string (as it does if it is called without arguments).Honestly, I am going to argue that using NewRelic for profiling is the best.It\'s a PHP extension which doesn\'t seem to slow down runtime at all and they do the monitoring for you, allowing decent drill down.  In the expensive version they allow heavy drill down (but we can\'t afford their pricing model).Still, even with the free/standard plan, it\'s obvious and simple where most of the low hanging fruit is.  I also like that it can give you an idea on DB interactions too.PECL XHPROF looks interensting too. It has clickable HTML interface for viewing reports and pretty straightforward documentation. I have yet to test it though.I like to use phpDebug for profiling.\nhttp://phpdebug.sourceforge.net/www/index.htmlIt outputs all time / memory usage for any SQL used as well as all the included files. Obviously, it works best on code that\'s abstracted. For function and class profiling I\'ll just use microtime() + get_memory_usage() + get_peak_memory_usage(). I would defiantly give BlackFire a try. There is this virtualBox I\'ve put together using puphpet, to test different php frameworks which coms with BlackFire, please feel free to fork and/or distribute if required :) https://github.com/webit4me/PHPFrameworksFor benchmarking, like in your example, I use the pear Benchmark package. You set markers for measuring. The class also provides a few presentation helpers, or you can process the data as you see fit.I actually have it wrapped in another class with a __destruct method. When a script exits, the output is logged via log4php to syslog, so I have a lot of performance data to work from.Poor man\'s profiling, no extensions required. Supports nested profiles and percent of total:Example:Yields:XDebug is not stable and it\'s not always available for particular php version. For example on some servers I still run php-5.1.6, -- it\'s what comes with RedHat RHEL5 (and btw still receives updates for all important issues), and recent XDebug does not even compile with this php. So I ended up with switching to DBG debugger\nIts php benchmarking provides timing for functions, methods, modules and even lines.Cross posting my reference from SO Documentation beta which is going offline.An extension to PHP called Xdebug is available to assist in profiling PHP applications, as well as runtime debugging.  When running the profiler, the output is written to a file in a binary format called "cachegrind".  Applications are available on each platform to analyze these files.  Node application code changes are necessary to perform this profiling.To enable profiling, install the extension and adjust php.ini settings. Some Linux distributions come with standard packages (e.g. Ubuntu\'s php-xdebug package). In our example we will run the profile optionally based on a request parameter.  This allows us to keep settings static and turn on the profiler only as needed.Next use a web client to make a request to your application\'s URL you wish to profile, e.g.As the page processes it will write to a file with a name similar to By default the number in the filename is the process id which wrote it.  This is configurable with the xdebug.profiler_output_name setting.Note that it will write one file for each PHP request / process that is executed.  So, for example, if you wish to analyze a form post, one profile will be written for the GET request to display the HTML form.  The XDEBUG_PROFILE parameter will need to be passed into the subsequent POST request to analyze the second request which processes the form.  Therefore when profiling it is sometimes easier to run curl to POST a form directly.Once written the profile cache can be read by an application such as KCachegrind.This will display information including:Obviously performance tuning is very specific to each application\'s use cases.  In general it\'s good to look for:Note: Xdebug, and in particular its profiling features, are very resource intensive and slow down PHP execution.  It is recommended to not run these in a production server environment.