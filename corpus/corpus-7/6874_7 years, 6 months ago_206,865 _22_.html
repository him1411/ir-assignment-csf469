This question already has an answer here:Given a datasource like that:How can I find the index of the first car satisfying a certain condition with LINQ?EDIT:I could think of something like this but it looks horrible:Will it be the best to solve this with a plain old loop?An IEnumerable is not an ordered set.\nAlthough most IEnumerables are ordered, some (such as Dictionary or HashSet) are not.Therefore, LINQ does not have an IndexOf method.However, you can write one yourself:or the slightly shorterSimply do : E.g. It works! Think about it. The index of the first matching item equals the number of (not matching) item before it.I too dislike the horrible standard solution you already suggested in your question. Like the accepted answer I went for a plain old loop although with a slight modification:Note that it will return the number of items instead of -1 when there is no match. But let\'s ignore this minor annoyance for now. In fact the horrible standard solution crashes in that case and I consider returning an index that is out-of-bounds superior.What happens now is ReSharper telling me Loop can be converted into LINQ-expression. While most of the time the feature worsens readability, this time the result was awe-inspiring. So Kudos to the JetBrains.Therefore I consider it optimal in time and space while remaining readable.Of course you can always hide it behind an extension method. And what to do best when there is no match heavily depends on the context.I will make my contribution here... why? just because :p Its a different implementation, based on the Any LINQ extension, and a delegate. Here it is:Here is a little extension I just put together.Then you can call it like this.Here\'s an implementation of the highest-voted answer that returns -1 when the item is not found: