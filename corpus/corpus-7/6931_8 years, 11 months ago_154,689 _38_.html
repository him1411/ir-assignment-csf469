Given two absolute paths, e.g.How can one create a relative path that uses the second path as its base? In the example above, the result should be: ./stuff/xyz.datIt\'s a little roundabout, but why not use URI?  It has a relativize method which does all the necessary checks for you.Since Java 7 you can use the relativize method:Output:At the time of writing (June 2010), this was the only solution that passed my test cases. I can\'t guarantee that this solution is bug-free, but it does pass the included test cases. The method and tests I\'ve written depend on the FilenameUtils class from Apache commons IO.The solution was tested with Java 1.4. If you\'re using Java 1.5 (or higher) you should consider replacing StringBuffer with StringBuilder (if you\'re still using Java 1.4 you should consider a change of employer instead).The test cases that this passes areWhen using java.net.URI.relativize you should be aware of Java bug:\nJDK-6226081 (URI should be able to relativize paths with partial roots)At the moment, the relativize() method of URI will only  relativize URIs when one is a prefix of the other.Which essentially means java.net.URI.relativize will not create ".."\'s for you.The bug referred to in @Peter Mueller\'s answer is addressed by URIUtils in Apache HttpComponentsResolves a URI reference against a\n  base URI. Work-around for bug in\n  java.net.URI ()If you know the second string is part of the first:or if you really want the period at the beginning as in your example:Recursion produces a smaller solution.  This throws an exception if the result is impossible (e.g. different Windows disk) or impractical (root is only common directory.) My version is loosely based on Matt and Steve\'s versions:In Java 8 you can simple do (and in contrast to URI, it is bug free):Matt B\'s solution gets the number of directories to backtrack wrong -- it should be the length of the base path minus the number of common path elements, minus one (for the last path element, which is either a filename or a trailing "" generated by split). It happens to work with /a/b/c/ and /a/x/y/, but replace the arguments with /m/n/o/a/b/c/ and /m/n/o/a/x/y/ and you will see the problem. Also, it needs an else break inside the first for loop, or it will mishandle paths that happen to have matching directory names, such as /a/b/c/d/ and /x/y/c/z -- the c is in the same slot in both arrays, but is not an actual match. All these solutions lack the ability to handle paths that cannot be relativized to one another because they have incompatible roots, such as C:\\foo\\bar and D:\\baz\\quux. Probably only an issue on Windows, but worth noting.I spent far longer on this than I intended, but that\'s okay. I actually needed this for work, so thank you to everyone who has chimed in, and I\'m sure there will be corrections to this version too!And here are tests to cover several cases:Here is a solution other library free:Outputs[EDIT] actually it outputs on more ..\\ because of the source is file not a directory. Correct solution for my case is:Actually my other answer didn\'t work if the target path wasn\'t a child of the base path.This should work.Cool!! I need a bit of code like this but for comparing directory paths on Linux machines. I found that this wasn\'t working in situations where a parent directory was the target.Here is a directory friendly version of the method:I\'m assuming you have fromPath (an absolute path for a folder), and toPath (an absolute path for a folder/file), and your\'re looking for a path that with represent the file/folder in toPath as a relative path from fromPath (your current working directory is fromPath) then something like this should work:Lots of answers already here, but I found they didn\'t handle all cases, such as the base and target being the same. This function takes a base directory and a target path and returns the relative path. If no relative path exists, the target path is returned. File.separator is unnecessary.Here a method that resolves a relative path from a base path regardless they are in the same or in a different root:Passes D\xc3\xb3nal\'s tests, the only change - if no common root it returns target path (it could be already relative)If you\'re writing a Maven plugin, you can use Plexus\' PathTool:org.apache.ant has a FileUtils class with a getRelativePath method. Haven\'t tried it myself yet, but could be worthwhile to check it out.http://javadoc.haefelinger.it/org.apache.ant/1.7.1/org/apache/tools/ant/util/FileUtils.html#getRelativePath(java.io.File, java.io.File)Psuedo-code: