I search for a good way to copy a file (binary or text). I\'ve written several samples, everyone works. But I want hear the opinion of seasoned programmers.I missing good examples and search a way which works with C++.ANSI-C-WAYPOSIX-WAY (K&R use this in "The C programming language", more low-level)KISS-C++-Streambuffer-WAYCOPY-ALGORITHM-C++-WAYOWN-BUFFER-C++-WAYLINUX-WAY // requires kernel >= 2.6.33Environment Steps to reproduce Results (CPU TIME used) Filesize doesn\'t change.\nsha256sum print the same results.\nThe video file is still playable.  QuestionsDo you know a reason to avoid a solution?FSTREAM (KISS, Streambuffer)\nI really like this one, because it is really short and simple. As far is I know the operator << is overloaded for rdbuf() and doesn\'t convert anything. Correct?ThanksUpdate 1\nI changed the source in all samples in that way, that the open and close of the file descriptors is include in the measurement of clock(). Their are no other significant changes in the source code. The results doesn\'t changed! I also used time to double-check my results.  Update 2\nANSI C sample changed: The condition of the while-loop doesn\'t call any longer feof() instead I moved fread() into the condition. It looks like, the code runs now 10,000 clocks faster.  Measurement changed: The former results were always buffered, because I repeated the old command line rm to.ogv && sync && time ./program for each program a few times. Now I reboot the system for every program. The unbuffered results are new and show no surprise. The unbuffered results didn\'t changed really.If i don\'t delete the old copy, the programs react different. Overwriting a existing file buffered is faster with POSIX and SENDFILE, all other programs are slower. Maybe the options truncate or create have a impact on this behaviour. But overwriting existing files with the same copy is not a real world use-case.  Performing the copy with cp takes 0.44 seconds unbuffered und 0.30 seconds buffered. So cp is a little bit slower than the POSIX sample. Looks fine for me.  Maybe I add also samples and results of mmap() and copy_file() from boost::filesystem.Update 3\nI\'ve put this also on a blog page and extended it a little bit. Including splice(), which is a low-level function from the Linux kernel. Maybe more samples with Java will follow.\nhttp://www.ttyhoney.com/blog/?page_id=69Copy a file in a sane way:This is so simple and intuitive to read it is worth the extra cost. If we were doing it a lot, better to fall back on OS calls to the file system. I am sure boost has a copy file method in its filesystem class. There is a C method for interacting with the file system:With C++17 the standard way to copy a file will be including the <filesystem> header and using:The first form is equivalent to the second one with copy_options::none used as options (see also copy_file).The filesystem library was originally developed as boost.filesystem and finally merged to ISO C++ as of C++17.Too many!The "ANSI C" way buffer is redundant, since a FILE is already buffered. (The size of this internal buffer is what BUFSIZ actually defines.)The "OWN-BUFFER-C++-WAY" will be slow as it goes through fstream, which does a lot of virtual dispatching, and again maintains internal buffers or each stream object. (The "COPY-ALGORITHM-C++-WAY" does not suffer this, as the streambuf_iterator class bypasses the stream layer.)I prefer the "COPY-ALGORITHM-C++-WAY", but without constructing an fstream, just create bare std::filebuf instances when no actual formatting is needed.For raw performance, you can\'t beat POSIX file descriptors. It\'s ugly but portable and fast on any platform.The Linux way appears to be incredibly fast \xe2\x80\x94 perhaps the OS let the function return before I/O was finished? In any case, that\'s not portable enough for many applications.EDIT: Ah, "native Linux" may be improving performance by interleaving reads and writes with asynchronous I/O. Letting commands pile up can help the disk driver decide when is best to seek. You might try Boost Asio or pthreads for comparison. As for "can\'t beat POSIX file descriptors"\xe2\x80\xa6 well that\'s true if you\'re doing anything with the data, not just blindly copying.I want to make the very important note that the LINUX method using sendfile() has a major problem in that it can not copy files more than 2GB in size! I had implemented it following this question and was hitting problems because I was using it to copy HDF5 files that were many GB in size.http://man7.org/linux/man-pages/man2/sendfile.2.htmlsendfile() will transfer at most 0x7ffff000 (2,147,479,552) bytes,\n  returning the number of bytes actually transferred.  (This is true on\n  both 32-bit and 64-bit systems.)Qt has a method for copying files:Note that to use this you have to install Qt (instructions here) and include it in your project (if you\'re using Windows and you\'re not an administrator, you can download Qt here instead). Also see this answer.