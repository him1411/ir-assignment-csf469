There are a group of private methods in my class, and I need to call one dynamically based on an input value. Both the invoking code and the target methods are in the same instance. The code looks like this:In this case, GetMethod() will not return private methods. What BindingFlags do I need to supply to GetMethod() so that it can locate private methods?Simply change your code to use the overloaded version of GetMethod that accepts BindingFlags:Here\'s the BindingFlags enumeration documentation.BindingFlags.NonPublic will not return any results by itself. As it turns out, combining it with BindingFlags.Instance does the trick.And if you really want to get yourself in trouble, make it easier to execute by writing an extension method:And usage:Are you absolutely sure this can\'t be done through inheritance?  Reflection is the very last thing you should look at when solving a problem, it makes refactoring, understanding your code, and any automated analysis more difficult.It looks like you should just have a DrawItem1, DrawItem2, etc class that override your dynMethod.Microsoft recently modified the reflection API rendering most of these answers obsolete. The following should work on modern platforms (including Xamarin.Forms and UWP):Or as an extension method:Note:If the desired method is in a superclass of obj the T generic must be explicitly set to the type of the superclass. If the method is asynchronous you can use await (Task) obj.InvokeMethod(\xe2\x80\xa6).Could you not just have a different Draw method for each type that you want to Draw?  Then call the overloaded Draw method passing in the object of type itemType to be drawn.Your question does not make it clear whether itemType genuinely refers to objects of differing types.I think you can pass it BindingFlags.NonPublic where it is the GetMethod method.Private members reflection breaks encapsulation principle and thus exposing your code to the following :There are so cases, when you depend on a third party or you need some api not exposed, you have to do some reflection. Some also use it to test some classes they own but that they don\'t want to change the interface to give access to the inner members just for tests.To mitigate the easy to break issue, the best is to detect any potential break by testing in unit tests that would run in a continuous integration build or such. Of course, it means you always use the same assembly (which contains the private members). If you use a dynamic load and reflection, you like play with fire, but you can always catch the Exception that the call may produce.In the recent versions of .Net Framework, CreateDelegate beat by a factor 50 the MethodInfo invoke: draw calls will be around 50x faster than MethodInfo.Invoke\nuse draw as a standard Func like that:Check this post of mine to see benchmark on different method invocationsBindingFlags.NonPublic