Can someone explain how these three methods of slicing are different?\nI\'ve seen the docs, \nand I\'ve seen these answers, but I still find myself unable to explain how the three are different.  To me, they seem interchangeable in large part, because they are at the lower levels of slicing.For example, say we want to get the first five rows of a DataFrame.  How is it that all three of these work?Can someone present three cases where the distinction in uses are clearer?Note: in pandas version 0.20.0 and above, ix is deprecated and the use of loc and iloc is encouraged instead. I have left the parts of this answer that describe ix intact as a reference for users of earlier versions of pandas. Examples have been added below showing alternatives to  ix.First, a recap:It\'s important to note some subtleties that can make ix slightly tricky to use:if the index is of integer type, ix will only use label-based indexing and not fall back to position-based indexing. If the label is not in the index, an error is raised.if the index does not contain only integers, then given an integer, ix will immediately use position-based indexing rather than label-based indexing. If however ix is given another type (e.g. a string), it can use label-based indexing. To illustrate the differences between the three methods, consider the following Series:Then s.iloc[:3] returns the first 3 rows (since it looks at the position) and s.loc[:3] returns the first 8 rows (since it looks at the labels):Notice s.ix[:3] returns the same Series as s.loc[:3] since it looks for the label first rather than going by position (and the index is of integer type).What if we try with an integer label that isn\'t in the index (say 6)?Here s.iloc[:6] returns the first 6 rows of the Series as expected. However, s.loc[:6] raises a KeyError since 6 is not in the index. As per the subtleties noted above, s.ix[:6] now raises a KeyError because it tries to work like loc but can\'t find a 6 in the index. Because our index is of integer type it doesn\'t fall back to behaving like iloc.If, however, our index was of mixed type, given an integer ix would behave like iloc immediately instead of raising a KeyError:Keep in mind that ix can still accept non-integers and behave like loc:As general advice, if you\'re only indexing using labels, or only indexing using integer positions, stick with loc or iloc to avoid unexpected results - try not use ix.Sometimes given a DataFrame, you will want to mix label and positional indexing methods for the rows and columns.For example, consider the following DataFrame. How best to slice the rows up to and including \'c\' and take the first four columns?In earlier versions of pandas (before 0.20.0) ix lets you do this quite neatly - we can slice the rows by label and the columns by position (note that for the columns, ix default to position-based slicing since the label 4 is not a column name):In later versions of pandas, we can achieve this result using iloc and the help of another method:get_loc() is an index method meaning "get the position of the label in this index". Note that since slicing with iloc is exclusive of its endpoint, we must add 1 to this value if we want row \'c\' as well.There are further examples in pandas\' documentation here.iloc works based on integer positioning. So no matter what your row labels are, you can always, e.g., get the first row by doingor the last five rows by doingYou can also use it on the columns. This retrieves the 3rd column:You can combine them to get intersections of rows and columns:On the other hand, .loc use named indices. Let\'s set up a data frame with strings as row and column labels:Then we can get the first row byand the second two rows of the \'date\' column by and so on. Now, it\'s probably worth pointing out that the default row and column indices for a DataFrame are integers from 0 and in this case iloc and loc would work in the same way. This is why your three examples are equivalent. If you had a non-numeric index such as strings or datetimes, df.loc[:5] would raise an error. Also, you can do column retrieval just by using the data frame\'s __getitem__:Now suppose you want to mix position and named indexing, that is, indexing using names on rows and positions on columns (to clarify, I mean select from our data frame, rather than creating a data frame with strings in the row index and integers in the column index). This is where .ix comes in:EDIT:\nI think it\'s also worth mentioning that you can pass boolean vectors to the loc method as well. For example:Will return the 1st and 3rd rows of df. This is equivalent to df[b] for selection, but it can also be used for assigning via boolean vectors: 