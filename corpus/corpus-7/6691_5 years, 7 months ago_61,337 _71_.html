I\'ve been trying to study up on PHP lately, and I find myself getting hung up on traits. I understand the concept of horizontal code reuse and not wanting to necessarily inherit from an abstract class. What I don\'t understand is what is the crucial difference between using traits versus interfaces?I\'ve tried searching for a decent blog post or article explaining when to use one or the other, but the examples I\'ve found so far seem so similar as to be identical.Could anyone out there share their opinion/view on this?An interface defines a set of methods that the implementing class must implement.When a trait is use\'d the implementations of the methods come along too--which doesn\'t happen in an Interface.That is the biggest difference.From the Horizontal Reuse for PHP RFC:Traits is a mechanism for code reuse in single inheritance languages such as PHP. A Trait is intended to reduce some limitations of single inheritance by enabling a developer to reuse sets of methods freely in several independent classes living in different class hierarchies.Public Service Announcement:I want to state for the record that I believe traits are almost always a code smell and should be avoided in favor of composition. It\'s my opinion that single inheritance is frequently abused to the point of being an anti-pattern and multiple inheritance only compounds this problem. You\'ll be much better served in most cases by favoring composition over inheritance (be it single or multiple). If you\'re still interested in traits and their relationship to interfaces, read on ...Let\'s start by saying this:Object-Oriented Programming (OOP) can be a difficult paradigm to grasp.\n  Just because you\'re using classes doesn\'t mean your code is\n  Object-Oriented (OO).To write OO code you need to understand that OOP is really about the capabilities of your objects. You\'ve got to think about classes in terms of what they can do instead of what they actually do. This is in stark contrast to traditional procedural programming where the focus is on making a bit of code "do something."If OOP code is about planning and design, an interface is the blueprint and an object is the fully constructed house. Meanwhile, traits are simply a way to help build the house laid out by the blueprint (the interface).So, why should we use interfaces? Quite simply, interfaces make our code less brittle. If you doubt this statement, ask anyone who\'s been forced to maintain legacy code that wasn\'t written against interfaces.The interface is a contract between the programmer and his/her code. The interface says, "As long as you play by my rules you can implement me however you like and I promise I won\'t break your other code."So as an example, consider a real-world scenario (no cars or widgets):You want to implement a caching system for a web application to cut\n  down on server loadYou start out by writing a class to cache request responses using APC:Then, in your http response object, you check for a cache hit before doing all the work to generate the actual response:This approach works great. But maybe a few weeks later you decide you want to use a file-based cache system instead of APC. Now you have to change your controller code because you\'ve programmed your controller to work with the functionality of the ApcCacher class rather than to an interface that expresses the capabilities of the ApcCacher class. Let\'s say instead of the above you had made the Controller class reliant on a CacherInterface instead of the concrete ApcCacher like so:To go along with that you define your interface like so:In turn you have both your ApcCacher and your new FileCacher classes implement the CacherInterface and you program your Controller class to use the capabilities required by the interface.This example (hopefully) demonstrates how programming to an interface allows you to change the internal implementation of your classes without worrying if the changes will break your other code.Traits, on the other hand, are simply a method for re-using code. Interfaces should not be thought of as a mutually exclusive alternative to traits. In fact, creating traits that fulfill the capabilities required by an interface is the ideal use case.You should only use traits when multiple classes share the same functionality (likely dictated by the same interface). There\'s no sense in using a trait to provide functionality for a single class: that only obfuscates what the class does and a better design would move the trait\'s functionality into the relevant class.Consider the following trait implementation:A more concrete example: imagine both your FileCacher and your ApcCacher from the interface discussion use the same method to determine whether a cache entry is stale and should be deleted (obviously this isn\'t the case in real life, but go with it). You could write a trait and allow both classes to use it to for the common interface requirement.One final word of caution: be careful not to go overboard with traits. Often traits are used as a crutch for poor design when unique class implementations would suffice. You should limit traits to fulfilling interface requirements for best code design.A trait is essentially PHP\'s implementation of a mixin, and is effectively a set of extension methods which can be added to any class through the addition of the trait. The methods then become part of that class\' implementation, but without using inheritance.From the PHP Manual (emphasis mine):Traits are a mechanism for code reuse in single inheritance languages such as PHP. ... It is an addition to traditional inheritance and enables horizontal composition of behavior; that is, the application of class members without requiring inheritance.An example:With the above trait defined, I can now do the following:At this point, when I create an instance of class MyClass, it has two methods, called foo() and bar() - which come from myTrait. And - notice that the trait-defined methods already have a method body - which an Interface-defined method can\'t.Additionally - PHP, like many other languages, uses a single inheritance model - meaning that a class can derive from multiple interfaces, but not multiple classes. However, a PHP class can have multiple trait inclusions - which allows the programmer to include reusable pieces - as they might if including multiple base classes.A few things to note:Polymorphism:In the earlier example, where MyClass extends SomeBaseClass, MyClass is an instance of SomeBaseClass. In other words, an array such as SomeBaseClass[] bases can contain instances of MyClass. Similarly, if MyClass extended IBaseInterface, an array of IBaseInterface[] bases could contain instances of MyClass. There is no such polymorphic construct available with a trait - because a trait is essentially just code which is copied for the programmer\'s convenience into each class which uses it.Precedence:As described in the Manual:An inherited member from a base class is overridden by a member inserted by a Trait. The precedence order is that members from the current class override Trait methods, which in return override inherited methods.So - consider the following scenario:When creating an instance of MyClass, above, the following occurs:ConclusionI think traits are useful to create classes that contain methods which can be used as methods of several different classes.For example:You can have and use this "error" method in any class that uses this trait.While with interfaces you can only declare the method signature, but not its functions\' code. Also, to use an interface you need to follow a hierarchy, using implements. This is not the case with traits.It is completely different!An often used metaphor to describe Traits is Traits are interfaces with implementation.This is a good way of thinking about it in most circumstances, but there are a number of subtle differences between the two.For a start, the instanceof operator will not work with traits (ie, a trait is not a real object) so you can\'t us that to see if a class has a certain trait (or to see if two otherwise unrelated classes share a trait). That\'s what they mean by it being a construct for horizontal code re-use.There are functions now in PHP that will let you get a list of all the traits a class uses, but trait-inheritance means you\'ll need to do recursive checks to reliably check if a class at some point has a specific trait (there\'s example code on the PHP doco pages). But yeah, it\'s certainly not as simple and clean as instanceof is, and IMHO it\'s a feature that would make PHP better.Also, abstract classes are still classes, so they don\'t solve multiple-inheritance related code re-use problems. Remember you can only extend one class (real or abstract) but implement multiple interfaces.I\'ve found traits and interfaces are really good to use hand in hand to create pseudo multiple inheritance. Eg:Doing this means you can use instanceof to determine if the particular Door object is Keyed or not, you know you\'ll get a consistent set of methods etc, and all the code is in one place across all the classes that use the KeyedTrait.Traits are simply for code reuse.Interface just provides the signature of the functions that is to be defined in the class where it can be used depending on the programmer\'s discretion. Thus giving us a prototype for a group of classes.For reference-\nhttp://www.php.net/manual/en/language.oop5.traits.phpYou can consider a Trait as an automated "copy-paste" of code, basically.Using Traits is dangerous since there is no mean to know what it does before execution.However, Traits are more flexible because of their lack of limitations such as inheritance.Traits can be useful to inject a method which checks something into a class, eg. the existence of anotherr method or attribute. A nice article on that (but in French, sorry)For French-reading people who can get it, the GNU/Linux Magazine HS 54 has an article on this subject.An interface is a contract that says \xe2\x80\x9cthis object is able to do this thing\xe2\x80\x9d, whereas a Trait is giving the object the ability to do the thing.A Trait is essentially a way to \xe2\x80\x9ccopy and paste\xe2\x80\x9d code between classes.try reading this articleThe main difference is that, with interfaces, you must define the actual implementation of each method within each class that implements said interface, so you can have many classes implement the same interface but with different behavior, while traits are just chunks of code injected in a class; another important difference is that trait methods can only be class-methods or static-methods, unlike interface methods which can also (and usually are) be instance methods.If you know English and know what trait means, it is exactly what the name says. It is a class-less pack of methods and properties you attach to existing classes by typing use. Basically, you could compare it to a single variable. Closures functions can use these variables from outside of the scope and that way they have the value inside. They are powerful and can be used in everything. Same happens to traits if they are being used.