Is there a way to immediately stop execution of a SQL script in SQL server, like a "break" or "exit" command?I have a script that does some validation and lookups before it starts doing inserts, and I want it to stop if any of the validations or lookups fail.The raiserror methodThis will terminate the connection, thereby stopping the rest of the script from running.Note that both severity level 20 or higher and the WITH LOG option are necessary for it to work this way.This even works with GO statements, eg.Will give you the output:Notice that \'ho\' is not printed.CAVEATS:Reference: http://www.mydatabasesupport.com/forums/ms-sqlserver/174037-sql-server-2000-abort-whole-script.html#post761334The noexec methodAnother method that works with GO statements is set noexec on. This causes the rest of the script to be skipped over. It does not terminate the connection, but you need to turn noexec off again before any commands will execute.Example:Just use a RETURN (it will work both inside and outside a stored procedure).If you can use SQLCMD mode, then the incantation (INCLUDING the colon) will cause RAISERROR to actually stop the script.  E.g.,will output:and the batch will stop.  If SQLCMD mode isn\'t turned on, you\'ll get parse error about the colon.  Unfortuantely, it\'s not completely bulletproof as if the script is run without being in SQLCMD mode, SQL Managment Studio breezes right past even parse time errors!    Still, if you\'re running them from the command line, this is fine.I would not use RAISERROR- SQL has IF statements that can be used for this purpose.  Do your validation and lookups and set local variables, then use the value of the variables in IF statements to make the inserts conditional.You wouldn\'t need to check a variable result of every validation test. You could usually do this with only one flag variable to confirm all conditions passed:Even if your validation is more complex, you should only need a few flag variables to include in your final check(s).you could wrap your SQL statement in a WHILE loop and use BREAK if neededI extended the noexec on/off solution successfully with a transaction to run the script in an all or nothing manner. Apparently the compiler "understands" the @finished variable in the IF, even if there was an error and the execution was disabled. However, the value is set to 1 only if the execution was not disabled. Hence I can nicely commit or rollback the transaction accordingly.In SQL 2012+, you can use THROW.From MSDN:Raises an exception and transfers execution to a CATCH block of a TRY\xe2\x80\xa6CATCH construct ... If a TRY\xe2\x80\xa6CATCH construct is not available, the session is ended. The line number and procedure where the exception is raised are set. The severity is set to 16.Further refinig Sglasses method, the above lines force the use of SQLCMD mode, and either treminates the scirpt if not using SQLCMD mode or uses :on error exit to exit on any error\nCONTEXT_INFO is used to keep track of the state.   Is this a stored procedure? If so, I think you could just do a Return, such as "Return NULL";I would suggest that you wrap your appropriate code block in a try catch block. You can then use the Raiserror event with a severity of 11 in order to break to the catch block if you wish. If you just want to raiserrors but continue execution within the try block then use a lower severity.Make sense?Cheers,\nJohn[Edited to include BOL Reference]http://msdn.microsoft.com/en-us/library/ms175976(SQL.90).aspxyou can use RAISERROR.None of these works with \'GO\' statements. In this code, regardless of whether the severity is 10 or 11, you get the final PRINT statement.Test Script:Results:RobThis was my solution:...You can alter the flow of execution using GOTO statements:You can use GOTO statement. Try this. This is use full for you.I use RETURN here all the time, works in script or SPMake sure you ROLLBACK the transaction if you are in one, otherwise RETURN immediately will result in an open uncommitted transactionThx for the answer!raiserror() works fine but you shouldn\'t forget the return statement otherwise the script continues without error! (hense the raiserror isn\'t a "throwerror" ;-)) and of course doing a rollback if necessary!raiserror() is nice to tell the person who executes the script that something went wrong.If you are simply executing a script in Management Studio, and want to stop execution or rollback transaction (if used) on first error, then the best way I reckon is to use try catch block (SQL 2005 onward).\nThis works well in Management studio if you are executing a script file.\nStored proc can always use this as well.