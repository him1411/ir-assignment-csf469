I have found an interesting performance regression in a small C++ snippet, when I enable C++11:With g++ (GCC) 4.8.2 20131219 (prerelease) and C++03 I get:With C++11 enabled on the other hand, the performance degrades significantly:Can someone explain this? So far my experience was that the STL gets faster by enabling C++11, esp. thanks to move semantics.EDIT: As suggested, using container.emplace_back(); instead the performance gets on par with the C++03 version. How can the C++03 version achieve the same for push_back?I can reproduce your results on my machine with those options you write in your post. However, if I also enable link time optimization (I also pass the -flto flag to gcc 4.7.2), the results are identical:(I am compiling your original code, with container.push_back(Item());)As for the reasons, one needs to look at the generated assembly code (g++ -std=c++11 -O3 -S regr.cpp). In C++11 mode the generated code is significantly more cluttered than for C++98 mode and inlining the function\nvoid std::vector<Item,std::allocator<Item>>::_M_emplace_back_aux<Item>(Item&&)\nfails in C++11 mode with the default inline-limit. This failed inline has a domino effect. Not because this function is being called \n(it is not even called!) but because we have to be prepared: If it is called,\nthe function argments (Item.a and Item.b) must already be at the right place. This leads to \na pretty messy code.Here is the relevant part of the generated code for the case where inlining succeeds:This is a nice and compact for loop. Now, let\'s compare this to that of the failed inline case:This code is cluttered and there is a lot more going on in the loop than in the previous case. \nBefore the function call (last line shown), the arguments must be placed appropriately:Even though this is never actually executed, the loop arranges the things before:This leads to the messy code. If there is no function call because inlining succeeds, \nwe have only 2 move instructions in the loop and there is no messing going with the %rsp (stack pointer). However, if the inlining fails, we get 6 moves and we mess a lot with the %rsp.Just to substantiate my theory (note the -finline-limit), both in C++11 mode:Indeed, if we ask the compiler to try just a little bit harder to inline that function, the difference in performance goes away.So what is the take away from this story? That failed inlines can cost you a lot and you should make full use of the compiler capabilities: I can only recommend link time optimization. It gave a significant performance boost to my programs (up to 2.5x) and all I needed to do is to pass the -flto flag. That\'s a pretty good deal! ;)However, I do not recommend trashing your code with the inline keyword; let the compiler decide what to do. (The optimizer is allowed to treat the inline keyword as white space anyway.)Great question, +1!