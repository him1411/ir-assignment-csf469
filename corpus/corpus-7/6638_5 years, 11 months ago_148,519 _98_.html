I\'m trying to use Fragment with a ViewPager using the FragmentPagerAdapter.\nWhat I\'m looking for to achieve is to replace a fragment, positioned on the first page of the ViewPager, with another one.The pager is composed of two pages. The first one is the FirstPagerFragment, the second one is the SecondPagerFragment. Clicking on a button of the first page. I\'d like to replace the FirstPagerFragment with the NextFragment.There is my code below....and here the xml filesfragment_pager.xmlfirst.xmlNow the problem... which ID should I use in?If I use R.id.first_fragment_root_id, the replacement works, but Hierarchy Viewer shows a strange behavior, as below.At the beginning the situation is\nafter the replacement the situation is\nAs you can see there is something wrong, I expect to find the same state shown as in the first picture after I replace the fragment.There is another solution that does not need modifying source code of ViewPager and FragmentStatePagerAdapter, and it works with the FragmentPagerAdapter base class used by the author.I\'d like to start by answering the author\'s question about which ID he should use; it is ID of the container, i.e. ID of the view pager itself. However, as you probably noticed yourself, using that ID in your code causes nothing to happen. I will explain why:First of all, to make ViewPager repopulate the pages, you need to call notifyDataSetChanged() that resides in the base class of your adapter.Second, ViewPager uses the getItemPosition() abstract method to check which pages should be destroyed and which should be kept. The default implementation of this function always returns POSITION_UNCHANGED, which causes ViewPager to keep all current pages, and consequently not attaching your new page. Thus, to make fragment replacement work, getItemPosition() needs to be overridden in your adapter and must return POSITION_NONE when called with an old, to be hidden, fragment as argument.This also means that your adapter always needs to be aware of which fragment that should be displayed in position 0, FirstPageFragment or NextFragment. One way of doing this is supplying a listener when creating FirstPageFragment, which will be called when it is time to switch fragments. I think this is a good thing though, to let your fragment adapter handle all fragment switches and calls to ViewPager and FragmentManager.Third, FragmentPagerAdapter caches the used fragments by a name which is derived from the position, so if there was a fragment at position 0, it will not be replaced even though the class is new. There are two solutions, but the simplest is to use the remove() function of FragmentTransaction, which will remove its tag as well.That was a lot of text, here is code that should work in your case:Hope this helps anyone!As of November 13th 2012, repacing fragments in a ViewPager seems to have become a lot easier. Google released Android 4.2 with support for nested fragments, and it\'s also supported in the new Android Support Library v11 so this will work all the way back to 1.6It\'s very similiar to the normal way of replacing a fragment except you use getChildFragmentManager. It seems to work except the nested fragment backstack isn\'t popped when the user clicks the back button. As per the solution in that linked question, you need to manually call the popBackStackImmediate() on the child manager of the fragment. So you need to override onBackPressed() of the ViewPager activity where you\'ll get the current fragment of the ViewPager and call getChildFragmentManager().popBackStackImmediate() on it.Getting the Fragment currently being displayed is a bit hacky as well, I used this dirty "android:switcher:VIEWPAGER_ID:INDEX" solution but you can also keep track of all fragments of the ViewPager yourself as explained in the second solution on this page.So here\'s my code for a ViewPager with 4 ListViews with a detail view shown in the ViewPager when the user clicks a row, and with the back button working. I tried to include just the relevant code for the sake of brevity so leave a comment if you want the full app uploaded to GitHub.HomeActivity.javaListProductsFragment.javaBased on @wize \'s answer, which I found helpful and elegant, I could achieve what I wanted partially, cause I wanted the cability to go back to the first Fragment once replaced. I achieved it bit modifying a bit his code.This would be the FragmentPagerAdapter:To perfom the replacement, simply define a static field, of the type CalendarPageFragmentListener and initialized through the newInstance methods of the corresponding fragments and call FirstFragment.pageListener.onSwitchToNextFragment() or NextFragment.pageListener.onSwitchToNextFragment() respictevely.Hope it is clear and helpful.\nBest Regards.I have implemented a solution for:The tricks to achieve this are the following:The adapter code is the following:The very first time you add all tabs, we need to call the method createHistory(), to create the initial historyEvery time you want to replace a fragment to a specific tab you call:\nreplace(final int position, final Class fragmentClass, final Bundle args)On back pressed you need to call the back() method:The solution works with sherlock action bar and with swipe gesture.To replace a fragment inside a ViewPager you can move source codes of ViewPager, PagerAdapter and FragmentStatePagerAdapter classes into your project and add following code.into ViewPager:into FragmentStatePagerAdapter:handleGetItemInbalidated() ensures that after next call of getItem() it return newFragment\ngetFragmentPosition() returns position of the fragment in your adapter.Now, to replace fragments call If you interested in an example project ask me for the sources.I have created a ViewPager with 3 elements and 2 sub elements for index 2 and 3 and here what I wanted to do..I have implemented this with the help from previous questions and answers from StackOverFlow and here is the link.ViewPagerChildFragments\nSome of the presented solutions helped me a lot to partially solve the problem but there is still one important thing missing in the solutions which has produced unexpected exceptions and black page content instead of fragment content in some cases.The thing is that FragmentPagerAdapter class is using item ID to store cached fragments to FragmentManager. For this reason, you need to override also the getItemId(int position) method so that it returns e. g. position for top-level pages and 100 + position for details pages. Otherwise the previously created top-level fragment would be returned from the cache instead of detail-level fragment.Furthermore, I\'m sharing here a complete example how to implement tabs-like activity with Fragment pages using ViewPager and tab buttons using RadioGroup that allows replacement of top-level pages with detailed pages and also supports back button. This implementation supports only one level of back stacking (item list - item details) but multi-level back stacking implementation is straightforward. This example works pretty well in normal cases except of it is throwing a NullPointerException in case when you switch to e. g. second page, change the fragment of the first page (while not visible) and return back to the first page. I\'ll post a solution to this issue once I\'ll figure it out:Works Great with AndroidTeam\'s solution, however I found that I needed the ability to go back much like FrgmentTransaction.addToBackStack(null)  But merely adding this will only cause the Fragment to be replaced  without notifying the ViewPager. Combining the provided solution with this minor enhancement will allow you to return to the previous state by merely overriding the activity\'s onBackPressed() method. The biggest drawback is that it will only go back one at a time which may result in multiple back clicksHope this helps someone.Also as far as getFragmentPosition() goes it\'s pretty much getItem() in reverse. You know which fragments go where, just make sure you return the correct position it will be in. Here\'s an example:tl;dr: Use a host fragment that is responsible for replacing its hosted content and keeps track of a back navigation history (like in a browser).As your use case consists of a fixed amount of tabs my solution works well: The idea is to fill the ViewPager with instances of a custom class HostFragment, that is able to replace its hosted content and keeps its own back navigation history. To replace the hosted fragment you make a call to the method hostfragment.replaceFragment():All that method does is to replace the frame layout with the id R.id.hosted_fragment with the fragment provided to the method.Check my tutorial on this topic for further details and a complete working example on GitHub!I also made a solution, which is working with Stacks. It\'s a more modular approach so u don\'t have to specify each Fragment and Detail Fragment in your FragmentPagerAdapter. It\'s build on top of the Example from ActionbarSherlock which derives if I\'m right from the Google Demo App.Add this for back button functionality in your MainActivity:If u like to save the Fragment State when it get\'s removed. Let your Fragment implement the interface SaveStateBundle return in the function a bundle with your save state. Get the bundle after instantiation by this.getArguments().You can instantiate a tab like this:works similiar if u want to add a Fragment on top of a Tab Stack. \nImportant: I think, it won\'t work if u want to have 2 instances of same class on top of two Tabs.\nI did this solution quick together, so I can only share it without providing any experience with it.Replacing fragments in a viewpager is quite involved but is very possible and can look super slick. First, you need to let the viewpager itself handle the removing and adding of the fragments. What is happening is when you replace the fragment inside of SearchFragment, your viewpager retains its fragment views. So you end up with a blank page because the SearchFragment gets removed when you try to replace it.The solution is to create a listener inside of your viewpager that will handle changes made outside of it so first add this code to the bottom of your adapter.Then you need to create a private class in your viewpager that becomes a listener for when you want to change your fragment. For example you could add something like this. Notice that it implements the interface that was just created. So whenever you call this method, it will run the code inside of the class below.There are two main things to point out here: Notice the listeners that are placed in the \'newInstance(listener)constructor.  These are how you will callfragment0Changed(String newFragmentIdentification)`. The following code shows how you create the listener inside of your fragment.static nextFragmentListener listenerSearch;You could call the change inside of your onPostExecuteThis would trigger the code inside of your viewpager to switch your fragment at position zero fragAt0 to become a new searchResultFragment. There are two more small pieces you would need to add to the viewpager before it became functional.One would be in the getItem override method of the viewpager.Now without this final piece you would still get a blank page. Kind of lame, but it is an essential part of the viewPager. You must override the getItemPosition method of the viewpager. Ordinarily this method will return POSITION_UNCHANGED which tells the viewpager to keep everything the same and so getItem will never get called to place the new fragment on the page. Here\'s an example of something you could doLike I said, the code gets very involved, but you basically have to create a custom adapter for your situation. The things I mentioned will make it possible to change the fragment. It will likely take a long time to soak everything in so I would be patient, but it will all make sense. It is totally worth taking the time because it can make a really slick looking application.Here\'s the nugget for handling the back button. You put this inside your MainActivityYou will need to create a method called backPressed() inside of FragmentSearchResults that calls fragment0changed. This in tandem with the code I showed before will handle pressing the back button. Good luck with your code to change the viewpager. It takes a lot of work, and as far as I have found, there aren\'t any quick adaptations. Like I said, you are basically creating a custom viewpager adapter, and letting it handle all of the necessary changes using listenersIn your onCreateView method, container is actually a ViewPager instance.So, just calling will change current fragment in your ViewPager.Here\'s my relatively simple solution to this problem.  The keys to this solution are to use FragmentStatePagerAdapter instead of FragmentPagerAdapter as the former will remove unused fragments for you while the later still retains their instances.  The second is the use of POSITION_NONE in getItem().  I\'ve used a simple List to keep track of my fragments.  My requirement was to replace the entire list of fragments at once with a new list, but the below could be easily modified to replace individual fragments:I doing something to similar to wize but in my answer yo can change between the two fragments whenever you want. And with the wize answer I have some problems when changing the orientation of the screen an things like that. This is the PagerAdapter looks like:The listener I implemented in the adapter container activity to put it to the fragment when attaching it, this is the activity:Then in the fragment putting the listener when attach an calling it:And finally the listener:I followed the answers by @wize and @mdelolmo and I got the solution. Thanks Tons. But, I tuned these solutions a little bit to improve the memory consumption.Problems I observed:They save the instance of Fragment which is replaced. In my case, it is a Fragment which holds MapView and I thought its costly. So, I am maintaining the FragmentPagerPositionChanged (POSITION_NONE or POSITION_UNCHANGED) instead of Fragment itself.Here is my implementation.Demo link here.. https://youtu.be/l_62uhKkLyMFor demo purpose, used 2 fragments TabReplaceFragment and DemoTab2Fragment at position two. In all the other cases I\'m using DemoTabFragment instances.Explanation:I\'m passing Switch from Activity to the DemoCollectionPagerAdapter. Based on the state of this switch we will display correct fragment. When the switch check is changed, I\'m calling the SwitchFragListener\'s onSwitchToNextFragment method, where I\'m changing the value of pagerAdapterPosChanged variable to POSITION_NONE. Check out more about POSITION_NONE. This will invalidate the getItem and I have logics to instantiate the right fragment over there. Sorry, if the explanation is a bit messy.Once again big thanks to @wize and @mdelolmo for the original idea.Hope this is helpful. :) Let me know if this implementation has any flaws. That will be greatly helpful for my project.I found simple solution, which works fine even if you want add new fragments in the middle or replace current fragment. In my solution you should override getItemId() which should return unique id for each fragment. Not position as by default. There is it:Notice: In this example FirstFragment and SecondFragment extends abstract class PageFragment, which has method getPage().after research i found solution with short code.\nfirst of all create a public instance on fragment and just remove your fragment on onSaveInstanceState if fragment not recreating on orientation change.