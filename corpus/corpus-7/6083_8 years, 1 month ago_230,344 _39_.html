I have a couple of properties in C# which are double and I want to store these in a table in SQL Server, but noticed there is no double type, so what is best to use, decimal or float?This will store latitude and longitude values, so I need the most accurate precision.Thanks for the responses so far.Or if you want to go old-school:You can also use float(53), but it means the same thing as float.("real" is equivalent to float(24), not float/float(53).)The decimal(x,y) SQL Server type is for when you want exact decimal numbers rather than floating point (which can be approximations). This is in contrast to the C# "decimal" data type, which is more like a 128-bit floating point number.MSSQL float does not have exactly the same precision as the 64-bit double type in .NET (slight difference in mantissa IIRC), but it\'s a close enough match most uses.To make things more confusing, a "float" in C# is only 32-bit, so it would be more equivalent in SQL to the real/float(24) type in MSSQL than float/float(53).In your specific use case...\nAll you need is 5 places after the decimal point to represent latitude and longitude within about one-meter precision, and you only need up to three digits before the decimal point for the degrees. Float(24) or decimal(8,5) will best fit your needs in MSSQL, and using float in C# is good enough, you don\'t need double. In fact, your users will probably thank you for rounding to 5 decimal places rather than having a bunch of insignificant digits coming along for the ride.Here are the CLR datatype mappings to SQL Server: http://msdn.microsoft.com/en-us/library/system.data.sqldbtype.aspxAs most others have noted, float is the correct answer.  See Microsoft\'s documentation on SQL Server - CLR datatype mapping for more information.Also, here is a good answer for SQL-CLR Type Mapping with a useful chart.From that post (by David):\nfloat is the closest equivalent.SqlDbType EnumerationEdit: For Lat/Long as OP mentioned.A metre is 1/40,000,000 of the latitude, 1 second is around 30 metres. Float/double give you 15 significant figures. With some quick and dodgy mental arithmetic... the rounding/approximation errors would be the about the length of this fill stop -> "."You should map it to FLOAT(53)- that\'s what LINQ to SQL does.float in SQL Server actually has [edit:almost] the precision of a "double" (in a C# sense).float is a synonym for float(53). 53 is the bits of the mantissa..NET double uses 54 bits for the mantissa.There is a great thread on MSDN describing the primary difference between FLOAT and DECIMAL.  In short, Float is approximate and cannot represent some values.Look at the accepted answer.For SQL Sever:Decimal Type is 128 bit signed number\nFloat is a 64 bit signed number.The real answer is Float, I was incorrect about decimal.The reason is if you use a decimal you will never fill 64 bit of the decimal type.Although decimal won\'t give you an error if you try to use a int type.Here is a nice reference chart of the types.It sounds like you can pick and choose.  If you pick float, you may lose 11 digits of precision.  If that\'s acceptable, go for it -- apparently the Linq designers thought this to be a good tradeoff.However, if your application needs those extra digits, use decimal.  Decimal (implemented correctly) is way more accurate than a float anyway -- no messy translation from base 10 to base 2 and back.@Achilles Excellent! Came here for the double stayed for the TinyInt.Here is a partially done switch case to convert between dataTable and SQL: The string can be a problem be sure to edit it to your needs, but the double should work which is the question at hand. Aren\'t there already mappings in the System.Data.Sql classes?See: C#: SQL Server data types equivalents in .NET Framework.Now, make mine a float...