The above python code is giving me following error:If you use Python3x then string is not the same type as for Python 2.x, you must cast it to bytes (encode it).Also do not use variable names like string or file while those are names of module or function.EDIT @TomYes, non-ASCII text is also compressed/decompressed. I use Polish letters with UTF-8 encoding:There is an easier solution to this problem.You just need to add a t to the mode so it becomes wt. This causes Python to open the file as a text file and not binary. Then everything will just work.The complete program becomes this:You can not serialize a Python 3 \'string\' to bytes without explict conversion to some encoding.is possibly what you want. Also this works for both python 2.x and 3.x.For Python 3.x you can convert your text to raw bytes through:For example:The object returned will work with outfile.write.This problem commonly occurs when switching from py2 to py3. In py2 plaintext is both a string and a byte array type. In py3 plaintext is only a string, and the method outfile.write() actually takes a byte array when outfile is opened in binary mode, so an exception is raised. Change the input to plaintext.encode(\'utf-8\') to fix the problem. Read on if this bothers you.   In py2, the declaration for file.write made it seem like you passed in a string: file.write(str). Actually you were passing in a byte array, you should have been reading the declaration like this: file.write(bytes). If you read it like this the problem is simple, file.write(bytes) needs a bytes type and in py3 to get bytes out of a str you convert it:Why did the py2 docs declare file.write took a string? Well in py2 the declaration distinction didn\'t matter because: The str-bytes class of py2 has methods/constructors that make it behave like a string class in some ways and a byte array class in others. Convenient for file.write isn\'t it?:Why did py3 break this nice system? Well because in py2 basic string functions didn\'t work for the rest of the world. Measure the length of a word with a non-ASCII character?All this time you thought you were asking for the len of a string in py2, you were getting the length of the byte array from the encoding. That ambiguity is the fundamental problem with double-duty classes. Which version of any method call do you implement?The good news then is that py3 fixes this problem. It disentangles the str and bytes classes. The str class has string-like methods, the separate bytes class has byte array methods:Hopefully knowing this helps de-mystify the issue, and makes the migration pain a little easier to bear. Well if useful for you in case removing annoying \'b\' character.If anyone got better idea please suggest me or feel free to edit me anytime in here.I\'m just newbieFor Django in django.test.TestCase unit testing, I changed my Python2 syntax:To use the Python3 .decode(\'utf8\') syntax: