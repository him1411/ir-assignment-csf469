What is decaying of an array? Is there any relation to array pointers?It\'s said that arrays "decay" into pointers.  A C++ array declared as int numbers [5] cannot be re-pointed, i.e. you can\'t say numbers = 0x5a5aff23. More importantly the term decay signifies loss of type and dimension; numbers decay into int* by losing the dimension information (count 5) and the type is not int [5] any more. Look here for cases where the decay doesn\'t happen.If you\'re passing an array by value, what you\'re really doing is copying a pointer - a pointer to the array\'s first element is copied to the parameter (whose type should also be a pointer the array element\'s type). This works due to array\'s decaying nature; once decayed, sizeof no longer gives the complete array\'s size, because it essentially becomes a pointer.  This is why it\'s preferred (among other reasons) to pass by reference or pointer.Three ways to pass in an array1:The last two will give proper sizeof info, while the first one won\'t since the array argument has decayed to be assigned to the parameter.1 The constant U should be known at compile-time.Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):you lose the ability of the sizeof operator to count elements in the array:This lost ability is referred to as "decay".For more details, check out this article about array decay.Here\'s what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):Except when it is the operand of the sizeof operator or the unary & operator, or is a\n  string literal used to initialize an array, an expression that has type \xe2\x80\x98\xe2\x80\x98array of type\xe2\x80\x99\xe2\x80\x99 is\n  converted to an expression with type \xe2\x80\x98\xe2\x80\x98pointer to type\xe2\x80\x99\xe2\x80\x99 that points to the initial element of\n  the array object and is not an lvalue.This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn\'t cause nearly as much confusion as the automatic conversion of array names to pointers.The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):An lvalue or rvalue of type \xe2\x80\x9carray of N T\xe2\x80\x9d or \xe2\x80\x9carray of unknown bound of T\xe2\x80\x9d can be converted to an rvalue\n  of type \xe2\x80\x9cpointer to T.\xe2\x80\x9dSo the conversion doesn\'t have to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I\'m not sure if there\'s any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn\'t lying."Decay" refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from "N-element array of T" to "pointer to T" and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the sizeof or & operators, or the array is a string literal being used as an initializer in a declaration.  Assume the following code:The expression a is of type "80-element array of char" and the expression "This is a test" is of type "16-element array of char" (in C; in C++ string literals are arrays of const char).  However, in the call to strcpy(), neither expression is an operand of sizeof or &, so their types are implicitly converted to "pointer to char", and their values are set to the address of the first element in each.  What strcpy() receives are not arrays, but pointers, as seen in its prototype:This is not the same thing as an array pointer.  For example:Both ptr_to_first_element and ptr_to_array have the same value; the base address of a.  However, they are different types and are treated differently, as shown below:Remember that the expression a[i] is interpreted as *(a+i) (which only works if the array type is converted to a pointer type), so both a[i] and ptr_to_first_element[i] work the same. The expression (*ptr_to_array)[i] is interpreted as *(*a+i).  The expressions *ptr_to_array[i] and ptr_to_array[i] may lead to compiler warnings or errors depending on the context; they\'ll definitely do the wrong thing if you\'re expecting them to evaluate to a[i].Again, when an array is an operand of sizeof, it\'s not converted to a pointer type.  ptr_to_first_element is a simple pointer to char.  Arrays, in C, have no value.Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type pointer to (type of array elements).In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it "decays into a pointer" (sic); when you compare an array to something else, again it "decays into a pointer" (sic); ...Function foo expects the value of an array. But, in C, arrays have no value! So foo gets instead the address of the first element of the array.In the comparison above, arr has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable ip.In the array indexing syntax you are used to seeing, again, the arr is \'decayed to a pointer\'The only times an array doesn\'t decay into a pointer are when it is the operand of the sizeof operator, or the & operator (the \'address of\' operator), or as a string literal used to initialize a character array.It\'s when array rots and is being pointed at ;-)Actually, it\'s just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.Array decaying means that, when an array is passed as a parameter to a function, it\'s treated identically to ("decays to") a pointer.There are two complications or exceptions to the above.First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like strcpy_s, and you can use a similar trick to reliably get the number of elements in an array.