What\'s the simplest way to add a click event handler to a canvas element that will return the x and y coordinates of the click (relative to the canvas element)?No legacy browser compatibility required, Safari, Opera and Firefox will do.As described here:Worked perfectly fine for me.Update (5/5/16): patriques\' answer should be used instead, as it\'s both simpler and more reliable.Since the canvas isn\'t always styled relative to the entire page, the canvas.offsetLeft/Top doesn\'t always return what you need. It will return the number of pixels it is offset relative to its offsetParent element, which can be something like a div element containing the canvas with a position: relative style applied. To account for this you need to loop through the chain of offsetParents, beginning with the canvas element itself. This code works perfectly for me, tested in Firefox and Safari but should work for all. The last line makes things convenient for getting the mouse coordinates relative to a canvas element. All that\'s needed to get the useful coordinates isIf you like simplicity but still want cross-browser functionality I found this solution worked best for me. This is a simplification of @Aldekein\xc2\xb4s solution but without jQuery.Modern browser\'s now handle this for you. Chrome, IE9, and Firefox support the offsetX/Y like this, passing in the event from the click handler.Most modern browsers also support layerX/Y, however Chrome and IE use layerX/Y for  the absolute offset of the click on the page including margin, padding, etc. In Firefox, layerX/Y and offsetX/Y are equivalent, but offset didn\'t previously exist. So, for compatibility with slightly older browsers, you can use:According to fresh Quirksmode the clientX and clientY methods are supported in all major browsers.\nSo, here it goes - the good, working code that works in a scrolling div on a page with scrollbars:This also requires jQuery for $(canvas).offset().I made a full demostration that works in every browser with the full source code of the solution of this problem: Coordinates of a mouse click on Canvas in Javascript. To try the demo, copy the code and paste it into a text editor. Then save it as example.html and, finally, open the file with a browser.Here is a small modification to Ryan Artecona\'s answer for canvases with a variable (%) width:Be wary while doing the coordinate conversion; there are multiple non-cross-browser values returned in a click event. Using clientX and clientY alone are not sufficient if the browser window is scrolled (verified in Firefox 3.5 and Chrome 3.0). This quirks mode article provides a more correct function that can use either pageX or pageY or a combination of clientX with document.body.scrollLeft and clientY with document.body.scrollTop to calculate the click coordinate relative to the document origin. UPDATE: Additionally, offsetLeft and offsetTop are relative to the padded size of the element, not the interior size. A canvas with the padding: style applied will not report the top-left of its content region as offsetLeft. There are various solutions to this problem; the simplest one may be to clear all border, padding, etc. styles on the canvas itself and instead apply them to a box containing the canvas.Here is a very nice tutorial-http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/hope this helps!I\'m not sure what\'s the point of all these answers that loop through parent elements and do all kinds of weird stuff.The HTMLElement.getBoundingClientRect method is designed to to handle actual screen position of any element. This includes scrolling, so stuff like scrollTop is not needed:(from MDN) The amount of scrolling that has been done of the viewport area (or\n  any other scrollable element) is taken into account when computing the\n  bounding rectangleThe very simplest approach was already posted here. This is correct as long as no wild CSS rules are involved.When image pixel width isn\'t matched by it\'s CSS width, you\'ll need to apply some ratio on pixel values:As long as the canvas has no border, it works for stretched images (jsFiddle).If the canvas has thick border, the things get little complicated. You\'ll literally need to subtract the border from the bounding rectangle. This can be done using .getComputedStyle. This answer describes the process.The function then grows up a little:I can\'t think of anything that would confuse this final function. See yourself at JsFiddle.If you don\'t like modifying the native prototypes, just change the function and call it with (canvas, event) (and replace any this with canvas).Using jQuery in 2016, to get click coordinates relative to the canvas, I do:This works since both canvas offset() and jqEvent.pageX/Y are relative to the document regardless of scroll position.Note that if your canvas is scaled then these coordinates are not the same as canvas logical coordinates.  To get those, you would also do:I recommend this link-\nhttp://miloq.blogspot.in/2011/05/coordinates-mouse-click-canvas.htmlIn Prototype, use cumulativeOffset() to do the recursive summation as mentioned by Ryan Artecona above.http://www.prototypejs.org/api/element/cumulativeoffsetYou could just do: This will give you the exact position of the mouse pointer.See demo at http://jsbin.com/ApuJOSA/1/edit?html,output .Hey, this is in dojo, just cause it\'s what I had the code in already for a project.It should be fairly Obvious how to convert it back to non dojo vanilla JavaScript. Hope that helps. Here is some modifications of the above Ryan Artecona\'s solution.First, as others have said, you need a function to get the position of the canvas element. Here\'s a method that\'s a little more elegant than some of the others on this page (IMHO). You can pass it any element and get its position in the document:Now calculate the current position of the cursor relative to that:Notice that I\'ve separated the generic findPos function from the event handling code. (As it should be. We should try to keep our functions to one task each.)The values of offsetLeft and offsetTop are relative to offsetParent, which could be some wrapper div node (or anything else, for that matter). When there is no element wrapping the canvas they\'re relative to the body, so there is no offset to subtract. This is why we need to determine the position of the canvas before we can do anything else.Similary, e.pageX and e.pageY give the position of the cursor relative to the document. That\'s why we subtract the canvas\'s offset from those values to arrive at the true position.An alternative for positioned elements is to directly use the values of e.layerX and e.layerY. This is less reliable than the method above for two reasons:ThreeJS r77After trying many solutions. This worked for me. Might help someone else hence posting. Got it from here