Does Javascript pass by references or pass by values? Here is an example from Javascript: The Good Parts. I am very confused about my parameter for the rectangle function. It is actually undefined, and redefined inside the function. There are no original reference. If I remove it from the function parameter, the inside area function is not able to access it. Is it a closure? But no function is returned.Primitives are passed by value, Objects are passed by "copy of a reference".Specifically, when you pass an object (or array) you are (invisibly) passing a reference to that object, and it is possible to modify the contents of that object, but if you attempt to overwrite the reference it will not affect the copy of the reference held by the caller - i.e. the reference itself is passed by value:Compare with C++ where changing a reference type can entirely replace the object passed by the caller:Think of it like this:Whenever you create an object in ECMAscript, this object is formed in a mystique ECMAscript universal place where no man will ever be able to get. All you get back is a reference to that object in this mystique place.Even obj is only a reference to the object (which is located in that special wonderful place) and hence, you can only pass this reference around. Effectively, any piece of code which accesses obj will modify the object which is far, far away.My 2 Cents.... It\'s irrelevant whether Javascript passes parameters by reference or value. What really matters is assignment vs mutation.I wrote a longer, more detailed explanation here (Is JavaScript a pass-by-reference or pass-by-value language?)When you pass anything (Whether that be an object or a primitive), all javascript does is assign a new variable while inside the function... just like using the equal sign (=)How that parameter behaves inside the function is exactly the same as it would behave if you just assigned a new variable using the equal sign.. Take these simple examples.If I were to pass myString as a parameter to a function, it behaves as if I simply assigned it to a new variable. Now, let\'s do the same thing, but with a function instead of a simple assignmentThe only reason that you can modify objects when you pass them to a function is because you are not reassigning... Instead, objects can be changed or mutated.... Again, it works the same way.If I were to pass myObject as a parameter to a function, it behaves as if I simply assigned it to a new variable. Again, the same thing with the exact same behavior but with a function.Every time you pass a variable to a function, you are "Assigning" to whatever the name of the parameter is, just like if you used the equal (=) sign.Always remember that the equals sign (=) means assignment.\nAnd passing a parameter to a function also means assignment. \nThey are the same and the 2 variables are connected in exactly the same way.The only time that modifying a variable affects a different variable is when the underlying object is mutated.There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn\'t have a function and just used the equal sign to assign to a new variable.As with C, ultimately, everything is passed by value.  Unlike C, you can\'t actually back up and pass the location of a variable, because it doesn\'t have pointers just references.And the refernces it has are all to objects, not variables.  There are several ways of achieving the same result, but they have to be done by hand, not just adding a keyword at either the call or declaration site.JavaScript is pass by value.\nFor primitives, primitive\'s value is passed.\nFor Objects, Object\'s reference "value" is passed.Example with Object:calling f2 results in printing out "a" value as 2 instead of 1, as the reference is passed and the "a" value in reference is updated.Example with primitive:calling f2 results in printing out "a" value as 1.In practical terms, Alnitak is correct and makes it easy to understand, but ultimately in JavaScript, everything is passed by value. What is the "value" of an object? It is the object reference.When you pass in an object, you get a copy of this value (hence the \'copy of a reference\' that Alnitak described). If you change this value, you do not change the original object, you are changing your copy of that reference."Global" javascript variables are members of the window object.  You could access the reference as a member of the window object.Note, the above example will not work for variables declared within a function.Function arguments are passed either by-value or by-sharing but never NEVER by reference in Javascript!Primitive types are passed by-value:Reassignments inside a function scope are not visible in the surrounding scope.This also applies to Strings, which are a composite data type and yet immutable:Objects, that is to say all types that are not primitives are passed by-sharing. A variable that holds a reference to an object actually holds merely a copy of this reference. If Javascript would pursue a Call-by-reference evaluation strategy, the variable would hold the original reference. This is the crucial difference between by-sharing and by-reference.What are the practical consequences of this distinction?Mutating means to modify certain properties of an existing Object. The reference copy that a variable is bound to and that refers to this object remains the same. Mutations are thus visible in the caller\'s scope.Reassigning means to replace the reference copy bound to a variable. Since it is only a copy, other variables holding a copy of the same reference remain unaffected. Reassignments are thus not visible in the caller\'s scope like they would be with a Call-by-reference evaluation strategy.Further information on evaluation strategies in Ecmascript.In the interest of creating a simple example that uses const...