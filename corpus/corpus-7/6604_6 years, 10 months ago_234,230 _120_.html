Ok everyone knows that to hide a keyboard you need to implement:But the big deal here is how to hide the keyboard when the user touches or selects any other place that is not an EditText or the softKeyboard?I tried to use the onTouchEvent() on my parent Activity but that only works if user touches outside any other view and there is no scrollview.I tried to implement a touch, click, focus listener without any success.I even tried to implement my own scrollview to intercept touch events but I can only get the coordinates of the event and not the view clicked.Is there a standard way to do this?? in iPhone it was really easy.The following snippet simply hides the keyboard:You can put this up in a utility class, or if you are defining it within an activity, avoid the activity parameter, or call hideSoftKeyboard(this).The trickiest part is when to call it. You can write a method that iterates through every View in your activity, and check if it is an instanceof EditText if it is not register a setOnTouchListener to that component and everything will fall in place. In case you are wondering how to do that, it is in fact quite simple. Here is what you do, you write a recursive method like the following, in fact you can use this to do anything, like setup custom typefaces etc... Here is the methodThat is all, just call this method after you setContentView in your activity. In case you are wondering what parameter you would pass, it is the id of the parent container. Assign an id to your parent container like<RelativeLayoutPanel android:id="@+id/parent"> ... </RelativeLayout>and call setupUI(findViewById(R.id.parent)), that is all.If you want to use this effectively, you may create an extended Activity and put this method in, and make all other activities in your application extend this activity and call its setupUI() in the onCreate() method.Hope it helps.If you use more than 1 activity define common id to parent layout like \n<RelativeLayout android:id="@+id/main_parent"> ... </RelativeLayout>Then extend a class from Activity and define setupUI(findViewById(R.id.main_parent)) Within its OnResume() and extend this class instead of ``Activityin your programYou can achieve this by doing the following steps:Make the parent view(content view of your activity) clickable and focusable by adding the following attributesImplement a hideKeyboard() methodLastly, set the onFocusChangeListener of your edittext.As pointed out in one of the comments below, this might not work if the parent view is a ScrollView. For such case, the clickable and focusableInTouchMode may be added on the view directly under the ScrollView.I find the accepted answer a bit complicated.Here\'s my solution. Add an OnTouchListener to your main layout, ie.:and put the following code in the onTouch method.This way you don\'t have to iterate over all views.I got one more solution to hide the keyboard by:Here pass HIDE_IMPLICIT_ONLY at the position of showFlag and 0 at the position of hiddenFlag.\nIt will forcefully close the soft keyboard.Well I manage to somewhat solve the problem, I overrode the dispatchTouchEvent on my activity, there I am using the following to hide the keyboard.EDIT: The getFields() method is just a method that returns an array with the textfields in the view. To avoid creating this array on every touch, I created an static array called sFields, which is returned at the getFields() method. This array is initialized on the onStart() methods such as:sFields = new EditText[] {mUserField, mPasswordField};It is not perfect, The drag event time is only based on heuristics so sometimes it doesnt hide when performing long clics, and I also finished by creating a method to get all the editTexts per view; else the keyboard would hide and show when clicking other EditText.Still, cleaner and shorter solutions are welcomeUse OnFocusChangeListener.For example:Update: you also may override onTouchEvent() in your activity and check coordinates of the touch. If coordinates are outside of EditText, then hide the keyboard.I implemented dispatchTouchEvent in Activity to do this:and I tested it, works perfect!I\'m aware that this thread is quite old, the correct answer seems valid and there are a lot of working solutions out there, but I think the approach stated bellow might have an additional benefit regarding efficiency and elegance.I need this behavior for all of my activities, so I created a class CustomActivity inheriting from the class Activity and "hooked" the dispatchTouchEvent function. There are mainly two conditions to take care of:This is my result:Side note: Additionally I assign these attributes to the root view making it possible to clear focus on every input field and preventing input fields gaining focus on activity startup (making the content view the "focus catcher"):I modified the solution of Andre Luis IM I achieved this one:I created a utility method to hide the soft keyboard the same way Andre Luiz IM did:But instead of register an OnTouchListener for every view, that give a poor performance, I registered the OnTouchListener for just the root view. Since the event bubbles until it\'s consumed (EditText is one of the views that consumes it by default), if it arrives to the root view, it\'s because it wasn\'t consumed, so I close the soft keyboard.Override public boolean dispatchTouchEvent(MotionEvent event) in any Activity (or extend class of Activity)And that\'s all you need to doI liked the approach of calling dispatchTouchEvent made by htafoya, but:So, I made this somewhat easier solution:There is one disadvantage:Switching from one EditText to another EditText makes the keyboard hide and reshow - in my case it\'s desired that way, because it shows that you switched between two input components.Method for show / hide soft keyboardI hope they have been usefulHere\'s another variation on fje\'s answer that addresses the issues raised by sosite.The idea here is to handle both the down and the up actions in the Activity\'s dispatchTouchEvent method.  On the down action, we make note of the currently focused view (if any) and whether the touch was inside it, saving both those bits of info for later.On the up action, we first dispatch, to allow another view to potentially take focus.  If after that, the currently focused view is the originally focused view, and the down touch was inside that view, then we leave the keyboard open.If the currently focused view is different than the originally focused view and it\'s an EditText, then we also leave the keyboard open.Otherwise we close it.So, to sum up, this works as follows:when the focused EditText is at the bottom of the screen and you long-click on some text to select it, the EditText keeps focus and therefore the keyboard opens like you want, because we do the "touch is within view bounds" check on the down action, not the up action.its too simple, just make your recent layout clickable an focusable by this code:and then write a method and an OnClickListner for that layout , so that when the uppermost layout is touched any where it will call a method in which you will write code to dismiss keyboard. following is the code for both;\n// you have to write this in OnCreate()method called from listner:-Plea: I recognize I have no clout, but please take my answer seriously.   Problem: Dismiss soft keyboard when clicking away from keyboard or edit text with minimal code.Solution: External library known as Butterknife.One Line Solution:More Readable Solution:Explanation:  Bind OnClick Listener to the activity\'s XML Layout parent ID, so that any click on the layout (not on the edit text or keyboard) will run that snippet of code which will hide the keyboard.Example:  If your layout file is R.layout.my_layout and your layout id  is R.id.my_layout_id, then your Butterknife bind call should look like:Butterknife Documentation Link: http://jakewharton.github.io/butterknife/Plug: Butterknife will revolutionize your android development.  Consider it.Note: The same result can be achieved without the use of external library Butterknife.  Just set an OnClickListener to the parent layout as described above.There is a simpler approach, based on iPhone same issue. Simply override the background\'s layout on touch event, where the edit text is contained. Just use this code in the activity\'s OnCreate (login_fondo is the root layout):Try to put stateHidden on as your activity windowSoftInputMode valuehttp://developer.android.com/reference/android/R.attr.html#windowSoftInputModeFor example for your Activity:This is a slightly modified version of fje\'s answer which mostly worked perfectly.This version uses ACTION_DOWN so performing a scroll action also closes the keyboard.\nIt also doesn\'t propagate the event unless you click on another EditText. This means that clicking anywhere outside your EditText, even on another clickable, simply closes the keyboard.Other idea is to override onInterceptTouchEvent method on the root view for your Activity. The touch event goes from the front most view on the screen (where the touch event occurred) down the stack of views calling the onTouch method until any of the views return true, indicating that the touch event was consumed. As many of the view consumes the touch event by default (that is the case of EditText or TextView, for instance), the event does not get to the Activity\'s root View onTouch method.But, before do this traversal, the touch event travels another path, going from the root view down the view tree until it gets to the front most view. This traversal is done by calling onInterceptTouchEvent. If the method returns true, it intercepts the event... nahhh, but that is a little bit trick, I don\'t think you want to do that nor to know the details. What you need to know is that you can override this method on the root view for your Activity, and put there the code to hide the keyboard when necessary.I got this working with a slight variant on Fernando Camarago\'s solution.  In my onCreate method I attach a single onTouchListener to the root view but send the view rather than activity as an argument.In a separate Utils class is...You may easily override the onKey() event in activity and fragments to hide the keyboard.hey guys i have simple solution for this problem and this solution can be used for simple registration or login form.\nmy solution is same as i implemented in ios setontouch listener to Main view activity_main.xml add ID to your main relative layout android:id="@+id/mainlayout"and add this code to your activity This may be old but I got this working by implenting a custom class the best practice here is to create a Helper class and every container Relative / Linear Layouts should implement this. **** Take note only the main Container should implement this class (For optimization) ****and implement it like this :the keyword this is for Activity. so if you are on fragment you use like getActivity();---thumbs up if it help you... \n--- cheers Ralph ---I thought this problem.\nfirst, I think that setOnTouchListener is not simple solution.\nso I believe dispatchTouchEvent is best simple solution.in here, a important is ACTION_UP.I assumed EditText only show soft keyboard otherwise not show the keyboard.\nI have tested on Android5.0.1 (G3.cat6 of LG).if you need drag checking, long click, ..., show comments above.My solution hides keyboard on outside click in any activity, with of all edit texts. Without specifying them one by one.First add  to root view of layout xml:\n    android:clickable="true"\n    android:focusableInTouchMode="true"Next, create one parent Acitvity of all activities you want to hide keyboard, and specify onResume() method:Extend your activity with this General activity (Inheritance power !) and that\'s all, every time any EditText (on any extended Activity) will lose focus, keyboard will be hidden.P.S. hideKeyboard method :context.getCurrentFocus()   doesn\'t need specifying specific EditText view..I have done this way:Hide keyboard code:DoneTo solve this problem what you have to do is first use setOnFocusChangeListener of that Edittextand then what you need to do is override dispatchTouchEvent in the activity which contains that Edittext see below codeNow what will happen is when a user click outside then firstly this dispatchTouchEvent will get called which then will clear focus from the editext now your OnFocusChangeListener will get called that focus has been changed now here you can do anything which you wanted to do hope it worksYou can try the way below, it works great for me :)  This way can be applied for Activity or Fragment and it\'s also compatible with ScrollView.  We put ScrollView as a top-level layout, declare id parentView for the LinearLayout inside and add two attributes like below:  In code, write a function like below:  Then register an OnFocusChangeListener for the root view (write in onCreate method) to make all EditText in Activity affected:I have refined the method, put the following code in some UI utility class(preferably, not necessarily)  so that it can be accessed from all your Activity or Fragment classes to serve its purpose.Then say for example you need to call it from activity, call it as follows;Notice findViewById(android.R.id.content)This gives us the root view of the current group(you mustn\'t have set the id on root view).Cheers :)