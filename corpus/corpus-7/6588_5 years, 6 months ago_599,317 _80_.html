I am getting this errordetailed message sun.security.validator.ValidatorException: PKIX path\n  building failed:\n  sun.security.provider.certpath.SunCertPathBuilderException: unable to\n  find valid certification path  to requested targetcause javax.net.ssl.SSLHandshakeException:\n  sun.security.validator.ValidatorException: PKIX path   building\n  failed: sun.security.provider.certpath.SunCertPathBuilderException:\n  unable to find valid certification path to requested targeti am using tomcat 6 as webserver. i have two https webbapplication installed on different tomcat on differte port but on same machine. Say App1(port 8443) and \n App2(port 443). App1 connects to App2 .When App1 connects to App2 i get above error. I know this is very common error so came across many solutions on different\n forums and sites. I have below entry in server.xml of both tomcat i.eEvery site says the same reason that certificate given by app2 is not in the trusted store of app1 jvm. This seems to be true also when i tired to hit the same\nURL in IE browser, it works(with warming, There is a problem with this web site\'s security certificate. here i say continue to this website) But when same url\nis hit by java client(in my case). So i get the above error. So to put it in trustore i tried  these tree options i.eOption1Option2\nSetting below in environment variableOption3\nSetting below in environment variableBut nothing worked .What at last worked   is executing the java approach suggested in How to handle invalid SSL certificates with Apache HttpClient? by Pascal Thivent i.e \nexecuting the program InstallCert. But this approach is fine for devbox setup but i can not use it at production environment. I am wondering\nwhy three approaches mentioned above did not work when  i have mentioned same values in server.xml of app2 server and same values in truststore by settingSystem.setProperty("javax.net.ssl.trustStore", "C:/.keystore") and System.setProperty("javax.net.ssl.trustStorePassword", "changeit");in app1 program.For more information this is how i am making the connectionEdit :- Tried to format the question and accepted answer in more presentable way at mine BlogYou need to add the certificate for App2 to the truststore file of the used JVM located at %JAVA_HOME%\\lib\\security\\cacerts.First you can check if your certificate is already in the truststore by running the following command:\nkeytool -list -keystore "%JAVA_HOME%/jre/lib/security/cacerts" (you don\'t need to provide a password)If your certificate is missing you can get it by downloading it with your browser and add it to the truststore with the following command:keytool -import -noprompt -trustcacerts -alias <AliasName> -file   <certificate> -keystore <KeystoreFile> -storepass <Password>Afer import you can run the first command again to check if your certificate was added.Sun/Oracle information can be found here.Hope this helped! Have Fun!javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\xe2\x80\xa2 When I got the error, I tried to Google out the meaning of the expression and I found, this issue occurs when a server changes their HTTPS SSL certificate, and our older version of java doesn\xe2\x80\x99t recognize the root certificate authority (CA).\xe2\x80\xa2 If you can access the HTTPS URL in your browser then it is possible to update Java to recognize the root CA.\xe2\x80\xa2 In your browser, go to the HTTPS URL that Java could not access. Click on the HTTPS certificate chain (there is lock icon in the Internet Explorer), click on the lock to view the certificate.\xe2\x80\xa2 Go to \xe2\x80\x9cDetails\xe2\x80\x9d of the certificate and \xe2\x80\x9cCopy to file\xe2\x80\x9d. Copy it in Base64 (.cer) format. It will be saved on your Desktop.\xe2\x80\xa2 Install the certificate ignoring all the alerts.\xe2\x80\xa2 This is how I gathered the certificate information of the URL that I was trying to access.Now I had to make my java version to know about the certificate so that further it doesn\xe2\x80\x99t refuse to recognize the URL. In this respect I must mention that I googled out that root certificate information stays by default in JDK\xe2\x80\x99s  \\jre\\lib\\security location, and the default password to access is: changeit.To view the cacerts information the following are the procedures to follow:\xe2\x80\xa2 Click on Start Button-->Run\xe2\x80\xa2 Type cmd. The command prompt opens (you may need to open it as administrator).\xe2\x80\xa2 Go to your Java/jreX/bin directory\xe2\x80\xa2 Type the followingkeytool -list -keystore D:\\Java\\jdk1.5.0_12\\jre\\lib\\security\\cacertsIt gives the list of the current certificates contained within the keystore. It looks something like this:C:\\Documents and Settings\\NeelanjanaG>keytool -list -keystore D:\\Java\\jdk1.5.0_12\\jre\\lib\\security\\cacertsEnter keystore password:  changeitKeystore type: jksKeystore provider: SUNYour keystore contains 44 entriesverisignclass3g2ca, Mar 26, 2004, trustedCertEntry,Certificate fingerprint (MD5): A2:33:9B:4C:74:78:73:D4:6C:E7:C1:F3:8D:CB:5C:E9entrustclientca, Jan 9, 2003, trustedCertEntry,Certificate fingerprint (MD5): 0C:41:2F:13:5B:A0:54:F5:96:66:2D:7E:CD:0E:03:F4thawtepersonalbasicca, Feb 13, 1999, trustedCertEntry,Certificate fingerprint (MD5): E6:0B:D2:C9:CA:2D:88:DB:1A:71:0E:4B:78:EB:02:41addtrustclass1ca, May 1, 2006, trustedCertEntry,Certificate fingerprint (MD5): 1E:42:95:02:33:92:6B:B9:5F:C0:7F:DA:D6:B2:4B:FCverisignclass2g3ca, Mar 26, 2004, trustedCertEntry,Certificate fingerprint (MD5): F8:BE:C4:63:22:C9:A8:46:74:8B:B8:1D:1E:4A:2B:F6\xe2\x80\xa2 Now I had to include the previously installed certificate into the cacerts.\xe2\x80\xa2 For this the following is the procedure:keytool \xe2\x80\x93import \xe2\x80\x93noprompt \xe2\x80\x93trustcacerts \xe2\x80\x93alias ALIASNAME -file FILENAME_OF_THE_INSTALLED_CERTIFICATE -keystore PATH_TO_CACERTS_FILE -storepass PASSWORDIf you are using Java 7:keytool \xe2\x80\x93importcert \xe2\x80\x93trustcacerts \xe2\x80\x93alias ALIASNAME -file PATH_TO_FILENAME_OF_THE_INSTALLED_CERTIFICATE -keystore PATH_TO_CACERTS_FILE -storepass changeit\xe2\x80\xa2 It will then add the certificate information into the cacert file.It is the solution I found for the Exception mentioned above!!I wanted to support a self signed certificate in a Tomcat App but the following snippet failed to workthis is what solved my issue:Even though iv\'e installed my certificate in Java\'s default certificate stores, Tomcat ignores that (seems like it\'s not configured to use Java\'s default certificate stores). To hack this, add the following somewhere in your code:My cacerts file was totally empty.  I solved this by copying the cacerts file off my windows machine (that\'s using Oracle Java 7) and scp\'d it to my Linux box (OpenJDK).  and then on the linux machineIt\'s worked great so far.Using Tomcat 7 under Linux, this did the trick.Under Linux, $JAVA_HOME is not always setup, but usually /etc/alternatives/jre points to $JAVA_HOME/jrei wrote a small win32 (WinXP 32bit testet) stupid cmd (commandline) script which looks for all java versions in program files and adds a cert to them. \nThe Password needs to be the default "changeit" or change it yourself in the script :-)For Tomcat running on Ubuntu server, to find out which Java is being used, use "ps -ef | grep tomcat" command:Sample:Then, we can go in to: cd /usr/local/java/jdk1.7.0_15/jre/lib/securityDefault cacerts file is located in here. Insert the untrusted certificate into it.I have this problem too.I tried almost everything by adding the SSL cert to .keystore, but, it was not working with Java1_6_x.\nFor me it helped if we start using newer version of Java, Java1_8_x as JVM.For me, this error appeared too while trying to connect to a process behind an NGINX reverse proxy which was handling the SSL. It turned out the problem was a certificate without the entire certificate chain concatenated. \nWhen I added intermediate certs, the problem was solved.Hope this helps.Its a flaw of Java not using the standard Operating system keystore like in MacOS X. I filed a change request today see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8185892