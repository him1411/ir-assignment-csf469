While programming software stored in a Subversion repo, I often modify some files, then notice that I\'d like to do some preparatory change for my main work. E.g. while implementing new functionality, I notice some refactoring which might help me.In order not to mix two unrelated changes, in these cases I\'d like to "stow away" my changes, i.e. revert to the repository version, do some other changes, commit these, then "fetch back" my changes. git-stash allows to do just that. Is there some way to do this with Subversion, either directly or with some plugin or script. Eclipse plugins would also be fine.when I\'ve got uncommitted changes from one task in my working copy and I need to switch to another task, I do one of two things:Check out a new working copy for the second task.orStart a branch:I have some scripts that help to automate this.This blog post advises using diff and patch.Note that this doesn\'t stash metadata changes or (I think) directory creates/deletes.  (Yes, svn tracks those separately from directory contents, unlike git.)You can store your current changes with svn diff into a patch file, then revert your working copy:After you\xe2\x80\x99ve implemented your preparatory feature, you can then apply your patch with the patch utility:As others have noted this will not work with svn:properties and tree operations (add, remove, rename files and directories).Binary files could also give problems, I don\xe2\x80\x99t know how patch (or TortoiseSVN in this case handles them).The easiest way would be to use a temporary branch, like this:This could (and probably should) be put in a script if done on a more regular basis.I don\'t know of an easy way to do that with just svn.  Honestly, I\'d advise using git-svn to make a git repo that acts as an svn working copy, and just using git stash with that.  Just replace git pull with git svn rebase and git push with git svn dcommit and you can actually keep 90% of your git workflow and still be talking to an svn server.There is a small Python 2 script called svn-stash available under GPL 3: https://github.com/frankcortes/svn-stash . It works like the svn diff/patch solutions mentioned and offers pushing and popping of changes as diffs into some local directory. Unfortunately, the stashes can not be named, and only the last one can be popped (well, yeah, it\'s a stack, but there is no real reason for such a limitation.) But then, you could always build the missing features into the source.It is written for *ix, but after replacing every "/" with os.sep it works nicely under Windows as well. If you use svn 1.7 or higher, you need to change is_a_current_stash(): remove the line if ".svn" in os.listdir(CURRENT_DIR):, since there is only one top-level .svn subdir in 1.7 WC\'s.You can do it easily using Intellij IDEA - Shelve Changesanother option is to copy your current checkout to a new directory and revert all your changes. this way you\xe2\x80\x99ll save the hassle of creating a temporary branch on your server\xe2\x80\x94after all stashing is a local operation, which not everybody should see and can be done quite often.after committing your hotfix you can update your main working copy and delete your \xe2\x80\x9cstashing area\xe2\x80\x9dI have also wanted this feature. I currently use TortoiseSVN. I have not found a hardfast solution except to export the tree, revert back to repository make my changes and commit, then compare the changes from the exported tree back into my source controlled directory using a tool like Beyond Compare.Or, another solution might be to branch from the HEAD to another directory, make your changes and the commit. Once you\'re ready to merge those back to your other working copy, do an update and merge your changes.I always keep a second checkout, which I call "trunk_clean". Whenever I need to do a quick, isolated change related to what I am doing, I just commit on that checkout instead.The branching and patching ideas above are great, but they don\'t work well for me. I use a visual diff tool, so running git diff doesn\'t produce text-based patches. Our build system spins up a new environment each time a branch is created, so creating temporary "stash" branches would get messy.Instead, I wrote a little shell script that copies a file to a "shelf" directory, adds a timestamp, and reverts the change. It\'s not as robust as the solutions above, but it also avoids some of the pitfalls that I ran into.In my practice, I use git init to create a git repository in trunk directory of svn repository, and then I add *.git to svn ignore patterns. After modifying some files, if I want to continue my work with svn mainline, I just use git stash to stash my work. After committing svn repository, I use git stash pop to restore my modifying.