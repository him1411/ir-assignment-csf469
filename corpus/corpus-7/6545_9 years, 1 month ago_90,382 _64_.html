What are the differences between delegates and an events? Don\'t both hold references to functions that can be executed?An Event declaration adds a layer of abstraction and protection on the delegate instance.  This protection prevents clients of the delegate from resetting the delegate and its invocation list and only allows adding or removing targets from the invocation list.In addition to the syntactic and operational properties, there\'s also a semantical difference. Delegates are, conceptually, function templates; that is, they express a contract a function must adhere to in order to be considered of the "type" of the delegate.Events represent ... well, events. They are intended to alert someone when something happens and yes, they adhere to a delegate definition but they\'re not the same thing.Even if they were exactly the same thing (syntactically and in the IL code) there will still remain the semantical difference. In general I prefer to have two different names for two different concepts, even if they are implemented in the same way (which doesn\'t mean I like to have the same code twice).To understand the differences you can look at this 2 examplesExample with Delegates (in this case, an Action - that is a kind of delegate that doesn\'t return a value)To use the delegate, you should do something like this:This code works well but you could have some weak spots.For example, if I write this: with the last line of code, I have overridden the previous behaviors just with one missing + (I have used = instead of +=)Another weak spot is that every class which uses your Animal class can raise RaiseEvent just calling it animal.RaiseEvent().To avoid these weak spots you can use events in c#.Your Animal class will change in this way:to call eventsDifferences:Notes:EventHandler is declared as the following delegate:it takes a sender (of Object type) and event arguments. The sender is null if it comes from static methods.This example, which uses EventHandler<ArgsSpecial>, can also be written using EventHandler instead.Refer here for documentation about EventHandlerIt is an old post but if any one stumbles upon it, like i did - here is another good link to refer to.. \nhttp://csharpindepth.com/Articles/Chapter2/Events.aspxbriefly, the take away from the article - Events are encapsulation over delegates.\nQuote from article - "Suppose events didn\'t exist as a concept in C#/.NET. How would\n  another class subscribe to an event?Three options:public delegatevariabledelegate variable backed by a propertydelegate variable with AddXXXHandler and RemoveXXXHandler methodsOption 1 is clearly horrible, for all the normal reasons we abhor\n  public variables. Option 2 is better, but allows subscribers to effectively override\n  each other - it would be all too easy to write someInstance.MyEvent =\n  eventHandler; which would replace any existing event handlers rather\n  than adding a new one. In addition, you still need to write the\n  properties.Option 3 is basically what events give you, but with a guaranteed\n  convention (generated by the compiler and backed by extra flags in the\n  IL) and a "free" implementation if you\'re happy with the semantics\n  that field-like events give you. Subscribing to and unsubscribing from\n  events is encapsulated without allowing arbitrary access to the list\n  of event handlers, and languages can make things simpler by providing\n  syntax for both declaration and subscription."You can also use events in interface declarations, not so for delegates.NOTE: If you have access to C# 5.0 Unleashed, read the "Limitations on Plain Use of Delegates" in Chapter 18 titled "Events" to understand better the differences between the two.It always helps me to have a simple, concrete example. So here\'s one for the community. First I show how you can use delegates alone to do what Events do for us. Then I show how the same solution would work with an instance of EventHandler. And then I explain why we DON\'T want to do what I explain in the first example. This post was inspired by an article by John Skeet.Example 1: Using public delegateSuppose I have a WinForms app with a single drop-down box. The drop-down is bound to an List<Person>. Where Person has properties of Id, Name, NickName, HairColor. On the main form is a custom user control that shows the properties of that person. When someone selects a person in the drop-down the labels in the user control update to show the properties of the person selected.Here is how that works. We have three files that help us put this together:Here is the relevant code for each of the classes:Here is our user control:Finally we have the following code in our Form1.cs. Here we are Calling OnPersonChanged, which calls any code subscribed to the delegate.Ok. So that\'s how you would get this working without using events and just using delegates. We just put a public delegate into a class -- you can make it static or a singleton, or whatever. Great. BUT, BUT, BUT, we do not want to do what I just described above. Because public fields are bad for many, many reason. So what are our options? As John Skeet describes, here are our options:This third option is essentially what an event gives us. When we declare an EventHandler, it gives us access to a delegate -- not publicly, not as a property, but as this thing we call an event that has just add/remove accessors.Let\'s see what the same program looks like, but now using an Event instead of the public delegate (I\'ve also changed our Mediator to a singleton):Example 2: With EventHandler instead of a public delegateMediator:Notice that if you F12 on the EventHandler, it will show you the definition is just a generic-ified delegate with the extra "sender" object:The User Control:Finally, here\'s the Form1.cs code:Because the EventHandler wants and EventArgs as a parameter, I created this class with just a single property in it:Hopefully that shows you a bit about why we have events and how they are different -- but functionally the same -- as delegates.An event in .net is a designated combination of an Add method and a Remove method, both of which expect some particular type of delegate.  Both C# and vb.net can auto-generate code for the add and remove methods which will define a delegate to hold the event subscriptions, and add/remove the passed in delegagte to/from that subscription delegate.  VB.net will also auto-generate code (with the RaiseEvent statement) to invoke the subscription list if and only if it is non-empty; for some reason, C# doesn\'t generate the latter.Note that while it is common to manage event subscriptions using a multicast delegate, that is not the only means of doing so.  From a public perspective, a would-be event subscriber needs to know how to let an object know it wants to receive events, but it does not need to know what mechanism the publisher will use to raise the events.  Note also that while whoever defined the event data structure in .net apparently thought there should be a public means of raising them, neither C# nor vb.net makes use of that feature.What a great misunderstanding between events and delegates!!! A delegate specifies a TYPE (such as a class, or an interface does), whereas an event is just a kind of MEMBER (such as fields, properties, etc). And, just like any other kind of member an event also has a type. Yet, in the case of an event, the type of the event must be specified by a delegate.  For instance, you CANNOT declare an event of a type defined by an interface. Concluding, we can make the following Observation: the type of an event MUST be defined by a delegate. This is the main relation between an event and a delegate and is described in the section II.18  Defining events of ECMA-335 (CLI) Partitions I to VI:In typical usage, the TypeSpec (if present) identifies a delegate whose signature matches the arguments passed to the event\xe2\x80\x99s fire method.However, this fact does NOT imply that an event uses a backing delegate field. In truth, an event may use a backing field of any different data structure type of your choice. If you implement an event explicitly in C#, you are free to choose the way you store the event handlers (note that event handlers are instances of the type of the event, which in turn is mandatorily a delegate type---from the previous Observation). But, you can store those event handlers (which are delegate instances) in a data structure such as a List or a Dictionary or any other else, or even in a backing delegate field. But don\xe2\x80\x99t forget that it is NOT mandatory that you use a delegate field.To define about event in simple way:Event is a REFERENCE to a delegate with two restrictionsAbove two are the weak points for delegates and it is addressed in event.  Complete code sample to show the difference in fiddler is here https://dotnetfiddle.net/5iR3fB .Toggle the comment between Event and Delegate and client code that invokes/assign values to delegate to understand the differenceHere is the inline code.