A process is considered to have completed correctly in Linux if its exit status was 0.\nI\'ve seen that segmentation faults often result in an exit status of 11, though I don\'t know if this is simply the convention where I work (the apps that failed like that have all been internal) or a standard.Are there standard exit codes for processes in Linux?8 bits of the return code and 8 bits of the number of the killing signal are mixed into a single value on the return from wait(2) & co..How are you determining the exit status?  Traditionally, the shell only stores an 8-bit return code, but sets the high bit if the process was abnormally terminated.If you\'re seeing anything other than this, then the program probably has a SIGSEGV signal handler which then calls exit normally, so it isn\'t actually getting killed by the signal.  (Programs can chose to handle any signals aside from SIGKILL and SIGSTOP.)As always, the Advanced Bash Scripting Guide has great information:\n (This was linked in another answer, but to a non-canonical URL.)1:  Catchall for general errors\n  2: Misuse of shell builtins (according to Bash documentation)\n  126:  Command invoked cannot execute\n  127:  "command not found"\n  128:  Invalid argument to exit\n  128+n:  Fatal error signal "n"\n  255: Exit status out of range (exit takes only integer args in the range 0 - 255)The ABSG references sysexits.h.On Linux:1   Catchall for general errors2   Misuse of shell builtins (according to Bash documentation)126 Command invoked cannot execute127 "command not found" 128 Invalid argument to exit128+n   Fatal error signal "n"  130 Script terminated by Control-C  255 Exit status out of rangeThis is for bash. However, for other applications, there are different exit codes.sysexits.h has a list of standard exit codes. It seems to date back to at least 1993 and some big projects like Postfix use it, so I imagine it\'s the way to go.From the OpenBSD man page:There are no standard exit codes, aside from 0 meaning success. Non-zero doesn\'t necessarily mean failure either.stdlib.h does define EXIT_FAILURE as 1 and EXIT_SUCCESS as 0, but that\'s about it.The 11 on segfault is interesting, as 11 is the signal number that the kernel uses to kill the process in the event of a segfault. There is likely some mechanism, either in the kernel or in the shell, that translates that into the exit code.Here is the real, long-standing exit status convention for normal termination (not by signal):For example, diff returns 0 if the files it compares are identical, and 1 if they differ. By long-standing convention, unix programs return exit status 2 when called incorrectly (unknown options, wrong number of arguments, etc.)  For example, diff -N, grep -Y or diff a b c will all result in $? being set to 2. This is and has been the practice since the early days of Unix in the 1970s.The accepted answer explains what happens when a command is terminated by a signal. In brief, termination due to an uncaught signal results in exit status 128+[<signal number>. E.g., termination by SIGINT (signal 2) results in exit status 130. None of the older answers describe exit status 2 correctly-- hence this answer. Contrary to what they claim, status 2 is what your command line utilities actually return when called improperly. (Yes, an answer can have hundreds of upvotes and still be wrong.)Several answers define exit status 2 as "Misuse of bash builtins". This applies only when bash (or a bash script) exits with status 2. Consider it a special case of incorrect usage error.In sysexits.h, mentioned in the most popular answer, exit status EX_USAGE ("command line usage error") is defined to be 64. But this does not reflect reality: I am not aware of any common Unix utility that returns 64 on incorrect invocation (examples welcome). Careful reading of the source code reveals that sysexits.h is aspirational, rather than a reflection of true usage: In other words, these definitions do not reflect the common practice at the time (1993) but were intentionally incompatible with it. More\'s the pity.To a first approximation, 0 is sucess, non-zero is failure, with 1 being general failure, and anything larger than one being a specific failure.  Aside from the trivial exceptions of false and test, which are both designed to give 1 for sucess, there\'s a few other exceptions I found.More realistically, 0 means sucess or maybe failure,  1 means general failure or maybe sucess, 2 means general failure if 1 and 0 are both used for sucess, but maybe sucess as well. The diff command gives 0 if files compared are identical, 1 if they differ, and 2 if binaries are different. 2 also means failure.  The less command gives 1 for failure unless you fail to supply an argument, in which case, it exits 0 despite failing.The more command and the spell command give 1 for failure, unless the failure is a result of permission denied, nonexistent file, or attempt to read a directory.  In any of these cases, they exit 0 despite failing.Then the expr command gives 1 for sucess unless the output is the empty string or zero, in which case, 0 is sucess.  2 and 3 are failure.Then there\'s cases where success or failure is ambiguous.  When grep fails to find a pattern, it exits 1, but it exits 2 for a genuine failure (like permission denied).  Klist also exits 1 when it fails to find a ticket, although this isn\'t really any more of a failure than when grep doesn\'t find a pattern, or when you ls an empty directory.So, unfortunately, the unix powers that be don\'t seem to enforce any logical set of rules, even on very commonly used executables.Programs return a 16 bit exit code.  If the program was killed with a signal then the high order byte contains the signal used, otherwise the low order byte is the exit status returned by the programmer.How that exit code is assigned to the status variable $? is then up to the shell.  Bash keeps the lower 7 bits of the status and then uses 128 + (signal nr) for indicating a signal.The only "standard" convention for programs is 0 for success, non-zero for error.  Another convention used is to return errno on error.When Linux returns 0, it means success.  Anything else means failure, each program has its own exit codes, so it would been quite long to list them all... !About the 11 error code, it\'s indeed the segmentation fault number, mostly meaning that the program accessed a memory location that was not assigned. Standard Unix exit codes are defined by sysexits.h, as another poster mentioned.\nThe same exit codes are used by portable libraries such as Poco - here is a list of them:http://pocoproject.org/docs/Poco.Util.Application.html#16218A signal 11 is a SIGSEGV (segment violation) signal, which is different from a return code. This signal is generated by the kernel in response to a bad page access, which causes the program to terminate. A list of signals can be found in the signal man page (run "man signal").