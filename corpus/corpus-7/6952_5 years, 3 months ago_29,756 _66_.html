I have seen this question asked a lot but never seen a true concrete answer to it. So I am going to post one here which will hopefully help people understand why exactly there is "modulo bias" when using a random number generator, like rand() in C++.So rand() is a pseudo-random number generator which chooses a natural number between 0 and RAND_MAX, which is a constant defined in cstdlib (see this article for a general overview on rand()).Now what happens if you want to generate a random number between say 0 and 2? For the sake of explanation, let\'s say RAND_MAX is 10 and I decide to generate a random number between 0 and 2 by calling rand()%3. However, rand()%3 does not produce the numbers between 0 and 2 with equal probability! When rand() returns 0, 3, 6, or 9, rand()%3 == 0. Therefore, P(0) = 4/11When rand() returns 1, 4, 7, or 10, rand()%3 == 1. Therefore, P(1) = 4/11 When rand() returns 2, 5, or 8, rand()%3 == 2. Therefore, P(2) = 3/11This does not generate the numbers between 0 and 2 with equal probability. Of course for small ranges this might not be the biggest issue but for a larger range this could skew the distribution, biasing the smaller numbers. So when does rand()%n return a range of numbers from 0 to n-1 with equal probability? When RAND_MAX%n == n - 1. In this case, along with our earlier assumption rand() does return a number between 0 and RAND_MAX with equal probability, the modulo classes of n would also be equally distributed.So how do we solve this problem? A crude way is to keep generating random numbers until you get a number in your desired range:but that\'s inefficient for low values of n, since you only have a n/RAND_MAX chance of getting a value in your range, and so you\'ll need to perform RAND_MAX/n calls to rand() on average.A more efficient formula approach would be to take some large range with a length divisible by n, like RAND_MAX - RAND_MAX % n, keep generating random numbers until you get one that lies in the range, and then take the modulus:For small values of n, this will rarely require more than one call to rand().Works cited and further reading:CPlusPlus ReferenceEternally Confuzzled Keep selecting a random is a good way to remove the bias.UpdateWe could make the code fast if we search for an x in range divisible by n.The above loop should be very fast, say 1 iteration on average.@user1413793 is correct about the problem. I\'m not going to discuss that further, except to make one point: yes, for small values of n and large values of RAND_MAX, the modulo bias can be very small. But using a bias-inducing pattern means that you must consider the bias every time you calculate a random number and choose different patterns for different cases. And if you make the wrong choice, the bugs it introduces are subtle and almost impossible to unit test. Compared to just using the proper tool (such as arc4random_uniform), that\'s extra work, not less work. Doing more work and getting a worse solution is terrible engineering, especially when doing it right every time is easy on most platforms.Unfortunately, the implementations of the solution are all incorrect or less efficient than they should be. (Each solution has various comments explaining the problems, but none of the solutions have been fixed to address them.) This is likely to confuse the casual answer-seeker, so I\'m providing a known-good implementation here.Again, the best solution is just to use arc4random_uniform on platforms that provide it, or a similar ranged solution for your platform (such as Random.nextInt on Java). It will do the right thing at no code cost to you. This is almost always the correct call to make.If you don\'t have arc4random_uniform, then you can use the power of opensource to see exactly how it is implemented on top of a wider-range RNG (ar4random in this case, but a similar approach could also work on top of other RNGs). Here is the OpenBSD implementation:It is worth noting the latest commit comment on this code for those who need to implement similar things:Change arc4random_uniform() to calculate 2**32 % upper_bound\'\' as\n  -upper_bound % upper_bound\'\'.  Simplifies the code and makes it the\n  same on both ILP32 and LP64 architectures, and also slightly faster on\n  LP64 architectures by using a 32-bit remainder instead of a 64-bit\n  remainder.Pointed out by Jorden Verwer on tech@\n  ok deraadt; no objections from djm or ottoThe Java implementation is also easily findable (see previous link):Modulo Bias is the inherent bias in using modulo arithmetic to reduce an output set to a subset of the input set. In general, a bias exists whenever the mapping between the input and output set is not equally distributed, as in the case of using modulo arithmetic when the size of the output set is not a divisor of the size of the input set.This bias is particularly hard to avoid in computing, where numbers are represented as strings of bits: 0s and 1s. Finding truly random sources of randomness is also extremely difficult, but is beyond the scope of this discussion. For the remainder of this answer, assume that there exists an unlimited source of truly random bits.Let\'s consider simulating a die roll (0 to 5) using these random bits. There are 6 possibilities, so we need enough bits to represent the number 6, which is 3 bits. Unfortunately, 3 random bits yields 8 possible outcomes:We can reduce the size of the outcome set to exactly 6 by taking the value modulo 6, however this presents the modulo bias problem: 110 yields a 0, and 111 yields a 1. This die is loaded.Rather than rely on random bits, in theory one could hire a small army to roll dice all day and record the results in a database, and then use each result only once. This is about as practical as it sounds, and more than likely would not yield truly random results anyway (pun intended).Instead of using the modulus, a naive but mathematically correct solution is to discard results that yield 110 and 111 and simply try again with 3 new bits. Unfortunately, this means that there is a 25% chance on each roll that a re-roll will be required, including each of the re-rolls themselves. This is clearly impractical for all but the most trivial of uses.Use more bits: instead of 3 bits, use 4. This yield 16 possible outcomes. Of course, re-rolling anytime the result is greater than 5 makes things worse (10/16 = 62.5%) so that alone won\'t help.Notice that 2 * 6 = 12 < 16, so we can safely take any outcome less than 12 and reduce that modulo 6 to evenly distribute the outcomes. The other 4 outcomes must be discarded, and then re-rolled as in the previous approach.Sounds good at first, but let\'s check the math:In this case, 1 extra bit didn\'t help at all!That result is unfortunate, but let\'s try again with 5 bits:A definite improvement, but not good enough in many practical cases. The good news is, adding more bits will never increase the chances of needing to discard and re-roll. This holds not just for dice, but in all cases.As demonstrated however, adding an 1 extra bit may not change anything. In fact if we increase our roll to 6 bits, the probability remains 6.25%.This begs 2 additional questions:Thankfully the answer to the first question is yes. The problem with 6 is that 2^x mod 6 flips between 2 and 4 which coincidentally are a multiple of 2 from each other, so that for an even x > 1, Thus 6 is an exception rather than the rule. It is possible to find larger moduli that yield consecutive powers of 2 in the same way, but eventually this must wrap around, and the probability of a discard will be reduced.Without offering further proof, in general using double the number\n  of bits required will provide a smaller, usually insignificant,\n  chance of a discard.Here is an example program that uses OpenSSL\'s libcrypo to supply random bytes. When compiling, be sure to link to the library with -lcrypto which most everyone should have available.I encourage playing with the MODULUS and ROLLS values to see how many re-rolls actually happen under most conditions. A sceptical person may also wish to save the computed values to file and verify the distribution appears normal.There are two usual complaints with the use of modulo.one is valid for all generators. It is easier to see in a limit case. If your generator has a RAND_MAX which is 2 (that isn\'t compliant with the C standard) and you want only 0 or 1 as value, using modulo will generate 0 twice as often (when the generator generates 0 and 2) as it will generate 1 (when the generator generates 1). Note that this is true as soon as you don\'t drop values, whatever the mapping you are using from the generator values to the wanted one, one will occurs twice as often as the other.some kind of generator have their less significant bits less random than the other, at least for some of their parameters, but sadly those parameter have other interesting characteristic (such has being able to have RAND_MAX one less than a power of 2). The problem is well known and for a long time library implementation probably avoid the problem (for instance the sample rand() implementation in the C standard use this kind of generator, but drop the 16 less significant bits), but some like to complain about that and you may have bad luckUsing something liketo generate a random number between 0 and n will avoid both problems (and it avoids overflow with RAND_MAX == INT_MAX)BTW, C++11 introduced standard ways to the the reduction and other generator than rand().As the accepted answer indicates, "modulo bias" has its roots in the low value of RAND_MAX.  He uses an extremely small value of RAND_MAX (10) to show that if RAND_MAX were 10, then you tried to generate a number between 0 and 2 using %, the following outcomes would result:So there are 4 outputs of 0\'s (4/10 chance) and only 3 outputs of 1 and 2 (3/10 chances each).  So it\'s biased.  The lower numbers have a better chance of coming out.But that only shows up so obviously when RAND_MAX is small.  Or more specifically, when the number your are modding by is large compared to RAND_MAX.A much better solution than looping (which is insanely inefficient and shouldn\'t even be suggested) is to use a PRNG with a much larger output range.  The Mersenne Twister algorithm has a maximum output of 4,294,967,295.  As such doing MersenneTwister::genrand_int32() % 10 for all intents and purposes, will be equally distributed and the modulo bias effect will all but disappear.With a RAND_MAX value of 3 (in reality it should be much higher than that but the bias would still exist) it makes sense from these calculations that there is a bias:1 % 2 = 1\n2 % 2 = 0\n3 % 2 = 1\nrandom_between(1, 3) % 2 = more likely a 1In this case, the % 2 is what you shouldn\'t do when you want a random number between 0 and 1. You could get a random number between 0 and 2 by doing % 3 though, because in this case: RAND_MAX is a multiple of 3.Another methodThere is much simpler but to add to other answers, here is my solution to get a random number between 0 and n - 1, so n different possibilities, without bias.Really random data is not easy to obtain, so why use more bits than needed.Below is an example in Smalltalk, using a cache of bits from a pseudo-random number generator. I\'m no security expert so use at your own risk.I just wrote a code for Von Neumann\'s Unbiased Coin Flip Method, that should theoretically eliminate any bias in the random number generation process. More info can be found at (http://en.wikipedia.org/wiki/Fair_coin)