I\'ve been playing around with docker for a while, and keep on finding the same issue when dealing with persistent data.I create my Dockerfile and expose a volume or use --volumes-from to mount a host folder inside my containerMy question is, what permissions should I apply to the shared volume on the host? I can think of 2 options:What I\'ve been doing so far, give everyone read/write access, so I can write to the folder from the docker containerMap the users from host into the container, so I can assign more granular permissions. Not sure this is possible though and haven\'t found much about it. So far, all I can do is run the container as some user: docker run -i -t -user="myuser" postgres, but this user has a different UID than my host myuser, so permissions do not work. Also, I\'m unsure if mapping the users will pose some security risks.Any other alternatives?How are you guys dealing with this issue?UPDATE 2016-03-02: As of Docker 1.9.0, Docker has named volumes which replace data-only containers. The answer below, as well as my linked blog post, still has value in the sense of how to think about data inside docker but consider using named volumes to implement the pattern described below rather than data containers.I believe the canonical way to solve this is by using data-only containers. With this approach, all access to the volume data is via containers that use -volumes-from the data container, so the host uid/gid doesn\'t matter.For example, one use case given in the documentation is backing up a data volume. To do this another container is used to do the backup via tar, and it too uses -volumes-from in order to mount the volume. So I think the key point to grok is: rather than thinking about how to get access to the data on the host with the proper permissions, think about how to do whatever you need -- backups, browsing, etc. -- via another container. The containers themselves need to use consistent uid/gids, but they don\'t need to map to anything on the host, thereby remaining portable.This is relatively new for me as well but if you have a particular use case feel free to comment and I\'ll try to expand on the answer.UPDATE: For the given use case in the comments, you might have an image some/graphite to run graphite, and an image some/graphitedata as the data container. So, ignoring ports and such, the Dockerfile of image some/graphitedata is something like:Build and create the data container:The some/graphite Dockerfile should also get the same uid/gids, therefore it might look something like this:And it would be run as follows:Ok, now that gives us our graphite container and associated data-only container with the correct user/group (note you could re-use the some/graphite container for the data container as well, overriding the entrypoing/cmd when running it, but having them as separate images IMO is clearer).Now, lets say you want to edit something in the data folder. So rather than bind mounting the volume to the host and editing it there, create a new container to do that job. Lets call it some/graphitetools. Lets also create the appropriate user/group, just like the some/graphite image.You could make this DRY by inheriting from some/graphite or some/graphitedata in the Dockerfile, or instead of creating a new image just re-use one of the existing ones (overriding entrypoint/cmd as necessary).Now, you simply run:and then vi /data/graphite/whatever.txt. This works perfectly because all the containers have the same graphite user with matching uid/gid.Since you never mount /data/graphite from the host, you don\'t care how the host uid/gid maps to the uid/gid defined inside the graphite and graphitetools containers. Those containers can now be deployed to any host, and they will continue to work perfectly.The neat thing about this is that graphitetools could have all sorts of useful utilities and scripts, that you can now also deploy in a portable manner.UPDATE 2: After writing this answer, I decided to write a more complete blog post about this approach. I hope it helps.UPDATE 3: I corrected this answer and added more specifics. It previously contained some incorrect assumptions about ownership and perms -- the ownership is usually assigned at volume creation time i.e. in the data container, because that is when the volume is created. See this blog. This is not a requirement though -- you can just use the data container as a "reference/handle" and set the ownership/perms in another container via chown in an entrypoint, which ends with gosu to run the command as the correct user. If anyone is interested in this approach, please comment and I can provide links to a sample using this approach.A very elegant solution can be seen on the official redis image and in general in all official images.Described in step-by-step process:As seen on Dockerfile comments:add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get addedgosu is an alternative of su / sudo for easy step-down from root user. (Redis is always run with redis user)By configuring the /data volume with the VOLUME /data command we now have a separate volume that can either be docker volume or bind-mounted to a host dir.Configuring it as the workdir (WORKDIR /data) makes it be the default directory where commands are executed from.This means that all container executions will run through the docker-entrypoint script, and by default the command to be run is redis-server.docker-entrypoint is a script that does a simple function: Change ownership of current directory (/data) and step-down from root to redis user to run redis-server. (If the executed command is not redis-server, it will run the command directly.)This has the following effectIf the /data directory is bind-mounted to the host, the docker-entrypoint will prepare the user permissions before running redis-server under redis user.This gives you the ease-of-mind that there is zero-setup in order to run the container under any volume configuration.Of course if you need to share the volume between different images you need to make sure they use the same userid/groupid otherwise the latest container will hijack the user permissions from the previous one.This is arguably not the best way for most circumstances, but it\'s not been mentioned yet so perhaps it will help someone. Bind mount host volumeHost folder FOOBAR is mounted in container /volume/FOOBARModify your container\'s startup script to find GID of the volume you\'re interested in$ TARGET_GID=$(stat -c "%g" /volume/FOOBAR)Ensure your user belongs to a group with this GID (you may have to create a new group). For this example I\'ll pretend my software runs as the nobody user when inside the container, so I want to ensure nobody belongs to a group with a group id equal to TARGET_GIDI like this because I can easily modify group permissions on my host volumes and know that those updated permissions apply inside the docker container. This happens without any permission or ownership modifications to my host folders/files, which makes me happy. I don\'t like this because it assumes there\'s no danger in adding yourself to an arbitrary groups inside the container that happen to be using a GID you want. It cannot be used with a USER clause in a Dockerfile (unless that user has root privileges I suppose). Also, it screams hack job ;-)If you want to be hardcore you can obviously extend this in many ways - e.g. search for all groups on any subfiles, multiple volumes, etc. Ok, this is now being tracked at docker issue #7198For now, I\'m dealing with this using your second option:Map the users from host into the containerUPDATE I\'m currently more inclined to Hamy answerTry to add a command to Dockerfilecredits goes to https://github.com/denderello/symfony-docker-example/issues/2#issuecomment-94387272Here\'s an approach that still uses a data-only container but doesn\'t require it to be synced with the application container (in terms of having the same uid/gid).Presumably, you want to run some app in the container as a non-root $USER without a login shell. In the Dockerfile:Then, in entrypoint.sh:For secure and change root for docker container an docker host try use --uidmap and --private-uids optionshttps://github.com/docker/docker/pull/4572#issuecomment-38400893Also you may remove several capabilities (--cap-drop) in docker container for securityhttp://opensource.com/business/14/9/security-for-dockerUPDATE support should come in docker > 1.7.0UPDATE Version 1.10.0 (2016-02-04) add --userns-remap flag\nhttps://github.com/docker/docker/blob/master/CHANGELOG.md#security-2Use this image: https://hub.docker.com/r/reduardo7/docker-host-userImportant: this destroys container portability across hosts.The same as you, I was looking for a way to map users/groups from host to docker containers and this is the shortest way I\'ve found so far:This is an extract from my docker-compose.yml.The idea is to mount (in read-only mode) users/groups lists from the host to the container thus after the container starts up it will have the same uid->username (as well as for groups) matchings with the host. Now you can configure user/group settings for your service inside the container as if it was working on your host system. When you decide to move your container to another host you just need to change user name in service config file to what you have on that host.To share folder between docker host and docker container, try below command$ docker  run  -v pwd:pwd -i -t  ubuntuThe -v flag mounts the current working directory into the container. When the host directory of a bind-mounted volume doesn\xe2\x80\x99t exist, Docker will automatically create this directory on the host for you,However, there are 2 problems we have here:Solution:Container:\ncreate a user say \'testuser\', by default user id will be starting from 1000,Host: \ncreate a group say \'testgroup\' with group id 1000, and chown the directory to the new group(testgroupIf you using Docker Compose, start the container in previleged mode: