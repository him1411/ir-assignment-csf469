CPU Cycles, Memory Usage, Execution Time, etc.?Added: Is there a quantitative way of testing performance in JavaScript besides just perception of how fast the code runs?Profilers are definitely a good way to get numbers, but in my experience, perceived performance is all that matters to the user/client. For example, we had a project with an Ext accordion that expanded to show some data and then a few nested Ext grids.  Everything was actually rendering pretty fast, no single operation took a long time, there was just a lot of information being rendered all at once, so it felt slow to the user.  We \'fixed\' this, not by switching to a faster component, or optimizing some method, but by rendering the data first, then rendering the grids with a setTimeout. So, the information appeared first, then the grids would pop into place a second later. Overall, it took slightly more processing time to do it that way, but to the user, the perceived performance was improved.EDIT: This answer is now 7 years old. These days, the Chrome profiler and other tools are universally available and easy to use, as are console.time(), console.profile(), and performance.now(). Chrome also gives you a timeline view which can show you what is killing your frame rate, where the user might be waiting, etc.Finding documentation for all these tools is really easy, you don\'t need an SO answer for that. 7 years later, I\'ll still repeat the advice of my original answer and point out that you can have slow code run forever where a user won\'t notice it, and pretty fast code running where they do, and they will complain about the pretty fast code not being fast enough. Or that your request to your server API took 220ms. Or something else like that. The point remains that if you take a profiler out and go looking for work to do, you will find it, but it may not be the work your users need.I do agree that perceived performance is really all that matters. But sometimes I just want to find out which method of doing something is faster. Sometimes the difference is HUGE and worth knowing.You could just use javascript timers. But I typically get much more consistent results using the native Chrome (now also in Firefox and Safari) devTool methods console.time() & console.timeEnd()Chrome canary recently added Line Level Profiling the dev tools sources tab which let\'s you see exactly how long each line took to execute!\nWe can always measure time taken by any function by simple date object.Try jsPerf. It\'s an online javascript performance tool for benchmarking and comparing snippets of code. I use it all the time.JSLitmus is a lightweight tool for creating ad-hoc JavaScript benchmark testsLet examine the performance between function expression and function constructor:What I did above is create a function expression and function constructor performing same operation. The result is as follows:FireFox Performance ResultIE Performance ResultMost browsers are now implementing high resolution timing in performance.now(). It\'s superior to new Date() for performance testing because it operates independently from the system clock.UsageReferencesSome people are suggesting specific plug-ins and/or browsers. I would not because they\'re only really useful for that one platform; a test run on Firefox will not translate accurately to IE7. Considering 99.999999% of sites have more than one browser visit them, you need to check performance on all the popular platforms.My suggestion would be to keep this in the JS. Create a benchmarking page with all your JS test on and time the execution. You could even have it AJAX-post the results back to you to keep it fully automated.Then just rinse and repeat over different platforms.I think JavaScript performance (time) testing is quite enough. I found a very handy article about JavaScript performance testing here.I have a small tool where I can quickly run small test-cases in the browser and immediately get the results:https://duzun.me/playground/js_speedYou can play with code and find out which technique is better in the tested browser.You could use this: http://getfirebug.com/js.html. It has a profiler for JavaScript.Here is a simple function that displays the execution time of a passed in function.I find execution time to be the best measure.You could use console.profile in firebugQuick answerOn jQuery (more specifically on Sizzle), we use this (checkout master and open speed/index.html on your browser), which in turn uses benchmark.js. This is used to performance test the library.Long answerIf the reader doesn\'t know the difference between benchmark, workload and profilers, first read some performance testing foundations on the "readme 1st" section of spec.org. This is for system testing, but understanding this foundations will help JS perf testing as well. Some highlights:What is a benchmark?A benchmark is "a standard of measurement or evaluation" (Webster\xe2\x80\x99s II Dictionary). A computer benchmark is typically a computer program that performs a strictly defined set of operations - a workload - and returns some form of result - a metric - describing how the tested computer performed. Computer benchmark metrics usually measure speed: how fast was the workload completed; or throughput: how many workload units per unit time were completed. Running the same computer benchmark on multiple computers allows a comparison to be made.Should I benchmark my own application?Ideally, the best comparison test for systems would be your own application with your own workload. Unfortunately, it is often impractical to get a wide base of reliable, repeatable and comparable measurements for different systems using your own application with your own workload. Problems might include generation of a good test case, confidentiality concerns, difficulty ensuring comparable conditions, time, money, or other constraints.If not my own application, then what?You may wish to consider using standardized benchmarks as a reference point. Ideally, a standardized benchmark will be portable, and may already have been run on the platforms that you are interested in. However, before you consider the results you need to be sure that you understand the correlation between your application/computing needs and what the benchmark is measuring. Are the benchmarks similar to the kinds of applications you run? Do the workloads have similar characteristics? Based on your answers to these questions, you can begin to see how the benchmark may approximate your reality.Note: A standardized benchmark can serve as reference point. Nevertheless, when you are doing vendor or product selection, SPEC does not claim that any standardized benchmark can replace benchmarking your own actual application.Performance testing JSIdeally, the best perf test would be using your own application with your own workload switching what you need to test: different libraries, machines, etc.If this is not feasible (and usually it is not). The first important step: define your workload. It should reflect your application\'s workload. In this talk, Vyacheslav Egorov talks about shitty workloads you should avoid.Then, you could use tools like benchmark.js to assist you collect metrics, usually speed or throughput. On Sizzle, we\'re interested in comparing how fixes or changes affect the systemic performance of the library.If something is performing really bad, your next step is to look for bottlenecks.How do I find bottlenecks? ProfilersWhat is the best way to profile javascript execution?I usually just test javascript performance, how long script runs. jQuery Lover gave a good article link for testing javascript code performance, but the article only shows how to test how long your javascript code runs. I would also recommend reading article called "5 tips on improving your jQuery code while working with huge data sets".UX Profiler approaches this problem from user perspective. It groups all the browser events, network activity etc caused by some user action (click) and takes into consideration all the aspects like latency, timeouts etc. The golden rule is to NOT under ANY circumstances lock your users browser. After that, I usually look at execution time, followed by memory usage (unless you\'re doing something crazy, in which case it could be a higher priority).This is a good way of collecting performance information for the specific operation.Here is a reusable class for time performance. Example is included in code: