In Objective-C instance data can be public, protected or private. For example:I haven\'t found any mention of access modifiers in the Swift reference. Is it possible to limit the visibility of data in Swift?As of Swift 3.0.1, there are 4 levels of access, described below from the highest (least restrictive) to the lowest (most restrictive).Enable an entity to be used outside the defining module (target). You typically use open or public access when specifying the public interface to a framework.However, open access applies only to classes and class members, and it differs from public access as follows:Enables an entity to be used within the defining module (target). You typically use internal access when defining an app\xe2\x80\x99s or a framework\xe2\x80\x99s internal structure.Restricts the use of an entity to its defining source file. You typically use fileprivate access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.Restricts the use of an entity to its enclosing declaration. You typically use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.When one talks about making a "private method" in Swift or ObjC (or ruby or java or\xe2\x80\xa6) those methods aren\'t really private. There\'s no actual access control around them. Any language that offers even a little introspection lets developers get to those values from outside the class if they really want to.So what we\'re really talking about here is a way to define a public-facing interface that merely presents the functionality we want it to, and "hides" the rest that we consider "private".The Swift mechanism for declaring interfaces is the protocol, and it can be used for this purpose.Remember, protocols are first-class types and can be used anyplace a type can. And, when used this way, they only expose their own interfaces, not those of the implementing type.Thus, as long as you use MyClass instead of MyClassImplementation in your parameter types, etc. it should all just work:There are some cases of direct assignment where you have to be explicit with type instead of relying on Swift to infer it, but that hardly seems a deal breaker:Using protocols this way is semantic, reasonably concise, and to my eyes looks a lot like the Class Extentions we\'ve been using for this purpose in ObjC.As far as I can tell, there are no keywords \'public\', \'private\' or \'protected\'. This would suggest everything is public.However Apple may be expecting people to use \xe2\x80\x9cprotocols\xe2\x80\x9d (called interfaces by the rest of the world) and the factory design pattern to hide details of the implementation type.   This is often a good design pattern to use anyway; as it lets you change your implementation class hierarchy,  while keeping the logical type system the same.Using a combination of protocols, closures, and nested/inner classes, it\'s possible to use something along the lines of the module pattern to hide information in Swift right now. It\'s not super clean or nice to read but it does work.Example:innerVal and mysteriousMath are hidden here from outside use and attempting to dig your way into the object should result in an error.I\'m only part of the way through my reading of the Swift docs so if there\'s a flaw here please point it out, would love to know.As of Xcode 6 beta 4, Swift has access modifiers. From the release notes:Swift access control has three access levels:The implicit default is internal, so within an application target you can leave access modifiers off except where you want to be more restrictive. In a framework target (e.g. if you\'re embedding a framework to share code between an app and an sharing or Today view extension), use public to designate API you want to expose to clients of your framework.As per mentioned in the Swift Documentation - Access Control, Swift 4 has 5 Access Controls:open and public: can be accessed from their module\'s entities and any module\'s entities that imports the defining module.internal: can only be accessed from their module\'s entities. It is the default access level.fileprivate and private: can only be accessed in limited within a limited scope where you define them.open is the same as public in previous versions of Swift, they allow classes from other modules to use and inherit them, i.e: they can be subclassed from other modules. Also, they allow members from other modules to use and override them. The same logic goes for their modules.public allow classes from other module to use them, but not to inherit them, i.e: they cannot be subclassed from other modules. Also, they allow members from other modules to use them, but NOT to override them. For their modules, they have the same open\'s logic (they allow classes to use and inherit them; They allow members to use and override them).fileprivate can be accessed from the their entire files.private can only be accessed from their single declaration and to extensions of that declaration that are in the same file; For instance:As mentioned in the SE-0169 proposal, the only refinement has been added to Swift 4 is that the private access control scope has been expanded to be accessible from extensions of that declaration in the same file; For instance:So, there is no need to declare myMessage as fileprivate to be accessible in the whole file.Swift 3.0 provides five different access controls:Open access and public access enable entities to be used within any source file from their defining module, and also in a\n  source file from another module that imports the defining module. You\n  typically use open or public access when specifying the public\n  interface to a framework. Internal access enables entities to be used within any source file from their defining module, but not in any source file outside of that\n  module. You typically use internal access when defining an app\xe2\x80\x99s or a\n  framework\xe2\x80\x99s internal structure.File-private access restricts the use of an entity to its own defining source file. Use file-private access to hide the\n  implementation details of a specific piece of functionality when those\n  details are used within an entire file.Private access restricts the use of an entity to the enclosing declaration. Use private access to hide the implementation details of\n  a specific piece of functionality when those details are used only\n  within a single declaration.Open access is the highest (least restrictive) access level and private access is the lowest (most restrictive) access level.Default Access LevelsAll entities in your code (with a few specific exceptions) have a default access level of internal if you do not specify an explicit access level yourself. As a result, in many cases you do not need to specify an explicit access level in your code.The release note on the topic:Classes declared as public can no longer be subclassed outside of\n  their defining module, and methods declared as public can no longer be\n  overridden outside of their defining module. To allow a class to be\n  externally subclassed or a method to be externally overridden, declare\n  them as open, which is a new access level beyond public. Imported\n  Objective-C classes and methods are now all imported as open rather\n  than public. Unit tests that import a module using an @testable import\n  will still be allowed to subclass public or internal classes as well\n  as override public or internal methods. (SE-0117)More information & details :\nThe Swift Programming Language (Access Control)No, it\'s not possible. There aren\'t any private/protected methods and variables at all.Everything is public.In Beta 6, the documentation states that there are three different access modifiers:And these three apply to Classes, Protocols, functions and properties.For more, check Access Control.Swift provides three different access levels for entities within your code. These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.Public access is the highest (least restrictive) access level and private access is the lowest (or most restrictive) access level.Default accecss it internal, and does as such not need to be specified. Also note that the private specifier does not work on the class level, but on the source file level. This means that to get parts of a class really private you need to separate into a file of its own. This also introduces some interesting cases with regards to unit testing...Another point to me made, which is commented upon in the link above, is that you can\'t \'upgrade\' the access level. If you subclass something, you can restrict it more, but not the other way around. This last bit also affects functions, tuples and surely other stuff in the way that if i.e. a function uses a private class, then it\'s not valid to have the function internal or public, as they might not have access to the private class. This results in a compiler warning, and you need to redeclare the function as a private function.One of the options you could use is to wrap the instance creation into a function and supply the appropriate getters and setters in a constructor:Now in beta 4, they\'ve added access modifiers to Swift.from Xcode 6 beta 4 realese notes:Swift access control has three access levels:By default, most entities in a source \xef\xac\x81le have internal access. This allows application developers \n  to largely ignore access control while allowing framework developers full control over a \n  framework\'s API.Swift 3 brought a lot of change including the access levels of instance variables and methods. Swift 3 now has a minimum of 4 access levels:Converting to Swift 3: The default solution changing \xe2\x80\x9cprivate\xe2\x80\x9d to \xe2\x80\x9cfileprivate\xe2\x80\x9d is appropriate in most cases, because the meaning of \xe2\x80\x9cprivate\xe2\x80\x9d in swift < 3.0 was like \xe2\x80\x9cfileprivate\xe2\x80\x9d in Swift >= 3.0Apple documentationThe language grammar does not have the keywords \'public\', \'private\' or \'protected\'.  This would suggest everything is public.  Of course, there could be some alternative method of specifying access modifiers without those keywords but I couldn\'t find it in the language reference.Hopefully to save some time for those who want something akin to protected methods:As per other answers, swift now provides the \'private\' modifier - which is defined file-wise rather than class-wise such as those in Java or C# for instance.  This means that if you want protected methods, you can do it with swift private methods if they are in the same filee.g. File 1:File 2:}https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3STARTING SWIFT 2.2 ;) By default Internaltill swift 2.0 there were only three access level [Public, internal, private]\nbut in swift 3.0 apple added two new access level which are [ Open, fileType ] so \nnow in swift 3.0 there are 5 access level \nHere I want to clear the role of these two access level \n1. Open: this is much similar to Public but the only difference is that the Public \n   can access the subclass and override, and Open access level can not access that    this image is taken from Medium website and this describe the difference between open and public accessNow to second new access level\n2. filetype is bigger version of private or less access level than internal \n   The fileType can access the extended part of the [class, struct, enum]\n   and private can not access the extended part of code it can only access the \n   lexical scope \n   this image is taken from Medium website and this describe the difference between fileType and Private access level