What is the correct way to cast an Int to an enum in Java given the following enum?Try MyEnum.values()[x] where x must be 0 or 1, i.e. a valid ordinal for that enum. Note that in Java enums actually are classes (and enum values thus are objects) and thus you can\'t cast an int or even Integer to an enum.MyEnum.values()[x] is an expensive operation. If the performance is a concern, you may want to do something like this:If you want to give your integer values, you can use a structure like belowI cache the values and create a simple static access method:You can try like this.\nCreate Class with element id. Now Fetch this Enum using id as int.This not something that is usually done, so I would reconsider. But having said that, the fundamental operations are: int --> enum using EnumType.values()[intNum], and enum --> int using enumInst.ordinal().However, since any implementation of values() has no choice but to give you a copy of the array (java arrays are never read-only), you would be better served using an EnumMap to cache the enum --> int mapping.Java enums don\'t have the same kind of enum-to-int mapping that they do in C++.That said, all enums have a values method that returns an array of possible enum values, soshould work. It\'s a little nasty and it might be better to not try and convert from ints to Enums (or vice versa) if possible.Use MyEnum enumValue = MyEnum.values()[x];Here\'s the solution I plan to go with.  Not only does this work with non-sequential integers, but it should work with any other data type you may want to use as the underlying id for your enum values.I only need to convert id\'s to enums at specific times (when loading data from a file), so there\'s no reason for me to keep the Map in memory at all times.  If you do need the map to be accessible at all times, you can always cache it as a static member of your Enum class.You can iterate over values() of enum and compare integer value of enum with given id like below:And use just like this:\nTestEnum x = TestEnum.getEnum(4);//Will return TestEnum.Value4\nI hope this helps ;)A good option is to avoid conversion from int to enum: for example, if you need the maximal value, you may compare x.ordinal() to y.ordinal() and return x or y correspondingly. (You may need to re-order you values to make such comparison meaningful.)If that is not possible, I would store MyEnum.values() into a static array.This is the same answer as the doctors but it shows how to eliminate the problem with mutable arrays. If you use this kind of approach because of branch prediction first if will have very little to zero effect and whole code only calls mutable array values() function only once. As both variables are static they will not consume n * memory for every usage of this enumeration too.This should address the indexes getting out of sync with the ordinal value issue.