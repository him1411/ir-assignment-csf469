Can I run the python interpreter without generating the compiled .pyc files?From "What\xe2\x80\x99s New in Python 2.6 - Interpreter Changes":Python can now be prevented from\n  writing .pyc or .pyo files by\n  supplying the -B switch to the Python\n  interpreter, or by setting the\n  PYTHONDONTWRITEBYTECODE environment\n  variable before running the\n  interpreter. This setting is available\n  to Python programs as the\n  sys.dont_write_bytecode variable, and\n  Python code can change the value to\n  modify the interpreter\xe2\x80\x99s behaviour.Update 2010-11-27: Python 3.2 addresses the issue of cluttering source folders with .pyc files by introducing a special __pycache__ subfolder, see What\'s New in Python 3.2 - PYC Repository Directories.There actually IS a way to do it in Python 2.3+, but it\'s a bit esoteric.  I don\'t know if you realize this, but you can do the following:According to the zipimport library:Any files may be present in the ZIP archive, but only files .py and .py[co] are available for import. ZIP import of dynamic modules (.pyd, .so) is disallowed. Note that if an archive only contains .py files, Python will not attempt to modify the archive by adding the corresponding .pyc or .pyo file, meaning that if a ZIP archive doesn\'t contain .pyc files, importing may be rather slow.Thus, all you have to do is zip the files up, add the zipfile to your sys.path and then import them.If you\'re building this for UNIX, you might also consider packaging your script using this recipe:  unix zip executable, but note that you might have to tweak this if you plan on using stdin or reading anything from sys.args (it CAN be done without too much trouble).In my experience performance doesn\'t suffer too much because of this, but you should think twice before importing any very large modules this way.In 2.5, theres no way to suppress it, other than measures like not giving users write access to the directory.In python 2.6 and 3.0 however, there may be a setting in the sys module called "dont_write_bytecode" that can be set to suppress this.  This can also be set by passing the "-B" option, or setting the environment variable "PYTHONDONTWRITEBYTECODE"I have several test cases in a test suite and before I was running the test suite in the Mac Terminal like this: Running the command this way my directory was being populated with .pyc files. I tried the below stated method and it solved the issue:This method works if you are importing test cases into the test suite and running the suite on the command line. You can set sys.dont_write_bytecode = True in your source, but that would have to be in the first python file loaded. If you execute python somefile.py then you will not get somefile.pyc.When you install a utility using setup.py and entry_points= you will have set sys.dont_write_bytecode in the startup script. So you cannot rely on the "default" startup script generated by setuptools.If you start Python with python file as argument yourself you can specify -B:somefile.pyc would not be generated anyway, but no .pyc files for other files imported too.If you have some utility myutil and you cannot change that, it will not pass -B to the python interpreter. Just start it by setting the environment variable PYTHONDONTWRITEBYTECODE:As far as I know python will compile all modules you "import". However python will NOT compile a python script run using: "python script.py" (it will however compile any modules that the script imports).The real questions is why you don\'t want python to compile the modules? You could probably automate a way of cleaning these up if they are getting in the way.You could make the directories that your modules exist in read-only for the user that the Python interpreter is running as.I don\'t think there\'s a more elegant option. PEP 304 appears to have been an attempt to introduce a simple option for this, but it appears to have been abandoned.I imagine there\'s probably some other problem you\'re trying to solve, for which disabling .py[co] would appear to be a workaround, but it\'ll probably be better to attack whatever this original problem is instead.