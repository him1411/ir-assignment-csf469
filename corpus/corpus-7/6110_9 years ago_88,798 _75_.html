I am working on an application and one design approach involves extremely heavy use of the instanceof operator. While I know that OO design generally tries to avoid using instanceof, that is a different story and this question is purely related to performance. I was wondering if there is any performance impact? Is is just as fast as ==?For example, I have a base class with 10 subclasses. In a single function that takes the base class, I do checks for if the class is an instance of the subclass and carry out some routine. One of the other ways I thought of solving it was to use a "type id" integer primitive instead, and use a bitmask to represent categories of the subclasses, and then just do a bit mask comparison of the subclasses "type id" to a constant mask representing the category.Is instanceof somehow optimized by the JVM to be faster than that? I want to stick to Java but the performance of the app is critical. It would be cool if someone that has been down this road before could offer some advice. Am I nitpicking too much or focusing on the wrong thing to optimize?Modern JVM/JIC compilers have removed the performance hit of most of the traditionally "slow" operations, including instanceof, exception handling, reflection, etc.As Donald Knuth wrote, "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil."  The performance of instanceof probably won\'t be an issue, so don\'t waste your time coming up with exotic workarounds until you\'re sure that\'s the problem.I wrote a benchmark program to evaluate different implementations:I used jmh to run the benchmark with 100 warmup calls, 1000 iterations under measuring, and with 10 forks. So each option was measured with 10 000 times, which takes 12:18:57 to run the whole benchmark on my MacBook Pro with macOS 10.12.4 and Java 1.8. The benchmark measures the average time of each option. For more details see my implementation on GitHub. For the sake of completeness: There is a previous version of this answer and my benchmark. In Java 1.8 instanceof is the fastest approach, although getClass() is very close. I just made a simple test to see how instanceOf performance is comparing to a simple s.equals() call to a string object with only one letter.in a 10.000.000 loop the instanceOf gave me 63-96ms, and the string equals gave me 106-230msI used java jvm 6.So in my simple test is faster to do a instanceOf instead of a one character string comparison.using Integer\'s .equals() instead of string\'s gave me the same result, only when I used the == i was faster than instanceOf by 20ms (in a 10.000.000 loop)The items which will determine the performance impact are:I created a microbenchmark for four different methods of dispatch.  The results from Solaris are as follows, with the smaller number being faster:Answering your very last question: Unless a profiler tells you, that you spend ridiculous amounts of time in an instanceof: Yes, you\'re nitpicking.Before wondering about optimizing something that never needed to be optimized: Write your algorithm in the most readable way and run it. Run it, until the jit-compiler gets a chance to optimize it itself. If you then have problems with this piece of code, use a profiler to tell you, where to gain the most and optimize this.In times of highly optimizing compilers, your guesses about bottlenecks will be likely to be completely wrong.And in true spirit of this answer (which I wholeheartly believe): I absolutely don\'t know how instanceof and == relate once the jit-compiler got a chance to optimize it.I forgot: Never measure the first run.I have got same question, but because i did not find \'performance metrics\' for use case similar to mine, i\'ve done some more sample code. On my hardware and Java 6 & 7, the difference between instanceof and switch on 10mln iterations isSo, instanceof is really slower, especially on huge number of if-else-if statements, however difference will be negligible within real application.instanceof is really fast, taking only a few CPU instructions.Apparently, if a class X has no subclasses loaded (JVM knows), instanceof can be optimized as:The main cost is just a read!If X does have subclasses loaded, a few more reads are needed; they are likely co-located so the extra cost is very low too.Good news everyone!instanceof is probably going to be more costly than a simple equals in most real world implementations (that is, the ones where instanceof is really needed, and you can\'t just solve it by overriding a common method, like every beginner textbook as well as Demian above suggest).Why is that? Because what is probably going to happen is that you have several interfaces, that provide some functionality (let\'s say, interfaces x, y and z), and some objects to manipulate that may (or not) implement one of those interfaces... but not directly. Say, for instance, I have:w extends xA implements wB extends AC extends B, implements yD extends C, implements zSuppose I am processing an instance of D, the object d. Computing (d instanceof x) requires to take d.getClass(), loop through the interfaces it implements to know whether one is == to x, and if not do so again recursively for all of their ancestors...\nIn our case, if you do a breadth first exploration of that tree, yields at least 8 comparisons, supposing y and z don\'t extend anything...The complexity of a real-world derivation tree is likely to be higher. In some cases, the JIT can optimize most of it away, if it is able to resolve in advance d as being, in all possible cases, an instance of something that extends x. Realistically, however, you are going to go through that tree traversal most of the time.If that becomes an issue, I would suggest using a handler map instead, linking the concrete class of the object to a closure that does the handling. It removes the tree traversal phase in favor of a direct mapping. However, beware that if you have set a handler for C.class, my object d above will not be recognized.here are my 2 cents, I hope they help...instanceof is very efficient, so your performance is unlikely to suffer.\nHowever, using lots of instanceof suggests a design issue.If you can use xClass == String.class, this is faster.  Note: you don\'t need instanceof for final classes.\'instanceof\' is actually an operator, like + or -, and I believe that it has its own JVM bytecode instruction.  It should be plenty fast.I should not that if you have a switch where you are testing if an object is an instance of some subsclass, then your design might need to be reworked.  Consider pushing the subclass-specific behavior down into the subclasses themselves.Instanceof is very fast. It boils down to a bytecode that is used for class reference comparison. Try a few million instanceofs in a loop and see for yourself.It\'s hard to say how a certain JVM implements instance of, but in most cases, Objects are comparable to structs and classes are as well and every object struct has a pointer to the the class struct it is an instance of. So actually instanceof formight be as fast as the following C codeassuming a JIT compiler is in place and does a decent job.Considering that this is only accessing a pointer, getting a pointer at a certain offset the pointer points to and comparing this to another pointer (which is basically the same as testing to 32 bit numbers being equal), I\'d say the operation can actually be very fast.It doesn\'t have to, though, it depends a lot on the JVM. However, if this would turn out to be the bottleneck operation in your code, I\'d consider the JVM implementation rather poor. Even one that has no JIT compiler and only interprets code should be able to make an instanceof test in virtually no time.InstanceOf is a warning of poor Object Oriented design.Current JVMs do mean the instanceOf is not much of a performance worry in itself. If you are finding yourself using it a lot, especially for core functionality, it is probably time to look at the design. The performance (and simplicity/maintainability) gains of refactoring to a better design will greatly outweigh any actual processor cycles spent on the actual instanceOf call.To give a very small simplistic programming example.Is a poor architecture a better choice would have been to have SomeObject be the parent class of two child classes where each child class overrides a method (doSomething) so the code would look as such:Demian and Paul mention a good point; however, the placement of the code to execute really depends on how you want to use the data...I\'m a big fan of small data objects that can be used in many ways. If you follow the override (polymorphic) approach, your objects can only be used "one way".This is where patterns come in...You can use double-dispatch (as in the visitor pattern) to ask each object to "call you" passing itself -- this will resolve the type of the object. However (again) you\'ll need a class that can "do stuff" with all of the possible subtypes.I prefer to use a strategy pattern, where you can register strategies for each subtype you want to handle. Something like the following. Note that this only helps for exact type matches, but has the advantage that it\'s extensible - third-party contributors can add their own types and handlers. (This is good for dynamic frameworks like OSGi, where new bundles can be added)Hopefully this will inspire some other ideas...Unless you\'re doing it in an inner loop, I wouldn\'t worry about it.Generally the reason why the "instanceof" operator is frowned upon in a case like that (where the instanceof is checking for subclasses of this base class) is because what you should be doing is moving the operations into a method and overridding it for the appropriate subclasses.  For instance, if you have:You can replace that withand then have the implementation of "doEverything()" in Class1 call "doThis()", and in Class2 call "doThat()", and so on.In modern Java version the instanceof operator is faster as a simple method call. This means:is faster as:Another thing is if you need to cascade many instanceof. Then a switch that only call once getType() is faster.If speed is your sole aim then using int constants to identify sub classes seems to shave a milliseconds of the timeterrible OO design, but if your performance analysis indicates this is where you bottleneck is then maybe. In my code the dispatch code takes 10% of total execution time and this maybe contributed to a 1% total speed improvement.I\'ll get back to you on instanceof performance. But a way to avoid problem (or lack thereof) altogether would be to create a parent interface to all the subclasses on which you need to do instanceof. The interface will be an super set of all the methods in sub-classes for which you need to do instanceof check. Where a method does not apply to a specific sub-class, simply provide a dummy implementation of this method. If I didn\'t misunderstand the issue, this is how I\'ve gotten around the problem int he past. You should measure/profile if it\'s really a performance issue in your project. If it is I\'d recommend a redesign - if possible. I\'m pretty sure you can\'t beat the platform\'s native implementation (written in C). You should also consider the multiple inheritance in this case.You should tell more about the problem, maybe you could use an associative store, e.g. a Map<Class, Object> if you are only interested in the concrete types.With regard to Peter Lawrey\'s note that you don\'t need instanceof for final classes and can just use a reference equality, be careful!  Even though the final classes cannot be extended, they are not guaranteed to be loaded by the same classloader.  Only use x.getClass() == SomeFinal.class or its ilk if you are absolutely positive that there is only one classloader in play for that section of code.I also prefer an enum approach, but I would use a abstract base class to force the subclasses to implement the getType() method.You\'re focusing on the wrong thing.  The difference between instanceof and any other method for checking the same thing would probably not even be measurable.  If performance is critical then Java is probably the wrong language.  The major reason being that you can\'t control when the VM decides it wants to go collect garbage, which can take the CPU to 100% for several seconds in a large program (MagicDraw 10 was great for that).  Unless you are in control of every computer this program will run on you can\'t guarantee which version of JVM it will be on, and many of the older ones had major speed issues.  If it\'s a small app you may be ok with Java, but if you are constantly reading and discarding data then you will notice when the GC kicks in.