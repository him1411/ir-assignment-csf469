Is it possible to write something similar to the following?Yes, but you need to declare it readonly instead of const:The reason is that const can only be applied to a field whose value is known at compile-time. The array initializer you\'ve shown is not a constant expression in C#, so it produces a compiler error.Declaring it readonly solves that problem because the value is not initialized until run-time (although it\'s guaranteed to have initialized before the first time that the array is used).Depending on what it is that you ultimately want to achieve, you might also consider declaring an enum:You can declare array as readonly, but keep in mind that you can change element of readonly array.Consider using enum, as Cody suggested, or IList.You can\'t create a \'const\' array because arrays are objects and can only be\ncreated at runtime and const entities are resolved at compile time.What you can do instead is to declare your array as "readonly". This has the\nsame effect as const except the value can be set at runtime. It can only be\nset once and it is thereafter a readonly (i.e. const) value.You could take a different approach: define a constant string to represent your array and then split the string into an array when you need it, e.g.This approach gives you a constant which can be stored in configuration and converted to an array when needed.AlastairFor my needs I define static array, instead of impossible const and it works:\npublic static string[] Titles = { "German", "Spanish", "Corrects", "Wrongs" };Since C# 6 you can write it like:See also: C# : The New and Improved C# 6.0 (specifically the chapter "Expression Bodied Functions and Properties")This will make a read-only static property, but it will still allow you to alter the content of the array returned, but when you call the property again, you will get the original, unaltered array again.For clarification, this code is the same as (or actually a shorthand for):Please note that there is a downside to this approach: A new array is actually instantiated on each and every reference, so if you are using a very large array, this might not be the most efficient solution.\nBut if you re-use the same array (by putting it in a private attribute for instance) it will again open up the possibility to change the contents of the array.If you want to have an immutable array (or list) you could also use:But, this still has a risk for changes, as you can still cast it back to a string[] and alter the contents, as such:This is a way to do what you want:It is very similar to doing a readonly array.I believe you can only make it readonly.Arrays are probably one of those things that can only be evaluated at\nruntime. Constants must be evaluated at compile time. Try using "readonly"\ninstead of "const".A .NET Framework v4.5+ solution that improves on tdbeckett\'s answer:Note: Given that the collection is conceptually constant, it may make sense to make it static to declare it at the class level.The above:Initializes the property\'s implicit backing field once with the array.Note that { get; } - i.e., declaring only a property getter - is what makes the property itself implicitly read-only (trying to combine readonly with { get; } is actually a syntax error).Alternatively, you could just omit the { get; } and add readonly to create a field instead of a property, as in the question, but exposing public data members as properties rather than fields is a good habit to form.Creates an array-like structure (allowing indexed access) that is truly and robustly read-only (conceptually, constant, once created), both with respect to:As an alternative, to get around the elements-can-be-modified issue with a readonly array, you can use a static property instead. (The individual elements can still be changed, but these changes will only be made on the local copy of the array.)Of course, this will not be particularly efficient as a new string array is created each time.