I am trying to extend the JSON.net example given here \nhttp://james.newtonking.com/projects/json/help/CustomCreationConverter.htmlI have another sub class deriving from base class/InterfaceHow do I deserialize following Json back to List< Person >I don\'t want to use TypeNameHandling JsonSerializerSettings. I am specifically looking for custom JsonConverter implementation to handle this. The documentation and examples around this are pretty sparse on the net. I can\'t seem to get the the overridden ReadJson() method implementation in JsonConverter right.Using the standard CustomCreationConverter, I was struggling to work how to generate the correct type (Person or Employee), because in order to determine this you need to analyse the JSON and there is no built in way to do this using the Create method.I found a discussion thread pertaining to type conversion and it turned out to provide the answer. Here is a link: Type converting.What\'s required is to subclass JsonConverter, overriding the ReadJson method and creating a new abstract Create method which accepts a JObject.The JObject class provides a means to load a JSON object and\n  provides access to the data within this object.The overridden ReadJson method creates a JObject and invokes the Create method (implemented by our derived converter class), passing in the JObject instance.This JObject instance can then be analysed to determine the correct type by checking existence of certain fields.ExampleThe above solution for the JsonCreationConverter<T> is all over the internet, but has a flaw that manifests itself in rare occasions. The new JsonReader created in the ReadJson method does not inherit any of the original reader\'s configuration values (Culture, DateParseHandling, DateTimeZoneHandling, FloatParseHandling, etc...). These values should be copied over before using the new JsonReader in serializer.Populate().This is the best I could come up with to fix some of the problems with the above implementation, but I still think there are some things being overlooked:Update I updated this to have a more explicit method that makes a copy of an existing reader. This just encapsulates the process of copying over individual JsonReader settings. Ideally this function would be maintained in the Newtonsoft library itself, but for now, you can use the following:This should be used as follows:Older solution follows:Just thought i would share a solution also based on this that works with the Knowntype attribute using reflection , had to get derived class from any base class, solution can benefit from recursion to find the best matching class though i didn\'t need it in my case, matching is done by the type given to the converter if it has KnownTypes it will scan them all until it matches a type that has all the properties inside the json string, first one to match will be chosen. usage is as simple as:in the above case ret will be of type B.JSON classes:Converter code:This is an expansion to totem\'s answer. It does basically the same thing but the property matching is based on the serialized json object, not reflect the .net object. This is important if you\'re using [JsonProperty], using the CamelCasePropertyNamesContractResolver, or doing anything else that will cause the json to not match the .net object. Usage is simple:Converter code:As another variation on Totem\'s known type solution, you can use reflection to create a generic type resolver to avoid the need to use known type attributes.This uses a technique similar to Juval Lowy\'s GenericResolver for WCF.As long as your base class is abstract or an interface, the known types will be automatically determined rather than having to be decorated with known type attributes.In my own case I opted to use a $type property to designate type in my json object rather than try to determine it from the properties, though you could borrow from other solutions here to use property based determination.It can then be installed as a formatterHere\'s another solution that avoids the use of jObject.CreateReader(), and instead creates a new JsonTextReader (which is the behavior used by the default JsonCreate.Deserialze method:The project JsonSubTypes implement a generic converter that handle this feature with the helps of attributes.For the concrete sample provided here is how it works: