We are developing a C# application for a web-service client. This will run on Windows XP PC\'s.One of the fields returned by the web service is a DateTime field. The server returns a field in GMT format i.e. with a "Z" at the end.However, we found that .NET seems to do some kind of implicit conversion and the time was always 12 hours out.The following code sample resolves this to some extent in that the 12 hour difference has gone but it makes no allowance for NZ daylight saving.As per this date site:UTC/GMT Offset Standard time zone: UTC/GMT +12 hours\n  Daylight saving time: +1 hour\n  Current time zone offset: UTC/GMT +13 hours How do we adjust for the extra hour? Can this be done programmatically or is this some kind of setting on the PC\'s?For strings such as 2012-09-19 01:27:30.000, DateTime.Parse cannot tell what time zone the date and time are from.DateTime has a Kind property, which can have one of three time zone options:NOTE If you are wishing to represent a date/time other than UTC or your local time zone, then you should use DateTimeOffset.So for the code in your question:You say you know what kind it is, so tell it.Now, once the system knows its in UTC time, you can just call ToLocalTime:This will give you the result you require.I\'d look into using the System.TimeZoneInfo class if you are in .NET 3.5. See http://msdn.microsoft.com/en-us/library/system.timezoneinfo.aspx. This should take into account the daylight savings changes correctly.I know this is an older question, but I ran into a similar situation, and I wanted to share what I had found for future searchers, possibly including myself :).DateTime.Parse() can be tricky -- see here for example.If the DateTime is coming from a Web service or some other source with a known format, you might want to consider something like  or, even better,The AssumeUniversal flag tells the parser that the date/time is already UTC; the combination of AssumeUniversal and AdjustToUniversal tells it not to convert the result to "local" time, which it will try to do by default.  (I personally try to deal exclusively with UTC in the business / application / service layer(s) anyway.  But bypassing the conversion to local time also speeds things up -- by 50% or more in my tests, see below.)Here\'s what we were doing before:  We had profiled the app and found that the DateTime.Parse represented a significant percentage of CPU usage.  (Incidentally, the CultureInfo constructor was not a significant contributor to CPU usage.)  So I set up a console app to parse a date/time string 10000 times in a variety of ways.  Bottom line:\nParse() 10 sec\nParseExact() (converting to local) 20-45 ms\nParseExact() (not converting to local) 10-15 ms\n... and yes, the results for Parse() are in seconds, whereas the others are in milliseconds.I\'d just like to add a general note of caution.If all you are doing is getting the current time from the computer\'s internal clock to put a date/time on the display or a report, then all is well.  But if you are saving the date/time information for later reference or are computing date/times, beware!Let\'s say you determine that a cruise ship arrived in Honolulu on 20 Dec 2007 at 15:00 UTC.  And you want to know what local time that was.\n1. There are probably at least three \'locals\' involved.  Local may mean Honolulu, or it may mean where your computer is located, or it may mean the location where your customer is located.\n2. If you use the built-in functions to do the conversion, it will probably be wrong.  This is because daylight savings time is (probably) currently in effect on your computer, but was NOT in effect in December.  But Windows does not know this... all it has is one flag to determine if daylight savings time is currently in effect.  And if it is currently in effect, then it will happily add an hour even to a date in December.\n3. Daylight savings time is implemented differently (or not at all) in various political subdivisions.  Don\'t think that just because your country changes on a specific date, that other countries will too.DateTime objects have the Kind of Unspecified by default, which for the purposes of ToLocalTime is assumed to be UTC.To get the local time of an Unspecified DateTime object, you therefore just need to do this:The step of changing the Kind of the DateTime from Unspecified to UTC is unnecessary. Unspecified is assumed to be UTC for the purposes of ToLocalTime: http://msdn.microsoft.com/en-us/library/system.datetime.tolocaltime.aspxDon\'t forget if you already have a DateTime object and are not sure if it\'s UTC or Local, it\'s easy enough to use the methods on the object directly:How do we adjust for the extra hour?Unless specified .net will use the local pc settings. I\'d have a read of: http://msdn.microsoft.com/en-us/library/system.globalization.daylighttime.aspxBy the looks the code might look something like:And as mentioned above double check what timezone setting your server is on. There are articles on the net for how to safely affect the changes in IIS.In answer to Dana\'s suggestion:The code sample now looks like:The original date was 20/08/08; the kind was UTC.Both "convertedDate" and "dt" are the same:21/08/08 10:00:26; the kind was localI had the problem with it being in a data set being pushed across the wire (webservice to client) that it would automatically change because the DataColumn\'s DateType field was set to local. Make sure you check what the DateType is if your pushing DataSets across.If you don\'t want it to change, set it to UnspecifiedI came across this question as I was having a problem with the UTC dates you get back through the twitter API (created_at field on a status); I need to convert them to DateTime. None of the answers/ code samples in the answers on this page were sufficient to stop me getting a "String was not recognized as a valid DateTime" error (but it\'s the closest I have got to finding the correct answer on SO)Posting this link here in case this helps someone else - the answer I needed was found on this blog post: http://www.wduffy.co.uk/blog/parsing-dates-when-aspnets-datetimeparse-doesnt-work/ - basically use DateTime.ParseExact with a format string instead of DateTime.Parse