Can someone help explain how can building a heap be O(n) complexity? Inserting an item into a heap is O(log n), and the insert is repeated n/2 times (the remainder are leaves, and can\'t violate the heap property). So, this means the complexity should be O(n log n), I would think.In other words, for each item we "heapify", it has the potential to have to filter down once for each level for the heap so far (which is log n levels).What am I missing?Your analysis is correct. However, it is not tight. It is not really easy to explain why building a heap is a linear operation, you should better read it.A great analysis of the algorithm can be seen here.The main idea is that in the build_heap algorithm the actual heapify cost is not O(log n)for all elements.When heapify is called, the running time depends on how far an element might move down in tree before the process terminates. In other words, it depends on the height of the element in the heap. In the worst case, the element might go down all the way to the leaf level. Let us count the work done level by level.At the bottommost level, there are 2^(h)nodes, but we do not call heapify on any of these, so the work is 0. At the next to level there are 2^(h \xe2\x88\x92 1) nodes, and each might move down by 1 level. At the 3rd level from the bottom, there are 2^(h \xe2\x88\x92 2) nodes, and each might move down by 2 levels.As you can see not all heapify operations are O(log n), this is why you are getting O(n).The accepted answer gives the correct analysis to show that buildHeap runs in O(n) time. But the question was raised: "This is a great explanation...but why is it then that the heap-sort runs in O(n log n). Why doesn\'t the same reasoning apply to heap-sort?" An answer was given in the comments that suggests that the difference lies in siftDown vs. siftUp that I think somewhat misses the point (or is just too brief to make it obvious). Indeed, you don\'t need to use siftUp at all when implementing a heap sort (although it is required for a priority queue, for example, to implement the insert operation). EDIT: I\'ve modified my answer to describe how a max heap works. This is the type of heap typically used for heap sort or for a priority queue where higher values indicate higher priority. A min heap is also useful; for example, when retrieving items with integer keys in ascending order or strings in alphabetical order. The principles are exactly the same, you just need to switch the sort order.Remember that the heap property specifies that each node must be at least as large as both of its children. In particular, this implies that the largest item in the heap is at the root. Sifting down and sifting up are essentially the same operation in opposite directions: move an offending node until it satisfies the heap property:The number of operations required for each operation is proportional to the distance the node may have to move. For siftDown, it is the distance from the bottom of the tree, so siftDown is expensive for nodes at the top of the tree. With siftUp, the work is proportional to the distance from the top of the tree, so siftUp is expensive for nodes at the bottom of the tree. Although both operations are O(log n) in the worst case, in a heap, only one node is at the top whereas half the nodes lie in the bottom layer. So it shouldn\'t be too surprising that if we have to apply an operation to every node, we would prefer siftDown over siftUp.The buildHeap function takes an array of unsorted items and moves them until it they all satisfy the heap property. There are two approaches one might take for buildHeap. One is to start at the top of the heap (the beginning of the array) and call siftUp on each item. At each step, the previously sifted items (the items before the current item in the array) form a valid heap, and sifting the next item up places it into a valid position in the heap. After sifting up each node, all items satisfy the heap property. The second approach goes in the opposite direction: start at the end of the array and move backwards towards the front. At each iteration, you sift an item down until it is in the correct location.Both of these solutions will produce a valid heap. The question is: which implementation for buildHeap is more efficient? Unsurprisingly, it is the second operation that uses siftDown. If h = log n is the height, then the work required for the siftDown approach is given by the sumEach term in the sum has the maximum distance a node at the given height will have to move (zero for the bottom layer, h for the root) multiplied by the number of nodes at that height. In contrast, the sum for calling siftUp on each node isIt should be clear that the second sum is larger. The first term alone is hn/2 = 1/2 n log n, so this approach has complexity at best O(n log n). However, the sum for the siftDown approach can be bounded by extending it to a Taylor series to show that it is indeed O(n). If there is interest, I can edit my answer to include the details. Obviously, O(n) is the best you could hope for.The next question is: if it is possible to run buildHeap in linear time, why does heap sort require O(n log n) time? Well, heap sort consists of two stages. First, we call buildHeap on the array, which requires O(n) time if implemented optimally. The next stage is to  repeatedly delete the largest item in the heap and put it at the end of the array. Because we delete an item from the heap, there is always an open spot just after the end of the heap where we can store the item. So heap sort achieves a sorted order by successively removing the next largest item and putting it into the array starting at the last position and moving towards the front. It is the complexity of this last part that dominates in heap sort. The loop looks likes this:Clearly, the loop runs O(n) times (n - 1 to be precise, the last item is already in place). The complexity of deleteMax for a heap is O(log n). It is typically implemented by removing the root (the largest item left in the heap) and replacing it with the last item in the heap, which is a leaf, and therefore one of the smallest items. This new root will almost certainly violate the heap property, so you have to call siftDown until you move it back into an acceptable position. This also has the effect of moving the next largest item up to the root. Notice that, in contrast to buildHeap where for most of the nodes we are calling siftDown from the bottom of the tree, we are now calling siftDown from the top of the tree on each iteration! Although the tree is shrinking, it doesn\'t shrink fast enough: The height of the tree stays constant until you have removed the first half of the nodes (when you clear out the bottom layer completely). Then for the next quarter, the height is h - 1. So the total work for this second stage isNotice the switch: now the zero work case corresponds to a single node and the h work case corresponds to half the nodes. This sum is O(n log n) just like the inefficient version of buildHeap that is implemented using siftUp. But in this case, we have no choice since we are trying to sort and we require the next largest item be removed next.In summary, the work for heap sort is the sum of the two stages:  O(n) time for buildHeap and O(n log n) to remove each node in order, so the complexity is O(n log n). You can prove (using some ideas from information theory) that for a comparison-based sort, O(n log n) is the best you could hope for anyway, so there\'s no reason to be disappointed by this or expect heap sort to achieve the O(n) time bound that buildHeap does."The complexity should be O(nLog n)... for each item we "heapify", it has the potential to have to filter down once for each level for the heap so far (which is log n levels)."Not quite. Your logic does not produce a tight bound -- it over estimates the complexity of each heapify. If built from the bottom up, insertion (heapify) can be much less than O(log(n)). The process is as follows:( Step 1 ) The first n/2 elements go on the bottom row of the heap. h=0, so heapify is not needed.( Step 2 ) The next n/22 elements go on the row 1 up from the bottom. h=1, heapify filters 1 level down.( Step i ) \nThe next n/2i elements go in row i up from the bottom. h=i, heapify filters i levels down.( Step log(n) ) The last n/2log2(n) = 1 element goes in row log(n) up from the bottom. h=log(n), heapify filters log(n) levels down.NOTICE: that after step one, 1/2 of the elements (n/2) are already in the heap, and we didn\'t even need to call heapify once. Also, notice that only a single element, the root, actually incurs the full log(n) complexity.The Total steps N to build a heap of size n, can be written out mathematically. At height i, we\'ve shown (above) that there will be n/2i+1 elements that need to call heapify, and we know heapify at height i is O(i). This gives:The solution to the last summation can be found by taking the derivative of both sides of the well known geometric series equation:Finally, plugging in x = 1/2 into the above equation yields 2. Plugging this into the first equation gives:Thus, the total number of steps is of size O(n)It would be O(n log n) if you built the heap by repeatedly inserting elements.  However, you can create a new heap more efficiently by inserting the elements in arbitrary order and then applying an algorithm to "heapify" them into the proper order (depending on the type of heap of course).See http://en.wikipedia.org/wiki/Binary_heap, "Building a heap" for an example.  In this case you essentially work up from the bottom level of the tree, swapping parent and child nodes until the heap conditions are satisfied.  While building a heap, lets say you\'re taking a bottom up approach.As we know the height of a heap is log(n), where n is the total number of elements.Lets represent it as h\n   When we perform heapify operation, then the elements at last level(h) won\'t move even a single step.   The number of elements at second last level(h-1) is 2h-1 and they can move at max 1 level(during heapify).    Similarly, for the ith, level we have 2i elements which can move h-i positions.Therefore total number of moves=S= 2h*0+2h-1*1+2h-2*2+...20*h                                               S=2h {1/2 + 2/22 + 3/23+ ... h/2h}                     -------------------------------------------------1\nthis is AGP series, to solve this divide both sides by 2\n                                               S/2=2h {1/22 + 2/23+ ... h/2h+1}                     -------------------------------------------------2\nsubtracting equation 2 from 1 gives\n                                               S/2=2h {1/2+1/22 + 1/23+ ...+1/2h+ h/2h+1}\n                                               S=2h+1 {1/2+1/22 + 1/23+ ...+1/2h+ h/2h+1}\nnow 1/2+1/22 + 1/23+ ...+1/2h is decreasing GP whose sum is less than 1 (when h tends to infinity, the sum tends to 1). In further analysis, let\'s take an upper bound on the sum which is 1. \nThis gives S=2h+1{1+h/2h+1}                    =2h+1+h                    ~2h+has h=log(n), 2h=n\nTherefore S=n+log(n) T(C)=O(n)Successive insertions can be described by: By starling approximation, n! =~ O(n^(n + O(1))), therefore T =~ O(nlog(n))Hope this helps, the optimal way O(n) is using the build heap algorithm for a given set (ordering doesn\'t matter).In case of building the heap, we start from height,\n    logn -1 (where logn is the height of tree of n elements). \nFor each element present at height \'h\', we go at max upto (logn -h) height down.@bcorso has already demonstrated the proof of the complexity analysis. But for the sake of those still learning complexity analysis, I have this to add:The basis of your original mistake is due to a misinterpretation of the meaning of the statement, "insertion into a heap takes O(log n) time". Insertion into a heap is indeed O(log n), but you have to recognise that n is the size of the heap during the insertion.In the context of inserting n objects into a heap, the complexity of the ith insertion is O(log n_i) where n_i is the size of the heap as at insertion i. Only the last insertion has a complexity of O (log n).I really like explanation by Jeremy west.... another approach which is really easy for understanding is given here  http://courses.washington.edu/css343/zander/NotesProbs/heapcomplexity since, buildheap depends using depends on heapify and shiftdown approach is used which depends upon sum of the heights of all nodes. So, to find the sum of height of nodes which is given by\n          S = summation from i = 0 to i = h of (2^i*(h-i)), where h = logn is height of the tree\n        solving s, we get s = 2^(h+1) - 1 - (h+1)\n        since, n = 2^(h+1) - 1\n        s = n - h - 1 = n- logn - 1\n        s = O(n), and so complexity of buildheap is O(n)."The linear time bound of build Heap, can be shown by computing the sum of the heights of all the nodes in the heap, which is the maximum number of dashed lines.\nFor the perfect binary tree of height h containing N = 2^(h+1) \xe2\x80\x93 1 nodes, the sum of the heights of the nodes is N \xe2\x80\x93 H \xe2\x80\x93 1.\nThus it is O(N)."Basically, work is done only on non-leaf nodes while building a heap...and the work done is the amount of swapping down to satisfy heap condition...in other words (in worst case) the amount is proportional to the height of the node...all in all the complexity of the problem is proportional to the sum of heights of all the non-leaf nodes..which is (2^h+1 - 1)-h-1=n-h-1= O(n)think you\'re making a mistake. Take a look at this: http://golang.org/pkg/container/heap/ Building a heap isn\'y O(n). However, inserting is O(lg(n). I\'m assuming initialization is O(n) if you set a heap size b/c the heap needs to allocate space and set up the data structure.\nIf you have n items to put into the heap then yes, each insert is lg(n) and there are n items, so you get n*lg(n) as u stated