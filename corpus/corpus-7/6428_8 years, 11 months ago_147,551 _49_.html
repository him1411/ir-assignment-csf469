I have a Spring MVC web app which uses Spring Security.  I want to know the username of the currently logged in user.  I\'m using the code snippet given below .  Is this the accepted way?  I don\'t like having a call to a static method inside this controller - that defeats the whole purpose of Spring, IMHO.  Is there a way to configure the app to have the current SecurityContext, or current Authentication, injected instead?  If you are using Spring 3, the easiest way is:A lot has changed in the Spring world since this question was answered. Spring has simplified getting the current user in a controller. For other beans, Spring has adopted the suggestions of the author and simplified the injection of \'SecurityContextHolder\'. More details are in the comments.This is the solution I\'ve ended up going with.  Instead of using SecurityContextHolder in my controller, I want to inject something which uses SecurityContextHolder under the hood but abstracts away that singleton-like class from my code.  I\'ve found no way to do this other than rolling my own interface, like so:Now, my controller (or whatever POJO) would look like this:And, because of the interface being a point of decoupling, unit testing is straightforward. In this example I use Mockito:The default implementation of the interface looks like this:And, finally, the production Spring config looks like this:It seems more than a little silly that Spring, a dependency injection container of all things, has not supplied a way to inject something similar.  I understand SecurityContextHolder was inherited from acegi, but still.  The thing is, they\'re so close - if only SecurityContextHolder had a getter to get the underlying SecurityContextHolderStrategy instance (which is an interface), you could inject that.  In fact, I even opened a Jira issue to that effect.One last thing - I\'ve just substantially changed the answer I had here before.  Check the history if you\'re curious but, as a coworker pointed out to me, my previous answer would not work in a multi-threaded environment.  The underlying SecurityContextHolderStrategy used by SecurityContextHolder is, by default, an instance of ThreadLocalSecurityContextHolderStrategy, which stores SecurityContexts in a ThreadLocal.  Therefore, it is not necessarily a good idea to inject the SecurityContext directly into a bean at initialization time - it may need to be retrieved from the ThreadLocal each time, in a multi-threaded environment, so the correct one is retrieved.I agree that having to query the SecurityContext for the current user stinks, it seems a very un-Spring way to handle this problem.I wrote a static "helper" class to deal with this problem; it\'s dirty in that it\'s a global and static method, but I figured this way if we change anything related to Security, at least I only have to change the details in one place:To make it just show up in your JSP pages, you can use the Spring Security Tag Lib:http://static.springsource.org/spring-security/site/docs/3.0.x/reference/taglibs.htmlTo use any of the tags, you must have the security taglib declared in your JSP:Then in a jsp page do something like this:NOTE: As mentioned in the comments by @SBerg413, you\'ll need to add use-expressions="true"to the "http" tag in the security.xml config for this to work.I get authenticated user by\nHttpServletRequest.getUserPrincipal();Example:If you are using Spring Security ver >= 3.2, you can use the @AuthenticationPrincipal annotation:Here, CustomUser is a custom object that implements UserDetails that is returned by a custom UserDetailsService.More information can be found in the @AuthenticationPrincipal chapter of the Spring Security reference docs.In Spring 3+ you have have following options.Option 1 : Option 2 : Option 3:Option 4 : Fancy one : Check this out for more detailsYes, statics are generally bad - generally, but in this case, the static is the most secure code you can write.  Since the security context associates a Principal with the currently running thread, the most secure code would access the static from the thread as directly as possible.  Hiding the access behind a wrapper class that is injected provides an attacker with more points to attack.  They wouldn\'t need access to the code (which they would have a hard time changing if the jar was signed), they just need a way to override the configuration, which can be done at runtime or slipping some XML onto the classpath.  Even using annotation injection in the signed code would be overridable with external XML.  Such XML could inject the running system with a rogue principal.  This is probably why Spring is doing something so un-Spring-like in this case.I would just do this:For the last Spring MVC app I wrote, I didn\'t inject the SecurityContext holder, but I did have a base controller that I had two utility methods related to this  ... isAuthenticated() & getUsername(). Internally they do the static method call you described.At least then it\'s only in once place if you need to later refactor.You could use Spring AOP aproach.\nFor example if you have some service, that needs to know current principal. You could introduce custom annotation i.e. @Principal , which indicate that this Service should be principal dependent.Then in your  advice, which I think needs to extend MethodBeforeAdvice, check that particular service has @Principal annotation and inject Principal name, or set it to \'ANONYMOUS\' instead.The only problem is that even after authenticating with Spring Security, the user/principal bean doesn\'t exist in the container, so dependency-injecting it will be difficult.  Before we used Spring Security we would create a session-scoped bean that had the current Principal, inject that into an "AuthService" and then inject that Service into most of the other services in the Application.  So those Services would simply call authService.getCurrentUser() to get the object.  If you have a place in your code where you get a reference to the same Principal in the session, you can simply set it as a property on your session-scoped bean.The best solution if you are using Spring 3 and need the authenticated principal in your controller is to do something like this:Try thisAuthentication authentication =\n  SecurityContextHolder.getContext().getAuthentication();\n  String userName = authentication.getName();I am using the @AuthenticationPrincipal annotation in @Controller classes as well as in @ControllerAdvicer annotated ones. Ex.:Where UserActive is the class i use for logged users services, and extends from org.springframework.security.core.userdetails.User. Something like:Really easy.Define Principal as a dependency in your controller method and spring will inject the current authenticated user in your method at invocation.this is old question but still we have different way to get user name during July-2016 using Spring 4, Boot, Security, OAuth2 and Angular2 \nPlease correct me if I\'m wrong because I\'m looking for simple solutionI like to share my way of supporting user details on freemarker page.\nEverything is very simple and working perfectly!You just have to place Authentication rerequest on default-target-url (page after form-login)\nThis is my Controler method for that page:And this is my ftl code:And that\'s it, username will appear on every page after authorisation.