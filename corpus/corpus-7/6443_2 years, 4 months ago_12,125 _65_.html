Is it possible to get a random number between 1-100 and keep the results mainly within the 40-60 range? I mean, it will go out of that range rarely, but I want it to be mainly within that range... Is it possible with JavaScript/jQuery?Right now I\'m just using the basic Math.random() * 100 + 1.The simplest way would be to generate two random numbers from 0-50 and add them together.This gives a distribution biased towards 50, in the same way rolling two dice biases towards 7.In fact, by using a larger number of "dice" (as @Falco suggests), you can make a closer approximation to a bell-curve:JSFiddle: http://jsfiddle.net/797qhcza/1/You have some good answers here that give specific solutions; let me describe for you the general solution.  The problem is:The general solution to this problem is to work out the quantile function of your desired distribution, and then apply the quantile function to the output of your uniform source.The quantile function is the inverse of the integral of your desired distribution function. The distribution function is the function where the area under a portion of the curve is equal to the probability that the randomly-chosen item will be in that portion.I give an example of how to do so here:http://ericlippert.com/2012/02/21/generating-random-non-uniform-data/The code in there is in C#, but the principles apply to any language; it should be straightforward to adapt the solution to JavaScript.Taking arrays of numbers, etc. isn\'t efficient. You should take a mapping which takes a random number between 0 to 100 and maps to the distribution you need. So in your case, you could take f(x)=-(1/25)x2+4x to get a distribution with the most values in the middle of your range.I might do something like setup a "chance" for the number to be allowed to go "out of bounds". In this example, a 20% chance the number will be 1-100, otherwise, 40-60:fiddle: http://jsfiddle.net/kbv39s9w/I needed to solve this problem a few years ago and my solution was easier than any of the other answers. I generated 3 randoms between the bounds and averaged them. This pulls the result towards the centre but leaves it completely possible to reach the extremities. It looks stupid but you can use rand twice:Sure it is possible. Make a random 1-100. If the number is <30 then generate number in range 1-100 if not generate in range 40-60. There is a lot of different ways to generate such random numbers. One way to do it is to compute the sum of multiple uniformly random numbers. How many random numbers you sum and what their range is will determine how the final distribution will look.The more numbers you sum up, the more it will be biased towards the center. Using the sum of 1 random number was already proposed in your question, but as you notice is not biased towards the center of the range. Other answers have propose using the sum of 2 random numbers or the sum of 3 random numbers.You can get even more bias towards the center of the range by taking the sum of more random numbers. At the extreme you could take the sum of 99 random numbers which each were either 0 or 1. That would be a binomial distribution. (Binomial distributions can in some sense be seen as the discrete version of normal distributions). This can still in theory cover the full range, but it has so much bias towards the center that you should never expect to see it reach the endpoints.This approach means you can tweak just how much bias you want.What about using something like this:The way I\'ve coded it allows you to set a couple of variables:\nloops = number of results\ntries = number of times the function will try to get a number between 40-60 before it stops running through the while loopAdded bonus: It uses do while!!! Awesomeness at its bestYou can write a function that maps random values between [0, 1) to [1, 100] according to weight. Consider this example:Here, the value 0.95 maps to value between [61, 100].\nIn fact we have .05 / .1 = 0.5, which, when mapped to [61, 100], yields 81.Here is the function:Here\'s a weighted solution at 3/4 40-60 and 1/4 outside that range.Ok, so I decided to add another answer because I felt like my last answer, as well as most answers here, use some sort of half-statistical way of obtaining a bell-curve type result return. The code I provide below works the same way as when you roll a dice. Therefore, it is hardest to get 1 or 99, but easiest to get 50.I\'d recommend using the beta distribution to generate a number between 0-1, then scale it up. It\'s quite flexible and can create many different shapes of distributions.Here\'s a quick and dirty sampler:The best solution targeting this very problem is the one proposed by BlueRaja - Danny Pflughoeft but I think a somewhat faster and more general solution is also worth mentioning.When I have to generate random numbers (strings, coordinate pairs, etc.) satisfying the two requirements ofI usually start by creating an array of numbers (strings, coordinate pairs, etc.) fulfilling the requirement (In your case: an array of numbers containing the more probable ones multiple times.), then choose a random item of that array. This way, you only have to call the expensive random function once per item.DistributionSolutionGeneric SolutionYou can use a helper random number to whether generate random numbers in 40-60 or 1-100:The best way to do that is generating a random number that is distributed equally in a certain set of numbers, and then apply a projection function to the set between 0 and a 100 where the projection is more likely to hit the numbers you want.Typically the mathematical way of achieving this is plotting a probability function of the numbers you want. We could use the bell curve, but let\'s for the sake of easier calculation just work with a flipped parabola.Let\'s make a parabola such that its roots are at 0 and 100 without skewing it. We get the following equation:Now, all the area under the curve between 0 and 100 is representative of our first set where we want the numbers generated. There, the generation is completely random. So, all we need to do is find the bounds of our first set.The lower bound is, of course, 0. The upper bound is the integral of our function at 100, which isSo we know that we need to generate a number somewhere between 0 and 166,666. Then, we simply need to take that number and project it to our second set, which is between 0 and 100.We know that the random number we generated is some integral of our parabola with an input x between 0 and 100. That means that we simply have to assume that the random number is the result of F(x), and solve for x.In this case, F(x) is a cubic equation, and in the form F(x) = ax^3 + bx^2 + cx + d = 0, the following statements are true:Solving this for x yields you the actual random number your are looking for, which is guaranteed to be in the [0, 100] range and a much higher likelihood to be close to the center than the edges.This answer is really good. But I would like to post implementation instructions (I\'m not into JavaScript, so I hope you will understand) for different situation.Assume you have ranges and weights for every range:Initial Static Information, could be cached:Number generation:Additional note for performance optimizations. Ranges don\'t have to be ordered neither ascending nor descending order, so for faster range look-up range that has highest weight should go first and one with lowest weight should go last.If you can use the gaussian function, use it. This function returns normal number with average 0 and sigma 1.95% of this number are within average +/- 2*sigma. Your average = 50, and sigma = 5 so