What is the advantages/disadvantages of using inline functions in C++? I see that it only increases performance for the code that the compiler outputs, but with today\'s optimized compilers, fast CPUs, huge memory etc. (not like in the 1980< where memory was scarce and everything had to fit in 100KB of memory) what advantages do they really have today?Inline functions are faster because you don\'t need to push and pop things on/off the stack like parameters and the return address; however, it does make your binary slightly larger. Does it make a significant difference?  Not noticeably enough on modern hardware for most.  But it can make a difference, which is enough for some people. Marking something inline does not give you a guarantee that it will be inline.  It\'s just a suggestion to the compiler.  Sometimes it\'s not possible such as when you have a virtual function, or when there is recursion involved.  And sometimes the compiler just chooses not to use it. I could see a situation like this making a detectable difference:In archaic C and C++, inline is like register: a suggestion (nothing more than a suggestion) to the compiler about a possible optimization.In modern C++, inline tells the linker that, if multiple definitions (not declarations) are found in different translation units, they are all the same, and the linker can freely keep one and discard all the other ones.inline is mandatory if a function (no matter how complex or "linear") is defined in a header file, to allow multiple sources to include it without getting a "multiple definition" error by the linker.Member functions defined inside a class are "inline" by default, as are template functions (in contrast to global functions).Note the inclusion of fileA.h into two .cpp files, resulting in two instances of afunc().\nThe linker will discard one of them.\nIf no inline is specified, the linker will complain.Inlining is a suggestion to the compiler which it is free to ignore.  It\'s ideal for small bits of code.If your function is inlined, it\'s basically inserted in the code where the function call is made to it, rather than actually calling a separate function.  This can assist with speed as you don\'t have to do the actual call.It also assists CPUs with pipelining as they don\'t have to reload the pipeline with new instructions caused by a call.The only disadvantage is possible increased binary size but, as long as the functions are small, this won\'t matter too much.I tend to leave these sorts of decisions to the compilers nowadays (well, the smart ones anyway). The people who wrote them tend to have far more detailed knowledge of the underlying architectures.Inline function is the optimization technique used by the compilers. One can simply prepend inline keyword to function prototype to make a function inline. Inline function instruct compiler to insert complete body of the function wherever that function got used in code.Advantages :-It does not require function calling overhead.It also save overhead of variables push/pop on the stack, while function calling.It also save overhead of return call from a function.It increases locality of reference by utilizing instruction cache.After in-lining compiler can also apply intra-procedural optimization if specified. This is the most important one, in this way compiler can now focus on dead code elimination, can give more stress on branch prediction, induction variable elimination etc..To check more about it one can follow this link\nhttp://tajendrasengar.blogspot.com/2010/03/what-is-inline-function-in-cc.htmlI\'d like to add that inline functions are crucial when you are building shared library. Without marking function inline, it will be exported into the library in the binary form. It will be also present in the symbols table, if exported. On the other side, inlined functions are not exported, neither to the library binaries nor to the symbols table.It may be critical when library is intended to be loaded at runtime. It may also hit binary-compatible-aware libraries. In such cases don\'t use inline.During optimization many compilers will inline functions even if you didn\'t mark them. You generally only need to mark functions as inline if you know something the compiler doesn\'t, as it can usually make the correct decision itself.inline allows you to place a function definition in a header file and #include that header file in multiple source files without violating the one definition rule.Generally speaking, these days with any modern compiler worrying about inlining anything is pretty much a waste of time. The compiler should actually optimize all of these considerations for you through its own analysis of the code and your specification of the optimization flags passed to the compiler. If you care about speed, tell the compiler to optimize for speed. If you care about space, tell the compiler to optimize for space. As another answer alluded to, a decent compiler will even inline automatically if it really makes sense.Also, as others have stated, using inline does not guarantee inline of anything. If you want to guarantee it, you will have to define a macro instead of an inline function to do it.When to inline and/or define a macro to force inclusion? - Only when you have a demonstrated and necessary proven increase in speed for a critical section of code that is known to have an affect on the overall performance of the application.It is not all about performance. Both C++ and C are used for embedded programming, sitting on top of hardware. If you would, for example, write an interrupt handler, you need to make sure that the code can be executed at once, without additional registers and/or memory pages being  being swapped. That is when inline comes in handy. Good compilers do some "inlining" themselves when speed is needed, but "inline" compels them. Fell into the same trouble with inlining functions into so libraries. It seems that inlined functions are not compiled into the library. as a result the linker puts out a "undefined reference" error, if a executable wants to use the inlined function of the library. (happened to me compiling Qt source with gcc 4.5.Why not make all functions inline by default? Because it\'s an engineering trade off. There are at least two types of "optimization": speeding up the program and reducing the size (memory footprint) of the program. Inlining generally speeds things up. It gets rid of the function call overhead, avoiding pushing then pulling parameters from the stack. However, it also makes the memory footprint of the program bigger, because every function call must now be replaced with the full code of the function. To make things even more complicated, remember that the CPU stores frequently used chunks of memory in a cache on the CPU for ultra-rapid access. If you make the program\'s memory image big enough, your program won\'t be able to use the cache efficiently, and in the worst case inlining could actually slow your program down. To some extent the compiler can calculate what the trade offs are, and may be able to make better decisions than you can, just looking at the source code.Our computer science professor urged us to never use inline in a c++ program. When asked why, he kindly explained to use that modern compilers should detect when to use inline automatically.So yes, the inline can be an optimization technique to be used wherever possible, but apparently this is something that is already done for you whenever it\'s possible to inline a function anyways.Conclusion from another discussion here:Are there any drawbacks with inline functions?Apparently, There is nothing wrong with using inline functions.But it is worth noting the following points!Overuse of inlining can actually make programs slower. Depending on a function\'s size, inlining it can cause the code size to increase or decrease. Inlining a very small accessor function will usually decrease code size while inlining a very large function can dramatically increase code size. On modern processors smaller code usually runs faster due to better use of the instruction cache. - Google GuidelinesThe speed benefits of inline functions tend to diminish as the function grows in size. At some point the overhead of the function call becomes small compared to the execution of the function body, and the benefit is lost - SourceThere are few situations where an inline function may not work:The __inline keyword causes a function to be inlined only if you specify the optimize option. If optimize is specified, whether or not __inline is honored depends on the setting of the inline optimizer option. By default, the inline option is in effect whenever the optimizer is run. If you specify optimize , you must also specify the noinline option if you want the __inline keyword to be ignored. -Source