What are the actual uses of the WeakMap data structure introduced in ECMAScript 6?Since a key of a weak map creates a strong reference to its corresponding value, ensuring that a value which has been inserted into a weak map will never disappear as long as its key is still alive, it can\'t be used for memo tables, caches or anything else that you would normally use weak references, maps with weak values, etc. for.It seems to me that this:...is just a roundabout way of saying this:What concrete use cases am I missing?WeakMaps provide a way to extend objects from the outside without interfering with garbage collection. Whenever you want to extend an object but can\'t because it is sealed - or from an external source - a WeakMap can be applied.A WeakMap is a map (dictionary) where the keys are weak - that is, if all references to the key are lost and there are no more references to the value - the value can be garbage collected. Let\'s show this first through examples, then explain it a bit and finally finish with a real use.Let\'s say I\'m using an API that gives me a certain object:Now, I have a method that uses the object:I want to keep track of how many times the method was called with a certain object and report if it happens more than N times. Naively one would think to use a Map:This works, but it has a memory leak - we now keep track of every single library object passed to the function which keeps the library objects from ever being garbage collected. Instead - we can use a WeakMap:And the memory leak is gone. Some use cases that would otherwise cause a memory leak and are enabled by WeakMaps include:It can be used to extend an object from the outside. Let\'s give a practical (adapted, sort of real - to make a point) example from the real world of io.js.Let\'s say you\'re NodeJS and you have Promise objects - now you want to keep track of all the currently rejected promises - however you do not want to keep them from being garbage collected in case no references exist to them. Now, you don\'t want to add properties to native objects for obvious reasons - so you\'re stuck. If you keep references to the promises you\'re causing a memory leak since no garbage collection can happen - if you don\'t keep references you can\'t save additional information about individual promises. Any scheme that involves saving the ID of a promise inherently means you need a reference to it.WeakMaps mean that the keys are weak. There are no ways to enumerate a weak map or to get all its values. In a weak map you can store the data based on a key and when the key gets garbage collected so do the values.This means that given a promise you can store state about it - and that object can still be garbage collected. Later on if you get a reference to an object you can check if you have any state relating to it and report it.This was used to implement unhandled rejection hooks by Petka Antonov as this:We keep information about promises in a map and can know when a rejected promise was handled.A use case could be to use it as a dictionary for listeners, I have a coworker who did that. It is very helpful because any listener is directly targetted with this way of doing things. Goodbye listener.on.But from a more abstract point of view, WeakMap is especially powerful to dematerialize access to basically anything, you don\'t need a namespace to isolate its members since it is already implied by the nature of this structure. I\'m pretty sure you could do some major memory improvements by replacing awkwards redundant object keys (even though deconstructing does the work for you).I do now realize my emphasize is not exactly the best way to tackle the problem and as Benjamin Gruenbaum pointed out (check out his answer, if it\'s not already above mine :p), this problem could not have been solved with a regular Map, since it would have leaked, thus the main strength of WeakMap is that it does not interfere with garbage collection given that they do not keep a reference.Here is the actual code of my coworker (thanks to him for sharing)Full source here, it\'s about listeners management I talked about above (you can also take a look at the specs)WeakMap work well for encapsulation and information hidingThe WeakMap only avaliable for ES 6 and above. A WeakMap is a collection of key and value pairs where the key must be an object. In the following example, we build a WeakMap with two items:We used the set() method to define an association between an object and another item (a string in our case). We used the get() method to retrieve the item associated with an object. The interesting aspect of the WeakMaps is the fact that it holds a weak reference to the key inside the map. A weak reference means that if the object is destroyed, the garbage collector will remove the entire entry from the WeakMap, thus freeing up memory.Weak Maps can be used to store metadata about DOM elements without interfering with garbage collection or making coworkers mad at your code. For example, you could use them to numerical index all elements in a webpage.The difference may look negligible, aside from the fact that the weakmap version is longer, however there is a major difference between the two pieces of code shown above. In the first snippet of code, without weak maps, the piece of code stores references every which way between the DOM elements. This prevents the DOM elements from being garbage collected. Math.pow(i, 2) % len] may seem like an oddball that nobody would use, but think again: plenty of production code has DOM references that bounce all over the document. Now, for the second piece of code, because all the references to the elements are weak, when you a remove a node, the browser is able to determine that the node is not used (not able to be reached by your code), and thus delete it from memory. The reason for why you should be concerned about memory usage, and memory anchors (things like the first snippet of code where unused elements are held in memory) is because more memory usage means more browser GC-attempts (to try to free up memory to avert a browser crash) means slower browsing experience and sometimes a browser crash.As for a polyfill for these, I would recommend my own library (found here @ github). It is a very lightweight library that will simply polyfill it without any of the way-overly-complex frameworks you might find in other polyfills.~ Happy coding!I use WeakMap for the cache of worry-free memoization of functions that take in immutable objects as their parameter.Memoization is fancy way of saying "after you compute the value, cache it so you don\'t have to compute it again".Here\'s an example:A few things to note:(Currently editing answer..)       