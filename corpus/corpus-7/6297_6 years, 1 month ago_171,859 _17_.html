The common example for C++11 range-based for() loops is always something simple like this:In which case xyz is an int.  But, what happens when we have something like a map?  What is the type of the variable in this example:When the container being traversed is something simple, it looks like range-based for() loops will give us each item, not an iterator.  Which is nice...if it was iterator, first thing we\'d always have to do is to dereference it anyway.But I\'m confused as to what to expect when it comes to things like maps and multimaps.(I\'m still on g++ 4.4, while range-based loops are in g++ 4.6+, so I haven\'t had the chance to try it yet.)Each element of the container is a map<K, V>::value_type, which is a typedef for std::pair<const K, V>.  Consequently, you\'d write this asFor efficiency, it is a good idea to make the parameter in the loop a reference.  You could also consider making it const if you want a read-only view of the values.In C++17 this is called structured bindings, which allows for the following:From this paper: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2049.pdffor( type-speci\xef\xac\x81er-seq simple-declarator : expression ) statementis syntactically equivalent toSo you can clearly see that what is abc in your case will be std::pair<key_type, value_type >. \nSo for printing you can do access each element by abc.first and abc.secondIf you only want to see the keys/values from your map and like using boost, you can use the boost adaptors with the range based loops:there is an equivalent boost::adaptors::key_valueshttp://www.boost.org/doc/libs/1_51_0/libs/range/doc/html/range/reference/adaptors/reference/map_values.htmlIf copy assignment operator of foo and bar is cheap (eg. int, char, pointer etc), you can do the following:EDIT: The below doesn\'t work as before :, it has to be a declaration, not an lvalue expression.