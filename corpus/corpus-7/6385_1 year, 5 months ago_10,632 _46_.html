In Java, using throw/catch as a part of logic when there\'s not actually an error is generally a bad idea (in part) because throwing and catching an exception is expensive, and doing it many times in a loop is usually far slower than other control structures which don\'t involve throwing exceptions.My question is, is the cost incurred in the throw/catch itself, or when creating the Exception object (since it gets a lot of runtime information including the execution stack)?In other words, if I dobut don\'t throw it, is that most of the cost of throwing, or is the throw + catch handling what\'s costly?I\'m not asking whether putting code in a try/catch block adds to the cost of executing that code, I\'m asking whether catching the Exception is the expensive part, or creating (calling the constructor for) the Exception is the expensive part.Another way of asking this is, if I made one instance of Exception and threw and caught it over and over, would that be significantly faster than creating a new Exception every time I throw?Creating an exception object is not more expensive than creating other regular objects. The main cost is hidden in native fillInStackTrace method which walks through the call stack and collects all required information to build a stack trace: classes, method names, line numbers etc.The myth about high exception costs comes from the fact that most of Throwable constructors implicitly call fillInStackTrace. However, there is one constructor to create a Throwable without a stack trace. It allows you to make throwables that are very fast to instantiate. Another way to create lightweight exceptions is to override fillInStackTrace.Now what about throwing an exception?\nIn fact, it depends on where a thrown exception is caught.If it is caught in the same method (or, more precisely, in the same context, since the context can include several methods due to inlining), then throw is as fast and simple as goto (of course, after JIT compilation).However if a catch block is somewhere deeper in the stack, then JVM needs to unwind the stack frames, and this can take significantly longer. It takes even longer, if there are synchronized blocks or methods involved, because unwinding implies releasing of monitors owned by removed stack frames.I could confirm the above statements by proper benchmarks, but fortunately I don\'t need to to this, since all the aspects are already perfectly covered in the post of HotSpot performance engineer Alexey Shipil\xc3\xabv: The Exceptional Performance of Lil\' Exception.The first operation in most Throwable constructors is to fill in the stack trace, which is where most of the expense is.There is, however, a protected constructor with a flag to disable the stack trace. This constructor is accessible when extending Exception as well. If you create a custom exception type, you can avoid the stack trace creation and get better performance at the expense of less information.If you create a single exception of any type by normal means, you can re-throw it many times without the overhead of filling in the stack trace. However, its stack trace will reflect where it was constructed, not where it was thrown in a particular instance.Current versions of Java make some attempts to optimize stack trace creation. Native code is invoked to fill in the stack trace, which records the trace in a lighter-weight, native structure. Corresponding Java StackTraceElement objects are lazily created from this record only when the getStackTrace(), printStackTrace(), or other methods that require the trace are called.If you eliminate stack trace generation, the other main cost is unwinding the stack between the throw and the catch. The fewer intervening frames encountered before the exception is caught, the faster this will be.Design your program so that exceptions are thrown only in truly exceptional cases, and optimizations like these are hard to justify.Theres a good write up on Exceptions here.http://shipilev.net/blog/2014/exceptional-performance/The conclusion being that stack trace construction and stack unwinding are the expensive parts. The code below takes advantage of a feature in 1.7 where we can turn stack traces on and off. We can then use this to see what sort of costs different scenarios haveThe following are timings for Object creation alone. I\'ve added String here so you can see that without the stack being written there\'s almost no difference in creating a JavaException Object and a String. With stack writing turned on the difference is dramatic ie at least one order of magnitude slower.The following shows how long it took to return from a throw at a particular depth a million times.The following is almost certainly a gross over simplification...If we take a depth of 16 with stack writing on then object creation is taking approximately ~40% of the time, the actual stack trace accounts for the vast majority of this. ~93% of instantiating the JavaException object is due to the stack trace being taken. This means that unwinding the stack in this case is taking the other 50% of the time.When we turn off the stack trace object creation accounts for a much smaller\nfraction ie 20% and stack unwinding now accounts for 80% of the time.In both cases stack unwinding takes a large portion of the overall time.The stack frames in this example are tiny compared to what you\'d normally find. You can peek at the bytecode using javap ie this is for method 4... The creation of the Exception with a null stack trace takes about as much time as the throw and try-catch block together. However, filling the stack trace takes on average 5x longer. I created the following benchmark to demonstrate the impact on performance. I added the -Djava.compiler=NONE to the Run Configuration to disable compiler optimization. To measure the impact of building the stack trace, I extended the Exception class to take advantage of the stack-free constructor:The benchmark code is as follows:Output:This implies that creating a NoStackException is approximately as expensive as repeatedly throwing the same Exception. It also shows that creating an Exception and filling its stack trace takes approximately 4x longer. This part of the question...Another way of asking this is, if I made one instance of Exception and\n  threw and caught it over and over, would that be significantly faster\n  than creating a new Exception every time I throw?Seems to be asking if creating an exception and caching it somewhere improves performance. Yes it does. It\'s the same as turning off the stack being written on object creation because it\'s already been done.These are timings I got, please read caveat after this...Of course the problem with this is your stack trace now points to where you instantiated the object not where it was thrown from.Using @AustinD\'s answer as a starting point, I made some tweaks. Code at the bottom.In addition to adding the case where one Exception instance is thrown repeatedly, I also turned off compiler optimization so that we can get accurate performance results. I added -Djava.compiler=NONE to the VM arguments, as per this answer.  (In eclipse, edit the Run Configuration â†’ Arguments to set this VM argument)The results:So creating the exception costs about 5x as much as throwing + catching it. Assuming the compiler doesn\'t optimize away much of the cost.For comparison, here\'s the same test run without disabling optimization:Code: