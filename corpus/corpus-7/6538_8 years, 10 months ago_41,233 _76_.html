Reading Paul Graham\'s essays on programming languages one would think that lisp macros are the only way to go. As a developer working on other platforms, I have not had the privilege of using Lisp macros. As someone who wants to understand the buzz, please explain what makes this feature so powerful.Please also relate this to something I would understand from the world of Python, Java, C# or C development.To give the short answer, macros are used for defining language syntax extensions to Common Lisp or Domain Specific Languages (DSLs).   These languages are embedded right into the existing Lisp code.   Now, the DSLs can have syntax similar to Lisp (like Peter Norvig\'s Prolog Interpreter for Common Lisp) or completely different (e.g. Infix Notation Math for Clojure).  Here is a more concrete example:Python has list comprehensions built into the language.  This gives a simple syntax for a common case. The lineyields a list containing all even numbers between 0 and 9.  Back in the Python 1.5 days there was no such syntax; you\'d use something more like this:These are both functionally equivalent.  Let\'s invoke our suspension of disbelief and pretend Lisp has a very limited loop macro that just does iteration and no easy way to do the equivalent of list comprehensions.  In Lisp you could write the following.   I should note this contrived example is picked to be identical to the Python code not a good example of Lisp code.Before I go further, I should better explain what a macro is.   It is a transformation perfomed on code by code.   That is, a piece of code, read by the interpreter (or compiler), which takes in code as an argument, manipulates and the returns the result, which is then run in place.  Of course that\'s a lot of typing and programmers are lazy.   So we could define DSL for doing list comprehensions.  In fact, we\'re using one macro already (the loop macro).   Lisp defines a couple of special syntax forms.  The quote (\') indicates the next token is a literal.  The quasiquote or backtick (`) indicates the next token is a literal with escapes.   Escapes are indicated by the comma operator.  The literal \'(1 2 3) is the equivalent of Python\'s [1, 2, 3].  You can assign it to another variable or use it in place.   You can think of `(1 2 ,x) as the equivalent of Python\'s [1, 2, x] where x is a variable previously defined.  This list notation is part of the magic that goes into macros.  The second part is the Lisp reader which intelligently substitutes macros for code but that is best illustrated below:So we can define a macro called lcomp (short for list comprehension).   It\'s syntax will be exactly like the python that we used in the example [x for x in range(10) if x % 2 == 0]   - (lcomp x for x in (range 10) if (= (% x 2) 0))Now we can execute at the command line:Pretty neat, huh?  Now it doesn\'t stop there.  You have a mechanism, or a paintbrush, if you like.   You can have any syntax you could possibly want.  Like Python or C#\'s with syntax.   Or .NET\'s LINQ syntax.   In end, this is what attracts people to Lisp - ultimate flexibility.  You will find a comprehensive debate around lisp macro here.An interesting subset of that article:In most programming languages, syntax is complex.  Macros have to take apart program syntax, analyze it, and reassemble it.  They do not have access to the program\'s parser, so they have to depend on heuristics and best-guesses.  Sometimes their cut-rate analysis is wrong, and then they break.But Lisp is different.  Lisp macros do have access to the parser, and it is a really simple parser.  A Lisp macro is not handed a string, but a preparsed piece of source code in the form of a list, because the source of a Lisp program is not a string; it is a list. And Lisp programs are really good at taking apart lists and putting them back together.  They do this reliably, every day.Here is an extended example.  Lisp has a macro, called "setf", that performs assignment.  The simplest form of setf iswhich sets the value of the symbol "x" to the value of the expression "whatever".Lisp also has lists; you can use the "car" and "cdr" functions to get the first element of a list or the rest of the list, respectively.Now what if you want to replace the first element of a list with a new value?  There is a standard function for doing that, and incredibly, its name is even worse than "car".  It is "rplaca".  But you do not have to remember "rplaca", because you can writeto set the car of somelist.What is really happening here is that "setf" is a macro.  At compile time, it examines its arguments, and it sees that the first one has the form (car SOMETHING).  It says to itself "Oh, the programmer is trying to set the car of somthing.  The function to use for that is \'rplaca\'."  And it quietly rewrites the code in place to:Common Lisp macros essentially extend the "syntactic primitives" of your code.For example, in C, the switch/case construct only works with integral types and if you want to use it for floats or strings, you are left with nested if statements and explicit comparisons. There\'s also no way you can write a C macro to do the job for you.But, since a lisp macro is (essentially) a lisp program that takes snippets of code as input and returns code to replace the "invocation" of the macro, you can extend your "primitives" repertoire as far as you want, usually ending up with a more readable program.To do the same in C, you would have to write a custom pre-processor that eats your initial (not-quite-C) source and spits out something that a C compiler can understand. It\'s not a wrong way to go about it, but it\'s not necessarily the easiest.Lisp macros allow you to decide when (if at all) any part or expression will be evaluated. To put a simple example, think of C\'s:What this says is: Evaluate expr1, and, should it be true, evaluate expr2, etc.Now try to make this && into a function... thats right, you can\'t. Calling something like:Will evaluate all three exprs before yielding an answer regardless of whether expr1 was false!With lisp macros you can code something like:now you have an &&, which you can call just like a function and it won\'t evaluate any forms you pass to it unless they are all true.To see how this is useful, contrast:and:Other things you can do with macros are creating new keywords and/or mini-languages (check out the (loop ...) macro for an example), integrating other languages into lisp, for example, you could write a macro that lets you say something like:And thats not even getting into Reader macros.Hope this helps.I don\'t think I\'ve ever seen Lisp macros explained better than by this fellow: http://www.defmacro.org/ramblings/lisp.htmlA lisp macro takes a program fragment as input. This program fragment is represented a data structure which can be manipulated and transformed any way you like. In the end the macro outputs another program fragment, and this fragment is what is executed at runtime.C# does not have a macro facility, however an equivalent would be if the compiler parsed the code into a CodeDOM-tree, and passed that to a method, which transformed this into another CodeDOM, which is then compiled into IL.This could be used to implement "sugar" syntax like the for each-statement using-clause, linq select-expressions and so on, as macros that transforms into the underlying code.If Java had macros, you could implement Linq syntax in Java, without needing Sun to change the base language.Here is pseudo-code for how a lisp-style macro in C# for implementing using could look:Think of what you can do in C or C++ with macros and templates. They\'re very useful tools for managing repetitive code, but they\'re limited in quite severe ways.Lisp and Lisp macros solve these problems.Talk to anyone that\'s mastered C++ and ask them how long they spent learning all the template fudgery they need to do template metaprogramming. Or all the crazy tricks in (excellent) books like Modern C++ Design, which are still tough to debug and (in practice) non-portable between real-world compilers even though the language has been standardised for a decade. All of that melts away if the langauge you use for metaprogramming is the same language you use for programming!I\'m not sure I can add some insight to everyone\'s (excellent) posts, but...Lisp macros work great because of the Lisp syntax nature.Lisp is an extremely regular language (think of everything is a list); macros enables you to treat data and code as the same (no string parsing or other hacks are needed to modify lisp expressions). You combine these two features and you have a very clean way to modify code. Edit: What I was trying to say is that Lisp is homoiconic, which means that the data structure for a lisp program is written in lisp itself.So, you end up with a way of creating your own code generator on top of the language using the language itself with all its power (eg. in Java you have to hack your way with bytecode weaving, although some frameworks like AspectJ allows you to do this using a different approach, it\'s fundamentally a hack).In practice, with macros you end up building your own mini-language on top of lisp, without the need to learn additional languages or tooling, and with using the full power of the language itself.Lisp macros represents a pattern that occurs in almost any sizeable programming project. Eventually in a large program you have a certain section of code where you realize it would be simpler and less error prone for you to write a program that outputs source code as text which you can then just paste in.In Python objects have two methods __repr__ and __str__.  __str__ is simply the human readable representation.  __repr__ returns a representation that is valid Python code, which is to say, something that can be entered into the interpreter as valid Python.  This way you can create little snippets of Python that generate valid code that can be pasted into your actually source.In Lisp this whole process has been formalized by the macro system.  Sure it enables you to create extensions to the syntax and do all sorts of fancy things, but it\'s actual usefulness is summed up by the above.  Of course it helps that the Lisp macro system allows you to manipulate these "snippets" with the full power of the entire language.Since the existing answers give good concrete examples explaining what macros achieve and how, perhaps it\'d help to collect together some of the thoughts on why the macro facility is a significant gain in relation to other languages; first from these answers, then a great one from elsewhere:... in C, you would have to write a custom pre-processor [which would probably qualify as a  sufficiently complicated C program] ...—VatineTalk to anyone that\'s mastered C++ and ask them how long they spent learning all the template fudgery they need to do template metaprogramming [which is still not as powerful].—Matt Curtis... in Java you have to hack your way with bytecode weaving, although some frameworks like AspectJ allows you to do this using a different approach, it\'s fundamentally a hack.—Miguel PingDOLIST is similar to Perl\'s foreach or Python\'s for. Java added a similar kind of loop construct with the "enhanced" for loop in Java 1.5, as part of JSR-201. Notice what a difference macros make. A Lisp programmer who notices a common pattern in their code can write a macro to give themselves a source-level abstraction of that pattern. A Java programmer who notices the same pattern has to convince Sun that this particular abstraction is worth adding to the language. Then Sun has to publish a JSR and convene an industry-wide "expert group" to hash everything out. That process--according to Sun--takes an average of 18 months. After that, the compiler writers all have to go upgrade their compilers to support the new feature. And even once the Java programmer\'s favorite compiler supports the new version of Java, they probably \'\'still\'\' can\'t use the new feature until they\'re allowed to break source compatibility with older versions of Java. So an annoyance that Common Lisp programmers can resolve for themselves within five minutes plagues Java programmers for years.—Peter Seibel, in "Practical Common Lisp"In short, macros are transformations of code. They allow to introduce many new syntax constructs. E.g., consider LINQ in C#. In lisp, there are similar language extensions that are implemented by macros (e.g., built-in loop construct, iterate). Macros  significantly decrease code duplication. Macros allow embedding \xc2\xablittle languages\xc2\xbb (e.g., where in c#/java one would use xml to configure, in lisp the same thing can be achieved with macros). Macros may hide difficulties of using libraries usage.E.g., in lisp you can writeand this hides all the database stuff (transactions, proper connection closing, fetching data, etc.) whereas in C# this requires creating SqlConnections, SqlCommands, adding SqlParameters to SqlCommands, looping on SqlDataReaders, properly closing them.While the above all explains what macros are and even have cool examples, I think the key difference between a macro and a normal function is that LISP evaluates all the parameters first before calling the function. With a macro it\'s the reverse, LISP passes the parameters unevaluated to the macro. For example, if you pass (+ 1 2) to a function, the function will receive the value 3. If you pass this to a macro, it will receive a List(  + 1 2). This can be used to do all kinds of incredibly useful stuff.Measure the time it takes to execute a function passed in. With a function the parameter would be evaluated before control is passed to the function. With the macro, you can splice your code between the start and stop of your stopwatch. The below has the exact same code in a macro and a function and the output is very different. Note: This is a contrived example and the implementation was chosen so that it is identical to better highlight the difference.I got this from The common lisp cookbook but I think it explained why lisp macros are good in a nice way."A macro is an ordinary piece of Lisp code that operates on another piece of putative Lisp code, translating it into (a version closer to) executable Lisp. That may sound a bit complicated, so let\'s give a simple example. Suppose you want a version of setq that sets two variables to the same value. So if you writewhen z=8 both x and y are set to 11. (I can\'t think of any use for this, but it\'s just an example.)It should be obvious that we can\'t define setq2 as a function. If x=50 and y=-5, this function would receive the values 50, -5, and 11; it would have no knowledge of what variables were supposed to be set. What we really want to say is, When you (the Lisp system) see (setq2 v1 v2 e), treat it as equivalent to (progn (setq v1 e) (setq v2 e)). Actually, this isn\'t quite right, but it will do for now. A macro allows us to do precisely this, by specifying a program for transforming the input pattern (setq2 v1 v2 e)" into the output pattern (progn ...)."If you thought this was nice you can keep on reading here:\nhttp://cl-cookbook.sourceforge.net/macros.htmlIn python you have decorators, you basically have a function that takes another function as input. You can do what ever you want: call the function, do something else, wrap the function call in a resource acquire release, etc.  but you don\'t get to peek inside that function.  Say we wanted to make it more powerful, say your decorator received the code of the function as a list then you could not only execute the function as is but you can now execute parts of it, reorder lines of the function etc.