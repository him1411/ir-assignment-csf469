In my application I use 3rd party library (Spring Data for MongoDb to be exact).Methods of this library return Iterable<T>, while the rest of my code expects Collection<T>.Is there any utility method somewhere that will let me quickly convert one to the other. I would like to avoid making a banch of foreach loops in my code for such a simple thing.With Guava you can use Lists.newArrayList(Iterable) or Sets.newHashSet(Iterable), among other similar methods. This will of course copy all the elements in to memory. If that isn\'t acceptable, I think your code that works with these ought to take Iterable rather than Collection. Guava also happens to provide convenient methods for doing things you can do on a Collection using an Iterable (such as Iterables.isEmpty(Iterable) or Iterables.contains(Iterable, Object)), but the performance implications are more obvious.In JDK 8, without depending on additional libs:Edit: The above one is for Iterator. If you are dealing with Iterable, You may write your own utility method for this as well:Concise solution with Java 8 using java.util.stream:IteratorUtils from commons-collections may help (although they don\'t support generics in the latest stable version 3.2.1):Version 4.0 (which is in SNAPSHOT at this moment) supports generics and you can get rid of the @SuppressWarnings.Update: Check IterableAsList from Cactoos.From CollectionUtils:Here are the full sources of this utility method:While at it, do not forget that all collections are finite, while Iterable has no promises whatsoever. If something is Iterable you can get an Iterator and that is it.will be expanded to:it.hasNext() is not required to ever return false. Thus in the general case you cannot expect to be able to convert every Iterable to a Collection. For example you can iterate over all positive natural numbers, iterate over something with cycles in it that produces the same results over and over again, etc.Otherwise: Atrey\'s answer is quite fine.I use FluentIterable.from(myIterable).toList() a lot.This is not an answer to your question but I believe it is the solution to your problem. The interface org.springframework.data.repository.CrudRepository does indeed have methods that return java.lang.Iterable but you should not use this interface. Instead use sub interfaces, in your case org.springframework.data.mongodb.repository.MongoRepository. This interface has methods that return objects of type java.util.List.I use my custom utility to cast an existing Collection if available.Main:Ideally the above would use ImmutableList, but ImmutableCollection does not allow nulls which may provide undesirable results.Tests:I implement similar utilities for all subtypes of Collections (Set,List,etc). I\'d think these would already be part of Guava, but I haven\'t found it.As soon as you call contains, containsAll, equals, hashCode, remove, retainAll, size or toArray, you\'d have to traverse the elements anyway.If you\'re occasionally only calling methods such as isEmpty or clear I suppose you\'d be better of by creating the collection lazily. You could for instance have a backing ArrayList for storing previously iterated elements.I don\'t know of any such class in any library, but it should be a fairly simple exercise to write up.In Java 8 you can do this to add all elements from an Iterable to Collection and return it:Inspired by @Afreys answer.Since RxJava is a hammer and this kinda looks like a nail, you can doHere\'s an SSCCE for a great way to do this in Java 8Two remarksTry StickyList from Cactoos: