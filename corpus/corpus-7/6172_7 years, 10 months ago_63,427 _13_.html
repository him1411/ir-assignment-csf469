OK, so the @Ignore annotation is good for marking that a test case shouldn\'t be run.However, sometimes I want to ignore a test based on runtime information.  An example might be if I have a concurrency test that needs to be run on a machine with a certain number of cores.  If this test were run on a uniprocessor machine, I don\'t think it would be correct to just pass the test (since it hasn\'t been run), and it certainly wouldn\'t be right to fail the test and break the build.So I want to be able to ignore tests at runtime, as this seems like the right outcome (since the test framework will allow the build to pass but record that the tests weren\'t run).  I\'m fairly sure that the annotation won\'t give me this flexibility, and suspect that I\'ll need to manually create the test suite for the class in question.  However, the documentation doesn\'t mention anything about this and looking through the API it\'s also not clear how this would be done programmatically (i.e. how do I programatically create an instance of Test or similar that is equivalent to that created by the @Ignore annotation?).If anyone has done something similar in the past, or has a bright idea of how else I could go about this, I\'d be happy to hear about it.The JUnit way is to do this at run-time is org.junit.Assume.You can do it in a @Before method or in the test itself, but not in an @After method. If you do it in the test itself, your @Before method will get run.An assumption failure causes the test to be ignored.Edit: To compare with the @RunIf annotation from junit-ext, their sample code would look like this:Not to mention that it is much easier to capture and use the connection from the Database.connect() method this way.You should checkout Junit-ext project.  They have RunIf annotation that performs conditional tests, like:[Code sample taken from their tutorial]In JUnit 4, another option for you may be to create an annotation to denote that the test needs to meet your custom criteria, then extend the default runner with your own and using reflection, base your decision on the custom criteria. It may look something like this:A quick note: Assume.assumeTrue(condition) ignores rest of the steps but passes the test. \nTo fail the test, use org.junit.Assert.fail() inside the conditional statement. Works same like Assume.assumeTrue() but fails the test.