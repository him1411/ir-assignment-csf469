On Linux, the readlink utility accepts an option -f that follows additional links. This doesn\'t seem to work on Mac and possibly BSD based systems. What would the equivalent be?Here\'s some debug information:readlink -f does two things:If you want to, you can just build a shell script that uses vanilla readlink behavior to achieve the same thing.  Here\'s an example.  Obviously you could insert this in your own script where you\'d like to call readlink -f Note that this doesn\'t include any error handling.  Of particular importance, it doesn\'t detect symlink cycles.  A simple way to do this would be to count the number of times you go around the loop and fail if you hit an improbably large number, such as 1,000.EDITED to use pwd -P instead of $PWD.Note that this script expects to be called like ./script_name filename, no -f, change $1 to $2 if you want to be able to use with -f filename like GNU readlink.macports and homebrew provide a coreutils package containing greadlink (GNU readlink). credit to Michael Kallweitt post in mackb.comYou may be interested in realpath(3), or Python\'s os.path.realpath.  The two aren\'t exactly the same; the C library call requires that intermediary path components exist, while the Python version does not.I know you said you\'d prefer something more lightweight than another scripting language, but just in case compiling a binary is insufferable, you can use Python and ctypes (available on Mac OS X 10.5) to wrap the library call:Ironically, the C version of this script ought to be shorter. :)I hate to pile on with yet another implementation, but I needed a) a portable, pure shell implementation, and b) unit-test coverage, as the number of edge-cases for something like this are non-trivial.See my project on Github for tests and full code. What follows is a synopsis of the implementation:As Keith Smith astutely points out, readlink -f does two things: 1) resolves symlinks recursively, and 2) canonicalizes the result, hence:First, the symlink resolver implementation:Note that this is a slightly simplified version of the full implementation. The full implementation adds a small check for symlink cycles, as well as massages the output a bit.Finally, the function for canonicalizing a path:That\'s it, more or less. Simple enough to paste into your script, but tricky enough that you\'d be crazy to rely on any code that doesn\'t have unit tests for your use cases.greadlink is the gnu readlink that implements -f. You can use macports or others as well, I prefer homebrew.A simple one-liner in perl that\'s sure to work almost everywhere without any external dependencies:Will dereference symlinks.Usage in a script could be like this:I made a script called realpath personally which looks a little something like:What about this?FreeBSD and OSX have a version of statderived from NetBSD.  You can adjust the output with format switches (see the manual pages at the links above).Some OS X versions of stat  may lack the -f%R option for formats. In this case -stat -f%Y may suffice. The -f%Y option will show the target of a symlink, whereas -f%R shows the absolute pathname corresponding to the file.EDIT:If you\'re able to use Perl (Darwin/OS X comes installed with recent verions of perl) then:will work.Here is a portable shell function that should work in ANY Bourne comparable shell.\nIt will resolve the relative path punctuation ".. or ." and dereference symbolic links.If for some reason you do not have a realpath(1) command, or readlink(1) this can be aliased.Enjoy:also, just in case anybody is interested here is how to implement basename and dirname in 100% pure shell code:You can find updated version of this shell code at my google site: http://sites.google.com/site/jdisnard/realpathEDIT:\nThis code is licensed under the terms of the 2-clause (freeBSD style) license.\nA copy of the license may be found by following the above hyperlink to my site.The easiest way to solve this problem and enable the functionality of readlink on Mac w/ Homebrew installed or FreeBSD is to install \'coreutils\' package.  May also be necessary on certain Linux distributions and other POSIX OS.  For example, in FreeBSD 11, I installed by invoking:# pkg install coreutilsOn MacOS with Homebrew, the command would be:$ brew install coreutilsNot really sure why the other answers are so complicated, that\'s all there is to it. The files aren\'t in a different place, they\'re just not installed yet.Begin UpdateThis is such a frequent problem that we have put together a Bash 4 library for free use (MIT License) called realpath-lib.  This is designed to emulate readlink -f by default and includes two test suites to verify (1) that it works for a given unix system and (2) against readlink -f if installed (but this is not required).  Additionally, it can be used to investigate, identify and unwind deep, broken symlinks and circular references, so it can be a useful tool for diagnosing deeply-nested physical or symbolic directory and file problems.  It can be found at github.com or bitbucket.org.  End UpdateAnother very compact and efficient solution that does not rely on anything but Bash is:This also includes an environment setting no_symlinks that provides the ability to resolve symlinks to the physical system.  As long as no_symlinks is set to something, ie no_symlinks=\'on\' then symlinks will be resolved to the physical system.  Otherwise they will be applied (the default setting).This should work on any system that provides Bash, and will return a Bash compatible exit code for testing purposes.There are already a lot of answers, but none worked for me... So this is what I\'m using now.Better late than never, I suppose.  I was motivated to develop this specifically because my Fedora scripts weren\'t working on the Mac.  The problem is dependencies and Bash.  Macs don\'t have them, or if they do, they are often somewhere else (another path).  Dependency path manipulation in a cross-platform Bash script is a headache at best and a security risk at worst - so it\'s best to avoid their use, if possible.The function get_realpath() below is simple, Bash-centric, and no dependencies are required.  I uses only the Bash builtins echo and cd.  It is also fairly secure, as everything gets tested at each stage of the way and it returns error conditions.If you don\'t want to follow symlinks, then put set -P at the front of the script, but otherwise cd should resolve the symlinks by default.  It\'s been tested with file arguments that are {absolute | relative | symlink | local} and it returns the absolute path to the file.  So far we\'ve not had any problems with it.You can combine this with other functions get_dirname, get_filename, get_stemname and validate_path.  These can be found at our GitHub repository as realpath-lib (full disclosure - this is our product but we offer it free to the community without any restrictions).  It also could serve as a instructional tool - it\'s well documented.We\'ve tried our best to apply so-called \'modern Bash\' practices, but Bash is a big subject and I\'m certain there will always be room for improvement.  It requires Bash 4+ but could be made to work with older versions if they are still around.Truely platform-indpendent would be also this R-onlinerTo actually mimic readlink -f <path>, $2 instead of $1 would need to be used.I wrote a realpath utility for OS X which can provide the same results as readlink -f.Here is an example: If you are using MacPorts, you can install it with the following command: sudo port selfupdate && sudo port install realpath.This is what I use:stat -f %N $your_pathThe paths to readlink are different between my system and yours.  Please try specifying the full path:/sw/sbin/readlink -fPerl has a readlink function (e.g. How do I copy symbolic links in Perl?). This works across most platforms, including OS X:For example:The answer from @Keith Smith gives an infinite loop.Here is my answer, which i use only on SunOS (SunOS miss so much POSIX and GNU commands).It\'s a script file you have to put in one of your $PATH directories: