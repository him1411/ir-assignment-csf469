I\'m trying to compile my program and it returns this error :in my makefile I use the command g++ and link to my library which is a symbolic link to my library located on an other directory.Is there an option to add to make it work please?If your library name is say libxyz.so and it is located on path say:then to link it to your program:To figure out what the linker is looking for, run it in verbose mode.  For example, I encountered this issue while trying to compile MySQL with ZLIB support.  I was receiving an error like this during compilation:I did some Googl\'ing and kept coming across different issues of the same kind where people would say to make sure the .so file actually exists and if it doesn\'t, then create a symlink to the versioned file, for example, zlib.so.1.2.8.  But, when I checked, zlib.so DID exist.  So, I thought, surely that couldn\'t be the problem.  I came across another post on the Internets that suggested to run make with LD_DEBUG=all:Although I got a TON of debugging output, it wasn\'t actually helpful.  It added more confusion than anything else.  So, I was about to give up.Then, I had an epiphany.  I thought to actually check the help text for the ld command:From that, I figured out how to run ld in verbose mode (imagine that):This is the output I got:Ding, ding, ding...So, to finally fix it so I could compile MySQL with my own version of ZLIB (rather than the bundled version):Voila!During compilation with g++ via make define LIBRARY_PATH if it may not be appropriate to change the Makefile with the -Loption. I had put my extra library in /opt/lib so I did: and then ran make for successful compilation and linking.To run the program with a shared library define:before executing the program.When G++ says cannot find -l<nameOfTheLibrary>, it means that G++ looked for the file lib{nameOfTheLibrary}.so, but it couldn\'t find it in the shared library search path, which by default points to /usr/lib and /usr/local/lib and somewhere else maybe.To resolve this problem, you should either provide the library file (lib{nameOfTheLibrary}.so) in those search paths or use -L command option. -L{path} tells the G++ (actually ld) to find library files in  path {path} in addition to default paths.Example: Assuming you have a library at /home/taylor/libswift.so, and you want to link your app to this library. In this case you should supply the G++with the following options:Note 1: -l option gets the library name without lib and .so at its beginning and end.Note 2: In some cases, the library file name is followed by its version, for instance libswift.so.1.2. In these cases, G++ also cannot find the library file. A simple workaround to fix this is creating a symbolic link to libswift.so.1.2 called libswift.so.When you link your app to a shared library, it\'s required that library stays available whenever you run the app. In runtime your app (actually dynamic linker) looks for its libraries in LD_LIBRARY_PATH. It\'s an environment variable which stores a list of paths.Example: In case of our libswift.so example, dynamic linker cannot find libswift.so in LD_LIBRARY_PATH (which points to default search paths). To fix the problem you should append that variable with the path libswift.so is in.There does not seem to be any answer which addresses the very common beginner problem of failing to install the required library in the first place.On Debianish platforms, if libfoo is missing, you can frequently install it with something likeThe -dev version of the package is required for development work, even trivial development work such as compiling source code to link to the library.The package name will sometimes require some decorations (libfoo0-dev?  foo-dev without the lib prefix? etc), or you can simply use your distro\'s package search to find out precisely which packages provide a particular file.(If there is more than one, you will need to find out what their differences are. Picking the coolest or the most popular is a common shortcut, but not an acceptable procedure for any serious development work.)For other architectures (most notably RPM) similar procedures apply, though the details will be different.When you compile your program you must supply the path to the library; in g++ use the -L option:This error may also be brought about if the symbolic link is to a dynamic library, .so, but for legacy reasons -static appears among the link flags.  If so, try removing it.The library I was trying to link to turned out to have a non-standard name (i.e. wasn\'t prefixed with \'lib\'), so they recommended using a command like this to compile it - gcc test.c -Iinclude lib/cspice.a -lm