Any way to cast java.lang.Double to java.lang.Integer? It throws an exception "java.lang.ClassCastException: java.lang.Double incompatible with java.lang.Integer"A Double is not an Integer, so the cast won\'t work.  Note the difference between the Double class and the double primitive.  Also note that a Double is a Number, so it has the method intValue, when you can use to get an primitive int.You need to explicitly get the int value using method intValue() like this:Or I see three possibilities. The first two cut off the digits, the last one rounds to the nearest Integer.I think it\'s impossible to understand the other answers without covering the pitfalls and reasoning behind it.You cannot directly cast an Integer directly to a Double object. Also Double and Integer are immutable objects so you cannot modify them in any way. However each numeric class has a primitive alternative (Double vs double, Integer vs int, ...). So the strategy should be:In Java:Actually there is a shortcut. You can unbox immediately from a Double straight to a primitive int. That way, you can skip step 2 entirely.However, there are a lot of things that are not covered in the code above.\nThe code-above is not null-safe.Now it works fine for most values. However Integers have a very small range (min/max value) compared to a Double. On top of that, Doubles can also hold "special values", that Integers cannot:So, depending on the application, you may want to add some filtering to avoid nasty Exceptions.Then, the next shortcoming is the rounding strategy. By default Java will always round down. Rounding down makes perfect sense in all programming languages. Basically Java is just throwing away some of the bytes. In financial applications you will surely want to use economical rounding (e.g.:  round(0.5) = 1 and round(0.4) = 0).You could be tempted to use auto-(un)boxing in this, but I wouldn\'t. If you\'re already stuck now, then the next things will not be that obvious neither. If you don\'t understand the inner workings of auto-(un)boxing then please don\'t use it.I guess the following shouldn\'t be a surprise. But if it is, then you may want to read some article about casting in Java.Also, don\'t be tempted to use new Integer() constructor (as some other answers propose). The valueOf() methods are better because they use caching. It\'s a good habit to use these methods, because from time to time they will save you some memory.Like this:  Indeed, the simplest way is to use intValue(). However, this merely returns the integer part; it does not do any rounding. If you want the Integer nearest to the Double value, you\'ll need to do this:And don\'t forget the null case:Math.round() handles odd duck cases, like infinity and NaN, with relative grace.One should also add that it works with autoboxing.Otherwise, you get an int (primitive) and then can get an Integer from there:Call intValue() on your Double object.Simply do it this way...Double and Integer are wrapper classes for Java primitives for double and int respectively. You can cast between those, but you will lose the floating point. That is, 5.4 casted to an int will be 5. If you cast it back, it will be 5.0.You can do that by using "Narrowing or Explicit type conversion",\ndouble \xe2\x86\x92 long \xe2\x86\x92 int. I hope it will work.PS: It will give 0 as double has all the decimal values and nothing on the left side. In case of 0.58, it will narrow it down to 0. But for others it will do the magic.Simply use the intValue method of DoubleUse the doubleNumber.intValue(); method.Try this onedouble doubleValue = 6.5;Double doubleObj = new Double(doubleValue);int intResult = doubleObj.intValue();