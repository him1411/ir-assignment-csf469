I have an application which I\'ve developed for a friend. It sends a POST request to the VB forum software and logs someone in (with out setting cookies or anything).Once the user is logged in I create a variable that creates a path on their local machine.c:\\tempfolder\\date\\usernameThe problem is that some usernames are throwing "Illegal chars" exception. For example if my username was mas|fenix it would throw an exception..I don\'t want to remove it from the string, but a folder with their username is created through FTP on a server. And this leads to my second question. If I am creating a folder on the server can I leave the "illegal chars" in? I only ask this because the server is Linux based, and I am not sure if Linux accepts it or not..EDIT: It seems that URL encode is NOT what I want.. Here\'s what I want to do:Where %xx is the ASCII value or any other value that would easily identify the character.Edit: Note that this answer is now out of date. See Siarhei Kuchuk\'s answer below for a better fixUrlEncoding will do what you are suggesting here. With C#, you simply use HttpUtility, as mentioned. You can also Regex the illegal characters and then replace, but this gets far more complex, as you will have to have some form of state machine (switch ... case, for example) to replace with the correct characters. Since UrlEncode does this up front, it is rather easy.As for Linux versus windows, there are some characters that are acceptable in Linux that are not in Windows, but I would not worry about that, as the folder name can be returned by decoding the Url string, using UrlDecode, so you can round trip the changes.I\'ve been experimenting with the various methods .NET provide for URL encoding.  Perhaps the following table will be useful (as output from a test app I wrote):The columns represent encodings as follows:UrlEncoded: HttpUtility.UrlEncodeUrlEncodedUnicode: HttpUtility.UrlEncodeUnicodeUrlPathEncoded: HttpUtility.UrlPathEncodeEscapedDataString: Uri.EscapeDataStringEscapedUriString: Uri.EscapeUriStringHtmlEncoded: HttpUtility.HtmlEncodeHtmlAttributeEncoded: HttpUtility.HtmlAttributeEncodeHexEscaped: Uri.HexEscapeNOTES: HexEscape can only handle the first 255 characters.  Therefore it throws an ArgumentOutOfRange exception for the Latin A-Extended characters (eg \xc4\x80).This table was generated in .NET 4.0 (see Levi Botelho\'s comment below that says the encoding in .NET 4.5 is slightly different).EDIT:I\'ve added a second table with the encodings for .NET 4.5.  See this answer: https://stackoverflow.com/a/21771206/216440EDIT 2:Since people seem to appreciate these tables, I thought you might like the source code that generates the table, so you can play around yourselves.  It\'s a simple C# console application, which can target either .NET 4.0 or 4.5:You should encode only the user name or other part of the URL that could be invalid. URL encoding a URL can lead to problems since something like this:Will yield  http%3a%2f%2fwww.google.com%2fsearch%3fq%3dExampleThis is obviously not going to work well. Instead, you should encode ONLY the value of the key/value pair in the query string, like this:Hopefully that helps. Also, as teedyay mentioned, you\'ll still need to make sure illegal file-name characters are removed or else the file system won\'t like the path.Better way is to useto not reference Full Profile of .net 4.Since .NET Framework 4.5 you can use WebUtility.UrlEncode.First, it resides in System.dll, so it does not require any additional references.Second, it properly escapes characters for URLs, unlike Uri.EscapeUriString (see comments to drweb86\'s answer).Third, it does not have any limits on the length of the string, unlike Uri.EscapeDataString (see related question), so it can be used for POST requests, for example.Fourth, it is available on WinRT, unlike HttpUtility (see related question).Url Encoding is easy in .NET. Use:If that\'ll be decoded to get the folder name, you\'ll still need to exclude characters that can\'t be used in folder names (*, ?, /, etc.)Levi Botelho commented that the table of encodings that was previously generated is no longer accurate for .NET 4.5, since the encodings changed slightly between .NET 4.0 and 4.5.  So I\'ve regenerated the table for .NET 4.5:The columns represent encodings as follows:NOTES: HexEscape can only handle the first 255 characters.  Therefore it throws an ArgumentOutOfRange exception for the Latin A-Extended characters (eg \xc4\x80).This table was generated in .NET 4.5 (see answer https://stackoverflow.com/a/11236038/216440 for the encodings relevant to .NET 4.0 and below).EDIT: If you can\'t see System.Web, change your project settings. The target framework should be ".NET Framework 4" instead of ".NET Framework 4 Client Profile"The .NET implementation of UrlEncode does not comply with RFC 3986. Some characters are not encoded but should be. The !()* characters are listed in the RFC\'s section 2.2 as a reserved characters that must be encoded yet .NET fails to encode these characters.Some characters are encoded but should not be. The .-_ characters are not listed in the RFC\'s section 2.2 as a reserved character that should not be encoded yet .NET erroneously encodes these characters.The RFC specifies that to be consistent, implementations should use upper-case HEXDIG, where .NET produces lower-case HEXDIG.Ideally these would go in a class called "FileNaming" or maybe just rename Encode to "FileNameEncode". Note: these are not designed to handle Full Paths, just the folder and/or file names.  Ideally you would Split("/") your full path first and then check the pieces.\nAnd obviously instead of a union, you could just add the "%" character to the list of chars not allowed in Windows, but I think it\'s more helpful/readable/factual this way.\nDecode() is exactly the same but switches the Replace(Uri.HexEscape(s[0]), s) "escaped" with the character.Thanks @simon-tewsi for the very usefull table above!In addition to @Dan Herbert\'s answer , \nYou we should encode just the values generally.Split has params parameter Split(\'&\',\'=\'); expression firstly split by & then \'=\' so odd elements are all values to be encoded shown below.