With the help of the Stack Overflow community I\'ve written a pretty basic-but fun physics simulator.You click and drag the mouse to launch a ball.  It will bounce around and eventually stop on the "floor".My next big feature I want to add in is ball to ball collision.  The ball\'s movement is broken up into a x and y speed vector.  I have gravity (small reduction of the y vector each step), I have friction (small reduction of both vectors each collision with a wall). The balls honestly move around in a surprisingly realistic way.I guess my question has two parts:Handling the collision detection of the "walls" and the resulting vector changes were easy but I see more complications with ball-ball collisions.  With walls I simply had to take the negative of the appropriate x or y vector and off it would go in the correct direction.  With balls I don\'t think it is that way.Some quick clarifications: for simplicity I\'m ok with a perfectly elastic collision for now, also all my balls have the same mass right now, but I might change that in the future.Edit: Resources I have found useful2d Ball physics with vectors: 2-Dimensional Collisions Without Trigonometry.pdf\n2d Ball collision detection example: Adding Collision DetectionI have the ball collision detection and response working great!Relevant code:Collision Detection:This will check for collisions between every ball but skip redundant checks (if you have to check if ball 1 collides with ball 2 then you don\'t need to check if ball 2 collides with ball 1.  Also, it skips checking for collisions with itself).Then, in my ball class I have my colliding() and resolveCollision() methods:Source Code: Complete source for ball to ball collider. If anyone has some suggestions for how to improve this basic physics simulator let me know!  One thing I have yet to add is angular momentum so the balls will roll more realistically.  Any other suggestions?  Leave a comment!To detect whether two balls collide, just check whether the distance between their centers is less than two times the radius. To do a perfectly elastic collision between the balls, you only need to worry about the component of the velocity that is in the direction of the collision. The other component (tangent to the collision) will stay the same for both balls. You can get the collision components by creating a unit vector pointing in the direction from one ball to the other, then taking the dot product with the velocity vectors of the balls. You can then plug these components into a 1D perfectly elastic collision equation. Wikipedia has a pretty good summary of the whole process. For balls of any mass, the new velocities can be calculated using the equations (where v1 and v2 are the velocities after the collision, and u1, u2 are from before): If the balls have the same mass then the velocities are simply switched. Here\'s some code I wrote which does something similar:As for efficiency, Ryan Fox is right, you should consider dividing up the region into sections, then doing collision detection within each section. Keep in mind that balls can collide with other balls on the boundaries of a section, so this may make your code much more complicated. Efficiency probably won\'t matter until you have several hundred balls though. For bonus points, you can run each section on a different core, or split up the processing of collisions within each section.Well, years ago I made the program like you presented here.\nThere is one hidden problem (or many, depends on point of view):  And also, almost in 100% cases your new speeds will be wrong. Well, not speeds, but positions. You have to calculate new speeds precisely in the correct place. Otherwise you just shift balls on some small "error" amount, which is available from the previous discrete step.The solution is obvious: you have to split the timestep so, that first you shift to correct place, then collide, then shift for the rest of the time you have.You should use space partitioning to solve this problem. Read up on \nBinary Space Partitioning\nand\nQuadtreesAs a clarification to the suggestion by Ryan Fox to split the screen into regions, and only checking for collisions within regions...e.g. split the play area up into a grid of squares (which will will arbitrarily say are of 1 unit length per side), and check for collisions within each grid square.That\'s absolutely the correct solution. The only problem with it (as another poster pointed out) is that collisions across boundaries are a problem.The solution to this is to overlay a second grid at a 0.5 unit vertical and horizontal offset to the first one.Then, any collisions that would be across boundaries in the first grid (and hence not detected) will be within grid squares in the second grid. As long as you keep track of the collisions you\'ve already handled (as there is likely to be some overlap) you don\'t have to worry about handling edge cases. All collisions will be within a grid square on one of the grids.A good way of reducing the number of collision checks is to split the screen into different sections. You then only compare each ball to the balls in the same section.One thing I see here to optimize.While I do agree that the balls hit when the distance is the sum of their radii one should never actually calculate this distance!  Rather, calculate it\'s square and work with it that way.  There\'s no reason for that expensive square root operation.Also, once you have found a collision you have to continue to evaluate collisions until no more remain.  The problem is that the first one might cause others that have to be resolved before you get an accurate picture.  Consider what happens if the ball hits a ball at the edge?  The second ball hits the edge and immediately rebounds into the first ball.  If you bang into a pile of balls in the corner you could have quite a few collisions that have to be resolved before you can iterate the next cycle.As for the O(n^2), all you can do is minimize the cost of rejecting ones that miss:1)  A ball that is not moving can\'t hit anything.  If there are a reasonable number of balls lying around on the floor this could save a lot of tests.  (Note that you must still check if something hit the stationary ball.)2)  Something that might be worth doing:  Divide the screen into a number of zones but the lines should be fuzzy--balls at the edge of a zone are listed as being in all the relevant (could be 4) zones.  I would use a 4x4 grid, store the zones as bits.  If an AND of the zones of two balls zones returns zero, end of test.3)  As I mentioned, don\'t do the square root.I found an excellent page with information on collision detection and response in 2D.http://www.metanetsoftware.com/technique.htmlThey try to explain how it\'s done from an academic point of view. They start with the simple object-to-object collision detection, and move on to collision response and how to scale it up.Edit: Updated linkYou have two easy ways to do this. Jay has covered the accurate way of checking from the center of the ball.The easier way is to use a rectangle bounding box, set the size of your box to be 80% the size of the ball, and you\'ll simulate collision pretty well.Add a method to your ball class:Then, in your loop:I see it hinted here and there, but you could also do a faster calculation first, like, compare the bounding boxes for overlap, and THEN do a radius-based overlap if that first test passes.  The addition/difference math is much faster for a bounding box than all the trig for the radius, and most times, the bounding box test will dismiss the possibility of a collision.  But if you then re-test with trig, you\'re getting the accurate results that you\'re seeking.  Yes, it\'s two tests, but it will be faster overall.This KineticModel is an implementation of the cited approach in Java.I implemented this code in JavaScript using the HTML Canvas element, and it produced wonderful simulations at 60 frames per second.  I started the simulation off with a collection of a dozen balls at random positions and velocities.  I found that at higher velocities, a glancing collision between a small ball and a much larger one caused the small ball to appear to STICK to the edge of the larger ball, and moved up to around 90 degrees around the larger ball before separating.  (I wonder if anyone else observed this behavior.)Some logging of the calculations showed that the Minimum Translation Distance in these cases was not large enough to prevent the same balls from colliding in the very next time step.  I did some experimenting and found that I could solve this problem by scaling up the MTD based on the relative velocities:I verified that before and after this fix, the total kinetic energy was conserved for every collision.  The 0.5 value in the mtd_factor was the approximately the minumum value found to always cause the balls to separate after a collision.Although this fix introduces a small amount of error in the exact physics of the system, the tradeoff is that now very fast balls can be simulated in a browser without decreasing the time step size.As I see here, a better way of implementing it is not mentioned.  I\'ll refer you to "How to Simulate Billiards and Similar Systems" by Boris D. Lubachevsky, available on arxiv: http://arxiv.org/abs/cond-mat/0503627 In the attached picture is a screenshot of a program I intend to make open source when I\'ll finish it. Even in an early stage is running with 5000 spheres pretty smoothly. Hopefully will do even better although I don\'t want to implement sectoring, I want to keep the code easy to understand. The description will be available on http://compphys.go.ro Later edit: The code is now available on GitHub: https://github.com/aromanro/EventMolecularDynamics Description is on the blog: http://compphys.go.ro/event-driven-molecular-dynamics/