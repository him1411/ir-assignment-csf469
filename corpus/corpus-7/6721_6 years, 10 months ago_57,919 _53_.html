In Java we see lots of places where the final keyword can be used but its use is uncommon. For example:In the above case, str can be final but this is commonly left off. When a method is never going to be overridden we can use final keyword. Similarly in case of a class which is not going to be inherited.Does the use of final keyword in any or all of these cases really improve performance? If so, then how? Please explain. If the proper use of final really matters for performance, what habits should a Java programmer develop to make best use of the keyword?Usually not. For virtual methods, HotSpot keeps track of whether the method has actually been overridden, and is able to perform optimizations such as inlining on the assumption that a method hasn\'t been overridden - until it loads a class which overrides the method, at which point it can undo (or partially undo) those optimizations.(Of course, this is assuming you\'re using HotSpot - but it\'s by far the most common JVM, so...)To my mind you should use final based on clear design and readability rather than for performance reasons. If you want to change anything for performance reasons, you should perform appropriate measurements before bending the clearest code out of shape - that way you can decide whether any extra performance achieved is worth the poorer readability/design. (In my experience it\'s almost never worth it; YMMV.)EDIT: As final fields have been mentioned, it\'s worth bringing up that they are often a good idea anyway, in terms of clear design. They also change the guaranteed behaviour in terms of cross-thread visibility: after a constructor has completed, any final fields are guaranteed to be visible in other threads immediately. This is probably the most common use of final in my experience, although as a supporter of Josh Bloch\'s "design for inheritance or prohibit it" rule of thumb, I should probably use final more often for classes...Short answer: don\'t worry about it!Long answer:When talking about final local variables keep in mind that using the keyword final will help the compiler optimize the code statically, which may in the end result in faster code. For example, the final Strings a + b in the example below are concatenated statically (at compile time).The result?Tested on Java Hotspot VM 1.7.0_45-b18.So how much is the actual performance improvement? I don\'t dare say. In most cases probably marginal (~270 nanoseconds in this synthetic test because the string concatenation is avoided altogether - a rare case), but in highly optimized utility code it might be a factor. In any case the answer to the original question is yes, it might improve performance, but marginally at best.Compile-time benefits aside, I could not find any evidence that the use of the keyword final has any measurable effect on performance.YES it can. Here is an instance where final can boost performance:Conditional compilation is a technique in which lines of code are not compiled into the class file based on a particular condition. This can be used to remove tons of debugging code in a production build. consider the following:By converting the doSomething attribute into a final attribute, you have told the compiler that whenever it sees doSomething, it should replace it with false as per the compile-time substitution rules. The first pass of the compiler changes the code to something like this:Once this is done, the compiler takes another look at it and sees that there are unreachable statements in the code. Since you are working with a top-quality compiler, it doesn\'t like all those unreachable byte codes. So it removes them, and you end up with this:thus reducing any excessive codes, or any unnecessary conditional checking.According to IBM - it doesnt for classes or methods.http://www.ibm.com/developerworks/java/library/j-jtp04223.htmlYou are really asking about two (at least) different cases:Jon Skeet has already answered 2). About 1):I don\'t think it makes a difference; for local variables, the compiler can deduce whether the variable is final or not (simply by checking whether it is assigned more than once). So if the compiler wanted to optimize variables that are only assigned once, it can do so no matter whether the variable is actually declared final or not.final might make a difference for protected/public class fields; there it\'s very difficult for the compiler to find out if the field is being set more than once, as it could happen from a different class (which may not even have been loaded). But even then the JVM could use the technique Jon describes (optimize optimistically, revert if a class is loaded which does change the field).In summary, I don\'t see any reason why it should help performance.\nSo this kind of micro-optimization is unlikely to help. You could try benchmarking it to make sure, but I doubt it will make a difference.Edit:Actually, according to Timo Westk\xc3\xa4mper\'s answer, final can improve performance for class fields in some cases. I stand corrected.Note: Not a java expertIf I remember my java correctly, there would be very little way to improve performance using the final keyword. \nI\'ve always known it to exist for "good code" - design and readability. Actually, while testing some OpenGL-related code, I found that using the final modifier on a private field can degrade performance. Here is the start of the class I tested:And this is the method I used to test the performance of various alternatives, amongst which the ShaderInput class:After the 3rd iteration, with the VM warmed up, I consistently got these figures without the final key word:With the final keyword:Note the figures for the ShaderInput test.It didn\'t matter whether I made the fields public or private.Incidentally, there are a few more baffling things. The ShaderInput class outperforms all other variants, even with the final keyword. This is remarkable b/c it basically is a class wrapping a float array, while the other tests directly manipulate the array. Have to figure this one out. May have something to do with ShaderInput\'s fluent interface.Also System.arrayCopy actually apparently is somewhat slower for small arrays than simply copying elements from one array to the other in a for loop. And using sun.misc.Unsafe (as well as direct java.nio.FloatBuffer, not shown here) performs abysmally.I\'m not an expert but I suppose you should add final keyword to the class or method if it won\'t be overwritten and leave variables alone. If there will be any way to optimize such things the compiler will do that for you.Definately yes, if variable converts as constant,as we know java compiler convert such final variables as constant which possiblesas concept of constant java compiler directly replace the value with it\'s reference at compile timein java variables goes as constant if that is string or primitive type which given without any runtime processotherwise it just final (non changeble) variable,& constatnt use is always faster than reference.so if possible, use constants in any programming language for better performancefinal keyword can be used in five ways in Java.A class is final: a class is final means we cannot be extended or inheritance means inheritance is not possible.Similarly - A object is final: some time we does not modified the internal state of object so in such case we can specify the object is final object.object final means not variable also final.Once reference variable is made final, it cannot be reassigned to other object. But can change the contents of the object as long as its fields are not final