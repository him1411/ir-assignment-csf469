Seeing as C# can\'t switch on a Type (which I gather wasn\'t added as a special case because is-a relationships mean that more than one distinct case might apply), is there a better way to simulate switching on type than this?Switching on types is definitely lacking in C# (UPDATE: in C#7 / VS 2017 switching on types is supported- see the answer below). In order to do this without a large if/else if/else statement, you\'ll need to work with a different structure. I wrote a blog post awhile back detailing how to build a TypeSwitch structure.http://blogs.msdn.com/jaredpar/archive/2008/05/16/switching-on-types.aspxShort version: TypeSwitch is designed to prevent redundant casting and give a syntax that is similar to a normal switch/case statement. For example, here is TypeSwitch in action on a standard Windows form eventThe code for TypeSwitch is actually pretty small and can easily be put into your project.One option is to have a dictionary from Type to Action (or some other delegate). Look up the action based on the type, and then execute it. I\'ve used this for factories before now.With C# 7, which shipped with Visual Studio 2017 (Release 15.*), you are able to use Types in case statements:With C# 6, you can use a switch statement with the nameof() operator (thanks @Joey Adams):With C# 5 and earlier, you could use a switch statement, but you\'ll have to use a magic string containing the type name... which is not particularly refactor friendly (thanks @nukefusion)With JaredPar\'s answer in the back of my head, I wrote a variant of his TypeSwitch class that uses type inference for a nicer syntax:Note that the order of the Case() methods is important.Get the full and commented code for my TypeSwitch class. This is a working abbreviated version:Create a superclass (S) and make A and B inherit from it. Then declare an abstract method on S that every subclass needs to implement.Doing this the "foo" method can also change its signature to Foo(S o), making it type safe, and you don\'t need to throw that ugly exception.You should really be overloading your method, not trying to do the disambiguation yourself.  Most of the answers so far don\'t take future subclasses into account, which may lead to really terrible maintenance issues later on.If you were using C# 4, you could make use of the new dynamic functionality to achieve an interesting alternative. I\'m not saying this is better, in fact it seems very likely that it would be slower, but it does have a certain elegance to it.   And the usage:The reason this works is that a C# 4 dynamic method invocation has its overloads resolved at runtime rather than compile time. I wrote a little more about this idea quite recently. Again, I would just like to reiterate that this probably performs worse than all the other suggestions, I am offering it simply as a curiosity.I liked Virtlink\'s use of implicit typing to make the switch much more readable, but I didn\'t like that an early-out isn\'t possible, and that we\'re doing allocations. Let\'s turn up the perf a little.Well, that makes my fingers hurt. Let\'s do it in T4:Adjusting Virtlink\'s example a little:Readable and fast. Now, as everybody keeps pointing out in their answers, and given the nature of this question, order is important in the type matching. Therefore:Given inheritance facilitates an object to be recognized as more than one type, I think a switch could lead to bad ambiguity. For example:Case 1Case 2Because s is a string and an object.\nI think when you write a switch(foo) you expect foo to match one and only one of the case statements. With a switch on types, the order in which you write your case statements could possibly change the result of the whole switch statement. I think that would be wrong.You could think of a compiler-check on the types of a "typeswitch" statement, checking that the enumerated types do not inherit from each other. That doesn\'t exist though.foo is T is not the same as foo.GetType() == typeof(T)!!I would eitherFor built-in types, you can use the TypeCode enumeration.  Please note that GetType() is kind of slow, but probably not relevant in most situations.For custom types, you can create your own enumeration, and either an interface or a base class with abstract property or method...Abstract class implementation of propertyAbstract class implementation of methodInterface implementation of propertyInterface implementation of methodOne of my coworkers just told me about this too: This has the advantage that you can use it for literally any type of object, not just ones that you define.  It has the disadvantage of being a bit larger and slower.First define a static class like this:And then you can use it like this:I looked at a few options here, mirroring what F# can do. F# has much better support for type-based switching (although I\'m still sticking to C# ;-p).\nYou might want to see here and here.Yes thank to C#7 this can be achieved, here\'s how it\'s done (using expression pattern):I such cases I usually end up with a list of predicates and actions. Something along these lines:Create an interface IFooable, then make your A and B classes to implement a common method, which in turn calls the corresponding method you want:Note, that it\'s better to use "as" instead first checking with "is" and then casting, as that way you make 2 casts (expensive).Another way would be to define an interface IThing and then implement it in both classes \nhere\'s the snipet:You can create overloaded methods:And use dynamic parameter type to bypass static type checking:You\'re looking for Discriminated Unions which are a language feature of F#, but you can achieve a similar effect by using a library I made, called OneOf https://github.com/mcintyre321/OneOfThe major advantage over switch (and if and exceptions as control flow) is that it is compile-time safe - there is no default handler or fall throughIf you add a third item to o, you\'ll get a compiler error as you have to add a handler Func inside the switch call.You can also do a .Match which returns a value, rather than executes a statement:I agree with Jon about having a hash of actions to class name.  If you keep your pattern, you might want to consider using the "as" construct instead:The difference is that when you use the patter if (foo is Bar) { ((Bar)foo).Action(); } you\'re doing the type casting twice.  Now maybe the compiler will optimize and only do that work once - but I wouldn\'t count on it.As Pablo suggests, interface approach is almost always the right thing to do to handle this. To really utilize switch, another alternative is to have a custom enum denoting your type in your classes.This is kind of implemented in BCL too. One example is MemberInfo.MemberTypes, another is GetTypeCode for primitive types, like:This is an alternate answer that mixes contributions from JaredPar and VirtLink answers, with the following constraints:Usage:Code: