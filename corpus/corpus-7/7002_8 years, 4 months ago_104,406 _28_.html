What is the difference between Serializable and Externalizable in Java?To add to the other answers, by implementating java.io.Serializable, you get "automatic" serialization capability for objects of your class. No need to implement any other logic, it\'ll just work. The Java runtime will use reflection to figure out how to marshal and unmarshal your objects.In earlier version of Java, reflection was very slow, and so serializaing large object graphs (e.g. in client-server RMI applications) was a bit of a performance problem. To handle this situation, the java.io.Externalizable interface was provided, which is like java.io.Serializable but with custom-written mechanisms to perform the marshalling and unmarshalling functions (you need to implement readExternal and writeExternal methods on your class). This gives you the means to get around the reflection performance bottleneck. In recent versions of Java (1.3 onwards, certainly) the performance of reflection is vastly better than it used to be, and so this is much less of a problem. I suspect you\'d be hard-pressed to get a meaningful benefit from Externalizable with a modern JVM. Also, the built-in Java serialization mechanism isn\'t the only one, you can get third-party replacements, such as JBoss Serialization, which is considerably quicker, and is a drop-in replacement for the default.A big downside of Externalizable is that you have to maintain this logic yourself - if you add, remove or change a field in your class, you have to change your writeExternal/readExternal methods to account for it.In summary, Externalizable is a relic of the Java 1.1 days. There\'s really no need for it any more.Just for completeness, the transient keyword also closes the gap between the two.  If you only want to serialize part of your object, just set specific fields as transient, marking them as not to be persisted, and implement Serializable.Serialization provides default functionality to store and later recreate the object. It uses complex algorithm to define the whole graph of objects to be stored e.g. suppose you have a linkedList and you code like below, then the default serialization will discover all the objects which are linked and will serialize. In default serialization the object is constructed entirely from its stored bits, with no constructor calls.But if you want restricted serialization or don\'t want some portion of your object to be serialized then use Externalizable. The Externalizable interface extends the Serializable interface and adds two methods, writeExternal() and readExternal(). These are automatically called while serialization or deserialization. While working with Externalizable we should remember that the default constructer should be public else the code will throw exception. Please follow the below code:Here if you comment the default constructer then the code will throw below exception:We can observe that as password is sensitive information, so i am not serializing it in writeExternal(ObjectOutput oo) method and not setting the value of same in readExternal(ObjectInput oi). That\'s the flexibility that is provided by Externalizable. The output of the above code is as per below:We can observe as we are not setting the value of passWord so it\'s null.The same can also be achieved by declaring the password field as transient.Hope it helps. I apologize if i made any mistakes. Thanks.Serialization uses certain default behaviors to store and later recreate the object. You may specify in what order or how to handle references and complex data structures, but eventually it comes down to using the default behavior for each primitive data field.Externalization is used in the rare cases that you really want to store and rebuild your object in a completely different way and without using the default serialization mechanisms for data fields. For example, imagine that you had your own unique encoding and compression scheme. Key differences between Serializable and ExternalizableRefer to blog by Hitesh Garg for more details.  https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.htmlDefault serialization is somewhat verbose, and assumes the widest possible usage scenario of the serialized object, and accordingly the default format (Serializable) annotates the resultant stream with information about the class of the serialized object.Externalization give the producer of the object stream complete control over the precise class meta-data (if any) beyond the minimal required identification of the class (e.g. its name).  This is clearly desirable in certain situations, such as closed environments, where producer of the object stream and its consumer (which reifies the object from the stream) are matched, and additional metadata about the class serves no purpose and degrades performance.Additionally (as Uri point out) externalization also provides for complete control over the encoding of the data in the stream corresponding to Java types.  For (a contrived) example, you may wish to record boolean true as \'Y\' and false as \'N\'.  Externalization allows you to do that.The Externalizable interface was not actually provided to optimize the serialization process performance! but to provide means of implementing your own custom processing and offer complete control over the format and contents of the stream for an object and its super types!Examples of this is the implementation of AMF (ActionScript Message Format) remoting to transfer native action script objects over the network.When considering options for improving performance, don\'t forget custom serialization.  You can let Java do what it does well, or at least good enough, for free, and provide custom support for what it does badly.  This is usually a lot less code than full Externalizable support.