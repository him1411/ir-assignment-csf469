Resultset has no method for hasNext. I want to check if the resultSet has any valueis this the correct way That\'s correct, initially the ResultSet\'s cursor is pointing to before the first row, if the first call to next() returns false then there was no data in the ResultSet.If you use this method, you may have to call beforeFirst() immediately after to reset it, since it has positioned itself past the first row now.It should be noted however, that Seifer\'s answer below is a more elegant solution to this question. Assuming you are working with a newly returned ResultSet whose cursor is pointing before the first row, an easier way to check this is to just call isBeforeFirst(). This avoids having to back-track if the data is to be read.As explained in the documentation, this returns false if the cursor is not before the first record or if there are no rows in the ResultSet.Â you could always do the next up front, and just do a post loop checkYou would usually do something like this:If you want to report an empty set, add a variable counting the items read. If you only need to read a single item, then your code is adequate.Best to use ResultSet.next() along with the do {...} while() syntax for this.The "check for any results" call ResultSet.next() moves the cursor to the first row, so use the do {...} while() syntax to process that row while continuing to process remaining rows returned by the loop.This way you get to check for any results, while at the same time also processing any results returned.That would work if you want to see if there are any rows in the result set yes. Note that next() always moves to the next row, so if you are planning on doing any reading from the result set you need to take that into account.Usual usage with ResultSet (when simply reading) is:Which obviously won\'t work correctly if you invoked next() once already to check if the result set was empty, so watch out for that. Although there are methods for "backing up", they are not supported for all types of result sets.According to the most viable answer the suggestion is to use "isBeforeFirst()". That\'s not the best solution if you don\'t have a "forward only type".There\'s a method called ".first()". It\'s less overkill to get the exact same result. You check whether there is something in your "resultset" and don\'t advance your cursor. The documentation states: "(...) false if there are no rows in the result set".You can also just call isBeforeFirst() to test if there are any rows returned without advancing the cursor, then proceed normally. \xe2\x80\x93  SnakeDoc Sep 2 \'14 at 19:00 However, there\'s a difference between "isBeforeFirst()" and "first()". First generates an exception if done on a resultset from type "forward only". Compare the two throw sections: \nhttp://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#isBeforeFirst()\nhttp://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#first()Okay, basically this means that you should use "isBeforeFirst" as long as you have a "forward only" type. Otherwise it\'s less overkill to use "first()". To be totally sure of rather the resultset is empty or not regardless of cursor position, I would do something like this: This function will return true if ResultSet is empty, false if not or throw an SQLException if that ResultSet is closed/uninitialized.isAfterLast() also returns false for empty result set but since cursor is before first row anyways, this method seems more clear.This is a practical and easy read piece I believe.Because if ResultSet has no raw then reset.first returns false.The best thing for to do is to check the first row so that when you intend to get the data you can avoid the mistake of skipping a row. Something like:    if (!resultSet.first() ) { System.out.println("no data"); }By using resultSet.next() you can easily get the result, whether resultSet containing any value or notIt is better to re execute query because when we call if(rs.next()){....} first row of ResultSet will be executed and after it inside while(rs.next()){....} we\'ll get result from next line. So I think re-execution of query inside if is the better option. you can do something like thisI\'ve been attempting to set the current row to the first index (dealing with primary keys). I would suggestWhen the ResultSet is populated, it points to before the first row. When setting it to the first row (indicated by rs.absolute(1)) it will return true denoting it was successfully placed at row 1, or false if the row does not exist. We can extrapolate this towhich sets the current row to position i and will fail if the row doesn\'t exist. This is just an alternative method toI created the following method to check if a ResultSet is empty.It is very important to have the following considerations:CallableStatement object must be setted to let to ResultSet object go at the end and go back to top.TYPE_SCROLL_SENSITIVE: ResultSet object can shift at the end and go back to top. Further can catch last changes.CONCUR_READ_ONLY: We can read the ResultSet object data, but can not updated.I think the easiest way for checking result set is via CollectionUtils under package org.apache.commons.collections.CollectionUtilsThis will check for null as well as empty result set condition. For more detail information you can refer to the following doc. \nCollectionUtilsInitially, the result set object (rs) points to the BFR (before first record). Once we use rs.next(), the cursor points to the first record and the rs holds "true". Using the while loop you can print all the records of the table. After all the records are retrieved, the cursor moves to ALR (After last record) and it will be set to null. Let us consider that there are 2 records in the table.In short hand, we can also write the condition as while (rs.next()).    