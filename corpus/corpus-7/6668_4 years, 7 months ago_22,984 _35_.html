-2147483648 is the smallest integer for integer type with 32 bits, but it seems that it will overflow in the if(...) sentence:This will print true in my testing. However, if we cast -2147483648 to integer, the result will be different:This will print false.I\'m confused. Can anyone give an explanation on this?Update 02-05-2012:Thanks for your comments, in my compiler, the size of int is 4 bytes. I\'m using VC for some simple testing. I\'ve changed the description in my question.That\'s a lot of very good replys in this post, AndreyT gave a very detailed explanation on how the compiler will behaviour on such input, and how this minimum integer was implemented. qPCR4vir on the other hand gave some related "curiosities" and how integer are represented. So impressive!-2147483648 is not a "number". C++ language does not support negative literal values.-2147483648 is actually an expression: a positive literal value 2147483648 with unary - operator in front of it. Value 2147483648 is apparently too large for the positive side of int range on your platform. If type long int had greater range on your platform, the compiler would have to automatically assume that 2147483648 has long int type. (In C++11 the compiler would also have to consider long long int type.) This would make the compiler to evaluate -2147483648 in the domain of larger type and the result would be negative, as one would expect. However, apparently in your case the range of long int is the same as range of int, and in general there\'s no integer type with greater range than int on your platform. This formally means that positive constant 2147483648 overflows all available signed integer types, which in turn means that the behavior of your program is undefined. (It is a bit strange that the language specification opts for undefined behavior in such cases, instead of requiring a diagnostic message, but that\'s the way it is.)In practice, taking into account that the behavior is undefined, 2147483648 might get interpreted as some implementation-dependent negative value which happens to turn positive after having unary - applied to it. Alternatively, some implementations might decide to attempt using unsigned types to represent the value (for example, in C89/90 compilers were required to use unsigned long int, but not in C99 or C++). Implementations are allowed to do anything, since the behavior is undefined anyway.As a side note, this is the reason why constants like INT_MIN are typically defined asinstead of the seemingly more straightforward The latter would not work as intended.The compiler (VC2012) promote to the "minimum" integers that can hold the values. In the first case, signed int (and long int) cannot (before the sign is applied), but unsigned int can: 2147483648 has unsigned int ???? type. \nIn the second you force int from the unsigned. warning C4146: unary minus operator applied to unsigned type, result still unsignedHere are  related "curiosities":C++11 standard:2.14.2 Integer literals [lex.icon]\xe2\x80\xa6  An integer literal is a sequence of digits that has no period or\n  exponent part. An integer literal may have a prefix that specifies its\n  base and a suffix that specifies its type.\xe2\x80\xa6 The type of an integer literal is the first of the corresponding list\n  in which its value can be represented. If an integer literal cannot be represented by any type in its list\n  and an extended integer type (3.9.1) can represent its value, it may\n  have that extended integer type. If all of the types in the list for\n  the literal are signed, the extended integer type shall be signed. If\n  all of the types in the list for the literal are unsigned, the\n  extended integer type shall be unsigned. If the list contains both\n  signed and unsigned types, the extended integer type may be signed or\n  unsigned. A program is ill-formed if one of its translation units\n  contains an integer literal that cannot be represented by any of the\n  allowed types.And these are the promotions rules for integers in the standard.4.5 Integral promotions [conv.prom] A prvalue of an integer type other than bool, char16_t, char32_t, or\n  wchar_t whose integer conversion rank (4.13) is less than the rank of\n  int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be\n  converted to a prvalue of type unsigned int.In Short, 2147483648 overflows to -2147483648, and (-(-2147483648) > 0) is true.This is how 2147483648 looks like in binary.In addition, in the case of signed binary calculations, the most significant bit ("MSB") is the sign bit. This question may help explain why.Because -2147483648 is actually 2147483648 with negation (-) applied to it, the number isn\'t what you\'d expect. It is actually the equivalent of this pseudocode: operator -(2147483648)Now, assuming your compiler has sizeof(int) equal to 4 and CHAR_BIT is defined as 8, that would make 2147483648 overflow the maximum signed value of an integer (2147483647). So what is the maximum plus one? Lets work that out with a 4 bit, 2s compliment integer.Wait! 8 overflows the integer! What do we do? Use its unsigned representation of 1000 and interpret the bits as a signed integer. This representation leaves us with -8 being applied the 2s complement negation resulting in 8, which, as we all know, is greater than 0.This is why <limits.h> (and <climits>) commonly define INT_MIN as ((-2147483647) - 1) - so that the maximum signed integer (0x7FFFFFFF) is negated (0x80000001), then decremented (0x80000000).