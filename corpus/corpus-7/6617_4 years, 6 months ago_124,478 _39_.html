What I am trying to implement is basically a "on ng repeat finished rendering" handler. I am able to detect when it is done but I can\'t figure out how to trigger a function from it.Check the fiddle:http://jsfiddle.net/paulocoelho/BsMqq/3/JSHTMLAnswer:\nWorking fiddle from finishingmove: http://jsfiddle.net/paulocoelho/BsMqq/4/ Notice that I didn\'t use .ready() but rather wrapped it in a $timeout. $timeout makes sure it\'s executed when the ng-repeated elements have REALLY finished rendering (because the $timeout will execute at the end of the current digest cycle -- and it will also call $apply internally, unlike setTimeout). So after the ng-repeat has finished, we use $emit to emit an event to outer scopes (sibling and parent scopes).And then in your controller, you can catch it with $on:With html that looks something like this:Use $evalAsync if you want your callback (i.e., test()) to be executed after the DOM is constructed, but before the browser renders.  This will prevent flicker -- ref.Fiddle.If you really want to call your callback after rendering, use $timeout:I prefer $eval instead of an event.  With an event, we need to know the name of the event and add code to our controller for that event.  With $eval, there is less coupling between the controller and the directive.The answers that have been given so far will only work the first time that the ng-repeat gets rendered, but if you have a dynamic ng-repeat, meaning that you are going to be adding/deleting/filtering items, and you need to be notified every time that the ng-repeat gets rendered, those solutions won\'t work for you.So, if you need to be notified EVERY TIME that the ng-repeat gets re-rendered and not just the first time, I\'ve found a way to do that, it\'s quite \'hacky\', but it will work fine if you know what you are doing. Use this $filter in your ng-repeat before you use any other $filter:This will $emit an event called ngRepeatFinished every time that the ng-repeat gets rendered.The ngRepeatFinish filter needs to be applied directly to an Array or an Object defined in your $scope, you can apply other filters after.Do not apply other filters first and then apply the ngRepeatFinish filter.If you want to apply certain css styles into the DOM after the list has finished rendering, because you need to have into account the new dimensions of the DOM elements that have been re-rendered by the ng-repeat. (BTW: those kind of operations should be done inside a directive)Do not perform a $scope.$apply in that function or you will put Angular in an endless loop that Angular won\'t be able to detect.Do not use it for making changes in the $scope properties, because those changes won\'t be reflected in your view until the next $digest loop, and since you can\'t perform an $scope.$apply they won\'t be of any use.No, they are not, this is a hack, if you don\'t like it don\'t use it. If you know a better way to accomplish the same thing please let me know it.This is a hack, and using it in the wrong way is dangerous, use it only for applying styles after the ng-repeat has finished rendering and you shouldn\'t have any issues.If you need to call different functions for different ng-repeats on the same controller you can try something like this:The directive:In your controller, catch events with $on:In your template with multiple ng-repeatThe other solutions will work fine on initial page load, but calling $timeout from the controller is the only way to ensure that your function is called when the model changes. Here is a working fiddle that uses $timeout. For your example it would be:ngRepeat will only evaluate a directive when the row content is new, so if you remove items from your list, onFinishRender will not fire. For example, try entering filter values in these fiddles emit.If you\xe2\x80\x99re not averse to using double-dollar scope props and you\xe2\x80\x99re writing a directive whose only content is a repeat, there is a pretty simple solution (assuming you only care about the initial render). In the link function:This is useful for cases where you have a directive that needs to do DOM manip based on the widths or heights of the members of a rendered list (which I think is the most likely reason one would ask this question), but it\xe2\x80\x99s not as generic as the other solutions that have been proposed.A solution for this problem with a filtered ngRepeat could have been with Mutation events, but they are deprecated (without immediate replacement).Then I thought of another easy one:This hooks into the Node.prototype methods of the parent element with a one-tick $timeout to watch for successive modifications.It works mostly correct but I did get some cases where the altDone would be called twice.Again... add this directive to the parent of the ngRepeat.Please have a look at the fiddle, http://jsfiddle.net/yNXS2/. Since the directive you created didn\'t created a new scope i continued in the way.$scope.test = function(){... made that happen.Very easy, this is how I did it.