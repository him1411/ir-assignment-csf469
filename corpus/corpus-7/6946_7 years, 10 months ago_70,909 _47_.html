Recently I\'ve seen an example like the following:What does this strange : bar(num) mean? It somehow seems to initialize the member variable but I\'ve never seen this syntax before. It looks like a function/constructor call but for an int?  Makes no sense for me. Perhaps someone could enlighten me. And, by the way, are there any other esoteric language features like this, you\'ll never find in a ordinary C++ book?It\'s a member initialization list.  You should find information about it in any good C++ book.You should, in most cases, initialize all member objects in the member initialization list (however, do note the exceptions listed at the end of the FAQ entry).  The takeaway point from the FAQ entry is that,All other things being equal, your code will run faster if you use initialization lists rather than assignment. This construct is called a Member Initializer List in C++.Simply said, it initializes your member bar to a value num.   Member Initialization: Member Assignment:There is a significant difference between Initializing a member using Member initializer list and assigning it an value inside the constructor body.When you initialize fields via Member initializer list the constructors will be called once and the object will be constructed and initialized in one operation.If you use assignment then the fields will be first initialized with default constructors and then reassigned (via assignment operator) with actual values.As you see there is an additional overhead of creation & assignment in the latter, which might be considerable for user defined classes.The latter is actually equivalent to:While the former is equivalent to just:For an inbuilt (your code example) or POD class members there is no practical overhead.You will have(rather forced) to use a Member Initializer list if:Online version of code sample.Class Member variables are always initialized in the order in which they are declared in the class.They are not initialized in the order in which they are specified in the Member Initalizer List.\nIn short, Member initialization list does not determine the order of initialization.      Given the above it is always a good practice to maintain the same order of members for Member initialization as the order in which they are declared in the class definition. This is because compilers do not warn if the two orders are different but a relatively new user might confuse member Initializer list as the order of initialization and write some code dependent on that.That\'s constructor initialisation.  It is the correct way to initialise members in a class constructor, as it prevents the default constructor being invoked.Consider these two examples:In example 1:In example 2:It\'s all about efficiency.This is called an initialization list.  It is an alternate way of initializing class members.  There are benefits to using this instead of simply assigning new values to the members in the body of the constructor, but if you have class members which are constants or references they must be initialized.This is not obscure, it\'s the C++ initialization list syntaxBasically, in your case, x will be initialized with _x, y with _y, z with _z.The other already explained to you that the syntax that you observe is called "constructor initializer list". This syntax lets you to custom-initialize base subobjects and member subobjects of the class (as opposed to allowing them to default-initialize or to remain uninitialized).I just want to note that the syntax that, as you said, "looks like a constructor call", is not necessarily a constructor call. In C++ language the () syntax is just one standard form of initialization syntax. It is interpreted differently for different types. For class types with user-defined constructor it means one thing (it is indeed a constructor call), for class types without user-defined constructor it means another thing (so called value initialization ) for empty ()) and for non-class types it again means something different (since non-class types have no constructors).In your case the data member has type int. int is not a class type, so it has no constructor. For type int this syntax means simply "initialize bar with the value of num" and that\'s it. It is done just like that, directly, no constructors involved, since, once again, int is not a class type of therefore it can\'t have any constructors.I don\'t know how you could miss this one, it\'s pretty basic. That\'s the syntax for initializing member variables or base class constructors.  It works for plain old data types as well as class objects.This is an initialization list. It\'ll initialize the members before the constructor body is run.\nConsidervs In the first example, str will be initialized by its no-argument constructorbefore the body of the Foo constructor. Inside the foo constructor, thewill be called on \'str\' as you do   str = p;Wheras in the second example, str will be initialized directly by\ncalling its constructorwith \'p\' as an argument.there is another \'benefit\'if the member variable type does not support null initialization or if its a reference (which cannot be null initialized) then you have no choice but to supply an initialization listIt\'s an initialization list for the constructor. Instead of default constructing x, y and z and then assigning them the values received in the parameters, those members will be initialized with those values right off the bat. This may not seem terribly useful for floats, but it can be quite a timesaver with custom classes that are expensive to construct.You are correct, this is indeed a way to initialize member variables.  I\'m not sure that there\'s much benefit to this, other than clearly expressing that it\'s an initialization.  Having a "bar=num" inside the code could get moved around, deleted, or misinterpreted much more easily.Not mentioned yet on this thread: since C++11, the member initializer list can use list-initialization  (aka. "uniform initialization", "braced initialization"):which has the same semantics as list-initialization in other contexts.