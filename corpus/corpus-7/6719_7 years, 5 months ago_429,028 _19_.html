Say I create one object and add it to my ArrayList. If I then create another object with exactly the same constructor input, will the contains() method evaluate the two objects to be the same? Assume the constructor doesn\'t do anything funny with the input, and the variables stored in both objects are identical.Is this how the class should be implemented to have contains() return true?ArrayList implements the List Interface.If you look at the Javadoc for List at the contains method you will see that it uses the equals() method to evaluate if two objects are the same.I think that right implementations should beThe ArrayList uses the equals method implemented in the class (your case Thing class) to do the equals comparison.Generally you should also override hashCode() each time you override equals(), even if just for the performance boost. HashCode() decides which \'bucket\' your object gets sorted into when doing a comparison, so any two objects which equal() evaluates to true should return the same hashCode value(). I cannot remember the default behavior of hashCode() (if it returns 0 then your code should work but slowly, but if it returns the address then your code will fail). I do remember a bunch of times when my code failed because I forgot to override hashCode() though. :)It uses the equals method on the objects. So unless Thing overrides equals and uses the variables stored in the objects for comparison, it will not return true on the contains() method.You must write:Now it works ;)Other posters have addressed the question about how contains() works.An equally important aspect of your question is how to properly implement equals().  And the answer to this is really dependent on what constitutes object equality for this particular class.  In the example you provided, if you have two different objects that both have x=5, are they equal?  It really depends on what you are trying to do.If you are only interested in object equality, then the default implementation of .equals() (the one provided by Object) uses identity only (i.e. this == other).  If that\'s what you want, then just don\'t implement equals() on your class (let it inherit from Object).  The code you wrote, while kind of correct if you are going for identity, would never appear in a real class b/c it provides no benefit over using the default Object.equals() implementation.If you are just getting started with this stuff, I strongly recommend the Effective Java book by Joshua Bloch.  It\'s a great read, and covers this sort of thing (plus how to correctly implement equals() when you are trying to do more than identity based comparisons)Just wanted to note that the following implementation is wrong when value is not a primitive type:In that case I propose the following:Shortcut from JavaDoc:boolean contains(Object o)Returns true if this list contains the specified element. More formally,\nreturns true if and only if this list contains at least one element e such\nthat (o==null ? e==null : o.equals(e))