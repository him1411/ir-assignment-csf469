In the code below, due to the interface, the class LazyBar must return a task from it\'s method (and for arguments sake can\'t be changed). If LazyBars implementation is unusual in that it happens to run quickly and synchronously - what is the best way to return a No-Operation task from the method?I have gone with Task.Delay(0) below, however I would like to know if this has any performance side-effects if the function is called a lot (for arguments sake, say hundreds of times a second):Is there a better way?Using Task.FromResult(0) or Task.FromResult<object>(null) will incur less overhead than creating a Task with a no-op expression.  When creating a Task with a result pre-determined, there is no scheduling overhead involved.Today, I would recommend using Task.CompletedTask to accomplish this.To add to Reed Copsey\'s answer about using Task.FromResult, you can improve performance even more if you cache the already completed task since all instances of completed tasks are the same:With TaskExtensions.CompletedTask you can use the same instance throughout the entire app domain.The latest version of the .Net Framework (v4.6) adds just that with the Task.CompletedTask static propertyTask.Delay(0) as was in the answer was a good approach, as it is a cached copy of a completed Task.As of 4.6 there\'s now Task.CompletedTask which is more explicit in its purpose, but not only does Task.Delay(0) still return a single cached instance, it returns the same single cached instance as does Task.CompletedTask.The cached nature of neither is guaranteed to remain constant, but as implementation-dependent optimisations that are only implementation-dependent as optimisations (that is, they\'d still work correctly if the implementation changed to something that was still valid) the use of Task.Delay(0) was better than the accepted answer.I prefer the Task completedTask = Task.CompletedTask; solution of .Net 4.6, but another approach is to mark the method async and return void:You\'ll get a warning (CS1998 - Async function without await expression), but this is safe to ignore in this context.Recently encountered this and kept getting warnings/errors about the method being void.We\'re in the business of placating the compiler and this clears it up:This brings together the best of all the advice here so far.  No return statement is necessary unless you\'re actually doing something in the method.