What will happen if two modules import each other?To generalize the problem, what about the cyclic imports in Python?There was a really good discussion on this over at comp.lang.python last year. It answers your question pretty thoroughly.Imports are pretty straightforward really. Just remember the following:\'import\' and \'from xxx import yyy\' are executable statements. They execute\n  when the running program reaches that line.If a module is not in sys.modules, then an import creates the new module\n  entry in sys.modules and then executes the code in the module. It does not\n  return control to the calling module until the execution has completed.If a module does exist in sys.modules then an import simply returns that\n  module whether or not it has completed executing. That is the reason why\n  cyclic imports may return modules which appear to be partly empty.Finally, the executing script runs in a module named __main__, importing\n  the script under its own name will create a new module unrelated to\n  __main__.Take that lot together and you shouldn\'t get any surprises when importing\n  modules. If you do import foo inside bar and import bar inside foo, it will work fine. By the time anything actually runs, both modules will be fully loaded and will have references to each other.The problem is when instead you do from foo import abc and from bar import xyz. Because now each module requires the other module to already be imported (so that the name we are importing exists) before it can be imported.Cyclic imports terminate, but you need to be careful not to use the cyclically-imported modules during module initialization.Consider the following files:a.py:b.py:If you execute a.py, you\'ll get the following:On the second import of b.py (in the second a in), the Python interpreter does not import b again, because it already exists in the module dict.If you try to access b.x from a during module initialization, you will get an AttributeError.Append the following line to a.py:Then, the output is:This is because modules are executed on import and at the time b.x is accessed, the line x = 3 has not be executed yet, which will only happen after b out.As other answers describe this pattern is acceptable in python:Which will avoid the execution of the import statement when the file is imported by other modules. Only if there is a logical circular dependency, this will fail.Most Circular Imports are not actually logical circular imports but rather raise ImportError errors, because of the way import() evaluates top level statements of the entire file when called.These ImportErrors can almost always be avoided  if you positively want your imports on top:Consider this circular import:From David Beazleys excellent talk Modules and Packages: Live and Let Die! - PyCon 2015, 1:54:00, here is a way to deal with circular imports in python:This tries to import SimplifiedImageSerializer and if ImportError is raised, because it already is imported, it will pull it from the importcache.PS: You have to read this entire post in David Beazley\'s voice.I got an example here that struck me!foo.pybar.pymain.pyAt the command line: $ python main.pyI completely agree with pythoneer\'s answer here. But I have stumbled on some code that was flawed with circular imports and caused issues when trying to add unit tests. So to quickly patch it without changing everything you can resolve the issue by doing a dynamic import.Again, this isn\'t a permanent fix but may help someone that wants to fix an import error without changing too much of the code.Cheers! Ok, I think I have a pretty cool solution.\nLet\'s say you have file a and file b.\nYou have a def or a class in file b that you want to use in module a, but you have something else, either a def, class, or variable from file a that you need in your definition or class in file b. \nWhat you can do is, at the bottom of file a, after calling the function or class in file a that is needed in file b, but before calling the function or class from file b that you need for file a, say import b\nThen, and here is the key part, in all of the definitions or classes in file b that need the def or class from file a (let\'s call it CLASS), you say from a import CLASSThis works because you can import file b without Python executing any of the import statements in file b, and thus you elude any circular imports.For example:Voila.