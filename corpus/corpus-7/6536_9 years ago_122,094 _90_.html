I hope this question is not considered too basic for this forum, but we\'ll see. I\'m wondering how to refactor some code for better performance that is getting run a bunch of times.Say I\'m creating a word frequency list, using a Map (probably a HashMap), where each key is a String with the word that\'s being counted and the value is an Integer that\'s incremented each time a token of the word is found.In Perl, incrementing such a value would be trivially easy:But in Java, it\'s much more complicated. Here the way I\'m currently doing it:Which of course relies on the autoboxing feature in the newer Java versions. I wonder if you can suggest a more efficient way of incrementing such a value. Are there even good performance reasons for eschewing the Collections framework and using a something else instead?Update: I\'ve done a test of several of the answers. See below.I\'ve gotten a lot of good answers to this question--thanks folks--so I decided to run some tests and figure out which method is actually fastest. The five methods I tested are these:Here\'s what I did...I\'ll present the results first and the code below for those who are interested.The ContainsKey method was, as expected, the slowest, so I\'ll give the speed of each method in comparison to the speed of that method.It would appear that only the MutableInt method and the Trove method are significantly faster, in that only they give a performance boost of more than 10%. However, if threading is an issue, AtomicLong might be more attractive than the others (I\'m not really sure). I also ran TestForNull with final variables, but the difference was negligible.Note that I haven\'t profiled memory usage in the different scenarios. I\'d be happy to hear from anybody who has good insights into how the MutableInt and Trove methods would be likely to affect memory usage.Personally, I find the MutableInt method the most attractive, since it doesn\'t require loading any third-party classes. So unless I discover problems with it, that\'s the way I\'m most likely to go.Here is the crucial code from each method.A little research in 2016: https://github.com/leventov/java-word-count, benchmark source codeBest results per method (smaller is better):Time\\space results:\n@Hank GayAs a follow-up to my own (rather useless) comment: Trove looks like the way to go. If, for whatever reason, you wanted to stick with the standard JDK, ConcurrentMap and AtomicLong can make the code a tiny bit nicer, though YMMV.will leave 1 as the value in the map for foo. Realistically, increased friendliness to threading is all that this approach has to recommend it.It\'s always a good idea to look at the Google Collections Library for this kind of thing. In this case a Multiset will do the trick:There are Map-like methods for iterating over keys/entries, etc. Internally the implementation currently uses a HashMap<E, AtomicInteger>, so you will not incur boxing costs....at least in some cases. They have this nice AtomicLongMap. Especially nice because you are dealing with long as value in your map.E.g.Also possible to add more then 1 to the value:You should be aware of the fact that your original attempt contains two potentially expensive operations on a map, namely containsKey and get. The former performs an operation potentially pretty similar to the latter, so you\'re doing the same work twice!If you look at the API for Map, get operations usually return null when the map does not contain the requested element.Note that this will make a solution likedangerous, since it might yield NullPointerExceptions. You should check for a null first.\n\nAlso note, and this is very important, that HashMaps can contain nulls by definition. So not every returned null says "there is no such element". In this respect, containsKey behaves differently from get in actually telling you whether there is such an element. Refer to the API for details.\n\nFor your case, however, you might not want to distinguish between a stored null and "noSuchElement". If you don\'t want to permit nulls you might prefer a Hashtable. Using a wrapper library as was already proposed in other answers might be a better solution to manual treatment, depending on the complexity of your application.To complete the answer (and I forgot to put that in at first, thanks to the edit function!), the best way of doing it natively, is to get into a final variable, check for null and put it back in with a 1. The variable should be final because it\'s immutable anyway. The compiler might not need this hint, but its clearer that way.If you do not want to rely on autoboxing, you should say something like map.put(new Integer(1 + i.getValue())); instead.OK, may be an old question, but there is a shorter way with Java 8 :What it does : if key do not exists, put 1 as value, otherwise sum 1 to the value linked to key.\nMore information hereAnother way would be creating a mutable integer:of course this implies creating an additional object but the overhead in comparison to creating an Integer (even with Integer.valueOf) should not be so much.And that\'s how you increment a value with simple code.Benefit:Another way is to use merge method, but this is too much for just incrementing a value.Suggestion: you should care about code readability more than little performance gain in most of the time.Memory rotation may be an issue here, since every boxing of an int larger than or equal to 128 causes an object allocation (see Integer.valueOf(int)). Although the garbage collector very efficiently deals with short-lived objects, performance will suffer to some degree.If you know that the number of increments made will largely outnumber the number of keys (=words in this case), consider using an int holder instead. Phax already presented code for this. Here it is again, with two changes (holder class made static and initial value set to 1):If you need extreme performance, look for a Map implementation which is directly tailored towards primitive value types. jrudolph mentioned GNU Trove.By the way, a good search term for this subject is "histogram".Instead of calling containsKey() it is faster just to call map.get and check if the returned value is null or not.Are you sure that this is a bottleneck? Have you done any performance analysis?Try using the NetBeans profiler (its free and built into NB 6.1) to look at hotspots.Finally, a JVM upgrade (say from 1.5->1.6) is often a cheap performance booster. Even an upgrade in build number can provide good performance boosts. If you are running on Windows and this is a server class application, use -server on the command line to use the Server Hotspot JVM. On Linux and Solaris machines this is autodetected.There are a couple of approaches:Use a Bag alorithm like the sets contained in Google Collections.Create mutable container which you can use in the Map:And use put("word", new My("Word") ); Then you can check if it exists and increment when adding.Avoid rolling your own solution using lists, because if you get innerloop searching and sorting, your performance will stink. The first HashMap solution is actually quite fast, but a proper like that found in Google Collections is probably better.Counting words using Google Collections, looks something like this:Using the HashMultiset is quite elegent, because a bag-algorithm is just what you need when counting words.I think your solution would be the standard way, but - as you noted yourself - it is probably not the fastest way possible.You may look at GNU Trove. That is a library which contains all sorts of fast primitive Collections. Your example would use a TObjectIntHashMap which has a method adjustOrPutValue which does exactly what you want.A variation on the MutableInt approach that might be even faster, if a bit of a hack, is to use a single-element int array: It would be interesting if you could rerun your performance tests with this variation.  It might be the fastest.Edit: The above pattern worked fine for me, but eventually I changed to use Trove\'s collections to reduce memory size in some very large maps I was creating -- and as a bonus it was also faster.One really nice feature is that the TObjectIntHashMap class has a single adjustOrPutValue call that, depending on whether there is already a value at that key, will either put an initial value or increment the existing value.  This is perfect for incrementing:Google Collections HashMultiset :\n - quite elegant to use\n - but consume CPU and memoryBest would be to have a method like : Entry<K,V> getOrPut(K); \n(elegant, and low cost)Such a method will compute hash and index only once,\nand then we could do what we want with the entry\n(either replace or update the value).More elegant:\n - take a HashSet<Entry>\n - extend it so that get(K) put a new Entry if needed\n - Entry could be your own object.\n--> (new MyHashSet()).get(k).increment(); "put" need "get" (to ensure no duplicate key).\nSo directly do a "put",\nand if there was a previous value, then do an addition:If count starts at 0, then add 1: (or any others values...)Notice : This code is not thread safe. Use it to build then use the map, not to concurrently update it. Optimization : In a loop, keep old value to become the new value of next loop.The various primitive wrappers, e.g., Integer are immutable so there\'s really not a more concise way to do what you\'re asking unless you can do it with something like AtomicLong. I can give that a go in a minute and update. BTW, Hashtable is a part of the Collections Framework.I\'d use Apache Collections Lazy Map (to initialize values to 0) and use MutableIntegers from Apache Lang as values in that map. Biggest cost is having to serach the map twice in your method. In mine you have to do it just once. Just get the value (it will get initialized if absent) and increment it.The Functional Java library\'s TreeMap datastructure has an update method in the latest trunk head:Example usage:This program prints "2".@Vilmantas Baranauskas: Regarding this answer, I would comment if I had the rep points, but I don\'t.  I wanted to note that the Counter class defined there is NOT thread-safe as it is not sufficient to just synchronize inc() without synchronizing value().  Other threads calling value() are not guaranteed to see the the value unless a happens-before relationship has been established with the update.  You can make use of computeIfAbsent method in Map interface provided in Java 8. The method computeIfAbsent checks if the specified key is already associated with a value or not? If no associated value then it attempts to compute its value using the given mapping function. In any case it returns the current (existing or computed) value associated with the specified key, or null if the computed value is null.On a side note if you have a situation where multiple threads update a common sum you can have a look at LongAdder class.Under high contention, expected throughput of this class is significantly higher than AtomicLong, at the expense of higher space consumption.If you\'re using Eclipse Collections, you can use a HashBag. It will be the most efficient approach in terms of memory usage and it will also perform well in terms of execution speed.HashBag is backed by a MutableObjectIntMap which stores primitive ints instead of Counter objects. This reduces memory overhead and improves execution speed.HashBag provides the API you\'d need since it\'s a Collection that also allows you to query for the number of occurrences of an item.Here\'s an example from the Eclipse Collections Kata.Note: I am a committer for Eclipse Collections.I don\'t know how efficient it is but the below code works as well.You need to define a BiFunction at the beginning. Plus, you can make more than just increment with this method.output is