I have been very excited about MongoDb and have been testing it lately. I had a table called posts in MySQL with about 20 million records indexed only on a field called \'id\'.I wanted to compare speed with MongoDB and I ran a test which would get and print 15 records randomly from our huge databases. I ran the query about 1,000 times each for mysql and MongoDB and I am suprised that I do not notice a lot of difference in speed. Maybe MongoDB is 1.1 times faster. That\'s very disappointing. Is there something I am doing wrong? I know that my tests are not perfect but is MySQL on par with MongoDb when it comes to read intensive chores. \nNote:Sample Code Used For Testing MongoDB\nSample Code For Testing MySQLMongoDB is not magically faster. If you store the same data, organised in basically the same fashion, and access it exactly the same way, then you really shouldn\'t expect your results to be wildly different. After all, MySQL and MongoDB are both GPL, so if Mongo had some magically better IO code in it, then the MySQL team could just incorporate it into their codebase.People are seeing real world MongoDB performance largely because MongoDB allows you to query in a different manner that is more sensible to your workload.For example, consider a design that persisted a lot of information about a complicated entity in a normalised fashion. This could easily use dozens of tables in MySQL (or any relational db) to store the data in normal form, with many indexes needed to ensure relational integrity between tables.Now consider the same design with a document store. If all of those related tables are subordinate to the main table (and they often are), then you might be able to model the data such that the entire entity is stored in a single document. In MongoDB you can store this as a single document, in a single collection. This is where MongoDB starts enabling superior performance.In MongoDB, to retrieve the whole entity, you have to perform:So a b-tree lookup, and a binary page read. Log(n) + 1 IOs. If the indexes can reside entirely in memory, then 1 IO.In MySQL with 20 tables, you have to perform:So the total for mysql, even assuming that all indexes are in memory (which is harder since there are 20 times more of them) is about 20 range lookups.These range lookups are likely comprised of random IO \xe2\x80\x94 different tables will definitely reside in different spots on disk, and it\'s possible that different rows in the same range in the same table for an entity might not be contiguous (depending on how the entity has been updated, etc).So for this example, the final tally is about 20 times more IO with MySQL per logical access, compared to MongoDB.This is how MongoDB can boost performance in some use cases.Do you have concurrency, i.e simultaneous users ? If you just run 1000 times the query straight, with just one thread, there will be almost no difference. Too easy for these engines :)BUT I strongly suggest that you build a true load testing session, which means using an injector such as JMeter with 10, 20 or 50 users AT THE SAME TIME so you can really see a difference (try to embed this code inside a web page JMeter could query).I just did it today on a single server (and a simple collection / table) and the results are quite interesting and surprising (MongoDb was really faster on writes & reads, compared to MyISAM engine and InnoDb engine).This really should be part of your test : concurrency & MySQL engine.\nThen, data/schema design & application needs are of course huge requirements, beyond response times. Let me know when you get results, I\'m also in need of inputs about this!Source: https://github.com/webcaetano/mongo-mysql10 rows100 rows1000 rows10.000 rowsman,,, the answer is that you\'re basically testing PHP and not a database.don\'t bother iterating the results, whether commenting out the print or not. there\'s a chunk of time.while the other chunk is spend yacking up a bunch of rand numbers.then theres a major difference b/w implode and in.and finally what is going on here. looks like creating a connection each time, thus its testing the connection time plus the query time.vs so your 101% faster might turn out to be 1000% faster for the underlying query stripped of jazz.urghhh. https://github.com/reoxey/benchmarkbenchmarkspeed comparison of MySQL & MongoDB in GOLANG1.6 & PHP5system used for benchmark: DELL cpu i5 4th gen 1.70Ghz * 4 ram 4GB GPU ram 2GBSpeed comparison of RDBMS vs NoSQL for INSERT, SELECT, UPDATE, DELETE executing different number of rows 10,100,1000,10000,100000,1000000Language used to execute is: PHP5 & Google fastest language GO 1.6Here is a little research that explored RDBMS vs NoSQL using MySQL vs Mongo, the conclusions were inline with @Sean Reilly\'s response. In short, the benefit comes from the design, not some raw speed difference. Conclusion on page 35-36:RDBMS vs NoSQL: Performance and Scaling ComparisonThe project tested, analysed and compared the performance and\n  scalability of the two database types. The experiments done included\n  running different numbers and types of queries, some more complex than\n  others, in order to analyse how the databases scaled with increased\n  load. The most important factor in this case was the query type used\n  as MongoDB could handle more complex queries faster due mainly to its\n  simpler schema at the sacrifice of data duplication meaning that a\n  NoSQL database may contain large amounts of data duplicates. Although\n  a schema directly migrated from the RDBMS could be used this would\n  eliminate the advantage of MongoDB\xe2\x80\x99s underlying data representation of\n  subdocuments which allowed the use of less queries towards the\n  database as tables were combined. Despite the performance gain which\n  MongoDB had over MySQL in these complex queries, when the benchmark\n  modelled the MySQL query similarly to the MongoDB complex query by\n  using nested SELECTs MySQL performed best although at higher numbers\n  of connections the two behaved similarly. The last type of query\n  benchmarked which was the complex query containing two JOINS and and a\n  subquery showed the advantage MongoDB has over MySQL due to its use of\n  subdocuments. This advantage comes at the cost of data duplication\n  which causes an increase in the database size. If such queries are\n  typical in an application then it is important to consider NoSQL\n  databases as alternatives while taking in\n  account the cost in storage and memory size resulting from the larger\n  database size.On Single Server, MongoDb would not be any faster than mysql MyISAM on both read and write, given table/doc \nsizes are small 1 GB to 20 GB.\nMonoDB will be faster on Parallel Reduce on Multi-Node clusters, where Mysql can NOT scale horizontally.   