I came across the term duck typing while reading random topics on software online and did not completely understand it.What is \xe2\x80\x9cduck typing\xe2\x80\x9d?It is a term used in dynamic languages that do not have strong typing.The idea is that you don\'t need a type in order to invoke an existing method on an object - if a method is defined on it, you can invoke it.The name comes from the phrase "If it looks like a duck and quacks like a duck, it\'s a duck".Wikipedia has much more information.Duck typing\nmeans that an operation does not formally specify the requirements that its operands have to meet, but just tries it out with what is given.Unlike what others have said, this does not necessarily relate to dynamic languages or inheritance issues.Example task: Call some method Quack on an object.Without using duck-typing, a function f doing this task has to specify in advance that its argument has to support some method Quack. A common way is the use of interfacesCalling f(42) fails, but f(donald) works as long as donald is an instance of a IQuack-subtype.Another approach is structural typing - but again, the method Quack() is formally specified any anything that cannot prove it quacks in advance will cause a compiler failure.We could even writein Haskell, where the Quackable typeclass ensures the existence of our method.Well, as I said, a duck typing system does not specify requirements but just tries if anything works.Thus, a dynamic type system as Python\'s always uses duck typing:If f gets an x supporting a Quack(), everything is fine, if not, it will crash at runtime.But duck typing doesn\'t imply dynamic typing at all - in fact, there is a very popular but completely static duck typing approach that doesn\'t give any requirements too:The function doesn\'t tell in any way that it wants some x that can Quack, so instead it just tries at compile time and if everything works, it\'s fine.Ask a programmer what it is and you\'ll get three different responses, but this is the general idea of what most people mean by it:Duck Typing (\xe2\x80\x9cIf it walks like a duck and quacks like a duck then it is a duck.\xe2\x80\x9d) - yes but what does that mean? This is best illustrated by example:Example:Imagine I have a magically ability. Special powers. If I say "Drive!" to a car, well then, it drives!Does it work on other things? Not sure: so I try it on a truck. Wow - it drives too! I then try it on planes, trains and 1 Woods. They all drive! But would it work on say, a teacup? Error: KAAAA-BOOOOOOM! that didn\'t work out so good. ====> Teacups can\'t drive!! duh!?This is basically the concept of duck typing. It\'s a try-before-you-buy type system. If it works, all is well. But if it fails, well, it\'s gonna blow up in your face.In other words, we are interested in what the object can do, rather than with what the object is.If we were concerned with what the object actually was, then our magic trick will work on cars, but will fail on other objects which can drive: trucks, mopeds, tuk-tuks etc. It won\'t work on trucks because our magic wand is expecting it to only work on cars. The only way you can get a truck to drive is if you can somehow get the magic wand to expect both trucks and cars (perhaps by "implementing a common interface"). If you don\'t know what that means then don\'t worry.SummaryThe important thing to take out of this is, is that what\'s important in duck typing is what the object can actually do, rather than what the object is. Hope that helps.Wikipedia has a fairly detailed explanation:http://en.wikipedia.org/wiki/Duck_typingduck typing is a style of dynamic\n  typing in which an object\'s current\n  set of methods and properties\n  determines the valid semantics, rather\n  than its inheritance from a particular\n  class or implementation of a specific\n  interface.The important note is likely that with duck typing a developer is concerned more with the parts of the object that are consumed rather than what the actual underlying type is. Consider you are designing a simple function, which gets an object of type Bird and calls its walk() method. There are two approaches, that you can think of:It must be considered that the duck typing may be useful in some cases, for example Python uses duck typing a lot. I know I am not giving generalized answer. In Ruby, we don\xe2\x80\x99t declare the types of variables or methods\xe2\x80\x94 everything is just some kind of object.\nSo Rule is "Classes Aren\xe2\x80\x99t Types"In Ruby, the class is never (OK, almost never) the type. Instead, the type of an object is defined more by what that object can do. In Ruby, we call this duck typing. If an object walks like a duck and talks like a duck, then the interpreter is happy to treat it as if it were a duck.For example, you may be writing a routine to add song information to a string. If you come from a C# or Java background, you may be tempted to write this:Embrace Ruby\xe2\x80\x99s duck typing, and you\xe2\x80\x99d write something far simpler:You don\xe2\x80\x99t need to check the type of the arguments. If they support << (in the case of result) or title and artist (in the case of song), everything will just work. If they don\xe2\x80\x99t, your method will throw an exception anyway (just as it would have done if you\xe2\x80\x99d checked the types). But without the check, your method is suddenly a lot more flexible. You could pass it an array, a string, a file, or any other object that appends using <<, and it would just work.Duck typing: If it talks and walks like a duck, then it is a duckThis is typically called abduction (abductive reasoning or also called retroduction, a clearer definition I think):from C (conclusion, what we see) and R (rule, what we know), we accept/decide/assume P (Premise, property) in other words a given fact... the very basis of medical diagnosiswith ducks: C = walks, talks, R = like a duck, P = it\'s a duckBack to programming:object o has method/property mp1 and interface/type T\nrequires/defines mp1object o has method/property mp2  and interface/type T requires/defines mp2...So, more than simply accepting mp1... on any object as long has it meets some definition of mp1..., compiler/runtime should also be okay with the assertion o is of type TAnd well, is it the case with examples above? Is Duck typing is essentially no typing at all? Or should we call it implicit typing?Looking at the language itself may help; it often helps me (I\'m not a native English speaker).In duck typing:1) the word typing does not mean typing on a keyboard (as was the persistent image in my mind), it means determining "what type of a thing is that thing?"2) the word duck expresses how is that determining done; it\'s kind of a \'loose\' determining, as in: "if it walks like a duck ... then it\'s a duck". It\'s \'loose\' because the thing may be a duck or may not, but whether it actually is a duck doesn\'t matter; what matters is that I can do with it what I can do with ducks and expect behaviors exhibited by ducks. I can feed it bread crumbs and the thing may go towards me or charge at me or back off ... but it will not devour me like a grizzly would.