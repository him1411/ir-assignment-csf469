Can Go have optional parameters? Or can I just define two functions with the same name and a different number of arguments?Go does not have optional parameters nor does it support method overloading:Method dispatch is simplified if it\n  doesn\'t need to do type matching as\n  well. Experience with other languages\n  told us that having a variety of\n  methods with the same name but\n  different signatures was occasionally\n  useful but that it could also be\n  confusing and fragile in practice.\n  Matching only by name and requiring\n  consistency in the types was a major\n  simplifying decision in Go\'s type\n  system.You can use a struct which includes the parameters:A nice way to achieve something like optional parameters is to use variadic args.  The function actually receives a slice of whatever type you specify.For arbitrary, potentially large number of optional parameters, a nice idiom is to use Functional options.For your type Foobar, first write only one constructor:where each option is a function which mutates the Foobar. Then provide convenient ways for your user to use or create standard options, for example :PlaygroundFor conciseness, you may give a name to the type of the options (Playground) :If you need mandatory parameters, add them as first arguments of the constructor before the variadic options.The main benefits of the Functional options idiom are :This technique was coined by Rob Pike and also demonstrated by Dave Cheney, but I can\'t find the exact links. Here is a transcription of the dotGo 2014 talk where I learned it.Neither optional parameters nor function overloading are supported in Go.  Go does support a variable number of parameters: Passing arguments to ... parametersNo -- neither.  Per the Go for C++ programmers docs,Go does not support function\n  overloading and does not support user\n  defined operators.I can\'t find an equally clear statement that optional parameters are unsupported, but they are not supported either.You can encapsulate this quite nicely in a func similar to what is below.In this example, the prompt by default has a colon and a space in front of it . . .. . . however you can override that by supplying a parameter to the prompt function.This will result in a prompt like below.I ended up using a combination of a structure of params and variadic args.  This way, I didn\'t have to change the existing interface which was consumed by several services and my service was able to pass additional params as needed.  Sample code in golang playground: https://play.golang.org/p/G668FA97NuI am a little late, but if you like fluent interface you might design your setters for chained calls like this:And then call it like this:This is similar to the Functional options idiom presented on @Ripounet answer and enjoys the same benefits but has some drawbacks:There is, however, a possible small advantage, this type of function calls should be easier for the compiler to inline but I am really not a specialist.