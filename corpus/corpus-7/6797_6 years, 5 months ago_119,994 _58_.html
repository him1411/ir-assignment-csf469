I know there are many posts out there about the differences between these two patterns, but there are a few things that I cannot find.From what I have been reading, I see that the factory method pattern allows you to define how to create a single concrete product but hiding the implementation from the client as they will see a generic product. My first question is about the abstract factory. Is its role to allow you to create families of concrete objects in (that can depend on what specific factory you use) rather than just a single concrete object? Does the abstract factory only return one very large object or many objects depending on what methods you call?My final two questions are about a single quote that I cannot fully understand that I have seen in numerous places:One difference between the two is that\n  with the Abstract Factory pattern, a\n  class delegates the responsibility of\n  object instantiation to another object\n  via composition whereas the Factory\n  Method pattern uses inheritance and\n  relies on a subclass to handle the\n  desired object instantiation.My understanding is that the factory method pattern has a Creator interface that will make the ConcreteCreator be in charge of knowing which ConcreteProduct to instantiate. Is this what it means by using inheritance to handle object instantiation?Now with regards to that quote, how exactly does the Abstract Factory pattern delegate the responsibility of object instantiation to another object via composition? What does this mean? It looks like the Abstract Factory pattern also uses inheritance to do the construction process as well in my eyes, but then again I am still learning about these patterns.Any help especially with the last question, would be greatly appreciated. The main difference between a "factory method" and an "abstract factory" is that the factory method is a single method, and an abstract factory is an object. I think a lot of people get these two terms confused, and start using them interchangeably. I remember that I had a hard time finding exactly what the difference was when I learnt them.Because the factory method is just a method, it can be overridden in a subclass, hence the second half of your quote: ... the Factory Method pattern uses\n  inheritance and relies on a subclass\n  to handle the desired object\n  instantiation.The quote assumes that an object is calling its own factory method here. Therefore the only thing that could change the return value would be a subclass.The abstract factory is an object that has multiple factory methods on it. Looking at the first half of your quote:... with the Abstract Factory pattern, a class\n  delegates the responsibility of object\n  instantiation to another object via\n  composition ...What they\'re saying is that there is an object A, who wants to make a Foo object. Instead of making the Foo object itself (e.g., with a factory method), it\'s going to get a different object (the abstract factory) to create the Foo object.To show you the difference, here is a factory method in use:And here is an abstract factory in use:Abstract factory creates a base class with abstract methods defining methods for the objects that should be created. Each factory class which derives the base class can create their own implementaton of each object type.Factory method is just a simple method used to create objects in a class. It\'s usually added in the aggregate root (The Order class has a method called CreateOrderLine)SummaryThe difference is that the intended purpose of the class containing a factory method is not to create objects, while an abstract factory should only be used to create objects.One should take care when using factory methods since it\'s easy to break the LSP (Liskovs Substitution principle) when creating objects.Difference between AbstractFactory and Factory design patters are as follows:Factory Method Pattern Implementation: AbstractFactory Pattern Implementation:Abstract Factory is an interface for creating related products, but Factory Method is only one method. Abstract Factory can be implemented by multiple Factory Methods.Consider this example for easy understanding. What does telecommunication companines provide? Broadband, phone line and mobile for instance and you\'re asked to create an application to offer their products to their customers.Generally what you\'d do here is, creating the products i.e broadband, phone line and mobile is through your Factory Method where you know what properties you have for those products and its pretty straigh forward.Now, the company wants to offer their customer a bundle of their products i.e broadband, phone line and mobile all together, and here comes the Abstract Factory to play.Abstract Factory is in other words are composition of other factories who are responsible for creating their own products and Abstract Factory knows how to place these products in more meaningful in respect of its own responsibilities.In this case, the BundleFactory is the Abstract Factory, BroadbandFactory, PhonelineFactory and MobileFactory are the Factory. To simply more, these Factories will have Factory Method to initialise the individual products.Se the code sample below:Let us put it clear that most of the time in production code, we use abstract factory pattern because class A is programmed with interface B.  And A needs to create instances of B.  So A has to have a factory object to produce instances of B. So A is not dependent on any concrete instance of B.  Hope it helps.Yes. The intent of Abstract Factory is:Provide an interface for creating families of related or dependent objects without specifying their concrete classes.Ideally it should return one object per the method client is invoking. Yes. Factory method uses inheritance. AbstractFactory defines a FactoryMethod and ConcreteFactory is responsible for building a ConcreteProduct. Just follow through the code example in this article.You can find more details in related SE posts:What is the basic difference between the Factory and Abstract Factory Patterns?factory-example-by-implementing-factory-method documentation link in design-patterns topic.Understand the differences in the motivations: \n    Suppose you\xe2\x80\x99re building a tool where you\xe2\x80\x99ve objects and a concrete implementation of the interrelations of the objects. Since you foresee variations in the objects, you\xe2\x80\x99ve created an indirection by assigning the responsibility of creating variants of the objects to another object (we call it abstract factory). This abstraction finds strong benefit since you foresee future extensions needing variants of those objects. \n    Another rather intriguing motivation in this line of thoughts is a case where every-or-none of the objects from the whole group will have a corresponding variant. Based on some conditions, either of the variants will be used and in each case all objects must be of same variant. This might be a bit counter intuitive to understand as we often tend think that - as long as the variants of an object follow a common uniform contract (interface in broader sense), the concrete implementation code should never break. The intriguing fact here is that, not always this is true especially when expected behavior cannot be modeled by a programming contract. \nA simple (borrowing the idea from GoF) is any GUI applications say a virtual monitor that emulates look-an-feel of MS or Mac or Fedora OS\xe2\x80\x99s. Here, for example, when all widget objects such as window, button, etc. have MS variant except a scroll-bar that is derived from MAC variant, the purpose of the tool fails badly. \n    These above cases form the fundamental need of Abstract Factory Pattern. \n\nOn the other hand, imagine you\xe2\x80\x99re writing a framework so that many people can built various tools (such as the one in above examples) using your framework. By the very idea of a framework, you don\xe2\x80\x99t need to, albeit you could not use concrete objects in your logic. You rather put some high level contracts between various objects and how they interact. While you (as a framework developer) remain at a very abstract level, each builders of the tool is forced to follow your framework-constructs. However, they (the tool builders) have the freedom to decide what object to be built and how all the objects they create will interact. Unlike the previous case (of Abstract Factory Pattern), you (as framework creator) don\xe2\x80\x99t need to work with concrete objects in this case; and rather can stay at the contract level of the objects. Furthermore, unlike the second part of the previous motivations, you or the tool-builders never have the situations of mixing objects from variants. Here, while framework code remains at contract level, every tool-builder is restricted (by the nature of the case itself) to using their own objects. Object creations in this case is delegated to each implementer and framework providers just provide uniform methods for creating and returning objects. Such methods are inevitable for framework developer to proceed with their code and has a special name called Factory method (Factory Method Pattern for the underlying pattern). \nFew Notes: Sample Code:To make it very simple with minimum interface & please focus "//1":Here important points: 1. Factory & AbstractFactory mechanisms must use inheritance (System.Object-> byte, float ...); so if you have inheritance in program then Factory(Abstract Factory would not be there most probably) is already there by design 2. Creator (MyFactory) knows about concrete type so returns concrete type object to caller(Main); In abstract factory return type would be an Interface.Important points: 1. Requirement: Honda would create "Regular", "Sports" but Hero would create "DarkHorse", "Sports" and "Scooty". 2. why two interfaces?  One for manufacturer type(IVehicleFactory) and another for product  factory(IVehicle); other way to understand 2 interfaces is abstract factory is all about creating related objects 2. The catch is the IVehicleFactory\'s children returning and IVehicle(instead of concrete in factory); so I get parent variable(IVehicle); then I create actual concrete type by calling CreateSingleVehicle and then casting parent object to actual child object. What would happen if I do RegularBike heroRegularBike = (RegularBike)hero.CreateSingleVehicle("Regular");; you will get ApplicationException and that\'s why we need generic abstract factory which I would explain if required. Hope it helps from beginner to intermediate audience.I would favor Abstract Factory over Factory Method anytime. From Tom Dalling\'s example (great explanation btw) above, we can see that Abstract Factory is more composable in that all we need to do is passing a different Factory to the constructor (constructor dependency injection in use here). But Factory Method requires us to introduce a new class (more things to manage) and use subclassing. Always prefer composition over inheritance. 