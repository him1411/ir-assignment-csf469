There\'s this one thing in C++ which has been making me feel uncomfortable for quite a long time, because I honestly don\'t know how to do it, even though it sounds simple:Goal: to make it possible to allow the client to instantiate some object using factory methods instead of the object\'s constructors, without unacceptable consequences and a performance hit. By "Factory method pattern", I mean both static factory methods inside an object or methods defined in another class, or global functions. Just generally "the concept of redirecting the normal way of instantiation of class X to anywhere else than the constructor".Let me skim through some possible answers which I have thought of.This sounds nice (and indeed often the best solution), but is not a general remedy. First of all, there are cases when object construction is a task complex enough to justify its extraction to another class. But even putting that fact aside, even for simple objects using just constructors often won\'t do.The simplest example I know is a 2-D Vector class. So simple, yet tricky. I want to be able to construct it both from both Cartesian and polar coordinates. Obviously, I cannot do:My natural way of thinking is then:Which, instead of constructors, leads me to usage of static factory methods... which essentially means that I\'m implementing the factory pattern, in some way ("the class becomes its own factory"). This looks nice (and would suit this particular case), but fails in some cases, which I\'m going to describe in point 2. Do read on.another case: trying to overload by two opaque typedefs of some API (such as GUIDs of unrelated domains, or a GUID and a bitfield), types semantically totally different (so - in theory - valid overloads) but which actually turn out to be the same thing - like unsigned ints or void pointers.Java has it simple, as we only have dynamic-allocated objects. Making a factory is as trivial as:In C++, this translates to:Cool? Often, indeed. But then- this forces the user to only use dynamic allocation. Static allocation is what makes C++ complex, but is also what often makes it powerful. Also, I believe that there exist some targets (keyword: embedded) which don\'t allow for dynamic allocation. And that doesn\'t imply that the users of those platforms like to write clean OOP.Anyway, philosophy aside: In the general case, I don\'t want to force the users of the factory to be restrained to dynamic allocation.OK, so we know that 1) is cool when we want dynamic allocation. Why won\'t we add static allocation on top of that?What? We can\'t overload by the return type? Oh, of course we can\'t. So let\'s change the method names to reflect that. And yes, I\'ve written the invalid code example above just to stress how much I dislike the need to change the method name, for example because we cannot implement a language-agnostic factory design properly now, since we have to change names - and every user of this code will need to remember that difference of the implementation from the specification.OK... there we have it. It\'s ugly, as we need to change the method name. It\'s imperfect, since we need to write the same code twice. But once done, it works. Right?Well, usually. But sometimes it does not. When creating Foo, we actually depend on the compiler to do the return value optimisation for us, because the C++ standard is benevolent enough for the compiler vendors not to specify when will the object created in-place and when will it be copied when returning a temporary object by value in C++. So if Foo is expensive to copy, this approach is risky.And what if Foo is not copiable at all? Well, doh. (Note that in C++17 with guaranteed copy elision, not-being-copiable is no problem anymore for the code above)Conclusion: Making a factory by returning an object is indeed a solution for some cases (such as the 2-D vector previously mentioned), but still not a general replacement for constructors.Another thing that someone would probably come up with is separating the issue of object allocation and its initialisation. This usually results in code like this:One may think it works like a charm. The only price we pay for in our code...Since I\'ve written all of this and left this as the last, I must dislike it too. :) Why?First of all... I sincerely dislike the concept of two-phase construction and I feel guilty when I use it. If I design my objects with the assertion that "if it exists, it is in valid state", I feel that my code is safer and less error-prone. I like it that way.Having to drop that convention AND changing the design of my object just for the purpose of making factory of it is.. well,  unwieldy.I know that the above won\'t convince many people, so let\'s me give some more solid arguments. Using two-phase construction, you cannot:And probably there could be some more drawbacks which I can\'t think of right now, and I don\'t even feel particularly obliged to since the above bullet points convince me already.So: not even close to a good general solution for implementing a factory.We want to have a way of object instantiation which would: I believe I have proven that the ways I have mentioned don\'t fulfil those requirements.Any hints? Please provide me with a solution, I don\'t want to think that this language won\'t allow me to properly implement such a trivial concept.First of all, there are cases when\n  object construction is a task complex\n  enough to justify its extraction to\n  another class.I believe this point is incorrect. The complexity doesn\'t really matter. The relevance is what does. If an object can be constructed in one step (not like in the builder pattern), the constructor is the right place to do it. If you really need another class to perform the job, then it should be a helper class that is used from the constructor anyway.There is an easy workaround for this:The only disadvantage is that it looks a bit verbose:But the good thing is that you can immediately see what coordinate type you\'re using, and at the same time you don\'t have to worry about copying. If you want copying, and it\'s expensive (as proven by profiling, of course), you may wish to use something like Qt\'s shared classes to avoid copying overhead.As for the allocation type, the main reason to use the factory pattern is usually polymorphism. Constructors can\'t be virtual, and even if they could, it wouldn\'t make much sense. When using static or stack allocation, you can\'t create objects in a polymorphic way because the compiler needs to know the exact size. So it works only with pointers and references. And returning a reference from a factory doesn\'t work too, because while an object technically can be deleted by reference, it could be rather confusing and bug-prone, see Is the practice of returning a C++ reference variable, evil? for example. So pointers are the only thing that\'s left, and that includes smart pointers too. In other words, factories are most useful when used with dynamic allocation, so you can do things like this:In other cases, factories just help to solve minor problems like those with overloads you have mentioned. It would be nice if it was possible to use them in a uniform way, but it doesn\'t hurt much that it is probably impossible.Have you thought about not using a factory at all, and instead making nice use of the type system? I can think of two different approaches which do this sort of thing:Option 1:Which lets you write things like:Option 2:you can use "tags" like the STL does with iterators and such. For example:This second approach lets you write code which looks like this:which is also nice and expressive while allowing you to have unique prototypes for each constructor.You can read a very good solution in: http://www.codeproject.com/Articles/363338/Factory-Pattern-in-CplusplusThe best solution is on the "comments and discussions", see the "No need for static Create methods".From this idea, I\'ve done a factory. Note that I\'m using Qt, but you can change QMap and QString for std equivalents.Sample usage:Loki has both a Factory Method and an Abstract Factory. Both are documented (extensively) in Modern C++ Design, by Andei Alexandrescu. The factory method is probably closer to what you seem to be after, though it\'s still a bit different (at least if memory serves, it requires you to register a type before the factory can create objects of that type).I mostly agree with the accepted answer, but there is a C++11 option that has not been covered in existing answers:Example:Then you can construct objects on the stack:As subobjects of other things:Or dynamically allocated:When might I use this?If, on a public constructor, it is not possible to give meaningful initialisers for all class members without some preliminary calculation, then I might convert that constructor to a static method. The static method performs the preliminary calculations, then returns a value result via a private constructor which just does a member-wise initialisation.I say \'might\' because it depends on which approach gives the clearest code without being unnecessarily inefficient.I don\'t try to answer all of my questions, as I believe it is too broad. Just a couple of notes:there are cases when object construction is a task complex enough to justify its extraction to another class.That class is in fact a Builder, rather than a Factory.In the general case, I don\'t want to force the users of the factory to be restrained to dynamic allocation.Then you could have your factory encapsulate it in a smart pointer. I believe this way you can have your cake and eat it too.This also eliminates the issues related to return-by-value.Conclusion: Making a factory by returning an object is indeed a solution for some cases (such as the 2-D vector previously mentioned), but still not a general replacement for constructors.Indeed. All design patterns have their (language specific) constraints and drawbacks. It is recommended to use them only when they help you solve your problem, not for their own sake.If you are after the "perfect" factory implementation, well, good luck.Factory PatternAnd if you compiler does not support Return Value Optimization, ditch it, it probably does not contain much optimization at all...I know this question has been answered 3 years ago, but this may be what your were looking for.Google has released a couple of weeks ago a library allowing easy and flexible dynamic object allocations. Here it is: http://google-opensource.blogspot.fr/2014/01/introducing-infact-library.html