I got slightly confused about the differences between Handlers, AsyncTask and Threads in Android. I\'ve read quite a few blogs and questions here in stackoverflow. Handler are background threads that provide you to communicate with the UI. Updating a progressbar for instance should be done via Handler. Using Handlers you have the advantage of MessagingQueues, so if you want to schedule messages or update multiple UI elements or have repeating tasks.AsyncTask are similar, infact they make use of Handler, but doesn\'t run in the UI thread, so it\'s good for fetching data, for instance fetching web services. Later you can interact with the UI.Thread however can\'t interact with the UI, provide more "basic" threading and you miss all the abstractions of AsyncTask.However I would like to have a socket connection run in a service. Should this be run in a handler or a thread, or even an AsyncTask? UI interaction is not necessary at all. Does it make a difference in terms of performance which I use?Meanwhile the documentation has been majorly improved.As the Tutorial on Android background processing with Handlers, AsyncTask and Loaders on the Vogella site puts it:The Handler class can be used to register to a thread and provides a simple channel to send data to this thread.The AsyncTask class encapsulates the creation of a background process and the synchronization with the main thread. It also supports reporting progress of the running tasks.And a Thread is basically the core element of multithreading which a developer can use with the following disadvantage:If you use Java threads you have to handle the following requirements\n  in your own code:And regarding the AsyncTask, as the Android Developer\'s Reference puts it:AsyncTask enables proper and easy use of the UI thread. This class\n  allows to perform background operations and publish results on the UI\n  thread without having to manipulate threads and/or handlers.AsyncTask is designed to be a helper class around Thread and Handler\n  and does not constitute a generic threading framework. AsyncTasks\n  should ideally be used for short operations (a few seconds at the\n  most.) If you need to keep threads running for long periods of time,\n  it is highly recommended you use the various APIs provided by the\n  java.util.concurrent package such as Executor, ThreadPoolExecutor and\n  FutureTask.Update May 2015: I found an excellent series of lectures covering this topic.This is the Google Search: Douglas Schmidt lecture android concurrency and synchronisationThis is the video of the first lecture on YouTubeAll this is part of the CS 282 (2013): Systems Programming for Android from the Vanderbilt University. Here\'s the YouTube PlaylistDouglas Schmidt seems to be an excellent lecturerIf you look at the source code of AsyncTask and Handler, you will see their code is written purely in Java. (Of course, there are some exceptions, but that is not an important point.)So there is no magic in AsyncTask or Handler. They just make your job easier as a developer.For example: If Program A calls method A(), method A() could run in a different thread with Program A.You can easily verify it using:Why you should use a new thread? You can google for it. Many many reasons.So, what is the difference between Thread, AsyncTask, and Handler?AsyncTask and Handler are written in Java (internally they use a Thread), so everything you can do with Handler or AsyncTask, you can achieve using a Thread too.What can Handler and AsyncTask really help you with?The most obvious reason is communication between the caller thread and the worker thread.\n(Caller Thread: A thread which calls the Worker Thread to perform some task. A Caller Thread does not necessarily have to be the UI thread). Of course, you can communicate between two threads in other ways, but there are many disadvantages (and dangers) due to thread safety issues.That is why you should use Handler and AsyncTask. They do most of the work for you, you just need to know what methods to override.The difference between Handler and AsyncTask is: Use AsyncTask when Caller thread is a UI Thread.\nThis is what android document says:AsyncTask enables proper and easy use of the UI thread. This class\n  allows to perform background operations and publish results on the UI\n  thread without having to manipulate threads and/or handlersI want to emphasize on two points:1) Easy use of the UI thread (so, use when caller thread is UI Thread).2) No need to manipulate handlers. (means: You can use Handler instead of AsyncTask, but AsyncTask is an easier option).There are many things in this post I haven\'t said yet, for example: what is UI Thread, or why it\'s easier. You must know some method behind each kind and use it, you will completely understand why..@: when you read the Android document, you will see:  Handler allows you to send and process Message and Runnable objects\n  associated with a thread\'s MessageQueueThey may seem strange at first. Just understand that each thread has each message queue (like a to do list), and the thread will take each message and do it until the message queue is empty (just like you finish your work and go to bed). So, when Handler communicates, it just gives a message to caller thread and it will wait to process. Complicated? Just remember that Handler can communicate with the caller thread in a safe way.After looking in depth, it\'s straight forward.AsyncTask: It\'s a simple way to use a thread without knowing anything about java thread model.\nAsyncTask gives various callbacks respective to the worker thread and main thread.Use for small waiting operations like the following:Handler:When we install an application in android, then it creates a thread  for that application called MAIN UI Thread.  All activities run inside that thread.  By the android single thread model rule, we can not access UI elements (bitmap , textview etc..) directly for another thread defined inside that activity.A Handler allows you communicate back with the UI thread from other background thread. This is useful in android as android doesn\xe2\x80\x99t allow other threads to communicate directly with UI thread. Handler can send and process Message and Runnable objects associated with a thread\xe2\x80\x99s MessageQueue. Each Handler instance is associated with a single thread and that thread\xe2\x80\x99s message queue. When a new Handler is created, it is bound to the thread/message queue of the thread that is creating it.It\'s the best fit for:Thread:Now it\'s time to talk about thread.Thread is the parent of both AsyncTask and Handler. They both internally use thread, which means you can also create your own thread model like AsyncTask and Handler, but that requires a good knowledge of Java\'s Multi-Threading Implementation.An AsyncTask is used to do some background computation and publish the result to the UI thread (with optional progress updates). Since you\'re not concerned with UI, then a Handler or Thread seems more appropriate.You can spawn a background Thread and pass messages back to your main thread by using the  Handler\'s post method.In my opinion threads aren\'t the most efficient way of doing socket connections but they do provide the most functionality in terms of running threads. I say that because from experience, running threads for a long time causes devices to be very hot and resource intensive. Even a simple while(true) will heat a phone in minutes. If you say that UI interaction is not important, perhaps an AsyncTask is good because they are designed for long-term processes. This is just my opinion on it.UPDATEPlease disregard my above answer! I answered this question back in 2011 when I was far less experienced in Android than I am now. My answer above is misleading and is considered wrong. I\'m leaving it there because many people commented on it below correcting me, and I\'ve learned my lesson.There are far better other answers on this thread, but I will at least give me more proper answer. There is nothing wrong with using a regular Java Thread; however, you should really be careful about how you implement it because doing it wrong can be very processor intensive (most notable symptom can be your device heating up). AsyncTasks are pretty ideal for most tasks that you want to run in the background (common examples are disk I/O, network calls, and database calls). However, AsyncTasks shouldn\'t be used for particularly long processes that may need to continue after the user has closed your app or put their device to standby. I would say for most cases, anything that doesn\'t belong in the UI thread, can be taken care of in an AsyncTask.ThreadsAndroid supports standard Java Threads. You can use standard Threads and the tools from the package \xe2\x80\x9cjava.util.concurrent\xe2\x80\x9d to put actions into the background. The only limitation is that you cannot directly update the UI from the a background process.\nIf you need to update the UI from a background task you need to use some Android specific classes. You can use the class \xe2\x80\x9candroid.os.Handler\xe2\x80\x9d for this or the class \xe2\x80\x9cAsyncTasks\xe2\x80\x9dHandlerThe class \xe2\x80\x9cHandler\xe2\x80\x9d can update the UI. A handle provides methods for receiving messages and for runnables. To use a handler you have to subclass it and override handleMessage() to process messages. To process runables you can use the method post(); You only need one instance of a handler in your activity.\nYou thread can post messages via the method sendMessage(Message msg) or sendEmptyMessage. AsyncTaskIf you have an Activity which needs to download content or perform operations that can be done in the background AsyncTask allows you to maintain a responsive user interface and publish progress for those operations to the user.For more information you can have a look on following links.http://mobisys.in/blog/2012/01/android-threads-handlers-and-asynctask-tutorial/http://www.slideshare.net/HoangNgoBuu/android-thread-handler-and-asynctask AsyncTask is designed to perform not more than few seconds operation to be done in background (not recommended for megabytes of file downloading from server or compute cpu intensive task such as file IO operations ). If you need to execute a long running operation,  you have been  strongly advised to use java native threads. Java gives you various thread related classes to do what you need. Use Handler to  update the UI Thread.Let me try and answer the question here with an example :) - MyImageSearch [Kindly refer the image here of the main activity screen - containing an edit text / search button / grid view]Description of MyImageSearch - Once user enters the details on the edit text field and clicks on the search button, we will search images on the internet via the web services provided by flickr (you only need to register there to get a key/secret token) - for searching we send an HTTP Request and GET JSON Data back in response containing the url\'s of individual images which we will then use to load the grid view.My Implementation - In the main activity I will define a inner class which extends the AsyncTask to send the HTTP Request in doInBackGround Method and fetch the JSON Response and update my local ArrayList of FlickrItems which I am going to use to update my GridView via the FlickrAdapter (extends the BaseAdapter) and call the adapter.notifyDataSetChanged() in the onPostExecute() of AsyncTask to reload the grid view. Note that here the HTTP Request is a blocking call because of which I have done it via the AsyncTask. And, I can cache the items in adapter to increase the performance or store them on SDCard. The grid that I will be inflating in the FlickrAdapter contains in my implementation a progressbar and image view. Below you can find the code for mainActivity which I used.Answer to the Question Now - \nSo once we have the JSON data for fetching individual Images we can implement the logic of getting the images in background via Handlers or Threads or AsyncTask. We should note here that since my images once downloaded must be displayed on the UI/main thread we cannot simply use threads as it is since they don\'t have access to the context.\nIn the FlickrAdapter, the choices I could think of:Here the source code:I hope my answer though long will help in understanding some of the finer details.Thread:You can use new Thread for long running background tasks without impacting UI Thread. From java Thread, you can\'t update UI Thread. Since normal Thread is not  much useful for Android architecture, helper classes for threading have been introduced. You can find answers to your queries in Threading performance documentation page.Handler:A Handler allows you to send and process Message and Runnable objects associated with a thread\'s MessageQueue. Each Handler instance is associated with a single thread and that thread\'s message queue.There are two main uses for a Handler:To schedule messages and runnables to be executed as some point in the future; To enqueue an action to be performed on a different thread than your own.AsyncTask:AsyncTask enables proper and easy use of the UI thread. This class allows you to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.Drawbacks:By default, an app pushes all of the AsyncTask objects it creates into a single thread. Therefore, they execute in serial fashion, and\xe2\x80\x94as with the main thread\xe2\x80\x94an especially long work packet can block the queue. Due to this reason,  use AsyncTask to handle work items shorter than 5ms in duration.AsyncTask objects are also the most common offenders for implicit-reference issues. AsyncTask objects present risks related to explicit references, as well.HandlerThread:You may need a more traditional approach to executing a block of work on a longer running thread (unlike AsyncTask, which should be used for 5ms workload) , and some ability to manage that workflow manually.  A handler thread is effectively a long-running thread that grabs work from a queue, and operates on it.ThreadPoolExecutor:This class manages the creation of a group of threads, sets their priorities, and manages how work is distributed among those threads. As workload increases or decreases, the class spins up or destroys more threads to adjust to the workload.If workload is more and single HandlerThread is not suffice, you can go for ThreadPoolExecutor However I would like to have a socket connection run in a service. Should this be run in a handler or a thread, or even an AsyncTask? UI interaction is not necessary at all. Does it make a difference in terms of performance which I use?Since UI interaction is not required, you may not go for AsyncTask. Normal threads are not much useful and hence HandlerThread is best option. Since you have to maintain socket connection, Handler on main thread is not useful at all. Create a HandlerThread and get a Handler from looper of HandlerThread. If you want to communicate back to UI thread, you can use one more Handler to process response. in your Runnable, you can addMore details about implementation can be found here:Android: Toast in a threadHandler - is communication medium between threads. In android it is mostly used to communicate with main thread by creating and sending messages through handlerAsyncTask - is used to perform long running applications in a background thread. With nAsyncTask you get can do the operation in a background thread and get the result in the main thread of the application. Thread - is a light weight process, to achieve concurrency and maximum cpu utilization. In android you can use thread to perform activities which does not touch UI of the app