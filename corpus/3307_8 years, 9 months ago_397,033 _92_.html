What is the difference between Could you give me some examples, please?When a parameter is passed by reference, the caller and the callee use the same variable for the parameter. If the callee modifies the parameter variable, the effect is visible to the caller\'s variable.When a parameter is passed by value, the caller and callee have two independent variables with the same value. If the callee modifies the parameter variable, the effect is not visible to the caller.However, if the value in question is a mutable reference-type object or otherwise indirectly references other values, then you can emulate call-by-reference in a call-by-value environment: if the callee modifies the object (or other values pointed to by the object), those modifications are visible to the caller. But the emulation isn\'t exactly the same, since only modifications to the object, not to the variable, are visible. This leads to contorted explanations like "call by value where the value is a reference". This somewhat confusing state of affairs is how many popular programming languages work today, and therefore people often confuse passing mutable objects by value with call-by-reference.For more explanation, see the other answers below.NOTE: For a long time, this answer used to say:Say I want to share a web page with you. If I tell you the URL, I\'m\n  passing by reference. You can use that URL to see the same web page I\n  can see. If that page is changed, we both see the changes. If you\n  delete the URL, all you\'re doing is destroying your reference to that\n  page - you\'re not deleting the actual page itself.If I print out the page and give you the printout, I\'m passing by\n  value. Your page is a disconnected copy of the original. You won\'t see\n  any subsequent changes, and any changes that you make (e.g. scribbling\n  on your printout) will not show up on the original page. If you\n  destroy the printout, you have actually destroyed your copy of the\n  object - but the original web page remains intact.It\'s a simple analogy that\'s easy to understand, which got this post hundreds of upvotes. However, the analogy is flawed: call-by-reference and call-by-value are not like URLs. (A reference type in a language like C# is like a URL; see Jon Skeet\'s great write-up about reference types in .NET for details. But reference types are not the same thing as pass by reference.)Since this analogy is not actually correct, it\'s been removed from this answer. See also the comments below where this was discussed.It\'s a way how to pass arguments to functions. Passing by reference means the called functions\' parameter will be the same as the callers\' passed argument (not the value, but the identity - the variable itself). Pass by value means the called functions\' parameter will be a copy of the callers\' passed argument. The value will be the same, but the identity - the variable - is different. Thus changes to a parameter done by the called function in one case changes the argument passed and in the other case just changes the value of the parameter in the called function (which is only a copy). In a quick hurry:CodesSince my language is C++, i will use that hereAnd an example in Java won\'t hurt:Wikipediahttp://en.wikipedia.org/wiki/Pass_by_reference#Call_by_valuehttp://en.wikipedia.org/wiki/Pass_by_reference#Call_by_referenceThis guy pretty much nails it:http://javadude.com/articles/passbyvalue.htmHere is an example:Many answers here (and in particular the most highly upvoted answer) are factually incorrect, since they misunderstand what "call by reference" really means. Here\'s my attempt to set matters straight.In simplest terms:In metaphoric terms:Note that both of these concepts are completely independent and orthogonal from the concept of reference types (which in Java is all types that are subtypes of Object, and in C# all class types), or the concept of pointer types like in C (which are semantically equivalent to Java\'s "reference types", simply with different syntax).The notion of reference type corresponds to a URL: it is both itself a piece of information, and it is a reference (a pointer, if you will) to other information. You can have many copies of a URL in different places, and they don\'t change what website they all link to; if the website is updated then every URL copy will still lead to the updated information. Conversely, changing the URL in any one place won\'t affect any other written copy of the URL.Note that C++ has a notion of "references" (e.g. int&) that is not like Java and C#\'s "reference types", but is like "call by reference". Java and C#\'s "reference types", and all types in Python, are like what C and C++ call "pointer types" (e.g. int*).OK, here\'s the longer and more formal explanation.To start with, I want to highlight some important bits of terminology, to help clarify my answer and to ensure we\'re all referring to the same ideas when we are using words. (In practice, I believe the vast majority of confusion about topics such as these stems from using words in ways that to not fully communicate the meaning that was intended.)To start, here\'s an example in some C-like language of a function declaration:And here\'s an example of calling this function:Using this example, I want to define some important bits of terminology:There are two very important sets of concepts to distinguish here. The first is value versus variable:The other important pair of concepts to distinguish is parameter versus argument:In call by value, the function\'s formal parameters are variables that are newly created for the function invocation, and which are initialized with the values of their arguments.This works exactly the same way that any other kinds of variables are initialized with values. For example:Here arg and another_variable are completely independent variables -- their values can change independently of each other. However, at the point where another_variable is declared, it is initialized to hold the same value that arg holds -- which is 1.Since they are independent variables, changes to another_variable do not affect arg:This is exactly the same as the relationship between arg and param in our example above, which I\'ll repeat here for symmetry:It is exactly as if we had written the code this way:That is, the defining characteristic of what call by value means is that the callee (foo in this case) receives values as arguments, but has its own separate variables for those values from the variables of the caller (bar in this case).Going back to my metaphor above, if I\'m bar and you\'re foo, when I call you, I hand you a piece of paper with a value written on it. You call that piece of paper param. That value is a copy of the value I have written in my notebook (my local variables), in a variable I call arg.(As an aside: depending on hardware and operating system, there are various calling conventions about how you call one function from another. The calling convention is like us deciding whether I write the value on a piece of my paper and then hand it to you, or if you have a piece of paper that I write it on, or if I write it on the wall in front of both of us. This is an interesting subject as well, but far beyond the scope of this already long answer.)In call by reference, the function\'s formal parameters are simply new names for the same variables that the caller supplies as arguments.Going back to our example above, it\'s equivalent to:Since param is just another name for arg -- that is, they are the same variable, changes to param are reflected in arg. This is the fundamental way in which call by reference differs from call by value.Very few languages support call by reference, but C++ can do it like this:In this case, param doesn\'t just have the same value as arg, it actually is arg (just by a different name) and so bar can observe that arg has been incremented.Note that this is not how any of Java, JavaScript, C, Objective-C, Python, or nearly any other popular language today works. This means that those languages are not call by reference, they are call by value.If what you have is call by value, but the actual value is a reference type or pointer type, then the "value" itself isn\'t very interesting (e.g. in C it\'s just an integer of a platform-specific size) -- what\'s interesting is what that value points to.If what that reference type (that is, pointer) points to is mutable then an interesting effect is possible: you can modify the pointed-to value, and the caller can observe changes to the pointed-to value, even though the caller cannot observe changes to the pointer itself.To borrow the analogy of the URL again, the fact that I gave you a copy of the URL to a website is not particularly interesting if the thing we both care about is the website, not the URL. The fact that you scribbling over your copy of the URL doesn\'t affect my copy of the URL isn\'t a thing we care about (and in fact, in languages like Java and Python the "URL", or reference type value, can\'t be modified at all, only the thing pointed to by it can).Barbara Liskov, when she invented the CLU programming language (which had these semantics), realized that the existing terms "call by value" and "call by reference" weren\'t particularly useful for describing the semantics of this new language. So she invented a new term: call by object sharing.When discussing languages that are technically call by value, but where common types in use are reference or pointer types (that is: nearly every modern imperative, object-oriented, or multi-paradigm programming language), I find it\'s a lot less confusing to simply avoid talking about call by value or call by reference. Stick to call by object sharing (or simply call by object) and nobody will be confused. :-)Comparing: Value vs. ReferencePass By Value\nThe local parameters are copies of the original arguments passed in\nChanges made in the function to these variables do not affect originalsPass By Reference\nThe local parameters are references to the storage locations of the original arguments passed in.\nChanges to these variables in the function will affect the originals\nNo copy is made, so overhead of copying (time, storage) is savedWhen passing by ref you are basically passing a pointer to the variable. Pass by value you are passing a copy of the variable.  In basic usage this normally means pass by ref changes to the variable will seen be the calling method and pass by value they wont.The simplest way to get this is on an Excel file. Let\xe2\x80\x99s say for example that you have two numbers, 5 and 2 in cells A1 and B1 accordingly, and you want to find their sum in a third cell, let\'s say A2. \nYou can do this in two ways.Either by passing their values to cell A2 by typing = 5 + 2 into this cell. In this case, if the values of the cells A1 or B1 change, the sum in A2 remains the same.Or by passing the \xe2\x80\x9creferences\xe2\x80\x9d of the cells A1 and B1 to cell A2 by typing = A1 + B1. In this case, if the values of the cells A1 or B1 change, the sum in A2 changes too.Before understanding the 2 terms, you MUST understand the following. Every object, has 2 things that can make it be distinguished.So if you say Employee.name = Johnknow that there are 2 things about name. Its value which is John and also its location in the memory which is some hexadecimal number maybe like  this: 0x7fd5d258dd00. So depending on the language\'s architecture you could be transferring John or 0x7fd5d258dd00Passing John is considered as passing by value.\nPassing 0x7fd5d258dd00 is considered as passing by reference. Anyone who is pointing to this memory location will also be pointing to the value of John.Pass by value sends a COPY of the data stored in the variable you specify, pass by reference sends a direct link to the variable itself. So if you pass a variable by reference and then change the variable inside the block you passed it into, the original variable will be changed. If you simply pass by value, the original variable will not be able to be changed by the block you passed it into but you will get a copy of whatever it contained at the time of the call.Pass by value - The function copies the variable and works with a copy(so it doesn\'t change anything in the original variable)Pass by reference - The function uses the original variable, if you change the variable in the other function, it changes in the original variable too.Example(copy and use/try this yourself and see) :Keep it simple, peeps. Walls of text can be a bad habit.A major difference between them is that value-type variables store values, so specifying a value-type variable in a method call passes a copy of that variable\'s value to the method. Reference-type variables store references to objects, so specifying a reference-type variable as an argument passes the method a copy of the actual reference that refers to the object. Even though the reference itself is passed by value, the method can still use the reference it receives to interact with\xe2\x80\x94and possibly modify\xe2\x80\x94the original object. Similarly, when returning information from a method via a return statement, the method returns a copy of the value stored in a value-type variable or a copy of the reference stored in a reference-type variable. When a reference is returned, the calling method can use that reference to interact with the referenced object. So, in effect, objects are always passed by reference.In c#, to pass a variable by reference so the called method can modify the variable\'s, C# provides keywords ref and out. Applying the ref keyword to a parameter declaration allows you to pass a variable to a method by reference\xe2\x80\x94the called method will be able to modify the original variable in the caller. The ref keyword is used for variables that already have been initialized in the calling method. Normally, when a method call contains an uninitialized variable as an argument, the compiler generates an error. Preceding a parameter with keyword out creates an output parameter. This indicates to the compiler that the argument will be passed into the called method by reference and that the called method will assign a value to the original variable in the caller. If the method does not assign a value to the output parameter in every possible path of execution, the compiler generates an error. This also prevents the compiler from generating an error message for an uninitialized variable that is passed as an argument to a method. A method can return only one value to its caller via a return statement, but can return many values by specifying multiple output (ref and/or out) parameters.see c# discussion and examples here link textIn short, Passed by value is WHAT it is and passed by reference is WHERE it is.If your value is VAR1 = "Happy Guy!", you will only see "Happy Guy!". If VAR1 changes to "Happy Gal!", you won\'t know that. If it\'s passed by reference, and VAR1 changes, you will.By definition, pass by value means you are making a copy in memory of the actual parameter\'s value that is passed in, a copy of the contents of the actual parameter. Use pass by value when when you are only "using" the parameter for some computation, not changing it for the client program. In pass by reference (also called pass by address), a copy of the address of the actual parameter is stored. Use pass by reference when you are changing the parameter passed in by the client program. pass by value means how to pass value to a function by making use of arguments. in pass by value we copy the data stored in the variable we specify and it is slower than pass by reference bcse t\nhe data is copied . of we make changes in the copied data the original data is not affected. nd in pass by refernce or pass by address we send direct link to the variable itself . or passing pointer to a variable. it is faster bcse less time is consumed If you don\'t want to change the value of the original variable after passing it into a function, the function should be constructed with a "pass by value" parameter. Then the function will have ONLY the value but not the address of the passed in variable.  Without the variable\'s address, the code inside the function cannot change the variable value as seen from the outside of the function.  But if you want to give the function the *ability to change the value of the variabl*e as seen from the outside, you need to use pass by reference.  As both the value and the address (reference) are passed in and available inside the function. Examples:const & is generally best. You don\'t incur the construction and destruction penalty. If the reference isn\'t const your interface is suggesting that it will change the passed in data.\nHere is an example that demonstrates the differences between pass by value - pointer value - reference:The \xe2\x80\x9cpassing by reference\xe2\x80\x9d method has an important limitation. If a parameter is declared as passed by reference (so it is preceded by the & sign) its corresponding actual parameter must be a variable.An actual parameter referring to \xe2\x80\x9cpassed by value\xe2\x80\x9d formal parameter may be an expression in general, so it is allowed to use not only a variable but also a literal or even a function invocation\'s result.The function is not able to place a value in something other than a variable. It cannot assign a new value to a literal or force an expression to change its result.PS: You can also check Dylan Beattie answer in the current thread that explains it in plain words.By value: when arguments are passed by value to a method, it means that a copy of the actual variable is being sent to the method and not the actual one, so any changes applied inside the method are actually affecting the copy version.By reference: When arguments are passed by reference, it means that a reference or a pointer to the actual variable is being passed to the method and not the actual variable data.Check this article for further examples.