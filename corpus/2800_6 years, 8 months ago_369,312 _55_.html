I want to do a Full Outer Join in MySQL. Is this possible? Is a Full Outer Join supported by MySQL?You don\'t have FULL JOINS on MySQL, but you can sure emulate them.For a code SAMPLE transcribed from this SO question you have:with two tables t1, t2:The answer that Pablo Santa Cruz gave is correct; however, in case anybody stumbled on this page and wants more clarification, here is a detailed breakdown.Suppose we have the following tables:An inner join, like this:Would get us only records that appear in both tables, like this:Inner joins don\'t have a direction (like left or right) because they are explicitly bidirectional - we require a match on both sides.Outer joins, on the other hand, are for finding records that may not have a match in the other table. As such, you have to specify which side of the join is allowed to have a missing record.LEFT JOIN and RIGHT JOIN are shorthand for LEFT OUTER JOIN and RIGHT OUTER JOIN; I will use their full names below to reinforce the concept of outer joins vs inner joins.A left outer join, like this:...would get us all the records from the left table regardless of whether or not they have a match in the right table, like this:A right outer join, like this:...would get us all the records from the right table regardless of whether or not they have a match in the left table, like this:A full outer join would give us all records from both tables, whether or not they have a match in the other table, with NULLs on both sides where there is no match. The result would look like this:However, as Pablo Santa Cruz pointed out, MySQL doesn\'t support this. We can emulate it by doing a UNION of a left join and a right join, like this:You can think of a UNION as meaning "run both of these queries, then stack the results on top of each other"; some of the rows will come from the first query and some from the second.It should be noted that a UNION in MySQL will eliminate exact duplicates: Tim would appear in both of the queries here, but the result of the UNION only lists him once. My database guru colleague feels that this behavior should not be relied upon. So to be more explicit about it, we could add a WHERE clause to the second query:On the other hand, if you wanted to see duplicates for some reason, you could use UNION ALL.Using a union query will remove duplicates, and this is different than the behavior of full outer join that never removes any duplicate:This is the expected result of full outer join:This is the result of using left and right Join with union:[SQL Fiddle]My suggested query is:Result of above query that is as same as expected result:[SQL Fiddle]@Steve Chambers: [From comments, with many thanks!]\n  Note: This may be the best solution, both for efficiency and for generating the same results as a FULL OUTER JOIN. This blog post also explains it well - to quote from Method 2: "This handles duplicate rows correctly and doesn\xe2\x80\x99t include anything it shouldn\xe2\x80\x99t. It\xe2\x80\x99s necessary to use UNION ALL instead of plain UNION, which would eliminate the duplicates I want to keep. This may be significantly more efficient on large result sets, since there\xe2\x80\x99s no need to sort and remove duplicates."I decided to add another solution that comes from full outer join visualization and math, it is not better that above but more readable:  Full outer join means (t1 \xe2\x88\xaa t2): all in t1 or in t2\n  (t1 \xe2\x88\xaa t2) = (t1 \xe2\x88\xa9 t2) + t1_only + t2_only: all in both t1 and t2 plus all in t1 that aren\'t in t2 and plus all in t2 that aren\'t in t1:[SQL Fiddle]In SQLite you should do this:Modified shA.t\'s query for more clarity:None of the above answers are actually correct, because they do not follow the semantics when there are duplicated values.For a query such as (from this duplicate):The correct equivalent is:If you need for this to work with NULL values (which may also be necessary), then use the NULL-safe comparison operator, <=> rather than =.what\'d you say about this solution?It is also possible, but you have to mention the same field names in select. Mysql as such does not support any command named FULL OUTER JOIN. The three joins supported are INNER JOIN,LEFT JOIN & RIGHT JOIN.   You can however implement full outer join by using the Command UNION as\n(left join query) UNION (right join query)For instance, consider the following example where I have two tables students and marks. To perform full outer join, I would execute the following code:I fix the response, and works include all rows (based on response of Pavle Lekic)Answer:Can be recreated as follows:Using a UNION or UNION ALL answer does not cover the edge case where the base tables have duplicated entries.Explanation:There is an edge case that a UNION or UNION ALL cannot cover. We cannot test this on mysql as it doesn\'t support FULL OUTER JOINs, but we can illustrate this on a database that does support it:The UNION solution:Gives an incorrect answer:The UNION ALL solution: Is also incorrect.Whereas this query:Gives the following:The order is different, but otherwise matches the correct answer.