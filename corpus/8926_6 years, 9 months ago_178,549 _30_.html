Is ob_start() used for output buffering so that the headers are buffered and not sent to the browser? Am I making sense here? If not then why should we use ob_start()?Think of ob_start() as saying "Start remembering everything that would normally be outputted, but don\'t quite do anything with it yet."For example:There are two other functions you typically pair it with: ob_get_contents(), which basically gives you whatever has been "saved" to the buffer since it was turned on with ob_start(), and then ob_end_clean() or ob_flush(), which either stops saving things and discards whatever was saved, or stops saving and outputs it all at once, respectively.I use this so I can break out of PHP with a lot of HTML but not render it. It saves me from storing it as a string which disables color-coding.Instead of:The accepted answer here describes what ob_start() does - not why it is used (which was the question asked).As stated elsewhere ob_start() creates a buffer which output is written to. But nobody has mentioned that it is possible to stack multiple buffers within PHP. See ob_get_level().As to the why....Sending HTML to the browser in larger chunks gives a performance benefit from a reduced network overhead.Passing the data out of PHP in larger chunks gives a performance and capacity benefit by reducing the number of context switches requiredPassing larger chunks of data to mod_gzip/mod_deflate gives a performance benefit in that the compression can be more efficient.buffering the output means that you can still manipulate the HTTP headers later in the codeexplicitly flushing the buffer after outputting the [head]....[/head] can allow the browser to begin marshaling other resources for the page before HTML stream completes.Capturing the output in a buffer means that it can redirected to other functions such as email, or copied to a file as a cached representation of the contentYou have it backwards. ob_start does not buffer the headers, it buffers the content.  Using ob_start allows you to keep the content in a server-side buffer until you are ready to display it.This is commonly used to so that pages can send headers \'after\' they\'ve \'sent\' some content already (ie, deciding to redirect half way through rendering a page).this is to further clarify JD Isaaks answer ... The problem  you run into often is that you are using php to output html from many different php sources, and those sources are often, for whatever reason, outputting via different ways. Sometimes you have literal html content that you want to directly output to the browser; other times the output is being dynamically created (server-side). The dynamic content is always(?) going to be a string. Now you have to combine this stringified dynamic html with any literal, direct-to-display html ... into one meaningful html node structure.This usually forces the developer to wrap all that direct-to-display content into a string (as JD Isaak was discussing) so that it can be properly delivered/inserted in conjunction with the dynamic html ... even though you don\'t really want it wrapped. But by using ob_## methods you can avoid that string-wrapping mess. The literal content is, instead, output to the buffer. Then in one easy step the entire contents of the buffer (all your literal html), is concatenated into your dynamic-html string. (My example shows literal html being output to the buffer, which is then added to a html-string ... look also at JD Isaaks example to see string-wrapping-of-html).I prefer:This function isn\'t just for headers. You can do a lot of interesting stuff with this. Example: You could split your page into sections and use it like this:You can capture the output that is generated here and add it at two totally different places in your layout.No, you are wrong, but the direction fits ;)The Output-Buffering buffers the output of a script. Thats (in short) everthing after echo or print. The thing with the headers is, that they only can get sent, if they are not already sent. But HTTP says, that headers are the very first of the transmission. So if you output something for the first time (in a request) the headers are sent and you can not set any other headers.