How should I parse JSON using Node.js? Is there some module which will validate and parse JSON securely?You can simply use JSON.parse. node.js is built on V8, which provides the global object JSON[docs]. The definition of the JSON object is part of the ECMAScript 5 specification.Note - JSON.parse can tie up the current thread because it is a synchronous method. So if you are planning to parse big JSON objects use a streaming json parser.you can require .json files.For example if you have a config.json file in the same directory as your source code file you would use:or (file extension can be omitted):note that require is synchronous and only reads the file once, following calls return the result from cacheAlso note You should only use this for local files under your absolute control, as it potentially executes any code within the file.You can use JSON.parse().You should be able to use the JSON object on any ECMAScript 5 compatible JavaScript implementation. And V8, upon which Node.js is built is one of them.You\'ll have to do some file operations with fs module.You can sometimes use require:But, I do not recommend this for several reasons:Seriously! Use JSON.parse.If you are reading large number of .json files, (and if you are extremely lazy), it becomes annoying to write boilerplate code every time. You can save some characters by using the jsonfile module.If the JSON content is streamed over the network, you need to use a streaming JSON parser. Otherwise it will tie up your processor and choke your event loop until JSON content is fully streamed.There are plenty of packages available in NPM for this. Choose what\'s best for you.If you are unsure if whatever that is passed to JSON.parse() is valid JSON, make sure to enclose the call to JSON.parse() inside a try/catch block. A user provided JSON string could crash your application, and could even lead to security holes. Make sure error handling is done if you parse externally-provided JSON.use the JSON object:Another example of JSON.parse :I\'d like to mention that there are alternatives to the global JSON object.\nJSON.parse and JSON.stringify are both synchronous, so if you want to deal with big objects you might want to check out some of the asynchronous JSON modules.Have a look: https://github.com/joyent/node/wiki/Modules#wiki-parsers-jsonInclude the node-fs library.For more info on \'fs\' library , refer the documentation at http://nodejs.org/api/fs.htmlSince you don\'t know that your string is actually valid, I would put it first into a try catch. Also since try catch blocks are not optimized by node, i would put the entire thing into another function:OR in "async style"Parsing a JSON stream? Use JSONStream.https://github.com/dominictarr/JSONStreamThat\'s all.as other answers here have mentioned, you probably want to either require a local json file that you know is safe and present, like a configuration file:or to use the global JSON object to parse a string value into an object:note that when you require a file the content of that file is evaluated, which introduces a security risk in case it\'s not a json file but a js file.here, i\'ve published a demo where you can see both methods and play with them online (the parsing example is in app.js file - then click on the run button and see the result in the terminal):\nhttp://staging1.codefresh.io/labs/api/env/json-parse-exampleyou can modify the code and see the impact...Everybody here has told about JSON.parse, so I thought of saying something else. There is a great module Connect with many middleware to make development of apps easier and better. One of the middleware is bodyParser. It parses JSON, html-forms and etc. There is also a specific middleware for JSON parsing only noop. Take a look at the links above, it might be really helpful to you. My solution:Just to make this as complicated as possible, and bring in as many packages as possible...This lets you do:Or if you\'re using async/await:The advantage over just using readFileSync is that your Node server can process other requests while the file is being read off disk.JSON.parse will not ensure safety of json string you are parsing. You should look at a library like json-safe-parse or a similar library.From json-safe-parse npm page: JSON.parse is great, but it has one serious flaw in the context of JavaScript: it allows you to override inherited properties. This can become an issue if you are parsing JSON from an untrusted source (eg: a user), and calling functions on it you would expect to exist.Leverage Lodash\'s attempt function to return an error object, which you can handle with the isError function.Always be sure to use JSON.parse in try catch block as node always throw an Unexpected Error  if you have some corrupted data in your json so use this code instead of simple JSON.ParseJust want to complete the answer (as I struggled with it for a while), want to show how to access the json information, this example shows accessing Json Array:If you want to add some comments in your JSON and allow trailing commas you might want use below implemention:Note that it might not work well if you have something like "abc": "foo // bar" in your JSON. So YMMV.Using JSON for your configuration with Node.js? Read this and get your configuration skills over 9000...Note: People claiming that data = require(\'./data.json\'); is a\n  security risk and downvoting people\'s answers with zealous zeal: You\'re exactly and completely wrong.\n  Try placing non-JSON in that file... Node will give you an error, exactly like it would if you did the same thing with the much slower and harder to code manual file read and then subsequent JSON.parse().  Please stop spreading misinformation; you\'re hurting the world, not helping.  Node was designed to allow this; it is not a security risk!Proper applications come in 3+ layers of configuration:Most developers treat their server and app config as if it can change.  It can\'t.  You can layer changes from higher layers on top of each other, but you\'re modifying base requirements. Some things need to exist!  Make your config act like it\'s immutable, because some of it basically is, just like your source code.Failing to see that lots of your stuff isn\'t going to change after startup leads to anti-patterns like littering your config loading with try/catch blocks, and pretending you can continue without your properly setup application.  You can\'t. If you can, that belongs in the community/user config layer, not the server/app config layer.  You\'re just doing it wrong.  The optional stuff should be layered on top when the application finishes it\'s bootstrap.Stop banging your head against the wall: Your config should be ultra simple.Take a look at how easy it is to setup something as complex as a protocol-agnostic and datasource-agnostic service framework using a simple json config file and simple app.js file...container-config.js...index.js... (the engine that powers everything)app.js... (the code that powers your protocol-agnostic and data-source agnostic service)Using this pattern, you can now load community and user config stuff on top of your booted app, dev ops is ready to shove your work into a container and scale it.  You\'re read for multitenant.  Userland is isolated.  You can now separate the concerns of which service protocol you\'re using, which database type you\'re using, and just focus on writing good code.Because you\'re using layers, you can rely on a single source of truth for everything, at any time (the layered config object), and avoid error checks at every step, worrying about "oh crap, how am I going to make this work without proper config?!?".This had to be shouted at me: it only works for .json files.If the file ending is different this does not work!It\'s simple, you can convert JSON to string using JSON.stringify(json_obj), and convert string to JSON using JSON.parse("your json string").