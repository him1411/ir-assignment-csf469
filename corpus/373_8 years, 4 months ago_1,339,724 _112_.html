I have this string stored in a variable:Now I would like to split the strings by ; delimiter so that I have:I don\'t necessarily need the ADDR1 and ADDR2 variables. If they are elements of an array that\'s even better.After suggestions from the answers below, I ended up with the following which is what I was after:Output:There was a solution involving setting Internal_field_separator (IFS) to ;. I am not sure what happened with that answer, how do you reset IFS back to default?RE: IFS solution, I tried this and it works, I keep the old IFS and then restore it:BTW, when I tried I only got the first string when printing it in loop, without brackets around $IN it works.You can set the internal field separator (IFS) variable, and then let it parse into an array. When this happens in a command, then the assignment to IFS only takes place to that single command\'s environment (to read ). It then parses the input according to the IFS variable value into an array, which we can then iterate over.It will parse one line of items separated by ;, pushing it into an array. Stuff for processing whole of $IN, each time one line of input separated by ;:Taken from Bash shell script split array:Explanation:This construction replaces all occurrences of \';\' (the initial // means global replace) in the string IN with \' \' (a single space), then interprets the space-delimited string as an array (that\'s what the surrounding parentheses do). The syntax used inside of the curly braces to replace each \';\' character with a \' \' character is called Parameter Expansion.There are some common gotchas:If you don\'t mind processing them immediately, I like to do this:You could use this kind of loop to initialize an array, but there\'s probably an easier way to do it. Hope this helps, though.To this SO question, there is already a lot of different way to do this in bash.\nBut bash has many special features, so called bashism that work well, but that won\'t work in any other shell.\nIn particular, arrays, associative array, and pattern  substitution are pure bashisms and may not work under other shells.On my Debian GNU/Linux, there is a standard shell called dash, but I know many people who like to use ksh.Finally, in very small situation, there is a special tool called busybox with his own shell interpreter (ash).The string sample in SO question is:As this could be usefull with whitespaces and as whitespaces could modify the result of the routine, I prefer to use this sample string:Under pure bash, we may use arrays and IFS:Using this syntaxe under recent bash don\'t change $IFS for current session, but only for the current command:Now the string var is splitted and stored into an array (named fields):This is the quickiest way to do this because there is no forks and no external ressource called.From there, you could use the syntax you already know for processing each field;or drop each field after processing (I like this shifting approach):or even for simple printout (shorter syntaxe):But if you would write something useable under many shells, you have to not use bashisms.There is a syntax, used in many shells, for splitting a string accros first or last occurence of a substring:( The missing of this is the main reason of my answer publication ;)This little sample script work well under bash, dash, ksh, busybox and was tested under Mac-OS\'s bash too:Have fun!How about this approach:SourceThis also works:Be careful, this solution is not always correct. In case you pass "bla@some.com" only, it will assign it to both ADD1 and ADD2.I\'ve seen a couple of answers referencing the cut command, but they\'ve all been deleted.  It\'s a little odd that nobody has elaborated on that, because I think it\'s one of the more useful commands for doing this type of thing, especially for parsing delimited log files.In the case of splitting this specific example into a bash script array, tr is probably more efficient, but cut can be used, and is more effective if you want to pull specific fields from the middle.Example:You can obviously put that into a loop, and iterate the -f parameter to pull each field independently.This gets more useful when you have a delimited log file with rows like this:cut is very handy to be able to cat this file and select a particular field for further processing.This worked for me:I think AWK is the best and efficient command to resolve your problem. AWK is included in Bash by default in almost every Linux distribution.will giveOf course your can store each email address by redefining the awk print field.A different take on Darron\'s answer, this is how I do it:In Bash, a bullet proof way, that will work even if your variable contains newlines:Look:The trick for this to work is to use the -d option of read (delimiter) with an empty delimiter, so that read is forced to read everything it\'s fed. And we feed read with exactly the content of the variable in, with no trailing newline thanks to printf. Note that\'s we\'re also putting the delimiter in printf to ensure that the string passed to read has a trailing delimiter. Without it, read would trim potential trailing empty fields:the trailing empty field is preserved.Since Bash 4.4, the builtin mapfile (aka readarray) supports the -d option to specify a delimiter. Hence another canonical way is:How about this one liner, if you\'re not using arrays:Here is a clean 3-liner:where IFS delimit words based on the separator and () is used to create an array. Then [@] is used to return each item as a separate word.If you\'ve any code after that, you also need to restore $IFS, e.g. unset IFS.Without setting the IFSIf you just have one colon you can do that:you will get:There is a simple and smart way like this:But you must use gnu xargs, BSD xargs cant support -d delim.  If you use apple mac like me.  You can install gnu xargs :thenThis is the simplest way to do it.If no space, Why not this?OutputSystem : Ubuntu 12.04.1There are some cool answers here (errator esp.), but for something analogous to split in other languages -- which is what I took the original question to mean -- I settled on this:Now ${a[0]}, ${a[1]}, etc, are as you would expect. Use ${#a[*]} for number of terms. Or to iterate, of course: IMPORTANT NOTE: This works in cases where there are no spaces to worry about, which solved my problem, but may not solve yours. Go with the $IFS solution(s) in that case. The following Bash/zsh function splits its first argument on the delimiter given by the second argument:For instance, the commandyieldsThis output may, for instance, be piped to other commands. Example:Compared to the other solutions given, this one has the following advantages:IFS is not overriden: Due to dynamic scoping of even local variables, overriding IFS over a loop causes the new value to leak into function calls performed from within the loop.Arrays are not used: Reading a string into an array using read requires the flag -a in Bash and -A in zsh.If desired, the function may be put into a script as follows:Two bourne-ish alternatives where neither require bash arrays:Case 1: Keep it nice and simple: Use a NewLine as the Record-Separator... eg.Note: in this first case no sub-process is forked to assist with list manipulation.Idea: Maybe it is worth using NL extensively internally, and only converting to a different RS when generating the final result externally.Case 2: Using a ";" as a record separator... eg.In both cases a sub-list can be composed within the loop is persistent after the loop has completed.  This is useful when manipulating lists in memory, instead storing lists in files. {p.s. keep calm and carry on B-) }Apart from the fantastic answers that were already provided, if it is just a matter of printing out the data you may consider using awk:This sets the field separator to ;, so that it can loop through the fields with a for loop and print accordingly.With another input:In Android shell, most of the proposed methods just do not work:What does work is:where // means global replacement.Use the set built-in to load up the $@ array:Then, let the party begin:A one-liner to split a string separated by \';\' into an array is:This only sets IFS in a subshell, so you don\'t have to worry about saving and restoring its value.Output:Explanation: Simple assignment using parenthesis () converts semicolon separated list into an array provided you have correct IFS while doing that. Standard FOR loop handles individual items in that array as usual.\nNotice that the list given for IN variable must be "hard" quoted, that is, with single ticks. IFS must be saved and restored since Bash does not treat an assignment the same way as a command. An alternate workaround is to wrap the assignment inside a function and call that function with a modified IFS. In that case separate saving/restoring of IFS is not needed. Thanks for "Bize" for pointing that out.Maybe not the most elegant solution, but works with * and spaces:OutputsOther example (delimiters at beginning and end):Basically it removes every character other than ; making delims eg. ;;;. Then it does for loop from 1 to number-of-delimiters as counted by ${#delims}. The final step is to safely get the $ith part using cut.Okay guys!Here\'s my answer!Why this approach is "the best" for me?Because of two reasons:[]\'sYou may also: