What is meant by nvarchar?What is the difference between char, nchar, varchar, and nvarchar in SQL Server?Just to clear up... or sum up...nchar and nvarchar will take up twice as much storage space, so it may be wise to use them only if you need Unicode support.All the answers so far indicate that varchar is single byte, nvarchar  is double byte. The first part of this actually depends on collation as illustrated below.ReturnsNote that the \xe5\x8d\x8e and \xe5\x9b\xbd characters were still not represented in the VARCHAR version and were silently replaced with ?.There are actually still no Chinese characters that can be reprsented by a single byte in that collation. The only single byte characters are the typical western ASCII set.Because of this it is possible for an insert from a nvarchar(X) column to a varchar(X) column to fail with a truncation error (where X denotes a number that is the same in both instances).SQL Server 2012 adds SC (Supplementary Character) collations that support UTF-16. In these collations a single nvarchar character may take 2 or 4 bytes.nchar and char pretty much operate in exactly the same way as each other, as do nvarchar and varchar. The only difference between them is that nchar/nvarchar store Unicode characters (essential if you require the use of extended character sets) whilst varchar does not.Because Unicode characters require more storage, nchar/nvarchar fields take up twice as much space (so for example in earlier versions of SQL Server the maximum size of an nvarchar field is 4000).This question is a duplicate of this one.Just to add something more:\nnchar - adds trailing spaces to the data.\nnvarchar - does not add trailing spaces to the data.So, if you are going to filter your dataset by an \'nchar\' field, you may want to use RTRIM to remove the spaces.\nE.g.\nnchar(10) field called BRAND stores the word NIKE.\nIt adds 6 spaces to the right of the word.\nSo, when filtering, the expression should read:\nRTRIM(Fields!BRAND.Value) = "NIKE"Hope this helps someone out there because I was struggling with it for a bit just now!My attempt to summarize and correct the existing answers:First, char and nchar will always use a fixed amount of storage space, even when the string to be stored is smaller than the available space, whereas varchar and nvarchar will use only as much storage space as is needed to store that string (plus two bytes of overhead, presumably to store the string length). So remember, "var" means "variable", as in variable space.The second major point to understand is that, nchar and nvarchar store strings using exactly two bytes per character, whereas char and varchar use an encoding determined by the collation code page, which will usually be exactly one byte per character (though there are exceptions, see below). By using two bytes per character, a very wide range of characters can be stored, so the basic thing to remember here is that nchar and nvarchar tend to be a much better choice when you want internationalization support, which you probably do.Now for some some finer points.First, nchar and nvarchar columns always store data using UCS-2. This means that exactly two bytes per character will be used, and any Unicode character in the Basic Multilingual Plane (BMP) can be stored by an nchar or nvarchar field. However, it is not the case that any Unicode character can be stored. For example, according to Wikipedia, the code points for Egyptian hieroglyphs fall outside of the BMP. There are, therefore, Unicode strings that can be represented in UTF-8 and other true Unicode encodings that cannot be stored in a SQL Server nchar or nvarchar field, and strings written in Egyptian hieroglyphs would be among them. Fortunately your users probably don\'t write in that script, but it\'s something to keep in mind!Another confusing but interesting point that other posters have highlighted is that char and varchar fields may use two bytes per character for certain characters if the collation code page requires it. (Martin Smith gives an excellent example in which he shows how Chinese_Traditional_Stroke_Order_100_CS_AS_KS_WS exhibits this behavior. Check it out.)UPDATE: As of SQL Server 2012, there are finally code pages for UTF-16, for example Latin1_General_100_CI_AS_SC, which can truly cover the entire Unicode range.The differences are: Another difference is length. Both nchar and nvarchar can be up to 4,000 characters long. And char and varchar can be up to 8000 characters long. But for SQL Server you can also use a [n]varchar(max) which can handle up to 2,147,483,648 characters. (Two gigabytes, a signed 4-byte integer.)nchar requires more space than nvarchar.eg,A char(100) will always store 100 characters even if you only enter 5, the\nremaining 95 chars will be padded with spaces.\nStoring 5 characters in a varchar(100)  will save 5 characters.by,Sunil.M.Lnchar[(n)]   (national character)nvarchar [(n | max)] (national character varying.)char [(n)] (character)varchar [(n | max)] (character varying)nchar(10) is a fixed-length Unicode string of length 10. nvarchar(10) is a variable-length Unicode string with a maximum length of 10. Typically, you would use the former if all data values are 10 characters and the latter if the lengths vary.nchar is fixed-length and can hold unicode characters. it uses two bytes storage per character.varchar is of variable length and cannot hold unicode characters. it uses one byte storage per character.NVARCHAR can store Unicode characters and takes 2 bytes per character.Differences between CHAR, NCHAR, VARCHAR and NVARCHAR?CHAR:char [ ( n ) ]Example:Output:  hWe got h as output. Because we didn\'t specified any length for char. It will take default length as 1.VARCHAR:varchar [ ( n | max ) ]NCHAR:nchar [ ( n ) ]NVARCHAR:nvarchar [ ( n | max ) ]Read more on "Differences between CHAR, NCHAR, VARCHAR and NVARCHAR?" with examples here.