Java has a logical AND operator.\nJava has a logical OR operator.\nJava has a logical NOT operator.\nJava has no logical XOR operator, according to sun.  I would like to define one.\nAs a method it is simply defined as follows:This method is called in the following way:I would much rather have an operator, used as follows:I can\'t find anything on how to go about defining a new operator in Java.  Where should I start?Java does have a logical XOR operator, it is ^ (as in a ^ b).Apart from that, you can\'t define new operators in Java. Edit: Here\'s an example:Output:Isn\'t it x != y ?Java has a logical AND operator.\n  Java has a logical OR operator.Wrong.Java hasXOR exists only as ^, because short-circuit evaluation is not possible.Perhaps you misunderstood the difference between & and &&, | and ||\nThe purpose of the short cut operators && and || is that the value of the first operand can determine the result and so the second operand doesn\'t need to be evaluated.This is especially useful if the second operand would results in an error.\ne.g.However with XOR, you always have to evaluate the second operand to get the result so the only meaningful operation is ^you can just write (a!=b) This would work the same as way as a^bThat\'s because operator overloading is something they specifically left out of the language deliberately.  They "cheated" a bit with string concatenation, but beyond that, such functionality doesn\'t exist.(disclaimer: I haven\'t worked with the last 2 major releases of java, so if it\'s in now, I\'ll be very surprised)The only operator overloading in Java is + on Strings (JLS 15.18.1 String Concatenation Operator +).  The community has been divided in 3 for years, 1/3 doesn\'t want it, 1/3 want it, and 1/3 doesn\'t care.You can use unicode to create method names that are symbols... so if you have a symbol you want to use you could do myVal = x.$(y); where $ is the symbol and x is not a primitive... but that is going to be dodgy in some editors and is limiting since you cannot do it on a primitive.Here is a var arg XOR method for java...EnjoyThe following your code:is superfluous.Why not to write:?Also, as javashlook said, there already is ^ operator.!= and ^ work identically for boolean operands (your case), but differently for integer operands.You can use Xtend (Infix Operators and Operator Overloading) to overload operators and \'stay\' on JavaWhat you\'re asking for wouldn\'t make much sense. Unless I\'m incorrect you\'re suggesting that you want to use XOR to perform Logical operations the same way AND and OR do. Your provided code actually shows what I\'m reffering to:Your function has boolean inputs, and when bitwise XOR is used on booleans the result is the same as the code you\'ve provided. In other words, bitwise XOR is already efficient when comparing individual bits(booleans) or comparing the individual bits in larger values. To put this into context, in terms of binary values any non-zero value is TRUE and only ZERO is false.So for XOR to be applied the same way Logical AND is applied, you would either only use binary values with just one bit(giving the same result and efficiency) or the binary value would have to be evaluated as a whole instead of per bit. In other words the expression ( 010 ^^ 110 ) = FALSE instead of ( 010 ^^ 110 ) = 100. This would remove most of the semantic meaning from the operation, and represents a logical test you shouldn\'t be using anyway.A and B would have to be boolean values to make != the same as xor so that the truth table would look the same. You could also use !(A==B) lol.I am using the very popular class "org.apache.commons.lang.BooleanUtils"This method is tested by many users and safe. Have fun.\nUsage:Because boolean data type is stored like an integer, bit operator ^ functions like a XOR operation if used with boolean values.Here\'s an example:Given 2 int values, return true if one is negative and one is positive. Except if the parameter "negative" is true, then return true only if both are negative. 