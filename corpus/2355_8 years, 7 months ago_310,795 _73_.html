Eclipse is giving me a warning of the following form:Type safety: Unchecked cast from Object to HashMapThis is from a call to an API that I have no control over which returns Object:I\'d like to avoid Eclipse warnings, if possible, since theoretically they indicate at least a potential code problem.  I haven\'t found a good way to eliminate this one yet, though.  I can extract the single line involved out to a method by itself and add @SuppressWarnings("unchecked") to that method, thus limiting the impact of having a block of code where I ignore warnings.  Any better options?  I don\'t want to turn these warnings off in Eclipse.Before I came to the code, it was simpler, but still provoked warnings:Problem was elsewhere when you tried to use the hash you\'d get warnings:The obvious answer, of course, is not to do the unchecked cast.If it\'s absolutely necessary, then at least try to limit the scope of the @SuppressWarnings annotation. According to its Javadocs, it can go on local variables; this way, it doesn\'t even affect the entire method.Example:There is no way to determine whether the Map really should have the generic parameters <String, String>. You must know beforehand what the parameters should be (or you\'ll find out when you get a ClassCastException). This is why the code generates a warning, because the compiler can\'t possibly know whether is safe.Wow; I think I figured out the answer to my own question.  I\'m just not sure it\'s worth it! :)The problem is the cast isn\'t checked.  So, you have to check it yourself.  You can\'t just check a parameterized type with instanceof, because the parameterized type information is unavailable at runtime, having been erased at compile time.But, you can perform a check on each and every item in the hash, with instanceof, and in doing so, you can construct a new hash that is type-safe.  And you won\'t provoke any warnings.Thanks to mmyers and Esko Luontola, I\'ve parameterized the code I originally wrote here, so it can be wrapped up in a utility class somewhere and used for any parameterized HashMap.  If you want to understand it better and aren\'t very familiar with generics, I encourage viewing the edit history of this answer.That\'s a lot of work, possibly for very little reward...  I\'m not sure if I\'ll use it or not.  I\'d appreciate any comments as to whether people think it\'s worth it or not.  Also, I\'d appreciate improvement suggestions: is there something better I can do besides throw AssertionErrors?  Is there something better I could throw?  Should I make it a checked Exception?Unfortunately, there are no great options here. Remember, the goal of all of this is to preserve type safety.  "Java Generics" offers a solutions for dealing with non-genericized legacy libraries, and there is one in particular called the "empty loop technique" in section section 8.2. Basically, make the unsafe cast, and suppress the warning. Then loop through the map like this:If an unexpected type is an encountered, you will get a runtime ClassCastException, but at least it will happen close to the source of the problem.In Eclipse Preferences, Go to Java->Compiler->Errors/Warnings->Generic types and check the Ignore unavoidable generic type problems check-box. This satisfies the intent of the question, i.e.I\'d like to avoid Eclipse warnings...if not the spirit.You can create a utility class like the following, and use it to suppress the unchecked warning.You can use it as follows:Some more discussion about this is here:\nhttp://cleveralias.blogs.com/thought_spearmints/2006/01/suppresswarning.htmlThis stuff is hard, but here are my current thoughts:If your API returns Object, then there\'s nothing you can do -- no matter what, you will be blindly casting the object. You let Java throw ClassCastExceptions, or you can check each element yourself and throw Assertions or IllegalArgumentExceptions or some such, but these runtime checks are all equivalent. You have to suppress the compile time unchecked cast  no matter what you do at runtime.I\'d just prefer to blind cast and let the JVM perform its runtime check for me since we "know" what the API should return, and are usually willing to assume that the API works. Use generics everywhere above the cast, if you need them. You aren\'t really buying anything there since you still have the single blind cast, but at least you can use generics from there on up so the JVM can help you avoid blind casts in other pieces of your code.In this particular case, presumably you can see the call to SetAttribute and see the type is going in, so just blind-casting the type to same on the way out is not immoral. Add a comment referencing the SetAttribute and be done with it.In the HTTP Session world you can\'t really avoid the cast, since the API is written that way (takes and returns only Object).With a little bit of work you can easily avoid the unchecked cast, \'though. This means that it will turn into a traditional cast giving a ClassCastException right there in the event of an error). An unchecked exception could turn into a CCE at any point later on instead of the point of the cast (that\'s the reason why it\'s a separate warning).Replace the HashMap with a dedicated class:Then cast to that class instead of Map<String,String> and everything will be checked at the exact place where you write your code. No unexpected ClassCastExceptions later on.In this particular case, I would not store Maps into the HttpSession directly, but instead an instance of my own class, which in turn contains a Map (an implementation detail of the class). Then you can be sure that the elements in the map are of the right type.But if you anyways want to check that the contents of the Map are of right type, you could use a code like this:The Objects.Unchecked utility function in the answer above by Esko Luontola is a great way to avoid program clutter.If you don\'t want the SuppressWarnings on an entire method, Java forces you to put it on a local. If you need a cast on a member it can lead to code like this:Using the utility is much cleaner, and it\'s still obvious what you are doing:NOTE:\nI feel its important to add that sometimes the warning really means you are doing something wrong like :What the compiler is telling you is that this cast will NOT be checked at runtime, so no runtime error will be raised until you try to access the data in the generic container.Here is a shortened example that avoids the "unchecked cast" warning by employing two strategies mentioned in other answers.Pass down the Class of the type of interest as a parameter at runtime (Class<T> inputElementClazz). Then you can use: inputElementClazz.cast(anyObject);For type casting of a Collection, use the wildcard ? instead of a generic type T to acknowledge that you indeed do not know what kind of objects to expect from the legacy code (Collection<?> unknownTypeCollection). After all, this is what the "unchecked cast" warning wants to tell us: We cannot be sure that we get a Collection<T>, so the honest thing to do is to use a Collection<?>. If absolutely needed, a collection of a known type can still be built (Collection<T> knownTypeCollection).The legacy code interfaced in the example below has an attribute "input" in the StructuredViewer (StructuredViewer is a tree or table widget, "input" is the data model behind it). This "input" could be any kind of Java Collection.Naturally, the code above can give runtime errors if we use the legacy code with the wrong data types (e.g. if we set an array as the "input" of the StructuredViewer instead of a Java Collection).Example of calling the method:Warning suppression is not a solution. You should not be doing two level casting in one statement.A quick guess if you post your code can say for sure but you might have done something along the lines ofwhich will produce the warning when you need to doit might be worth looking at Generics in the Java Programming Languageif your unfamiliar with what needs to be done.I may have misunderstood the question(an example and a couple of surrounding lines would be nice), but why don\'t you always use an appropriate interface (and Java5+)? I see no reason why you would ever want to cast to a HashMap instead of a Map<KeyType,ValueType>. In fact, I can\'t imagine any reason to set the type of a variable to HashMap instead of Map.And why is the source an Object? Is it a parameter type of a legacy collection? If so, use generics and specify the type you want.If I have to use an API that doesn\'t support Generics.. I try and isolate those calls in wrapper routines with as few lines as possible. I then use the SuppressWarnings annotation and also add the type-safety casts at the same time.This is just a personal preference to keep things as neat as possible.  Take this one, it\'s much faster than creating a new HashMap, if it\'s already one, but still secure, as each element is checked against it\'s type...Just typecheck it before you cast it.And for anyone asking, it\'s quite common to receive objects where you aren\'t sure of the type.  Plenty of legacy "SOA" implementations pass around various objects that you shouldn\'t always trust.  (The horrors!)EDIT Changed the example code once to match the poster\'s updates, and following some comments I see that instanceof doesn\'t play nicely with generics.  However changing the check to validate the outer object seems to play well with the commandline compiler.  Revised example now posted.Almost every problem in Computer Science can be solved by adding a level of indirection*, or something.So introduce a non-generic object that is of a higher-level that a Map. With no context it isn\'t going to look very convincing, but anyway:*Except too many levels of indirection.Here\'s one way I handle this when I override the equals() operation.This seems to work in Java 8 (even compiled with -Xlint:unchecked)The problem lies in here:The result of session.getAttribute(...) is an object which could be anything, but since you "know" it\'s a HashMap<String, String> you\'re just casting without checking it first.  Thus, the warning.  To be pedantic, which Java wants you to be in this case, you should retrieve the result and verify it\'s compatibility with instanceof.If you are sure that the type returned by session.getAttribute() is HashMap then you can not typecast to that exact type, but rely on only checking the generic HashMapEclipse will then surprise warnings, but of course this can lead to runtime errors that can be hard to debug. I use this approach in not operation-critical contexts only. Two ways, one which avoids the tag completely, the other using a naughty but nice utility method.\nThe problem is pre-genericised Collections...\nI believe the rule of thumb is: "cast objects one thing at a time" - what this means when trying to use raw classes in a genericised world is that because you don\'t know what is in this Map<?, ?> (and indeed the JVM might even find that it isn\'t even a Map!), it obvious when you think about it that you can\'t cast it.  If you had a Map<String, ?> map2 then HashSet<String> keys = (HashSet<String>)map2.keySet() does not give you a warning, despite this being an "act of faith" for the compiler (because it might turn out to be a TreeSet)... but it is only a single act of faith.\n\nPS to the objection that iterating as in my first way "is boring" and "takes time", the answer is "no pain no gain": a genericised collection is guaranteed to contain Map.Entry<String, String>s, and nothing else.  You have to pay for this guarantee.  When using generics systematically this payment, beautifully, takes the form of coding compliance, not machine time!\nOne school of thought might say that you should set Eclipse\'s settings to make such unchecked casts errors, rather than warnings.  In that case you would have to use my first way.In Android Studio if you want to disable inspection you can use: This makes the warnings go away...Solution: Disable this warning in Eclipse. Don\'t @SuppressWarnings it, just disable it completely.Several of the "solutions" presented above are way out of line, making code unreadable for the sake of suppressing a silly warning.