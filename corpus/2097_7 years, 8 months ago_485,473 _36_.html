How can I go about rolling back to a specific commit in git?The best answer someone could give me was to use git revert X times until I reach the desired commit.  So let\'s say I want to revert back to a commit that\'s 20 commits old, I\'d have to run it 20 times.  Is there an easier way to do this?  I can\'t use reset because this repository is public.Try this:where [revision] is the commit hash (for example: 12345678901234567890123456789012345678ab). Don\'t forget the . at the end, very important. This will apply changes to the whole tree. Then commit and you should be good.You can undo this bythat will delete all modifications from the working directory and staging area.To rollback to a specific commit:To rollback 10 commits back:You can use "git revert" as in the following post if you don\'t want to rewrite the historyHow to revert Git repository to a previous commit?Well, I guess the question is, what do you mean by \'roll back\'? If you can\'t reset because it\'s public and you want to keep the commit history intact, do you mean you just want your working copy to reflect a specific commit? Use git checkout and the commit hash.Edit: As was pointed out in the comments, using git checkout without specifying a branch will leave you in a "no branch" state. Use git checkout <commit> -b <branchname> to checkout into a branch, or git checkout <commit> . to checkout into the current branch.The original poster states:The best answer someone could give me was to use git revert X times until I\n  reach the desired commit.So let\'s say I want to revert back to a commit that\'s 20 commits old, I\'d have\n  to run it 20 times.Is there an easier way to do this?I can\'t use reset cause this repo is public.It\'s not necessary to use git revert X times. git revert can accept a\ncommit range as an argument, so you only need to use it once to revert a range\nof commits. For example, if you want to revert the last 20 commits:The commit range HEAD~20.. is short for HEAD~20..HEAD, and means "start from the 20th parent of the HEAD commit, and revert all commits after it up to HEAD". That will revert that last 20 commits, assuming that none of those are merge\ncommits. If there are merge commits, then you cannot revert them all in one command, you\'ll need to revert them individually withNote also that I\'ve tested using a range with git revert using git version 1.9.0. If you\'re using an older version of git, using a range with git revert may or may not work.Note that unlike this answer that says to use git checkout, git revert\nwill actually remove any files that were added in any of the commits that you\'re\nreverting, which makes this the correct way to revert a range of revisions.Step 1: fetch list of commits:You\'ll get list like in this example:Step 2: copy needed commit hash and paste it for checkout:That\'s all.will do it.  It\'s "git checkout" but without updating HEAD.You can achieve the same effect with if you prefer stringing convenience commands together.These leave you with your worktree and index in the desired state, you can just git commit to finish.I\'m not sure what changed, but I am unable to checkout a specific commit without the option --detach. The full command that worked for me was:\ngit checkout --detach [commit hash]To get back from the detached state I had to checkout my local branch: git checkout master