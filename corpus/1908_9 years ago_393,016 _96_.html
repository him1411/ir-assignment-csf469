I want to filter a java.util.Collection based on a predicate.Java 8 (2014) solves this problem using streams and lambdas in one line of code:Here\'s a tutorial.Use Collection#removeIf to modify the collection in place (provided it supports element removal):lambdaj allows filtering collections without writing loops or inner classes:Can you imagine something more readable?Disclaimer: I am a contributor on lambdajAssuming that you are using Java 1.5, and that you cannot add Google Collections, I would do something very similar to what the Google guys did. This is a slight variation on Jon\'s comments.First add this interface to your codebase.Its implementers can answer when a certain predicate is true of a certain type. E.g. If T were User and AuthorizedUserPredicate<User> implements IPredicate<T>, then AuthorizedUserPredicate#apply returns whether the passed in User is authorized.Then in some utility class, you could saySo, assuming that you have the use of the above might beIf performance on the linear check is of concern, then I might want to have a domain object that has the target collection. The domain object that has the target collection would have filtering logic for the methods that initialize, add and set the target collection.UPDATE: In the utility class (let\'s say Predicate), I have added a select method with an option for default value when the predicate doesn\'t return the expected value, and also a static property for params to be used inside the new IPredicate.The following example looks for missing objects between collections:The following example, looks for an instance in a collection, and returns the first element of the collection as default value when the instance is not found:UPDATE (after Java 8 release):It\'s been several years since I (Alan) first posted this answer, and I still cannot believe I am collecting SO points for this answer. At any rate, now that Java 8 has introduced closures to the language, my answer would now be considerably different, and simpler. With Java 8, there is no need for a distinct static utility class. So if you want to find the 1st element that matches your predicate.The JDK 8 API for optionals has the ability to get(), isPresent(), orElse(defaultUser), orElseGet(userSupplier) and orElseThrow(exceptionSupplier), as well as other \'monadic\' functions such as map, flatMap and filter.If you want to simply collect all the users which match the predicate, then use the Collectors to terminate the stream in the desired collection.See here for more examples on how Java 8 streams work.Use CollectionUtils.filter(Collection,Predicate), from Apache Commons.Consider Google Collections for an updated Collections framework that supports generics.UPDATE: The google collections library is now deprecated.  You should use the latest release of Guava instead.  It still has all the same extensions to the collections framework including a mechanism for filtering based on a predicate."Best" way is too wide a request. Is it "shortest"? "Fastest"? "Readable"?\nFilter in place or into another collection?Simplest (but not most readable) way is to iterate it and use Iterator.remove() method:Now, to make it more readable, you can wrap it into a utility method. Then invent a IPredicate interface, create an anonymous implementation of that interface and do something like:where filterInPlace() iterate the collection and calls Predicate.keepIt() to learn if the instance to be kept in the collection.I don\'t really see a justification for bringing in a third-party library just for this task.Wait for Java 8:Since the early release of Java 8, you could try something like:For example, if you had a list of integers and you wanted to filter the numbers that are > 10 and then print out those numbers to the console, you could do something like:I\'ll throw RxJava in the ring, which is also available on Android. RxJava might not always be the best option, but it will give you more flexibility if you wish add more transformations on your collection or handle errors while filtering.Output:More details on RxJava\'s filter can be found here.The setup:The usage:Are you sure you want to filter the Collection itself, rather than an iterator?see org.apache.commons.collections.iterators.FilterIteratoror using version 4 of apache commons org.apache.commons.collections4.iterators.FilterIteratorLet\xe2\x80\x99s look at how to filter a built-in JDK List and a MutableList using Eclipse Collections (formerly GS Collections).If you wanted to filter the numbers less than 3, you would expect the following outputs.Here\xe2\x80\x99s how you can filter using an anonymous inner class as the Predicate.Here are some alternatives to filtering JDK lists and Eclipse Collections MutableLists using the Predicates factory.Here is a version that doesn\'t allocate an object for the predicate, by using the Predicates2 factory instead with the selectWith method that takes a Predicate2.Sometimes you want to filter on a negative condition.  There is a special method in Eclipse Collections for that called reject.Here\xe2\x80\x99s how you can filter using a Java 8 lambda as the Predicate.The method partition will return two collections, containing the elements selected by and rejected by the Predicate.Note: I am a committer for Eclipse Collections.With the ForEach DSL you may writeGiven a collection of [The, quick, brown, fox, jumps, over, the, lazy, dog] this results in [quick, brown, jumps, over, lazy], ie all strings longer than three characters.All iteration styles supported by the ForEach DSL areFor more details, please refer to https://www.iam.unibe.ch/scg/svn_repos/Sources/ForEachThe Collections2.filter(Collection,Predicate) method in Google\'s Guava library does just what you\'re looking for.How about some plain and straighforward JavaSimple, readable and easy (and works in Android!)\nBut if you\'re using Java 8 you can do it in a sweet one line:Note that toList() is statically importedThis, combined with the lack of real closures, is my biggest gripe for Java.\nHonestly, most of the methods mentioned above are pretty easy to read and REALLY efficient; however, after spending time with .Net, Erlang, etc... list comprehension integrated at the language level makes everything so much cleaner. Without additions at the language level, Java just cant be as clean as many other languages in this area.If performance is a huge concern, Google collections is the way to go (or write your own simple predicate utility). Lambdaj syntax is more readable for some people, but it is not quite as efficient.And then there is a library I wrote. I will ignore any questions in regard to its efficiency (yea, its that bad)...... Yes, i know its clearly reflection based, and no I don\'t actually use it, but it does work:ORJFilter http://code.google.com/p/jfilter/ is best suited for your requirement.JFilter is a simple and high performance open source library to query collection of Java beans.Key featuresI wrote an extended Iterable class that support applying functional algorithms without copying the collection content.Usage:The code above will actually executeUse Collection Query Engine (CQEngine). It is by far the fastest way to do this.See also: How do you query object collections in Java (Criteria/SQL-like)?The simple pre-Java8 solution:Unfortunately this solution isn\'t fully generic, outputting a list rather than the type of the given collection. Also, bringing in libraries or writing functions that wrap this code seems like overkill to me unless the condition is complex, but then you can write a function for the condition.https://code.google.com/p/joquery/Supports different possibilities,Given collection,of type,FilterJava 7Java 8Also,Sorting (also available for the Java 7)Grouping (also available for the Java 7)Joins (also available for the Java 7)Given,Can be Joined like,ExpressionsSome really great great answers here. Me, I\'d like to keep thins as simple and readable as possible:}My answer builds on that from Kevin Wong, here as a one-liner using CollectionUtils from spring and a Java 8 lambda expression.This is as concise and readable as any alternative I have seen (without using aspect-based libraries)Spring CollectionUtils is available from spring version 4.0.2.RELEASE, and remember you need JDK 1.8 and language level 8+.Using java 8, specifically lambda expression, you can do it simply like the below example:where for each product inside myProducts collection, if prod.price>10, then add this product to the new filtered list.With Guava:I needed to filter a list depending on the values already present in the list. For example, remove all values following that is less than the current value. {2 5 3 4 7 5} -> {2 5 7}. Or for example to remove all duplicates {3 5 4 2 3 5 6} -> {3 5 4 2 6}.This will bee used like this.