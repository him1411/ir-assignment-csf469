In C++, is there any difference between:and In C++, there is only a subtle difference.  It\'s a holdover from C, in which it makes a difference.The C language standard (C89 \xc2\xa73.1.2.3, C99 \xc2\xa76.2.3, and C11 \xc2\xa76.2.3) mandates separate namespaces for different categories of identifiers, including tag identifiers (for struct/union/enum) and ordinary identifiers (for typedef and other identifiers). If you just said:you would get a compiler error, because Foo is only defined in the tag namespace. You\'d have to declare it as:Any time you want to refer to a Foo, you\'d always have to call it a struct Foo.  This gets annoying fast, so you can add a typedef:Now both struct Foo (in the tag namespace) and just plain Foo (in the ordinary identifier namespace) both refer to the same thing, and you can freely declare objects of type Foo without the struct keyword.The construct:is just an abbreviation for the declaration and typedef.Finally,declares an anonymous structure and creates a typedef for it.  Thus, with this construct, it doesn\'t have a name in the tag namespace, only a name in the typedef namespace.  This means it also cannot be forward-declared.  If you want to make a forward declaration, you have to give it a name in the tag namespace.In C++, all struct/union/enum/class declarations act like they are implicitly typedef\'ed, as long as the name is not hidden by another declaration with the same name.  See Michael Burr\'s answer for the full details.In this DDJ article, Dan Saks explains one small area where bugs can creep through if you do not typedef your structs (and classes!):If you want, you can imagine that C++\n  generates a typedef for every tag\n  name, such asUnfortunately, this is not entirely\n  accurate. I wish it were that simple,\n  but it\'s not. C++ can\'t generate such\n  typedefs for structs, unions, or enums\n  without introducing incompatibilities\n  with C.For example, suppose a C program\n  declares both a function and a struct\n  named status:Again, this may be bad practice, but\n  it is C. In this program, status (by\n  itself) refers to the function; struct\n  status refers to the type.If C++ did automatically generate\n  typedefs for tags, then when you\n  compiled this program as C++, the\n  compiler would generate:Unfortunately, this type name would\n  conflict with the function name, and\n  the program would not compile. That\'s\n  why C++ can\'t simply generate a\n  typedef for each tag.In C++, tags act just like typedef\n  names, except that a program can\n  declare an object, function, or\n  enumerator with the same name and the\n  same scope as a tag. In that case, the\n  object, function, or enumerator name\n  hides the tag name. The program can\n  refer to the tag name only by using\n  the keyword class, struct, union, or\n  enum (as appropriate) in front of the\n  tag name. A type name consisting of\n  one of these keywords followed by a\n  tag is an elaborated-type-specifier.\n  For instance, struct status and enum\n  month are elaborated-type-specifiers. Thus, a C program that contains both:behaves the same when compiled as C++.\n  The name status alone refers to the\n  function. The program can refer to the\n  type only by using the\n  elaborated-type-specifier struct\n  status.So how does this allow bugs to creep\n  into programs? Consider the program in\n  Listing 1. This program defines a\n  class foo with a default constructor,\n  and a conversion operator that\n  converts a foo object to char const *.\n  The expressionin main should construct a foo object\n  and apply the conversion operator. The\n  subsequent output statementshould display class foo, but it\n  doesn\'t. It displays function foo.This surprising result occurs because\n  the program includes header lib.h\n  shown in Listing 2. This header\n  defines a function also named foo. The\n  function name foo hides the class name\n  foo, so the reference to foo in main\n  refers to the function, not the class.\n  main can refer to the class only by\n  using an elaborated-type-specifier, as\n  inThe way to avoid such confusion\n  throughout the program is to add the\n  following typedef for the class name\n  foo:immediately before or after the class\n  definition. This typedef causes a\n  conflict between the type name foo and\n  the function name foo (from the\n  library) that will trigger a\n  compile-time error.I know of no one who actually writes\n  these typedefs as a matter of course.\n  It requires a lot of discipline. Since\n  the incidence of errors such as the\n  one in Listing 1 is probably pretty\n  small, you many never run afoul of\n  this problem. But if an error in your\n  software might cause bodily injury,\n  then you should write the typedefs no\n  matter how unlikely the error. I can\'t imagine why anyone would ever\n  want to hide a class name with a\n  function or object name in the same\n  scope as the class. The hiding rules\n  in C were a mistake, and they should\n  not have been extended to classes in\n  C++. Indeed, you can correct the\n  mistake, but it requires extra\n  programming discipline and effort that\n  should not be necessary.One more important difference: typedefs cannot be forward declared. So for the typedef option you must #include the file containing the typedef, meaning everything that #includes your .h also includes that file whether it directly needs it or not, and so on. It can definitely impact your build times on larger projects.Without the typedef, in some cases you can just add a forward declaration of struct Foo; at the top of your .h file, and only #include the struct definition in your .cpp file.There is a difference, but subtle. Look at it this way: struct Foo introduces a new type. The second one creates an alias called Foo (and not a new type) for an unnamed struct type.7.1.3 The typedef specifier1 [...]A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a\n  typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in\n  the way described in Clause 8. A typedef-name is thus a synonym for another type. A typedef-name does not introduce a new type the way a class declaration (9.1) or enum declaration does.8 If the typedef declaration defines an unnamed class (or enum), the first typedef-name declared by the declaration\n  to be that class type (or enum type) is used to denote the class type (or enum type) for linkage\n  purposes only (3.5). [ Example:So, a typedef always is used as an placeholder/synonym for another type.You can\'t use forward declaration with the typedef struct.The struct itself is an anonymous type, so you don\'t have an actual name to forward declare.A forward declaration like this wont work:An important difference between a \'typedef struct\' and a \'struct\' in C++ is that inline member initialisation in \'typedef structs\' will not work.Struct is to create a data type.\nThe typedef is to set a nickname for a data type.There is no difference in C++, but I believe in C it would allow you to declare instances of the struct Foo without explicitly doing: