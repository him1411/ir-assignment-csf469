What is the correct way of iterating over a vector in C++?Consider these two code fragments, this one works fine:and this one:which generates warning: comparison between signed and unsigned integer expressions.I\'m new in the world of C++, so the unsigned variable looks a bit frightening to me and I know unsigned variables can be dangerous if not used correctly, so - is this correct?See this answer. This is almost identical. Just change the iterators / swap decrement by increment. You should prefer iterators. Some people tell you to use std::size_t as the index variable type. However, that is not portable. Always use the size_type typedef of the container (While you could get away with only a conversion in the forward iterating case, it could actually go wrong all the way in the backward iterating case when using std::size_t, in case std::size_t is wider than what is the typedef of size_type):Important is, always use the prefix increment form for iterators whose definitions you don\'t know. That will ensure your code runs as generic as possible. Read in the backward iterating answer what problem the sizeof approach can yield to, though.Four years passed, Google gave me this answer. With the standard C++11 (aka C++0x) there is actually a new pleasant way of doing this (at the price of breaking backward compatibility): the new auto keyword. It saves you the pain of having to explicitly specify the type of the iterator to use (repeating the vector type again), when it is obvious (to the compiler), which type to use. With v being your vector, you can do something like this:C++11 goes even further and gives you a special syntax for iterating over collections like vectors. It removes the necessity of writing things that are always the same:To see it in a working program, build a file auto.cpp:As of writing this, when you compile this with g++, you normally need to set it to work with the new standard by giving an extra flag:Now you can run the example:Please note that the instructions on compiling and running are specific to gnu c++ compiler on Linux, the program should be platform (and compiler) independent.In the specific case in your example, I\'d use the STL algorithms to accomplish this. For a more general, but still fairly simple case, I\'d go with:Regarding Johannes Schaub\'s answer:That may work with some compilers but not with gcc. The problem here is the question if std::vector::iterator is a type, a variable (member) or a function (method). We get the following error with gcc:The solution is using the keyword \'typename\' as told:A call to vector<T>::size() returns a value of type std::vector<T>::size_type, not int, unsigned int or otherwise.Also generally iteration over a container in C++ is done using iterators, like this.Where T is the type of data you store in the vector.Or using the different iteration algorithms (std::transform, std::copy, std::fill, std::for_each et cetera).Use size_t :Quoting Wikipedia:The stdlib.h and stddef.h header files define a datatype called size_t which is used to represent the size of an object. Library functions that take sizes expect them to be of type size_t, and the sizeof operator evaluates to size_t.The actual type of size_t is platform-dependent; a common mistake is to assume size_t is the same as unsigned int, which can lead to programming errors, particularly as 64-bit architectures become more prevalent.I usually use BOOST_FOREACH:It works on STL containers, arrays, C-style strings, etc.To be complete, C++11 syntax enables just one another version for iterators (ref):Which is also comfortable for reverse iterationI would use general algorithms like for_each to avoid searching for the right type of iterator and lambda expression to avoid extra named functions/objects.The short "pretty" example for your particular case (assuming polygon is a vector of integers):tested on: http://ideone.com/i6EthdDont\' forget to include: algorithm and, of course, vector :)Microsoft has actually also a nice example on this:\nsource: http://msdn.microsoft.com/en-us/library/dd293608.aspxA bit of history:To represent whether a number is negative or not computer use a \'sign\' bit.  int is a signed data type meaning it can hold positive and negative values (about -2billion to 2billion).  Unsigned can only store positive numbers (and since it doesn\'t waste a bit on metadata it can store more: 0 to about 4billion).std::vector::size() returns an unsigned, for how could a vector have negative length?The warning is telling you that the right operand of your inequality statement can hold more data then the left.Essentially if you have a vector with more then 2 billion entries and you use an integer to index into you\'ll hit overflow problems (the int will wrap back around to negative 2 billion).The first is type correct, and correct in some strict sense.  (If you think about is, size can never be less than zero.)  That warning strikes me as one of the good candidates for being ignored, though.