I have code where I schedule a task using java.util.timer. I was looking around and saw ExecutorService can do the same. So this question here, have you used Timer and ExecutorService to schedule tasks, what is the benefit of one using over another?Also wanted to check if anyone had used the Timer class and ran into any issues which the ExecutorService solved for them.According to Java Concurrency in Practice:If you can use ScheduledThreadExecutor instead of Timer, do so.One more thing... while ScheduledThreadExecutor isn\'t available in Java 1.4 library, there is a Backport of JSR 166 (java.util.concurrent) to Java 1.2, 1.3, 1.4, which has the ScheduledThreadExecutor class.If it\'s available to you, then it\'s difficult to think of a reason not to use the Java 5 executor framework. Calling:will give you a ScheduledExecutorService with similar functionality to Timer (i.e. it will be single-threaded) but whose access may be slightly more scalable (under the hood, it uses concurrent structures rather than complete synchronization as with the Timer class). Using a ScheduledExecutorService also gives you advantages such as:About the only reasons for sticking to Timer I can think of are:ExecutorService is newer and more general.  A timer is just a thread that periodically runs stuff you have scheduled for it.An ExecutorService may be a thread pool, or even spread out across other systems in a cluster and do things like one-off batch execution, etc...Just look at what each offers to decide.Here\'s some more good practices around Timer use:http://tech.puredanger.com/2008/09/22/timer-rules/In general, I\'d use Timer for quick and dirty stuff and Executor for more robust usage.My reason for sometimes preferring Timer over Executors.newSingleThreadScheduledExecutor() is that I get much cleaner code when I need the timer to execute on daemon threads.compare with I do this when I don\'t need the robustness of an executorservice.From oralce documentation page on ScheduledThreadPoolExecutorA ThreadPoolExecutor that can additionally schedule commands to run after a given delay, or to execute periodically. This class is preferable to Timer when multiple worker threads are needed, or when the additional flexibility or capabilities of ThreadPoolExecutor (which this class extends) are required.ExecutorService/ThreadPoolExecutor or ScheduledThreadPoolExecutor is obvious choice when you have multiple worker threads. Pros of ExecutorService over TimerThreadPoolExecutor provides better API for management of Thread life cycle.Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks. Each ThreadPoolExecutor also maintains some basic statistics, such as the number of completed tasksFew advantages:a. You can create/manage/control life cycle of Threads & optimize thread creation cost overheadsb. You can control processing of tasks ( Work Stealing, ForkJoinPool, invokeAll) etc.c. You can monitor the progress and health of threadsd. Provides better exception handling mechanism 