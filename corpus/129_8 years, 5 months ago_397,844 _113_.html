How can I make two decorators in Python that would do the following?...which should return:I\'m not trying to make HTML this way in a real application - just trying to understand how decorators and decorator chaining works.Check out the documentation to see how decorators work. Here is what you asked for:If you are not into long explanations, see Paolo Bergantino\xe2\x80\x99s answer.To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let\xe2\x80\x99s see why with a simple example :Keep this in mind. We\xe2\x80\x99ll circle back to it shortly. Another interesting property of Python functions is they can be defined inside another function!Okay, still here? Now the fun part...You\xe2\x80\x99ve seen that functions are objects. Therefore, functions:That means that a function can return another function.There\xe2\x80\x99s more! If you can return a function, you can pass one as a parameter:Well, you just have everything needed to understand decorators. You see, decorators are \xe2\x80\x9cwrappers\xe2\x80\x9d, which means that they let you execute code before and after the function they decorate without modifying the function itself.How you\xe2\x80\x99d do it manually:Now, you probably want that every time you call a_stand_alone_function, a_stand_alone_function_decorated is called instead. That\xe2\x80\x99s easy, just overwrite a_stand_alone_function with the function returned by my_shiny_new_decorator:The previous example, using the decorator syntax:Yes, that\xe2\x80\x99s all, it\xe2\x80\x99s that simple. @decorator is just a shortcut to:Decorators are just a pythonic variant of the decorator design pattern. There are several classic design patterns embedded in Python to ease development (like iterators).Of course, you can accumulate decorators:Using the Python decorator syntax:The order you set the decorators MATTERS:As a conclusion, you can easily see how to answer the question:You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (self). That means you can build a decorator for methods the same way! Just remember to take self into consideration:If you\xe2\x80\x99re making general-purpose decorator--one you\xe2\x80\x99ll apply to any function or method, no matter its arguments--then just use *args, **kwargs:Great, now what would you say about passing arguments to the decorator itself? This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function\xe2\x80\x99s arguments directly to the decorator.Before rushing to the solution, let\xe2\x80\x99s write a little reminder: It\xe2\x80\x99s exactly the same. "my_decorator" is called. So when you @my_decorator, you are telling Python to call the function \'labelled by the variable "my_decorator"\'. This is important! The label you give can point directly to the decorator\xe2\x80\x94or not. Let\xe2\x80\x99s get evil. \xe2\x98\xbaNo surprise here. Let\xe2\x80\x99s do EXACTLY the same thing, but skip all the pesky intermediate variables:Let\xe2\x80\x99s make it even shorter:Hey, did you see that? We used a function call with the "@" syntax! :-)So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?Here it is: a decorator with arguments. Arguments can be set as variable:As you can see, you can pass arguments to the decorator like any function using this trick. You can even use *args, **kwargs if you wish. But remember decorators are called only once. Just when Python imports the script. You can\'t dynamically set the arguments afterwards. When you do "import x", the function is already decorated, so you can\'t\nchange anything.Okay, as a bonus, I\'ll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function. We wrapped the decorator.Anything else we saw recently that wrapped function?Oh yes, decorators!Let\xe2\x80\x99s have some fun and write a decorator for the decorators:It can be used as follows:I know, the last time you had this feeling, it was after listening a guy saying: "before understanding recursion, you must first understand recursion". But now, don\'t you feel good about mastering this?The functools module was introduced in Python 2.5. It includes the function functools.wraps(), which copies the name, module, and docstring of the decorated function to its wrapper. (Fun fact: functools.wraps() is a decorator! \xe2\x98\xba)Now the big question: What can I use decorators for? Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can\'t modify it), or for debugging (you don\'t want to modify it because it\xe2\x80\x99s temporary). You can use them to extend several functions in a DRY\xe2\x80\x99s way, like so:Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:Python itself provides several decorators: property, staticmethod, etc. This really is a large playground.Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:This enables you to write:orPersonally I would have written the decorator somewhat differently:which would yield:Don\'t forget the construction for which decorator syntax is a shorthand:It looks like the other people have already told you how to solve the problem. I hope this will help you understand what decorators are.Decorators are just syntactical sugar.Thisexpands to    And of course you can return lambdas as well from a decorator function:Python decorators add extra functionality to another functionAn italics decorator could be likeNote that a function is defined inside a function.\nWhat it basically does is replace a function with the newly defined one. For example, I have this classNow say, I want both functions to print "---" after and before they are done.\nI could add a print "---" before and after each print statement.\nBut because I don\'t like repeating myself, I will make a decoratorSo now I can change my class to For more on decorators, check\nhttp://www.ibm.com/developerworks/linux/library/l-cpdecor.htmlAnother way of doing the same thing:Or, more flexibly:You could make two separate decorators that do what you want as illustrated directly below. Note the use of *args, **kwargs in the declaration of the wrapped() function which supports the decorated function having multiple arguments (which isn\'t really necessary for the example say() function, but is included for generality).For similar reasons, the functools.wraps decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (func.__doc__) be those of the decorated function instead of wrapped()\'s.As you can see there\'s a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a decorator factory\xe2\x80\x94in other words, a decorator that makes other decorators. That way there would be less code repetition\xe2\x80\x94and allow the DRY principle to be followed.To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:or even combine them like this:While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorator are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.This requires more code in the decorator itself, but this only runs when it\'s being appled to function definitions, not later when they themselves are called. This also applies when creating more readable names by using lambda functions as previously illustrated. Sample:You want the following function, when called:To return:To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:Now use them as desired:and now:But we seem to have nearly lost the original function. To find it, we\'d need to dig into the closure of each lambda, one of which is buried in the other:So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.We have the decorator wraps from the functools module in the standard library! It is unfortunate that there\'s still some boilerplate, but this is about as simple as we can make it. In Python 3, you also get __qualname__ and __annotations__ assigned by default.So now:And now:So we see that wraps makes the wrapping function do almost everything except tell us exactly what the function takes as arguments. There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.A decorator takes the function definition and creates a new function that executes this function and transforms the result.is eqivarent to:Thisis eqivalent to this\n    def do2(number):\n        return chr(number)65 <=> \'a\'To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes func and transforms the result.To explain decorator in a simpler way:With:When do:You really do:Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: func_counter1 = counter(func); func_counter2 = counter(func)), and the counter variable will remain private to each. Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.The output looks like:You can also write decorator in ClassResult:  