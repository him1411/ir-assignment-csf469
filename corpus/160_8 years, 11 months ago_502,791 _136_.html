I\'ve been wondering whether there is a good "git export" solution that creates a copy of a tree without the .git repository directory. There are at least three methods I know of:None of these solutions really strike me as being satisfactory. The closest one to svn export might be option 1, because both those require the target directory to be empty first. But option 2 seems even better, assuming I can figure out what it means to read a tree into the index.Probably the simplest way to achieve this is with git archive. If you really need just the expanded tree you can do something like this.Most of the time that I need to \'export\' something from git, I want a compressed archive in any case so I do something like this.ZIP archive:git help archive for more details, it\'s quite flexible.Note: If you are interested in exporting the index, the command is(See Greg\'s answer for more details)I found out what option 2 means. From a repository, you can do:The slash at the end of the path is important, otherwise it will result in the files being in /destination with a prefix of \'path\'.Since in a normal situation the index contains the contents of the repository, there is nothing special to do to "read the desired tree into the index". It\'s already there.The -a flag is required to check out all files in the index (I\'m not sure what it means to omit this flag in this situation, since it doesn\'t do what I want). The -f flag forces overwriting any existing files in the output, which this command doesn\'t normally do.This appears to be the sort of "git export" I was looking for.git archive also works with remote repository.To export particular path inside the repo add as many paths as you wish as last argument to git, e.g.:Just use svn export.As far as I know Github does not allow archive --remote. Although GitHub is svn compatible and they do have all git repos svn accessible so you could just use svn export like you normally would with a few adjustments to your GitHub url.For example to export an entire repository, notice how trunk in the URL replaces master (or whatever the project\'s HEAD branch is set to):And you can export a single file or even a certain path or folder:The HEAD branch or master branch will be available using trunk:The non-HEAD branches will be accessible under /branches/:All tags under /tags/ in the same fashion:From the Git Manual:Using git-checkout-index to "export an entire tree"The prefix ability basically makes it trivial to use git-checkout-index as an "export as tree" function. Just read the desired tree into the index, and do:$ git checkout-index --prefix=git-export-dir/ -aI\'ve written a simple wrapper around git-checkout-index that you can use like this:If the destination directory already exists, you\'ll need to add -f or --force.Installation is simple; just drop the script somewhere in your PATH, and make sure it\'s executable.The github repository for git-export It appears that this is less of an issue with Git than SVN.  Git only puts a .git folder in the repository root, whereas SVN puts a .svn folder in every subdirectory.  So "svn export" avoids recursive command-line magic, whereas with Git recursion is not necessary.The equivalent of inside an existing repo isThe equivalent ofisI use git-submodules extensively.\nThis one works for me:The right answer is "git checkout"-f\nWhen checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.-q\nAvoid verboseAdditionally you can get any Branch or Tag or from a specific Commit Revision like in SVN just adding the SHA1 (SHA1 in Git is the equivalent to the Revision Number in SVN)The /path/to/checkout/ must be empty, Git will not delete any file, but will overwrite files with the same name without any warningUPDATE:\nTo avoid the beheaded problem or to leave intact the working repository when using checkout for export with tags, branches or SHA1, you need to add -- ./ at the endthe double dash -- tell git that everything after the dashs are paths or files and also in this case tell git checkout to not change the HEADExamples:This command will get just the libs directory and also the readme.txt file from that exactly commitThis will create(overwrite) my_file_2_behind_HEAD.txt two commits behind the head HEAD^2To get the export of another branchNotice that ./ is relative to the root of the repositoryThis will copy all contents, minus the .dot files. I use this to export git cloned projects into my web app\'s git repo without the .git stuff.cp -R ./path-to-git-repo /path/to/destination/Plain old bash works just great :)I have hit this page frequently when looking for a way to export a git repository. My answer to this question considers three properties that svn export has by design compared to git, since svn follows a centralized repository approach:Exporting a certain branch using svn is accomplished by specifying the appropriate pathWhen building a certain release it is useful to clone a stable branch as for example --branch stable or --branch release/0.9.I just want to point out that in the case that you areThen you can just use cp foo [destination] instead of the mentioned git-archive master foo | -x -C [destination].As simple as clone then delete the .git folder:\ngit clone url_of_your_repo path_to_export && rm -rf path_to_export/.git\nYou can archive a remote repo at any commit as zip file.For GitHub users, the git archive --remote method won\'t work directly, as the export URL is ephemeral.  You must ask GitHub for the URL, then download that URL.  curl makes that easy:This will give you the exported code in a local directory.  Example:Edit\nIf you want the code put into a specific, existing directory (rather than the random one from github):Bash-implementation of git-export.I have segmented the .empty file creation and removal processes on their own function, with the purpose of re-using them in the \'git-archive\' implementation (will be posted later on).I have also added the \'.gitattributes\' file to the process in order to remove un-wanted files from the target export folder.\nIncluded verbosity to the process while making the \'git-export\' function more efficient.EMPTY_FILE=".empty";Output:$ git-export /tmp/rel-1.0.0Adding \'.empty\' files to empty folder(s): ... done.Checking-Out Index component(s): ... done.Resetting HEAD and Index: ... done.Purging Git-Specific component(s): ...\'/tmp/rel-1.0.0/{.buildpath}\' files ... done.\'\'/tmp/rel-1.0.0/{.project}\' files ... done.\'\'/tmp/rel-1.0.0/{.gitignore}\' files ... done.\'\'/tmp/rel-1.0.0/{.git}\' files ... done.\'\'/tmp/rel-1.0.0/{.gitattributes}\' files ... done.\'\'/tmp/rel-1.0.0/{*.mno}\' files ... done.\'\'/tmp/rel-1.0.0/{*~}\' files ... done.\'\'/tmp/rel-1.0.0/{.*~}\' files ... done.\'\'/tmp/rel-1.0.0/{*.swp}\' files ... done.\'\'/tmp/rel-1.0.0/{*.swo}\' files ... done.\'\'/tmp/rel-1.0.0/{.DS_Store}\' files ... done.\'\'/tmp/rel-1.0.0/{.settings}\' files ... done.\'\'/tmp/rel-1.0.0/{.empty}\' files ... done.\'done.Archiving Checked-Out component(s): ... done.-rw-r--r--  1 admin  wheel  25445901  3 Nov 12:57 /tmp/rel-1.0.0.tgzI have now incorporated the \'git archive\' functionality into a single process that makes use of \'create_empty\' function and other features.If you want something that works with submodules this might be worth a go.Note:Assumptions:cd MASTER_DIR && tar -zcvf ../DEST_DIR/export.tar.gz --exclude=\'.git*\'\n  . && cd ../DEST_DIR/ && tar xvfz export.tar.gz && rm export.tar.gzThis will copy the files in a range of commits (C to G) to a tar file. Note: this will only get the files commited. Not the entire repository. Slightly modified from HereExample Commit HistoryA --> B --> C --> D --> E --> F --> G --> H --> Igit-diff-tree Manual Page-r --> recurse into sub-trees--no-commit-id --> git diff-tree outputs a line with the commit ID when applicable. This flag suppressed the commit ID output.--name-only --> Show only names of changed files.--diff-filter=ACMRT --> Select only these files. See here for full list of filesC..G --> Files in this range of commitsC~ --> Include files from Commit C. Not just files since Commit C.| xargs tar -rf myTarFile --> outputs to tarMy preference would actually be to have a dist target in your Makefile (or other build system) that exports a distributable archive of your code (.tar.bz2, .zip, .jar, or whatever is appropriate).  If you happen to be using GNU autotools or Perl\'s MakeMaker systems, I think this exists for you automatically.  If not, I highly recommend adding it.ETA (2012-09-06): Wow, harsh downvotes.  I still believe it is better to build your distributions with your build tools rather than your source code control tool.  I believe in building artifacts with build tools.  In my current job, our main product is built with an ant target.  We are in the midst of switching source code control systems, and the presence of this ant target means one less hassle in migration.Yes, this is a clean and neat command to archive your code without any git inclusion in the archive and is good to pass around without worrying about any git commit history.I needed this for a deploy script and I couldn\'t use any of the above mentioned approaches. Instead I figured out a different solution:Doing it the easy way, this is a function for .bash_profile, it directly unzips the archive on current location, configure first your usual [url:path]. NOTE: With this function you avoid the clone operation, it gets directly from the remote repo.Alias for .gitconfig, same configuration required (TAKE CARE executing the command inside .git projects, it ALWAYS jumps to the base dir previously as said here, until this is fixed I personally prefer the functionI think @Aredridel\'s post was closest, but there\'s a bit more to that - so I will add this here; the thing is, in svn, if you\'re in a subfolder of a repo, and you do:then svn will export all files that are under revision control (they could have also freshly Added; or Modified status) - and if you have other "junk" in that directory (and I\'m not counting .svn subfolders here, but visible stuff like .o files), it will not be exported; only those files registered by the SVN repo will be exported. For me, one nice thing is that this export also includes files with local changes that have not been committed yet; and another nice thing is that the timestamps of the exported files are the same as the original ones. Or, as svn help export puts it:To realize that git will not preserve the timestamps, compare the output of these commands (in a subfolder of a git repo of your choice):... and:... and I, in any case, notice that git archive causes all the timestamps of the archived file to be the same! git help archive says:git archive behaves differently when given a tree ID versus when given a commit ID or tag ID. In the first case the\n  current time is used as the modification time of each file in the archive. In the latter case the commit time as recorded\n  in the referenced commit object is used instead. ... but apparently both cases set the "modification time of each file"; thereby not preserving the actual timestamps of those files!So, in order to also preserve the timestamps, here is a bash script, which is actually a "one-liner", albeit somewhat complicated - so below it is posted in multiple lines:Note that it is assumed that you\'re exporting the contents in "current" directory (above, /media/disk/git_svn/subdir) - and the destination you\'re exporting into is somewhat inconveniently placed, but it is in DEST environment variable. Note that with this script; you must create the DEST directory manually yourself, before running the above script. After the script is ran, you should be able to compare:... and hopefully see the same timestamps (for those files that were under version control). Hope this helps someone,\nCheers!By far the easiest way i\'ve seen to do it (and works on windows as well) is git bundle:git bundle create /some/bundle/path.bundle --allSee this answer for more details: How can I copy my git repository from my windows machine to a linux machine via usb drive?If you need submodules as well, this should do the trick: https://github.com/meitar/git-archive-all.sh/wikii have the following utility function in my .bashrc file: it creates an archive of the current branch in a git repository.The option 1 sounds not too efficient. What if there is no space in the client to do a clone and then remove the .git folder?Today I found myself trying to do this, where the client is a Raspberry Pi with almost no space left. Furthermore, I also want to exclude some heavy folder from the repository.Option 2 and others answers here do not help in this scenario. Neither git archive (because require to commit a .gitattributes file, and I don\'t want to save this exclusion in the repository).Here I share my solution, similar to option 3, but without the need of git clone:Changing the rsync line for an equivalent line for compress will also work as a git archive but with a sort of exclusion option (as is asked here).This is my favorite solution:This will compare two different commits and export changed files as a tar.gz fileCheers!