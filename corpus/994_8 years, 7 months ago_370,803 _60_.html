When building console applications that take parameters, you can use the arguments passed to Main(string[] args). In the past I\'ve simply indexed/looped that array and done a few regular expressions to extract the values. However, when the commands get more complicated, the parsing can get pretty ugly.  So I\'m interested in:Assume the commands always adhere to common standards such as answered here.I would strongly suggest using NDesk.Options (Documentation) and/or Mono.Options (same API, different namespace).  An example from the documentation:I really like the Command Line Parser Library ( http://commandline.codeplex.com/ ). It has a very simple and elegant way of setting up parameters via attributes:The WPF TestApi library comes with one of the nicest command line parsers for C# development. I highly recommend looking into it, from Ivo Manolov\'s blog on the API:Look at http://github.com/mono/mono/tree/master/mcs/class/Mono.Options/Looks like everybody has their own pet command-line parsers, figure I had better add mine as well :).http://bizark.codeplex.com/This library contains a command-line parser that will initialize a class with the values from the command-line. It has a ton of features (I\'ve been building it up over many years).From the documentation...Command-line parsing in the BizArk framework has these key features:I wrote a C# command line argument parser a while back. Its at: http://www.codeplex.com/CommandLineArgumentsCLAP (command line argument parser) has a usable API and is wonderfully documented. You make a method, annotating the parameters.  https://github.com/adrianaisemberg/CLAPThere are numerous solutions to this problem. For completeness and to provide the alternative if someone desires I\'m adding this answer for two useful classes in my google code library.  The first is ArgumentList which is responsible only for parsing command line parameters.  It collects name-value pairs defined by switches \'/x:y\' or \'-x=y\' and also collects a list of \'unnamed\' entries.  It\'s basic usage is discussed here, view the class here.The second part of this is the CommandInterpreter which creates a fully-functional command-line application out of your .Net class.  As an example:With the above example code you can run the following:Program.exe DoSomething "string value" 5-- or --Program.exe dosomething /ivalue=5 -svalue:"string value"It\'s as simple as that or as complex as you need it to be.  You can review the source code, view the help, or download the binary.I like that one, because you can "define rules" for the arguments, needed or not,...or if you\'re a Unix guy, than you might like the GNU Getopt .NET port.You may like my one Rug.CmdEasy to use and expandable command line argument parser. Handles: Bool, Plus / Minus, String, String List, CSV, Enumeration. Built in \'/?\' help mode.Built in \'/??\' and \'/?D\' document generator modes.Edit: This is my project and as such this answer should not be seen as an endorsement from a third party. That said I do use it for every command line based program I write, it is open source and it is my hope that others may benefit from it. There is a command line argument parser at http://www.codeplex.com/commonlibrarynetIt can parse arguments using \n1. attributes\n2. explicit calls\n3. single line of multiple arguments OR string arrayIt can handle things like the following:-config:Qa -startdate:${today} -region:\'New York\' Settings01It\'s very easy to use.This is a handler I wrote based on the Novell Options class. This one is aimed at console applications that execute a while (input !="exit") style loop, an interactive console such as an FTP console for example.Example usage:And the source:My personal favorite is http://www.codeproject.com/KB/recipes/plossum_commandline.aspx by Peter Palotas:I recently came across The FubuCore Command line parsing implementation I really like it, the reasons being:Below is a simple example on how to use this. To illustrate the usage, I\'ve written a simple utility that has two commands: \n- add (adds an object to a list - an object consists of a name(string), value(int) and a boolean flag)\n- list (lists all the currently added objects)First of all, I wrote a Command class for the \'add\' command:This command takes a CommandInput instance as parameter, so I define that next:The next command is \'list\', which is implemented as follows:The \'list\' command takes no parameters, so I defined a NullInput class for this:All that\'s left now is to wire this up in the Main() method, like this:The program works as expected, printing hints about the correct usage in case any commands are invalid:And a sample usage for the \'add\' command:Powershell Commandlets.Parsing done by powershell based on attributes specified on the commandlets, support for validations, parameter sets, pipelining, error reporting, help, and best of all returning .NET objects for use in other commandlets.A couple links i found helpful getting started:C# CLI is a very simple command-line argument parsing library that I wrote. It\'s well-documented and open source.Genghis Command Line Parser  may be a little out of date, but it is very feature complete and works pretty well for me.I would suggest the open-source library CSharpOptParse.  It parses the command line and hydrates a user-defined .NET object with the command-line input.  I always turn to this library when writing a C# console application.Please use the .net port of the apache commons cli API. This works great.http://sourceforge.net/projects/dotnetcli/and the original API for concepts and introductionhttp://commons.apache.org/cli/A very simple easy to use ad hoc class for command line parsing, that supports default arguments.