I have always been of the belief that if a method can throw an exception then it is reckless not to protect this call with a meaningful try block.I just posted \'You should ALWAYS wrap calls that can throw in try, catch blocks.\' to this question and was told that it was \'remarkably bad advice\' - I\'d like to understand why.A method should only catch an exception when it can handle it in some sensible way.Otherwise, pass it on up, in the hope that a method higher up the call stack can make sense of it.As others have noted, it is good practice to have an unhandled exception handler (with logging) at the highest level of the call stack to ensure that any fatal errors are logged.As Mitch and others stated, you shouldn\'t catch an exception that you do not plan on handling in some way.  You should consider how the application is going to systematically handle exceptions when you are designing it.  This usually leads to having layers of error handling based on the abstractions - for example, you handle all SQL-related errors in your data access code so that the part of the application that is interacting with domain objects is not exposed to the fact that there is a DB under the hood somewhere.There are a few related code smells that you definitely want to avoid in addition to the "catch everything everywhere" smell."catch, log, rethrow": if you want scoped based logging, then write a class that emits a log statement in its destructor when the stack is unrolling due to an exception (ala std::uncaught_exception()).  All that you need to do is declare a logging instance in the scope that you are interested in and, voila, you have logging and no unnecessary try/catch logic."catch, throw translated": this usually points to an abstraction problem.  Unless you are implementing a federated solution where you are translating several specific exceptions into one more generic one, you probably have an unnecessary layer of abstraction... and don\'t say that "I might need it tomorrow"."catch, cleanup, rethrow": this is one of my pet-peeves.  If you see a lot of this, then you should apply Resource Acquisition is Initialization techniques and place the cleanup portion in the destructor of a janitor object instance.I consider code that is littered with try/catch blocks to be a good target for code review and refactoring.  It indicates that either exception handling is not well understood or the code has become an am≈ìba and is in serious need of refactoring.Because the next question is "I\'ve caught an exception, what do I do next?" What will you do? If you do nothing - that\'s error hiding and the program could "just not work" without any chance to find what happened. You need to understand what exactly you will do once you\'ve caught the exception and only catch if you know.You don\'t need to cover every block with try-catches because a try-catch can still catch unhandled exceptions thrown in functions further down the call stack.  So rather than have every function have a try-catch, you can have one at the top level logic of your application.  For example, there might be a SaveDocument() top-level routine, which calls many methods which call other methods etc.  These sub-methods don\'t need their own try-catches, because if they throw, it\'s still caught by SaveDocument()\'s catch.This is nice for three reasons: it\'s handy because you have one single place to report an error: the SaveDocument() catch block(s).  There\'s no need to repeat this throughout all the sub-methods, and it\'s what you want anyway: one single place to give the user a useful diagnostic about something that went wrong.Two, the save is cancelled whenever an exception is thrown.  With every sub-method try-catching, if an exception is thrown, you get in to that method\'s catch block, execution leaves the function, and it carries on through SaveDocument().  If something\'s already gone wrong you likely want to stop right there.Three, all your sub-methods can assume every call succeeds.  If a call failed, execution will jump to the catch block and the subsequent code is never executed.  This can make your code much cleaner.  For example, here\'s with error codes:Here\'s how that might be written with exceptions:Now it\'s much clearer what is happening.Note exception safe code can be trickier to write in other ways: you don\'t want to leak any memory if an exception is thrown.  Make sure you know about RAII, STL containers, smart pointers, and other objects which free their resources in destructors, since objects are always destructed before exceptions.Herb Sutter wrote about this problem here. For sure worth reading.\nA teaser:"Writing exception-safe code is fundamentally about writing \'try\' and \'catch\' in the correct places." Discuss.Put bluntly, that statement reflects a fundamental misunderstanding of exception safety. Exceptions are just another form of error reporting, and we certainly know that writing error-safe code is not just about where to check return codes and handle error conditions.Actually, it turns out that exception safety is rarely about writing \'try\' and \'catch\' -- and the more rarely the better. Also, never forget that exception safety affects a piece of code\'s design; it is never just an afterthought that can be retrofitted with a few extra catch statements as if for seasoning.As stated in other answers, you should only catch an exception if you can do some sort of sensible error handling for it.For example, in the question that spawned your question, the questioner asks whether it is safe to ignore exceptions for a lexical_cast from an integer to a string.  Such a cast should never fail.  If it did fail, something has gone terribly wrong in the program.  What could you possibly do to recover in that situation?  It\'s probably best to just let the program die, as it is in a state that can\'t be trusted.  So not handling the exception may be the safest thing to do.The best advice I\'ve heard is that you should only ever catch exceptions at points where you can sensibly do something about the exceptional condition, and that "catch, log and release" is not a good strategy (if occasionally unavoidable in libraries).If you always handle exceptions immediately in the caller of a method that can throw an exception, then exceptions become useless, and you\'d better use error codes.The whole point of exceptions is that they need not be handled in every method in the call chain.The advice my computer science professor gave me once was: "Use Try and Catch blocks only when it\'s not possible to handle the error using standard means."As an example, he told us that if a program ran into some serious issue in a place where it\'s not possible to do something like:Then you should be using try, catch blocks. While you can use exceptions to handle this, it\'s generally not recommended because exceptions are expensive performance wise.I agree with the basic direction of your question to handle as many exceptions as possible at the lowest level.Some of the existing answer go like "You don\'t need to handle the exception. Someone else will do it up the stack." To my experience that is a bad excuse to not think about exception handling at the currently developed piece of code, making the exception handling the problem of someone else or later.That problem grows dramatically in distributed development, where you may need to call a method implemented by a co-worker. And then you have to inspect a nested chain of method calls to find out why he/she is throwing some exception at you, which could have been handled much easier at the deepest nested method.If you want to test the outcome of every function, use return codes.  The purpose of Exceptions is so that you can test outcomes LESS often.  The idea is to separate exceptional (unusual, rarer) conditions out of your more ordinary code.  This keeps the ordinary code cleaner and simpler - but still able to handle those exceptional conditions.In well-designed code deeper functions might throw and higher functions might catch.  But the key is that many functions "in between" will be free from the burden of handling exceptional conditions at all.  They only have to be "exception safe", which does not mean they must catch.Besides the above advice, personally I use some try+catch+throw;  for the following reason:If you want to fix intermittent production issues easily then you should wrap every block of code in a try..catch block.  This basically instruments the code with the goal of providing extensive debug info allowing you to debug without a debugger in production.  Users don\'t have to email or chat with support and all the info needed to fix the issue is right there.  There is no need to reproduce issues.To work properly it needs to be combined with extensive logging that can capture the namespace/module, class name, method, inputs, and error message and store in a database so it can be aggregated to highlight which method fails the most so it can be fixed first.  Exceptions are 100 to 1000 times slower than normal code and should never be rethrown.  Also do not create an exception and throw it.  This is very distpruotive.  Exceptions are caught so the can be fixed with regular code.This technique was used to quickly stabilize a buggy app in a Fortune 500 company developed by 12 Devs over 2 years.   Using this I identified, fixed, build tests, and deployed 3000 fixes in 4 months in which case the system no longer reported any exceptions as all were handled.  This averages out to a fix every 15 minutes on average for 4 months.You have no need to cover up every part of your code inside try-catch. The main use of the try-catch block is to error handling and got bugs/exceptions in your program. Some usage of try-catch -