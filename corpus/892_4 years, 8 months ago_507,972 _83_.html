How can I send my $scope object from one controller to another using .$emit and .$on methods?It doesn\'t work the way I think it should. How do $emit and $on work?First of all, parent-child scope relation does matter. You have two possibilities to emit some event:I don\'t know anything about your controllers (scopes) relation, but there are several options:If scope of firstCtrl is parent of the secondCtrl scope, your code should\nwork by replacing $emit by $broadcast in firstCtrl:In case there is no parent-child relation between your scopes you\ncan inject $rootScope into the controller and broadcast the event\nto all child scopes (i.e. also secondCtrl).Finally, when you need to dispatch the event from child controller\nto scopes upwards you can use $scope.$emit. If scope of firstCtrl is parent of the secondCtrl scope:I would additionally suggest a 4th option as a better alternative to the proposed options by @zbynour. Use $rootScope.$emit rather than $rootScope.$broadcast regardless of the relationship between trasmitting and receiving controller. That way, the event remains within the set of $rootScope.$$listeners whereas with $rootScope.$broadcast the event propagates to all children scopes, most of which will probably not be listeners of that event anyway. And of course in the receiving controller\'s end you just use $rootScope.$on.For this option you must remember to destroy the controller\'s rootScope listeners:How can I send my $scope object from one controller to another using .$emit and .$on methods?You can send any object you want within the hierarchy of your app, including $scope.Here is a quick idea about how broadcast and emit work.Notice the nodes below; all nested within node 3. You use broadcast and emit when you have this scenario.Note: The number of each node in this example is arbitrary; it could easily be the number one; the number two; or even the number 1,348. Each number is just an identifier for this example. The point of this example is to show nesting of Angular controllers/directives.Check out this tree. How do you answer the following questions?Note: There are other ways to answer these questions, but here we\'ll discuss broadcast and emit. Also, when reading below text assume each number has it\'s own file (directive, controller) e.x. one.js, two.js, three.js.How does node 1 speak to node 3?In file one.jsIn file three.js - the uppermost node to all children nodes needed to communicate.How does node 2 speak to node 3?In file two.jsIn file three.js - the uppermost node to all children nodes needed to communicate.How does node 3 speak to node 1 and/or node 2?In file three.js - the uppermost node to all children nodes needed to communicate.In file one.js && two.js whichever file you want to catch the message or both.How does node 2 speak to node 1?In file two.jsIn file three.js - the uppermost node to all children nodes needed to communicate.In file one.jsHOWEVERWhen you have all these nested child nodes trying to communicate like this, you will quickly see many $on\'s, $broadcast\'s, and $emit\'s.Here is what I like to do.In the uppermost PARENT NODE ( 3 in this case... ), which may be your parent controller...So, in file three.jsNow in any of the child nodes you only need to $emit the message or catch it using $on.NOTE: It is normally quite easy to cross talk in one nested path without using $emit, $broadcast, or $on, which means most use cases are for when you are trying to get node 1 to communicate with node 2 or vice versa.How does node 2 speak to node 1?In file two.jsIn file three.js - the uppermost node to all children nodes needed to communicate.We already handled this one remember?In file one.jsYou will still need to use $on with each specific value you want to catch, but now you can create whatever you like in any of the nodes without having to worry about how to get the message across the parent node gap as we catch and broadcast the generic pushChangesToAllNodes.Hope this helps...To send $scope object from one controller to another using, I will discuss about $rootScope.$broadcast and $rootScope.$emit here as they are used most.Case 1:$rootScope.$broadcast:-$rootScope listener are not destroyed automatically. You need to destroy it using $destroy. It is better to use $scope.$on as listeners on $scope are destroyed automatically i.e. as soon as $scope is destroyed.Or,Case 2: $rootScope.$emit:The major difference in $emit and $broadcast is that $rootScope.$emit event must be listened using $rootScope.$on, because the emitted event never comes down through the scope tree..\nIn this case also you must destroy the listener as in the case of $broadcast.Edit:I prefer not to use $rootScope.$broadcast + $scope.$on but use\n  $rootScope.$emit+ $rootScope.$on. The $rootScope.$broadcast +\n  $scope.$on combo can cause serious performance problems. That is\n  because the event will bubble down through all scopes.Edit 2:The issue addressed in this answer have been resolved in angular.js\n  version 1.2.7. $broadcast now avoids bubbling over unregistered scopes\n  and runs just as fast as $emit.You must use $rootScope to send and capture events between controllers in same app. Inject $rootScope dependency to your controllers. Here is a working example.Events linked into $scope object just work in the owner controller. Communication between controllers is done via $rootScope or Services.You can call a service from your controller that returns a promise and then use it in your controller. And further use $emit or $broadcast to inform other controllers about it. \nIn my case, I had to make http calls through my service, so I did something like this : and my service looks like this This is my function:Below code shows the two sub-controllers from where the events are        dispatched upwards to parent controller (rootScope)  http://jsfiddle.net/shushanthp/zp6v0rut/I ended up adding an external EventEmitter library to project as a service and injecting it wherever I need. So I can "emit" and "on" anything anywhere without caring for scope inheritance. It is less trouble this way and certainly better performance. Also more readable to me.Wildcard support: EventEmitter2Good performance: eventemitter3Other alternative: DripScope(s) can be used to propagate, dispatch event to the scope children or parent.$emit - propagates the event to parent. $broadcast - propagates the event to children.\n$on - method to listen the events, propagated by $emit and $broadcast.example index.html:example app.js:Here u can test code:\nhttp://jsfiddle.net/zp6v0rut/41/According to the angularjs event docs the receiving end should be containing arguments with a structure like @params-- {Object} event being the event object containing info on the event-- {Object} args that are passed by the callee (Note that this can only be one so better to send in a dictionary object always)$scope.$on(\'fooEvent\', function (event, args) { console.log(args) });\nFrom your codeAlso if you are trying to get a shared piece of information to be available accross different controllers there is an another way to achieve that and that is angular services.Since the services are singletons information can be stored and fetched across controllers.Simply create getter and setter functions in that service, expose these functions, make global variables in the service and use them to store the infoThe Easiest way :HTMLJavaScript