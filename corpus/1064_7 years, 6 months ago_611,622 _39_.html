Is there an easy and straight-forward method to select elements based on their data attribute?  For example, select all anchors that has data attribute named customerID which has value of 22.  I am kind of hesitant to use rel or other attributes to store such information, but I find it much harder to select an element based on what data is stored in it.You should be able to omit the *, but if I recall correctly, depending on which jQuery version you\xe2\x80\x99re using, this might give faulty results.Note that for compatibility with the Selectors API (document.querySelector{,all}), the quotes around the attribute value (22) may not be omitted in this case.Also, if you work with data attributes a lot in your jQuery scripts, you might want to consider using the HTML5 custom data attributes plugin. This allows you to write even more readable code by using .dataAttr(\'foo\'), and results in a smaller file size after minification (compared to using .attr(\'data-foo\')).For people Googling and want more general rules about selecting with data-attributes:$("[data-test]") will select any element that merely has the data attribute (no matter the value of the attribute).  Including:$(\'[data-test~="foo"]\') will select any element where the data attribute contains foo but doesn\'t have to be exact, such as:$(\'[data-test="the_exact_value"]\') will select any element where the data attribute exact value is the_exact_value, for example:but notUsing $(\'[data-whatever="myvalue"]\') will select anything with html attributes, but in newer jQueries it seems that if you use $(...).data(...) to attach data, it uses some magic browser thingy and does not affect the html, therefore is not discovered by .find as indicated in the previous answer.Verify (tested with 1.7.2+) (also see fiddle):  (updated to be more complete)To select all anchors with the data attribute data-customerID==22, you should include the a to limit the scope of the search to only that element type. Doing data attribute searches in a large loop or at high frequency when there are many elements on the page can cause performance issues.I haven\'t seen a JavaScript answer without jQuery. Hopefully it helps someone.data attributes.querySelectorAll();via Jquery filter() method:http://jsfiddle.net/9n4e1agn/1/HTML:JavaScript:The construction like this: $(\'[data-XXX=111]\') isn\'t working in Safari 8.0. If you set data attribute this way: $(\'div\').data(\'XXX\', 111), it only works if you set data attribute directly in DOM like this: $(\'div\').attr(\'data-XXX\', 111).I think it\'s because jQuery team optimized garbage collector to prevent memory leaks and heavy operations on DOM rebuilding on each change data attribute.For this to work in Chrome the value must not have another pair of quotes. It only works, for example, like this:Native JS ExampleGet NodeList of elementshtml: <div data-id="container"></div>Get the first element html: <div id="container"></div>Target collection of nodes then selecthtml:Get multiple IDshtml:Get items where the value starts withIt\'s sometimes desirable to filter elements based on whether they have data-items attached to them programmatically (aka not via dom-attributes):The above works but is not very readable. A better approach is to use a pseudo-selector for testing this sort of thing:Now we can refactor the original statement to something more fluent and readable: