Question: is there a simple sh/bash/zsh/fish/... command to print the absolute path of whichever file I feed it?Usage case: I\'m in directory /a/b and I\'d like to print the full path to file c on the command-line so that I can easily paste it into another program: /a/b/c. Simple, yet a little program to do this could probably save me 5 or so seconds when it comes to handling long paths, which in the end adds up. So it surprises me that I can\'t find a standard utility to do this \xe2\x80\x94 is there really none?Here\'s a sample implementation, abspath.py:Try realpath.Try readlink which will resolve symbolic links:This is better than readlink -e FILE or realpath, because it works even if the file doesn\'t exist.Forget about readlink and realpath which may or may not be installed on your system.Expanding on dogbane\'s answer above here it is expressed as a function:you can then use it like this:The solution exploits the fact that the Bash built-in pwd command will print the absolute path of the current directory when invoked without arguments.It is portable and doesn\'t require neither readlink or realpath which often does not exist on a default install of a given Linux/Unix distro.As given above the function will fail and print on stderr if the directory path given does not exist. This may not be what you want. You can expand the function to handle that situation:Now it will return an empty string if one the parent dirs do not exist.Well, it does give an absolute path in that case, but not a minimal one. It will look like:If you want to resolve the \'..\' you will need to make the script like:This relative path to absolute path converter shell functionCode:Sample:Note: This is based on the answers from nolan6000 and bsingh, but fixes the file case.I also understand that the original question was about an existing command line utility. But since this seems to be THE question on stackoverflow for that including shell scripts that want to have minimal dependencies, I put this script solution here, so I can find it later :)The find command may helpLists all the files in or below the current directory with names matching the pattern.  You can simplify it if you will only get a few results (e.g. directory near bottom of tree containing few files), justI use this on Solaris 10, which doesn\'t have the other utilities mentioned.If you don\'t have readlink or realpath utilities than you can use following function which works in bash and zsh (not sure about the rest).This also works for nonexistent files (as does the python function os.path.abspath).Unfortunately abspath ./../somefile doesn\'t get rid of the dots.Here\'s a zsh-only function that I like for its compactness. It uses the \xe2\x80\x98A\xe2\x80\x99 expansion modifier  \xe2\x80\x94 see zshexpn(1).There is generally no such thing as the absolute path to a file (this statement means that there may be more than one in general, hence the use of the definite article the is not appropriate). An absolute path is any path that start from the root "/" and designates a file without ambiguity independently of the working directory.(see for example wikipedia).A relative path is a path  that is to be interpreted starting from another directory. It may be the working directory if it is a relative path being manipulated by an application\n(though not necessarily). When it is in a symbolic link in a directory, it is generally intended to be relative to that directory (though the user may have other uses in mind).Hence an absolute path is just a path relative to the root directory.A path (absolute or relative) may or may not contain symbolic links. If it does not, it is also somewhat impervious to changes in the linking structure, but this is not necessarily required or even desirable. Some people call canonical path ( or canonical file name or resolved path) an absolute path in which all symbolic links have been resolved, i.e. have been replaced by a path to whetever they link to. The commands realpath and readlink both look for a canonical path, but only realpath has an option for getting an absolute path without bothering to resolve symbolic links (along with several other options to get various kind of paths, absolute or relative to some directory).This calls for several remarks:Hence, even with the much more restrictive definition of canonical path, there may be several canonical paths to a file. This also means that the qualifier canonical is somewhat inadequate since it usually implies a notion of uniqueness.This expands a brief discussion of the topic in an answer to another similar question at Bash: retrieve absolute path given relativeMy conclusion is that realpath is better designed and much more flexible than readlink.\nThe only use of readlink that is not covered by realpath is the call without option returning the value of a symbolic link.I have placed the following script on my system & I call it as a bash alias for when I want to quickly grab the full path to a file in the current dir:I am not sure why, but, on OS X when called by a script "$PWD" expands to the absolute path. When the find command is called on the command line, it doesn\'t. But it does what I want... enjoy.For directories dirname gets tripped for ../ and returns ./.nolan6000\'s function can be modified to fix that:This makes up for the shortcomings of realpath, store it in a shell script fullpath. You can now call:This is not an answer to the question, but for those who does scripting:it handles / .. ./ etc correctly. I also seems to work on OSXAn alternative to get the absolute path in Ruby:realpath() {ruby -e "require \'Pathname\'; puts Pathname.new(\'$1\').realpath.to_s";}Works with no arguments (current folder) and relative and absolute file or folder path as agument.The dogbane answer with the description what is coming on:Explanation:Hey guys I know it\'s an old thread but I am just posting this for reference to anybody else who visited this like me. If i understood the question correctly, I think the locate $filename command. It displays the absolute path of the file supplied, but only if it exists.