How do people deal with persistent storage for your docker containers? I am currently using this approach: build the image, e.g. for Postgres, and then start the container withIMHO, that has the drawback, that I must not ever (by accident) delete container "c0dbc34fd631".Another idea would be to mount host volumes "-v" into the container, however, the userid within the container does not necessarily match the userid from the host, and then permissions might be messed up.Note: Instead of --volumes-from \'cryptic_id\' you can also use --volumes-from my-data-container where my-data-container is a name you assigned to a data-only container, e.g. docker run --name my-data-container ... (see accepted answer)Use volume APIthis means that the data only container pattern must be abandoned in favour of the new volumes.Actually the volume API is only a better way to achieve what was the data-container pattern.If you create a container with a -v volume_name:/container/fs/path docker will automatically create a named volume for you that can:The new volume api adds a useful command that let you identify dangling volumes:And then remove it through its name:as @mpugach underlines in the comments you can get rid of all the dangling volumes with a nice one liner:The approach that seems to work best for production is to use a data only container.The data only container is run on a barebone image and actually does nothing except exposing\na data volume.Then you can run any other container to have access to the data container volumes:In this blog post there is a good description of the so called container as volume pattern which clarifies the main point of having data only containers.Docker documentation has now the DEFINITIVE description of the container as volume/s pattern.Following is backup/restore procedure for Docker 1.8.x and belowBACKUP:RESTORE:Here is a nice article from the excellent Brian Goff explaining why it is good to use the same image for a container and a data container.In Docker release v1.0, binding a mount of a file or directory on the host machine can be done by the given command:The above volume could be used as a persistent storage on the host running docker.As of docker-compose 1.6, there is now improved support for data volumes in docker Compose. The following compose file will create a data image which will persist between restarts (or even removal) of parent containers:Here is the blog announcement: https://blog.docker.com/2016/02/compose-1-6/Here\'s an example compose file:As far as I can understand: This will create a data volume container (db_data) which will persist between restarts. If you run: docker volume ls you should see your volume listed:You can get some more details about the data volume:Some testing:Notes:You can also specify various drivers in the volumes block. e.g.: You could specify the flocker driver for db_data:Disclaimer: This approach is promising, and I\'m using it successfully in a development environment. I would be apprehensive to use this in production just yet! In case it is not clear from Update 5 of the selected answer, as of Docker 1.9, you can create volumes that can exist without being associated with a specific container, thus making the "data-only container" pattern obsolete.See https://github.com/docker/docker/issues/17798I think the Docker maintainers realized the data-only container pattern was a bit of a design smell and decided to make volumes a separate entity that can exist without an associated container.While this is still a part of docker that needs some work, you should put the volume in the Dockerfile with the VOLUME instruction so you don\'t need to copy the volumes from another container. That will make your containers less inter-dependent and you don\'t have to worry about the deletion of one container affecting another.@tommasop\'s answer is good, and explains some of the mechanics of using data-only containers. But as someone who initially thought that data containers were silly when one could just bind mount a volume to the host (as suggested by several other answers), but now realizes that in fact data-only containers are pretty neat, I can suggest my own blog post on this topic: https://medium.com/@ramangupta/why-docker-data-containers-are-good-589b3c6c749eSee also: my answer to the question "What is the (best) way to manage permissions for docker shared volumes" for an example of how to use data containers to avoid problems like permissions and uid/gid mapping with the host.To address one of the OPs original concerns: that the data container must not be deleted. Even if the data container is deleted, the data itself will not be lost as long as any container has a reference to that volume i.e. any container that mounted the volume via --volumes-from. So unless all the related containers are stopped and deleted (one could consider this the equivalent of an accidental rm -fr /) the data is safe. You can always recreate the data container by doing --volumes-from any container that has a reference to that volume.As always, make backups though!UPDATE: Docker now has volumes that can be managed independently of containers, which further makes this easier to manage.If you want to move your volumes around you should also look at https://github.com/clusterhq/flockerfrom the README: Flocker is a data volume manager and multi-host Docker cluster management tool. With it you can control your data using the same tools you use for your stateless applications by harnessing the power of ZFS on Linux. This means that you can run your databases, queues and key-value stores in Docker and move them around as easily as the rest of your app.When using docker-compose, simply attach a data volume i.e.Depends on your scenario (this isn\'t really suitable for a prod environment) but here is one way: http://txt.fliglio.com/2013/11/creating-a-mysql-docker-container/this gist of it is, use a directory on your host for data persistence.I recently wrote about a potential solution and an application demonstrating the technique. I find it to be pretty efficient during development and in production. Hope it helps or sparks some ideas.Repo: https://github.com/LevInteractive/docker-nodejs-example\nArticle: http://lev-interactive.com/2015/03/30/docker-load-balanced-mongodb-persistence/There are several levels of managing persistent data, depending on your needs:I\'m just using a predefined directory on the host to persist data for Postgres. Also, this way it is possible to migrate existing Postgres installations to Docker container easily: https://crondev.com/persistent-postgresql-inside-docker/My solution is to get use of the new docker cp, which is now able to copy data out from containers, not matter if it\'s running or not and share a host volume to the exact same location where the database app creating it\'s db files inside the container. This double solution works without a data-only container, straight from the original database container.So my systemd init script taking the job of backuping the database into an archive on the host. I placed a timestamp in the filename to never rewrite a file.It\'s doing it on the ExecStartPre:And doing the same thing on ExecStopPost too:Plus I exposed a folder from the host as a volume to the exact same location where the database is stored:It works great on my VM (I building a LEMP stack for myself): https://github.com/DJviolin/LEMPBut I just don\'t know is it a "bulletproof" solution when your life depends on it actually (for example: webshop with transactions in any possible miliseconds)?At 20:20 from this official Docker keynote video, the presenter does the same thing with the db: https://www.youtube.com/watch?v=klzLdzpPcQw"For the database we have a volume, so we can make sure that, as the database goes up and down, we don\'t loose data, when the database container stopped."Use persistent volume claim from Kubernetes, which is a docker container management & scheduling tool http://kubernetes.io/docs/user-guide/persistent-volumes/The advantage of using Kubernetes for this purpose are that 