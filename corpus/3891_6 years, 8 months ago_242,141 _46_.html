Task: Print numbers from 1 to 1000 without using any loop or conditional statements. Don\'t just write the printf() or cout statement 1000 times.How would you do that using C or C++?Compile time recursion! :PThis one actually compiles to assembly that doesn\'t have any conditionals:This version of the above in standard C, since it doesn\'t rely on arithmetic on function pointers:I\'m surprised nobody seems to have posted this -- I thought it was the most obvious way. 1000 = 5*5*5*8.Looks like it doesn\'t need to use loopsHere are three solutions that I know. The second might be argued though.[ Edit: (1) and (4) can be used for compile time constants only, (2) and (3) can be used for runtime expressions too â€” end edit. ]I\'m not writing the printf statement 1000 times!You\'re welcome ;)It doesn\'t print all the numbers, but it does "Print numbers from 1 to 1000."  Ambiguous question for the win! :)Trigger a fatal error! Here\'s the file, countup.c:Compile, then execute on a shell prompt:This does indeed print the numbers from 1 to 1000, without any loops or conditionals!Using system commands:Untested, but should be vanilla standard C:A bit boring compared to others here, but probably what they\'re looking for.The task never specified that the program must terminate after 1000.(Can be shortened to this if you run ./a.out with no extra params)Easy as pie! :P We can launch 1000 threads, each printing one of the numbers. Install OpenMPI, compile using mpicxx -o 1000 1000.cpp and run using mpirun -np 1000 ./1000. You will probably need to increase your descriptor limit using limit or ulimit. Note that this will be rather slow, unless you have loads of cores!Of course, the numbers won\'t necessarily be printed in order, but the question doesn\'t require them to be ordered.With plain C:Of course, you can implement the same idea for other bases (2: print2 print4 print8 ...) but the number 1000 here suggested base 10. You can also reduce a little the number of lines adding intermediate functions: print2() print10() print20() print100() print200() print1000() and other equivalent alternatives.Just use std::copy() with a special iterator.Function pointer (ab)use. No preprocessor magic to increase output. ANSI C.Ugly C answer (unrolled for only one stack frame per power of 10):Stack overflow:This is for an 8MB stack. Each function invocation appears to take about 32 bytes (hence the 32 * 1000). But then when I ran it I only got to 804 (hence the 196 * 32; perhaps the C runtime has other parts in the stack that you have to deduct also).Fun with function pointers (none of that new-fangled TMP needed):As a side note: I took the prohibition against conditionals to extend to logical and relational operators as well.  If you allow logical negation, the recursive call can be simplified to:I feel this answer will be very simple and easy to understand.I missed all the fun, all the good C++ answers have already been posted !This is the weirdest thing I could come up with, I wouldn\'t bet it\'s legal C99 though :pAnother one, with a little cheating :Last idea, same cheat :Easy as pie:method of execution:The specification does not say that the sequence must be generated inside the code :)More preprocessor abuse:I feel so dirty; I think I\'ll go shower now.If POSIX solutions are accepted:Since there is no restriction on bugs..Or even better(?),