I need to find a bottleneck and need to accurately as possible measure time.Is the following code snippet the best way to measure the performance?No, it\'s not. Use the Stopwatch (in System.Diagnostics)Stopwatch automatically checks for the existence of high-precision timers.It is worth mentioning that DateTime.Now often is quite a bit slower than DateTime.UtcNow due to the work that has to be done with timezones, DST and such.DateTime.UtcNow typically has a resolution of 15Â ms. See John Chapman\'s blog post about DateTime.Now precision for a great summary.Interesting trivia: The stopwatch falls back on DateTime.UtcNow if your hardware doesn\'t support a high frequency counter. You can check to see if Stopwatch uses hardware to achieve high precision by looking at the static field Stopwatch.IsHighResolution.If you want something quick and dirty I would suggest using Stopwatch instead for a greater degree of precision.  Alternatively, if you need something a little more sophisticated you should probably consider using a 3rd party profiler such as ANTS.This article says that first of all you need to compare three alternatives, Stopwatch, DateTime.Now AND DateTime.UtcNow.It also shows that in some cases (when performance counter doesn\'t exist) Stopwatch is using DateTime.UtcNow + some extra processing. Because of that it\'s obvious that in that case DateTime.UtcNow is the best option (because other use it + some processing)However, as it turns out, the counter almost always exists - see Explanation about high-resolution performance counter and its existence related to .NET Stopwatch?.Here is a performance graph. Notice how low performance cost UtcNow has compared to alternatives:The X axis is sample data size, and the Y axis is the relative time of the example.One thing Stopwatch is better at is that it provides higher resolution time measurements. Another is its more OO nature. However, creating an OO wrapper around UtcNow can\'t be hard.It\'s useful to push your benchmarking code into a utility class/method. The StopWatch class does not need to be Disposed or Stopped on error.  So, the simplest code to time some action isSample calling codeHere is the extension method versionAnd sample calling codeThe stopwatch functionality would be better (higher precision).  I\'d also recommend just downloading one of the popular profilers, though (DotTrace and ANTS are the ones I\'ve used the most... the free trial for DotTrace is fully functional and doesn\'t nag like some of the others).Use the System.Diagnostics.Stopwatch class. Ditto Stopwatch, it is way better.Regarding performance measuring you should also check whether your "// Some Execution Process" is a very short process.Also bear in mind that the first run of your "// Some Execution Process" might be way slower than subsequent runs.I typically test a method by running it 1000 times or 1000000 times in a loop and I get much more accurate data than running it once.These are all great ways to measure time, but that is only a very indirect way to find bottleneck(s).The most direct way to find a bottneck in a thread is to get it running, and while it is doing whatever makes you wait, halt it with a pause or break key. Do this several times. If your bottleneck takes X% of time, X% is the probability that you will catch it in the act on each snapshot.Here\'s a more complete explanation of how and why it works@Sean ChambersFYI, the .NET Timer class is not for diagnostics, it generates events at a preset interval, like this (from MSDN):So this really doesn\'t help you know how long something took, just that a certain amount of time has passed.The timer is also exposed as a control in System.Windows.Forms... you can find it in your designer tool box in VS05/VS08This is the correct way:For more information go through Use Stopwatch instead of DataTime for getting accurate performance counter.Visual Studio Team System has some features that may help with this problem. Essentially you can write unit tests and mix them in different scenarios to run against your software as part of a stress or load test. This may help to identify areas of code that impact your applications performance the most.Microsoft\' Patterns and Practices group has some guidance in Visual Studio Team System Performance Testing Guidance.I just found a post in Vance Morrison\'s blog about a CodeTimer class he wrote that makes using StopWatch easier and does some neat stuff on the side.I\'ve done very little of this sort of performance checking (I tend to just think "this is slow, make it faster") so I have pretty much always gone with this.A google does reveal a lot of resources/articles for performance checking.Many mention using pinvoke to get performance information. A lot of the materials I study only really mention using perfmon..Seen the talks of StopWatch.. Nice! I have learned something :)This looks like a good articleThe way I use within my programs is using the StopWatch class as shown here.This is not professional enough:A more reliable version is:In my real code, I will add GC.Collect call to change managed heap to a known state, and add Sleep call so that different intervals of code can be easily separated in ETW profile.