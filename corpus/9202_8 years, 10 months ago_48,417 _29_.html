What are the benefits of having a member variable declared as read only?  Is it just protecting against someone changing during the lifecycle of the class or are there any compiler speed improvements due to this keywordThe readonly keyword is used to declare a member variable a constant, but allows the value to be calculated at runtime.  This differs from a constant declared with the const modifier, which must have its value set at compile time.  Using readonly you can set the value of the field either in the declaration, or in the constructor of the object that the field is a member of.Also use it if you don\'t want to have to recompile external DLLs that reference the constant (since it gets replaced at compile time).I don\'t believe there are any performance gains from using a readonly field.  It\'s simply a check to ensure that once the object is fully constructed, that field cannot be pointed to a new value. However "readonly" is very different from other types of read-only semantics because it\'s enforced at runtime by the CLR.  The readonly keyword compiles down to .initonly which is verifiable by the CLR. The real advantage of this keyword is to generate immutable data structures.  Immutable data structures by definition cannot be changed once constructed.  This makes it very easy to reason about the behavior of a structure at runtime.  For instance, there is no danger of passing an immutable structure to another random portion of code.  They can\'t changed it ever so you can program reliably against that structure.Here is a good entry about one of the benefits of immutability: ThreadingThere are no apparent performance benefits to using readonly, at least none that I\'ve ever seen mentioned anywhere. It\'s just for doing exactly as you suggest, for preventing modification once it has been initialised.So it\'s beneficial in that it helps you write more robust, more readable code. The real benefit of things like this come when you\'re working in a team or for maintenance. Declaring something as readonly is akin to putting a contract for that variable\'s usage in the code. Think of it as adding documentation in the same way as other keywords like internal or private, you\'re saying "this variable should not be modified after initialisation", and moreover you\'re enforcing it.So if you create a class and mark some member variables readonly by design, then you prevent yourself or another team member making a mistake later on when they\'re expanding upon or modifying your class. In my opinion, that\'s a benefit worth having (at the small expense of extra language complexity as doofledorfer mentions in the comments).To put it in very practical terms:If you use a const in dll A and dll B references that const, the value of that const will be compiled into dll B. If you redeploy dll A with a new value for that const, dll B will still be using the original value.If you use a readonly in dll A and dll B references that readonly, that readonly will always be looked up at runtime. This means if you redeploy dll A with a new value for that readonly, dll B will use that new value. There is a potential case where the compiler can make a performance optimization based on the presence of the readonly keyword.This only applies if the readonly field is also marked as static. In that case, the JIT compiler can assume that this static field will never change. The JIT compiler can take this into account when compiling the methods of the class.Typical example: your class could have a static readonly IsDebugLoggingEnabled field that is initialized in the constructor (e.g. based on a configuration file). Once the actual methods are JIT compiled, the compiler may ommit whole parts of the code when debug logging is not enabled.I have not checked if this optimization is actually implemented in the current version of the JIT compiler, so this is just speculation.Keep in mind that readonly only applies to the value itself, so if you\'re using a reference type readonly only protects the reference from being change. The state of the instance is not protected by readonly. Don\'t forget there is a workaround to get the the readonly fields set outside of any constructors using out params.  A little messy but:Further discussion here: http://www.adamjamesnaylor.com/2013/01/23/Setting-Readonly-Fields-From-Chained-Constructors.aspxBe careful with private readonly arrays. If these are exposed a client as an object (you might do this for COM interop as I did) the client can manipulate array values. Use the Clone() method when returning an array as an object.If you have a pre defined or pre calculated value that needs to remain same through out the program then you should use constant but if you have a value that needs to be provided at the runtime but once assigned should remain same throughout the program u should use readonly. for example if you have to assign the program start time or you have to store a user provided value at the object initialization and you have to restrict it from further changes you should use readonly.readonly can be initialized at declaration or get its value from the constructor only. Unlike const it has to be initialized and declare at the same time.\nreadonly has everything const has, plus constructor initializationcode https://repl.it/HvRU/1There can be a performance benefit in WPF, as it removes the need for expensive DependencyProperties. This can be especially useful with collectionsAnother interesting part of usage of readonly marking can be protecting field from initialization in singleton. for example in code from csharpindepth:readonly plays small role of protecting field Singleton from being initialized twice. Another detail is that for mentioned scenario you can\'t use const because const forces creation during compile time, but singleton makes creation at run time.