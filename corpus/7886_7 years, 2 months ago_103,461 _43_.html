I\'m looking to make a service which I can use to make calls to a web-based REST API.Basically I want to start a service on app init then I want to be able to ask that service to request a url and return the results.  In the meantime I want to be able to display a progress window or something similar.I\'ve created a service currently which uses IDL, I\'ve read somewhere that you only really need this for cross app communication, so think these needs stripping out but unsure how to do callbacks without it.  Also when I hit the post(Config.getURL("login"), values) the app seems to pause for a while (seems weird - thought the idea behind a service was that it runs on a different thread!)Currently I have a service with post and get http methods inside, a couple of AIDL files (for two way communication), a ServiceManager which deals with starting, stopping, binding etc to the service and I\'m dynamically creating a Handler with specific code for the callbacks as needed.I don\'t want anyone to give me a complete code base to work on, but some pointers would be greatly appreciated.Code in (mostly) full:A couple of AIDL files:and and the service manager:Service init and bind:service function call:If your service is going to be part of you application then you are making it way more complex than it needs to be. Since you have a simple use case of getting some data from a RESTful Web Service, you should look into ResultReceiver and IntentService. This Service + ResultReceiver pattern works by starting or binding to the service with startService() when you want to do some action. You can specify the operation to perform and pass in your ResultReceiver (the activity) through the extras in the Intent.In the service you implement onHandleIntent to do the operation that is specified in the Intent. When the operation is completed you use the passed in ResultReceiver to send a message back to the Activity at which point onReceiveResult will be called.So for example, you want to pull some data from your Web Service.I know you mentioned you didn\'t want a code base but the open source Google I/O 2010 app uses a service in this way I am describing.Updated to add sample code:The activity.The Service:ResultReceiver extension - edited about to implement MyResultReceiver.ReceiverAlso when I hit\n  the post(Config.getURL("login"),\n  values) the app seems to pause for a\n  while (seems weird - thought the idea\n  behind a service was that it runs on a\n  different thread!)No you have to create a thread yourself, a Local service runs in the UI thread by default.Developing Android REST client applications has been an awesome resource for me. The speaker does not show any code, he just goes over design considerations and techniques in putting together a rock solid Rest Api in android. If your a podcast kinda person or not, I\'d recommend giving this one at least one listen but, personally I\'ve listened to it like 4 or five times thus far and I\'m probably going to listen to it again.Developing Android REST client applications\nAuthor: Virgil Dobjanschi\nDescription:This session will present architectural considerations for developing RESTful applications on the Android platform. It focuses on design patterns, platform integration and performance issues specific to the Android platform.And there are so many considerations I really hadn\'t made in the first version of my api that I\'ve had to refactorI know @Martyn does not want full code, but I think this annotation its good for this question:10 Open Source Android Apps which every Android developer must look intoFoursquared for Android is open-source, and have an interesting code pattern interacting with the foursquare REST API.Just wanted to point you all in the direction of an standalone class I rolled that incorporates all of the functionality. http://github.com/StlTenny/RestServiceIt executes the request as non-blocking, and returns the results in an easy to implement handler. Even comes with an example implementation.I would highly recommend the REST client Retrofit.I have found this well written blog post extremely helpful, it also contains simple example code.\nThe author uses Retrofit to make the network calls and Otto to implement a data bus pattern:http://www.mdswanson.com/blog/2014/04/07/durable-android-rest-clients.htmlLets say I want to start the service on an event - onItemClicked() of a button. The Receiver mechanism would not work in that case because :-\na) I passed the Receiver to the service (as in Intent extra) from onItemClicked()\nb) Activity moves to the background. In onPause() I set the receiver reference within the ResultReceiver to null to avoid leaking the Activity.\nc) Activity gets destroyed.\nd) Activity gets created again. However at this point the Service will not be able to make a callback to the Activity as that receiver reference is lost.\nThe mechanism of a limited broadcast or a PendingIntent seems to be more usefull in such scenarios- refer to Notify activity from serviceNote that the solution from Robby Pond is somehow lacking: in this way you only allow todo one api call at a time since the IntentService only handles one intent at a time. Often you want to perform parallel api calls. If you want todo this you have to extend Service instead of IntentService and create your own thread.Also when I hit the post(Config.getURL("login"), values) the app seems to pause for a while (seems weird - thought the idea behind a service was that it runs on a different thread!)In this case its better to use asynctask, which runs on a different thread and return result back to the ui thread on completion.There is another approach here which basically helps you to forget about the whole management of the requests. It is based on an async queue method and a callable/callback based response. \nThe main advantage is that by using this method you\'ll be able to make the whole process (request, get and parse response, sabe to db) completely transparent for you. Once you get the response code the work is already done. After that you just need to make a call to your db and you are done.\nIt helps as well with the problematic of what happens when your activity is not active.\nWhat will happen here is that you\'ll have all your data saved in your local database but the response won\'t be processed by your activity, that\'s the ideal way.I wrote about a general approach here \nhttp://ugiagonzalez.com/2012/07/02/theres-life-after-asynctasks-in-android/I\'ll be putting specific sample code in upcoming posts.\nHope it helps, feel free to contact me for sharing the approach and solving potential doubts or issues.Robby provides a great answer, though I can see you still looking for more information. I implemented REST api calls the easy BUT wrong way. It wasn\'t until watching this Google I/O  video that I understood where I went wrong. It\'s not as simple as putting together an AsyncTask with a HttpUrlConnection get/put call.