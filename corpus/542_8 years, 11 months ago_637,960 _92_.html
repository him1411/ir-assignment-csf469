I\'m using $.post() to call a servlet using Ajax and then using the resulting HTML fragment to replace a div element in the user\'s current page. However, if the session times out, the server sends a redirect directive to send the user to the login page. In this case, jQuery is replacing the div element with the contents of the login page, forcing the user\'s eyes to witness a rare scene indeed. How can I manage a redirect directive from an Ajax call with jQuery 1.2.6?I read this question and implemented the approach that has been stated regarding setting the response status code to 278 in order to avoid the browser transparently handling the redirects. Even though this worked, I was a little dissatisfied as it is a bit of a hack.After more digging around, I ditched this approach and used JSON. In this case, all responses to ajax requests have the status code 200 and the body of the response contains a JSON object that is constructed on the server. The javascript on the client can then use the JSON object to decide what it needs to do.I had a similar problem to yours. I perform an ajax request that has 2 possible responses: one that redirects the browser to a new page and one that replaces an existing HTML form on the current page with a new one. The jquery code to do this looks something like:The JSON object "data" is constructed on the server to have 2 members: data.redirect and data.form. I found this approach to be much better.I solved this issue by:Adding a custom header to the response:Binding a JavaScript function to the ajaxSuccess event and checking to see if the header exists:No browsers handle 301 and 302 responses correctly. And in fact the standard even says they should handle them "transparently" which is a MASSIVE headache for Ajax Library vendors. In Ra-Ajax we were forced into using HTTP response status code 278 (just some "unused" success code) to handle transparently redirects from the server...This really annoys me, and if someone here have some "pull" in W3C I would appreciate that you could let W3C know that we really need to handle 301 and 302 codes ourselves...! ;)The solution that was eventually implemented was to use a wrapper for the callback function of the Ajax call and in this wrapper check for the existence of a specific element on the returned HTML chunk. If the element was found then the wrapper executed a redirection. If not, the wrapper forwarded the call to the actual callback function. For example, our wrapper function was something like:Then, when making the Ajax call we used something like:This worked for us because all Ajax calls always returned HTML inside a DIV element that we use to replace a piece of the page. Also, we only needed to redirect to the login page.I like Timmerz\'s method with a slight twist of lemon. If you ever get returned contentType of text/html when you\'re expecting JSON, you are most likely being redirected. In my case, I just simply reload the page, and it gets redirected to the login page. Oh, and check that the jqXHR status is 200, which seems silly, because you are in the error function, right? Otherwise, legitimate error cases will force an iterative reload (oops)Use the low-level $.ajax() call:Try this for a redirect:I just wanted to share my approach as this might it might help someone:I basically included a JavaScript module which handles the authentication stuff like displaying the username and also this case handling the redirect to the login page.My scenario: We basically have an ISA server in between which listens to all requests and responds with a 302 and a location header to our login page.In my JavaScript module my initial approach was something likeThe problem (as many here already mentioned) is that the browser handles the redirect by itself wherefore my ajaxComplete callback got never called, but instead I got the response of the already redirected Login page which obviously was a status 200. The problem: how do you detect whether the successful 200 response is your actual login page or just some other arbitrary page??Since I was not able to capture 302 redirect responses, I added a LoginPage header on my login page which contained the url of the login page itself. In the module I now listen for the header and do a redirect:...and that works like charm :). You might wonder why I include the url in the LoginPage header...well basically because I found no way of determining the url of GET resulting from the automatic location redirect from the xhr object...I know this topic is old, but I\'ll give yet another approach I\'ve found and previously described here. Basically I\'m using ASP.MVC with WIF (but this is not really important for the context of this topic - answer is adequate no matter which frameworks are used. The clue stays unchanged - dealing with issues related to authentication failures while performing ajax requests). The approach shown below can be applied to all ajax requests out of the box (if they do not redefine beforeSend event obviously).Before any ajax request is performed CheckPulse method is invoked (the controller method which can be anything simplest):If user is not authenticated (token has expired) such method cannot be accessed (protected by Authorize attribute). Because the framework handles authentication, while token expires, it puts http status 302 to the response. If you don\'t want your browser to handle 302 response transparently, catch it in Global.asax and change response status - for example to 200 OK. Additionally, add header, which instructs you to process such response in special way (later at the client side):Finally at the client side check for such custom header. If present - full redirection to logon page should be done (in my case window.location is replaced by url from request which is handled automatically by my framework).I think a better way to handle this is to leverage the existing HTTP protocol response codes, specifically 401 Unauthorized.Here is how I solved it:Client side: Bind to the ajax eventsIMO this is more generic and you are not writing some new custom spec/header.  You also should not have to modify any of your existing ajax calls.Edit: Per @Rob\'s comment below, 401 (the HTTP status code for authentication errors) should be the indicator. See 403 Forbidden vs 401 Unauthorized HTTP responses for more detail. With that being said some web frameworks use 403 for both authentication AND authorization errors - so adapt accordingly. Thanks Rob.Another solution I found (especially useful if you want to set a global behaviour) is to use the $.ajaxsetup() method together with the statusCode property. Like others pointed out, don\'t use a redirect statuscode (3xx), instead use a 4xx statuscode and handle the redirect client-side.Replace 400 with the statuscode you want to handle. Like already mentioned 401 Unauthorized could be a good idea. I use the 400 since it\'s very unspecific and I can use the 401 for more specific cases (like wrong login credentials). So instead of redirecting directly your backend should return a 4xx error-code when the session timed out and you you handle the redirect client-side. Works perfect for me even with frameworks like backbone.jsThis problem may appear then using ASP.NET MVC RedirectToAction method. To prevent form displaying the response in div you can simply do some kind of ajax response filter for incomming responses with $.ajaxSetup. If the response contains MVC redirection you can evaluate this expression on JS side. Example code for JS below:If data is: "window.location = \'/Acount/Login\'" above filter will catch that and evaluate to make the redirection instead of letting the data to be displayed.I resolved this issue like this:Add a middleware to process response, if it is a redirect for an ajax request, change the response to a normal response with the redirect url.Then in ajaxComplete, if the response contains redirect, it must be a redirect, so change the browser\'s location.Putting together what Vladimir Prudnikov and Thomas Hansen said:This makes the browser treat the response as a success, and hand it to your Javascript.Most of the given solutions use a workaround, using an extra header or an inappropiate HTTP code. Those solutions will most probably work but feel a bit \'hacky\'. I\'ve come up with another solution.We\'re using WIF which is configured to redirect (passiveRedirectEnabled="true") on a 401 response. The redirect is usefull when handling normal requests but won\'t work for AJAX requests (since browsers won\'t execute the 302/redirect). Using the following code in your global.asax you can disable the redirect for AJAX requests:This allows you to return 401 responses for AJAX requests, which your javascript can then handle by reloading the page. Reloading the page  will throw a 401 which will be handled by WIF (and WIF will redirect the user to the login page).An example javascript to handle 401 errors:I have a simple solution that works for me, no server code change needed...just add a tsp of nutmeg...I check the presence of html tag, but you can change the indexOf to search for whatever unique string exists in your login page...TryPut it on the login page. If it was loaded in a div on the main page, it will redirect til the login page. "#site" is a id of a div which is located on all pages except login page.I solved this by putting the following in my login.php page.While the answers seem to work for people if you\'re using Spring Security I have found extending LoginUrlAuthenticationEntryPoint and adding specific code to handle AJAX more robust.  Most of the examples intercept all redirects not just authentication failures.  This was undesirable for the project I work on.  You may find the need to also extend ExceptionTranslationFilter and override the "sendStartAuthentication" method to remove the caching step if you don\'t want the failed AJAX request cached.Example AjaxAwareAuthenticationEntryPoint:}Sources:\n1, 2Some might find the below useful:I wanted clients to be redirected to the login page for any rest-action that is sent without an authorization token. Since all of my rest-actions are Ajax based, I needed a good generic way to redirect to the login page instead of handling the Ajax success function.This is what I\'ve done:On any Ajax request my server will return a Json 200 response "NEED TO AUTHENTICATE" (if the client needs to authenticate).Simple example in Java (server side):In my Javascript I\'ve added the following code:And that\'s about it.in the servlet you should put \nresponse.setStatus(response.SC_MOVED_PERMANENTLY);\nto send the \'301\' xmlHttp status you need for a redirection...and in the $.ajax function you should not use the .toString() function..., justif (xmlHttp.status == 301) {\n    top.location.href = \'xxxx.jsp\';\n}the problem is it is not very flexible, you can\'t decide where you want to redirect..redirecting through the servlets should be the best way. but i still can not find the right way to do it.If you also want to pass the values then you can also set the session variables and access \nEg: \nIn your jsp you can write And then you can store this temp value in your javascript variable and play around I didn\'t have any success with the header solution - they were never picked up in my ajaxSuccess / ajaxComplete method. I used Steg\'s answer with the custom response, but I modified the JS side some. I setup a method that I call in each function so I can use standard $.get and $.post methods.Example of it in use...Finally, I solve the problem by adding a custom HTTP Header. Just before response for every request in server side, i add the current requested url to response\'s header.My application type on server is Asp.Net MVC, and it has a good place to do it. in Global.asax i implemented the Application_EndRequest event so:It works perfect for me! Now in every response of the JQuery $.post i have the requested url and also other response headers which comes as result of POST method by status 302, 303 ,... .and other important thing is that there is no need to modify code on server side nor client side.and the next is the ability to get access to the other information of post action such errors, messages, and ..., In this way.I posted this, maybe help someone :)I just wanted to latch on to any ajax requests for the entire page. @SuperG got me started. Here is what I ended up with:I wanted to specifically check for certain http status codes to base my decision on. However, you can just bind to ajaxError to get anything other than success (200 only perhaps?) I could have just written:I was having this problem on a django app I\'m tinkering with (disclaimer: I\'m tinkering to learn, and am in no way an expert). What I wanted to do was use jQuery ajax to send a DELETE request to a resource, delete it on the server side, then send a redirect back to (basically) the homepage. When I sent HttpResponseRedirect(\'/the-redirect/\') from the python script, jQuery\'s ajax method was receiving 200 instead of 302. So, what I did was to send a response of 300 with:Then I sent/handled the request on the client with jQuery.ajax like so:Maybe using 300 isn\'t "right", but at least it worked just like I wanted it to.PS :this was a huge pain to edit on the mobile version of SO. Stupid ISP put my service cancellation request through right when I was done with my answer! You can also hook XMLHttpRequest send prototype. This will work for all sends (jQuery/dojo/etc) with one handler.I wrote this code to handle a 500 page expired error, but it should work just as well to trap a 200 redirect. Ready the wikipedia entry on XMLHttpRequest onreadystatechange about the meaning of readyState.Additionally you will probably want to redirect user to the given in headers URL. So finally it will looks like this:UPD: Opps. Have the same task, but it not works. Doing this stuff. I\'ll show you solution when I\'ll find it.this worked for me: on success, ajax will get the same status code the browser gets from the server and execute it.