In the code below, the AngularJS $http method calls the URL, and submits the xsrf object as a "Request Payload" (as described in the Chrome debugger network tab). The jQuery $.ajax method does the same call, but submits xsrf as "Form Data".How can I make AngularJS submit xsrf as form data instead of a request payload?The following line needs to be added to the $http object that is passed:And the data passed should be converted to a URL-encoded string:So you have something like:From: https://groups.google.com/forum/#!msg/angular/5nAedJ1LyO0/4Vj_72EZcDsJIf you do not want to use jQuery in the solution you could try this. Solution nabbed from here https://stackoverflow.com/a/1714899/1784301The continued confusion surrounding this issue inspired me to write a blog post about it. The solution I propose in this post is better than your current top rated solution because it does not restrict you to parametrizing your data object for $http service calls; i.e. with my solution you can simply continue to pass actual data objects to $http.post(), etc. and still achieve the desired result.Also, the top rated answer relies on the inclusion of full jQuery in the page for the $.param() function, whereas my solution is jQuery agnostic, pure AngularJS ready.http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/Hope this helps.I took a few of the other answers and made something a bit cleaner, put this .config() call on the end of your angular.module in your app.js:As of AngularJS v1.4.0, there is a built-in $httpParamSerializer service that converts any object to a part of a HTTP request according to the rules that are listed on the docs page.It can be used like this:Remember that for a correct form post, the Content-Type header must be changed. To do this globally for all POST requests, this code (taken from Albireo\'s half-answer) can be used:To do this only for the current post, the headers property of the request-object needs to be modified:You can define the behavior globally:So you don\'t have to redefine it every time:As a workaround you can simply make the code receiving the POST respond to application/json data.  For PHP I added the code below, allowing me to POST to it in either form-encoded or JSON.These answers look like insane overkill, sometimes, simple is just better:You can try with below solutionThere is a really nice tutorial that goes over this and other related stuff - Submitting AJAX Forms: The AngularJS Way. Basically, you need to set the header of the POST request to indicate that you are sending form data as a URL encoded string, and set the data to be sent the same formatNote that jQuery\'s param() helper function is used here for serialising the data into a string, but you can do this manually as well if not using jQuery.Please checkout!\nhttps://uncorkedstudios.com/blog/multipartformdata-file-upload-with-angularjsCreate an adapter service for post:Use it in your controllers or whatever:For Symfony2 users:If you don\'t want to change anything in your javascript for this to work you can do these modifications in you symfony app:Create a class that extends Symfony\\Component\\HttpFoundation\\Request class:Now use you class in app_dev.php (or any index file that you use)Just set Content-Type is not enough, url encode form data before send.\n$http.post(url, jQuery.param(data))I\'m currently using the following solution I found in the AngularJS google group.Note that if you\'re using PHP, you\'ll need to use something like Symfony 2 HTTP component\'s Request::createFromGlobals() to read this, as $_POST won\'t automatically loaded with it.AngularJS is doing it right as it doing the following content-type inside the http-request header:If you are going with php like me, or even with Symfony2 you can simply extend your server compatibility for the json standard like described here: http://silex.sensiolabs.org/doc/cookbook/json_request_body.htmlThe Symfony2 way (e.g. inside your DefaultController):The advantage would be, that you dont need to use jQuery param and you could use AngularJS its native way of doing such requests.Complete answer (since angular 1.4). You need to include de dependency $httpParamSerializerIn your app config -With your resource request -This isn\'t a direct answer, but rather a slightly different design direction:Do not post the data as a form, but as a JSON object to be directly mapped to server-side object, or use REST style path variableNow I know neither option might be suitable in your case since you\'re trying to pass a XSRF key. Mapping it into a path variable like this is a terrible design:Because by nature you would want to pass xsrf key to other path too, /login, /book-appointment etc. and you don\'t want to mess your pretty URLInterestingly adding it as an object field isn\'t appropriate either, because now on each of json object you pass to server you have to add the fieldYou certainly don\'t want to add another field on your server-side class which does not have a direct semantic association with the domain object.In my opinion the best way to pass your xsrf key is via a HTTP header. Many xsrf protection server-side web framework library support this. For example in Java Spring, you can pass it using X-CSRF-TOKEN header.Angular\'s excellent capability of binding JS object to UI object means we can get rid of the practice of posting form all together, and post JSON instead. JSON can be easily de-serialized into server-side object and support complex data structures such as map, arrays, nested objects, etc.How do you post array in a form payload? Maybe like this:or this:Both are poor design..The only thin you have to change is to use property "params" rather than "data" when you create your $http object:In the example above clients[i] is just JSON object (not serialized in any way). If you use "params" rather than "data" angular will serialize the object for you using $httpParamSerializer: https://docs.angularjs.org/api/ng/service/$httpParamSerializerUse AngularJS $http service and use its post method or configure $http function.