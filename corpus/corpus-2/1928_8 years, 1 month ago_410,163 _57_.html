I have a simple key/value list in JSON being sent back to ASP.NET via POST. Example:I AM NOT TRYING TO DESERIALIZE INTO STRONGLY-TYPED .NET OBJECTSI simply need a plain old Dictionary(Of String, String), or some equivalent (hash table, Dictionary(Of String, Object), old-school StringDictionary--hell, a 2-D array of strings would work for me.I can use anything available in ASP.NET 3.5, as well as the popular Json.NET (which I\'m already using for serialization to the client).Apparently neither of these JSON libraries have this forehead-slapping obvious capability out of the box--they are totally focused on reflection-based deserialization via strong contracts.Any ideas?Limitations:Json.NET does this...More examples: Serializing Collections with Json.NETI did discover .NET has a built in way to cast the JSON string into a Dictionary<String, Object> via the System.Web.Script.Serialization.JavaScriptSerializer type in the 3.5 System.Web.Extensions assembly. Use the method DeserializeObject(String). I stumbled upon this when doing an ajax post (via jquery) of content type \'application/json\' to a static .net Page Method and saw that the method (which had a single parameter of type Object) magically received this Dictionary.For those searching the internet and stumbling upon this post, I wrote a blog post on how to use the JavaScriptSerializer class.Read more...\nhttp://procbits.com/2011/04/21/quick-json-serializationdeserialization-in-c/Here is an example:Tried to not use any external JSON implementation so i deserialised like this:I had same problem so I wrote this my self. This solution is differentiated from other answers because it can deserialize in to multiple levels. Just send json string in to deserializeToDictionary function it will return non strongly-typed Dictionary<string, object> object.Ex: This will return Dictionary<string, object> object of a Facebook JSON response.Note: hometown further deserilize into a Dictionary<string, object>\n  object.If you\'re after a lightweight, no-added-references kind of approach, maybe this bit of code I just wrote will work (I can\'t 100% guarantee robustness though).[I realise that this violates the OP Limitation #1, but technically, you didn\'t write it, I did]Edit: This works, but the accepted answer using Json.NET is much more straightforward. Leaving this one in case someone needs BCL-only code.It\xe2\x80\x99s not supported by the .NET framework out of the box. A glaring oversight \xe2\x80\x93 not everyone needs to deserialize into objects with named properties. So I ended up rolling my own:Called with:Sorry for the mix of C# and VB.NET\xe2\x80\xa6I added a check for null values in the JSON to the other answer I had same problem so I wrote this my self. This solution is\ndifferentiated from other answers because it can deserialize in to\nmultiple levels. Just send json string in to deserializeToDictionary function it\nwill return non strongly-typed Dictionary<string, object> object.Ex: This will return Dictionary<string, object> object of a Facebook\nJSON response.Note: hometown further deserialize into a Dictionary<string, object> object.I just needed to parse a nested dictionary, likewhere JsonConvert.DeserializeObject doesn\'t help. I found the following approach:The SelectToken lets you dig down to the desired field. You can even specify a path like "x.y.z" to step further down into the JSON object.I\'ve added upon the code submitted by jSnake04 and Dasun herein. I\'ve added code to create lists of objects from JArray instances. It has two-way recursion but as it is functioning on a fixed, finite tree model, there is no risk of stack overflow unless the data is massive. Mark Rendle posted this as a comment, I wanted to post it as an answer since it\'s the only solution that has worked so far to return the success and the error-codes json results from the Google reCaptcha response.Thanks again, Mark!It seems all of these answers here just assume you can get that little string out of a bigger object... for people looking to simply deserealize a large object with such a dictionary somewhere inside the mapping, and who are using the System.Runtime.Serialization.Json DataContract system, here\'s a solution:An answer on gis.stackexchange.com had this interesting link. I had to recover it with archive.org, but it offers a pretty much perfect solution: a custom IDataContractSurrogate class in which you implement exactly your own types. I was able to expand it easily.I made a bunch of changes in it, though. Since the original source is no longer available, I\'ll post the entire class here:To add new supported types to the class, you just need to add your class, give it the right constructors and functions (look at SurrogateDictionary for an example), make sure it inherits JsonSurrogateObject, and add its type mapping to the KnownTypes dictionary. The included SurrogateDictionary can serve as basis for any Dictionary<String,T> types where T is any type that does deserialize correctly.Calling it is really simple:Note that for some reason this thing has trouble using key strings which contain spaces; they were simply not present in the final list. Might just be it\'s simply against json specs and the api I was calling was poorly implemented, mind you; I dunno. Anyway, I solved this by regex-replacing them with underscores in the raw json data and fixing the dictionary after the deserialization.I just implemented this in RestSharp. This post was helpful to me.Besides the code in the link, here is my code. I now get a Dictionary of results when I do something like this:Be mindful of the sort of JSON you\'re expecting - in my case, I was retrieving a single object with several properties. In the attached link, the author was retrieving a list.My approach directly deserializes to IDictionary, without JObject or ExpandObject in between. The code uses converter, which is basically copied from ExpandoObjectConverter class found in JSON.NET sourcecode, but using IDictionary instead of ExpandoObject.Usage:Code:Annoyingly enough, if you want to use the default model binders, it looks like you will have to use numerical index values like a form POST.See the following excerpt from this article http://msdn.microsoft.com/en-us/magazine/hh781022.aspx:Though it\xe2\x80\x99s somewhat counterintuitive, JSON requests have the same\n  requirements\xe2\x80\x94they, too, must adhere to the form post naming syntax.\n  Take, for example, the JSON payload for the previous UnitPrice\n  collection. The pure JSON array syntax for this data would be\n  represented as:However, the default value providers and model binders require the\n  data to be represented as a JSON form post:The complex object collection scenario is perhaps one of the most\n  widely problematic scenarios that developers run into because the\n  syntax isn\xe2\x80\x99t necessarily evident to all developers. However, once you\n  learn the relatively simple syntax for posting complex collections,\n  these scenarios become much easier to deal with.I would suggest using System.Runtime.Serialization.Json that is part of .NET 4.5.Then use it like this:If you don\'t want or can\'t add a large third-party library like Json.NET (for example, because you\'re using Unity3D), I really recommend taking a look at MiniJSON. Short and sweet code, easy to extend if there\'s something more you need.You could use Tiny-JSON