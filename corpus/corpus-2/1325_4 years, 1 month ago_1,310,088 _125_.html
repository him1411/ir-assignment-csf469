A common problem that new Java developers experience is that their programs fail to run with the error message:  Could not find or load main class ...What does this mean, what causes it, and how should you fix it?First of all, you need to understand the correct way to launch a program using the java (or javaw) command.The normal syntax1 is this:where <option> is a command line option (starting with a "-" character), <class-name> is a fully qualified Java class name, and <argument> is an arbitrary command line argument that gets passed to your application.\n1 - There is a second syntax for "executable" JAR files which I will describe at the bottom.The fully qualified classname is conventionally written as you would in Java source code; e.g.However some versions of the java command allow you to use slashes instead of periods; e.g.which (confusingly) looks like a file pathname, but isn\'t one.  Note that the term fully qualified classname is standard Java terminology ... not something I just made up to confuse you :-)Here is an example of what a java command should look like:The above is going to cause the java command to do the following:When you get the message "Could not find or load main class ...", that means that the first step has failed.  The java command was not able to find the class.  And indeed, the "..." in the message will be the fully qualified class name that java is looking for. So why might it be unable to find the class?  The first likely cause is that you may have provided the wrong class name.  (Or ... the right class name, but in the wrong form.)   Considering the example above, here a variety of wrong ways to specify the class name:Example #1 - a simple class name:When the class is declared in a package such as com.acme.example, then you must use the full classname including the package name in the java command; e.g. Example #2 - a filename or pathname rather than a class name:Example #3 - a class name with the casing incorrect:Example #4 - a typoExample #5 - a source filenameExample #6 - you forgot the class name entirelyThe second likely cause is that the class name is correct, but that the java command cannot find the class.  To understand this, you need to understand the concept of the "classpath".  This is explained well by the Oracle documentation:So ... if you have specified the class name correctly, the next thing to check is that you have specified the classpath correctly:When you put a directory on the classpath, it notionally corresponds to the root of the qualified name space.  Classes are located in the directory structure beneath that root, by mapping the fully qualified name to a pathname.  So for example, if "/usr/local/acme/classes" is on the class path, then when the JVM looks for a class called com.acme.example.Foon, it will look for a ".class" file with this pathname:If you had put "/usr/local/acme/classes/com/acme/example" on the classpath, then the JVM wouldn\'t be able to find the class.The classpath needs to include all of the other (non-system) classes that your application depends on.  (The system classes are located automatically, and you rarely need to concern yourself with this.)  For the main class to load correctly, the JVM needs to find:(Note: the JLS and JVM specifications allow some scope for a JVM to load classes "lazily", and this can affect when a classloader exception is thrown.)It occasionally happens that someone puts a source code file into the\nthe wrong folder in their source code tree, or they leave out the package declaration.  If you do this in an IDE, the IDE\'s compiler will tell you about this immediately.  Similarly if you use a decent Java build tool, the tool will run javac in a way that will detect the problem.  However, if you build your Java code by hand, you can do it in such a way that the compiler doesn\'t notice the problem, and the resulting ".class" file is not in the place that you expect it to be.The alternative syntax used for "executable" JAR files is as follows:e.g.In this case the name of the entry-point class (i.e. com.acme.example.ListUser) and the classpath are specified in the MANIFEST of the JAR file.A typical Java IDE has support for running Java applications in the IDE JVM itself or in a child JVM.  These are generally immune from this particular exception, because the IDE uses its own mechanisms to construct the runtime classpath, identify the main class and create the java command line.However it is still possible for this exception to occur, if you do things behind the back of the IDE.  For example, if you have previously set up an Application Launcher for your Java app in Eclipse, and you then moved the JAR file containing the "main" class to a different place in the file system without telling Eclipse, Eclipse would unwittingly launch the JVM with an incorrect classpath.In short, if you get this problem in an IDE, check for things like stale IDE state, broken project references or broken launcher configurations.It is also possible for an IDE to simply get confused.  IDE\'s are hugely complicated pieces of software comprising many interacting parts.  Many of these parts adopt various caching strategies in order to make the IDE as a whole responsive.  These can sometimes go wrong, and one possible symptom is problems when launching applications.  If you suspect this could be happening, it is worth restarting your IDE.If your source code name is HelloWorld.java, your compiled code will be HelloWorld.class.You will get that error if you call it using:Instead, use this:If your classes are in packages then you have to cd to the main directory and run using the full name of the class (packageName.MainClassName).Example:My classes are in here:The full name of my main class is:So I cd back to the main directory:Then issue the java command:If your main method is in the class under a package, you should run it over the hierarchical directory.Assume there is a source code file (Main.java):For running this code, you should place Main.Class in the package like directory ./com/test/Main.Java. And in the root directory use java com.test.Main.When the same code works on one PC, but it shows the error in another, the best solution I have ever found is compiling like the following:What helped me was specifying the classpath on the command line, for example:Create a new folder, C:\\tempCreate file Temp.java in C:\\temp, with the following class in it:Open a command line in folder C:\\temp, and write the following command to compile the Temp class:Run the compiled Java class, adding the -classpath option to let JRE know where to find the class:According to the error message ("Could not find or load main class"), there are two categories of problems:Main class could not be found when there is typo or wrong syntax in the fully qualified class name or it does not exist in the provided classpath.Main class could not be loaded when the class cannot be initiated, typically the main class extends another class and that class does not exist in the provided classpath.For example:If camel-spring is not included, this error will be reported.Sometimes what might be causing the issue has nothing to do with the main class, and I had to find this out the hard way. It was a referenced library that I moved, and it gave me the:Could not find or load main class xxx LinuxI just deleted that reference, added it again, and it worked fine again.I had such an error in this case:It works with ; for Windows and : for Unix:In my case, error appeared because I had supplied the source file name instead of the class name. We need to supply the class name containing the main method to the interpreter.Try -Xdiag.Steve C\'s answer covers the possible cases nicely, but sometimes to determine whether the class could not be found or loaded might not be that easy. Use java -Xdiag (since jdk 7). This prints out nice stacktrace which provides a hint to what the message Could not find or load main class message means.For instance, it can point you to other classes used by the main class that could not be found and prevented the main class to be loaded.In this instance you have:Could not find or load main class ?classpathIt\'s because you are using "-classpath", but the dash is not the same dash used by java on the command prompt. I had this issue copying and pasting from Notepad to cmd.First set the path using this command;Then you need to load the program. Type "cd (folder name)" in the stored drive and compile it. For Example, if my program stored on the D drive, type "D:" press enter and type " cd (folder name)".What fixed the problem in my case was:Right click on the project/class you want to run, then Run As->Run Configurations. Then you should either fix your existing configuration or add new in the following way:open the Classpath tab, click on the Advanced... button then add bin folder of your project.Use this commandexample if your classname is Hello.class created from Hello.java then use below commandIf your file Hello.java is inside package com.demo then use below commandwith jdk 8 many time it happens that class file is present in same folder but java command expects classpath and for this reason we add -cp . to take current folder as reference for classpath.You really need to do this from the src folder. There you type the following command line:Let\'s say your class is called CommandLine.class, and the code looks like this:Then you should cd to the src folder and the command you need to run would look like this:And the output on the command line would be:I spent a decent amount of time trying to solve this problem. I thought that I was somehow setting my classpath incorrectly but the problem was that I typed:  java -cp C:/java/MyClasses C:/java/MyClasses/utilities/myapp/Cool\n  instead of:\n  java -cp C:/java/MyClasses utilities/myapp/Cool\n  I thought the meaning of fully qualified meant to include the full path name instead of the full package name.By default, Java uses ., the geek letter for "current working directory" (you now know one letter in the geek alphabet right?) as the default CLASSPATH. What this means is that when you type a command at the prompt e.g. java MyClass, the command is interpreted as if you had type java -cp . MyClass. Did you see that dot between -cp and MyClass? (cp is short for the longer classpath option)This is sufficient for most cases and things seems to work just fine until at some time you try to add a directory to your CLASSPATH. In most cases when programmers need to do this, they just run a command like set CLASSPATH=path\\to\\some\\dir. This command creates a new environment variable called CLASSPATH having the value path\\to\\some\\dir or replaces its value with path\\to\\some\\dir if CLASSPATH was already set before.When this is done, you now have a CLASSPATH environment variable and Java no longer uses it\'s default classpath (.) but the one you\'ve set. So the next day you open your editor, write some java program, cd to the directory where you saved it, compile it, and try to run it with the command java MyClass, and you are greeted with a nice output: Could not find or load main class ... (If your commands were working well before and you are now getting this output, then this might be the case for you).What happens is that when you run the command java MyClass, Java searches for the class file named MyClass in the directory or directories that you have set in your CLASSPATH and not your current working directory so it doesn\'t find your class file there and hence complains.What you need to do is add . to your class path again which can be done with the command set CLASSPATH=%CLASSPATH%;. (notice the dot after the semicolon). In plain english this command says "Pick what was initially the value of CLASSPATH (%CLASSPATH%), add . to it (;.) and assign the result back to CLASSPATH".And viola, you are once again able to use your command java MyClass as usual.Thanks.When running the java with the -cp option as advertised in Windows PowerShell you may get an error that looks something like:In order to for PowerShell to accept the command, the arguments of the -cp option must be contained in quotes as in:Forming the command this way should allow Java process the classpath arguments correctly.This might help you if your case is specifically like mine:  as a beginner I also ran into this problem when I tried to run a java program. I compiled it like this: \njavac HelloWorld.javaand tried to run also with the same extensionjava Helloworld.javaWhen I removed the .java and rewrote the command like this java HelloWorld, \nThe Program ran perfectly. :)Sometimes, in some online compilers that you might have tried you will get this error if you don\'t write public class [Classname] but just class [Classname]. In Java, when you sometimes run the JVM from the command line using the java executable and are trying to start a program from a class file with public static void main (PSVM), you might run into the below error even though the classpath parameter to the JVM is accurate and the class file is present on the classpath:This happens if the class file with PSVM could not be loaded. One possible reason for that is that the class may be implementing an interface or extending another class that is not on the classpath. Normally if a class is not on the classpath, the error thrown indicates as such. But, if the class in use is extended or implemented, java is unable to load the class itself.Reference: https://www.computingnotes.net/java/error-main-class-not-found-or-loaded/I got this error after doing mvn eclipse:eclipse\nThis messed up my .classpath file a little bit.Had to change the lines in .classpath fromto This is a specific case, but since I came to this page looking for a solution and didn\'t find it, I\'ll add it here.Windows (tested with 7) doesn\'t accept special characters (like \xc3\xa1) in class and package names. Linux does, though.I found this out when I built a .jar in NetBeans and tried to run it in command line. It ran in NetBeans but not in command line.On Windows put .; at the CLASSPATH value in the beginning.The . (dot) means "look in the current directory". This is a permanent solution.Also you can set it "one time" with set CLASSPATH=%CLASSPATH%;.. This will last as long as your cmd window is open.I was unable to solve this problem with the solutions stated here (although the answer stated has, no doubt, cleared my concepts). I faced this problem two times and each time I have tried different solutions (in the Eclipse IDE).Sometimes it\'s better to remove the added JAR files and add again with proper build helps. For me it has been a regular issue, and I followed the same approach:All answers here are directed towards Windows users it seems. For Mac, the classpath separator is :, not ;. As an error setting the classpath using ; is not thrown then this can be a difficult to discover if coming from Windows to Mac.Here is corresponding Mac command:Where in this example the package is com.test and a lib folder is also to be included on classpath.Class file location:         C:\\test\\com\\companyFile Name:                   Main.classFully qualified class name:  com.company.MainCommand line command: Note here that class path does NOT include \\com\\companyif you use maven to build the jar please making sure to specify the main class in the pom.xml