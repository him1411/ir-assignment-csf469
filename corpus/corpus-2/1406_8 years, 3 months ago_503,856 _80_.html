What\'s the real difference between declaring an array like this:andThere is a difference, but there is no difference in that example.Using the more verbose method: new Array() does have one extra option in the parameters: if you pass a number to the constructor, you will get an array of that length:To illustrate the different ways to create an array:The difference between creating an array with the implicit array and the array constructor is subtle but important.When you create an array usingYou\'re telling the interpreter to create a new runtime array. No extra processing necessary at all. Done.If you use:You\'re telling the interpreter, I want to call the constructor "Array" and generate an object. It then looks up through your execution context to find the constructor to call, and calls it, creating your array.You may think "Well, this doesn\'t matter at all. They\'re the same!". Unfortunately you can\'t guarantee that.Take the following example:In the above example, the first call will alert \'SPARTA\' as you\'d expect. The second will not. You will end up seeing undefined. You\'ll also note that b contains all of the native Array object functions such as push, where the other does not.While you may expect this to happen, it just illustrates the fact that [] is not the same as new Array().It\'s probably best to just use [] if you know you just want an array. I also do not suggest going around and redefining Array...Cheers!Oddly enough, new Array(size) is almost 2x faster than [] in Chrome, and about the same in FF and IE (measured by creating and filling an array). It only matters if you know the approximate size of the array. If you add more items than the length you\'ve given, the performance boost is lost.For more information, the following page describes why you never need to use new Array():http://yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/You never need to use new Object() in\n  JavaScript. Use the object literal {}\n  instead. Similarly, don\xe2\x80\x99t use new\n  Array(), use the array literal []\n  instead. Arrays in JavaScript work\n  nothing like the arrays in Java, and\n  use of the Java-like syntax will\n  confuse you.Do not use new Number, new String, or\n  new Boolean. These forms produce\n  unnecessary object wrappers. Just use\n  simple literals instead.Also check out the comments - the new Array(length) form does not serve any useful purpose (at least in today\'s implementations of JavaScript).There is a huge difference that no one mentioned.You may think the new Array(2) is equivalent to [undefined, undefined] cuz we haveBUT IT\'S NOT!Let\'s try map():See? It\'s different! But why is that?According to ES6 Spec 22.1.1.2, Array(len) only create a new array with length set to len and nothing more. Thus there is no real element inside the new array. And map, according to spec 22.1.3.15 would firstly check HasProperty but turns out the array hasn\'t:That\'s why you can not expect any iteration functions work the same to new Array(len).BTW, Safari and Firefox have a much better expression to this:And I have submitted an issue to Chrome to ask them to fix this confusing log:\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=732021The first one is the default object constructor call. You can use it\'s parameters if you want.The second one gives you the ability to create not empty array:In order to better understand [] and new Array():The above result is from Google Chrome console on Windows 7.Here is a piece of JavaScript code that will verify that both declarations lead to the same type:I can explain in a more specific way starting with this example that\'s based on Fredrik\'s good one.I just added another value to the arrays, and made four alerts:\nThe first and second are to give us the value stored in each array, to be sure about the values. They will return the same!\nNow try the third one, it returns false, that\'s because JS treats test1 as a VARIABLE with a data type of array, and it treats test2 as an OBJECT with the functionality of an array, and\n  there are few slight differences here.The first difference is when we call test1 it calls a variable without thinking, it just returns the values that are stored in this variable disregarding its data type!\nBut, when we call test2 it calls the Array() function and then it stores our "Pushed" values in its "Value" property, and the same happens when we alert test2, it returns the "Value" property of the array object.So when we check if test1 equals test2 of course they will never return true, one is a function and the other is a variable (with a type of array), even if they have the same value!To be sure about that, try the 4th alert, with the .value added to it; it will return true. In this case we tell JS "Disregarding the type of the container, whether was it function or variable, please compare the values that are stored in each container and tell us what you\'ve seen!" that\'s exactly what happens.I hope I said the idea behind that clearly, and sorry for my bad English.The first one is the default object constructor call.mostly used for dynamic values.the second array is used when creating static valuesThere is no big difference, they basically do  the same thing but doing them in different ways, but read on, look at this statement at W3C:andThe two examples above do exactly the same. There is no need to use\n  new Array(). For simplicity, readability and execution speed, use the\n  first one (the array literal method).But at the same time, creating new array using new Array syntax considered as a bad practice:Avoid new Array()There is no need to use the JavaScript\'s built-in array constructor\n  new Array().\n  Use [] instead.\n  These two different statements both create a new empty array named\n  points:These two different statements both create a new array containing 6\n  numbers:The new keyword only complicates the code. It can also produce some\n  unexpected results:What if I remove one of the elements?So basically not considered as the best practice, also there is one minor difference there, you can pass length to new Array(length) like this, which also not a recommended way.The difference of usingOrAs been discussed enough in this question. I would like to add the speed issue - the current fastest way, on google chrome is the second one.But pay attention, these things tend to change a lot with updates. Also the run time will differ between different browsers.For example - the 2nd option that i mentioned, runs at 2 million [ops/second] on chrome, but if you\'d try it on mozilla dev. you\'d get a surprisingly higher rate of 23 million.Anyway, I\'d suggest you check it out, every once in a while, on different browsers (and machines), using site as such As I know the diference u can find the slice(or the other funcitons of Array) like code1.and code2 show u Array and his instances:code1:code2:conclusion:as u can see [] and new Array() create a new instance of Array.And they all get the prototype functions from Array.prototypeThey are just different instance of Array.so this explain why\n[] != []:)I\'ve incurred in a weird behaviour using []. We have Model "classes" with fields initialised to some value. E.g.: I found that when the fields are initialised with [] then it would be shared by all Model objects. Making changes to one affects all others.This doesn\'t happen initialising them with new Array(). Same for the initialisation of Objects ({} vs new Object())TBH I am not sure if its a problem with the framework we were using (Dojo)I\'ve found one difference between the two constructions that bit me pretty hard.Let\'s say I have:In real life, if I do this:What I end up with is this:I don\'t know what the language specification says is supposed to happen, but if I want my two objects to have unique property arrays in my objects, I have to use new Array().Using the Array constructor makes a new array of the desired length and populates each of the indices with undefined, the assigned an array to a variable one creates the indices that you give it info for.