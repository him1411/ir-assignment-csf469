I am not able to understand the differences between std::string and std::wstring. I know wstring supports wide characters such as Unicode characters. I have got the following questions:std::string is a basic_string templated on a char, and std::wstring on a wchar_t.char is supposed to hold a character, usually a 1-byte character.\nwchar_t is supposed to hold a wide character, and then, things get tricky: On Linux, a wchar_t is 4-bytes, while on Windows, it\'s 2-bytesThe problem is that neither char nor wchar_t is directly tied to unicode.Let\'s take a Linux OS: My Ubuntu system is already unicode aware. When I work with a char string, it is natively encoded in UTF-8 (i.e. Unicode string of chars). The following code:outputs the following text:You\'ll see the "ol\xc3\xa9" text in char is really constructed by four chars: 110, 108, 195 and 169 (not counting the trailing zero). (I\'ll let you study the wchar_t code as an exercise)So, when working with a char on Linux, you should usually end up using Unicode without even knowing it. And as std::string works with char, so std::string is already unicode-ready.Note that std::string, like the C string API, will consider the "ol\xc3\xa9" string to have 4 characters, not three. So you should be cautious when truncating/playing with unicode chars because some combination of chars is forbidden in UTF-8.On Windows, this is a bit different. Win32 had to support a lot of application working with char and on different charsets/codepages produced in all the world, before the advent of Unicode.So their solution was an interesting one: If an application works with char, then the char strings are encoded/printed/shown on GUI labels using the local charset/codepage on the machine. For example, "ol\xc3\xa9" would be "ol\xc3\xa9" in a french-localized Windows, but would be something diff\xc3\xa9rent on an cyrillic-localized Windows ("ol\xd0\xb9" if you use Windows-1251). Thus, "historical apps" will usually still work the same old way.For Unicode based applications, Windows uses wchar_t, which is 2-bytes wide, and is encoded in UTF-16, which is Unicode encoded on 2-bytes characters (or at the very least, the mostly compatible UCS-2, which is almost the same thing IIRC).Applications using char are said "multibyte" (because each glyph is composed of one or more chars), while applications using wchar_t are said "widechar" (because each glyph is composed of one or two wchar_t. See MultiByteToWideChar and WideCharToMultiByte Win32 conversion API for more info.Thus, if you work on Windows, you badly want to use wchar_t (unless you use a framework hiding that, like GTK+ or QT...). The fact is that behind the scenes, Windows works with wchar_t strings, so even historical applications will have their char strings converted in wchar_t when using API like SetWindowText (low level API function to set the label on a Win32 GUI).UTF-32 is 4 bytes per characters, so there is no much to add, if only that a UTF-8 text and UTF-16 text will always use less or the same amount of memory than an UTF-32 text (and usually less).If there is a memory issue, then you should know than for most western languages, UTF-8 text will use less memory than the same UTF-16 one.Still, for other languages (chinese, japanese, etc.), the memory used will be either the same, or larger for UTF-8 than for UTF-16.All in all, UTF-16 will mostly use 2 bytes per characters (unless you\'re dealing with some kind of esoteric language glyphs (Klingon? Elvish?), while UTF-8 will spend from 1 to 4 bytes.See http://en.wikipedia.org/wiki/UTF-8#Compared_to_UTF-16 for more info.1. When I should use std::wstring over std::string?On Linux? Almost never (\xc2\xa7).\nOn Windows? Almost always (\xc2\xa7).\nOn cross-platform code? Depends on your toolkit...(\xc2\xa7) : unless you use a toolkit/framework saying otherwise2. Can std::string hold all the ASCII character set including special characters?Notice: A std::string is suitable for holding a \'binary\' buffer, where a std::wstring is not!On Linux? Yes.\nOn Windows? Only special characters available for the current locale of the Windows user.Edit (After a comment from Johann Gerell): a std::string will be enough to handle all char based strings (each char being a number from 0 to 255). But:3. Is std::wstring supported by almost all popular C++ compilers?Mostly, with the exception of GCC based compilers that are ported to Windows\nIt works on my g++ 4.3.2 (under Linux), and I used Unicode API on Win32 since Visual C++ 6.4. What is exactly a wide character?On C/C++, it\'s a character type written wchar_t which is larger than the simple char character type. It is supposed to be used to put inside characters whose indices (like Unicode glyphs) are larger than 255 (or 127, depending...)So, every reader here now should have a clear understanding about the facts, the situation. If not, then you must read paercebal\'s outstandingly comprehensive answer [btw: thanks!].My pragmatical conclusion is shockingly simple: all that C++ (and STL) "character encoding" stuff is substantially broken and useless. Blame it on Microsoft or not, that will not help anyway.My solution, after in-depth investigation, much frustration and the consequential experiences is the following:accept, that you have to be responsible on your own for the encoding and conversion stuff (and you will see that much of it is rather trivial)use std::string for any UTF-8 encoded strings (just a typedef std::string UTF8String)accept that such an UTF8String object is just a dumb, but cheap container. Do never ever access and/or manipulate characters in it directly (no search, replace, and so on). You could, but you really just really, really do not want to waste your time writing text manipulation algorithms for multi-byte strings! Even if other people already did such stupid things, don\'t do that! Let it be! (Well, there are scenarios where it makes sense... just use the ICU library for those).use std::wstring for UCS-2 encoded strings (typedef std::wstring UCS2String) - this is a compromise, and a concession to the mess that the WIN32 API introduced). UCS-2 is sufficient for most of us (more on that later...).use UCS2String instances whenever a character-by-character access is required (read, manipulate, and so on). Any character-based processing should be done in a NON-multibyte-representation. It is simple, fast, easy.add two utility functions to convert back & forth between UTF-8 and UCS-2:The conversions are straightforward, google should help here ...That\'s it. Use UTF8String wherever memory is precious and for all UTF-8 I/O. Use UCS2String wherever the string must be parsed and/or manipulated. You can convert between those two representations any time.Alternatives & Improvementsconversions from & to single-byte character encodings (e.g. ISO-8859-1) can be realized with help of plain translation tables, e.g. const wchar_t tt_iso88951[256] = {0,1,2,...}; and appropriate code for conversion to & from UCS2.if UCS-2 is not sufficient, than switch to UCS-4 (typedef std::basic_string<uint32_t> UCS2String)ICU or other unicode libraries?For advanced stuff.I recommend avoiding std::wstring on Windows or elsewhere, except when required by the interface, or anywhere near Windows API calls and respective encoding conversions as a syntactic sugar. My view is summarized in http://utf8everywhere.org of which I am a co-author. Unless your application is API-call-centric, e.g. mainly UI application, the suggestion is to store Unicode strings in std::string and encoded in UTF-8, performing conversion near API calls. The benefits outlined in the article outweigh the apparent annoyance of conversion, especially in complex applications. This is doubly so for multi-platform and library development. And now, answering your questions:When you want to have wide characters stored in your string. wide depends on the implementation. Visual C++ defaults to 16 bit if i remember correctly, while GCC defaults depending on the target. It\'s 32 bits long here. Please note wchar_t (wide character type) has nothing to do with unicode. It\'s merely guaranteed that it can store all the members of the largest character set that the implementation supports by its locales, and at least as long as char. You can store unicode strings fine into std::string using the utf-8 encoding too. But it won\'t understand the meaning of unicode code points. So str.size() won\'t give you the amount of logical characters in your string, but merely the amount of char or wchar_t elements stored in that string/wstring. For that reason, the gtk/glib C++ wrapper folks have developed a Glib::ustring class that can handle utf-8.  If your wchar_t is 32 bits long, then you can use utf-32 as an unicode encoding, and you can store and handle unicode strings using a fixed (utf-32 is fixed length) encoding. This means your wstring\'s s.size() function will then return the right amount of wchar_t elements and logical characters. I frequently use std::string to hold utf-8 characters without any problems at all.  I heartily recommend doing this when interfacing with API\'s which use utf-8 as the native string type as well.For example, I use utf-8 when interfacing my code with the Tcl interpreter.The major caveat is the length of the std::string, is no longer the number of characters in the string.Applications that are not satisfied with only 256 different characters have the options of either using wide characters (more than 8 bits) or a variable-length encoding (a multibyte encoding in C++ terminology) such as UTF-8. Wide characters generally require more space than a variable-length encoding, but are faster to process. Multi-language applications that process large amounts of text usually use wide characters when processing the text, but convert it to UTF-8 when storing it to disk.The only difference between a string and a wstring is the data type of the characters they store. A string stores chars whose size is guaranteed to be at least 8 bits, so you can use strings for processing e.g. ASCII, ISO-8859-15, or UTF-8 text. The standard says nothing about the character set or encoding.Practically every compiler uses a character set whose first 128 characters correspond with ASCII. This is also the case with compilers that use UTF-8 encoding. The important thing to be aware of when using strings in UTF-8 or some other variable-length encoding, is that the indices and lengths are measured in bytes, not characters.The data type of a wstring is wchar_t, whose size is not defined in the standard, except that it has to be at least as large as a char, usually 16 bits or 32 bits. wstring can be used for processing text in the implementation defined wide-character encoding. Because the encoding is not defined in the standard, it is not straightforward to convert between strings and wstrings. One cannot assume wstrings to have a fixed-length encoding either.If you don\'t need multi-language support, you might be fine with using only regular strings. On the other hand, if you\'re writing a graphical application, it is often the case that the API supports only wide characters. Then you probably want to use the same wide characters when processing the text. Keep in mind that UTF-16 is a variable-length encoding, meaning that you cannot assume length() to return the number of characters. If the API uses a fixed-length encoding, such as UCS-2, processing becomes easy. Converting between wide characters and UTF-8 is difficult to do in a portable way, but then again, your user interface API probably supports the conversion.1) As mentioned by Greg, wstring is helpful for internationalization, that\'s when you will be releasing your product in languages other than english4) Check this out for wide character\nhttp://en.wikipedia.org/wiki/Wide_characterA good question!\nI think DATA ENCODING (sometime CHARSET also involved) is a MEMORY EXPRESSION MECHANISM in order to save data to file or transfer data via network, so I answer this question as:1.When should I use std::wstring over std::string?If the programming platform or API function is a single-byte one, and we want to process or parse some unicode datas, e.g read from Windows\' .REG file or network 2-byte stream, we should declare std::wstring variable to easy process them. e.g.: wstring ws=L"\xe4\xb8\xad\xe5\x9b\xbda"(6 octets memory: 0x4E2D 0x56FD 0x0061), we can use ws[0] to get character \'\xe4\xb8\xad\' and  ws[1] to get character \'\xe5\x9b\xbd\' and  ws[2] to get character \'a\', etc.2.Can std::string hold the entire ASCII character set, including the special characters?Yes. But notice: American ASCII, means each 0x00~0xFF octet stand for one character ,including printable text such as "123abc&*_&" and you said special one, mostly print it as a \'.\' avoid confusing editors or terminals. And some other countries extend their own "ASCII" charset ,e.g. Chinese, use 2 octets to stand for one character. 3.Is std::wstring supported by all popular C++ compilers?Maybe, or mostly. I have used: VC++6 and GCC 3.3, YES4.What is exactly a "wide character"?wide character mostly indicate using 2 octets or 4 octets to hold all countries\'s characters. 2 octets UCS2 is a representative sample, and further e.g. English \'a\', its memory is 2 octet of 0x0061(vs in ASCII \'a\'s memory is 1 octet 0x61)When should you NOT use wide-characters?  When you\'re writing code before the year 1990.Obviously, I\'m being flip, but really, it\'s the 21st century now. 127 characters have long since ceased to be sufficient.  Yes, you can use UTF8, but why bother with the headaches?