What are the best practices for using Java\'s @Override annotation and why?   It seems like it would be overkill to mark every single overridden method with the @Override annotation.   Are there certain programming situations that call for using the @Override and others that should never use the @Override?   Use it every time you override a method for two benefits.  Do it so that you can take advantage of the compiler checking to make sure you actually are overriding a method when you think you are.  This way, if you make a common mistake of misspelling a method name or not correctly matching the parameters, you will be warned that you method does not actually override as you think it does.  Secondly, it makes your code easier to understand because it is more obvious when methods are overwritten.Additionally, in Java 1.6 you can use it to mark when a method implements an interface for the same benefits.  I think it would be better to have a separate annotation (like @Implements), but it\'s better than nothing.I think it is most useful as a compile-time reminder that the intention of the method is to override a parent method.  As an example:You will often see something like the above method that overrides a method in the base class.  This is an important implementation detail of this class -- we don\'t want sensitive information to be displayed.  Suppose this method is changed in the parent class to This change will not cause any compile time errors or warnings - but it completely changes the intended behavior of the subclass.To answer your question:  you should use the @Override annotation if the lack of a method with the same signature in a superclass is indicative of a bug.  There are many good answers here, so let me offer another way to look at it...There is no overkill when you are coding.  It doesn\'t cost you anything to type @override, but the savings can be immense if you misspelled a method name or got the signature slightly wrong.Think about it this way: In the time you navigated here and typed this post, you pretty much used more time than you will spend typing @override for the rest of your life; but one error it prevents can save you hours.Java does all it can to make sure you didn\'t make any mistakes at edit/compile time, this is a virtually free way to solve an entire class of mistakes that aren\'t preventable in any other way outside of comprehensive testing.Could you come up with a better mechanism in Java to ensure that when the user intended to override a method, he actually did?Another neat effect is that if you don\'t provide the annotation it will warn you at compile time that you accidentally overrode a parent method--something that could be significant if you didn\'t intend to do it.I always use the tag.  It is a simple compile-time flag to catch little mistakes that I might make.It will catch things like tostring() instead of toString()The little things help in large projects.Using the @Override annotation acts as a compile-time safeguard against a common programming mistake. It will throw a compilation error if you have the annotation on a method you\'re not actually overriding the superclass method.The most common case where this is useful is when you are changing a method in the base class to have a different parameter list. A method in a subclass that used to override the superclass method will no longer do so due the changed method signature. This can sometimes cause strange and unexpected behavior, especially when dealing with complex inheritance structures. The @Override annotation safeguards against this.To take advantage from compiler checking you should always use Override annotation. But don\xe2\x80\x99t forget that Java Compiler 1.5 will not allow this annotation when overriding interface methods. You just can use it to override class methods (abstract, or not).Some IDEs, as Eclipse, even configured with Java 1.6 runtime or higher, they maintain compliance with Java 1.5 and don\xe2\x80\x99t allow the use @override as described above. To avoid that behaviour you must go to: Project Properties ->Java Compiler -> Check \xe2\x80\x9cEnable Project Specific Settings\xe2\x80\x9d -> Choose \xe2\x80\x9cCompiler Compliance Level\xe2\x80\x9d = 6.0, or higher.I like to use this annotation every time I am overriding a method independently, if the base is an interface, or class. This helps you avoiding some typical errors, as when you are thinking that you are overriding an event handler and then you see nothing happening. Imagine you want to add an event listener to some UI component:The above code compiles and run, but if you move the mouse inside someUIComponent the \xe2\x80\x9cdo something\xe2\x80\x9d code will note run, because actually you are not overriding the base method mouseEntered(MouseEvent ev). You just create a new parameter-less method mouseEntered(). Instead of that code, if you have used the @Override annotation you have seen a compile error and you have not been wasting time thinking why your event handler was not running.@Override on interface implementation is inconsistent since there is no such thing as "overriding an interface" in java. @Override on interface implementation is useless since in practise it catches no bugs that the compilation wouldn\'t catch anyway. \nThere is only one, far fetched scenario where override on implementers actually does something: If you implement an interface, and the interface REMOVES methods, you will be notified on compile time that you should remove the unused implementations. Notice that if the new version of the interface has NEW or CHANGED methods you\'ll obviously get a compile error anyways as you\'re not implementing the new stuff.@Override on interface implementers should never have been permitted in 1.6, and with eclipse sadly choosing to auto-insert the annotations as default behavior, we get a lot of cluttered source files. When reading 1.6 code, you cannot see from the @Override annotation if a method actually overrides a method in the superclass or just implements an interface.Using @Override when actually overriding a method in a superclass is fine.Its best to use it for every method intended as an override, and Java 6+, every method intended as an implementation of an interface.First, it catches misspellings like "hashcode()" instead of "hashCode()" at compile-time. It can be baffling to debug why the result of your method doesn\'t seem to match your code when the real cause is that your code is never invoked.Also, if a superclass changes a method signature, overrides of the older signature can be "orphaned", left behind as confusing dead code. The @Override annotation will help you identify these orphans so that they can be modified to match the new signature.If you find yourself overriding (non-abstract) methods very often, you probably want to take a look at your design. It is very useful when the compiler would not otherwise catch the error. For instance trying to override initValue() in ThreadLocal, which I have done.Using @Override when implementing interface methods (1.6+ feature) seems a bit overkill for me. If you have loads of methods some of which override and some don\'t, that probably bad design again (and your editor will probably show which is which if you don\'t know).@Override on interfaces actually are helpful, because you will get warnings if you change the interface.Another thing it does is it makes it more obvious when reading the code that it is changing the behavior of the parent class. Than can help in debugging.Also, in Joshua Block\'s book Effective Java (2nd edition), item 36 gives more details on the benefits of the annotation.It makes absolutely no sense to use @Override when implementing an interface method. There\'s no advantage to using it in that case--the compiler will already catch your mistake, so it\'s just unnecessary clutter.Whenever a method overrides another method, or a method implements a signature in an interface.The @Override annotation assures you that you did in fact override something. Without the annotation you risk a misspelling or a difference in parameter types and number.I use it every time. It\'s more information that I can use to quickly figure out what is going on when I revisit the code in a year and I\'ve forgotten what I was thinking the first time.The best practive is to always use it (or have the IDE fill them for you)@Override usefulness is to detect changes in parent classes which has not been reported down the hierarchy.\nWithout it, you can change a method signature and forget to alter its overrides, with @Override, the compiler will catch it for you.That kind of safety net is always good to have.I use it everywhere.\nOn the topic of the effort for marking methods, I let Eclipse do it for me so, it\'s no additional effort.I\'m religious about continuous refactoring.... so, I\'ll use every little thing to make it go more smoothly.If used consistently, it protects you from a large class of nefarious bugs. Use @Override annotation to avoid these bugs:\n(Spot the bug in the following code:)source: Effective JavaBe careful when you use Override, because you can\'t do reverse engineer in starUML afterwards; make the uml first.It seems that the wisdom here is changing. Today I installed IntelliJ IDEA 9 and noticed that its "missing @Override inspection" now catches not just implemented abstract methods, but implemented interface methods as well. In my employer\'s code base and in my own projects, I\'ve long had the habit to only use @Override for the former -- implemented abstract methods. However, rethinking the habit, the merit of using the annotations in both cases becomes clear. Despite being more verbose, it does protect against the fragile base class problem (not as grave as C++-related examples) where the interface method name changes, orphaning the would-be implementing method in a derived class.Of course, this scenario is mostly hyperbole; the derived class would no longer compile, now lacking an implementation of the renamed interface method, and today one would likely use a Rename Method refactoring operation to address the entire code base en masse.Given that IDEA\'s inspection is not configurable to ignore implemented interface methods, today I\'ll change both my habit and my team\'s code review criteria.The annotation @Override is used for helping to check whether the developer what to override the correct method in the parent class or interface. When the name of super\'s methods changing, the compiler can notify that case, which is only for keep consistency with the super and the subclass. BTW, if we didn\'t announce the annotation @Override in the subclass, but we do override some methods of the super, then the function can work as that one with the @Override. But this method can not notify the developer when the super\'s method was changed. Because it did not know the developer\'s purpose -- override super\'s method or define a new method? So when we want to override that method to make use of the Polymorphism, we have better to add @Override above the method. I use it as much as can to identify when a method is being overriden.  If you look at the Scala programming language, they also have an override keyword.  I find it useful.It does allow you (well, the compiler) to catch when you\'ve used the wrong spelling on a method name you are overriding.Override annotation is used to take advantage of the compiler, for checking whether you actually are overriding a method from parent class. It is used to notify if you make any mistake like mistake of misspelling a method name, mistake of not correctly matching the parametersi think it\'s best to code the @override whenever allowed. it helps for coding. however, to be noted, for ecipse Helios, either sdk 5 or 6, the @override annotation for implemented interface methods is allowed. as for Galileo, either 5 or 6, @override annotation is not allowed.Annotations do provide meta data about the code  to the Compiler and the annotation @Override is used in case of inheritance when we are overriding any method of base class. It just tells the compiler that you are overriding method. It can avoide some kinds common mistakes we can do like not following the proper signature of the method or mispelling in name of the method etc. So its a good practice to use @Override annotation.For me the @Override ensures me I have the signature of the method correct.  If I put in the annotation and the method is not correctly spelled, then the compiler complains letting me know something is wrong.Simple\xe2\x80\x93when you want to override a method present in your superclass, use @Override annotation to  make a correct override. The compiler will warn you if you don\'t override it correctly.