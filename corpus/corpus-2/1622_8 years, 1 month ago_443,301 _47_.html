I have two integer values a and b, but I need their ratio in floating point.  I know that a<b and I want to calculate a/b, so if I use integer division I\'ll always get 0 with a remainder of a.How can I force c to be a floating point number in Python in the following?You can cast to float by doing c = a / float(b). If the numerator or denominator is a float, then the result will be also.A caveat: as commenters have pointed out, this won\'t work if b might be something other than an integer or floating-point number (or a string representing one). If you might be dealing with other types (such as complex numbers) you\'ll need to either check for those or use a different method.I have two integer values a and b, but I need their ratio in floating point. I know that a < b and I want to calculate a/b, so if I use integer division I\'ll always get 0 with a remainder of a.How can I force c to be a floating point number in Python in the following?What is really being asked here is:"How do I force true division such that a / b will return a fraction?"In Python 3, to get true division, you simply do a / b. Floor division, the classic division behavior for integers, is now a // b:However, you may be stuck using Python 2, or you may be writing code that must work in both 2 and 3.In Python 2, it\'s not so simple. Some ways of dealing with classic Python 2 division are better and more robust than others.You can get Python 3 division behavior in any given module with the following import at the top:which then applies Python 3 style division to the entire module. It also works in a python shell at any given point. In Python 2:This is really the best solution as it ensures the code in your module is more forward compatible with Python 3.If you don\'t want to apply this to the entire module, you\'re limited to a few workarounds. The most popular is to coerce one of the operands to a float. One robust solution is a / (b * 1.0). In a fresh Python shell:Also robust is truediv from the operator module operator.truediv(a, b), but this is likely slower because it\'s a function call:Commonly seen is a / float(b). This will raise a TypeError if b is a complex number. Since division with complex numbers is defined, it makes sense to me to not have division fail when passed a complex number for the divisor.It doesn\'t make much sense to me to purposefully make your code more brittle.You can also run Python with the -Qnew flag, but this has the downside of executing all modules with the new Python 3 behavior, and some of your modules may expect classic division, so this is not recommended. But to demonstrate:In Python 3.x, the single slash (/) always means true (non-truncating) division. (The // operator is used for truncating division.) In Python 2.x (2.2 and above), you can get this same behavior by putting aat the top of your module.Just making any of the parameters for division in floating-point format also produces the output in floating-point.Example:or,or, or, Add a dot (.) to indicate floating point numbersorThis will also work0.2If you want to use "true" (floating point) division by default, there is a command line flag:There are some drawbacks (from the PEP):It has been argued that a command line option to change the\n        default is evil.  It can certainly be dangerous in the wrong\n        hands: for example, it would be impossible to combine a 3rd\n        party library package that requires -Qnew with another one that\n        requires -Qold. You can learn more about the other flags values that change / warn-about the behavior of division by looking at the python man page.For full details on division changes read: PEP 238 -- Changing the Division Operatorwhere a is dividend and b is the divisor.\nThis function is handy when quotient after division  of two integers is a float.if you do a division of two integers python will return you a integer, then you need to do:orand then get c as a float typeThis will also worku=1./5\n        print uanswered Dec 24 \'13 at 19:58 Gaurav Agarwal 6,7172279140Thanks Gauraw, this does the trick and is quite a neat solution.\nIn case both the numerator and denominator are variables, the "solution" might be multiplying 1. by the quotient.Example: ;-)Max - Italy