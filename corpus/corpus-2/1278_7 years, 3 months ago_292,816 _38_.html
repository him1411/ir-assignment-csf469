Is there a standard Bash tool that acts like echo but outputs to stderr rather than stdout?I know I can do echo foo 1>&2 but it\'s kinda ugly and, I suspect, error prone (e.g. more likely to get edited wrong when things change). This question is old, but you could do this, which facilitates reading:The operator \'>&2\' literally means redirect the address of file descriptor 1 (stdout) to the address of file descriptor 2 (stderr) for that command. depending on how deeply you want to understand it, read this: http://wiki.bash-hackers.org/howto/redirection_tutorialTo avoid interaction with other redirections use subshellYou could define a function:This would be faster than a script and have no dependencies.Camilo Martin\'s bash specific suggestion uses a "here string" and will print anything you pass to it, including arguments (-n) that echo would normally swallow:Glenn Jackman\'s solution also avoids the argument swallowing problem:Since 1 is the standard output, you do not have to explicitly name it in front of an output redirection like > but instead can simply type:Since you seem to be worried that 1>&2 will be difficult for you to reliably type, the elimination of the redundant 1 might be a slight encouragement to you!Another optionNo, that\'s the standard way to do it.  It shouldn\'t cause errors.This is a simple STDERR function, which redirect the pipe input to STDERR.Don\'t use cat as some are mentioned here. cat is a program \nwhile echo and printf are bash (shell) builtins. Launching a program or an other script (also mentioned above) means create an new process with all it\'s costs. Using builtins, writing functions are quite cheap, because there is no need to create (execute) a process (-environment).The opner asks "is there any standard tool to output (pipe) to stderr", the schort answer is : NO ... why? ... rediredcting pipes is an elemantary concept in systems like unix (Linux...) and bash (sh) builds up on these concepts.I agree with the opener that redirecting with notations like this: &2>1 is not very pleasant for modern programmers, but that\'s bash. Bash was not intended to write huge and robust programs, it is intended to help the admins to get there work with less keypresses ;-)And at least, you can place the redirection anywhere in the line:If you don\'t mind logging the message also to syslog, the not_so_ugly way is:The -s option means: "Output the message to standard error as well as to the system log."Note: I\'m answering the post- not the misleading/vague "echo that outputs to stderr" question (already answered by OP).Use a function to show the intention and source the implementation you want. E.g.And error_handling being:Reasons that handle concerns in OP:Other reasons:Make a scriptthat would be your tool.Or make a function if you don\'t want to have a script in separate file.read is a shell builtin command that prints to stderr, and can be used like echo without performing redirection tricks:The -t 0.1 is a timeout that disables read\'s main functionality, storing one line of stdin into a variable.This has been answered already and with a lot of votes. Just for the record:echo "my errz" > /proc/self/fd/2will effectively output to stderr. Explanation: /proc/self is a link to the current process and /proc/self/fd holds the process opened file descriptors. Then, 0, 1, and 2 stands for stdin, stdout and stderr respectively.I found it more readable. Also this may work in most linux distibutions:echo "my errz" > /dev/stderrMaking it a lot more readable.Mac OS X: I tried the accepted answer and a couple of other answers and all of them resulted in writing STDOUT not STDERR on my Mac.Here is a portable way to write to standard error using Perl: