It seems to me like the files run the same without that line.If you have several versions of Python installed, /usr/bin/env will ensure the interpreter used is the first one on your environment\'s $PATH. The alternative would be to hardcode something like #!/usr/bin/python; that\'s ok, but less flexible.In Unix, an executable file that\'s meant to be interpreted can indicate what interpreter to use by having a #! at the start of the first line, followed by the interpreter (and any flags it may need).If you\'re talking about other platforms, of course, this rule does not apply (but that "shebang line" does no harm, and will help if you ever copy that script to a platform with a Unix base, such as Linux, Mac, etc).That is called the shebang line. As the Wikipedia entry explains:In computing, a shebang (also called a hashbang, hashpling, pound bang, or crunchbang) refers to the characters "#!" when they are the first two characters in an interpreter directive as the first line of a text file. In a Unix-like  operating system, the program loader takes the presence of these two characters as an indication that the file is a script, and tries to execute that script using the interpreter  specified by the rest of the first line in the file.See also the Unix FAQ entry.Even on Windows, where the shebang line does not determine the interpreter to be run, you can pass options to the interpreter by specifying them on the shebang line. I find it useful to keep a generic shebang line in one-off scripts (such as the ones I write when answering questions on SO), so I can quickly test them on both Windows and ArchLinux.The env utility allows you to invoke a command on the path:The first remaining argument specifies the program name to invoke; it is searched for according to the PATH environment variable. Any remaining arguments are passed as arguments to that program.Expanding a bit on the other answers, here\'s a little example of how your command line scripts can get into trouble by incautious use of /usr/bin/env shebang lines:The json module doesn\'t exist in Python 2.5.One way to guard against that kind of problem is to use the versioned python command names that are typically installed with most Pythons:If you just need to distinguish between Python 2.x and Python 3.x, recent releases of Python 3 also provide a python3 name:In order to run the python script, we need to tell the shell three things:The shebang #! accomplishes (1.). The shebang begins with a # because the # character is a comment marker in many scripting languages. The contents of the shebang line are therefore automatically ignored by the interpreter.The env command accomplishes (2.) and (3.). To quote "grawity,"A common use of the env command is to launch interpreters, by making\n  use of the fact that env will search $PATH for the command it is told\n  to launch. Since the shebang line requires an absolute path to be\n  specified, and since the location of various interpreters (perl, bash,\n  python) may vary a lot, it is common to use:#!/usr/bin/env perl\xc2\xa0 instead of trying to guess whether it is\n  /bin/perl, /usr/bin/perl, /usr/local/bin/perl, /usr/local/pkg/perl,\n  /fileserver/usr/bin/perl, or /home/MrDaniel/usr/bin/perl on the user\'s\n  system...On the other hand, env is almost always in /usr/bin/env. (Except in\n  cases when it isn\'t; some systems might use /bin/env, but that\'s a\n  fairly rare occassion and only happens on non-Linux systems.)Technically, in Python, this is just a comment line.This line is only used if you run the py script from the shell (from the command line). This is know as the "Shebang!", and it is used in various situations, not just with Python scripts.Here, it instructs the shell to start a specific version of Python (to take care of the rest of the file.Perhaps your question is in this sense:If you want to use: $python myscript.pyYou don\'t need that line at all. The system will call python and then python interpreter will run your script.But if you intend to use: $./myscript.pyCalling it directly like a normal program or bash script, you need write that line to specify to the system which program use to run it, (and also make it executable with chmod 755) The main reason to do this is to make the script portable across operating system environments.  For example under mingw, python scripts use :and under GNU/Linux distribution it is either:or and under the best commercial Unix sw/hw system of all (OS/X), it is:or on FreeBSD:However all these differences can make the script portable across all by using:It probably makes sense to emphasize one thing that the most have missed, which may prevent immediate understanding. When you type python in terminal you don\'t normally provide a full path. Instead, the executable is up looked in PATH environment variable. In turn, when you want to execute a Python program directly, /path/to/app.py, one must tell the shell what interpreter to use (via the hashbang, what the other contributors are explaining above).Hashbang expects full path to an interpreter. Thus to run your Python program directly you have to provide full path to Python binary which varies significantly, especially considering a use of virtualenv. To address portability the trick with /usr/bin/env is used. The latter is originally intended to alter environment in-place and run a command in it. When no alteration is provided it runs the command in current environment, which effectively results in the same PATH lookup which does the trick.Source from unix stackexchangeIt\'s recommended way, proposed in documentation:2.2.2. Executable Python ScriptsOn BSD\xe2\x80\x99ish Unix systems, Python scripts can be made directly\n  executable, like shell scripts, by putting the linefrom http://docs.python.org/py3k/tutorial/interpreter.html#executable-python-scriptsThe exec system call of the Linux kernel understands shebangs (#!) nativelyWhen you do on bash:on Linux, this calls the exec system call with the full path to something.This line of the kernel gets called on the file passed to exec: https://github.com/torvalds/linux/blob/v4.8/fs/binfmt_script.c#L25if ((bprm->buf[0] != \'#\') || (bprm->buf[1] != \'!\'))This reads the very first bytes of the file, and compares them to #!.If that is true, then the rest of the line is parsed by the Linux kernel, which makes another exec call with path /usr/bin/env python and current file as the first argument:and this works for any scripting language that uses # as a comment character.And yes, you can make an infinite loop with:and an executable file at /a#! just happens to be human readable, but that is not required.If the file started with different bytes, then the exec system call would use a different handler. The other most important built-in handler is for ELF executable files: https://github.com/torvalds/linux/blob/v4.8/fs/binfmt_elf.c#L1305 which checks for bytes 7f 45 4c 46 (which also happens to be human readable for .ELF). This reads the ELF file, puts it into memory correctly, and starts a new process with it. See also: How does kernel get an executable binary file running under linux?Finally, you can add your own shebang handlers with the binfmt_misc mechanism. For example, you can add a custom handler for .jar files: Running a JAR file without directly calling `java` This mechanism even supports handlers by file extension.I don\'t think POSIX specifies shebangs however: https://unix.stackexchange.com/a/346214/32558This is a shell convention that tells the shell which program can execute the script.resolves to a path to the Python binary.You can try this issue using virtualenvHere is test.pyCreate virtual environmentsactivate each environment then check the differencesIt seems to me like the files run the same without that line.If so, then perhaps you\'re running the Python program on Windows? Windows doesn\'t use that line\xe2\x80\x94instead, it uses the file-name extension to run the program associated with the file extension.However in 2011, a "Python launcher" was developed which (to some degree) mimics this Linux behaviour for Windows. This is limited just to choosing which Python interpreter is run \xe2\x80\x94 e.g. to select between Python 2 and Python 3 on a system where both are installed. The launcher is optionally installed as py.exe by Python installation, and can be associated with .py files so that the launcher will check that line and in turn launch the specified Python interpreter version.If you\'re running your script in a virtual environment, say venv, then executing which python while working on venv will display the path to the Python interpreter:~/Envs/venv/bin/pythonNote that the name of the virtual environment is embedded in the path to the Python interpreter. Therefore, hardcoding this path in your script will cause two problems:Therefore, to add to Jonathan\'s answer, the ideal shebang is #!/usr/bin/env python, not just for portability across OSes but for portability across virtual environments as well!Considering the portability issues between python2 and python3, you should always specify either version unless your program is compatible with both.Some distributions are shipping python symlinked to python3 for a while now - do not rely on python being python2.This is emphasized by PEP 394:In order to tolerate differences across platforms, all new code that\n  needs to invoke the Python interpreter should not specify python, but\n  rather should specify either python2 or python3 (or the more specific\n  python2.x and python3.x versions; see the Migration Notes). This\n  distinction should be made in shebangs, when invoking from a shell\n  script, when invoking via the system() call, or when invoking in any\n  other context.It just specifies what interpreter you want to use. To understand this, create a file through terminal by doing touch test.py, then type into that file the following:and do chmod +x test.py to make your script executable. After this when you do ./test.py you should get an error saying:because python3 doesn\'t supprt the print operator.Now go ahead and change the first line of your code to:and it\'ll work, printing test to stdout, because python2 supports the print operator. So, now you\'ve learned how to switch between script interpreters.It tells the interpreter which version of python to run the program with when you have multiple versions of python.this tells the script where is python directory !