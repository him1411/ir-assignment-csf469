How do I check if a background service (on Android) is running?I want an Android activity that toggles the state of the service -- it lets me turn it on if it is off and off if it is on.I had the same problem not long ago. Since my service was local, I ended up simply using a static field in the service class to toggle state, as described by hackbod hereEDIT (for the record):Here is the solution proposed by hackbod:If your client and server code is part of the same .apk and you are \n  binding to the service with a concrete Intent (one that specifies the \n  exact service class), then you can simply have your service set a \n  global variable when it is running that your client can check. We deliberately don\'t have an API to check whether a service is \n  running because, nearly without fail, when you want to do something \n  like that you end up with race conditions in your code. I use the following from inside an activity:And I call it using:This works reliably, because it is based on the information about running services provided by the Android operating system through ActivityManager#getRunningServices.All the approaches using onDestroy or onSometing events or Binders or static variables will not work reliably because as a developer you never know, when Android decides to kill your process or which of the mentioned callbacks are called or not. Please note the "killable" column in the lifecycle events table in the Android documentation.Got it! You MUST call startService() for your service to be properly registered and passing BIND_AUTO_CREATE will not suffice.And now the ServiceTools class:A small complement is:My goal is to know wether a service is running without actualy running it if it is not running.Calling bindService or calling an intent that can be caught by the service is not a good idea then as it will start the service if it is not running.So, as miracle2k suggested, the best is to have a static field in the service class to know whether the service has been started or not.To make it even cleaner, I suggest to transform the service in a singleton with a very very lazy fetching: that is, there is no instantiation at all of the singleton instance through static methods. The static getInstance method of your service/singleton just returns the instance of the singleton if it has been created. But it doesn\'t actualy start or instanciate the singleton itself. The service is only started through normal service start methods.It would then be even cleaner to modify the singleton design pattern to rename the confusing getInstance method into something like the isInstanceCreated() : boolean method.The code will look like:This solution is elegant, but it is only relevant if you have access to the service class and only for classes iside the app/package of the service. If your classes are outside of the service app/package then you could query the ActivityManager with limitations underlined by Pieter-Jan Van Robays.You can use this (I didn\'t try this yet, but I hope this works):The startService method returns a ComponentName object if there is an already running service. If not, null will be returned.See public abstract ComponentName startService (Intent service).This is not like checking I think, because it\'s starting the service, so you can add stopService(someIntent); under the code.First of all you musn\'t try to reach the service by using the ActivityManager. (Discussed here)Services can run on their own, be bound to an Activity or both. The way to check in an Activity if your Service is running or not is by making an interface (that extends Binder) where you declare methods that both, the Activity and the Service, understand. You can do this by making your own Interface where you declare for example "isServiceRunning()".\nYou can then bind your Activity to your Service, run the method isServiceRunning(), the Service will check for itself if it is running or not and returns a boolean to your Activity.You can also use this method to stop your Service or interact with it in another way.I used this tutorial to learn how to Implement this scenario in my application.onDestroy isn\'t always called in the service so this is useless! For example: Just run the app again with one change from Eclipse. The application is forcefully exited using SIG: 9.I just want to add a note to the answer by @Snicolas. The following steps can be used to check stop service with/without calling onDestroy().onDestroy() called: Go to Settings -> Application -> Running Services -> Select and stop your service.onDestroy() not Called: Go to Settings -> Application -> Manage Applications -> Select and "Force Stop" your application in which your service is running. However, as your application is stopped here, so definitely the service instances will also be stopped.Finally, I would like to mention that the approach mentioned there using a static variable in singleton class is working for me.Xamarin C# verison .For the use-case given here we may simply make use of the stopService() method\'s return value. It returns true if there exists the specified service and it is killed. Else it returns false. So you may restart the service if the result is false else it is assured that the current service has been stopped. :) It would be better if you have a look at this.I have slightly modified one of the solutions presented above, but passing the class instead of a generic string name, in order to be sure to compare strings coming out from the same method class.getName()and thenAgain, another alternative that people might find cleaner if they use pending intents (for instance with the AlarmManager: Where CODE is a constant that you define privately in your class to identify the pending intents associated to your service.Inside TheServiceClass define:Then In onStartCommand(...) Then, call if(TheServiceClass.serviceRunning == true) from any class.There can be several services with the same class name. I\'ve just created two apps. The package name of the first app is com.example.mock. I created a subpackage called lorem in the app and a service called Mock2Service. So its fully qualified name is com.example.mock.lorem.Mock2Service.Then I created the second app and a service called Mock2Service. The package name of the second app is com.example.mock.lorem. The fully qualified name of the service is com.example.mock.lorem.Mock2Service, too.Here is my logcat output.A better idea is to compare ComponentName instances because equals() of ComponentName compares both package names and class names. And there can\'t be two apps with the same package name installed on a device.The equals() method of ComponentName.ComponentNameThis is an extract from Android docsOrdered broadcasts (sent with Context.sendOrderedBroadcast) are\n  delivered to one receiver at a time. As each receiver executes in\n  turn, it can propagate a result to the next receiver, or it can\n  completely abort the broadcast so that it won\'t be passed to other\n  receivers.This is a bit of a hack but think of this as "pinging" the Service since we can broadcast syncronously we can broadcast and get a result synchronously on the UI thread.BroadcastReceiver .This applies more towards Intent Service debugging since they spawn a thread, but may work for regular services as well. I found this thread thanks to BingingIn my case, I played around with the debugger and found the thread view. It kind of looks like the bullet point icon in MS Word. Anyways, you don\'t have to be in debugger mode to use it. Click on the process and click on that button. Any Intent Services will show up while they are running, at least on the emulator.If the service belongs to another process or APK use the solution based on the ActivityManager.If you have access to its source, just use the solution based on a static field. But instead using a boolean I would suggest using a Date object. While the service is running, just update its value to \'now\' and when it finishes set it to null. From the activity you can check if its null or the date is too old which will mean that it is not running.You can also send broadcast notification from your service indicating that is running along further info like progress.Take it easy guys... :)I think the most suitable solution is holding a key-value pair in SharedPreferences about if the service is running or not.Logic is very straight; at any desired position in your service class; put a boolean value which will act as a flag for you about whether the service is running or not. Then read this value whereever you want in your application.A sample code which I am using in my app is below:In my Service class (A service for Audio Stream), I execute the following code when the service is up;Then in any activity of my application, I am checking the status of the service with the help of following code;No special permissions, no loops... Easy way, clean solution :)If you need extra information, please refer the link Hope this helps.The proper way to check if a service is running is to simply ask it. Implement a BroadcastReceiver in your service that responds to pings from your activities. Register the BroadcastReceiver when the service starts, and unregister it when the service is destroyed. From your activity (or any component), send a local broadcast intent to the service and if it responds, you know it\'s running. Note the subtle difference between ACTION_PING and ACTION_PONG in the code below.ORif don\'t wanna use static then user SharedPreferencesPrefManager is my singleton class for managing all preferences.simple use bind with don\'t create auto example :why not using? getRunningServices() Note: this method is only intended for debugging or implementing service management type user interfaces.this works for me