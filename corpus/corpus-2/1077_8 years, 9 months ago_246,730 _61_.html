I can find lots of information on how Long Polling works (For example, this, and this), but no simple examples of how to implement this in code.All I can find is cometd, which relies on the Dojo JS framework, and a fairly complex server system..Basically, how would I use Apache to serve the requests, and how would I write a simple script (say, in PHP) which would "long-poll" the server for new messages?The example doesn\'t have to be scaleable, secure or complete, it just needs to work!It\'s simpler than I initially thought.. Basically you have a page that does nothing, until the data you want to send is available (say, a new message arrives).Here is a really basic example, which sends a simple string after 2-10 seconds. 1 in 3 chance of returning an error 404 (to show error handling in the coming Javascript example)msgsrv.phpNote: With a real site, running this on a regular web-server like Apache will quickly tie up all the "worker threads" and leave it unable to respond to other requests.. There are ways around this, but it is recommended to write a "long-poll server" in something like Python\'s twisted, which does not rely on one thread per request. cometD is an popular one (which is available in several languages), and Tornado is a new framework made specifically for such tasks (it was built for FriendFeed\'s long-polling code)... but as a simple example, Apache is more than adequate! This script could easily be written in any language (I chose Apache/PHP as they are very common, and I happened to be running them locally)Then, in Javascript, you request the above file (msg_srv.php), and wait for a response.  When you get one, you act upon the data. Then you request the file and wait again, act upon the data (and repeat)What follows is an example of such a page.. When the page is loaded, it sends the initial request for the msgsrv.php file.. If it succeeds, we append the message to the #messages div, then after 1 second we call the waitForMsg function again, which triggers the wait.The 1 second setTimeout() is a really basic rate-limiter, it works fine without this, but if msgsrv.php always returns instantly (with a syntax error, for example) - you flood the browser and it can quickly freeze up. This would better be done checking if the file contains a valid JSON response, and/or keeping a running total of requests-per-minute/second, and pausing appropriately.If the page errors, it appends the error to the #messages div, waits 15 seconds and then tries again (identical to how we wait 1 second after each message)The nice thing about this approach is it is very resilient. If the clients internet connection dies, it will timeout, then try and reconnect - this is inherent in how long polling works, no complicated error-handling is requiredAnyway, the long_poller.htm code, using the jQuery framework:I\'ve got a really simple chat example as part of slosh.Edit: (since everyone\'s pasting their code in here)This is the complete JSON-based multi-user chat using long-polling and slosh.  This is a demo of how to do the calls, so please ignore the XSS problems.  Nobody should deploy this without sanitizing it first.Notice that the client always has a connection to the server, and as soon as anyone sends a message, everyone should see it roughly instantly.Tornado is designed for long-polling, and includes a very minimal (few hundred lines of Python) chat app in /examples/chatdemo , including server code and JS client code. It works like this:Clients use JS to ask for an updates since (number of last message), server URLHandler receives these and adds a callback to respond to the client to a queue. When the server gets a new message, the onmessage event fires, loops through the callbacks, and sends the messages.The client-side JS receives the message, adds it to the page, then asks for updates since this new message ID.I think the client looks like a normal asynchronous AJAX request, but you expect it to take a "long time" to come back.The server then looks like this.So, the AJAX request goes to the server, probably including a timestamp of when it was last update so that your hasNewData() knows what data you have already got.\nThe server then sits in a loop sleeping until new data is available.  All the while, your AJAX request is still connected, just hanging there waiting for data.\nFinally, when new data is available, the server gives it to your AJAX request and closes the connection.This is a nice 5-minute screencast on how to do long polling using PHP & jQuery:\nhttp://screenr.com/SNHCode is quite similar to dbr\'s example above.Here are some classes I use for long-polling in C#. There are basically 6 classes (see below).I used this to get to grips with Comet, I have also set up Comet using the Java Glassfish server and found lots of other examples by subscribing to cometdaily.comHere is a simple long-polling example in PHP by Erik Dubbelboer using the Content-type: multipart/x-mixed-replace header:And here is a demo:http://dubbelboer.com/multipart.phpBelow is a long polling solution I have developed for Inform8 Web. Basically you override the class and implement the loadData method. When the loadData returns a value or the operation times out it will print the result and return. If the processing of your script may take longer than 30 seconds you may need to alter the set_time_limit() call to something longer.Apache 2.0 license. Latest version on github \nhttps://github.com/ryanhend/Inform8/blob/master/Inform8-web/src/config/lib/Inform8/longpoll/LongPoller.phpRyanThanks for the code, dbr. Just a small typo in long_poller.htm around the lineI think it should befor it to work.For those interested, I tried a Django equivalent. Start a new Django project, say lp for long polling:Call the app msgsrv for message server:Add the following lines to settings.py to have a templates directory:Define your URL patterns in urls.py as such:And msgsrv/views.py should look like:Lastly, templates/long_poller.htm should be the same as above with typo corrected. Hope this helps.Take a look at this blog post which has code for a simple chat app in Python/Django/gevent.This is one of the scenarios that PHP is a very bad choice for. As previously mentioned, you can tie up all of your Apache workers very quickly doing something like this. PHP is built for start, execute, stop. It\'s not built for start, wait...execute, stop. You\'ll bog down your server very quickly and find that you have incredible scaling problems.That said, you can still do this with PHP and have it not kill your server using the nginx HttpPushStreamModule: http://wiki.nginx.org/HttpPushStreamModuleYou setup nginx in front of Apache (or whatever else) and it will take care of holding open the concurrent connections. You just respond with payload by sending data to an internal address which you could do with a background job or just have the messages fired off to people that were waiting whenever the new requests come in. This keeps PHP processes from sitting open during long polling.This is not exclusive to PHP and can be done using nginx with any backend language. The concurrent open connections load is equal to Node.js so the biggest perk is that it gets you out of NEEDING Node for something like this. You see a lot of other people mentioning other language libraries for accomplishing long polling and that\'s with good reason. PHP is just not well built for this type of behavior naturally.Here is a node.js example that comes with a jquery client. There\'s also instructions on setting it up on heroku.The WS-I group published something called "Reliable Secure Profile" that has a Glass Fish and .NET implementation that apparently inter-operate well.With any luck there is a Javascript implementation out there as well.There is also a Silverlight implementation that uses HTTP Duplex.  You can connect javascript to the Silverlight object to get callbacks when a push occurs.There are also commercial paid versions as well.Why not consider the web sockets instead of long polling? They are much efficient and easy to setup. However they are supported only in modern browsers. Here is a quick reference.For a ASP.NET MVC implementation, look at SignalR which is available on NuGet.. note that the NuGet is often out of date from the Git source which gets very frequent commits.Read more about SignalR on a blog on by Scott Hanselman You can try icomet(https://github.com/ideawu/icomet), a C1000K C++ comet server built with libevent. icomet also provides a JavaScript library, it is easy to use as simple asicomet supports a wide range of Browsers and OSes, including Safari(iOS, Mac), IEs(Windows), Firefox, Chrome, etc. 