I tried to declare a boolean variable in a shell script using the following syntax:Is this correct? Also, if I wanted to update that variable would I use the same syntax? Finally, is the following syntax for using boolean variables as expressions correct:Revised Answer (Feb 12, 2014)Original AnswerCaveats: https://stackoverflow.com/a/21210966/89391From: Using boolean variables in BashThe reason the original answer is included here is because the comments before the revision on Feb 12, 2014 pertain only to the original answer, and many of the comments are wrong when associated with the revised answer. For example, Dennis Williamson\'s comment about bash builtin true on Jun 2, 2010 only applies to the original answer, not the revised.I do not recommend the accepted answer1. Its syntax is pretty but it has some flaws.Say we have the following condition.In the following cases2, this condition will evaluate to true and execute the nested command.Typically you only want your condition to evaluate to true when your "boolean" variable, var in this example, is explicitly set to true. All the others cases are dangerously misleading!The last case (#5) is especially naughty because it will execute the command contained in the variable (which is why the condition evaluates to true for valid commands3, 4).Here is a harmless example:Quoting your variables is safer, e.g. if "$var"; then. In the above cases, you should get a warning that the command is not found. But we can still do better (see my recommendations at the bottom).Also see Mike Holt\'s explanation of Miku\'s original answer.This approach also has unexpected behaviour.You would expect the above condition to evaluate to false, thus never executing the nested statement. Surprise!Quoting the value ("false"), quoting the variable ("$var"), or using test or [[ instead of [, do not make a difference.Here are ways I recommend you check your "booleans". They work as expected.They\'re all pretty much equivalent. You\'ll have to type a few more keystrokes than the approaches in the other answers5 but your code will be more defensive.There seems to be some misunderstanding here about the bash builtin true, and more specifically, about how bash expands and interprets expressions inside brackets.The code in miku\'s answer has absolutely nothing to do with the bash builtin true, nor /bin/true, nor any other flavor of the true command. In this case, true is nothing more than a simple character string, and no call to the true command/builtin is ever made, neither by the variable assignment, nor by the evaluation of the conditional expression.The following code is functionally identical to the code in the miku\'s answer:The only difference here is that the four characters being compared are \'y\', \'e\', \'a\', and \'h\' instead of \'t\', \'r\', \'u\', and \'e\'. That\'s it. There\'s no attempt made to call a command or builtin named yeah, nor is there (in miku\'s example) any sort of special handling going on when bash parses the token true. It\'s just a string, and a completely arbitrary one at that.Update (2/19/2014): After following the link in miku\'s answer, now I see where some of the confusion is coming from. Miku\'s answer uses single brackets, but the code snippet he links to does not use brackets. It\'s just:Both code snippets will behave the same way, but the brackets completely change what\'s going on under the hood. Here\'s what bash is doing in each case:No brackets:Brackets:The no-brackets code works because the true command returns an exit code of 0, which indicates success. The bracketed code works because the value of $the_world_is_flat is identical to the string literal true on the right side of the =.Just to drive the point home, consider the following two snippets of code: This code (if run with root privs) will reboot your computer:This code just prints "Nice try." The reboot command is not called.Update (4/14/2014) To answer the question in the comments regarding the difference between = and ==: AFAIK, there is no difference. The == operator is a bash-specific synonym for =, and as far as I\'ve seen, they work exactly the same in all contexts. Note, however, that I\'m specifically talking about the = and == string comparison operators used in either [ ] or [[ ]] tests. I\'m not suggesting that = and == are interchangeable everywhere in bash. For example, you obviously can\'t do variable assignment with ==, such as var=="foo" (well technically you can do this, but the value of var will be "=foo", because bash isn\'t seeing an == operator here, it\'s seeing an = (assignment) operator, followed by the literal value ="foo", which just becomes "=foo").Also, although = and == are interchangeable, you should keep in mind that how those tests work does depend on whether you\'re using it inside [ ] or [[ ]], and also on whether or not the operands are quoted.  You can read more about that here: Advanced Bash Scripting Guide: 7.3 Other Comparison Operators (scroll down to the discussion of = and ==).Use arithmetic expressions.Output:true\n    not falseLong ago, when all we had was sh, booleans where handled by relying on a convention of the test program where test returns a false exit status if run with no arguments.  This allows one to think of a variable that is unset as false and variable set to any value as true.  Today, test is builtin to bash and is commonly known by its one character alias [ (or an executable to use in shells lacking it, as dolmen notes):Because of quoting conventions, script writers prefer to use the compound command [[ that mimics test but has nicer syntax:  variables with spaces do not need to be quoted, one can use && and || as logical operators with weird precedence, and there are no POSIX limitations on the number of terms.For example, to determine if FLAG is set and COUNT is a number greater than 1:This stuff can get confusing when spaces, zero length strings, and null variables are all needed and also when your script needs to work with several shells.How to declare and use boolean variables in shell script?Unlike many other programming languages, Bash does not segregate its variables by "type." [1]So the answer is pretty clear. There is no boolean variable in bash.\nHowever :Using a declare statement, we can limit the value assignment to variables.[2]The r option in declare and readonly is used to state explicitly that the variables are readonly. Hope the purpose is clear.Instead of faking a boolean and leaving a trap for future readers, why not just use a better value than true and false?For example:Bill Parker is getting voted down because his definitions are reversed from normal code convention. Normally, true is defined as 0 and false is defined as nonzero. 1 will work for false, as will 9999 and -1. Same with function return values - 0 is success and anything nonzero is failure. Sorry I don\'t have the street creds yet to vote or to reply to him directly.Bash recommends using double brackets now as a habit instead of single brackets, and the link Mike Holt gave explains the differences in how they work. 7.3. Other Comparison OperatorsFor one thing -eq is  a numerical operator, so having the codewill issue an error statement, expecting an integer expression. This applies to either parameter, as neither is an integer value. Yet, if we put double brackets around it, it will not issue an error statement, but will yield a wrong value (well, in 50% of the possible permutations).  It will evaluate to [[0 -eq true]] = success but also to [[0 -eq false]] = success, which is wrong (hmmm.... what about that builtin being a numerical value?).There are other permutations of the conditional which will give wrong output as well. Basically, anything (other than the error condition listed above) that sets a variable to a numerical value and compares it to a true/false builtin, or sets a variable to a true/false builtin and compares it to a numerical value. Also, anything that sets a variable to a true/false builtin and does a comparison using -eq. So avoid -eq  for boolean comparisons and avoid using numerical values for boolean comparisons. Here\'s a summary of the permutations that will give invalid results:So, now to what works. Use true/false builtins for both your comparison and your evaluations (as Mike Hunt noted, don\'t enclose them in quotes). Then use either or single or double equal sign (= or ==) and either single or double brackets ([ ] or [[ ]]). Personally, I like the double equals sign because it reminds me of logical comparisons in other programming languages, and double quotes just because I like typing. So these work:There you have it.Good morning gentle folk.  I found the existing alternatives confusing.  Personally, I just want to have something that looks and works like C.  This is what worked for me.and to keep everyone happy, I tested:Which also worked fine.The $snapshotEvents evaluates the value (content) of the variable.  You don\'t really need the parentheses, I just find them helpful.Here is a improvement on @miku\'s original answer that addresses @dennis concerns about the case where the variable is not set:To test if the variable is false:About the other cases (nasty content in the variable), this is a problem with any external input fed to a program. Any external input must be validated before trusting it. But that validation has to be done just once when that input is received. It doesn\'t have to impact the performance of the program by doing it on every use of the variable like @dennis suggests.Bash really confuses the issue with the likes of [, [[, ((, $(( etc all treading on each others\' codespaces. I guess this is mostly historical, where bash has to pretend to be sh occasionally.Most times, I can just pick a method and stick with it. In this instance, I tend to declare (preferably in a common library file I can . include in my actual scripts)I can then use the (( arithmetic )) comparator operator to test thusly...It\'s not a perfect solution, but it covers every case I need such a test... so I am satisfied with it.