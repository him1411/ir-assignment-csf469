I have a large array in C (not C++ if that makes a difference). I want to initialize all members to the same value. I could swear I once knew a simple way to do this. I could use memset() in my case, but isn\'t there a way to do this that is built right into the C syntax?Unless that value is 0 (in which case you can omit some part of the initializer\nand the corresponding elements will be initialized to 0), there\'s no easy way.Don\'t overlook the obvious solution, though:Elements with missing values will be initialized to 0:So this will initialize all elements to 0:In C++, an empty initialization list will also initialize every element to 0.\nThis is not allowed with C:Remember that objects with static storage duration will initialize to 0 if no\ninitializer is specified:And that "0" doesn\'t necessarily mean "all-bits-zero", so using the above is\nbetter and more portable than memset(). (Floating point values will be\ninitialized to +0, pointers to null value, etc.)If your compiler is GCC you can use following syntax:Check out detailed description:\nhttp://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Designated-Inits.htmlFor statically initializing a large array with the same value, without multiple copy-paste, you can use macros:If you need to change the value, you have to do the replacement at only one place.(courtesy of Jonathan Leffler)You can easily generalize this with:A variant can be created using:that works with structures or compound arrays.macro names are negotiable. If you want to ensure that every member of the array is explicitly initialized, just omit the dimension from the declaration:The compiler will deduce the dimension from the initializer list. Unfortunately, for multidimensional arrays only the outermost dimension may be omitted:is OK, butis not.I saw some code that used this syntax:Where it becomes particularly useful is if you\'re making an array that uses enums as the index:This keeps things in order, even if you happen to write some of the enum-values out of order.More about this technique can be found here and here.I think this is better thanincase the size of the array changes.You can do the whole static initializer thing as detailed above, but it can be a real bummer when your array size changes (when your array embiggens, if you don\'t add the appropriate extra initializers you get garbage).memset gives you a runtime hit for doing the work, but no code size hit done right is immune to array size changes.  I would use this solution in nearly all cases when the array was larger than, say, a few dozen elements.If it was really important that the array was statically declared, I\'d write a program to write the program for me and make it part of the build process.Here is another way:See:C-ExtensionsDesignated initsThen ask the question: When can one use C extensions?The code sample above is in an embedded system and will never see the light from another compiler. For initializing \'normal\' data types (like int arrays), you can use the bracket notation, but it will zero the values after the last if there is still space in the array:A slightly tongue-in-cheek answer; write the statementin your favourite array-capable language (mine is Fortran, but there are many others), and link it to your C code.  You\'d probably want to wrap it up to be an external function.There is a fast way to initialize array of any type with given value. It works very well with large arrays. Algorithm is as follows:For 1 000 000 elements int array it is 4 times faster than regular loop initialization (i5, 2 cores, 2.3 GHz, 4GiB memory, 64 bits):loop runtime 0.004248 [seconds]memfill() runtime 0.001085 [seconds] If the array happens to be int or anything with the size of int or your mem-pattern\'s size fits exact times into an int (i.e. all zeroes or 0xA5A5A5A5), the best way is to use memset().Otherwise call memcpy() in a loop moving the index.You can use memset function.Nobody has mentioned the index order to access the elements of the initialized array. My example code will give an illustrative example to it.The output is:example:\n    int array[10];\n    memset(array,-1, 10 *sizeof(int));Cutting through all the chatter, the short answer is that if you turn on optimization at compile time you won\'t do better than this: Added bonus: the code is actually legible :)I see no requirements in the question, so the solution must be generic: initialization of an unspecified possibly multidimensional array built from unspecified possibly structure elements with an initial member value:Result:EDIT:  start+element_size changed to (char*)start+element_size