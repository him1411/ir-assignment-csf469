I\'ve seen the word static used in different places in C code; is this like a static function/class in C# (where the implementation is shared across objects)?  (1) is the more foreign topic if you\'re a newbie, so here\'s an example:This prints:This is useful for cases where a function needs to keep some state between invocations, and you don\'t want to use global variables. Beware, however, this feature should be used very sparingly - it makes your code not thread-safe and harder to understand.(2) Is used widely as an "access control" feature. If you have a .c file implementing some functionality, it usually exposes only a few "public" functions to users. The rest of its functions should be made static, so that the user won\'t be able to access them. This is encapsulation, a good practice.Quoting Wikipedia:In the C programming language, static\n  is used with global variables and\n  functions to set their scope to the\n  containing file. In local variables,\n  static is used to store the variable\n  in the statically allocated memory\n  instead of the automatically allocated\n  memory. While the language does not\n  dictate the implementation of either\n  type of memory, statically allocated\n  memory is typically reserved in data\n  segment of the program at compile\n  time, while the automatically\n  allocated memory is normally\n  implemented as a transient call stack.See here and here for more details.And to answer your second question, it\'s not like in C#.In C++, however, static is also used to define class attributes (shared between all objects of the same class) and methods. In C there are no classes, so this feature is irrelevant.There is one more use not covered here, and that is as part of an array type declaration as an argument to a function:In this context, this specifies that arguments passed to this function must be an array of type char with at least 10 elements in it. For more info see my question here.Short answer ... it depends.Static defined local variables do not lose their value between function calls. In other words they are global variables, but scoped to the local function they are defined in.Static global variables are not visible outside of the C file they are defined in.Static functions are not visible outside of the C file they are defined in.Multi-file variable scope examplea.c:main.c:Compilation:Output:InterpretationAs usual, the smaller the scope, the better, so always declare variables static if you can.In C programming, files are often used to represent "classes", and static variables represent "private" members of the class.What standards say about itC99 N1256 draft 6.7.1 "Storage-class specifiers" says that static is a "storage-class specifier".6.2.2/3 "Linkages of identifiers" says static implies internal linkage:If the declaration of a file scope identifier for an object or a function contains the storage-class specifier static, the identifier has internal linkage.and 6.2.2/2 says that internal linkage behaves like in our example:In the set of translation units and libraries that constitutes an entire program, each declaration of a particular identifier with external linkage denotes the same object or function. Within one translation unit, each declaration of an identifier with internal linkage denotes the same object or function. where "translation unit is a source file after preprocessing.How GCC implements it for ELF (Linux)?With the STB_LOCAL binding.If we compile:and disassemble the symbol table with:the output contains:so the binding is the only significant difference between them. Value is just their offset into the .bss section, so we expect it to differ.STB_LOCAL is documented on the ELF spec at http://www.sco.com/developers/gabi/2003-12-17/ch4.symtab.html:STB_LOCAL Local symbols are not visible outside the object file containing their definition. Local symbols of the same name may exist in multiple files without interfering with each otherwhich makes it a perfect choice to represent static.Variables without static are STB_GLOBAL, and the spec says:When the link editor combines several relocatable object files, it does not allow multiple definitions of STB_GLOBAL symbols with the same name. which is coherent with the link errors on multiple non static definitions.If we crank up the optimization with -O3, the si symbol is removed entirely from the symbol table: it cannot be used from outside anyways. TODO why keep static variables on the symbol table at all when there is no optimization? Can they be used for anything? Maybe for debugging.See alsoTry it yourselfExample on github for you to play with.It depends:The function would return 1, 2, 3, etc. --- the variable is not on the stack.It means that this function has scope only in this file. So a.c and b.c can have different foo()s, and foo is not exposed to shared objects. So if you defined foo in a.c you couldn\'t access it from b.c or from any other places.In most C libraries all "private" functions are static and most "public" are not.People keep saying that \'static\' in C has two meanings.  I offer an alternate way of viewing it that gives it a single meaning:The reason it seems to have two meanings is that, in C, every item to which \'static\' may be applied already has one of these two properties, so it seems as if that particular usage only involves the other.For example, consider variables.  Variables declared outside of functions already have persistence (in the data segment), so applying \'static\' can only make them not visible outside the current scope (compilation unit).  Contrariwise, variables declared inside of functions already have non-visibility outside the current scope (function), so applying \'static\' can only make them persistent.Applying \'static\' to functions is just like applying it to global variables - code is necessarily persistent (at least within the language), so only visibility can be altered.NOTE: These comments only apply to C.  In C++, applying \'static\' to class methods is truly giving the keyword a different meaning.  Similarly for the C99 array-argument extension.static means different things in different contexts.You can declare a static variable in a C function. This variable is only visible in the function however it behaves like a global in that it is only initialized once and it retains its value. In this example, everytime you call foo() it will print an increasing number. The static variable is initialized only once.Another use of static is when you implement a function or global variable in a .c file but don\'t want its symbol to be visible outside of the .obj generated by the file. e.g.From Wikipedia:In the C programming language, static is used with global variables and functions to set their scope to the containing file. In local variables, static is used to store the variable in the statically allocated memory instead of the automatically allocated memory. While the language does not dictate the implementation of either type of memory, statically allocated memory is typically reserved in data segment of the program at compile time, while the automatically allocated memory is normally implemented as a transient call stack.In C, static has two meanings, depending on scope of its use. In the global scope, when an object is declared at the file level, it means that that object is only visible within that file.At any other scope it declares an object that will retain its value between the different times that the particular scope is entered. For example, if an int is delcared within a procedure:the value of \'i\' is initialized to zero on the first call to the procedure, and the value is retained each subsequent time the procedure is called. if \'i\' were printed it would output a sequence of 0, 1, 2, 3, ...I hate to answer an old question, but I don\'t think anybody has mentioned how K&R explain it in section A4.1 of "The C Programming Language".In short, the word static is used with two meanings:Peter Van Der Linden gives these two meanings in "Expert C Programming":If you declare a variable in a function static, its value will not be stored on the function call stack and will still be available when you call the function again.If you declare a global variable static, its scope will be restricted to within the file in which you declared it. This is slightly safer than a regular global which can be read and modified throughout your entire program.If you declare this in a mytest.c file:Then this variable can only be seen from this file. The variable cannot be exported anywhere else.If you declare inside a function the value of the variable will keep its value each time the function is called.A static function cannot be exported from outside the file. So in a *.c file, you are hiding the functions and the variables if you declare them static.It is important to note that static variables in functions get initialized at the first entry into that function  and persist even after their call has been finished; in case of recursive functions the static variable gets initialized only once and persists as well over all recursive calls and even after the call of the function has been finished.If the variable has been created outside a function, it means that the programmer is only able to use the variable in the source-file the variable has been declared.Also to note that static can be used in 4 different ways.A static variable is a special variable that you can use in a function, and it saves the data between calls, and it does not delete it between calls. For example:The output:0, 1, 2, 3, 4, 5, ...A static variable value persists between different function calls andits scope is limited to the local block\na static var always initializes with value 0Static variables in C have the lifetime of the program.If defined in a function, they have local scope, i.e. they can be accessed only inside those functions. The value of static variables is preserved between function calls.For example:In the above program, var is stored in the data segment. Its lifetime is the whole C program.After function call 1, var becomes 2. After function call 2, var becomes 3.The value of var is not destroyed between functions calls.If var had between non static and local variable, it would be stored in the stack segment in the C program. Since the stack frame of the function is destroyed after the function returns, the value of var is also destroyed.Initialized static variables are stored in the data segment of the C program whereas uninitialized ones are stored in the BSS segment.Another information about static: If a variable is global and static, it has the life time of the C program, but it has file scope. It is visible only in that file.To try this:Now try to link them using:It would give a linker error as x has the file scope of file1.c and the linker would not be able to resolve the reference to variable x used in file2.c.References: