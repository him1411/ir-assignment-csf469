When deleting a column in a DataFrame I use:and this works great. Why can\'t I use:As you can access the column/Series as df.column_name, I expect this to work.It\'s difficult to make del df.column_name work simply as the result of syntactic limitations in Python. del df[name] gets translated to df.__delitem__(name) under the covers by PythonThe best way to do this in pandas is to use drop:where 1 is the axis number (0 for rows and 1 for columns.)To delete the column without having to reassign df you can do:Finally, to drop by column number instead of by column label, try this to delete, e.g. the 1st, 2nd and 4th columns:This will delete one or more columns in-place. Note that inplace=True was added in pandas v0.13 and won\'t work on older versions, do you\'d have to do assign the result back in that case:delete first, second and fourth columns:delete first column:There is an optional parameter inplace so that the original\ndata can be modified without creating a copy.Column selection, addition, deletiondelete column column-name:print df:df.drop(df.columns[[0]], axis=1, inplace=True)\nprint df:three = df.pop(\'three\')\nprint df:The actual question posed, missed by most answers here is:At first we need to understand the problem, which requires us to dive into python magic methods.As Wes points out in his answer del df[\'column\'] maps to the python magic method df.__delitem__(\'column\') which is implemented in pandas to drop the columnHowever, as pointed out in the link above about python magic methods:In fact, del should almost never be used because of the precarious circumstances under which it is called; use it with caution!You could argue that del df[\'column_name\'] should not be used or encouraged, and thereby del df.column_name should not even be considered.However, in theory, del df.column_name could be implemeted to work in pandas using the magic method __delattr__. This does however introduce certain problems, problems which the del df[\'column_name\'] implementation already has, but in lesser degree.What if I define a column in a dataframe called "dtypes" or "columns".Then assume I want to delete these columns.del df.dtypes would make the __delattr__ method confused as if it should delete the "dtypes" attribute or the "dtypes" column.You cannot do del df.column_name because pandas has a quite wildly grown architecture that needs to be reconsidered in order for this kind of cognitive dissonance not to occur to its users.Don\'t use df.column_name, It may be pretty, but it causes cognitive dissonanceThere are multiple ways of deleting a column.There should be one-- and preferably only one --obvious way to do it.Columns are sometimes attributes but sometimes not.Special cases aren\'t special enough to break the rules.Does del df.dtypes delete the dtypes attribute or the dtypes column?In the face of ambiguity, refuse the temptation to guess.from version 0.16.1 you can do A nice addition is the ability to drop columns only if they exist, this way you can cover more use cases, and it will only drop the existing columns from the labels passed to it: simply add errors=\'ignore\' ,e.g:It\'s good practice to always use the [] notation, one reason is that attribute notation (df.column_name) does not work for numbered indices:In pandas 0.16.1+ you can drop columns only if they exist per the solution posted by @eiTanLaVi.  Prior to that version, you can achieve the same result via a conditional list comprehension:You should use drop(). Suppose your dataframe name is df. A lot of effort to find a marginally more efficient solution.  Difficult to justify the added complexity while sacrificing the simplicity of df.drop(dlst, 1, errors=\'ignore\')Preamble\nDeleting a column is semantically the same as selecting the other columns.  I\'ll show a few additional methods to consider.  I\'ll also focus on the general solution of deleting multiple columns at once and allowing for the attempt to delete columns not present.  Using these solutions are general and will work for the simple case as well.Setup\nConsider the pd.DataFrame df and list to delete dlstThe result should look like:Since I\'m equating deleting a column to selecting the other columns, I\'ll break it into two types:We start by manufacturing the list/array of labels that represent the columns we want to keep and without the columns we want to delete.df.columns.difference(dlst)np.setdiff1d(df.columns.values, dlst)df.columns.drop(dlst, errors=\'ignore\')list(set(df.columns.values.tolist()).difference(dlst))[x for x in df.columns.values.tolist() if x not in dlst]Columns from Labels\nFor the sake of comparing the selection process, assume:Then we can evaluate  Which all evaluate to:We can construct an array/list of booleans for slicingColumns from Boolean\nFor the sake of comparison  Which all evaluate to:Robust Timing Functions Testing This is relative to the time it takes to run df.drop(dlst, 1, errors=\'ignore\').  It seems like after all that effort, we only improve performance modestly.If fact the best solutions use reindex or reindex_axis on the hack list(set(df.columns.values.tolist()).difference(dlst)).  A close second and still very marginally better than drop is np.setdiff1d.the dot syntax works in JS but not in python.Python: del df[\'column_name\']JS:     del df[\'column_name\'] OR del df.column_name