Apple mentioned that they could co-exist in one application, but does this mean that one could technically re-use old classes made in Objective-C whilst building new classes in Swift?Objective-C is a platform-independent language, whereas Swift is platform-dependent. Writing non-platform-dependent code (business logic libraries) in Swift would thus not be wise. However, writing platform-dependent code in it (interface related for example) would be perfectly fine. Not to say it would be a good idea, however it is definitely an interest.**\nIf you have an existing class that you\'d like to use, perform Step 2 and then skip to Step 5. (For some cases, I had to add an explicit #import <Foundation/Foundation.h to an older Objective-C File.)\n**Add a .m file to your class, and name it CustomObject.m.When adding your .m file, you\'ll likely be hit with a prompt that looks like this:Click  YES !  If you did not see the prompt, or accidentally deleted your bridging header, add a new .h file to your project and name it <#YourProjectName#>-Bridging-Header.h.In some situations, particularly when working with Objective-C frameworks, you don\'t add an Objective-C class explicitly and Xcode can\'t find the linker. In this case, create your .h file named as mentioned above, then make sure you link its path in your target\'s project settings like so:NoteIt\'s best practice to link your project using the $(SRCROOT) macro so that if you move your project, or work on it with others using a remote repository, it will still work. $(SRCROOT) can be thought of as the directory that contains your .xcodeproj file. It might look like this:Add another .h file and name it CustomObject.h.In CustomObject.hIn CustomObject.mIn YourProject-Bridging-Header.h:In SomeSwiftFile.swift:There is no need to import explicitly; that\'s what the bridging header is for.  Add a .swift file to your project, and name it MySwiftObject.swift.In MySwiftObject.swift:In SomeRandomClass.m:The file:<#YourProjectName#>-Swift.h should already be created automatically in your project, even if you can not see it.1. CodeCompletion wasn\'t behaving as accurately as I\'d like it to. On my system, running a quick build with "cmd + r" seemed to help Swift find some of the Objective-C code and vice versa. 2. If you add a .swift file to an older project and get error: dyld: Library not loaded: @rpath/libswift_stdlib_core.dylib, try completely restarting Xcode.3. While it was originally possible to use pure Swift classes in Objective-C by using the @objc prefix, after Swift 2.0, this is no longer possible. See edit history for original explanation. If this functionality is reenabled in future Swift versions, the answer will be updated accordingly.See Apple\'s guide to Using Swift with Cocoa and Objective-C. This guide covers how to use Objective-C and C code from Swift and vice versa and has recommendations for how to convert a project or mix and match Objective-C/C and Swift parts in an existing project.The compiler automatically generates Swift syntax for calling C functions and Objective-C methods. As seen in the documentation, this Objective-C:turns into this Swift code:Xcode also does this translation on the fly \xe2\x80\x94 you can use Open Quickly while editing a Swift file and type an Objective-C class name, and it\'ll take you to a Swift-ified version of the class header. (You can also get this by cmd-clicking on an API symbol in a Swift file.) And all the API reference documentation in the iOS 8 and OS X v10.10 (Yosemite) developer libraries is visible in both Objective-C and Swift forms (e.g. UIView).Here are step-by-step instructions for using Objective-C code (in this case, a framework provided by a third-party) in a Swift project:In simple steps:A prompt appears, and then click on OK... If it does not appear,  then we create it manually like in the following... Create one header file from iOS source and give the name ProjectName-Bridging-Header (example: Test-Bridging-Header), and then go to build setting in the Swift compiler code -> Objective-C bridge add Objective-C bridge name ..(Test/Test-Bridging-Header.h). Yeah, that\'s complete.Optionally, delete the Objective-C file you added (named "anything" in the GIF image above). You don\'t need it any more.Open the bridging header file -- the filename is of the form [YourProject]-Bridging-Header.h. It includes an Xcode-provided comment. Add a line of code for the Objective-C file you want to include, such as a third-party framework. For example, to add Mixpanel to your project, you will need to add the following line of code to the bridging header file:Now in any Swift file you can use existing Objective-C code, in the Swift syntax (in the case of this example, and you can call Mixpanel SDK methods, etc.). You need to familiarize yourself with how Xcode translates Objective-C to Swift. Apple\'s guide is a quick read. Or see this answer for an incomplete summary.Example for Mixpanel:That\'s it!Note: If you remove the bridging header file from your project, be sure to go into Build Settings and remove the value for "Objective-C Bridging Header" under "Swift Compiler - Code Generation".You can read the nice post Swift & Cocoapods. Basically, we need to create a bridging header file and put all Objective-C headers there. And then we need to reference it from our build settings. After that, we can use the Objective-C code.Also have a look at Apple\'s document Using Swift with Cocoa and Objective-C as well.I wrote a simple Xcode 6 project that shows how to mix C++, Objective-C and Swift code:https://github.com/romitagl/shared/tree/master/C-ObjC-Swift/Performance_ConsoleIn particular, the example calls an Objective-C and a C++ function from the Swift.The key is to create a shared header, Project-Bridging-Header.h, and put the Objective-C headers there.Please download the project as a complete example.Quote from the documentation:Any Objective-C framework (or C library) that\xe2\x80\x99s accessible as a module\n  can be imported directly into Swift. This includes all of the\n  Objective-C system frameworks\xe2\x80\x94such as Foundation, UIKit, and\n  SpriteKit\xe2\x80\x94as well as common C libraries supplied with the system. For\n  example, to import Foundation, simply add this import statement to the\n  top of the Swift file you\xe2\x80\x99re working in:import FoundationThis import makes all of the Foundation APIs\xe2\x80\x94including NSDate, NSURL,\n  NSMutableData, and all of their methods, properties, and\n  categories\xe2\x80\x94directly available in Swift.I am very thankful to @Logan\'s answer. It helps a lot to create a bridge file and setups.But after doing all these steps I\'m still not getting an Objective-C class in Swift.I used the cocoapods library and integrated it in my project. Which is pod "pop".So if are using Objective-C pods in Swift then there may be a chance that you can not able to get or import the classes into Swift.The simple thing you have to do is:For example: (Pop library)ReplacewithUse clang import when #import is not working.Just a note for whoever is trying to add an Objective-C library to Swift: You should add -ObjC in Build Settings -> Linking -> Other Linker Flags.Click on the New file menu, and chose file select language Objective.  At that time it automatically generates a "Objective-C Bridging Header" file that is used to define some class name."Objective-C Bridging Header" under "Swift Compiler - Code Generation".After you created a Bridging header, go to Build Setting => Search for "Objective-C Bridging Header".Just below you will find the ""Objective-C Generated Interface Header Name" file.Import that file in your view controller.Example: In my case: "Dauble-Swift.h"Any Objective-C framework (or C library) that\xe2\x80\x99s accessible as a module can be imported directly into Swift. This includes all of the Objective-C system frameworks\xe2\x80\x94such as Foundation, UIKit, and SpriteKit\xe2\x80\x94as well as common C libraries supplied with the system. For example, to import Foundation, simply add this import statement to the top of the Swift file you\xe2\x80\x99re working in:This import makes all of the Foundation APIs\xe2\x80\x94including NSDate, NSURL, NSMutableData, and all of their methods, properties, and categories\xe2\x80\x94directly available in Swift.I have taken this from Apple\'s documentation.