I want to create a URL shortener service where you can write a long URL into an input field and the service shortens the URL to "http://www.example.org/abcdef".Edit: Due to the ongoing interest in this topic, I\'ve published an efficient solution to GitHub, with implementations for JavaScript, PHP, Python and Java. Add your solutions if you like :)Instead of "abcdef" there can be any other string with six characters containing a-z, A-Z and 0-9. That makes 56~57 billion possible strings.My approach:I have a database table with three columns:I would then insert the long URL into the table. Then I would select the auto-increment value for "id" and build a hash of it. This hash should then be inserted as "short". But what sort of hash should I build? Hash algorithms like MD5 create too long strings. I don\'t use these algorithms, I think. A self-built algorithm will work, too.My idea:For "http://www.google.de/" I get the auto-increment id 239472. Then I do the following steps:That could be repeated until the number isn\'t divisible any more. Do you think this is a good approach? Do you have a better idea?I would continue your "convert number to string" approach. However you will realize that your proposed algorithm fails if your ID is a prime and greater than 52.You need a Bijective Function f. This is necessary so that you can find a inverse function g(\'abc\') = 123 for your f(123) = \'abc\' function. This means:Take an auto-generated, unique numerical key (the auto-incremented id of a MySQL table for example).For this example I will use 12510 (125 with a base of 10).Now you have to convert 12510 to X62 (base 62).12510 = 2\xc3\x97621 + 1\xc3\x97620 = [2,1]This requires use of integer division and modulo. A pseudo-code example:Now map the indices 2 and 1 to your alphabet. This is how your mapping (with an array for example) could look like:With 2 \xe2\x86\x92 c and 1 \xe2\x86\x92 b you will receive cb62 as the shortened URL.The reverse is even easier. You just do a reverse lookup in your alphabet.e9a62 will be resolved to "4th, 61st, and 0th letter in alphabet".e9a62 = [4,61,0] = 4\xc3\x97622 + 61\xc3\x97621 + 0\xc3\x97620 = 1915810Now find your database-record with WHERE id = 19158 and do the redirect.Why would you want to use a hash?\nYou can just use a simple translation of your auto-increment value to an alphanumeric value.\nYou can do that easily by using some base conversion. Say you character space (A-Z,a-z,0-9 etc\') has 40 characters, convert the id to a base-40 number and use the characters are the digits.Not an answer to your question, but I wouldn\'t use case-sensitive shortened URLs. They are hard to remember, usually unreadable (many fonts render 1 and l, 0 and O and other characters very very similar that they are near impossible to tell the difference) and downright error prone. Try to use lower or upper case only.Also, try to have a format where you mix the numbers and characters in a predefined form. There are studies that show that people tend to remember one form better than others (think phone numbers, where the numbers are grouped in a specific form). Try something like num-char-char-num-char-char. I know this will lower the combinations, especially if you don\'t have upper and lower case, but it would be more usable and therefore useful.My approach: Take the Database ID, then Base36 Encode it. I would NOT use both Upper AND Lowercase letters, because that makes transmitting those URLs over the telephone a nightmare, but you could of course easily extend the function to be a base 62 en/decoder.Here is my PHP 5 class. You could hash the entire URL, but if you just want to shorten the id, do as marcel suggested. I wrote this python implementation:https://gist.github.com/778542C# version:If you don\'t want re-invent the wheel ... http://lilurl.sourceforge.net/Here\'s my version for whomever needs it.Why not just translate your id to a string? You just need a function that maps a digit between, say, 0 and 61 to a single letter (upper/lower case) or digit. Then apply this to create, say, 4-letter codes, and you\'ve got 14.7 million URLs covered.Here is a decent URL encoding function for PHP...Don\'t know if anyone will find this useful - it is more of a \'hack n slash\' method, yet is simple and works nicely if you want only specific chars.This is what I use:It\'s very fast and can take long integers.For a similar project, to get a new key, I make a wrapper function around a random string generator that calls the generator until I get a string that hasn\'t already been used in my hashtable. This method will slow down once your name space starts to get full, but as you have said, even with only 6 characters, you have plenty of namespace to work with.did you omit O, 0, i on purpose ?Just created a php class based on Ryan\'s solution.I have a variant of the problem, in that I store web pages from many different authors and need to prevent discovery of pages by guesswork. So my short URLs add a couple of extra digits to the Base-62 string for the page number. These extra digits are generated from information in the page record itself and they ensure that only 1 in 3844 URLs are valid (assuming 2-digit Base-62). You can see an outline description at http://mgscan.com/MBWL.Very good answer, I have created a Golang implementation of the bjf:Hosted at github: https://github.com/xor-gate/go-bjfMy python3 version Here is Node.js implementation that is likely to bit.ly. generate highly random 7 character string. using Node.js crypto to generate highly random 25 charset than random select 7 character.For a quality NodeJS / Javascript solution, see the id-shortener module, which is thoroughly tested and has been used in production for months.It provides an efficient id / url shortener backed by pluggable storage defaulting to redis, and you can even customize your short id character set and whether or not shortening is idempotent. This is an important distinction that not all URL shorteners take into account.In relation to other answers here, this module implements the Marcel Jackwerth\'s excellent accepted answer above.The core of the solution is provided by the following Redis Lua snippet: