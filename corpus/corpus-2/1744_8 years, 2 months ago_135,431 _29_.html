What are the differences between implementing a @property with @dynamic or @synthesize?@synthesize will generate getter and setter methods for your property.\n@dynamic just tells the compiler that the getter and setter methods are implemented not by the class itself but somewhere else (like the superclass or will be provided at runtime).Uses for @dynamic are e.g. with subclasses of NSManagedObject (CoreData) or when you want to create an outlet for a property defined by a superclass that was not defined as an outlet.@dynamic also can be used to delegate the responsibility of implementing the accessors. If you implement the accessors yourself within the class then you normally do not use @dynamic.Super class: Subclass:Take a look at this article; under the heading "Methods provided at runtime":Some accessors are created dynamically at runtime, such as certain ones used in CoreData\'s NSManagedObject class. If you want to declare and use properties for these cases, but want to avoid warnings about methods missing at compile time, you can use the @dynamic directive instead of @synthesize....Using the @dynamic directive essentially tells the compiler "don\'t worry about it, a method is on the way."The @synthesize directive, on the other hand, generates the accessor methods for you at compile time (although as noted in the "Mixing Synthesized and Custom Accessors" section it is flexible and does not generate methods for you if either are implemented).As others have said, in general you use @synthesize to have the compiler generate the getters and/ or settings for you, and @dynamic if you are going to write them yourself.There is another subtlety not yet mentioned: @synthesize will let you provide an implementation yourself, of either a getter or a setter. This is useful if you only want to implement the getter for some extra logic, but let the compiler generate the setter (which, for objects, is usually a bit more complex to write yourself).However, if you do write an implementation for a @synthesize\'d accessor it must still be backed by a real field (e.g., if you write -(int) getFoo(); you must have an int foo; field). If the value is being produce by something else (e.g. calculated from other fields) then you have to use @dynamic.@dynamic is typically used (as has been said above) when a property is being dynamically created at runtime.  NSManagedObject does this (why all its properties are dynamic) -- which suppresses some compiler warnings.For a good overview on how to create properties dynamically (without NSManagedObject and CoreData:, see: http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1here is  example of @dynamicAs per the documentation:https://developer.apple.com/library/mac/documentation/cocoa/conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html@dynamic tells the compiler that the accessor methods are provided at runtime.With a little bit of investigation I found out that providing accessor methods override the @dynamic directive.@synthesize tells the compiler to create those accessors for you (getter and setter)@property tells the compiler that the accessors will be created, and that can be accessed with the dot notation or [object message]One thing want to add is that if a property is declared as @dynamic it will not occupy memory (I confirmed with allocation instrument). A consequence is that you can declare property in class category.As per the Apple documentation.You use the @synthesize statement in a class\xe2\x80\x99s implementation block to tell the compiler to create implementations that match the specification you gave in the @property declaration.You use the @dynamic statement to tell the compiler to suppress a warning if it can\xe2\x80\x99t find an implementation of accessor methods specified by an @property declaration.More info:-https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html