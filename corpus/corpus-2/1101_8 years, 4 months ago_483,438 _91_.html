What is the difference between public, private, and protected inheritance in C++? All of the questions I\'ve found on SO deal with specific cases.To answer that question, I\'d like to describe member\'s accessors first in my own words. If you already know this, skip to the heading "next:".There are three accessors that I\'m aware of: public, protected and private. Let:By "is aware of", I mean "acknowledge the existence of, and thus be able to access".The same happens with public, private and protected inheritance. Let\'s consider a class Base and a class Child that inherits from Base.IMPORTANT NOTE: Classes B, C and D all contain the variables x, y and z. It is just question of access.About usage of protected and private inheritance you could read here.Limiting the visibility of inheritance will make code not able to see that some class inherits another class: Implicit conversions from the derived to the base won\'t work, and static_cast from the base to the derived won\'t work either. Only members/friends of a class can see private inheritance, and only members/friends and derived classes can see protected inheritance. public inheritanceIS-A inheritance. A button is-a window, and anywhere where a window is needed, a button can be passed too. protected inheritanceProtected implemented-in-terms-of. Rarely useful. Used in boost::compressed_pair to derive from empty classes and save memory using empty base class optimization (example below doesn\'t use template to keep being at the point):private inheritanceImplemented-in-terms-of. The usage of the base class is only for implementing the derived class. Useful with traits and if size matters (empty traits that only contain functions will make use of the empty base class optimization). Often containment is the better solution, though. The size for strings is critical, so it\'s an often seen usage herepublic memberAggregateAccessorsprotected memberProviding enhanced access for derived classesprivate memberKeep implementation detailsNote that C-style casts purposely allows casting a derived class to a protected or private base class in a defined and safe manner and to cast into the other direction too. This should be avoided at all costs, because it can make code dependent on implementation details - but if necessary, you can make use of this technique. It has to do with how the public members of the base class are exposed from the derived class.As litb points out, public inheritance is traditional inheritance that you\'ll see in most programming languages. That is it models an "IS-A" relationship. Private inheritance, something AFAIK peculiar to C++, is an "IMPLEMENTED IN TERMS OF" relationship. That is you want to use the public interface in the derived class, but don\'t want the user of the derived class to have access to that interface. Many argue that in this case you should aggregate the base class, that is instead of having the base class as a private base, make in a member of derived in order to reuse base class\'s functionality.Inheritance type  :             Object inherited as:\nThese three keywords are also used in a completely different context to specify the visibility inheritance model. This table gathers all of the possible combinations of the component declaration and inheritance model presenting the resulting access to the components when the subclass is completely defined.It reads in the following way (take a look at the first row): if a component is declared as public and its class is inherited as public the resulting access is public.An example:   The resulting access for variables p, q, r in class Subsub is none.Another example:The resulting access for variables y, z in class Sub is protected and for variable x is none.A more detailed example:Now lets define a subclass:The defined class named Sub which is a subclass of class named Super or that Sub class is derived from the Super class. \nThe Sub class introduces neither new variables nor new functions. Does it mean that any object of the Sub class inherits all the traits after the Super class being in fact a copy of a Super class\xe2\x80\x99 objects?No. It doesn\xe2\x80\x99t.If we compile the following code, we will get nothing but compilation errors saying that put and get methods are inaccessible. Why? When we omit the visibility specifier, the compiler assumes that we are going to apply the so-called private inheritance. It means that all public superclass components turn into private access, private superclass components won\'t be accessible at all. It consequently means that you are not allowed to use the latter inside the subclass.We have to inform the compiler that we want to preserve the previously used access policy.Don\xe2\x80\x99t be misled: it doesn\xe2\x80\x99t mean that private components of the Super\n  class (like the storage variable) will turn into public ones in a\n  somewhat magical way. Private components will remain private, public\n  will remain public.Objects of the Sub class may do "almost" the same things as their older siblings created from the Super class. "Almost" because the fact of being a subclass also means that the class lost access to the private components of the superclass. We cannot write a member function of the Sub class which would be able to directly manipulate the storage variable.This is a very serious restriction. Is there any workaround?Yes.The third access level is called protected. The keyword protected means that the component marked with it behaves like a public one when used by any of the subclasses and looks like a private one to the rest of the world. -- This is true only for the publicly inherited classes (like the Super class in our example) --As you see in the example code we a new functionality to the Sub class and it does one important thing: it accesses the storage variable from the Super class. It wouldn\xe2\x80\x99t be possible if the variable was declared as private.\nIn the main function scope the variable remains hidden anyway so if you write anything like:The compiler will inform you that it is an error: \'int Super::storage\' is protected.Finally, the last program will produce the following output:1) Public Inheritance:a. Private members of Base class are not accessible in Derived class.b. Protected members of Base class remain protected in Derived class.c. Public members of Base class remain public in Derived class.So, other classes can use public members of Base class through Derived class object.2) Protected Inheritance:a. Private members of Base class are not accessible in Derived class.b. Protected members of Base class remain protected in Derived class.c. Public members of Base class too become protected members of Derived class.So, other classes can\'t use public members of Base class through Derived class object; but they are available to subclass of Derived.3) Private Inheritance:a. Private members of Base class are not accessible in Derived class.b. Protected & public members of Base class become private members of Derived class.So, no members of Base class can be accessed by other classes through Derived class object as they are private in Derived class. So, even subclass of Derived \nclass can\'t access them.Public inheritance models an IS-A relationship. With every D is a B. Private inheritance models an IS-IMPLEMENTED-USING relationship (or whatever that\'s called). With a D is not a B, but every D uses its B in its implementation. Private inheritance can always be eliminated by using containment instead: This D, too, can be implemented using B, in this case using its b_. Containment is a less tight coupling between types than inheritance, so in general it should be preferred. Sometimes using containment instead of private inheritance is not as convenient as private inheritance. Often that\'s a lame excuse for being lazy. I don\'t think anyone knows what protected inheritance models. At least I haven\'t seen any convincing explanation yet. If you inherit publicly from another class, everybody knows you are inheriting and you can be used polymorphically by anyone through a base class pointer.If you inherit protectedly only your children classes will be able to use you polymorphically.If you inherit privately only yourself will be able to execute parent class methods.Which basically symbolizes the knowledge the rest of the classes have about your relationship with your parent classProtected data members can be accessed by any classes that inherit from your class. Private data members, however, cannot. Let\'s say we have the following:From within your extension to this class, referencing this.myPrivateMember won\'t work. However, this.myProtectedMember will. The value is still encapsulated, so if we have an instantiation of this class called myObj, then myObj.myProtectedMember won\'t work, so it is similar in function to a private data member.Based on this example for java... I think a little table worth a thousand words :)Summary:When inheriting, you can (in some languages) change the protection type of a data member in certain direction, e.g. from protected to public.The private members of a base class can only be accessed by members of that base class .The public members of a base class can be accessed by members of that base class, members of its derived class as well as the members which are outside the base class and derived class.The protected members of a base class can be accessed by members of base class as well as members of its derived class.private:  baseprotected:  base + derivedpublic:  base + derived + any other memberIt\'s essentially the access protection of the public and protected members of the base class in the derived class.  With public inheritance, the derived class can see public and protected members of the base.  With private inheritance, it can\'t.  With protected, the derived class and any classes derived from that can see them.I found an easy answer and so thought of posting it for my future reference too.Its from the links http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/See these codes to understand features of c++ about inheritance...\nI put the result at the end...\nHope it helps.