What is the \'Angular way\' to set focus on input field in AngularJS?More specific requirements:I tried to achieve the first requirement with autofocus, but this works only when the Modal is opened for the first time, and only in certain browsers (e.g. in Firefox it doesn\'t work).Any help will be appreciated.Define a directive and have it $watch a property/trigger so it knows when to focus the element:PlunkerThe $timeout seems to be needed to give the modal time to render.\'2.\' Everytime <input> becomes visible (e.g. by clicking some button), set focus on it.Create a directive essentially like the one above.  Watch some scope property, and when it becomes true (set it in your ng-click handler), execute element[0].focus().  Depending on your use case, you may or may not need a $timeout for this one:PlunkerUpdate 7/2013:  I\'ve seen a few people use my original isolate scope directives and then have problems with embedded input fields (i.e., an input field in the modal).  A directive with no new scope (or possibly a new child scope) should alleviate some of the pain.  So above I updated the answer to not use isolate scopes.  Below is the original answer:Original answer for 1., using an isolate scope:Plunker.Original answer for 2., using an isolate scope:Plunker.Since we need to reset the trigger/focusInput property in the directive, \'=\' is used for two-way databinding.  In the first directive, \'@\' was sufficient.  Also note that when using \'@\' we compare the trigger value to "true" since @ always results in a string.Mark Rajcok is the man... and his answer is a valid answer, but it has had a defect (sorry Mark)......Try using the boolean to focus on the input, then blur the input, then try using it to focus the input again. It won\'t work unless you reset the boolean to false, then $digest, then reset it back to true. Even if you use a string comparison in your expression, you\'ll be forced to change the string to something else, $digest, then change it back. (This has been addressed with the blur event handler.)So I propose this alternate solution:JavaScript loves events after all. Events are inherently loosely coupled, and even better, you avoid adding another $watch to your $digest.So now you could use it like this:and then anywhere in your app... This is awesome because you can do all sorts of things with something like this. For one, you could tie into events that already exist. For another thing you start doing something smart by having different parts of your app publish events that other parts of your app can subscribe to.Anyhow, this type of thing screams "event driven" to me. I think as Angular developers we try really hard to hammer $scope shaped pegs into event shape holes.Is it the best solution? I dunno. It\'s a solution.After @ShimonRachlenko\'s comment below, I\'ve changed my method of doing this slightly. Now I use a combination of a service and a directive that handles an event "behind the scenes":Other than that, it\'s the same principal outlined above.Here is a quick demo PlunkI have found some of the other answers to be overly complicated when all you really need is thisusage is We use the timeout to let things in the dom render, even though it is zero, it at least waits for that - that way this works in modals and whatnot tooHTML has an attribute autofocus.http://www.w3schools.com/tags/att_input_autofocus.aspYou can also use the jqlite functionality built into angular.angular.element(\'.selector\').trigger(\'focus\');This works well and an angular way to focus input controlThis is although not a pure angular way of doing the task yet the syntax follows angular style. Jquery plays role indirectly and directly access DOM using Angular (jQLite => JQuery Light).If required, this code can easily be put inside a simple angular directive where element is directly accessible.I don\'t think $timeout is a good way to focus the element on creation. Here is a method using built-in angular functionality, dug out from the murky depths of the angular docs. Notice how the "link" attribute can be split into "pre" and "post", for pre-link and post-link functions.Working Example: http://plnkr.co/edit/Fj59GBFull AngularJS Directive Docs: https://docs.angularjs.org/api/ng/service/$compileHere is my original solution:plunkerAnd the HTML:It focuses the input as it becomes visible with ng-show. No use of $watch or $on here.I\'ve written a two-way binding focus directive, just like model recently.You use focus directive like this:If you make someFocusVariable scope variable true in anywhere in your controller, input got focus. And if you "blur" your input, someFocusVariable is set to false. It\'s like Mark Rajcok\'s first answer but with two-way binding.Here is the directive:Usage:Here is the fiddle:http://fiddle.jshell.net/ubenzer/9FSL4/8/For those who use Angular with the Bootstrap plugin:http://angular-ui.github.io/bootstrap/#/modalYou can hook into the opened promise of the modal instance:Instead of creating your own directive, it\'s possible to simply use javascript functions to accomplish a focus.Here is an example.In the html file:In a file javascript, in a controller for example, where you want to activate the focus:Not to resurrect a zombie or plug my own directive (ok that\'s exactly what I\'m doing):https://github.com/hiebj/ng-focus-ifhttp://plnkr.co/edit/MJS3zRk079Mu72o5A9l6?p=previewFirst, an official way to do focus is on the roadmap for 1.1. Meanwhile, you can write a directive to implement setting focus.Second, to set focus on an item after it has become visible currently requires a workaround. Just delay your call to element focus() with a $timeout.Because the same controller-modifies-DOM problem exists for focus, blur and select, I propose having an ng-target directive:Angular thread here: http://goo.gl/ipsx4 , and more details blogged here: http://goo.gl/4rdZaThe following directive will create a .focus() function inside your controller as specified by your ng-target attribute. (It creates a .blur() and a .select() too.) Demo: http://jsfiddle.net/bseib/WUcQX/I found it useful to use a general expression.  This way you can do stuff like automatically move focus when input text is validOr automatically focus when the user completes a fixed length fieldAnd of course focus after loadThe code for the directive:If you just wanted a simple focus that was controlled by an ng-click.Html:Directive:A simple one that works well with modals:ExampleYou could just create a directive that forces focus on the decorated element on postLinking: Then in your html:This would work for modals and ng-if toggled elements, not for ng-show since postLinking happens only on HTML processing.Mark and Blesh have great answers; however, Mark\'s has a flaw that Blesh points out (besides being complex to implement), and I feel that Blesh\'s answer has a semantic error in creating a service that\'s specifically about sending focus request to the frontend when really all he needed was a way to delay the event until all the directives were listening.So here is what I ended up doing which steals a lot from Blesh\'s answer but keeps the semantics of the controller event and the "after load" service separate.This allows the controller event to easily be hooked for things other than just focusing a specific element and also allows to incur the overhead of the "after load" functionality only if it is needed, which it may not be in many cases.Just a newbie here, but I was abble to make it work in a ui.bootstrap.modal with this directive:and in the $modal.open method I used the folowing to indicate the element where the focus should be putted:on the template I have this:I edit \'Mark Rajcok\'  focusMe directive to work for multiple focus in one element.HTML:in AngularJs Controller:AngulaJS Directive:The following directive did the trick for me. Use the same autofocus html attribute for input.If you are using modalInstance and have the object you can use "then" to do actions after opening the modal. If you are not using the modalInstance, and hard coded to open the modal you can use the event. The $timeout is not a good solution.You can do (Bootstrap3):At modalInstance you can look at library to how execute the code after open modal.Don\'t use $timeout like this, the $timeout can be 0, 1, 10, 30, 50, 200 or more this will depend on client computer, and the process to open modal.Don\'t use $timeout let the method tell you when you can focus ;)I hope that this help! :)All of the previous answer doesn\'t work if the desired focus element is injected in a directive template.\nThe following directive fit to both simple element or directive injected element (I wrote it in typescript). it accept selector for inner focusable element. if you just need to focus the self element - don\'t send any selector parameter to the directive :}usage example for simple element:usage example for inner element (usually for dynamic injected element like directive with template):you can use any jQuery selector instead of "input"I want to contribute to this discussion after searching for at better solution and not finding it, having to create it instead.Criteria: \n1. Solution should be independent of parent controller scope to increase re-usability.\n2. Avoid the use of $watch to monitor some condition, this is both slow, increases the size of the digest loop and makes testing harder.\n3. Avoid $timeout or $scope.$apply() to trigger a digest loop.\n4. An input element is present within the element where the Directive is used open.This is the solution I liked the most:Directive: Html: I hope this will help someone out there!This is also possible to use ngModelController. Working with 1.6+ (don\'t know with older versions).HTMLJS--N.B.: Depending of the context, you maybe have to wrap in a timeout function.N.B.\xc2\xb2: When using controllerAs, this is almost the same. Just replace name="myForm" with name="vm.myForm" and in JS, vm.myForm.myText.$$element.focus();.Probably, the simplest solution on the ES6 age.Adding following one liner directive makes HTML \'autofocus\' attribute effective on Angular.js.Now, you can just use HTML5 autofocus syntax like:I think the directive is unnecessary. Use HTML id and class attributes to select the required element and have the service use document.getElementById or document.querySelector to apply focus (or jQuery equivalents).Markup is standard HTML/angular directives with added id/classes for selectionController broadcasts eventIn UI service uses querySelector - if there are multiple matches (say due to class) it will only return the firstYou may want to use $timeout() to force a digest cycleJust throwing in some coffee.Not sure if relying on the timeout is a good idea, but this works for ng-repeat because this code runs AFTER angularjs updates the DOM, so you make sure all objects are there:you can use below directive that get a bool value in html input for focus on it...You can even set a function in your controller to ngFocus directive value\npay attention to below code...this directive to happen when html page render.     