When asking about common undefined behavior in C, souls more enlightened than I referred to the strict aliasing rule.\nWhat are they talking about?A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to uint32_ts or uint16_ts). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.So in this kind of setup, if I want to send a message to something I\'d have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases another of an incompatible type is undefined behavior. Unfortunately, you can still code this way, maybe get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code. (GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn\'t have to think about inserting instructions to refresh the contents of buff every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load buff[0] and buff[1] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of buff could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don\'t type-pun pointers, the strict aliasing rule was introduced.Keep in mind, if you think the example is contrived, this might even happen if you\'re passing a buffer to another function doing the sending for you, if instead you have.And rewrote our earlier loop to take advantage of this convenient functionThe compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If SendMessage is part of another API that\'s compiled separately, it probably has instructions to load buff\'s contents. Then again, maybe you\'re in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it\'s just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what\'s happening under the hood, it\'s still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn\'t necessarily help.So how do I get around this?Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.You can disable strict aliasing in your compiler (f[no-]strict-aliasing in gcc)) You can use char* for aliasing instead of your system\'s word. The rules allow an exception for char* (including signed char and unsigned char). It\'s always assumed that char* aliases other types. However this won\'t work the other way: there\'s no assumption that your struct aliases a buffer of chars.Beginner bewareThis is only one potential minefield when overlaying two types onto each other. You should also learn about endianness, word alignment, and how to deal with alignment issues through packing structs correctly.The best explanation I have found is by Mike Acton, Understanding Strict Aliasing. It\'s focused a little on PS3 development, but that\'s basically just GCC.From the article:"Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)"So basically if you have an int* pointing to some memory containing an int and then you point a float* to that memory and use it as a float you break the rule. If your code does not respect this, then the compiler\'s optimizer will most likely break your code.The exception to the rule is a char*, which is allowed to point to any type.This is the strict aliasing rule, found in section 3.10 of the C++03 standard (other answers provide good explanation, but none provided the rule itself):If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:New C++11 wording (changes emphasized):If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:Two changes were small: glvalue instead of lvalue, and clarification of the aggregate/union case.The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of similar types that are now safe to alias.Also the C wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 \xc2\xa76.5 \xc2\xb67):An object shall have its stored value accessed only by an lvalue\n  expression that has one of the following types  73) or 88): 73) or 88) The intent of this list is to specify those circumstances in which an object may or may not be aliased.Strict aliasing doesn\'t refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. Strict Aliasing White Paper.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.As addendum to what Doug T. already wrote, here\nis a simple test case which probably triggers it with gcc :check.cCompile with gcc -O2 -o check check.c .\nUsually (with most gcc versions I tried) this outputs "strict aliasing problem", because the compiler assumes that "h" cannot be the same address as "k" in the "check" function. Because of that the compiler optimizes the if (*h == 5) away and always calls the printf.For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:So the if condition is completely gone from the assembler code.Type punning via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.Strict aliasing is not allowing different pointer types to the same data.This article should help you understand the issue in full detail.According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:should be required to reload the value of x between the assignment and return statement so as to allow for the possibility that p might point to x, and the assignment to *p might consequently alter the value of x.  The notion that a compiler should be entitled to presume that there won\'t be aliasing in situations like the above was non-controversial.The authors of the Standard identified a few cases where aliasing might be used in code that should be nearly 100% portable, and mandated that compilers allow for aliasing in at least those cases.  They made no attempt to pass judgment upon what constructs should be usable within code that is only intended to be usable on specific platforms, nor what constructs should be supported by quality implementations that claim to be suitable for systems programming on those platforms.If a compiler for a particular platform indicates that it is intended for high-end number crunching applications, and a piece of operating system code for that platform malfunctions when fed to that compiler, that does not mean that the compiler is defective, nor does it mean that the code is defective.  It merely means that the compiler and operating system code are not suitable for use with each other.Unfortunately, some compiler writers point to the fact that the Standard doesn\'t require that all compilers recognize certain aliasing constructs as implying a judgment that all code using such constructs should be considered defective, even if the code does things which could not be done as efficiently any other way.  If such compiler writers would recognize that the authors of the Standard have never tried to enumerate all the features and guarantees needed to make a compiler suitable for any particular purpose, they could shift their efforts toward figuring out how to make their compiler as useful as possible for a wide range of purposes, rather than trying to argue that the Standard doesn\'t require them to do so.