Microsoft should have implemented something snappy for INotifyPropertyChanged, like in the automatic properties, just specify {get; set; notify;}\nI think it makes a lot of sense to do it. Or are there any complications to do it? Can we ourselves implement something like \'notify\' in our properties. Is there a graceful solution for implementing INotifyPropertyChanged in your class or the only way to do it is by raising the PropertyChanged event in each property.If not can we write something to auto-generate the piece of code to raise PropertyChanged  event?Without using something like postsharp, the minimal version I use uses something like:Each property is then just something like:which isn\'t huge; it can also be used as a base-class if you want. The bool return from SetField tells you if it was a no-op, in case you want to apply other logic.or even easier with C# 5:which can be called like this:with which the compiler will add the "Name" automatically.C# 6.0 makes the implementation easier:-- can even be made more simple:.Net 4.5 introduces a new Caller Information Attributes.It\'s probably a good idea to add a comparer to the function as well.More examples here and hereAlso see Caller Information (C# and Visual Basic)I really like Marc\'s solution, but I think it can be slightly improved to avoid using a "magic string" (which doesn\'t support refactoring). Instead of using the property name as a string, it\'s easy to make it a lambda expression :Just add the following methods to Marc\'s code, it will do the trick :BTW, this was inspired by this blog post updated URLThere\'s also Fody which has a PropertyChanged add-in, which lets you write this:...and at compile time injects property changed notifications.I think people should pay a little more attention to performance, it really does impact the UI when there are a lot of objects to be bind (think of a grid with 10,000+ rows) or if the object\'s value changes frequently (realtime monitoring app).I took various implementation found here and elsewhere and did a comparison, check it out perfomance comparison of INotifyPropertyChanged implementations.Here is a peek at the result\nI introduce a Bindable class in my blog at http://timoch.com/blog/2013/08/annoyed-with-inotifypropertychange/\nBindable uses a dictionary as a property bag. It\'s easy enough to add the necessary overloads for a subclass to manage its own backing field using ref parameters.The code: It can be used like this:I haven\'t actually had a chance to try this myself yet, but next time I\'m setting up a project with a big requirement for INotifyPropertyChanged I\'m intending on writing a Postsharp attribute that will inject the code at compile time. Something like:Will become:I\'m not sure if this will work in practice and I need to sit down and try it out, but I don\'t see why not. I may need to make it accept some parameters for situations where more than one OnPropertyChanged needs to be triggered (if, for example, I had a FullName property in the class above)Currently I\'m using a custom template in Resharper, but even with that I\'m getting fed up of all my properties being so long.Ah, a quick Google search (which I should have done before I wrote this) shows that at least one person has done something like this before here. Not exactly what I had in mind, but close enough to show that the theory is good.Yes, better way certainly exists.\nHere it is:Step by step tutorial shrank by me, based on this useful article.Install-Package Castle.CoreInstall-Package MvvmLightLibsNotifierInterceptorProxyCreator-Put bindings into xaml:Put line of code in code-behind file MainWindow.xaml.cs like this:DataContext = ProxyCreator.MakeINotifyPropertyChanged<MainViewModel>();Attention!!! All bounded properties should be decorated with\nkeyword virtual because they used by castle proxy for overriding.A very AOP-like approach is to inject the INotifyPropertyChanged stuff onto an already instantiated object on the fly.  You can do this with something like Castle DynamicProxy.  Here is an article that explains the technique:Adding INotifyPropertyChanged to an existing objectLook here : http://dotnet-forum.de/blogs/thearchitect/archive/2012/11/01/die-optimale-implementierung-des-inotifypropertychanged-interfaces.aspxIt\'s written in German, but you can download the ViewModelBase.cs. All the comments in the cs-File are written in English.With this ViewModelBase-Class it is possible to implement bindable properties similar to the well known Dependency Properties :Let me introduce my own approach called Yappi.\nIt belongs to Runtime proxy|derived class generators, adding new functionality to an existing object or type, like Caste Project\'s Dynamic Proxy.It allows to implement INotifyPropertyChanged once in base class, and then declare derived classes in following style, still supporting INotifyPropertyChanged for new properties:Complexity of derived class or proxy construction can be hidden behind the following line:And all INotifyPropertyChanged implementation work can be done like this:It is fully safe for refactoring, uses no reflection after type construction and fast enough.Based on the answer by Thomas which was adapted from an answer by Marc I\'ve turned the reflecting property changed code into a base class:Usage is the same as Thomas\' answer except that you can pass additional properties to notify for.  This was necessary to handle calculated columns which need to be refreshed in a grid.I have this driving a collection of items stored in a BindingList exposed via a DataGridView.  It has eliminated the need for me to do manual Refresh() calls to the grid.If you are using dynamics in .NET 4.5 you don\'t need to worry about INotifyPropertyChanged. if Name is bound to some control it just works fine. All these answer are very nice.My solution is using the code snippets to do the job.This uses the simplest call to PropertyChanged event.Save this snippet and use it as you use \'fullprop\' snippet.the location can be found at \'Tools\\Code Snippet Manager...\' menu at Visual Studio.You can modify the call as you like (to use the above solutions)I have written an article that helps with this (https://msdn.microsoft.com/magazine/mt736453).  You can use the SolSoft.DataBinding NuGet package.  Then you can write code like this:Benefits:Other things you may want to consider when implementing these sorts of properties is the fact that the INotifyPropertyChang *ed *ing both use event argument classes.If you have a large number of properties that are being set then the number of event argument class instances can be huge, you should consider caching them as they are one of the areas that a string explosion can occur.Take a look at this implementation and explanation of why it was conceived.Josh Smiths BlogAn idea using reflection:Another combined solution is using StackFrame:Usage:I created an Extension Method in my base Library for reuse:This works with .Net 4.5 because of CallerMemberNameAttribute.\nIf you want to use it with an earlier .Net version you have to change the method declaration from: ...,[CallerMemberName] string propertyName = "", ... to ...,string propertyName, ...Usage:I keep this around as a snippet. C# 6 adds some nice syntax for invoking the handler.Here is a Unity3D or non-CallerMemberName version of NotifyPropertyChangedThis code enables you to write property backing fields like this:Furthermore, in resharper if you create a pattern/search snippet you can then also automate you\'re workflow by converting simple prop fields into the above backing.Search Pattern:Replace Pattern:I realize this question already has a gazillion answers, but none of them felt quite right for me. My issue is I don\'t want any performance hits and am willing to put up with a little verbosity for that reason alone. I also don\'t care too much for auto properties either, which led me to the following solution:In other words, the above solution is convenient if you don\'t mind doing this:ProsConsAlas, it is still better than doing this,For every single property, which becomes a nightmare with the additional verbosity ;-(Note, I do not claim this solution is better performance-wise compared to the others, just that it is a viable solution for those who don\'t like the other solutions presented.I came up with this base class to implement the observable pattern, pretty much does what you need ("automatically" implementing the set and get). I spent line an hour on this as prototype, so it doesn\'t have many unit tests, but proves the concept. Note it uses the Dictionary<string, ObservablePropertyContext> to remove the need for private fields.Here\'s the usageI have just found ActiveSharp - Automatic INotifyPropertyChanged, I have yet to use it, but it looks good.To quote from it\'s web site...Send property change notifications\n  without specifying property name as a\n  string.Instead, write properties like this:Note that there is no need to include the name of the property as a string. ActiveSharp reliably and correctly figures that out for itself. It works based on the fact that your property implementation passes the backing field (_foo) by ref. (ActiveSharp uses that "by ref" call to identify which backing field was passed, and from the field it identifies the property).Another Idea...=> here my solution with the following featuresUse this}I resolved in This Way (it\'s a little bit laboriouse, but it\'s surely the faster in runtime).In VB (sorry, but I think it\'s not hard translate it in C#), I make this substitution with RE:with:This transofrm all code like this:InAnd If I want to have a more readable code, I can be the opposite just making the following substitution:WithI throw to replace the IL code of the set method, but I can\'t write a lot of compiled code in IL... If a day I write it, I\'ll say you!I use the following extension method (using C# 6.0) to make the INPC implemenation as easy as possible:The INPC implementation boils down to (you can either implement this every time or create a base class):Then write your properties like this:NOTE: You can omit the [CallerMemberName] declaration in the extension method, if you want, but I wanted to keep it flexible.If you have properties without a backing field you can overload changeProperty:An example use would be:Prism 5 implementation: