What are the pros & cons of using Entity Framework 4.1 Code-first over Model/Database-first with EDMX diagram?I\'m trying to fully understand all the approaches to building data access layer using EF 4.1. I\'m using Repository pattern and IoC.I know I can use code-first approach: define my entities and context by hand and use ModelBuilder to fine-tune the schema.I can also create an EDMX diagram and choose a code generation step that uses T4 templates to generate the same POCO classes. In both cases I end up with POCO object which are ORM agnostic and context that derives from DbContext.Database-first seems to be most appealing since I can design database in Enterprise Manager, quickly synch the model and fine-tune it using the designer. So what is the difference between those two approaches? Is it just about the preference VS2010 vs Enterprise Manager?I think the differences are:Code firstDatabase firstModel firstI expect that in case of EF 4.1 there are several other features related to Code First vs. Model/Database first. Fluent API used in Code first doesn\'t offer all features of EDMX. I expect that features like stored procedures mapping, query views, defining views etc. works when using Model/Database first and DbContext (I didn\'t try it yet) but they don\'t in Code first.I think this simple "decision tree" by Julie Lerman the author of "Programming Entity Framework" should help making the decision with more confidence:More info Here.Database first and model first has no real differences.\nGenerated code are the same and you can combine this approaches. For example, you can create database using designer, than you can alter database using sql script and update your model.When you using code first you can\'t alter model without recreation database and losing all data. IMHO, this limitation is very strict and does not allow to use code first in production. This will be addressed in upcoming Microsoft Code First Migrations. But for now it is not truly usable.Second minor disadvantage of code first is that model builder require privileges on master database. This doesn\'t affect you if you using SQL Server Compact database or if you control database server.Advantage of code first is very clean and simple code. You have full control of this code and can easily modify and use it as your view model.I can recommend to use code first approach when you creating simple standalone application without versioning and using model\\database first in projects that requires modification in production.Quoting the relevant parts from http://www.itworld.com/development/405005/3-reasons-use-code-first-design-entity-framework 3 reasons to use code first design with Entity Framework1) Less cruft, less bloatUsing an existing database to generate a .edmx model file and the\n  associated code models results in a giant pile of auto generated code.\n  You\xe2\x80\x99re implored never to touch these generated files lest you break\n  something, or your changes get overwritten on the next generation. The\n  context and initializer are jammed together in this mess as well. When\n  you need to add functionality to your generated models, like a\n  calculated read only property, you need to extend the model class.\n  This ends up being a requirement for almost every model and you end up\n  with an extension for everything.With code first your hand coded models become your database. The exact\n  files that you\xe2\x80\x99re building are what generate the database design.\n  There are no additional files and there is no need to create a class\n  extension when you want to add properties or whatever else that the\n  database doesn\'t need to know about. You can just add them into the\n  same class as long as you follow the proper syntax. Heck, you can even\n  generate a Model.edmx file to visualize your code if you want.2) Greater ControlWhen you go DB first, you\xe2\x80\x99re at the mercy of what gets generated for\n  your models for use in your application. Occasionally the naming\n  convention is undesirable. Sometimes the relationships and\n  associations aren\'t quite what you want. Other times non transient\n  relationships with lazy loading wreak havoc on your API responses.While there is almost always a solution for model generation problems\n  you might run into, going code first gives you complete and fine\n  grained control from the get go. You can control every aspect of both\n  your code models and your database design from the comfort of your\n  business object. You can precisely specify relationships, constraints,\n  and associations. You can simultaneously set property character limits\n  and database column sizes. You can specify which related collections\n  are to be eager loaded, or not be serialized at all. In short, you are\n  responsible for more stuff but you\xe2\x80\x99re in full control of your app\n  design.3)Database Version ControlThis is a big one. Versioning databases is hard, but with code first\n  and code first migrations, it\xe2\x80\x99s much more effective. Because your\n  database schema is fully based on your code models, by version\n  controlling your source code you\'re helping to version your database.\n  You\xe2\x80\x99re responsible for controlling your context initialization which\n  can help you do things like seed fixed business data. You\xe2\x80\x99re also\n  responsible for creating code first migrations.When you first enable migrations, a configuration class and an initial\n  migration are generated. The initial migration is your current schema\n  or your baseline v1.0. From that point on you will add migrations\n  which are timestamped and labeled with a descriptor to help with\n  ordering of versions. When you call add-migration from the package\n  manager, a new migration file will be generated containing everything\n  that has changed in your code model automatically in both an UP() and\n  DOWN() function. The UP function applies the changes to the database,\n  the DOWN function removes those same changes in the event you want to\n  rollback. What\xe2\x80\x99s more, you can edit these migration files to add\n  additional changes such as new views, indexes, stored procedures, and\n  whatever else. They will become a true versioning system for your\n  database schema.Code first appears to be the rising star. I had a quick look at Ruby on Rails, and their standard is code first, with database migrations.If you are building an MVC3 application, I believe Code first has the following advantages:UpdateThe question also asks for a comparison of code-first to EDMX model/db-first. Code-first can be used for both of these approaches too:I use EF database first in order to provide more flexibility and control over the database configuration.  EF code first and model first seemed cool at first, and provides database independence, however in doing this it does not allow you to specify what I consider very basic and common database configuration information. For example table indexes, security metadata, or have a primary key containing more than one column.  I find I want to use these and other common database features and therefore have to do some database configuration directly anyway. I find the default POCO classes generated during DB first are very clean, however lack the very useful data annotation attributes, or mappings to stored procedures.   I used the T4 templates to overcome some of these limitations.  T4 templates are awesome, especially when combined with your own metadata and partial classes.Model first seems to have lots of potential, but is giving me lots of bugs during complex database schema refactoring.  Not sure why.Working with large models were very slow before the SP1, (have not tried it after the SP1, but it is said that is a snap now).I still Design my tables first, then an in-house built tool generates the POCOs for me, so it takes the burden of doing repetitive tasks for each poco object.when you are using source control systems, you can easily follow the history of your POCOs, it is not that easy with designer generated code.I have a base for my POCO, which makes a lot of things quite easy. I have views for all of my tables, each base view brings basic info for my foreign keys and my view POCOs derive from my POCO classes, which is quite usefull again.And finally I dont like designers.Database first approach example:Without writing any code:\nASP.NET MVC / MVC3 Database First Approach / Database firstAnd I think it is better than other approaches because data loss is less with this approach. IMHO I think that all the models have a great place but the problem I have with the model first approach is in many large businesses with DBA\'s controlling the databases you do not get the flexibility of building applications without using database first approaches.  I have worked on many projects and when it came to deployment they wanted full control.So as much as I agree with all the possible variations Code First, Model First, Database first, you must consider the actual production environment. So if your system is going to be a large user base application with many users and DBA\'s running the show then you might consider the Database first option just my opinion.