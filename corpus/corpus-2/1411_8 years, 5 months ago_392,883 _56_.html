What is the cleanest way to create a comma-separated list of string values from an IList<string> or IEnumerable<string>?String.Join(...) operates on a string[] so can be cumbersome to work with when types such as IList<string> or IEnumerable<string> cannot easily be converted into a string array..NET 4+Detail & Pre .Net 4.0 SolutionsIEnumerable<string> can be converted into a string array very easily with LINQ (.NET 3.5):It\'s easy enough to write the equivalent helper method if you need to:Then call it like this:You can then call string.Join. Of course, you don\'t have to use a helper method:The latter is a bit of a mouthful though :)This is likely to be the simplest way to do it, and quite performant as well - there are other questions about exactly what the performance is like, including (but not limited to) this one.As of .NET 4.0, there are more overloads available in string.Join, so you can actually just write:Much simpler :)FYI, the .NET 4.0 version of string.Join() has some extra overloads, that work with IEnumerable instead of just arrays, including one that can deal with any type T:The easiest way I can see to do this is using the LINQ Aggregate method:I think that the cleanest way to create a comma-separated list of string values is simply:Here is a full example:There is no need to make a helper function, this is built into .NET 4.0 and above.Here\'s another extension method:Something a bit fugly, but it works:Gives you a CSV from a List after you give it the convertor (in this case d => d.DivisionID.ToString("b")).Hacky but works - could be made into an extension method perhaps?Here\'s the way I did it, using the way I have done it in other languages:Arriving a little late to this discussion but this is my contribution fwiw. I have an IList<Guid> OrderIds to be converted to a CSV string but following is generic and works unmodified with other types:Short and sweet, uses StringBuilder for constructing new string, shrinks StringBuilder length by one to remove last comma and returns CSV string.I\'ve updated this to use multiple Append()\'s to add string + comma. From James\' feedback I used Reflector to have a look at StringBuilder.AppendFormat(). Turns out AppendFormat() uses a StringBuilder to construct the format string which makes it less efficient in this context than just using multiple Appends()\'s.Specific need when we should surround by \', by ex: Comparing by performance the winner is "Loop it, Join it, and do back step".\nActually "enumerable and manual move next" is the same good (consider stddev).Code:https://github.com/dotnet/BenchmarkDotNet was usedWe have a utility function, something like this:Which can be used for joining lots of collections easily:Note that we have the collection param before the lambda because intellisense then picks up the collection type.If you already have an enumeration of strings all you need to do is the ToArray:I just solved this issue before happening across this article. My solution goes something like below :Called like:I could also have just as easily expressed as such and would have also been more efficient:Since I reached here while searching to join on a specific property of a list of objects (and not the ToString() of it) here\'s an addition to the accepted answer:you can convert the IList to an array using ToArray and then run a string.join command on the array. They can be easily converted to an array using the Linq extensions in .NET 3.5.You could also use something like the following after you have it converted to an array using one of the of methods listed by others:Edit: Here is another exampleMy answer is like above Aggregate solution but should be less call-stack heavy since there are no explicit delegate calls:Of course, one can extend the signature to be delimiter-independent. I\'m really not a fan of the sb.Remove() call and I\'d like to refactor it to be a straight-up while-loop over an IEnumerable and use MoveNext() to determine whether or not to write a comma. I\'ll fiddle around and post that solution if I come upon it.Here\'s what I wanted initially:No temporary array or list storage required and no StringBuilder Remove() or Length-- hack required.In my framework library I made a few variations on this method signature, every combination of including the delimiter and the converter parameters with usage of "," and x.ToString() as defaults, respectively.Hopefully this is the simplest way I came over this discussion while searching for a good C# method to join strings like it is done with the MySql method CONCAT_WS(). This method differs from the string.Join() method in that it does not add the separator sign if strings are NULL or empty. CONCAT_WS(\', \',tbl.Lastname,tbl.Firstname) will return only Lastname if firstname is empty, whilst string.Join(", ", strLastname, strFirstname) will return strLastname + ", " in the same case. Wanting the first behavior, I wrote the following methods:I wrote a few extension methods to do it in a way that\'s efficient:This depends on You can use .ToArray() on Lists and IEnumerables, and then use String.Join() as you wanted.