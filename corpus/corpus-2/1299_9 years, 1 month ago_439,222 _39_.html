I often have to sort a dictionary, consisting of keys & values, by value. For example, I have a hash of words and respective frequencies, that I want to order by frequency.There is a SortedList which is good for a single value (say frequency), that I want to map it back to the word.SortedDictionary orders by key, not value. Some resort to a custom class, but is there a cleaner way?Use:Since you\'re targeting .NET 2.0 or above, you can simplify this into lambda syntax -- it\'s equivalent, but shorter. If you\'re targeting .NET 2.0 you can only use this syntax if you\'re using the compiler from Visual Studio 2008 (or above).Use LINQ:This would also allow for great flexibility in that you can select the top 10, 20 10%, etc. Or if you are using your word frequency index for type-ahead, you could also include StartsWith clause as well.Looking around, and using some C# 3.0 features we can do this:This is the cleanest way I\'ve seen and is similar to the Ruby way of handling hashes.You can sort a Dictionary by value and save it back to itself (so that when you foreach over it the values come out in order):Sure, it may not be correct, but it works.On a high level, you have no other choice then to walk through the whole Dictionary and look at each value.Maybe this helps:\nhttp://bytes.com/forum/thread563638.html\nCopy/Pasting from John Timney:You\'d never be able to sort a dictionary anyway.  They are not actually ordered.  The guarantees for a dictionary are that the key and value collections are iterable, and values can be retrieved by index or key, but here is no guarantee of any particular order.  Hence you would need to get the name value pair into a list.You do not sort entries in the Dictionary. Dictionary class in .NET is implemented as a hashtable - this data structure is not sortable by definition.If you need to be able to iterate over your collection (by key) - you need to use SortedDictionary, which is implemented as a Binary Search Tree.In your case, however the source structure is irrelevant, because it is sorted by a different field. You would still need to sort it by frequency and put it in a new collection sorted by the relevant field (frequency). So in this collection the frequencies are keys and words are values. Since many words can have the same frequency (and you are going to use it as a key) you cannot use neither Dictionary nor SortedDictionary (they require unique keys). This leaves you with a SortedList.I don\'t understand why you insist on maintaining a link to the original item in your main/first dictionary. If the objects in your collection had a more complex structure (more fields) and you needed to be able to efficiently access/sort them using several different fields as keys - You would probably need a custom data structure that would consist of the main storage that supports O(1) insertion and removal (LinkedList) and several indexing structures - Dictionaries/SortedDictionaries/SortedLists. These indexes would use one of the fields from your complex class as a key and a pointer/reference to the LinkedListNode in the LinkedList as a value.You would need to coordinate insertions and removals to keep your indexes in sync with the main collection (LinkedList) and removals would be pretty expensive I\'d think.\nThis is similar to how database indexes work - they are fantastic for lookups but they become a burden when you need to perform many insetions and deletions.All of the above is only justified if you are going to do some look-up heavy processing. If you only need to output them once sorted by frequency then you could just produce a list of (anonymous) tuples:Or for fun you could use some LINQ extension goodness:Sort valuesThis show how to sort the values in a Dictionary. We see a console program you can compile in Visual Studio and run. It adds keys to a Dictionary and then sorts them by their values. Remember that Dictionary instances are not initially sorted in any way. We use the LINQ orderby keyword in a query statement.OrderBy Clause\nProgram that sorts Dictionary [C#]OutputSorting a SortedDictionary list to bind into a ListView control using VB.NET:XAML:The easiest way to get a sorted Dictionary is to use the built in SortedDictionary class:sortedSections will contains the sorted version of sectionsThe other answers are good, if you all you want is to have a "temporary" list sorted by Value. However, if you want to have a dictionary sorted by Key that automatically synchronizes with another dictionary that is sorted by Value, you could use the Bijection<K1, K2> class.Bijection<K1, K2> allows you to initialize the collection with two existing dictionaries, so if you want one of them to be unsorted, and you want the other one to be sorted, you could create your bijection with code likeYou can use dict like any normal dictionary (it implements IDictionary<>), and then call dict.Inverse to get the "inverse" dictionary which is sorted by Value.Bijection<K1, K2> is part of Loyc.Collections.dll, but if you want, you could simply copy the source code into your own project.Note: In case there are multiple keys with the same value, you can\'t use Bijection, but you could manually synchronize between an ordinary Dictionary<Key,Value> and a BMultiMap<Value,Key>.Suppose we have a dictionary as 1) you can use temporary dictionary to store values as :You can sort the Dictionary by value and get the result in dictionary using the code below:Given you have a dictionary you can sort them directly on values using below one liner: