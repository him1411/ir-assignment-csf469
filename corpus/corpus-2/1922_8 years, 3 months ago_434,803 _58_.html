Is it possible to use ls in Unix to list the total size of a sub-directory and all its contents as opposed to the usual 4K that (I assume) is just the directory file itself?  I.E.After scouring the man pages I\'m coming up empty.Try something like:du: Disk Usage-s: Display a summary for each specified file.  (Equivalent to -d 0)-h: "Human-readable" output.  Use unit suffixes: Byte, Kilobyte, Megabyte, Gigabyte, Terabyte and Petabyte.du -sk * | sort -n will sort the folders by size. Helpful when looking to clear space..This will be displayed in human readable format.The command you want is \'du -sk\' du = "disk usage"The -k flag gives you output in kilobytes, rather than the du default of disk sectors (512-byte blocks). The -s flag will only list things in the top level directory (i.e., the current directory, by default, or the directory specified on the command line).  It\'s odd that du has the opposite behavior of ls in this regard.  By default du will recursively give you the disk usage of each sub-directory.  In contrast, ls will only give list files in the specified directory.  (ls -R gives you recursive behavior.)To display it in ls -lh format, use:Awk code explained:Sample output:To list the largest directories from the current directory in human readable format:   du -sh * | sort -hrSample:  It makes it more convenient to read :)I always use du -sk (-k flag showing file size in kilobytes) instead. look at du command for thatdu -sch * in the same directory.Put this shell function declaration in your shell initialization scripts:I called it duls because it shows the output from both du and ls (in that order):Explanation:The paste utility creates columns from its input according to the specification that you give it.  Given two input files, it puts them side by side, with a tab as separator.We give it the output of du -hs -- "$@" | cut -f1 as the first file (input stream really) and the output of ls -ld -- "$@" as the second file.In the function, "$@" will evaluate to the list of all command line arguments, each in double quotes. It will therefore understand globbing characters and path names with spaces etc.The double minuses (--) signals the end of command line options to du and ls.  Without these, saying duls -l would confuse du and any option for du that ls doesn\'t have would confuse ls (and the options that exist in both utilities might not mean the same thing, and it would be a pretty mess).The cut after du simply cuts out the first column of the du -hs output (the sizes).I decided to put the du output on the left, otherwise I would have had to manage a wobbly right column (due to varying lengths of file names).The command will not accept command line flags. This has been tested in both bash and in ksh93. It will not work with /bin/sh.These are all great suggestions, but the one I use is:-ksh makes sure the files and folders are listed in a human-readable format and in megabytes, kilobytes, etc. Then you sort them numerically and reverse the sort so it puts the bigger ones first. The only downside to this command is that the computer does not know that Gigabyte is bigger than Megabyte so it will only sort by numbers and you will often find listings like this:Just be careful to look at the unit. This command also works on the Mac (whereas sort -h does not for example).du have another useful option:  -S, --separate-dirs telling du not include size of subdirectories - handy on some occasions.Example 1 - shows only the file sizes in a directory:Example 2 - shows the file sizes and subdirectories in directory:du -sm * | sort -nr Output by size This is one I likeupdate: I didnt like the previous one because it didn\'t show files in the current directory, it only listed directories.Example output for /var on ubuntu:sudo du -hDaxd1 /var | sort -h | tail -n10just a warning, if you want to compare sizes of files. du produces different results depending on file system, block size, ... .It may happen that the size of the files is different, e.g. comparing the same directory on your local hard-disk and a USB mass storage device. I use the following script, including ls to sum up the directory size. The result in in bytes taking all sub directories into account.To display current directory\'s files and subdirectories sizes recursively:To display the same size information but without printing their sub directories recursively (which can be a huge list), just use the --max-depth option:For a while, I used Nautilus (on Gnome desktop on RHEL 6.0) to  delete files on my home folder instead of using the rm command in bash. As a result, the total size shown by did not match the sum of disk usage of each sub-directory, when I usedIt took me a while to realise Nautilus sends the deleted files to its Trash folder, and that folder is not listed in du -sh * command. So, just wanted to share this, in case somebody faced the same problem. Hmm, best way is to use this command:Then you will be able to get all sizes folders over all your server. Easy to help to you to find the biggest sizes.I ran into an issue similar to what Martin Wilde described, in my case comparing the same directory on two different servers after mirroring with rsync. Instead of using a script I added the -b flag to the du which counts the size in bytes and as far as I can determine eliminated the differences on the two servers. You still can use -s -h to get a comprehensible output.type "ls -ltrh /path_to_directory"