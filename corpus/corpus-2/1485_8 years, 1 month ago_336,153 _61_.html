There is a table messages that contains data as shown below:If I run a query select * from messages group by name, I will get the result as:What query will return the following result?That is, the last record in each group should be returned.At present, this is the query that I use:But this looks highly inefficient. Any other ways to achieve the same result?I write the solution this way:Regarding performance, one solution or the other can be better, depending on the nature of your data. So you should test both queries and use the one that is better at performance given your database.For example, I have a copy of the StackOverflow August data dump.  I\'ll use that for benchmarking.  There are 1,114,357 rows in the Posts table.  This is running on MySQL 5.0.75 on my Macbook Pro 2.40GHz.I\'ll write a query to find the most recent post for a given user ID (mine).First using the technique shown by @Eric with the GROUP BY in a subquery:Even the EXPLAIN analysis takes over 16 seconds:Now produce the same query result using my technique with LEFT JOIN:The EXPLAIN analysis shows that both tables are able to use their indexes:Here\'s the DDL for my Posts table:UPD: 2017-03-31, the version 5.7.5 of MySQL made the ONLY_FULL_GROUP_BY switch enabled by default (hence, non-deterministic GROUP BY queries became disabled). Moreover, they updated the GROUP BY implementation and the solution might not work as expected anymore even with the disabled switch. One needs to check.Bill Karwin\'s solution above works fine when item count within groups is rather small, but the performance of the query becomes bad when the groups are rather large, since the solution requires about n*n/2 + n/2 of only IS NULL comparisons.I made my tests on a InnoDB table of 18684446 rows with 1182 groups. The table contains testresults for functional tests and has the (test_id, request_id) as the primary key. Thus, test_id is a group and I was searching for the last request_id for each test_id.Bill\'s solution has already been running for several hours on my dell e4310 and I do not know when it is going to finish even though it operates on a coverage index (hence using index in EXPLAIN).I have a couple of other solutions that are based on the same ideas:3 ways MySQL uses indexes is a great article to understand some details.Solution 1This one is incredibly fast, it takes about 0,8 secs on my 18M+ rows:If you want to change the order to ASC, put it in a subquery, return the ids only and use that as the subquery to join to the rest of the columns:This one takes about 1,2 secs on my data.Solution 2Here is another solution that takes about 19 seconds for my table:It returns tests in descending order as well. It is much slower since it does a full index scan but it is here to give you an idea how to output N max rows for each group. The disadvantage of the query is that its result cannot be cached by the query cache.Use your subquery to return the correct grouping, because you\'re halfway there.Try this:If it\'s not id you want the max of:This way, you avoid correlated subqueries and/or ordering in your subqueries, which tend to be very slow/inefficient.I arrived at a different solution, which is to get the IDs for the last post within each group, then select from the messages table using the result from the first query as the argument for a WHERE x IN construct:I don\'t know how this performs compared to some of the other solutions, but it worked spectacularly for my table with 3+ million rows. (4 second execution with 1200+ results)This should work both on MySQL and SQL Server.Solution by sub query fiddle LinkSolution By join condition fiddle linkReason for this post is to give fiddle link only.\nSame SQL is already provided in other answers.I\'ve not yet tested with large DB but I think this could be faster than joining tables:Here are two suggestions.  First, if mysql supports ROW_NUMBER(), it\'s very simple:I\'m assuming by "last" you mean last in Id order. If not, change the ORDER BY clause of the ROW_NUMBER() window accordingly. If ROW_NUMBER() isn\'t available, this is another solution:Second, if it doesn\'t, this is often a good way to proceed:In other words, select messages where there is no later-Id message with the same Name.Here is my solution:Try this:Here is another way to get the last related record using GROUP_CONCAT with order by and SUBSTRING_INDEX to pick one of the record from the list Above query will group the all the Other_Columns that are in same Name group  and using ORDER BY id DESC will join all the Other_Columns in a specific group in descending order  with the provided separator in my case i have used || ,using SUBSTRING_INDEX over this list will pick the first one You can take view from here as well. http://sqlfiddle.com/#!9/ef42b/9FIRST SOLUTION SECOND SOLUTIONIs there any way we could use this method to delete duplicates in a table? The result set is basically a collection of unique records, so if we could delete all records not in the result set, we would effectively have no duplicates? I tried this but mySQL gave a 1093 error. Is there a way to maybe save the output to a temp variable then delete from  NOT IN (temp variable)? @Bill thanks for a very useful solution.EDIT: Think i found the solution:The below query will work fine as per your question.Hi @Vijay Dev if your table messages contains Id which is auto increment primary key then to fetch the latest record basis on the primary key your query should read as below:If you want the last row for each Name, then you can give a row number to each row group by the Name and order by Id in descending order.QUERYHow about this:I had similar issue (on postgresql tough) and on a 1M records table. This solution takes 1.7s vs 44s produced by the one with LEFT JOIN.\nIn my case I had to filter the corrispondant of your name field against NULL values, resulting in even better performances by 0.2 secs