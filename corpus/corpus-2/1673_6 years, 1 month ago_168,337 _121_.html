I\'ve found the following contract in a Node.js module:I wonder whats the different between module.exports and exports and why both are used here.Setting module.exports allows the database_module function to be called like a function when required.  Simply setting exports wouldn\'t allow the function to be \nexported because node exports the object module.exports references.  The following code wouldn\'t allow the user to call the function. The following won\'t work.The following will work if module.exports is set.consoleBasically node.js doesn\'t export the object that exports currently references, but exports the properties of what exports originally references.  Although Node.js does export the object module.exports references, allowing you to call it like a function.They set both module.exports and exports to ensure exports isn\'t referencing the prior exported object.  By setting both you use exports as a shorthand and avoid potential bugs later on down the road.Using exports.prop = true  instead of module.exports.prop = true saves characters and avoids confusion.Even though question is answered and accepted long ago, just want to share my 2 cents:You can imagine that at very beginning of your file there is something like (just for explanation):So whatever you do just keep in mind that module.exports and NOT exports will be returned from your module when you requiring that module from somewhere else.So when you do something like:You are adding 2 function \'a\' and \'b\' to the object on which module.exports points too, so typeof returning result will be an object : { a: [Function], b: [Function] }Of course this is the same result you will get if you are using module.exports in this example instead of exports.This is the case where you want your module.exports to behave like container of exported values. In the case where you only want to export a constructor function, what you will do? (Remember again that module.exports will be returned when you required something, not export).Now typeof returning result is \'function\' and you can required it and immediately invoke like:\n var x = require(\'./file1.js\')(); because you overwrite the returning result to be an function.Why in this case you can\'t use something like:Because with this exports reference doesn\'t \'point\' anymore to the object where module.exports points, so there is not a relationship between exports and module.exports anymore. In this case module.exports still points to the empty object {} which will be returned.Accepted answer from another topic should also help:\nDoes Javascript pass by reference?Basically the answer lies in what really happens when a module is required via require statement. Assuming this is the first time the module is being required.For example:contents of file1.js:When the above statement is executed, a Module object is created. Its constructor function is:As you see each module object has a property with name exports. This is what is eventually returned as part of require.Next step of require is to wrap the contents of file1.js into an anonymous function like below: And this anonymous function is invoked the following way, module here refers to the Module Object created earlier.As we can see inside the function, exports formal argument refers to module.exports. In essence it\'s a convenience provided to the module programmer.However this convenience need to be exercised with care. In any case if trying to assign a new object to exports ensure we do it this way.If we do it following way wrong way, module.exports will still be pointing to the object created as part of module instance.As as result adding anything to the above exports object will have no effect to module.exports object and nothing will be exported or returned as part of require.Initially,module.exports=exports , and the require function returns the object module.exports refers to.if we add property to the object, say exports.a=1, then module.exports and exports still refer to the same object. So if we call require and assign the module to a variable, then the variable has a property a and its value is 1;But if we override one of them, for example, exports=function(){}, then they are different now: exports refers to a new object and module.exports refer to the original object. And if we require the file, it will not return the new object, since module.exports is not refer to the new object.For me, i will keep adding new property, or override both of them to a new object. Just override one is not right. And keep in mind that module.exports is the real boss.exports and module.exports are the same unless you reassign exports within your module.The easiest way to think about it, is to think that this line is implicitly at the top of every module.If, within your module, you reassign exports, then you reassign it within your module and it no longer equals module.exports. This is why, if you want to export a function, you must do: If you simply assigned your function() { ... } to exports, you would be reassigning exports to no longer point to module.exports.If you don\'t want to refer to your function by module.exports every time, you can do:Notice that module.exports is the left most argument.Attaching properties to exports is not the same since you are not reassigning it. That is why this worksIt\'s a subtle difference to do with the way objects are passed by reference in JavaScript.exports and module.exports both point to the same object. exports is a variable and module.exports is an attribute of the module object.Say I write something like this:exports and module.exports now point to different objects. Modifying exports no longer modifies module.exports.When the import function inspects module.exports it gets {b:12}I just make some test, it turns out that, inside nodejs\'s module code, it should something like this:so:Here is a good description written about node modules in node.js in action book from Manning publication.\nWhat ultimately gets exported in your application is module.exports. exports is set\nup simply as a global reference to module.exports , which initially is defined as an\nempty object that you can add properties to. So exports.myFunc is just shorthand\nfor module.exports.myFunc.\nAs a result, if exports is set to anything else, it breaks the reference between\nmodule.exports and exports . Because module.exports is what really gets\nexported, exports will no longer work as expected\xe2\x80\x94it doesn\xe2\x80\x99t reference module\n.exports anymore. If you want to maintain that link, you can make module.exports\nreference exports  again as follows:I went through some tests and I think this may shed some light on the subject...app.js:versions of /routes/index.js:I even added new files:./routes/index.js:./routes/not-index.js:./routes/user.js:We get the output "@routes {}"./routes/index.js:./routes/not-index.js:./routes/user.js:We get the output "@routes { fn: {}, user: {} }"./routes/index.js:./routes/not-index.js:./routes/user.js:We get the output "@routes { user: [Function: user] }"\nIf we change user.js to { ThisLoadedLast: [Function: ThisLoadedLast] }, we get the output "@routes { ThisLoadedLast: [Function: ThisLoadedLast] }".But if we modify ./routes/index.js..../routes/index.js:./routes/not-index.js:./routes/user.js:... we get "@routes { fn: { fn: [Function: fn] }, ThisLoadedLast: { ThisLoadedLast: [Function: ThisLoadedLast] } }"So I would suggest always use module.exports in your module definitions.I don\'t completely understand what\'s going on internally with Node, but please comment if you can make more sense of this as I\'m sure it helps.-- Happy codingThis shows how require() works in its simplest form, excerpted from Eloquent JavaScriptProblem\nIt is not possible for a module to directly export a value other than the exports object, such as a function. For example, a module might want to export only the constructor of the object type it defines. Right now, it cannot do that because require always uses the exports object it creates as the exported value.Solution\nProvide modules with another variable, module, which is an object that has a property exports. This property initially points at the empty object created by require but can be overwritten with another value in order to export something else.Here is the result of Also:Note:\nThe CommonJS specification only allows the use of the exports variable to expose public members. Therefore, the named exports pattern is the only one that is really compatible with the CommonJS specification. The use of module.exports is an extension provided by Node.js to support a broader range of module definition patterns.//Firstly,the exports and module.exports point the same empty Object//If you point exp to other object instead of point it\'s property to other object. The md.exp will be empty Object {}I found this link useful to answer the above question.http://timnew.me/blog/2012/04/20/exports-vs-module-exports-in-node-js/To add to the other posts  The module system in node does    before executing your code. So when you want to exports = foo  , you probably want to do module.exports = exports = foo  but using exports.foo = foo should be fine"If you want the root of your module\'s export to be a function (such as a constructor) or if you want to export a complete object in one assignment instead of building it one property at a time, assign it to module.exports instead of exports." - http://nodejs.org/api/modules.htmlFrom the docsThe exports variable is available within a module\'s file-level scope, and is assigned the value of module.exports before the module is evaluated.It allows a shortcut, so that module.exports.f = ... can be written more succinctly as exports.f = .... However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports:It is just a variable pointing to module.exports. 1.exports -> use as singleton utility \n2. module-exports -> use as logical objects such as service , model etcLet\'s create one module with 2 ways:One waySecond wayAnd this is how require() will integrate module.First way:Second wayin node js module.js file is use to run the module.load system.every time when node execute a file it wrap your js file content as followbecause of this wrapping inside ur js source code you can access exports,require,module,etc..\nthis approach is used because there is no other way to get functionalities wrote in on js file to another.then node execute this wrapped function using c++. at that moment exports object that passed into this function will be filled.you can see inside this function parameters exports and module.\nactually exports is a public member of module constructor function.look at following codecopy this code into b.jscopy this code to a.jsnow run using nodeobject.keys of foo: \nname is function (){console.log(\'function to module exports\')}\nfunction to module exportsnow remove the commented line in a.js and comment the line above that line\nand remove the last line of b.js and run.in javascript world you cannot reassign object that passed as parameter but you can change function\'s public member when object of that function set as a parameter to another functionuse module.exports on and only if you wants to get a function when you use require keyword .\nin above example we var foo = require(a.js); you can see we can call foo as a function;this is how node documentation explain it\n"The exports object is created by the Module system. Sometimes this is not acceptable, many want their module to be an instance of some class. To do this assign the desired export object to module.exports."Both module.exports and exports point to the same function database_module(cfg) {...}.You can change b on line 3 to a, the output is reverse. The conclusion is:a and b are independent.So module.exports = exports = nano = function database_module(cfg) {...} is equivalent to:Assumed the above is module.js, which is required by foo.js. The benefits of module.exports = exports = nano = function database_module(cfg) {...} is clear now:In foo.js, since module.exports is require(\'./module.js\'):In moduls.js: You can use exports instead of module.exports.So, you will be happy if both exports and module.exports pointing to the same thing.