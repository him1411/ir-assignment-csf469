When merging topic branch "B" into "A" using git merge, I get some conflicts. I know all the conflicts can be solved using the version in "B".I am aware of git merge -s ours. But what I want is something like git merge -s theirs. Why doesn\'t it exist? How can I achieve the same result after the conflicting merge with existing git commands? (git checkout every unmerged file from B)UPDATE: The "solution" of just discarding anything from branch A (the merge commit point to B version of the tree) is not what I am looking for.Add the -X option to theirs. For example:Everything will merge in the desired way.The only thing I\'ve seen cause problems is if files were deleted from branchB. They show up as conflicts if something other than git did the removal.The fix is easy. Just run git rm with the name of any files that were deleted:After that, the -X theirs should work as expected. Of course, doing the actual removal with the git rm command will prevent the conflict from happening in the first place.Note: A longer form option also exists. Too use it, replace:with:A possible and tested solution for merging branchB into our checked-out branchA:To automate it you can wrap it into a script using branchA and branchB as arguments.This solution preserves the first and second parent of the merge commit, just as you would expect of git merge -s theirs branchB.Older versions of git allowed you to use the "theirs" merge strategy:But this has since been removed, as explained in this message by Junio Hamano (the Git maintainer).  As noted in the link, instead you would do this:Beware, though, that this is different than an actual merge.  Your solution is probably the option you\'re really looking for.I used the answer from Paul Pladijs since now. I found out, you can do a "normal" merge, conflicts occur, so you do to resolve the conflict by using the revision from the other branch. If you do this for each file, you have the same behaviour as you would expect from Anyway, the effort is more than it would be with the merge-strategy! (This was tested with git version 1.8.0)It is not entirely clear what your desired outcome is, so there is some confusion about the "correct" way of doing it in the answers and their comments. I try to give an overview and see the following three options:Try merge and use B for conflictsThis is not the "theirs version for git merge -s ours" but the "theirs version for git merge -X ours" (which is short for git merge -s recursive -X ours):This is what e.g. Alan W. Smith\'s answer does.Use content from B onlyThis creates a merge commit for both branches but discards all changes from branchA and only keeps the contents from branchB.Note that the merge commits first parent now is that from branchB and only the second is from branchA. This is what e.g. Gandalf458\'s answer does.Use content from B only and keep correct parent orderThis is the real "theirs version for git merge -s ours". It has the same content as in the option before (i.e. only that from branchB) but the order of parents is correct, i.e. the first parent comes from branchA and the second from branchB.This is what Paul Pladijs\'s answer does (without requiring a temporary branch).I solved my problem usingIf you are on branch A do:Tested on git version 1.7.8When merging topic branch "B" in "A" using git merge, I get some conflicts. I >know all the conflicts can be solved using the version in "B".I am aware of git merge -s ours. But what I want is something like git merge >-s their. I\'m assuming that you created a branch off of master and now want to merge back into master, overriding any of the old stuff in master. That\'s exactly what I wanted to do when I came across this post.Do exactly what it is you want to do, Except merge the one branch into the other first. I just did this, and it worked great.Then, checkout master and merge your branch in it (it will go smoothly now):To really properly do a merge which takes only input from the branch you are merging you can dogit merge --strategy=ours ref-to-be-mergedgit diff --binary ref-to-be-merged | git apply --reverse --indexgit commit --amendThere will be no conflicts in any scenario I know of, you don\'t have to make additional branches, and it acts like a normal merge commit.This doesn\'t play nice with submodules however.See Junio Hamano\'s widely cited answer: if you\'re going to discard committed content, just discard the commits, or at any rate keep it out of the main history.  Why bother everyone in the future reading commit messages from commits that have nothing to offer?But sometimes there are administrative requirements, or perhaps some other reason.  For those situations where you really have to record commits that contribute nothing, you want:(edit: wow, did I manage to get this wrong before. This one works.)This one uses a git plumbing command read-tree, but makes for a shorter overall workflow.This will merge your newBranch in existing baseBranchWhile the second answer answers the OP\'s original question, it doesn\'t reflect the updated intent of the OP\'s question.What you are looking for is not the opposite of the git merge -s ours command you are looking for the opposite of the git merge -s recursive -X ours command, which is git merge -s recursive -X theirsgiven original branchesto merge branch B into A while ignoring the state of branch A, then first do a regular mergethis results indo not push this merge as the commit ID will change (and it\'s wrong either way)\nnow we can change, after the fact, the ours strategy into a theirs strategydo not forget to write down the commit id of the merge as it will be unavailable after the next hard reset.  (If you forget no damage will be done but you will have to do a hard reset back to A and start all over again).now we havedoneI needed to do this when a coworker applied my changes A to his independent branch B without merging, this enables me to accept his modifications on my branch.I think what you actually want is:This seems clumsy, but it should work. The only think I really dislike about this solution is the git history will be confusing...   But at least the history will be completely preserved and you won\'t need to do something special for deleted files.I just recently needed to do this for two separate repositories that share a common history.  I started with:I wanted all the changes from repository2 master to be applied to repository1 master, accepting all changes that repository2 would make.  In git\'s terms, this should be a strategy called -s theirs BUT it does not exist.  Be careful because -X theirs is named like it would be what you want, but it is NOT the same (it even says so in the man page).The way I solved this was to go to repository2 and make a new branch repo1-merge.  In that branch, I ran git pull git@gitlab.com:Org/repository1 -s ours and it merges fine with no issues.  I then push it to the remote.Then I go back to repository1 and make a new branch repo2-merge.  In that branch, I run git pull git@gitlab.com:Org/repository2 repo1-merge which will complete with issues.Finally, you would either need to issue a merge request in repository1 to make it the new master, or just keep it as a branch.