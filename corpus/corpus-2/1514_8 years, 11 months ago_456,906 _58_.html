I\'m currently using the following code to right-trim all the std::strings in my programs:It works fine, but I wonder if there are some end-cases where it might fail?Of course, answers with elegant alternatives and also left-trim solution are welcome.EDIT Since c++17, some parts of the standard library were removed. Fortunately, starting with c++11, we have lambdas which are a superior solution.Thanks to https://stackoverflow.com/a/44973498/524503 for bringing up the modern solution.I tend to use one of these 3 for my trimming needs:They are fairly self explanatory and work very well.EDIT: BTW, I have std::ptr_fun in there to help disambiguate std::isspace because there is actually a second definition which supports locales. This could have been a cast just the same, but I tend to like this better.EDIT: To address some comments about accepting a parameter by reference, modifying and returning it. I Agree. An implementation that I would likely prefer would be two sets of functions, one for in place and one which makes a copy. A better set of examples would be:I am keeping the original answer above though for context and in the interest of keeping the high voted answer still available.Using Boost\'s string algorithms would be easiest:str is now "hello world!". There\'s also trim_left and trim, which trims both sides.If you add _copy suffix to any of above function names e.g. trim_copy, the function will return a trimmed copy of the string instead of modifying it through a reference.If you add _if suffix to any of above function names e.g. trim_copy_if, you can trim all characters satisfying your custom predicate, as opposed to just whitespaces.Use the following code to right trim (trailing) spaces and tab characters from std::strings (ideone):And just to balance things out, I\'ll include the left trim code too (ideone):Bit late to the party, but never mind. Now C++11 is here, we have lambdas and auto variables. So my version, which also handles all-whitespace and empty strings, is:We could make a reverse iterator from wsfront and use that as the termination condition in the second find_if_not but that\'s only useful in the case of an all-whitespace string, and gcc 4.8 at least isn\'t smart enough to infer the type of the reverse iterator (std::string::const_reverse_iterator) with auto. I don\'t know how expensive constructing a reverse iterator is, so YMMV here. With this alteration, the code looks like this:I like tzaman\'s solution, the only problem with it is that it doesn\'t trim a string containing only spaces.To correct that 1 flaw, add a str.clear() in between the 2 trimmer linesWhat you are doing is fine and robust. I have used the same method for a long time and I have yet to find a faster method:By supplying the characters to be trimmed you have the flexibility to trim non-whitespace characters and the efficiency to trim only the characters you want trimmed.Try this, it works for me.In the case of an empty string, your code assumes that adding 1 to string::npos gives 0. string::npos is of type string::size_type, which is unsigned. Thus, you are relying on the overflow behaviour of addition.http://ideone.com/nFVtEoHacked off of Cplusplus.comThis works for the null case as well. :-)My solution based on the answer by @Bill the Lizard.Note that these functions will return the empty string if the input string contains nothing but whitespace.My answer is an improvement upon the top answer for this post that trims control characters as well as spaces (0-32 and 127 on the ASCII table).std::isgraph determines if a character has a graphical representation, so you can use this to alter Evan\'s answer to remove any character that doesn\'t have a graphical representation from either side of a string.  The result is a much more elegant solution:Note:  Alternatively you should be able to use std::iswgraph if you need support for wide characters, but you will also have to edit this code to enable std::wstring manipulation, which is something that I haven\'t tested (see the reference page for std::basic_string to explore this option).This is what I use.  Just keep removing space from the front, and then, if there\'s anything left, do the same from the back.For what it\'s worth, here is a trim implementation with an eye towards performance.  It\'s much quicker than many other trim routines I\'ve seen around.  Instead of using iterators and std::finds, it uses raw c strings and indices.  It optimizes the following special cases: size 0 string (do nothing), string with no whitespace to trim (do nothing), string with only trailing whitespace to trim (just resize the string), string that\'s entirely whitespace (just clear the string).  And finally, in the worst case (string with leading whitespace), it does its best to perform an efficient copy construction, performing only 1 copy and then moving that copy in place of the original string.With C++11 also came a regular expression module, which of course can be used to trim leading or trailing spaces.Maybe something like this:An elegant way of doing it can be likeAnd the supportive functions are implemented as:And once you\'ve all these in place, you can write this as well:I guess if you start asking for the "best way" to trim a string, I\'d say a good implementation would be one that:Obviously there are too many different ways to approach this and it definitely depends on what you actually need. However, the C standard library still has some very useful functions in <string.h>, like memchr. There\'s a reason why C is still regarded as the best language for IO - its stdlib is pure efficiency.Trim C++11 implementation:I\'m not sure if your environment is the same, but in mine, the empty string case will cause the program to abort. I would either wrap that erase call with an if(!s.empty()) or use Boost as already mentioned. Here\'s what I came up with: Stream extraction eliminates whitespace automatically, so this works like a charm.\nPretty clean and elegant too, if I do say so myself. ;)Contributing my solution to the noise. trim defaults to creating a new string and returning the modified one while trim_in_place modifies the string passed to it. The trim function supports c++11 move semantics.This can be done more simply in C++11 due to the addition of back() and pop_back().Here is my version:Here\'s a solution easy to understand for beginners not used to write std:: everywhere and not yet familiar with const-correctness, iterators, STL algorithms, etc...Hope it helps...The above methods are great, but sometimes you want to use a combination of functions for what your routine considers to be whitespace.  In this case, using functors to combine operations can get messy so I prefer a simple loop I can modify for the trim.  Here is a slightly modified trim function copied from the C version here on SO.  In this example, I am trimming non alphanumeric characters.This version trims internal whitespace and non-alphanumerics:Yet another option - removes one or more characters from both ends.What about this...?Note: I\'m still relatively new to C++, so please forgive me if I\'m off base here.c++11:output:works fine also with empty strings