In bash, calling foo would display any output from that command on the stdout.Calling foo > output would redirect any output from that command to the file specified (in this case \'output\').Is there a way to redirect output to a file and have it display on stdout?The command you want is named tee:For example:If you only care about stdout.  Or, if you want everything.Uses 2>&1 which redirects Channel 2 (Standard Error) and Channel 1 (Standard Output) to the same place which in this context is Channel 1 (Standard Output), and thence, to the output file as directed by the tee command.p.s.You may need to append the log file via tee -a2>&1 dumps the stderr and stdout streams.\ntee outfile takes the stream it gets and writes it to the screen and to the file "outfile".This is probably what most people are looking for. The likely situation is some program or script is working hard for a long time and producing a lot of output. The user wants to check it periodically for progress, but also wants the output written to a file.The problem (especially when mixing stdout and stderr streams) is that there is reliance on the streams being flushed by the program. If, for example, all the writes to stdout are not flushed, but all the writes to stderr are flushed, then they\'ll end up out of chronological order in the output file and on the screen.It\'s also bad if the program only outputs 1 or 2 lines every few minutes to report progress. In such a case, if the output was not flushed by the program, the user wouldn\'t even see any output on the screen for hours, because none of it would get pushed through the pipe for hours.Update: The program unbuffer, part of the expect package, will solve the buffering problem. This will cause stdout and stderr to write to the screen and file immediately and keep them in sync when being combined and redirected to tee. E.g.:Another way that works for me is, as shown in gnu bash manualExample:If \xe2\x80\x98|&\xe2\x80\x99 is used, command1\xe2\x80\x99s standard error, in addition to its standard output, is connected to command2\xe2\x80\x99s standard input through the pipe; it is shorthand for 2>&1 |. This implicit redirection of the standard error to the standard output is performed after any redirections specified by the command. For more information, refer redirection tee is your friend.You can primarily use Zoredache solution, but If you don\'t want to overwrite the output file you should write tee with -a option as follow :using tail -f output should work.Something to add ...The package unbuffer has support issues with some packages under fedora and redhat unix releases.Setting aside the troubles Following worked for meThank you ScDF & matthew your inputs saved me lot of time..Bonus answer since this use-case brought me here:In the case where you need to do this as some other user Note that the echo will happen as you and the file write will happen as "some_user" what will NOT work is if you were to run the echo as "some_user" and redirect the output with >> "some_file" because the file redirect will happen as you.Hint: tee also supports append with the -a flag, if you need to replace a line in a file as another user you could execute sed as the desired user.tee is perfect for this, but this will also do the job