I have an array of numbers that I need to make sure are unique. I found the code snippet below on the internet and it works great until the array has a zero in it. I found this other script here on SO that looks almost exactly like it, but it doesn\'t fail.So for the sake of helping me learn, can someone help me determine where the prototype script is going wrong?With JavaScript 1.6 / ECMAScript 5 you can use the native filter method of an Array in the following way to get an array with unique values:The native method filter will loop through the array and leave only those entries that pass the given callback function onlyUnique.onlyUnique checks, if the given value is the first occurring. If not, it must be a duplicate and will not be copied.This solution works without any extra library like jQuery or prototype.js.It works for arrays with mixed value types too.For old Browsers (<ie9), that do not support the native methods filter and indexOf you can find work arounds in the MDN documentation for filter and indexOf.If you want to keep the last occurrence of a value, simple replace indexOf by lastIndexOf. With ES6 it could be shorten to this:Thanks to Camilo Martin for hint in comment. ES6 has a native object Set to store unique values. To get an array with unique values you could do now this:The constructor of Set takes an iterable object, like Array, and the spread operator ... transform the set back into an Array. Thanks to Lukas Liese for hint in comment.Updated answer for ES6/ES2015: Using the Set operator, the single line solution is:Which returns As le_m suggested, this can also be shortened using spread operator , likeYou can also use underscore.js.which will return:I realise this question has more than 30 answers already. But I\'ve read through all the existing answers first and made my own research.I split all answers to 4 possible solutions:Here\'s sample codes found in answers:And I wondered which one is faster. I\'ve made sample Google Sheet to test functions. Note: ECMA 6 is not avaliable in Google Sheets, so I can\'t test it.Here\'s the result of tests:\nI expected to see that code using object { } will win because it uses hash. So I\'m glad that tests showed best results for this algorithm in Chrome and IE. Thanks to @rab for the code.I have since found a nice method that uses jQueryNote: This code was pulled from Paul Irish\'s duck punching post - I forgot to give credit :PShortest solution with ES6: [...new Set( [1, 1, 2] )];Or if you want to modify the Array prototype (like in the original question):EcmaScript 6 is only partially implemented in modern browsers at the moment (Aug. 2015), but Babel has become very popular for transpiling ES6 (and even ES7) back to ES5. That way you can write ES6 code today!If you\'re wondering what the ... means, it\'s called the spread operator. From MDN: \xc2\xabThe spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) are expected\xc2\xbb. Because a Set is an iterable (and can only have unique values), the spread operator will expand the Set to fill the array.Resources for learning ES6:With ES6 syntaxlist = list.filter((x, i, a) => a.indexOf(x) == i)With ES5 syntaxBrowser Compatibility: IE9+Simplest solution:Or:The simplest, and fastest (in Chrome) way of doing this:Simply goes through every item in the array, tests if that item is already in the list, and if it\'s not, push to the array that gets returned.According to jsPerf, this function is the fastest of the ones I could find anywhere - feel free to add your own though.The non-prototype version:When also needing to sort the array, the following is the fastest:or non-prototype:This is also faster than the above method in most non-chrome browsers.PERFORMANCE ONLY! this code is probably 10X faster than all the codes in here *works on all browsers and also has the lowest memory impact....\nand moreif you don\'t need to reuse the old array;btw do the necessary other operations before you convert it to unique here is probably the fastest way to do this, also very short.then you can try thisI came up with this function reading this article...http://www.shamasis.net/2009/09/fast-algorithm-to-find-unique-items-in-javascript-array/I don\'t like the for loop. it has to many parameters.i like the while-- loop.\nwhile is the fastest loop in all browsers except the one we all like so much... chrome.anyway i wrote the first function that uses while.And yep it\'s a little faster than the function found in the article.but not enough.unique2()next step use modern js.Object.keys\ni replaced the other for loop with js1.7\'s Object.keys...\na little faster and shorter (in chrome 2x faster) ;). Not enough!.unique3().at this point i was thinking about what i really need in MY unique function.\ni don\'t need the old array, i want a fast function.\nso i used 2 while loops + splice.unique4()Useless to say that i was impressed.chrome: the usual 150,000 operations per second jumped to 1,800,000 operations per second.ie: 80,000 op/s vs 3,500,000 op/sios: 18,000 op/s vs 170,000 op/s safari: 80,000 op/s vs 6,000,000 op/sProof\nhttp://jsperf.com/wgu or better use console.time... microtime... whateverunique5() is just to show you what happens if you want to keep the old array.Don\'t use Array.prototype if yu don\'t know what your doing.\ni just did alot of copy and past.\nUse Object.defineProperty(Array.prototype,...,writable:false,enumerable:false}) if you want to create a native prototype.example: https://stackoverflow.com/a/20463021/2450730Demo\nhttp://jsfiddle.net/46S7g/NOTE: your old array is destroyed/becomestheunique after this operation.if you can\'t read the code above ask, read a javascript book or here are some explainations about shorter code. https://stackoverflow.com/a/21353032/2450730some are using indexOf  ... don\'t ... http://jsperf.com/dgfgghfghfghghgfhgfhfghfhgfhfor empty arraysMany of the answers here may not be useful to beginners. If de-duping an array is difficult, will they really know about the prototype chain, or even jQuery?In modern browsers, a clean and simple solution is to store data in a Set, which is designed to be a list of unique values.The Array.from is useful to convert the Set back to an Array so that you have easy access to all of the awesome methods (features) that arrays have. There are also other ways of doing the same thing. But you may not need Array.from at all, as Sets have plenty of useful features like forEach.If you need to support old Internet Explorer, and thus cannot use Set, then a simple technique is to copy items over to a new array while checking beforehand if they are already in the new array.To make this instantly reusable, let\'s put it in a function.So to get rid of the duplicates, we would now do this.The deduplicate(cars) part becomes the thing we named result when the function completes.Just pass it the name of any array you like.This prototype getUnique is not totally correct, because if i have a Array like: ["1",1,2,3,4,1,"foo"] it will return ["1","2","3","4"] and "1" is string and 1 is a integer; they are different.Here is a correct solution:using:The above will produce ["1",2,3,4,1,"foo"].Without extending Array.prototype (it is said to be a bad practice) or using jquery/underscore, you can simply filter the array.By keeping last occurrence:or first occurrence:Well, it\'s only javascript ECMAScript 5+, which means only IE9+, but it\'s nice for a development in native HTML/JS (Windows Store App, Firefox OS, Sencha, Phonegap, Titanium, ...).That\'s because 0 is a falsy value in JavaScript.this[i] will be falsy if the value of the array is 0 or any other falsy value.If you\'re using Prototype framework there is no need to do \'for\' loops, you can use http://www.prototypejs.org/api/array/uniq like this:Which will produce a duplicate array with no duplicates. I came across your question searching a method to count distinct array records so after uniq()I used size()and there was my simple result. \np.s. Sorry if i misstyped somethingedit: if you want to escape undefined records you may want to add compact() before, like this:I\'m not sure why Gabriel Silveira wrote the function that way but a simpler form that works for me just as well and without the minification is:or in CoffeeScript:From Shamasis Bhattacharya\'s blog (O(2n) time complexity) :From Paul Irish\'s blog: improvement on JQuery .unique() :Finding unique Array values in simple methodTo address the problem the other way around, it may be useful to have no duplicate while you load your array, the way Set object would do it but it\'s not available in all browsers yet. It saves memory and is more efficient if you need to look at its content many times.Sample:Gives you set = [1,3,4,2]You can also use jQueryOriginally answered at: jQuery function to get all unique elements from an array?If anyone using knockoutjsBTW have look at all ko.utils.array* utilities.I found that serializing they hash key helped me get this working for objects.You can also use sugar.js:This will work.Building on other answers, here\'s another variant that takes an optional flag to choose a strategy (keep first occurrence or keep last):Without extending Array.prototype Extending Array.prototypeUsing object keys to make unique array, I have tried followingWhich returns ["1", 1, 2, 3, 4, "foo", false, null]Look at this. Jquery provides uniq method:\nhttps://api.jquery.com/jQuery.unique/If you have the mighty reduce method available (â‰¥ 5.1), you can try something like this:It\'s not the most efficient implementation (because of the indexOf check, which may in the worst case go through the entire list). If efficiency matters, you can keep the "history" of occurrences in some random-access structure (say, {}) and key those instead. That\'s basically what the most voted answer does, so check that out for an example.