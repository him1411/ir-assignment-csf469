This question already has an answer here:I\'m a beginner in C programming, but I was wondering what\'s the difference between using typedef when defining a structure versus not using typedef. It seems to me like there\'s really no difference, they accomplish the same.vs.The common idiom is using both: They are different definitions. To make the discussion clearer I will split the sentence:In the first line you are defining the identifier S within the struct name space (not in the C++ sense). You can use it and define variables or function arguments of the newly defined type by defining the type of the argument as struct S:The second line adds a type alias S in the global name space and thus allows you to just write:Note that since both identifier name spaces are different, defining S both in the structs and global spaces is not an error, as it is not redefining the same identifier, but rather creating a different identifier in a different place.To make the difference clearer:You can define a function with the same name of the struct as the identifiers are kept in different spaces, but you cannot define a function with the same name as a typedef as those identifiers collide.In C++, it is slightly different as the rules to locate a symbol have changed subtly. C++ still keeps the two different identifier spaces, but unlike in C, when you only define the symbol within the class identifier space, you are not required to provide the struct/class keyword:What changes are the search rules, not where the identifiers are defined. The compiler will search the global identifier table and after S has not been found it will search for S within the class identifiers.The code presented before behaves in the same way:After the definition of the S function in the second line, the struct S cannot be resolved automatically by the compiler, and to create an object or define an argument of that type you must fall back to including the struct keyword:Another difference not pointed out is that giving the struct a name (i.e. struct myStruct) also enables you to provide forward declarations of the struct.  So in some other file, you could write:without having to have access to the definition.  What I recommend is you combine your two examples:This gives you the convenience of the more concise typedef name but still allows you to use the full struct name if you need.struct and typedef are two very different things.The struct keyword is used to define, or to refer to, a structure type. For example, this:creates a new type called struct foo. The name foo is a tag; it\'s meaningful only when it\'s immediately preceded by the struct keyword, because tags and other identifiers are in distinct name spaces. (This is similar to, but much more restricted than, the C++ concept of namespaces.)A typedef, in spite of the name, does not define a new type; it merely creates a new name for an existing type. For example, given:my_int is a new name for int; my_int and int are exactly the same type. Similarly, given the struct definition above, you can write:The type already has a name, struct foo.  The typedef declaration gives the same type a new name, foo.The syntax allows you to combine a struct and typedef into a single declaration:This is a common idiom. Now you can refer to this structure type either as struct bar or just as bar.Note that the typedef name doesn\'t become visible until the end of the declaration. If the structure contains a pointer to itself, you have use the struct version to refer to it:Some programmers will use distinct identifiers for the struct tag and for the typedef name. In my opinion, there\'s no good reason for that; using the same name is perfectly legal and makes it clearer that they\'re the same type.  If you must use different identifiers, at least use a consistent convention:(Personally, I prefer to omit the typedef and refer to the type as struct bar. The typedef save a little typing, but it hides the fact that it\'s a structure type.  If you want the type to be opaque, this can be a good thing. If client code is going to be referring to the member n by name, then it\'s not opaque; it\'s visibly a structure, and in my opinion it makes sense to refer to it as a structure. But plenty of smart programmers disagree with me on this point. Be prepared to read and understand code written either way.)(C++ has different rules. Given a declaration of struct blah, you can refer to the type as just blah, even without a typedef. Using a typedef might make your C code a little more C++-like -- if you think that\'s a good thing.)In C (not C++), you have to declare struct variables like:In order to be able to use myStruct myVariable; instead, you can typedef the struct:You can combine struct definition and typedefs it in a single statement which declares an anonymous struct and typedefs it.In C, the type specifier keywords of structures, unions and enumerations are mandatory, ie you always have to prefix the type\'s name (its tag) with struct, union or enum when referring to the type.You can get rid of the keywords by using a typedef, which is a form of information hiding as the actual type of an object will no longer be visible when declaring it.It is therefore recommended (see eg the Linux kernel coding style guide, Chapter 5) to only do this when \nyou actually want to hide this information and not just to save a few keystrokes.An example of when you should use a typedef would be an opaque type which is only ever used with corresponding accessor functions/macros.If you use struct without typedef, you\'ll always have to writeIt\'s illegal to writeIf you use the typedef you don\'t need the struct prefix anymore. The difference comes in when you use the struct.The first way you have to do:The second way allows you to remove the keyword struct.The typedef, as it is with other constructs, is used to give a data type a new name.  In this case it is mostly done in order to make the code cleaner:vs.You can\'t use forward declaration with the typedef struct.The struct itself is an anonymous type, so you don\'t have an actual name to forward declare.A forward declaration like this won\'t work:The following code creates an anonymous struct with the alias myStruct:You can\'t refer it without the alias because you don\'t specify an identifier for the structure.I see some clarification is in order on this.  C and C++ do not define types differently.  C++ was originally nothing more than an additional set of includes on top of C.The problem that virtually all C/C++ developers have today, is a) universities are no longer teaching the fundamentals, and b) people don\'t understand the difference between a definition and a declaration.The only reason such declarations and definitions exist is so that the linker can calculate address offsets to the fields in the structure.  This is why most people get away with code that is actually written incorrectly-- because the compiler is able to determine addressing.  The problem arises when someone tries to do something advance, like a queue, or a linked list, or piggying-backing an O/S structure.A declaration begins with \'struct\', a definition begins with \'typedef\'.Further, a struct has a forward declaration label, and a defined label.  Most people don\'t know this and use the forward declaration label as a define label.Wrong:They\'ve just used the forward declaration to label the structure-- so now the compiler is aware of it-- but it isn\'t an actual defined type.  The compiler can calculate the addressing-- but this isn\'t how it was intended to be used, for reasons I will show momentarily.People who use this form of declaration, must always put \'struct\' in practicly every reference to it-- because it isn\'t an offical new type.Instead, any structure that does not reference itself, should be declared and defined this way only:Now it\'s an actual type, and when used you can use at as \'myStruct\' without having to prepend it with the word \'struct\'.If you want a pointer variable to that structure, then include a secondary label:Now you have a pointer variable to that structure, custom to it.FORWARD DECLARATION--Now, here\'s the fancy stuff, how the forward declaration works.  If you want to create a type that refers to itself, like a linked list or queue element, you have to use a forward declaration.  The compiler doesn\'t consider the structure defined until it gets to the semicolon at the very end, so it\'s just declared before that point.Now, the compiler knows that although it doesn\'t know what the whole type is yet, it can still reference it using the forward reference.Please declare and typedef your structures correctly.  There\'s actually a reason.With the latter example you omit the struct keyword when using the structure. So everywhere in your code, you can write :instead ofThis save some typing, and might be more readable, but this is a matter of taste