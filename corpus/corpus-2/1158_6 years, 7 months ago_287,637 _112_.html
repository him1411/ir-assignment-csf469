I\'m looking for an optimal way to resize wrapping text in a TextView so that it will fit within its getHeight and getWidth bounds. I\'m not simply looking for a way to wrap the text- I want to make sure it both wraps and is small enough to fit entirely on the screen. I\'ve seen a few cases on StackOverflow where auto resizing was needed, but they are either very special cases with hack solutions, have no solution, or involve re-drawing the TextView recursively until it is small enough (which is memory intense and forces the user to watch the text shrink step-by-step with every recursion). But I\'m sure somebody out there has found a good solution that doesn\'t involve what I\'m doing: writing several heavy routines that parse and measure the text, resize the text, and repeat until a suitably small size has been found. What routines does TextView use to wrap the text? Couldn\'t those be somehow used to predict whether text will be small enough?tl;dr: is there a best-practice way to auto-resize a TextView to fit, wrapped, in its getHeight and getWidth bounds?With Android 8.0 (Api level 26) this is a default feature.\nhttps://developer.android.com/guide/topics/ui/look-and-feel/autosizing-textview.htmlAs a mobile developer, I was sad to find nothing native that supports auto resizing. My searches did not turn up anything that worked for me and in the end, I spent the better half of my weekend and created my own auto resize text view. I will post the code here and hopefully it will be useful for someone else. This class uses a static layout with the text paint of the original text view to measure the height. From there, I step down by 2 font pixels and remeasure until I have a size that fits. At the end, if the text still does not fit, I append an ellipsis. I had requirements to animate the text and reuse views and this seems to work well on the devices I have and seems to run fast enough for me. Warning. There is an important fixed bug affecting Android 3.1 - 4.04 causing all AutoResizingTextView widgets not to work. Please read: https://stackoverflow.com/a/21851157/2075875UPDATE: Following code  also fulfills the requirement of an ideal  AutoScaleTextView as described here : Auto-fit TextView for Android and is marked as winner.UPDATE 2: Support of maxlines added, now works fine before API level 16.Update 3: Support for android:drawableLeft, android:drawableRight, android:drawableTop and android:drawableBottom tags added, thanks to MartinH\'s simple fix here.My requirements were little bit different. I needed an efficient way to adjust size because I was animating an integer from, may be 0 to ~4000 in TextView in 2 seconds and I wanted to adjust the size accordingly. My solution works bit differently. Here is what final result looks like: and the code that produced it:And finally the java code:Actually a solution is in Google\'s DialogTitle class... though it\'s not as effective as the accepted one, it\'s a lot simpler and is easy to adapt.I started with Chase\'s solution, but had to adapt two things before it was working as expected on my device (Galaxy Nexus, Android 4.1):using a copy of TextPaint for measuring layout\nThe documentation for TextView.getPaint() states that it should be used read-only, so I made a copy in both places where we use the paint object for measuring:adding a unit to setting the text sizeWith these two modifications the solution is working perfectly for me, thanks Chase! I don\'t know whether it is due to Android 4.x that the original solution was not working. In case you want to see it in action or test whether it really works on your device, you can have a look at my flashcard app Flashcards ToGo where I use this solution to scale the text of a flashcard. The text can have arbitrary length, and the flashcards are displayed in different activities, sometimes smaller sometimes bigger, plus in landscape + portrait mode, and I haven\'t found any corner case where the solution would not work properly...I started with Chase\'s AutoResizeTextView class, and made a minor change so it would fit both vertically and horizontally.I also discovered a bug which causes a Null Pointer Exception in the Layout Editor (in Eclipse) under some rather obscure conditions.Change 1:  Fit the text both vertically and horizontallyChase\'s original version reduces the text size until it fits vertically, but allows the text to be wider than the target.  In my case, I needed the text to fit a specified width.This change makes it resize until the text fits both vertically and horizontally.In resizeText(int,int) change from:to:Then, at the end of the file, append the getTextWidth() routine; it\'s just a slightly modified getTextHeight().  It probably would be more efficient to combine them to one routine which returns both height and width.\n\n\nChange 2:  Fix a EmptyStackException in the Eclipse Android Layout EditorUnder rather obscure and very precise conditions, the Layout Editor will fail to display the graphical display of the layout; it will throw an "EmptyStackException: null" exception in com.android.ide.eclipse.adt.The conditions required are:\n- create an AutoResizeTextView widget\n- create a style for that widget\n- specify the text item in the style; not in the widget definition  as in:res/layout/main.xml:res/values/myStyles.xml:With these files, selecting the Graphical Layout tab when editing main.xml will display:  error!\n    EmptyStackException: null\n    Exception details are logged in Window > Show View > Error Log  instead of the graphical view of the layout.To keep an already too-long story shorter, I tracked this down to the following lines (again in resizeText):The problem is that under the specific conditions, mTextSize is never initialized; it has the value 0.With the above, targetTextSize is set to zero (as a result of Math.min).That zero is passed to getTextHeight() (and getTextWidth()) as the textSize argument.  When it gets to\nlayout.draw(sTextResizeCanvas);\nwe get the exception.It\'s more efficient to test if (mTextSize == 0) at the beginning of resizeText() rather than testing in getTextHeight() and getTextWidth(); testing earlier saves all the intervening work.With these updates, the file (as in my crash-demo test app) is now:\n\nA big thank you to Chase for posting the initial code.  I enjoyed reading through it to see how it worked, and I\'m pleased to be able to add to it.A workaround for Android 4.x:I found AutoResizeTextView and it works great on my Android 2.1 emulator. I loved it so much. But unfortunately it failed on my own 4.0.4 cellphone and 4.1 emulator. After trying I found it could be easily resolved by adding following attributes in AutoResizeTextView class in the xml:android:ellipsize="none"android:singleLine="true"With the 2 lines above, now AutoResizeTextView working perfectly on my 2.1 & 4.1 emulators and my own 4.0.4 cellphone now.Hope this helps you. :-)Warning, bug in Android Honeycomb and Ice Cream SandwichAndroids versions: 3.1 - 4.04 have a bug, that setTextSize() inside of TextView works only for the 1st time (1st invocation).Bug is described here: http://code.google.com/p/android/issues/detail?id=22493 http://code.google.com/p/android/issues/detail?id=17343#c9workaround is to add new line character to text assigned to TextView before changing size:I use it in my code as follow:I add this "\\u3000" character on left and right of my text, to keep it centered. If you have it aligned to left then append to the right only. Of course it can be also embedded with AutoResizeTextView widget, but I wanted to keep fix code outside.My need was to resize text in order to perfectly fit view bounds. Chase\'s solution only reduces text size, this one enlarges also the text if there is enough space.To make all fast & precise i used a bisection method instead of an iterative while, as you can see in resizeText() method. That\'s why you have also a MAX_TEXT_SIZE option. I also included onoelle\'s tips.Tested on Android 4.4I hope this helps youNOTE: I use MAX_TEXT_SIZE in case of text size is bigger than 20 because I don\'t want to allow big fonts applies to my View, if this is not your case, you can just simply remove it.Since I\'ve been looking for this forever, and I found a solution a while ago which is missing here, I\'m gonna write it here, for future reference also.Note: this code was taken directly from Google Android Lollipop dialer a while back, I don\'t remember If changes were made at the time. Also, I don\'t know which license is this under, but I have reason to think it is Apache 2.0.Class ResizeTextView, the actual View This ResizeTextView class could extend TextView and all its children as I undestand, so EditText as well.Class ViewUtil with method resizeText(...)You should set your view asHope it helps!I wrote a blog post about this.I created a component called ResizableButton based on Kirill Grouchnikov\'s blog post about custom components used in the new android market app. I placed the src code here.On the other hand, mosabua read my post and told me he was going to open source his implementation which was faster than mine. I hope he release it soon enough :)My implementation is a bit more complex, but comes with the following goodies:[revised on 2012-11-21]Here\'s a simple solution that uses TextView itself with a TextChangedListened added to it:This approach will increase or decrease the font size as needed to fit the text, respecting the MIN_SP and MAX_SP bounds received as parameters.AppcompatTextView now supports auto sizing starting from Support Library 26.0. TextView in Android O also works same way. More info can be found here. A simple demo app can be found here.I found the following to work nicely for me.  It doesn\'t loop and accounts for both height and width.  Note that it is important to specify the PX unit when calling setTextSize on the view.  Here is the routine I use, passing in the getPaint() from the view.  A 10 character string with a \'wide\' character is used to estimate the width independent from the actual string.Here\'s an enumeration of what else I\'ve found for anyone still searching: 1) Here\'s a solution that recursively re-paints the textview until it fits. This means literally watching your text shrink into place, but at least it fits when it\'s done. The code will need some tweaking to implement, but it\'s mostly there. 2) You can try hacking together a custom solution like this, or dunni\'s class in this, which is what I did using the getPaint().measureText(str) to search for the right size, but it got a lot messier since I need it to wrap only on whitespace...3) You can keep searching- I\'ve tried more alternatives than I can count. Ted\'s advice on StaticLayout hasn\'t paid off for me but maybe there\'s something there; I tried using the StaticLayout.getEllipsis(line) to determine if text was going off screen, to no effect. See my (presently un-answered) post about that here. I needed a specific solution. I have got an edittext and textview in my layout. The textview is fixed height and width. When the user starts to type in the edittext, the text should immediately appear in the textview. The text in the textfield should auto - resize to fit the textview. So I updated Chase\'s solution to work for me. So when the text changes in the textview, resizing starts. The difference between mine and Chase\'s soluton: resizing is done even if the user DELETE some chars. I hope it can help someone.You can use the android.text.StaticLayout class for this. That\'s what TextView uses internally.This solutions works for us:I just created the following method (based on the ideas of Chase) which might help you if you want to draw text to any canvas:This could be used e.g. in any onDraw() method of any custom view.Here is my formulation.I combined some of the above suggestions to make one that scales up and down, with bisection method. It also scales within the width.I have use code from chase and M-WaJeEh\nand I found some advantage & disadvantage herefrom chaseAdvantage: Disadvantage: if it\'s more than 1 line with custom font some of text will disappearif it\'s enable ellipse, it didn\'t prepare space for ellipseif it\'s custom font (typeface), it didn\'t supportfrom M-WaJeEhAdvantage: Disadvantage: if set height as wrap-content, this code will start from minimum size and it will reduce to smallest as it can, not from the setSize and reduce by the limited widthif it\'s custom font (typeface), it didn\'t supportIf anyone needs it, here is the same code snippet but for Xamarin.Android.Thanks to Chase and onoelle, for the lazy programmers, let me post here a working version of their fantastic merged code, adapted on a Button, instead of a TextView.Substitute all your Buttons (not ImageButtons) with AutoResizeTextButtons and the same boring problem is fixed for them too.Here is the code. I just removed the imports.Usage:put a AutoResizeTextButton inside your xml in replace of a normal Button, without changing\nanything else.\nInside the onCreate() put (for example):Here\'s yet another solution, just for kicks.  It\'s probably not very efficient, but it does cope with both height and width of the text, and with marked-up text.Here is the approach I take. It\'s very simple. It uses successive approximation to zero in on the fontsize and can generally have it figured out in less than 10 iterations. Just replace "activityWidth" with the width of whatever view you are using to display the text in. In my example, it\'s set as a private field to the screen\'s width. The inital fontsize of 198 is only set in the event the method generates an exception (which really should never happen):Extend TextView and override onDraw with the code below. It will keep text aspect ratio but size it to fill the space. You could easily modify code to stretch if necessary.Refer to the ScalableTextView.java here Auto-fit TextView for Android. I have added the code to shrink and expand the TextView based on the text length