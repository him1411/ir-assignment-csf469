I need to store a multi-dimensional associative array of data in a flat file for caching purposes. I might occasionally come across the need to convert it to JSON for use in my web app but the vast majority of the time I will be using the array directly in PHP.Would it be more efficient to store the array as JSON or as a PHP serialized array in this text file? I\'ve looked around and it seems that in the newest versions of PHP (5.3), json_decode is actually faster than unserialize.I\'m currently leaning towards storing the array as JSON as I feel its easier to read by a human if necessary, it can be used in both PHP and JavaScript with very little effort, and from what I\'ve read, it might even be faster to decode (not sure about encoding, though).Does anyone know of any pitfalls? Anyone have good benchmarks to show the performance benefits of either method?Depends on your priorities.If performance is your absolute driving characteristic, then by all means use the fastest one.  Just make sure you have a full understanding of the differences before you make a choiceAnd there\'s probably a few other differences I can\'t think of at the moment.A simple speed test to compare the twoJSON is simpler and faster than PHP\'s serialization format and should be used unless:I\'ve written a blogpost about this subject: "Cache a large array: JSON, serialize or var_export?". In this post it is shown that serialize is the best choice for small to large sized arrays. For very large arrays (> 70MB) JSON is the better choice.You might also be interested in https://github.com/phadej/igbinary - which provides a  different serialization \'engine\' for PHP.My random/arbitrary \'performance\' figures, using PHP 5.3.5 on a 64bit platform show :JSON :Native PHP :Igbinary :So, it\'s quicker to igbinary_serialize() and igbinary_unserialize() and uses less disk space.I used the fillArray(0, 3) code as above, but made the array keys longer strings.igbinary can store the same data types as PHP\'s native serialize can (So no problem with objects etc) and you can tell PHP5.3 to use it for session handling if you so wish.See also http://ilia.ws/files/zendcon_2010_hidden_features.pdf - specifically slides 14/15/16Y just tested serialized and json encode and decode, plus the size it will take the string stored.We can conclude that JSON encodes faster and results a smaller string, but unserialize is faster to decode the string.If you are caching information that you will ultimately want to "include" at a later point in time, you may want to try using var_export. That way you only take the hit in the "serialize" and not in the "unserialize".I augmented the test to include unserialization performance. Here are the numbers I got.So json seems to be faster for encoding but slow in decoding.  So it could depend upon your application and what you expect to do the most.Seems like serialize is the one I\'m going to use for 2 reasons:Someone pointed out that unserialize is faster than json_decode and a \'read\' case sounds more probable than a \'write\' case.I\'ve had trouble with json_encode when having strings with invalid UTF-8 characters. When that happens the string ends up being empty causing loss of information.I\'ve tested this very thoroughly on a fairly complex, mildly nested multi-hash with all kinds of data in it (string, NULL, integers), and serialize/unserialize ended up much faster than json_encode/json_decode.The only advantage json have in my tests was it\'s smaller \'packed\' size.These are done under PHP 5.3.3, let me know if you want more details.Here are tests results then the code to produce them. I can\'t provide the test data since it\'d reveal information that I can\'t let go out in the wild.Really nice topic and after reading the few answers, I want to share my experiments on the subject.I got a use case where some "huge" table needs to be queried almost every time I talk to the database (don\'t ask why, just a fact). The database caching system isn\'t appropriate as it\'ll not cache the different requests, so I though about php caching systems. I tried apcu but it didn\'t fit the needs, memory isn\'t enough reliable in this case. Next step was to cache into a file with serialization.Table has 14355 entries with 18 columns, those are my tests and stats on reading the serialized cache:As you all said, the major inconvenience with json_encode/json_decode is that it transforms everything to an StdClass instance (or Object). If you need to loop it, transforming it to an array is what you\'ll probably do, and yes it\'s increasing the transformation timeaverage time: 780.2 ms; memory use: 41.5MB; cache file size: 3.8MB@hutch mentions msgpack. Pretty website. Let\'s give it a try shall we?average time: 497 ms; memory use: 32MB; cache file size: 2.8MBThat\'s better, but requires a new extension; compiling sometimes afraid people...@GingerDog mentions igbinary. Note that I\'ve set the igbinary.compact_strings=Offbecause I care more about reading performances than file size.average time: 411.4 ms; memory use: 36.75MB; cache file size: 3.3MBBetter than msg pack. Still, this one requires compiling too.average time: 477.2 ms; memory use: 36.25MB; cache file size: 5.9MBBetter performances than JSON, the bigger the array is, slower json_decode is, but you already new that.Those external extensions are narrowing down the file size and seems great on paper. Numbers don\'t lie*. What\'s the point of compiling an extension if you get almost the same results that you\'d have with a standard PHP function? We can also deduce that depending on your needs, you will choose something different than someone else: That\'s it, another serialization methods comparison to help you choose the one!*Tested with PHPUnit 3.7.31, php 5.5.10 - only decoding with a standard hardrive and old dual core CPU - average numbers on 10 same use case tests, your stats might be differentI made a small benchmark as well. My results were the same. But I need the decode performance. Where I noticed, like a few people above said as well, unserialize is faster than json_decode. unserialize takes roughly 60-70% of the json_decode time. So the conclusion is fairly simple:\nWhen you need performance in encoding, use json_encode, when you need performance when decoding, use unserialize. Because you can not merge the two functions you have to make a choise where you need more performance.My benchmark in pseudo:On avarage: unserialize won 96 times over 4 times the json_decode. With an avarage of roughly 1.5ms over 2.5ms.Before you make your final decision, be aware that the JSON format is not safe for associative arrays - json_decode() will return them as objects instead:Output is:just an fyi -- if you want to serialize your data to something easy to read and understand like JSON but with more compression and higher performance, you should check out messagepack.Check out the results here (sorry for the hack putting the PHP code in the JS code box):http://jsfiddle.net/newms87/h3b0a0ha/embedded/result/RESULTS: serialize() and unserialize() are both significantly faster in PHP 5.4 on arrays of varying size.I made a test script on real world data for comparing json_encode vs serialize and json_decode vs unserialize. The test was run on the caching system of an in production e-commerce site. It simply takes the data already in the cache, and tests the times to encode / decode (or serialize / unserialize) all the data and I put it in an easy to see table.I ran this on PHP 5.4 shared hosting server.The results were very conclusive that for these large to small data sets serialize and unserialize were the clear winners. In particular for my use case, the json_decode and unserialize are the most important for the caching system. Unserialize was almost an ubiquitous winner here. It was typically 2 to 4 times (sometimes 6 or 7 times) as fast as json_decode.It is interesting to note the difference in results from @peter-bailey.Here is the PHP code used to generate the results:JSON is better if you want to backup Data and restore it on a different machine or via FTP.For example with serialize if you store data on a Windows server, download it via FTP and restore it on a Linux one it could not work any more due to the charachter re-encoding, because serialize stores the length of the strings and in the Unicode > UTF-8 transcoding some 1 byte charachter could became 2 bytes long making the algorithm crash.THX - for this benchmark code:My results on array I use for configuration are as fallows:\nJSON encoded in 0.0031511783599854 seconds\nPHP serialized in 0.0037961006164551 seconds\njson_encode() was roughly 20.47% faster than serialize()\nJSON encoded in 0.0070841312408447 seconds\nPHP serialized in 0.0035839080810547 seconds\nunserialize() was roughly 97.66% faster than json_encode()So - test it on your own data.First, I changed the script to do some more benchmarking (and also do 1000 runs instead of just 1):I used this build of PHP 7:PHP 7.0.14 (cli) (built: Jan 18 2017 19:13:23) ( NTS ) Copyright (c)\n  1997-2016 The PHP Group Zend Engine v3.0.0, Copyright (c) 1998-2016\n  Zend Technologies\n      with Zend OPcache v7.0.14, Copyright (c) 1999-2016, by Zend TechnologiesAnd my results were:serialize() (wins: 999) was roughly 10.98% faster than json_encode()\n  unserialize() (wins: 987) was roughly 33.26% faster than json_decode()\n  unserialize() (wins: 987) was roughly 48.35% faster than array\n  json_decode()So clearly, serialize/unserialize is the fastest method, while json_encode/decode is the most portable.If you consider a scenario where you read/write serialized data 10x or more often than you need to send to or receive from a non-PHP system, you are STILL better off to use serialize/unserialize and have it json_encode or json_decode prior to serialization in terms of time.If to summ up what people say here, json_decode/encode seems faster than serialize/unserialize BUT\nIf you do var_dump the type of the serialized object is changed.\nIf for some reason you want to keep the type, go with serialize!(try for example stdClass vs array)serialize/unserialize:json encode/decodeAs you can see the json_encode/decode converts all to stdClass, which is not that good, object info lost... So decide based on needs, especially if it is not only arrays...