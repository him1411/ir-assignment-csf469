This figure again shows that every object has a prototype. Constructor\n  function Foo also has its own __proto__ which is Function.prototype,\n  and which in turn also references via its __proto__ property again to\n  the Object.prototype. Thus, repeat, Foo.prototype is just an explicit\n  property of Foo which refers to the prototype of b and c objects.What are the differences between __proto__ and prototype properties?The figure is taken from here.__proto__ is the actual object that is used in the lookup chain to resolve methods, etc.  prototype is the object that is used to build __proto__ when you create an object with new:prototype is a property of a Function object. It is the prototype of objects constructed by that function.__proto__ is internal property of an object, pointing to its prototype. Current standards provide an equivalent Object.getPrototypeOf(O) method, though de facto standard __proto__ is quicker.You can find instanceof relationships by comparing a function\'s prototype to an object\'s __proto__ chain, and you can break these relationships by changing prototype.Here Point is a constructor function, it builds an object (data structure) procedurally. myPoint is an object constructed by Point() so Point.prototype gets saved to myPoint.__proto__ at that time.Prototype property is created when a function is declared. For instance:Person.prototype property is created internally once you declare above function.\nMany properties can be added to the Person.prototype which are shared by Person instances created using new Person().It is worth noting that Person.prototype is an Object literal by default (it can be changed as required). Every instance created using new Person() has a __proto__ property which points to the Person.prototype. This is the chain that is used to traverse to find a property of a particular object. creates 2 instances of Person, these 2 objects can call age property of Person.prototype as person1.age, person2.age.In the above picture you can see that Foo is a Function Object and therefore it has a __proto__ link to the Function.prototype which in turn is an instance of Object and has a __proto__ link to Object.prototype. The proto link ends here with __proto__ in the Object.prototype pointing to null.Any object can have access to all the properties in its proto chain as linked by __proto__ , thus forming the basis for prototypal inheritance.__proto__ is not a standard way of accessing the prototype chain, the standard but similar approach is to use Object.getPrototypeOf(obj).Below code for instanceof operator gives a better understanding:object instanceof Class operator returns true when an object is an instance of a Class, more specifically if Class.prototype is found in the proto chain of that object then the object is an instance of that Class.The above method can be called as : instanceOf.call(object,Class) which return true if object is instance of Class.A nice way to think of it is...prototype is used by constructor() functions. It should\'ve really been called something like, "prototypeToInstall", since that\'s what it is.and __proto__ is that "installed prototype" on an object (that was created/installed upon the object from said constructor() function)When creating a function, a property object called prototype is being created automatically (you didn\'t create it yourself) and is being attached to the function object (the constructor). Note: This new prototype object also points to, or has an internal-private link to, the native JavaScript Object.Example:If you will create a new object out of Foo using the new keyword, you basically creating (among other things) a new object that has an internal or private link to the function\'s prototype Foo we discussed earlier:To be more specific, __proto__ is actually a getter function that belong to the native JavaScript Object and returns the internal-private prototype linkage of whatever the this binding is (returns the [[Prototype]] of b):It is worth noting that starting of ECMAScript5, you can also use the getPrototypeOf method to get the internal private linkage:To explain let us create a functionWhen JavaScript executes this code, it adds prototype property to a, prototype property is an object with two properties to it:So when we doa.prototype it returns Now as you can see constructor is nothing but the function a itself\nand __proto__ points to the root level Object of JavaScript.Let us see what happens when we use a function with new key word.When JavaScript executes this code it does 4 things:Now if we add a.prototype.car = "BMW" and do \nb.car, the output "BMW" appears.this is because when JavaScript executed this code it searched for car property on b, it did not find then JavaScript used b.__proto__ (which was made to point to \'a.prototype\' in step#2) and finds car property so return "BMW".Hope this helps!!!!!!To make it a little bit clear in addition to above great answers:Instances have __proto__, classes have prototype.Another good way to understand it:Only after IE11 __proto__ is supported. Before that version, such as IE9, you could use the constructor to get the __proto__.To put it simply:This allows you to attach properties to X.prototype AFTER objects of type X has been instantiated, and they will still get access to those new properties through the __proto__ reference which the Javascript-engine uses to walk up the prototype chain.Prototype or Object.prototype is a property of an object literal. It represents the Object prototype object which you can override to add more properties or methods further along the prototype chain. __proto__ is an accessor property (get and set function) that exposes the internal prototype of an object thru which it is accessed.References:http://www.w3schools.com/js/js_object_prototypes.asphttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/protoI know, I am late but let me try to simplify it. Let us say there is a function Foo function will have a prototype object linked. So,Whenever we create a function in JavaScript, it always has a prototype object linked to it. Now let us go ahead and create two objects using the function Foo. Now, Foo.prototype, a.proto, and b.proto  all denotes same object. all of above would return true. As we know, in JavaScript properties can be added dynamically. We can add property to object As you see we added Greet() method in Foo.prototype but it is accessible in a and b or any other object which is constructed using Foo. While executing a.Greet(), JavaScript will first search Greet in object a on property list. On not finding , it will go up in proto chain of a. Since a.proto and Foo.prototype is same object, JavaScript will find Greet() method and execute it. I hope, now prototype and proto  is simplified a bit. I happen to be learning prototype from You Don\'t Know JS: this & Object Prototypes, which is a wonderful book to understand the design underneath and clarify so many misconceptions (that\'s why I\'m trying to avoid using inheritance and things like instanceof). But I have the same question as people asked here. Several answers are really helpful and enlightening. I\'d also love to share my understandings. Objects in JavaScript have an internal property, denoted in the specification as[[Prototype]], which is simply a reference to another object. Almost all objects are given a non-nullvalue for this property, at the time of their creation.via __proto__or Object.getPrototypeOfprototype is an object automatically created as a special property of a function, which is used to establish the delegation (inheritance) chain, aka prototype chain.When we create a function a, prototype is automatically created as a special property on a and saves the function code on as the constructor on prototype.I\'d love to consider this property as the place to store the properties (including methods) of a function object. That\'s also the reason why utility functions in JS are defined like Array.prototype.forEach() , Function.prototype.bind(), Object.prototype.toString().Why to emphasize the property of a function?So, Arary, Function, Objectare all functions. I should admit that this refreshes my impression on JS. I know functions are first-class citizen in JS but it seems that it is built on functions.__proto__a reference works on every object to refer to its [[Prototype]]property.prototype is an object automatically created as a special property of a function, which is used to store the properties (including methods) of a function object.With these two, we could mentally map out the prototype chain. Like this picture illustrates:General Idea :\n------------------------------------------------------------------------------------------------------------Instances use __ proto __ to access the prototype of its constructor function.Prototype is a property of function object.Whenever a function is declared it comes with a prototype property.If we declare a function called Parent_func like the following (it is also called constructor function):Constructor functions ships with a prototype property called Parent_func.prototype.It is an object .So it means we can add new method and properties on it.It has a interface like the following:If we create a new instance of that constructor function, newly created instance will have a method called __ proto __ which will be assigned the prototype of the constructor function.console.log(parent1) will produce this resulthere parent1 is an instance of Parent_func.So parent1 will have a __ proto __ and it will be assigned Parent_func.prototype.Thus we can say instances use __ proto __ to access the prototype of the constructor function.Additional Information :\n------------------------------------------------------------------------------------------------(__ proto __) in inheritance  (parent-child relationship) :Say we have another constructor beside parent called Child().As Child is also a constructor, it too has a prototype property.We want child to inherit from Parent_func.We can do this using Child.prototype Now Child inherit from parent .If we make an instance of Child() constructorSo,child1.__ proto __ is now pointing to an object which happens to be an instance of Parent constructor.So now it will inherit all method and properties of Parent_func including it\'s prototype.So Thus prototype chaining works in classical javascript** _Now i will explain the image which op attached with the question:**As we already know __ proto __ is used by instances to access the prototype  of it\'s constructor :1. First we created a constructor \n    function Foo(){}2. constructor function Foo has a prototype property which points to it\'s prototype which is  Foo.prototype( see image).3. Constructor functions are function which is instance of [[Function]] object.So we can say function Foo is constructed by [[Function]] object.So, __ proto __ of Foo indicates to Function.prototype.4. [[Function]] objects inherit from [[Object]].So __ proto __ of Function.prototype points to Object.prototype.5. Object.prototype is last man standing in prototype chain.So it\'s __ proto __ points to null.6. Now come to instances of Foo.When we create an instance using new Foo(), it creates an instance.Foo it the constructor of these instance.Here we created two instances (x and y). __ proto __ of x and y thus points to Foo.prototype.I\'ll try a 4th grade explanation:Things are very simple. A prototype is an example of how something should be built. So:I\'m a function and I build new objects similar to my prototypeI\'m an object and I was built using my __proto__ as an exampleproof:Every function you create has a property called prototype, and it starts off its life as an empty object. This property is of no use until you use this function as constructor function i.e. with the \'new\' keyword. This is often confused with the __proto__ property of an object. Some might get confused and except that the prototype property of an object might get them the proto of an object. But this is not case. prototype is used to get the __proto__ of an object created from a function constructor.In the above example:I hope it makes sense.(number inside the parenthesis () is a \'link\' to the code that is written below)prototype - an object that consists of:\n => functions (3) of this\n   particular ConstructorFunction.prototype(5) that are accessible by each\n   object (4) created or to-be-created through this constructor function (1)\n => the constructor function itself (1)\n => __proto__ of this particular object (prototype object)__proto__ (dandor proto?) - a link BETWEEN any object (2) created through a particular constructor function (1), AND the prototype object\'s properties (5) of that constructor THAT allows each created object (2) to have access to the prototype\'s functions and methods (4) (__proto__ is by default included in every single object in JS)1.2.3.  4.5.The proto property is a simple accessor property on Object.prototype consisting of a getter and setter function. A property access for proto that eventually consults Object.prototype will find this property, but an access that does not consult Object.prototype will not find it. If some other proto property is found before Object.prototype is consulted, that property will hide the one found on Object.prototype.The proto getter function exposes the value of the internal [[Prototype]] of an object. For objects created using an object literal, this value is Object.prototype. For objects created using array literals, this value is Array.prototype. For functions, this value is Function.prototype. For objects created using new fun, where fun is one of the built-in constructor functions provided by JavaScript (Array, Boolean, Date, Number, Object, String, and so on \xe2\x80\x94 including new constructors added as JavaScript evolves), this value is always fun.prototype. For objects created using new fun, where fun is a function defined in a script, this value is the value of fun.prototype. (That is, if the constructor didn\'t return an other object explicitly, or the fun.prototype has been reassigned since the instance was created).The proto setter allows the [[Prototype]] of an object to be mutated. The object must be extensible according to Object.isExtensible(): if it is not, a TypeError is thrown. The value provided must be an object or null. Providing any other value will do nothing.To understand how prototypes are used for inheritance, see guide article Inheritance and the prototype chain.prototype is a property of a Function. It is the blueprint for creating objects by using that (constructor) function with new keyword.__proto__ is used in the lookup chain to resolve methods, properties. when an object is created (using constructor function with new keyword), __proto__ is set to (Constructor) Function.prototypeImagine there is an imaginary class (blueprint/coockie cutter) associated with function. That imaginary class is used to instantiate objects. prototype is the extention mechanism (extention method in C#, or Swift Extension) to add things to that imaginary class.      The above can be imagined as: So, Now adding method to the prototype of Robot:The above can be imagined as extension of Robot class:    Which in turn, my understanding is: __proto__ and prototype are all served for the prototype chain technique . the difference is functions named with underscore(like __proto__) are not aim for developers invoked explicitly at all. in other words, they are just for some mechanisms like inherit etc. they are \'back-end\'. but functions named without underscore are designed for invoked explicitly, they are \'front-end\'. !!!THIS IS THE BEST EXPLANATION IN THE WORLD!!!!! in function constructors javascript engine call this q.__proto__ = prototype automatically  when we write new Class, and in to the __proto__ prop set Class.prototypeEnjoy %)