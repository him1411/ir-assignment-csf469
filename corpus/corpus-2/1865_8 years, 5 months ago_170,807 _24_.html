What is the meaning of const in declarations like these? The const confuses me.When you add the const keyword to a method the this pointer will essentially become const, and you can therefore not change any member data. (Unless you use mutable, more on that later).The const keyword is part of the functions signature which means that you can implement two similar methods, one which is called when the object is const, and one that isn\'t.This will outputIn the non-const method you can change the instance members, which you cannot do in the const version. If you change the method declaration in the above example to the code below you will get some errors.This is not completely true, because you can mark a member as mutable and a const method can then change it. It\'s mostly used for internal counters and stuff. The solution for that would be the below code.which would outputThe const means that the method promises not to alter any members of the class. You\'d be able to execute the object\'s members that are so marked, even if the object itself were marked const:would be legal.See How many and which are the uses of \xe2\x80\x9cconst\xe2\x80\x9d in C++? for more information.The const qualifier means that the methods can be called on any value of foobar. The difference comes when you consider calling a non-const method on a const object. Consider if your foobar type had the following extra method declaration:The method bar() is non-const and can only be accessed from non-const values.The idea behind const though is to mark methods which will not alter the internal state of the class. This is a powerful concept but is not actually enforceable in C++.  It\'s more of a promise than a guarantee. And one that is often broken and easily broken.  These const mean that compiler will Error if the method \'with const\' changes internal data.The testRead this for more informationBlair\'s answer is on the mark.However note that there is a mutable qualifier which may be added to a class\'s data members.  Any member so marked can be modified in a const method without violating the const contract.You might want to use this (for example) if you want an object to remember how many times a particular method is called, whilst not affecting the "logical" constness of that method.when you use const in the method signature (like your said: const char* foo() const;) you are telling the compiler that memory pointed to by this can\'t be changed by this method (which is foo here).Meaning of a Const Member Function in C++ Common Knowledge: Essential Intermediate Programming gives a clear explanation:  The type of the this pointer in a non-const member function of a class\n  X is X * const. That is, it\xe2\x80\x99s a constant pointer to a non-constant X\n  (see Const Pointers and Pointers to Const [7, 21]). Because the object\n  to which this refers is not const, it can be modified. The type of\n  this in a const member function of a class X is const X * const. That\n  is, it\xe2\x80\x99s a constant pointer to a constant X. Because the object to\n  which this refers is const, it cannot be modified. That\xe2\x80\x99s the\n  difference between const and non-const member functions.So in your code:  You can think it as this:  