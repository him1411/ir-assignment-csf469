I don\'t fully get what Node.js is all about. Maybe it\'s because I am mainly a web based business application developer. What is it and what is the use of it?My understanding so far is that:Are my understandings correct? If yes, then what are the benefits of evented I/O, is it just more for the concurrency stuff? Also, is the direction of Node.js to become a framework like, JavaScript based (V8 based) programming model?I think the advantages are:Web development in a dynamic language (JavaScript) on a VM that is incredibly fast (V8). It is much faster than Ruby, Python, or Perl.Ability to handle thousands of concurrent connections with minimal overhead on a single process.JavaScript is perfect for event loops with first class function objects and closures. People already know how to use it this way having used it in the browser to respond to user initiated events.A lot of people already know JavaScript, even people who do not claim to be programmers. It is arguably the most popular programming language.Using JavaScript on a web server as well as the browser reduces the impedance mismatch between the two programming environments which can communicate data structures via JSON that work the same on both sides of the equation. Duplicate form validation code can be shared between server and client, etc.I use Node.js at work, and find it to be very powerful. Forced to choose one word to describe Node.js, I\'d say "interesting" (which is not a purely positive adjective). The community is vibrant and growing. JavaScript, despite its oddities can be a great language to code in. And you will daily rethink your own understanding of "best practice" and the patterns of well-structured code. There\'s an enormous energy of ideas flowing into Node.js right now, and working in it exposes you to all this thinking - great mental weightlifting.Node.js in production is definitely possible, but far from the "turn-key" deployment seemingly promised by the documentation. With Node.js v0.6.x, "cluster" has been integrated into the platform, providing one of the essential building blocks, but my "production.js" script is still ~150 lines of logic to handle stuff like creating the log directory, recycling dead workers, etc. For a "serious" production service, you also need to be prepared to throttle incoming connections and do all the stuff that Apache does for PHP. To be fair, Ruby on Rails has this exact problem. It is solved via two complementary mechanisms: 1) Putting Ruby on Rails/Node.js behind a dedicated webserver (written in C and tested to hell and back) like Nginx (or Apache / Lighttd). The webserver can efficiently serve static content, access logging, rewrite URLs, terminate SSL, enforce access rules, and manage multiple sub-services. For requests that hit the actual node service, the webserver proxies the request through. 2) Using a framework like Unicorn that will manage the worker processes, recycle them periodically, etc. I\'ve yet to find a Node.js serving framework that seems fully baked; it may exist, but I haven\'t found it yet and still use ~150 lines in my hand-rolled "production.js".Reading frameworks like Express makes it seem like the standard practice is to just serve everything through one jack-of-all-trades Node.js service ... "app.use(express.static(__dirname + \'/public\'))". For lower-load services and development, that\'s probably fine. But as soon as you try to put big time load on your service and have it run 24/7, you\'ll quickly discover the motivations that push big sites to have well baked, hardened C-code like Nginx fronting their site and handling all of the static content requests (...until you set up a CDN, like Amazon CloudFront)). For a somewhat humorous and unabashedly negative take on this, see this guy.Node.js is also finding more and more non-service uses. Even if you are using something else to serve web content, you might still use Node.js as a build tool, using npm modules to organize your code, Browserify to stitch it into a single asset, and uglify-js to minify it for deployment. For dealing with the web, JavaScript is a perfect impedance match and frequently that makes it the easiest route of attack. For example, if you want to grovel through a bunch of JSON response payloads, you should use my underscore-CLI module, the utility-belt of structured data.For another perspective on JavaScript and Node.js, check out From Java to Node.js, a blog post on a Java developer\'s impressions and experiences learning Node.js.Modules\nWhen considering node, keep in mind that your choice of JavaScript libraries will DEFINE your experience. Most people use at least two, an asynchronous pattern helper (Step, Futures, Async), and a JavaScript sugar module (Underscore.js).Helper / JavaScript Sugar:Asynchronous Pattern Modules:Or to read all about the asynchronous libraries, see this panel-interview with the authors.Web Framework:Testing:Also, check out the official list of recommended Node.js modules. However, GitHub\'s Node Modules Wiki is much more complete and a good resource.To understand Node, it\'s helpful to consider a few of the key design choices:Node.js is EVENT BASED and ASYNCHRONOUS / NON-BLOCKING. Events, like an incoming HTTP connection will fire off a JavaScript function that does a little bit of work and kicks off other asynchronous tasks like connecting to a database or pulling content from another server. Once these tasks have been kicked off, the event function finishes and Node.js goes back to sleep. As soon as something else happens, like the database connection being established or the external server responding with content, the callback functions fire, and more JavaScript code executes, potentially kicking off even more asynchronous tasks (like a database query). In this way, Node.js will happily interleave activities for multiple parallel workflows, running whatever activities are unblocked at any point in time. This is why Node.js does such a great job managing thousands of simultaneous connections.Why not just use one process/thread per connection like everyone else? In Node.js, a new connection is just a very small heap allocation. Spinning up a new process takes significantly more memory, a megabyte on some platforms. But the real cost is the overhead associated with context-switching. When you have 10^6 kernel threads, the kernel has to do a lot of work figuring out who should execute next. A bunch of work has gone into building an O(1) scheduler for Linux, but in the end, it\'s just way way more efficient to have a single event-driven process than 10^6 processes competing for CPU time. Also, under overload conditions, the multi-process model behaves very poorly, starving critical administration and management services, especially SSHD (meaning you can\'t even log into the box to figure out how screwed it really is).Node.js is SINGLE THREADED and LOCK FREE. Node.js, as a very deliberate design choice only has a single thread per process. Because of this, it\'s fundamentally impossible for multiple threads to access data simultaneously. Thus, no locks are needed. Threads are hard. Really really hard. If you don\'t believe that, you haven\'t done enough threaded programming. Getting locking right is hard and results in bugs that are really hard to track down. Eliminating locks and multi-threading makes one of the nastiest classes of bugs just go away. This might be the single biggest advantage of node.But how do I take advantage of my 16 core box?Two ways:Node.js lets you do some really powerful things without breaking a sweat. Suppose you have a Node.js program that does a variety of tasks, listens on a TCP port for commands, encodes some images, whatever. With five lines of code, you can add in an HTTP based web management portal that shows the current status of active tasks. This is EASY to do:Now you can hit a URL and check the status of your running process. Add a few buttons, and you have a "management portal". If you have a running Perl / Python / Ruby script, just "throwing in a management portal" isn\'t exactly simple.But isn\'t JavaScript slow / bad / evil / spawn-of-the-devil? JavaScript has some weird oddities, but with "the good parts" there\'s a very powerful language there, and in any case, JavaScript is THE language on the client (browser). JavaScript is here to stay; other languages are targeting it as an IL, and world class talent is competing to produce the most advanced JavaScript engines. Because of JavaScript\'s role in the browser, an enormous amount of engineering effort is being thrown at making JavaScript blazing fast.  V8 is the latest and greatest javascript engine, at least for this month. It blows away the other scripting languages in both efficiency AND stability (looking at you, Ruby). And it\'s only going to get better with huge teams working on the problem at Microsoft, Google, and Mozilla, competing to build the best JavaScript engine (It\'s no longer a JavaScript "interpreter" as all the modern engines do tons of JIT compiling under the hood with interpretation only as a fallback for execute-once code).  Yeah, we all wish we could fix a few of the odder JavaScript language choices, but it\'s really not that bad. And the language is so darn flexible that you really aren\'t coding JavaScript, you are coding Step or jQuery -- more than any other language, in JavaScript, the libraries define the experience. To build web applications, you pretty much have to know JavaScript anyway, so coding with it on the server has a sort of skill-set synergy.  It has made me not dread writing client code.Besides, if you REALLY hate JavaScript, you can use syntactic sugar like CoffeeScript. Or anything else that creates JavaScript code, like Google Web Toolkit (GWT).Speaking of JavaScript, what\'s a "closure"? - Pretty much a fancy way of saying that you retain lexically scoped variables across call chains. ;) Like this:See how you can just use "myData" without doing anything awkward like stashing it into an object? And unlike in Java, the "myData" variable doesn\'t have to be read-only. This powerful language feature makes asynchronous-programming much less verbose and less painful.Writing asynchronous code is always going to be more complex than writing a simple single-threaded script, but with Node.js, it\'s not that much harder and you get a lot of benefits in addition to the efficiency and scalability to thousands of concurrent connections...V8 is an implementation of JavaScript. It lets you run standalone JavaScript applications (among other things).Node.js is simply a library written for V8 which does evented I/O. This concept is a bit trickier to explain, and I\'m sure someone will answer with a better explanation than I... The gist is that rather than doing some input or output and waiting for it to happen, you just don\'t wait for it to finish. So for example, ask for the last edited time of a file:That might take a couple of milliseconds, or it might take seconds. With evented I/O you simply fire off the request and instead of waiting around you attach a callback that gets run when the request finishes:This makes it a lot like JavaScript code in the browser (for example, with Ajax style functionality).For more information, you should check out the article Node.js is genuinely exciting which was my introduction to the library/platform... I found it quite good.Node.js is an open source command line tool built for the server side JavaScript code. You can download a tarball, compile and install the source. It lets you run JavaScript programs.The JavaScript is executed by the V8, a JavaScript engine developed by Google which is used in Chrome browser. It uses a JavaScript API to access the network and file system.It is popular for its performance and the ability to perform parallel operations.Understanding node.js is the best explanation of node.js I have found so far.Following are some good articles on the topic.The closures are a way to execute code in the context it was created in.What this means for concurency is that you can define variables, then initiate a nonblocking I/O function, and send it an anonymous function for its callback.When the task is complete, the callback function will execute in the context with the variables, this is the closure.The reason closures are so good for writing applications with nonblocking I/O is that it\'s very easy to manage the context of functions executing asynchronously.Two good examples are regarding how you manage templates and use progressive enhancements with it. You just need a few lightweight pieces of JavaScript code to make it work perfectly.I strongly recommend that you watch and read these articles:Pick up any language and try to remember how you would manage your HTML file templates and what you had to do to update a single CSS class name in your DOM structure (for instance, a user clicked on a menu item and you want that marked as "selected" and update the content of the page).With Node.js it is as simple as doing it in client-side JavaScript code. Get your DOM node and apply your CSS class to that. Get your DOM node and innerHTML your content (you will need some additional JavaScript code to do this. Read the article to know more).Another good example, is that you can make your web page compatible both with JavaScript turned on or off with the same piece of code. Imagine you have a date selection made in JavaScript that would allow your users to pick up any date using a calendar. You can write (or use) the same piece of JavaScript code to make it work with your JavaScript  turned ON or OFF.There is a very good fast food place analogy that best explains the event driven model of Node.js, see the full article, Node.js, Doctor\xe2\x80\x99s Offices and Fast Food Restaurants \xe2\x80\x93 Understanding Event-driven ProgrammingHere is a summary:If the fast food joint followed a traditional thread-based model, you\'d order your food and wait in line until you received it. The person behind you wouldn\'t be able to order until your order was done. In an event-driven model, you order your food and then get out of line to wait. Everyone else is then free to order.Node.js is event-driven, but most web servers are thread-based.York explains how Node.js works:You use your web browser to make a request for "/about.html" on a\nNode.js web server.The Node.js server accepts your request and calls a function to retrieve\nthat file from disk.While the Node.js server is waiting for the file to be retrieved, it\nservices the next web request.When the file is retrieved, there is a callback function that is\ninserted in the Node.js servers queue.The Node.js server executes that function which in this case would\nrender the "/about.html" page and send it back to your web browser."Well, I understand that For me that means that you were correct in all three assumptions. The library sure looks promising!Also, do not forget to mention that Google\'s V8 is VERY fast. It actually converts the JavaScript code to machine code with the matched performance of compiled binary. So along with all the other great things, it\'s INSANELY fast. Q: The programming model is event driven, especially the way it handles I/O.Correct. It uses call-backs, so any request to access the file system would cause a request to be sent to the file system and then Node.js would start processing its next request. It would only worry about the I/O request once it gets a response back from the file system, at which time it will run the callback code. However, it is possible to make synchronous I/O requests (that is, blocking requests). It is up to the developer to choose between asynchronous (callbacks) or synchronous (waiting).Q: It uses JavaScript and the parser is V8.YesQ: It can be easily used to create concurrent server applications.Yes, although you\'d need to hand-code quite a lot of JavaScript. It might be better to look at a framework, such as http://www.easynodejs.com/ - which comes with full online documentation and a sample application.