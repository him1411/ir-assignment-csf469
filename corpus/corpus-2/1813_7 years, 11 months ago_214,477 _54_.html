I hear a lot that new programming languages are dynamically typed but what does it actually mean when we say a language is dynamically typed vs. statically typed?A language is statically typed if the type of a variable is known at compile time. For some languages this means that you as the programmer must specify what type each variable is (e.g.: Java, C, C++); other languages offer some form of type inference, the capability of the type system to deduce the type of a variable (e.g.: OCaml, Haskell, Scala, Kotlin)The main advantage here is that all kinds of checking can be done by the compiler, and therefore a lot of trivial bugs are caught at a very early stage.A language is dynamically typed if the type is associated with run-time values, and not named variables/fields/etc. This means that you as a programmer can write a little quicker because you do not have to specify types every time (unless using a statically-typed language with type inference). \nExample: Perl, Ruby, PythonMost scripting languages have this feature as there is no compiler to do static type-checking anyway, but you may find yourself searching for a bug that is due to the interpreter misinterpreting the type of a variable. Luckily, scripts tend to be small so bugs have not so many places to hide.Most dynamically typed languages do allow you to provide type information, but do not require it. One language that is currently being developed, Rascal, takes a hybrid approach allowing dynamic typing within functions but enforcing static typing for the function signature.Statically typed programming languages do type checking (the process of verifying and enforcing the constraints of types) at compile-time as opposed to run-time.Dynamically typed programming languages do type checking at run-time as opposed to Compile-time.Here is an example contrasting how Python (dynamically typed) and Go (statically typed) handle a type error: Python does type checking at run time, and therefore:Runs perfectly fine, and produces the expected output Hi. Error is only raised if the problematic line is hit:Producesbecause the relevant line was actually executed.Go on the other hand does type-checking at compile time:The above will not compile, with the following error:Simply put it this way: in a statically typed language variables\' types are static, meaning once you set a variable to a type, you cannot change it. That is because typing is associated with the variable rather than the value it refers to. For example in Java: Where on the other hand: in a dynamically typed language variables\' types are dynamic, meaning after you set a variable to a type, you CAN change it. That is because typing is associated with the value it assumes rather than the variable itself. For example in Python:So, it is best to think of variables in dynamically typed languages as  just generic pointers  to typed values. To sum up, type describes (or should have described) the variables in the language rather than the language itself. It could have been better used as a language with statically typed variables versus a language with dynamically typed variables IMHO.Statically typed languages are generally compiled languages, thus, the compilers check the types (make perfect sense right? as types are not allowed to be changed later on at run time).Dynamically typed languages are generally interpreted, thus type checking (if any) happens at run time when they are used. This of course brings some performance cost, and is one of the reasons dynamic languages (e.g., python, ruby, php) do not scale as good as the typed ones (java, c#, etc.). From another perspective, statically typed languages have more of a start-up cost: makes you usually write more code, harder code. But that pays later off. The good thing is both sides are borrowing features from the other side. Typed languages are incorporating more dynamic features, e.g., generics and dynamic libraries in c#, and dynamic languages are including more type checking, e.g., type annotations in python, or HACK variant of PHP, which are usually not core to the language and usable on demand. When it comes to technology selection, neither side has an intrinsic superiority over the other. It is just a matter of preference whether you want more control to begin with or flexibility. just pick the right tool for the job, and make sure to check what is available in terms of the opposite before considering a switch. http://en.wikipedia.org/wiki/Type_systemStatic typingA programming language is said to use\n  static typing when type checking is\n  performed during compile-time as\n  opposed to run-time. In static typing,\n  types are associated with variables\n  not values. Statically typed languages\n  include Ada, C, C++, C#, JADE, Java,\n  Fortran, Haskell, ML, Pascal, Perl\n  (with respect to distinguishing\n  scalars, arrays, hashes and\n  subroutines) and Scala. Static typing\n  is a limited form of program\n  verification (see type safety):\n  accordingly, it allows many type\n  errors to be caught early in the\n  development cycle. Static type\n  checkers evaluate only the type\n  information that can be determined at\n  compile time, but are able to verify\n  that the checked conditions hold for\n  all possible executions of the\n  program, which eliminates the need to\n  repeat type checks every time the\n  program is executed. Program execution\n  may also be made more efficient (i.e.\n  faster or taking reduced memory) by\n  omitting runtime type checks and\n  enabling other optimizations.Because they evaluate type information\n  during compilation, and therefore lack\n  type information that is only\n  available at run-time, static type\n  checkers are conservative. They will\n  reject some programs that may be\n  well-behaved at run-time, but that\n  cannot be statically determined to be\n  well-typed. For example, even if an\n  expression  always\n  evaluates to true at run-time, a\n  program containing the codewill be rejected as ill-typed, because\n  a static analysis cannot determine\n  that the else branch won\'t be\n  taken.[1] The conservative behaviour\n  of static type checkers is\n  advantageous when \n  evaluates to false infrequently: A\n  static type checker can detect type\n  errors in rarely used code paths.\n  Without static type checking, even\n  code coverage tests with 100% code\n  coverage may be unable to find such\n  type errors. Code coverage tests may\n  fail to detect such type errors\n  because the combination of all places\n  where values are created and all\n  places where a certain value is used\n  must be taken into account.The most widely used statically typed\n  languages are not formally type safe.\n  They have "loopholes" in the\n  programming language specification\n  enabling programmers to write code\n  that circumvents the verification\n  performed by a static type checker and\n  so address a wider range of problems.\n  For example, Java and most C-style\n  languages have type punning, and\n  Haskell has such features as\n  unsafePerformIO: such operations may\n  be unsafe at runtime, in that they can\n  cause unwanted behaviour due to\n  incorrect typing of values when the\n  program runs. Dynamic typingA programming language is said to be\n  dynamically typed, or just \'dynamic\',\n  when the majority of its type checking\n  is performed at run-time as opposed to\n  at compile-time. In dynamic typing,\n  types are associated with values not\n  variables. Dynamically typed languages\n  include Groovy, JavaScript, Lisp, Lua,\n  Objective-C, Perl (with respect to\n  user-defined types but not built-in\n  types), PHP, Prolog, Python, Ruby,\n  Smalltalk and Tcl. Compared to static\n  typing, dynamic typing can be more\n  flexible (e.g. by allowing programs to\n  generate types and functionality based\n  on run-time data), though at the\n  expense of fewer a priori guarantees.\n  This is because a dynamically typed\n  language accepts and attempts to\n  execute some programs which may be\n  ruled as invalid by a static type\n  checker.Dynamic typing may result in runtime\n  type errors\xe2\x80\x94that is, at runtime, a\n  value may have an unexpected type, and\n  an operation nonsensical for that type\n  is applied. This operation may occur\n  long after the place where the\n  programming mistake was made\xe2\x80\x94that is,\n  the place where the wrong type of data\n  passed into a place it should not\n  have. This makes the bug difficult to\n  locate.Dynamically typed language systems,\n  compared to their statically typed\n  cousins, make fewer "compile-time"\n  checks on the source code (but will\n  check, for example, that the program\n  is syntactically correct). Run-time\n  checks can potentially be more\n  sophisticated, since they can use\n  dynamic information as well as any\n  information that was present during\n  compilation. On the other hand,\n  runtime checks only assert that\n  conditions hold in a particular\n  execution of the program, and these\n  checks are repeated for every\n  execution of the program.Development in dynamically typed\n  languages is often supported by\n  programming practices such as unit\n  testing. Testing is a key practice in\n  professional software development, and\n  is particularly important in\n  dynamically typed languages. In\n  practice, the testing done to ensure\n  correct program operation can detect a\n  much wider range of errors than static\n  type-checking, but conversely cannot\n  search as comprehensively for the\n  errors that both testing and static\n  type checking are able to detect.\n  Testing can be incorporated into the\n  software build cycle, in which case it\n  can be thought of as a "compile-time"\n  check, in that the program user will\n  not have to manually run such tests.ReferencesThe terminology "dynamically typed" is unfortunately misleading. All languages are statically typed, and types are properties of expressions (not of values as some think). However, some languages have only one type. These are called uni-typed languages. One example of such a language is the untyped lambda calculus.In the untyped lambda calculus, all terms are lambda terms, and the only operation that can be performed on a term is applying it to another term. Hence all operations always result in either infinite recursion or a lambda term, but never signal an error.However, were we to augment the untyped lambda calculus with primitive numbers and arithmetic operations, then we could perform nonsensical operations, such adding two lambda terms together: (\xce\xbbx.x) + (\xce\xbby.y). One could argue that the only sane thing to do is to signal an error when this happens, but to be able to do this, each value has to be tagged with an indicator that indicates whether the term is a lambda term or a number. The addition operator will then check that indeed both arguments are tagged as numbers, and if they aren\'t, signal an error. Note that these tags are not types, because types are properties of programs, not of values produced by those programs.A uni-typed language that does this is called dynamically typed.Languages such as JavaScript, Python, and Ruby are all uni-typed. Again, the typeof operator in JavaScript and the type function in Python have misleading names; they return the tags associated with the operands, not their types. Similarly, dynamic_cast in C++ and instanceof in Java do not do type checks.Statically typed languages type-check at compile time and the type can NOT change. (Don\'t get cute with type-casting comments, a new variable/reference is created).Dynamically typed languages type-check at run-time and the type of an variable CAN be changed at run-time.Sweet and simple definitions, but fitting the need:\nStatically typed languages binds the type to a variable for its entire scope (Seg: SCALA)\nDynamically typed languages bind the type to the actual value referenced by a variable.In a statically typed language, every variable name is bound both\n 1.to a type (at compile time, by means of a data declaration)\n 2.to an object.\nThe binding to an object is optional \xe2\x80\x94 if a name is not bound to an object, the name is said to be null.\nIn a dynamically typed language, every variable name is (unless it is null) bound only to an object.Names are bound to objects at execution time by means of assignment statements, and it is possible to bind a name to objects of different types during the execution of the program.Static Typing: \nThe languages such as Java and Scala are static typed.The variables have to be defined and initialized before they are used in a code.for ex. int x; x = 10;System.out.println(x);Dynamic Typing:\n Perl is an dynamic typed language.Variables need not be initialized before they are used in code.y=10; use this variable in the later part of code