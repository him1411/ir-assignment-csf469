What is the difference between unit, functional, acceptance, and integration testing (and any other types of tests that I failed to mention)?Depending on where you look, you\'ll get slightly different answers.  I\'ve read about the subject a lot, and here\'s my distillation; again, these are slightly wooly and others may disagree.Unit TestsTests the smallest unit of functionality, typically a method/function (e.g. given a class with a particular state, calling x method on the class should cause y to happen).  Unit tests should be focussed on one particular feature (e.g., calling the pop method when the stack is empty should throw an InvalidOperationException).  Everything it touches should be done in memory; this means that the test code and the code under test shouldn\'t:Any kind of dependency that is slow / hard to understand / initialise / manipulate should be stubbed/mocked/whatevered using the appropriate techniques so you can focus on what the unit of code is doing, not what its dependencies do. In short, unit tests are as simple as possible, easy to debug, reliable (due to reduced external factors), fast to execute and help to prove that the smallest building blocks of your program function as intended before they\'re put together.  The caveat is that, although you can prove they work perfectly in isolation, the units of code may blow up when combined which brings us to ...Integration TestsIntegration tests build on unit tests by combining the units of code and testing that the resulting combination functions correctly.  This can be either the innards of one system, or combining multiple systems together to do something useful.  Also, another thing that differentiates integration tests from unit tests is the environment.  Integration tests can and will use threads, access the database or do whatever is required to ensure that all of the code and the different environment changes will work correctly.  If you\'ve built some serialization code and unit tested its innards without touching the disk, how do you know that it\'ll work when you are loading and saving to disk?  Maybe you forgot to flush and dispose filestreams.  Maybe your file permissions are incorrect and you\'ve tested the innards using in memory streams.  The only way to find out for sure is to test it \'for real\' using an environment that is closest to production.The main advantage is that they will find bugs that unit tests can\'t such as wiring bugs (e.g. an instance of class A unexpectedly receives a null instance of B) and environment bugs (it runs fine on my single-CPU machine, but my colleague\'s 4 core machine can\'t pass the tests).  The main disadvantage is that integration tests touch more code, are less reliable, failures are harder to diagnose and the tests are harder to maintain.Also, integration tests don\'t necessarily prove that a complete feature works.  The user may not care about the internal details of my programs, but I do!Functional TestsFunctional tests check a particular feature for correctness by comparing the results for a given input against the specification.  Functional tests don\'t concern themselves with intermediate results or side-effects, just the result (they don\'t care that after doing x, object y has state z). They are written to test part of the specification such as, "calling function Square(x) with the argument of 2 returns 4". Acceptance TestsAcceptance testing seems to be split into two types:Standard acceptance testing involves performing tests on the full system (e.g. using your web page via a web browser) to see whether the application\'s functionality satisfies the specification. E.g. "clicking a zoom icon should enlarge the document view by 25%." There is no real continuum of results, just a pass or fail outcome. The advantage is that the tests are described in plain English and ensures the software, as a whole, is feature complete.  The disadvantage is that you\'ve moved another level up the testing pyramid. Acceptance tests touch mountains of code, so tracking down a failure can be tricky.  Also, in agile software development, user acceptance testing involves creating tests to mirror the user stories created by/for the software\'s customer during development.  If the tests pass, it means the software should meet the customer\'s requirements and the stories can be considered complete. An acceptance test suite is basically an executable specification written in a domain specific language that describes the tests in the language used by the users of the system.ConclusionThey\'re all complementary.  Sometimes it\'s advantageous to focus on one type or to eschew them entirely.  The main difference for me is that some of the tests look at things from a programmer\'s perspective, whereas others use a customer/end user focus.The important thing is that you know what those terms mean to your colleagues.  Different groups will have slightly varying definitions of what they mean when they say "full end-to-end" tests, for instance. I came across Google\'s naming system for their tests recently, and I rather like it - they bypass the arguments by just using Small, Medium, and Large.  For deciding which category a test fits into, they look at a few factors - how long does it take to run, does it access the network, database, filesystem, external systems and so on.http://googletesting.blogspot.com/2010/12/test-sizes.htmlI\'d imagine the difference between Small, Medium, and Large for your current workplace might vary from Google\'s.  However, it\'s not just about scope, but about purpose.  Mark\'s point about differing perspectives for tests, e.g. programmer vs customer/end user, is really important.  http://martinfowler.com/articles/microservice-testing/Martin Fowler\'s blog post speaks about strategies to test code (Especially in a micro-services architecture) but most of it applies to any application.I\'ll quote from his summary slide:Unit Testing - As the name suggests, this method tests at the object level. Individual software components are tested for any errors. Knowledge of the program is needed for this test and the test codes are created to check if the software behaves as it is intended to.Functional Testing - Is carried out without any knowledge of the internal working of the system. The tester will try to use the system by just following requirements, by providing different inputs and testing the generated outputs. This test is also known as closed-box testing or black-box.Acceptance Testing - This is the last test that is conducted before the software is handed over to the client. It is carried out to ensure that the developed software meets all the customer requirements. There are two types of acceptance testing - one that is carried out by the members of the development team, known as internal acceptance testing (Alpha testing), and the other that is carried out by the customer or end user known as (Beta testing)  Integration Testing - Individual modules that are already subjected to unit testing are integrated with one another. Generally the two approachs are followed :1) Top-Down\n2) Bottom-UpThis is very simple.Unit testing: This is the testing actually done by developers that have coding knowledge. This testing is done at the coding phase and it is a part of white box testing. When a software comes for development, it is developed into the piece of code or slices of code known as a unit. And individual testing of these units called unit testing done by developers to find out some kind of human mistakes like missing of statement coverage etc..Functional testing: This testing is done at testing (QA) phase and it is a part of black box testing. The actual execution of the previously written test cases. This testing is actually done by testers, they find the actual result of any functionality in the site and compare this result to the expected result. If they found any disparity then this is a bug.Acceptance testing: know as UAT. And this actually done by the tester as well as developers, management team, author, writers, and all who are involved in this project. To ensure the project is finally ready to be delivered with bugs free.Integration testing: The units of code (explained in point 1) are integrated with each other to complete the project. These units of codes may be written in different coding technology or may these are of different version so this testing is done by developers to ensure that all units of the code are compatible with other and there is no any issue of integration.Some (relatively) recent ideas against excessive mocking and pure unit-testing:unit test: testing of individual module or independent component in an application is known to be unit testing , the unit testing will be done by developer.integration test: combining all the modules and testing the application to verify the communication and the data flow between the modules are working properly or not , this testing also performed by developers.funcional test checking the individual functionality of an application is mean to be functional testingacceptance testing this testing is done by end user or customer whether the build application is according to the customer requirement , and customer specification this is known to be acceptance testingI will explain you this with a practical example and no theory stuff:A developer writes the code. No GUI is implemented yet. The testing at this level verifies that the functions work correctly and the data types are correct. This phase of testing is called Unit testing.When a GUI is developed, and application is assigned to a tester, he verifies business requirements with a client and executes the different scenarios. This is called functional testing. Here we are mapping the client requirements with application flows.Integration testing: let\'s say our application has two modules: HR and Finance. HR module was delivered and tested previously. Now Finance is developed and is available to test. The interdependent features are also available now, so in this phase, you will test communication points between the two and will verify they are working as requested in requirements.Regression testing is another important phase, which is done after any new development or bug fixes. Its aim is to verify previously working functions.