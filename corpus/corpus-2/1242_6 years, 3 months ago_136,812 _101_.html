Without creating a branch and doing a bunch of funky work on a new branch, is it possible to break a single commit into a few different commits after it\'s been committed to the local repository?git rebase -i will do it.To split apart your most recent commit, first:Now commit the pieces individually in the usual way, producing as many commits as you need.If it was farther back in the tree, thenwhere 3 is how many commits back it is.If it was farther back in the tree than you want to count, thenwhere 123abcd is the SHA1 of the commit you want to split up.When you get the rebase edit screen, find the commit you want to break apart.  At the beginning of that line, replace pick with edit (e for short).  Save the buffer and exit.  Rebase will now stop just after the commit you want to edit.  Then:Commit the pieces individually in the usual way, producing as many commits as you need, thenFrom git-rebase manual (SPLITTING COMMITS section)In interactive mode, you can mark commits with the action "edit". However, this does not necessarily mean that git rebase expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:Start an interactive rebase with git rebase -i <commit>^, where <commit> is the commit you want to split. In fact, any commit range will do, as long as it contains that commit. Mark the commit you want to split with the action "edit". When it comes to editing that commit, execute git reset HEAD^. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same. Now add the changes to the index that you want to have in the first commit. You can use git add (possibly interactively) or git gui (or both) to do that. Commit the now-current index with whatever commit message is appropriate now. Repeat the last two steps until your working tree is clean. Continue the rebase with git rebase --continue.Use git rebase --interactive to edit that earlier commit, run git reset HEAD~, and then git add -p to add some, then make a commit, then add some more and make another commit, as many times as you like. When you\'re done, run git rebase --continue, and you\'ll have all the split commits earlier in your stack.Important: Note that you can play around and make all the changes you want, and not have to worry about losing old changes, because you can always run git reflog to find the point in your project that contains the changes you want, (let\'s call it a8c4ab), and then git reset a8c4ab.Here\'s a series of commands to show how it works:mkdir git-test; cd git-test; git initnow add a file Avi Aadd this line:onegit commit -am onethen add this line to A:twogit commit -am twothen add this line to A:threegit commit -am threenow the file A looks like this:and our git log looks like the following (well, I use git log --pretty=oneline --pretty="%h %cn %cr ---- %s"Let\'s say we want to split the second commit, two.git rebase --interactive HEAD~2This brings up a message that looks like this:Change the first pick to an e to edit that commit.git reset HEAD~git diff shows us that we just unstaged the commit we made for the second commit:Let\'s stage that change, and add "and a third" to that line in file A.git add .This is usually the point during an interactive rebase where we would run git rebase --continue, because we usually just want to go back in our stack of commits to edit an earlier commit. But this time, we want to create a new commit. So we\'ll run git commit -am \'two and a third\'. Now we edit file A and add the line two and two thirds. git add .\ngit commit -am \'two and two thirds\'\ngit rebase --continueWe have a conflict with our commit, three, so let\'s resolve it:We\'ll changeto git add .; git rebase --continueNow our git log -p looks like this:git rebase --interactive can be used to split a commit into smaller commits.  The Git docs on rebase have a concise walkthrough of the process - Splitting Commits:In interactive mode, you can mark commits with the action "edit". However, this does not necessarily mean that git rebase expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:Start an interactive rebase with git rebase -i <commit>^, where <commit> is the commit you want to split. In fact, any commit range will do, as long as it contains that commit.Mark the commit you want to split with the action "edit".When it comes to editing that commit, execute git reset HEAD^. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.Now add the changes to the index that you want to have in the first commit. You can use git add (possibly interactively) or git gui (or both) to do that.Commit the now-current index with whatever commit message is appropriate now.Repeat the last two steps until your working tree is clean.Continue the rebase with git rebase --continue.If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use git stash to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.You can do interactive rebase git rebase -i. Man page has exactly what you want:http://git-scm.com/docs/git-rebase#_splitting_commitsPlease note there\'s also git reset --soft HEAD^. It\'s similar to git reset (which defaults to --mixed) but it retains the index contents. So that if you\'ve added/removed files, you have them in the index already.Turns out to be very useful in case of giant commits.Previous answers have covered the use of git rebase -i to edit the commit that you want to split, and committing it in parts.This works well when splitting the files into different commits, but if you want to break apart changes to the individual files, there\'s more you need to know.Having got to the commit you want to split, using rebase -i and marking it for edit, you have two options.After using git reset HEAD~, go through the patches individually using git add -p to select the ones you want in each commitEdit the working copy to remove the changes you do not want; commit that interim state; and then pull back the full commit for the next round.Option 2 is useful if you\'re splitting a large commit, as it lets you check that the interim versions build and run properly as part of the merge. This proceeds as follows.After using rebase -i and editing the commit, usegit reset --soft HEAD~to undo the commit, but leave the committed files in the index. You can also do a mixed reset by omitting --soft, depending on how close to the final result your initial commit is going to be. The only difference is whether you start with all the changes staged or with them all unstaged.Now go in and edit the code. You can remove changes, delete added files, and do whatever you want to construct the first commit of the series you\'re looking for. You can also build it, run it, and confirm that you have a consistent set of source.Once you\'re happy, stage/unstage the files as needed (I like to use git gui for this), and commit the changes through the UI or the command linegit commitThat\'s the first commit done. Now you want to restore your working copy to the state it had after the commit you are splitting, so that you can take more of the changes for your next commit. To find the sha1 of the commit you\'re editing, use git status. In the first few lines of the status you\'ll see the rebase command that is currently executing, in which you can find the sha1 of your original commit:$ git status\ninteractive rebase in progress; onto be83b41\nLast commands done (3 commands done):\n   pick 4847406 US135756: add debugging to the file download code\n   e 65dfb6a US135756: write data and download from remote\n  (see more in file .git/rebase-merge/done)\n...In this case, the commit I\'m editing has sha1 65dfb6a. Knowing that, I can check out the content of that commit over my working directory using the form of git checkout which takes both a commit and a file location. Here I use . as the file location to replace the whole working copy:git checkout 65dfb6a .Don\'t miss the dot on the end!This will check out, and stage, the files as they were after the commit you\'re editing, but relative to the previous commit you made, so any changes you already committed won\'t be part of the commit.You can either go ahead now and commit it as-is to finish the split, or go around again, deleting some parts of the commit before making another interim commit.If you want to reuse the original commit message for one or more commits, you can use it straight from the rebase\'s working files:git commit --file .git/rebase-merge/messageFinally, once you\'ve committed all the changes, git rebase --continuewill carry on and complete the rebase operation.Now in the latest TortoiseGit on Windows you can do it very easily.Open the rebase dialog, configure it, and do the following steps.Very helpful, thanks TortoiseGit ! Easiest thing to do without an interactive rebase is (probably) to make a new branch starting at the commit before the one you want to split, cherry-pick -n the commit, reset, stash, commit the file move, reapply the stash and commit the changes, and then either merge with the former branch or cherry-pick the commits that followed.  (Then switch the former branch name to the current head.)  (It\'s probably better to follow MBOs advice and do an interactive rebase.)I think that the best way i use git rebase -i. I created a video to show the steps to split a commit: https://www.youtube.com/watch?v=3EzOz7e1ADIIf you have this:Where you have committed some content in commit B:But you want to split B into C - D, and get this result:You can divide the content like this for example (content from different directories in different commits)...Reset the branch back to the commit before the one to split:Create first commit (C):Create second commit (D):