I wonder what is better to do:or:in is definitely more pythonic.In fact has_key() was removed in Python 3.x.in wins hands-down, not just in elegance (and not being deprecated;-) but also in performance, e.g.:While the following observation is not always true, you\'ll notice that usually, in Python, the faster solution is more elegant and Pythonic; that\'s why -mtimeit is SO helpful -- it\'s not just about saving a hundred nanoseconds here and there!-)According to python docs:has_key() is deprecated in favor of\n  key in d.Use dict.has_key() if (and only if) your code is required to be runnable by Python versions earlier than 2.3 (when key in dict was introduced). There is one example where in actually kills your performance.If you use in on a O(1) container that only implements __getitem__ and has_key() but not __contains__ you will turn an O(1) search into an O(N) search (as in falls back to a linear search via __getitem__).Fix is obviously trivial:has_key is a dictionary method, but in will work on any collection, and even when __contains__ is missing, in will use any other method to iterate the collection to find out.Python 2.x supports has_key().Python 2.3+ and Python 3.x support in.Solution to dict.has_key() is deprecated, use \'in\' -- sublime text editor 3Here I have taken an example of dictionary named \'ages\' -If your intention is to use a default value in case a key is not in the dictionary thenis a way of skipping the in check. get returns None if the key is not in the dictionary. The speed is also O(1) as with using in. You can also usebut I find that less readable.Expanding on Alex Martelli\'s performance tests with Adam Parkin\'s comments...If you have something like thischange it to below for running on Python 3.X and aboveThe API looks the way it does for a reason... Using the builtin type APIs as documented is Pythonic...You should typically do my_dict.get(\'key\', default_value) rather than my_dict.get(\'key\') or default_value.The exception would be the odd case want to replace all false-equivalent values (0, \'\', [] etc) returned from my_dict with default_value.Actually, if the intention is to get a default value from a dict, why not use collections.defaultdict instead of the builtin dict?The most common usecase for defaultdicts is probably with the list type, e.g: