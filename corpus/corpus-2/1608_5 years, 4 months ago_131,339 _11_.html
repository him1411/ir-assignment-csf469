I know that in C++11 we can now use using to write type alias, like typedefs:Is, from what I understand, equivalent to:And that new syntax emerged from the effort to have a way to express "template typedef":But, with the first two non-template examples, are there any other subtle differences in the standard? For example, typedefs do aliasing in a "weak" way. That is it does not create a new type but only a new name (conversions are implicit between those names).Is it the same with using or does it generate a new type? Are there any differences?They are equivalent, from the standard (emphasis mine) (7.1.3.2):A typedef-name can also be introduced by an alias-declaration. The\n  identifier following the using keyword becomes a typedef-name and the\n  optional attribute-specifier-seq following the identifier appertains\n  to that typedef-name. It has the same semantics as if it were\n  introduced by the typedef specifier. In particular, it\n  does not define a new type and it shall not appear in the type-id.The using syntax has an advantage when used within templates. If you need the type abstraction, but also need to keep template parameter to be possible to be specified in future. You should write something like this.But using syntax simplifies this use case.They are largely the same, except thatThe alias declaration is compatible with templates, whereas the C style typedef is not.\n