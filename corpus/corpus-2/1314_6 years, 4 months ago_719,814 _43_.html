Is there a way to delete an item from a dictionary in Python?I know I can just call .pop on the dictionary, but that returns the item that was removed. What I\'m looking for is something returns the dictionary minus the element in question. At present I have a helper function that accepts the dictionary in question as parameter, and then returns a dictionary with the item removed, Is there a more elegant solution?The del statement removes an element:However, this mutates the existing dictionary so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a new dictionary, make a copy of the dictionary:The dict() constructor makes a shallow copy. To make a deep copy, see the copy module.pop mutates the dictionary.If you want to keep the original you could just copy it.I think your solution is best way to do it. But if you want another solution, you can create a new dictionary with using the keys from old dictionary without including your specified key, like this:The del statement is what you\'re looking for. If you have a dictionary named foo with a key called \'bar\', you can delete \'bar\' from foo like this:Note that this permanently modifies the dictionary being operated on. If you want to keep the original dictionary, you\'ll have to create a copy beforehand:The dict call makes a shallow copy. If you want a deep copy, use copy.deepcopy.Here\'s a method you can copy & paste, for your convenience:Result: d = {1: 2, \'2\': 3}Simply call del d[\'key\'].However, in production, it is always a good practice to check if \'key\' exists in d.this doesn\'t do any error handling, it assumes the key is in the dict, you might want to check that first and raise if its notNo, there is no other way thanHowever, often creating copies of only slightly altered dictionaries is probably not a good idea because it will result in comparatively large memory demands. It is usually better to log the old dictionary(if even necessary) and then modify it.nice one-liner to check if the key is present, delete it, return the value, or default:Here a top level design approach:I\'m passing the dictionary and the key I want into my function, validates if it\'s a dictionary and if the key is okay, and if both exist, removes the value from the dictionary and prints out the left-overs.Output: {\'B\': 55, \'A\': 34}Hope that helps!There\'re a lot of nice answers, but I want to emphasize one moment.You can use both dict.pop() method and a more generic del statement to remove items from a dictionary. They both mutate the original dictionary, so you need to make a copy (see details below).And both of them will raise a KeyError if the key you\'re providing to them is not present in the dictionary:andYou have to take care of this:by capturing the exception:andby performing a check:andbut with pop() there\'s also a much more concise way - provide the default return value:Unless you use pop() to get the value of a key being removed you may provide anything, not necessary None.\nThough it might be that using del with in check is slightly faster due to pop() being a function with its own complications causing overhead. Usually it\'s not the case, so pop() with default value is good enough.As for the main question, you\'ll have to make a copy of your dictionary, to save the original dictionary and have a new one without the key being removed.Some other people here suggest making a full (deep) copy with copy.deepcopy(), which might be an overkill, a "normal" (shallow) copy, using copy.copy() or dict.copy(), might be enough. The dictionary keeps a reference to the object as a value for a key. So when you remove a key from a dictionary this reference is removed, not the object being referenced. The object itself may be removed later automatically by the garbage collector, if there\'re no other references for it in the memory. Making a deep copy requires more calculations compared to shallow copy, so it decreases code performance by making the copy, wasting memory and providing more work to the GC, sometimes shallow copy is enough.However, if you have mutable objects as dictionary values and plan to modify them later in the returned dictionary without the key, you have to make a deep copy.With shallow copy:With deep copy:Below code snippet will help you definitely, I have added comments in each line which will help you in understanding the code.Here\'s another variation using list comprehension:The approach is based on an answer from this post:\nEfficient way to remove keys with empty strings from a dict