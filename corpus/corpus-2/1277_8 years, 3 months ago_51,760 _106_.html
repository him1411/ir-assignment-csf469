C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can\'t predict the behavior when the code is run.As far as I know, the standard doesn\'t explicitly say why the concept of undefined behavior exists. In my mind, it\'s simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.So, with that in mind, why are these "issues"? The language clearly says that certain things lead to undefined behavior. There is no problem, there is no "should" involved. If the undefined behavior changes when one of the involved variables is declared volatile, that doesn\'t prove or change anything. It is undefined; you cannot reason about the behavior.Your most interesting-looking example, the one withis a text-book example of undefined behavior (see Wikipedia\'s entry on sequence points).Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.This is what I get on my machine, together with what I think is going on:(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)I think the relevant parts of the C99 standard are 6.5 Expressions, \xc2\xa72Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.and 6.5.16 Assignment operators, \xc2\xa74:The order of evaluation of the operands is unspecified. If an attempt is made to modify\n  the result of an assignment operator or to access it after the next sequence point, the\n  behavior is undefined. The behavior can\'t really be explained because it invokes both unspecified behavior and undefined behavior, so we can not make any general predictions about this code, although if you read Olve Maudal\'s work such as Deep C and Unspecified and Undefined sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don\'t do that anywhere near production.So moving on to unspecified behavior, in draft c99 standard section6.5 paragraph 3 says(emphasis mine):The grouping of operators and operands is indicated by the syntax.74) Except as specified\n  later (for the function-call (), &&, ||, ?:, and comma operators), the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.So when we have a line like this:we do not know whether i++ or ++i will be evaluated first. This is mainly to give the compiler better options for optimization.We also have undefined behavior here as well since the program is modifying variables(i, u, etc..) more than once between sequence points. From draft standard section 6.5 paragraph 2(emphasis mine):Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.it cites the following code examples as being undefined:In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the ; in each one of these cases:Unspecified behavior is defined in the draft c99 standard in section 3.4.4 as:use of an unspecified value, or other behavior where this International Standard provides\n  two or more possibilities and imposes no further requirements on which is chosen in any\n  instanceand undefined behavior is defined in section 3.4.3 as:behavior, upon use of a nonportable or erroneous program construct or of erroneous data,\n  for which this International Standard imposes no requirementsand notes that:Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand why the behavior of these constructs are undefined, let\'s understand these terms first in the light of C11 standard:  Sequenced: (5.1.2.3)Given any two evaluations A and B, if A is sequenced before B, then the execution of A shall precede the execution of B.  Unsequenced:If A is not sequenced before or after B, then A and B are unsequenced.  Evaluations can be one of two things: Sequence Point:The presence of a sequence point between the evaluation of expressions A and B implies that every value computation and side effect associated with A is sequenced before every value computation and side effect associated with B. Now coming to the question, for the expressions like  standard says that:  If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. [...]  Therefore, the above expression invokes UB because two side effects on the same object i is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to i will be done before or after the side effect by ++.\nDepending on whether assignment occurs before or after the increment, different results will be produced and that\'s the one of the case of undefined behavior.  Lets rename the i at left of assignment be il and at the right of assignment (in the expression i++) be ir, then the expression be like  An important point regarding Postfix ++ operator is that:  just because the ++ comes after the variable does not mean that the increment happens late. The increment can happen as early as the compiler likes as long as the compiler ensures that the original value is used.    It means the expression il = ir++ could be evaluated either as  or  resulting in two different results 1 and 2 which depends on the sequence of side effects by assignment and ++ and hence invokes UB. Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, what are they supposed to mean? What was the programmer trying to do?The first fragment asked about, i = i++ + ++i, is pretty clearly insane in my book.  No one would ever write it in a real program, it\'s not obvious what it does, there\'s no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it\'s not obvious to you and me what it\'s supposed to do, it\'s fine in my book if the compiler can\'t figure out what it\'s supposed to do, either.The second fragment, i = i++, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:C, of course, has a handy shortcut:This means, "add 1 to i, and assign the result back to i".  So if we construct a hodgepodge of the two, by writingwhat we\'re really saying is "add 1 to i, and assign the result back to i, and assign the result back to i".  We\'re confused, so it doesn\'t bother me too much if the compiler gets confused, too.Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, "If it\'s not obvious what an expression using ++ means, don\'t write it."[Addendum:  Another practical rule is that if you have a question that starts with something like the words, "I have a question about some weird behavior involving ++", then I can tell you, without reading any further but with almost absolute certainty, that the answer is "It\'s undefined.  Don\'t write it that way, and don\'t try to figure out why you got the weird result you did."]We used to spend countless hours on comp.lang.c discussing expressions like these and why they\'re undefined.  Two of my longer answers, that try to really explain why, are on the web at http://www.eskimo.com/~scs/readings/undef.950321.html and http://www.eskimo.com/~scs/readings/precvsooe.960725.html .While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement "i++" with the sequence:While I don\'t think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, i would get incremented by two) and it\'s not totally inconceivable that some future processor might provide a feature something like that.If the compiler were to write i++ as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn\'t happen to notice that one of the other instructions happened to access i, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable i is used in both places, but if a routine accepts references to two variables i and j, and uses i and j in the above expression (rather than using i twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same variable were passed for both i and j.Often this question is linked as a duplicate of questions related to code likeor or similar variants.While this is also undefined behaviour as stated already, there are subtle differences when printf() is involved when comparing to a statement such as:In the following statement:the order of evaluation of arguments in printf() is unspecified. That means, expressions i++ and ++i could be evaluated in any order. C11 standard has some relevant descriptions on this:Annex J, unspecified behavioursThe order in which the function designator, arguments, and\n  subexpressions within the arguments are evaluated in a function call\n  (6.5.2.2).3.4.4, unspecified behaviorUse of an unspecified value, or other behavior where this\n  International Standard provides two or more possibilities and imposes\n  no further requirements on which is chosen in any instance.EXAMPLE An example of unspecified behavior is the order in which the\n  arguments to a function are evaluated.The unspecified behaviour itself is NOT an issue. Consider this example:This too has unspecified behaviour because the order of evaluation of ++x and y++ is unspecified. But it\'s perfectly legal and valid statement. There\'s no undefined behaviour in this statement. Because the modifications (++x and y++) are done to distinct objects.What renders the following statement as undefined behaviour is the fact that these two expressions modify the same object i without an intervening sequence point.Another detail is that the comma involved in the printf() call is a separator, not the comma operator.This is an important distinction because the comma operator does introduce a sequence point between the evaluation of their operands, which makes the following legal:The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in j = (++i, i++);, ++i increments i to 6 and i++ yields old value of i (6) which is assigned to j. Then i becomes 7 due to post-increment.So if the comma in the function call were to be a comma operator then will not be a problem. But it invokes undefined behaviour because the comma here is a separator.For those who are new to undefined behaviour would benefit from reading What Every C Programmer Should Know About Undefined Behavior  to understand the concept and many other variants of undefined behaviour in C.This post: Undefined, unspecified and implementation-defined behavior is also relevant.The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. \nSo every statement of the form:and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.However, two different variables can be incremented between two sequence points.The above is a common coding practice while copying/analysing strings.In https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c someone asked about a statement like:which prints 7... the OP expected it to print 6.The ++i increments aren\'t guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 ++i executed, then the values of k[] were read, then the last ++i then k[].Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).While the syntax of C allows such constructs, the behaviour of the program is undefined, because a shall in C standard is not obeyed. C99 6.5p2:Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]With footnote 73 further clarifying thatThis paragraph renders undefined statement expressions such aswhile allowingYou can detect such errors in a program by for example using a recent version of GCC with -Wall and -Werror, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).However if you stick to one compiler, you will find the behavior persistent, as long as you don\'t add function calls or pointers, which would make the behavior more messy.So first the GCC:\nUsing Nuwen MinGW 15 GCC 7.1 you will get:}How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).according to GCC C++: OperatorsIn GCC C++,  the precedence of the operators controls the order in\n  which the individual operators are evaluatedthe equivalent code in defined behavior C++ as   GCC understands:Then we go to Visual Studio. Visual Studio 2015, you get:How does visual studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass. So the equivalent in defined behavior C++ as Visual C++ understands:as Visual Studio documentation states at Precedence and Order of Evaluation:Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators. 