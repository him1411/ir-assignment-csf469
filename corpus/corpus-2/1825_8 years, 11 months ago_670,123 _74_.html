I am trying to run some unit tests in a C# Windows Forms application (Visual Studio 2005), and I get the following error:System.IO.FileLoadException: Could not load file or assembly \'Utility, Version=1.2.0.200, Culture=neutral, PublicKeyToken=764d581291d764f7\' or one of its dependencies. The located assembly\'s manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)**at x.Foo.FooGO()at x.Foo.Foo2(String groupName_) in Foo.cs:line 123at x.Foo.UnitTests.FooTests.TestFoo() in FooTests.cs:line 98**System.IO.FileLoadException: Could not load file or assembly \'Utility, Version=1.2.0.203, Culture=neutral, PublicKeyToken=764d581291d764f7\' or one of its dependencies. The located assembly\'s manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)I look in my references, and I only have a reference to Utility version 1.2.0.203 (the other one is old).Any suggestions on how I figure out what is trying to reference this old version of this DLL file?Besides, I don\'t think I even have this old assembly on my hard drive.\nIs there any tool to search for this old versioned assembly?The .NET Assembly loader is unable to find 1.2.0.203, but did find a 1.2.0.200. This assembly does not match what was requested and therefore you get this error. In simple words, it can\'t find the assembly that was referenced. Make sure it can find the right assembly by putting it in the GAC or in the application path. Also see http://blogs.msdn.com/junfeng/archive/2004/03/25/95826.aspx.You can do a couple of things to troubleshoot this issue. First, use Windows file search to search your hard drive for your assembly (.dll). Once you have a list of results, do View->Choose Details... and then check "File Version". This will display the version number in the list of results, so you can see where the old version might be coming from.Also, like Lars said, check your GAC to see what version is listed there. This Microsoft article states that assemblies found in the GAC are not copied locally during a build,  so you might need to remove the old version before doing a rebuild all. (See my answer to this question for notes on creating a batch file to do this for you)If you still can\'t figure out where the old version is coming from, you can use the fuslogvw.exe application that ships with Visual Studio to get more information about the binding failures. Microsoft has information about this tool here. Note that you\'ll have to enable logging by setting the HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Fusion\\EnableLog registry key to 1.I just ran into this problem myself, and I found that the issue was something different than what the others have run into.I had two DLLs that my main project was referencing:  CompanyClasses.dll and CompanyControls.dll.  I was getting a run-time error saying:Could not load file or assembly\n  \'CompanyClasses, Version=1.4.1.0,\n  Culture=neutral,\n  PublicKeyToken=045746ba8544160c\' or\n  one of its dependencies. The located\n  assembly\'s manifest definition does\n  not match the assembly referenceTrouble was, I didn\'t have any CompanyClasses.dll files on my system with a version number of 1.4.1.  None in the GAC, none in the app folders...none anywhere.  I searched my entire hard drive.  All the CompanyClasses.dll files I had were 1.4.2. The real problem, I found, was that CompanyControls.dll referenced version 1.4.1 of CompanyClasses.dll.  I just recompiled CompanyControls.dll (after having it reference CompanyClasses.dll 1.4.2) and this error went away for me.The following redirects any assembly version to version 3.1.0.0, we have a script that will always update this reference in the App.config so we never have to deal with this issue again.\nThrough reflection you can get the assembly publicKeyToken and generate this block from the .dll file itself.Note that without an xml namespace attribute (xmlns) this will not work.If you don\'t care about the version and you just want your app to run then right click on the reference and set \'specific version\' to false.  The other solutions wouldn\'t work for me.\nIf you are using Visual Studio, try "clean solution" and then rebuild your project.I just ran across this issue and the problem was I had an old copy of the .dll in my application debug directory.  You might want to also check there (instead of the GAC) to see if you see it.In my case it was an old version of the DLL in C:\\WINDOWS\\Microsoft.NET\\Framework\\~\\Temporary ASP.NET Files\\ directory. You can either delete or replace the old version, or you can remove and add back the reference to the DLL in your project. Basically, either way will create a new pointer to the temporary ASP.NET Files. I added a NuGet package, only to realize a black-box portion of my application was referencing an older version of the library.I removed the package and referenced the older version\'s static DLL file, but the web.config file was never updated from:to what it should have reverted to when I uninstalled the package:For us, the problem was caused by something else. The license file for the DevExpress components included two lines, one for an old version of the components that was not installed on this particular computer. Removing the older version from the license file solved the issue. The annoying part is that the error message gave no indication to what reference was causing the problems.In my case, this error occurred while running an ASP.NET application.\nThe solution was to:Clean didn\'t work, rebuild didn\'t work, all references were fine, but it wasn\'t writing one of the libraries. After deleting those directories, everything worked perfectly.This exact same error is thrown if you try to late bind using reflection, if the assembly you are binding to gets strong-named or has its public-key token changed.  The error is the same even though there is not actually any assembly found with the specified public key token.You need to add the correct public key token (you can get it using sn -T on the dll) to resolve the error.  Hope this helps.Mine was a very similar situation to the post by Nathan Bedford but with a slight twist. My project too referenced the changed dll in two ways.  1) Directly and 2) Indirectly by referencing a component (class library) that itself had a reference to the changed dll. Now my Visual studio project for the component(2) referenced the correct version of the changed dll. However the version number of the compnent itself was NOT changed. And as a result the install of the new version of the project failed to replace that component on the client machine.End result: Direct reference (1) and Indirect reference(2) were pointing to different versions of the changed dll at the client machine. On my dev machine it worked fine.Resolution: Remove application; Delete all the DLLS from application folder; Re-install.Simple as that in my case.I\'ll let someone benefit from my shear stupidity.  I have some dependencies to a completely separate application (let\'s call this App1).  The dll\'s from that App1 are pulled into my new application (App2).  Any time I do updates in APP1, I have to create new dll\'s and copy them into App2.  Well. . .I got tired of copying and pasting between 2 different App1 versions, so I simply added a \'NEW_\' prefix to the dll\'s.  Well. . . I\'m guessing that the build process scans the /bin folder and when it matches something up incorrectly, it barfs with the same error message as noted above.  I deleted my "new_" versions and it built just dandy.My issue was copying source code to a new machine without pulling over any of the referenced assemblies. Nothing that I did fixed the error, so in haste, I deleted the BIN directory altogether. Rebuilt my source code, and it worked from then on out.All the above got me confused, however this one saved my day: http://runtingsproper.blogspot.in/2010/04/solved-located-assemblys-manifest.htmlI just found another reason why to get this error. I cleaned my GAC from all versions of a specific library and built my project with reference to specific version deployed together with the executable. When I run the project I got this exception searching for a newer version of the library.The reason was publisher policy. When I uninstalled library\'s versions from GAC I forgot to uninstall publisher policy assemblies as well so instead of using my locally deployed assembly the assembly loader found publisher policy in GAC which told it to search for a newer version. To me the code coverage configuration in the "Local.testtesttings" file "caused" the problem. I forgot to update the files that were referenced there.I got this error while building on Team Foundation Server\'s build-service. It turned out I had multiple projects in my solution using different versions of the same library added with Nuget. I removed all old versions with Nuget and added the new one as reference for all.Team Foundation Server puts all dll:s in one directory, and there can only be one dll of a certain name at a time of course.I would like to just add that I was creating a basic MVC4 Project and added DotNetOpenAuth.AspNet via Nuget. This resulted in the same error after I Referenced a missmatching DLL for Microsoft.Web.WebPages.OAuthTo fix it I did a Update-Package and Cleaned solution for a Full Rebuild.THat worked for me and is kind of a lazy way but time is money:-PFigured I\'d throw my answer on the pile, in case it helps someone.  My app.config contains a for npgsql.  Somehow on the user\'s machine, my app.exe.config went missing.  Not sure if it was a silly user, installer glitch, or wacked out anti-virus yet.  Replacing the file solved the issue.In your AssemblyVersion in AssemblyInfo.cs file, use a fixed version number instead of specifying *. The * will change the version number on each compilation. That was the issue for this exception in my case.Manually deleting the old assembly from folder location and then adding the reference to new assemblies might help.In my case the problem was between chair and keyboard :-)Two or more different assemblies wanted to use different version of DotNetOpenAuth lib, that would not be a problem. Furthermore on my local computer a web.config was automatically udpated by nuget:Then I realized that I have forget to copy/deploy the new web.config to the production server. So if you have manual way of deploying web.config, check it is updated. If you have completely different web.config for production server, you have to merge these dependentAssembly section in sync after using nuget.I got the same error...\nIn my case it got resolved as follows:Here\'s my method of fixing this issue.Okay, so in this example, my .dll is definitely 2.0.5022.0  (so the Exception version number is wrong).So, in this example, I would replace this...... with this...Job done !I received this error message due to referencing an assembly that had the same name as the assembly I was building. This compiled but it overwrote the referenced assembly with the current projects assembly - thus causing the error.To fix it I changed the name of the project, and the assembly properties available through right-clicking on the project and choosing \'Properties\'.I had a similar problem when attempted to update one dll of my web-site.This error was occuring, when I simply copied this dll into bin folder over ftp.I resolved this problem by:I faced the same problem while running my unit testcases.\nError clearly states the problem is: when we try to load assembly, the .net assembly loader tries to load its refered assemblies based on its manifest data(refered assembly name, public key token, version). To check manifest data : To solve this, just drag each of project dependent assembly to ILDASM window separately and check which dependent assembly holds manifest data with old assembly version. Just rebuild this dependent assembly and refer it back to your project.I ran into this issue while using an internal package repository.  I had added the main package to the internal repository, but not the dependencies of the package.  Make sure you add all dependencies, dependencies of dependencies, recursive etc to your internal repository as well.