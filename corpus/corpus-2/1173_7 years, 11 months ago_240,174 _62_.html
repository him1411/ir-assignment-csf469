Given the 2 toString() implementations below, which one is preferred:or?More importantly, given we have only 3 properties it might not make a difference, but at what point would you switch from + concat to  StringBuilder?Version 1 is preferable because it is shorter and the compiler will in fact turn it into version 2 - no performance difference whatsoever.More importantly given we have only 3\n  properties it might not make a\n  difference, but at what point do you\n  switch from concat to builder?At the point where you\'re concatenating in a loop - that\'s usually when the compiler can\'t substitute StringBuilder by itself.The key is whether you are writing a single concatenation all in one place or accumulating it over time.For the example you gave, there\'s no point in explicitly using StringBuilder. (Look at the compiled code for your first case.)But if you are building a string e.g. inside a loop, use StringBuilder.To clarify, assuming that hugeArray contains thousands of strings, code like this:is very time- and memory-wasteful compared with:I prefer:...because it\'s short and readable.I would not optimize this for speed unless you use it inside a loop with a very high repeat count and have measured the performance difference.I agree, that if you have to output a lot of parameters, this form can get confusing (like one of the comments say). In this case I\'d switch to a more readable form (perhaps using ToStringBuilder of apache-commons - taken from the answer of matt b) and ignore performance again.In most cases, you won\'t see an actual difference between the two approaches, but it\'s easy to construct a worst case scenario like this one:The output is:The problem is that to += append to a string reconstructs a new string, so it costs something linear to the length of your strings (sum of both).So - to your question:The second approach would be faster, but it\'s less readable and harder to maintain.\nAs I said, in your specific case you would probably not see the difference.I also had clash with my boss on the fact whether to use append or +.As they are using Append(I still cant figure out as they say every time a new object is created).\nSo I thought to do some R&D.Although I love Michael Borgwardt explaination but just wanted to show an explanation if somebody will really need to know in future.and disassembly of above class comes out asFrom the above two codes you can see Michael is right.In each case only one SB object is created.Since Java 1.5, simple one line concatenation with "+" and StringBuilder.append() generate exactly the same bytecode.So for the sake of code readability, use "+".2 exceptions : Using latest version of Java(1.8) the disassembly(javap -c) shows the optimization introduced by compiler. + as well sb.append() will generate very similar code. However, it will be worthwhile inspecting the behaviour if we are using + in a for loop.Adding strings using + in a for loopJava: ByteCode:(for loop excerpt)Adding strings using stringbuilder.appendJava:ByteCdoe:(for loop excerpt)There is a bit of glaring difference though. In first case, where + was used, new StringBuilder is created for each for loop iteration and generated result is stored by doing a toString() call(29 through 41). So you are generating intermediate Strings that your really do not need while using + operator in for loop.Apache Commons-Lang has a ToStringBuilder class which is super easy to use. It does a nice job of both handling the append-logic as well as formatting of how you want your toString to look.Will return output that looks like com.blah.YourClass@abc1321f[a=whatever, b=foo].Or in a more condensed form using chaining:Or if you want to use reflection to include every field of the class:You can also customize the style of the ToString if you want.In Java 9 the version 1 should be faster because it is converted to invokedynamic call. More details can be found in JEP-280:The idea is to replace the entire StringBuilder append dance with a simple invokedynamic call to java.lang.invoke.StringConcatFactory, that will accept the values in the need of concatenation.For performance reasons, the use of += (String concatenation) is discouraged. The reason why is: Java String is an immutable, every time a new concatenation is done a new String is created (the new one has a different fingerprint from the older one already in the String pool ). Creating new strings puts pressure on the GC and slows down the program: object creation is expensive. Below code should make it more practical and clear at the same time. Results for a run are reported below. Not considering the results for 1 concatenation (JIT was not yet doing its job), even for 10 concatenations the performance penalty is relevant; for thousands of concatenations, the difference is huge. Lessons learned from this very quick experiment (easily reproducible with the above code): never use the += to concatenate strings together, even in very basic cases where a few concatenations are needed (as said, creating new strings is expensive anyway and puts pressure on the GC). Make the toString method as readable as you possibly can!The sole exception for this in my book is if you can prove to me that it consumes significant resources :)  (Yes, this means profiling)Also note that the Java 5 compiler generates faster code than the handwritten "StringBuffer" approach used in earlier versions of Java.  If you use "+" this and future enhancements comes for free.Can I point out that if you\'re going to iterate over a collection and use StringBuilder, you may want to check out Apache Commons Lang and StringUtils.join() (in different flavours) ? Regardless of performance, it\'ll save you having to create StringBuilders and for loops for what seems like the millionth time.I compared four different approach to compare the performance. I exactly don\'t know what happens to gc, but the important thing for me is time. Compiler is important factor here.I used jdk1.8.0_45 under window8.1 platform.There seems to be some debate whether using StringBuilder is still needed with current compilers. So I thought I\'ll give my 2 cents of experience. I have a JDBC result set of 10k records (yes, I need all of them in one batch.) Using the + operator takes about 5 minutes on my machine with Java 1.8. Using stringBuilder.append("") takes less than a second for the same query. So the difference is huge. Inside a loop StringBuilder is much faster. I think we should go with StringBuilder append approach.\nReason is The String concatenate will create a new string object each time (As String is immutable object) , so it will create 3 objects.With String builder only one object will created[StringBuilder is muttable] and the further string gets appended to it.For simple strings like that I prefer to use In order, I would say the preferred method of constructing a string is using StringBuilder, String#concat(), then the overloaded + operator.  StringBuilder is a significant performance increase when working large strings just like using the + operator is a large decrease in performance (exponentially large decrease as the String size increases).  The one problem with using .concat() is that it can throw NullPointerExceptions.