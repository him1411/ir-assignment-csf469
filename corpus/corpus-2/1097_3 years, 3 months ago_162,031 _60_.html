In Objective C, I can use #pragma mark to mark sections of my code in the symbol navigator. Since this is a C preprocessor command, it\'s not available in Swift. Is there a stand-in for this in Swift, or do I have to use ugly comments?You can use // MARK:Historical, Prior to Xcode 6 Beta 4Just talked to an Engineer here at WWDC, and the current beta of Xcode doesn\'t implement the // MARK: style yet, but I\'m told future versions will. It was also suggested that making liberal use of class extensions might be a better practice anyway. Since extensions can implement protocols, you can e.g. put all of your table view delegate methods in an extension and group your code at a more semantic level than #pragma mark is capable of. For those who are interested in using extensions vs pragma marks (as mentioned in the first comment), here is how to implement it from a Swift Engineer: It\'s also not necessarily the best practice, but this is how you do it if you like. Up to Xcode 5 the preprocessor directive #pragma mark existed.From Xcode 6 on, you have to use // MARK:These preprocessor features allow to bring some structure to the function drop down box of the source code editor.some examples :-> will be preceded by a horizontal divider-> puts \'your text goes here\' in bold in the drop down list-> puts \'your text goes here\' in bold in the drop down list, preceded by a horizontal dividerupdate : added screenshot \'cause some people still seem to have issues with this :Pragma mark - [SOME TEXT HERE] was used in Objective-C to group several function together by line separating.In Swift you can achieve this using MARK, TODO OR FIXMEi. MARK : //MARK: viewDidLoad This will create a horizontal line with functions grouped under viewDidLoad(shown in screenshot 1)ii. TODO : //TODO: - viewDidLoadThis will group function under TODO: - viewDidLoad category (shown in screenshot 2)iii. FIXME : //FIXME - viewDidLoad This will group function under FIXME: - viewDidLoad category (shown in screenshot 3)In Objective-C code Xcode detects comments like // MARK: - foo which is a bit more portable than #pragma. But these do not seem to be picked up, too (yet?).Edit: Fixed in Xcode 6 beta 4.I think Extensions is a better way instead of #pragma mark.The Code before using Extensions:The code after using Extensions:Confirmed with an Apple Engineer in the Swift lab this morning at WWDC that there currently aren\'t any #pragma or equivalent at the moment, they consider this a bug, and it will arrive soon, so I am guessing beta 2, I hope.Anyway, it\'s on it\'s way. Xcode now supports //MARK:, //TODO: and //FIXME landmarks to annotate your code and \nlists them in the jump barXcode 8 now handles it as followed and shows up like this in the method dropdown:Add a line between the colon and your description to insert a separator line. This helps to organize your code even more. The code and screenshot above make use of the MARK comment with a line included.This only works with the MARK comment.UseorThis will give a line above pragma mark, making it more readable.For ease just add to your code snippets.Alternate way -Use it in this wayThis will not only add mark(just like pragma mark) but also segregate the code nicely.//MARK: does not seem to work for me in Xcode 6.3.2.  However, this is what I did to get it to work:1) Code:2) In the jump bar nothing appears to change when adding the //MARK: comment.  However, if I click on the rightmost name in the jump bar, in my case it says MainWindowController(with a leading C icon), then a popup window will display showing the effects of the //MARK: comment, namely a heading that says "My cool methods":3) I also notice that if I click on one of the methods in my code, then the method becomes the rightmost entry in the jump bar.  In order to get MainWindowController(with a leading C icon) to be the rightmost entry in the jump bar, I have to click on the whitespace above my methods.Professional programer must be use this tag for good code. \nIt is also good for team work.  Apple states in the latest version of Building Cocoa Apps, The Swift compiler does not include a preprocessor. Instead, it takes\n  advantage of compile-time attributes, build configurations, and\n  language features to accomplish the same functionality. For this\n  reason, preprocessor directives are not imported in Swift.The # character appears to still be how you work with various build configurations and things like that, but it looks like they\'re trying to cut back on your need for most preprocessing in the vein of pragma and forward you to other language features altogether.  Perhaps this is to aid in the operation of the Playgrounds and the REPL behaving as close as possible to the fully compiled code.