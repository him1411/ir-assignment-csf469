Is there an efficient way to tell if a DOM element (in an HTML document) is currently visible (appears in the viewport)?(The question regards Firefox)Update: Time marches on and so have our browsers. This technique is no longer recommended and you should use @Dan\'s solution below (https://stackoverflow.com/a/7557433/5628) if you do not need to support IE<7.Original solution (now outdated):This will check if the element is entirely visible in the current viewport:You could modify this simply to determine if any part of the element is visible in the viewport:Now most browsers support getBoundingClientRect method, which has become the best practice. Using an old answer is very slow, not accurate and has several bugs.The solution selected as correct is almost never precise. You can read more about its bugs.This solution was tested on IE7+, iOS5+ Safari, Android2+, Blackberry, Opera Mobile, and IE Mobile 10.You can be sure that the function given above returns correct answer at the moment of time when it is called, but what about tracking element\'s visibility as an event?Place the following code at the bottom of your <body> tag:If you do any DOM modifications, they can change your element\'s visibility of course.Guidelines and common pitfalls:Maybe you need to track page zoom / mobile device pinch? jQuery should handle zoom/pinch cross browser, otherwise first or second link should help you.  If you modify DOM, it can affect the element\'s visibility. You should take control over that and call handler() manually. Unfortunately, we have no cross browser onrepaint event. On the other hand that allows us to make optimizations and perform re-check only on DOM modifications that can change element\'s visibility.Never Ever use it inside jQuery $(document).ready() only, because there is no warranty CSS has been applied in this moment. Your code can work locally with your CSS on hard drive, but once put on remote server it will fail.After DOMContentLoaded is fired, styles are applied, but the images are not loaded yet. So, we should add window.onload event listener.We can\'t catch zoom/pinch event yet.The last resort could be the following code:You can use awesome feature pageVisibiliy HTML5 API if you care if the tab with your web page is active and visible.TODO: this method does not handle two situations:using overflow-scroll in element\'s containertry something new https://pawelgrzybek.com/the-intersection-observer-api-explained/There are some issues with the answer provided by Dan that might make it an unsuitable approach for some situations.  Some of these issues are pointed out in his answer near the bottom, that his code will give false positives for elements that are:These limitations are demonstrated in the following results of a simple test:Here\'s a solution to those problems, with the test result below and an explanation of some parts of the code.Passing test: http://jsfiddle.net/AndyE/cAY8c/And the result:This method is not without its own limitations, however. For instance, an element being tested with a lower z-index than another element at the same location would be identified as hidden even if the element in front doesn\'t actually hide any part of it.  Still, this method has its uses in some cases that Dan\'s solution doesn\'t cover.Both element.getBoundingClientRect() and document.elementFromPoint() are part of the CSSOM Working Draft specification and are supported in at least IE 6 and later and most desktop browsers for a long time (albeit, not perfectly). See Quirksmode on these functions for more information.contains() is used to see if the element returned by document.elementFromPoint() is a child node of the element we\'re testing for visibility.  It also returns true if the element returned is the same element.  This just makes the check more robust.  It\'s supported in all major browsers, Firefox 9.0 being the last of them to add it.  For older Firefox support, check this answer\'s history.If you want to test more points around the element for visibility\xe2\x80\x95ie, to make sure the element isn\'t covered by more than, say, 50%\xe2\x80\x95it wouldn\'t take much to adjust the last part of the answer.  However, be aware that it would probably be very slow if you checked every pixel to make sure it was 100% visible.I tried Dan\'s answer but the algebra used to determine the bounds is incorrect. ryanve\'s answer is closer, but the element being tested should be inside the viewport by at least 1 pixel, so try this function:There is jQuery plugin called inview that does the jobAs a public service:\nDan\'s answer with the correct calculations (element can be > window, especially on mobile phone screens), and correct jQuery testing,  as well as adding isElementPartiallyInViewport:By the way, the difference between window.innerWidth and document.documentElement.clientWidth is that clientWidth/clientHeight doesn\'t include the scrollbar, while window.innerWidth/Height does.Test-caseSee the source of verge, which uses getBoundingClientRect. It\'s like:Returns true if any part of the element is in the viewport.my shorter and faster version.add jsFiddle as required\nhttps://jsfiddle.net/on1g619L/1/I found it troubling that there wasn\'t a jQuery centric version of the functionality available. When i came across Dan\'s solution i spied the opportunity to provide something for folks who like to program in the jQuery OO style. Be sure to scroll up and leave an upvote on Dan\'s code. Its nice and snappy and works like a charm for me.bada bing bada boomusagehttp://www.appelsiini.net/projects/viewportGreat easy to use plugin, simply use :in-viewportI find that the accepted answer here is overly complicated for most use cases. This code does the job well (using JQuery) and differentiates between fully visible and partially visible elements. Depends what you mean by visible. If you mean is it currently shown on the page, given the scroll position, you can calculate it based on the elements y offset and the current scroll position.Based on @dan\'s solution above (https://stackoverflow.com/a/7557433/5628), I had a go at cleaning up implementation so that using it multiple times on the same page is easier:The way I\'m using it is that when the element scrolls into view, I\'m adding a class that triggers a css keyframe animation. It\'s pretty straightforward and works especially well when you\'ve got like 10+ things to conditionally animate on a page.Hope it helps!I think this is a more functional way to do it.\nThe Dan\'s answer do not work in recursive context.This function solve the problem when your element is inside others scrollable divs by testing any levels recursively upper to the HTML tag, and stops in the first false.All answers I\'ve encountered here only check if the element is positioned inside the current viewport. But that doesn\'t mean that it is visible.\nWhat if the given element is inside a div with overflowing content, and it is scrolled out of view?To solve that, you\'d have to check if the element is contained by all parents.\nMy solution does exactly that:It also allows you to specify how much of the element has to be visible.This solution ignored the fact that elements may not be visible due to other facts, like opacity: 0. I have tested this solution in Chrome and Internet Explorer 11.Here\'s my solution, it will work if an element is hidden inside a scroll-able container. Here\'s a demo (try re-sizing the window to)I only needed to check if it\'s visible in the Y axis (for a scrolling ajax load more records feature). A better solution:I had the same question and figured it out by using getBoundingClientRect(). This code is completely \'generic\' and only has to be written once for it to work (you don\'t have to write it out for each element that you want to know is in the viewport). This code only checks to see if it is vertically in the viewport not horizontally. In this case, the variable (array) \'elements\' holds all the elements that you are checking to be vertically in the viewport, so grab any elements you want anywhere and store them there. The \'for loop\', loops through each element and checks to see if it is vertically in the viewport. This code executes every time the user scrolls! If the getBoudingClientRect().top is less than 3/4 the viewport (the element is one quarter in the viewport), it registers as \'in the viewport\'. Since the code is generic, you will want to know \'which\' element is in the viewport. To find that out, you can determine it by custom attribute, node name, id, class name, and more. Here is my code (Tell me if it doesn\'t work, it has been tested in IE 11, FireFox 40.0.3, Chrome Version 45.0.2454.85 m, Opera 31.0.1889.174, and Edge with Windows 10, [not Safari yet])...Hope this helps someone :-)The easy and small solution that has worked for me.Example You want to see if the element is visible in parent element that has overflow scroll.Checks if element is at least partially in view (vertical dimension):I use this function (it only checks if the y is inscreen since most of the time the x is not needed)  For a similar challenge i really enjoyed this gist which exposes a polyfill for scrollIntoViewIfNeeded().All the necessary Kung Fu needed to answer is within this block:this refers to the element that you want to know if it is i.e. overTop or overBottom - just should get the drift...I wanted a jQuery solution which is simple (only checks for vertical scroll), so I modified Adam Rehals code. This example clicks all buttons within the viewport, checking 5 times per second. (the buttons become disabled when clicked btw)