There are three assembly version attributes. What are differences? Is it ok if I use AssemblyVersion and ignore the rest?MSDN says:AssemblyVersion:Specifies the version of the assembly being attributed. AssemblyFileVersion:Instructs a compiler to use a specific version number for the Win32 file version resource. The Win32 file version is not required to be the same as the assembly\'s version number. AssemblyInformationalVersion:Defines additional version information for an assembly manifest. This is follow up to What are the best practices for using Assembly Attributes?AssemblyVersionWhere other assemblies that reference your assembly will look. If this number changes, other assemblies have to update their references to your assembly! The AssemblyVersion is required.I use the format: major.minor. This would result in:AssemblyFileVersionUsed for deployment. You can increase this number for every deployment. It is used by setup programs. Use it to mark assemblies that have the same AssemblyVersion, but are generated from different builds.In Windows, it can be viewed in the file properties.If possible, let it be generated by MSBuild. The AssemblyFileVersion is optional. If not given, the AssemblyVersion is used.I use the format: major.minor.revision.build, where I use revision for development stage (Alpha, Beta, RC and RTM),  service packs and hot fixes. This would result in:AssemblyInformationalVersionThe Product version of the assembly. This is the version you would use when talking to customers or for display on your website. This version can be a string, like \'1.0 Release Candidate\'. Unfortunately, when you use a string, it will generate a false warning --  already reported to Microsoft (fixed in VS2010). Also the Code Analysis will complain about it (CA2243) -- reported to Microsoft (not fixed in VS2013). The AssemblyInformationalVersion is optional. If not given, the AssemblyVersion is used.I use the format: major.minor [revision as string]. This would result in:Here is a blog post I recently wrote that delves into the details of assembly versioning...Versioning of assemblies in .NET can be a confusing prospect given that there are currently at least three ways to specify a version for your assembly.Here are the three main version-related assembly attributes:By convention, the four parts of the version are referred to as the Major Version, Minor Version, Build, and Revision.Typically you\xe2\x80\x99ll manually set the Major and Minor AssemblyFileVersion to reflect the version of the assembly, then increment the Build and/or Revision every time your build system compiles the assembly. The AssemblyFileVersion should allow you to uniquely identify a build of the assembly, so that you can use it as a starting point for debugging any problems.On my current project we have the build server encode the changelist number from our source control repository into the Build and Revision parts of the AssemblyFileVersion. This allows us to map directly from an assembly to its source code, for any assembly generated by the build server (without having to use labels or branches in source control, or manually keeping any records of released versions).This version number is stored in the Win32 version resource and can be seen when viewing the Windows Explorer property pages for the assembly.The CLR does not care about nor examine the AssemblyFileVersion.The AssemblyInformationalVersion is intended to allow coherent versioning of the entire product, which may consist of many assemblies that are independently versioned, perhaps with differing versioning policies, and potentially developed by disparate teams.\xe2\x80\x9cFor example, version 2.0 of a product\n  might contain several assemblies; one\n  of these assemblies is marked as\n  version 1.0 since it\xe2\x80\x99s a new assembly\n  that didn\xe2\x80\x99t ship in version 1.0 of the\n  same product. Typically, you set the\n  major and minor parts of this version\n  number to represent the public version\n  of your product. Then you increment\n  the build and revision parts each time\n  you package a complete product with\n  all its assemblies.\xe2\x80\x9d\n             \xe2\x80\x94 Jeffrey Richter, CLR via C# (Second Edition) p. 57The CLR does not care about nor examine the AssemblyInformationalVersion.The AssemblyVersion is used by the CLR to bind to strongly named assemblies. It is stored in the AssemblyDef manifest metadata table of the built assembly, and in the AssemblyRef table of any assembly that references it.This is very important, because it means that when you reference a strongly named assembly, you are tightly bound to a specific AssemblyVersion of that assembly. The entire AssemblyVersion must be an exact match for the binding to succeed. For example, if you reference version 1.0.0.0 of a strongly named assembly at build-time, but only version 1.0.0.1 of that assembly is available at runtime, binding will fail! (You will then have to work around this using Assembly Binding Redirection.)There is a little confusion around whether the entire AssemblyVersion has to be an exact match in order for an assembly to be loaded. Some people are under the false belief that only the Major and Minor parts of the AssemblyVersion have to match in order for binding to succeed. This is a sensible assumption, however it is ultimately incorrect (as of .NET 3.5), and it\xe2\x80\x99s trivial to verify this for your version of the CLR. Just execute this sample code.On my machine the second assembly load fails, and the last two lines of the fusion log make it perfectly clear why:I think the source of this confusion is probably because Microsoft originally intended to be a little more lenient on this strict matching of the full AssemblyVersion, by matching only on the Major and Minor version parts:\xe2\x80\x9cWhen loading an assembly, the CLR will automatically find the latest\n  installed servicing version that\n  matches the major/minor version of the\n  assembly being requested.\xe2\x80\x9d\n              \xe2\x80\x94 Jeffrey Richter, CLR via C# (Second Edition) p. 56This was the behaviour in Beta 1 of the 1.0 CLR, however this feature was removed before the 1.0 release, and hasn\xe2\x80\x99t managed to re-surface in .NET 2.0:\xe2\x80\x9cNote: I have just described how you\n  should think of version numbers.\n  Unfortunately, the CLR doesn\xe2\x80\x99t treat\n  version numbers this way. [In .NET\n  2.0], the CLR treats a version number as an opaque value, and if an assembly\n  depends on version 1.2.3.4 of another\n  assembly, the CLR tries to load\n  version 1.2.3.4 only (unless a binding\n  redirection is in place). However,\n  Microsoft has plans to change the\n  CLR\xe2\x80\x99s loader in a future version so\n  that it loads the latest\n  build/revision for a given major/minor\n  version of an assembly. For example,\n  on a future version of the CLR, if the\n  loader is trying to find version\n  1.2.3.4 of an assembly and version 1.2.5.0 exists, the loader with automatically pick up the latest\n  servicing version. This will be a very\n  welcome change to the CLR\xe2\x80\x99s loader \xe2\x80\x94 I\n  for one can\xe2\x80\x99t wait.\xe2\x80\x9d\n              \xe2\x80\x94 Jeffrey Richter, CLR via C# (Second Edition) p. 164 (Emphasis\n  mine)As this change still hasn\xe2\x80\x99t been implemented, I think it\xe2\x80\x99s safe to assume that Microsoft had back-tracked on this intent, and it is perhaps too late to change this now. I tried to search around the web to find out what happened with these plans, but I couldn\xe2\x80\x99t find any answers. I still wanted to get to the bottom of it.So I emailed Jeff Richter and asked him directly \xe2\x80\x94 I figured if anyone knew what happened, it would be him.He replied  within 12 hours, on a Saturday morning no less, and clarified that the .NET 1.0 Beta 1 loader did implement this \xe2\x80\x98automatic roll-forward\xe2\x80\x99 mechanism of picking up the latest available Build and Revision of an assembly, but this behaviour was reverted before .NET 1.0 shipped. It was later intended to revive this but it didn\xe2\x80\x99t make it in before the CLR 2.0 shipped. Then came Silverlight, which took priority for the CLR team, so this functionality got delayed further. In the meantime, most of the people who were around in the days of CLR 1.0 Beta 1 have since moved on, so it\xe2\x80\x99s unlikely that this will see the light of day, despite all the hard work that had already been put into it.The current behaviour, it seems, is here to stay.It is also worth noting from my discussion with Jeff that AssemblyFileVersion was only added after the removal of the \xe2\x80\x98automatic roll-forward\xe2\x80\x99 mechanism \xe2\x80\x94 because after 1.0 Beta 1, any change to the AssemblyVersion was a breaking change for your customers, there was then nowhere to safely store your build number. AssemblyFileVersion is that safe haven, since it\xe2\x80\x99s never automatically examined by the CLR. Maybe it\xe2\x80\x99s clearer that way, having two separate version numbers, with separate meanings, rather than trying to make that separation between the Major/Minor (breaking) and the Build/Revision (non-breaking) parts of the AssemblyVersion.The moral is that if you\xe2\x80\x99re shipping assemblies that other developers are going to be referencing, you need to be extremely careful about when you do (and don\xe2\x80\x99t) change the AssemblyVersion of those assemblies. Any changes to the AssemblyVersion will mean that application developers will either have to re-compile against the new version (to update those AssemblyRef entries) or use assembly binding redirects to manually override the binding.Just take another look at the version attributes on mscorlib:Note that it\xe2\x80\x99s the AssemblyFileVersion that contains all the interesting servicing information (it\xe2\x80\x99s the Revision part of this version that tells you what  Service Pack you\xe2\x80\x99re on), meanwhile the AssemblyVersion is fixed at a boring old 2.0.0.0. Any change to the AssemblyVersion would force every .NET application referencing mscorlib.dll to re-compile against the new version!AssemblyVersion pretty much stays internal to .NET, while AssemblyFileVersion is what Windows sees. If you go to the properties of an assembly sitting in a directory and switch to the version tab, the AssemblyFileVersion is what you\'ll see up top. If you sort files by version, this is what\'s used by Explorer.The AssemblyInformationalVersion maps to the "Product Version" and is meant to be purely "human-used".AssemblyVersion is certainly the most important, but I wouldn\'t skip AssemblyFileVersion, either. If you don\'t provide AssemblyInformationalVersion, the compiler adds it for you by stripping off the "revision" piece of your version number and leaving the major.minor.build.AssemblyInformationalVersion and AssemblyFileVersion are displayed when you view the "Version" information on a file through Windows Explorer by viewing the file properties. These attributes actually get compiled in to a VERSION_INFO resource that is created by the compiler.AssemblyInformationVersion is the "Product version" value. AssemblyFileVersion is the "File version" value.The AssemblyVersion is specific to .NET assemblies and is used by the .NET assembly loader to know which version of an assembly to load/bind at runtime.Out of these, the only one that is absolutely required by .NET is the AssemblyVersion attribute. Unfortunately it can also cause the most problems when it changes indiscriminately, especially if you are strong naming your assemblies.It\'s worth noting some other things:1)  As shown in Windows Explorer Properties dialog for the generated assembly file, there are two places called "File version".  The one seen in the header of the dialog shows the AssemblyVersion, not the AssemblyFileVersion.In the Other version information section, there is another element called "File Version".  This is where you can see what was entered as the AssemblyFileVersion.2)  AssemblyFileVersion is just plain text.  It doesn\'t have to conform to the numbering scheme restrictions that AssemblyVersion does (<build> < 65K, e.g.).  It can be 3.2.<release tag text>.<datetime>, if you like.  Your build system will have to fill in the tokens.Moreover, it is not subject to the wildcard replacement that AssemblyVersion is.  If you just have a value of "3.0.1.*" in the AssemblyInfo.cs, that is exactly what will show in the Other version information->File Version element.3)  I don\'t know the impact upon an installer of using something other than numeric file version numbers, though.To keep this question current it is worth highlighting that AssemblyInformationalVersion is used by NuGet and reflects the package version including any pre-release suffix.For example an AssemblyVersion of 1.0.3.* packaged with the asp.net core dotnet-cliProduces a package with version 1.0.3-ci-7 which you can inspect with reflection using:When a assembly\' s AssemblyVersion is changed,\nIf it has strong name, the referencing assemblies need to be recompiled, otherwise the assembly does not load!\nIf it does not have strong name, if not explicitly added to project file, it will not be copied to output directory when build so you may miss depending assemblies, especially after cleaning the output directory. 