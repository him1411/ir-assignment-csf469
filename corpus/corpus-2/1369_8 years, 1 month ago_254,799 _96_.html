Let\'s say, you have a bash alias like:which works fine.However:won\'t work, and neither will:So how do you end up matching up opening and closing quotes inside a string once you have escaped quotes?seems ungainly although it would represent the same string if you\'re allowed to concatenate them like that.If you really want to use single quotes in the outermost layer, remember that you can glue both kinds of quotation. Example:Explanation of how \'"\'"\' is interpreted as just \':If you do not place any whitespaces between (1) and (2), or between (4) and (5), the shell will interpret that string as a one long word.I always just replace each embedded single quote with the sequence: \'\\\'\' (that is: quote backslash quote quote) which closes the string, appends an escaped single quote and reopens the string.  I often whip up a "quotify" function in my Perl scripts to do this for me.  The steps would be:This pretty much takes care of all cases.Life gets more fun when you introduce eval into your shell-scripts. You essentially have to re-quotify everything again!For example, create a Perl script called quotify containing the above statements:then use it to generate a correctly-quoted string:result:which can then be copy/pasted into the alias command:(If you need to insert the command into an eval, run the quotify again:result:which can be copy/pasted into an eval:For Bash this should work:From man bash:Words of the form $\'string\' are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard. Backslash  escape sequences, if present, are decoded as follows:See example:See Quotes and escaping: ANSI C like strings on bash-hackers.org wiki for more details.I don\'t see the entry on his blog (link pls?) but according to the gnu reference manual:Enclosing characters in single quotes\n  (\xe2\x80\x98\'\xe2\x80\x99) preserves the literal value of\n  each character within the quotes. A\n  single quote may not occur between\n  single quotes, even when preceded by a\n  backslash.so bash won\'t understand:alias x=\'y \\\'z \'however, you can do this if you surround with double quotes:I can confirm that using \'\\\'\' for a single quote inside a single-quoted string does work in Bash, and it can be explained in the same way as the "gluing" argument from earlier in the thread. Suppose we have a quoted string: \'A \'\\\'\'B\'\\\'\' C\' (all quotes here are single quotes). If it is passed to echo, it prints the following: A \'B\' C.\nIn each \'\\\'\' the first quote closes the current single-quoted string, the following \\\' glues a single quote to the previous string (\\\' is a way to specify a single quote without starting a quoted string), and the last quote opens another single-quoted string.Simple example of escaping quotes in shell:It\'s done by finishing already opened one (\'), placing escaped one (\\\'), then opening another one (\'). This syntax works for all commands. It\'s very similar approach to the 1st answer.I\'m not specifically addressing the quoting issue because, well, sometimes, it\'s just reasonable to consider an alternative approach.which you can then call as:the idea being that you can now alias this without concern for quotes:or, if you need to include the # in all calls for some reason:which you can then call as:then, of course, an alias is:(oops, i guess i kind of did address the quoting :)I just use shell codes.. e.g. \\x27 or \\\\x22 as applicable. No hassle, ever really.Both versions are working, either with concatenation by using the escaped single quote character (\\\'), or with concatenation by enclosing the single quote character within double quotes ("\'").The author of the question did not notice that there was an extra single quote (\') at the end of his last escaping attempt:As you can see in the previous nice piece of ASCII art, the last escaped single quote (\\\') is followed by an unnecessary single quote (\'). Using a syntax-highlighter like the one present in Notepad++ can prove very helpful.The same is true for another example like the following one:These two beautiful instances of aliases show in a very intricate and obfuscated way how a file can be lined down. That is, from a file with a lot of lines you get only one line with commas and spaces between the contents of the previous lines. In order to make sense of the previous comment, the following is an example:IMHO the real answer is that you can\'t escape single-quotes within single-quoted strings.  Its impossible. If we presume we are using bash.From bash manual...You need to use one of the other string escape mechanisms  " or \\There is nothing magic about alias that demands it use single quotes. Both the following work in bash.The latter is using \\ to escape the space character.There is also nothing magic about #111111 that requires single quotes.The following options achieves the same result the other two options, in that the rxvt alias works as expected.You can also escape the troublesome # directlySince one cannot put single quotes within single quoted strings, the simplest and most readable option is to use a HEREDOC stringIn the code above, the HEREDOC is sent to the cat command and the output of that is assigned to a variable via the command substitution notation $(..)Putting a single quote around the HEREDOC is needed since it is within a $()In the given example, simply used double quotes instead of single quotes as outer escape mechanism:This approach is suited for many cases where you just want to pass a fixed string to a command: Just check how the shell will interpret the double-quoted string through an echo, and escape characters with backslash if necessary.In the example, you\'d see that double quotes are sufficient to protect the string:Most of these answers hit on the specific case you\'re asking about. There is a general approach that a friend and I have developed that allows for arbitrary quoting in case you need to quote bash commands through multiple layers of shell expansion, e.g., through ssh, su -c, bash -c, etc. There is one core primitive you need, here in native bash:This does exactly what it says: it shell-quotes each argument individually (after bash expansion, of course):It does the obvious thing for one layer of expansion:(Note that the double quotes around $(quote_args ...) are necessary to make the result into a single argument to bash -c.) And it can be used more generally to quote properly through multiple layers of expansion:The above example:That\'s the idea in a nutshell. You can do some pretty complicated stuff with this, but you have to be careful about order of evaluation and about which substrings are quoted. For instance, the following do the wrong things (for some definition of "wrong"):In the first example, bash immediately expands quote_args cd /; pwd 1>&2 into two separate commands, quote_args cd / and pwd 1>&2, so the CWD is still /tmp when the pwd command is executed. The second example illustrates a similar problem for globbing. Indeed, the same basic problem occurs with all bash expansions. The problem here is that a command substitution isn\'t a function call: it\'s literally evaluating one bash script and using its output as part of another bash script.If you try to simply escape the shell operators, you\'ll fail because the resulting string passed to bash -c is just a sequence of individually-quoted strings that aren\'t then interpreted as operators, which is easy to see if you echo the string that would have been passed to bash:The problem here is that you\'re over-quoting. What you need is for the operators to be unquoted as input to the enclosing bash -c, which means they need to be outside the $(quote_args ...) command substitution.Consequently, what you need to do in the most general sense is to shell-quote each word of the command not intended to be expanded at the time of command substitution separately, and not apply any extra quoting to the shell operators:Once you\'ve done this, the entire string is fair game for further quoting to arbitrary levels of evaluation:etc.These examples may seem overwrought given that words like success, sbin, and pwd don\'t need to be shell-quoted, but the key point to remember when writing a script taking arbitrary input is that you want to quote everything you\'re not absolutely sure doesn\'t need quoting, because you never know when a user will throw in a Robert\'; rm -rf /.To better understand what is going on under the covers, you can play around with two small helper functions:that will enumerate each argument to a command before executing it:Here is an elaboration on The One True Answer referenced above:Sometimes I will be downloading using rsync over ssh and have to escape a filename with a \' in it TWICE! (OMG!) Once for bash and once for ssh. The same principle of alternating quotation delimiters is at work here.For example, let\'s say we want to get: Louis Theroux\'s LA Stories ...And behold! You wind up with this:which is an awful lot of work for one little \' -- but there you goAnother way to fix the problem of too many layers of nested quotation:You are trying to cram too much into too tiny a space, so use a bash function.The problem is you are trying to have too many levels of nesting, and the basic alias technology is not powerful enough to accommodate.  Use a bash function like this to make it so the single, double quotes back ticks and passed in parameters are all handled normally as we would expect:Then you can use your $1 and $2 variables and single, double quotes and back ticks without worrying about the alias function wrecking their integrity.This program prints:This function:allows quoting of \' inside \'. Use as this:If the line to quote gets more complex, like double quotes mixed with single quotes, it may become quite tricky to get the string to quote inside a variable. When such cases show up, write the exact line that you need to quote inside an script (similar to this).Will output:All correctly quoted strings inside single quotes.Here is another solution. This function will take a single argument and appropriately quote it using the single-quote character, just as the voted answer above explains:So, you can use it this way:If you\'re generating the shell string within Python 2 or Python 3, the following may help to quote the arguments:This will output: