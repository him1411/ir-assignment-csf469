I am trying to convert an ISO 8601 formatted String to a java.util.Date. I found the pattern "yyyy-MM-dd\'T\'HH:mm:ssZ" to be ISO8601-compliant if used with a Locale (compare sample).\nHowever, using the java.text.SimpleDateFormat, I cannot convert the correctly formatted String "2010-01-01T12:00:00+01:00". I have to convert it first to "2010-01-01T12:00:00+0100", without the colon. \nSo, the current solution iswhich obviously isn\'t that nice. Am I missing something or is there a better solution?answerThanks to JuanZe\'s comment, I found the Joda-Time magic, it is also described here.\nSo, the solution isOr more simply, use the default parser via the constructor:To me, this is nice.Unfortunately, the time zone formats available to SimpleDateFormat (Java 6 and earlier) are not ISO 8601 compliant. SimpleDateFormat understands time zone strings like "GMT+01:00" or "+0100", the latter according to RFC # 822.Even if Java 7 added support for time zone descriptors according to ISO 8601, SimpleDateFormat is still not able to properly parse a complete date string, as it has no support for optional parts.Reformatting your input string using regexp is certainly one possibility, but the replacement rules are not as simple as in your question:The easier solution is possibly to use the data type converter in JAXB, since JAXB must be able to parse ISO8601 date string according to the XML Schema specification. javax.xml.bind.DatatypeConverter.parseDateTime("2010-01-01T12:00:00Z") will give you a Calendar object and you can simply use getTime() on it, if you need a Date object.You could probably use Joda-Time as well, but I don\'t know why you should bother with that.Okay, this question is already answered, but I\'ll drop my answer anyway. It might help someone.I\'ve been looking for a solution for Android (API 7).Ended up implementing this simple class. It covers only the most common form of ISO 8601 strings, but this should be enough in some cases (when you\'re quite sure that the input will be in this format).Performance note: I instantiate new SimpleDateFormat every time as means to avoid a bug in Android 2.1. If you\'re as astonished as I was, see this riddle. For other Java engines, you may cache the instance in a private static field (using ThreadLocal, to be thread safe).The way that is blessed by Java 7 documentation:You can find more examples in section Examples at SimpleDateFormat javadoc.The Jackson-databind library also has ISO8601DateFormat class that does that (actual implementation in ISO8601Utils.The java.time API (built into Java 8 and later), makes this a little easier.If you know the input is in UTC, such as the Z (for Zulu) on the end, the Instant class can parse.If your input may be another offset-from-UTC values rather than UTC indicated by the Z (Zulu) on the end, use the OffsetDateTime class to parse. Then extract an Instant, and  convert to a java.util.Date by calling from.For Java version 7You can follow Oracle documentation: \nhttp://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.htmlX - is used for ISO 8601 time zoneThe DatatypeConverter solution doesn\'t work in all VMs. The following works for me:I\'ve found that joda does not work out of the box (specifically for the example I gave above with the timezone on a date, which should be valid)UPDATE: The Joda-Time project is now in maintenance mode, with the team advising migration to the java.time classes. Skip to Using java.time section below.The answer embedded into the question, using Joda-Time 2.3, is correct but needlessly long and complicated. The DateTime class constructor takes a String argument in various ISO 8601 formats. So no need for the calls to parse methods. You can do it in a single line of code.The Question\xe2\x80\x99s embedded answer ignores the crucial issue of time zone. If you do not specify otherwise, the JVM\xe2\x80\x99s current default time zone is implicitly assigned to the new DateTime object. Remember that the JVM\xe2\x80\x99s current default time zone can change at any time by any code in any thread in the JVM. The default time zone may also be different when run on other machines.Better to specify your desired/expected time zone. If you truly want the default, explicitly call getDefault to self-document your intent.The question failed to address time zones. So here is example code in variations for different time zone possibilities.Dump to console\xe2\x80\xa6When run\xe2\x80\xa6The new java.time package in Java 8 and later was inspired by Joda-Time. The OffsetDateTime class represents a moment on the timeline with an offset-from-UTC but not a time zone.Calling toString generates a string in standard ISO 8601 format:2010-01-01T12:00+01:00To see the same value through the lens of UTC, extract an Instant or adjust the offset from +01:00 to 00:00.\xe2\x80\xa6or\xe2\x80\xa6Adjust into a time zone if desired. A time zone is a history of offset-from-UTC values for a region, with a set of rules for handling anomalies such as Daylight Saving Time (DST). So apply a time zone rather than a mere offset whenever possible.The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, & SimpleDateFormat.The Joda-Time project, now in maintenance mode, advises migration to the java.time classes.To learn more, see the Oracle Tutorial. And search Stack Overflow for many examples and explanations. Specification is JSR 310.Where to obtain the java.time classes? The ThreeTen-Extra project extends java.time with additional classes. This project is a proving ground for possible future additions to java.time. You may find some useful classes here such as Interval, YearWeek, YearQuarter, and more.I think we should use for Date 2010-01-01T12:00:00ZAnother very simple way to parse ISO8601 timestamps is to use  org.apache.commons.lang.time.DateUtils:Note that in Java 8, you can use the java.time.ZonedDateTime class and its static parse(CharSequence text) method.I faced the same problem and solved it by the following code .Earlier I was using\nSimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSSZ", Locale.getDefault());But later i found the main cause of the exception was the yyyy-MM-dd\'T\'HH:mm:ss.SSSZ ,So i used SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", Locale.getDefault()); It worked fine for me .Also you can use the following class - Link to the Java Doc - Hierarchy For Package org.springframework.extensions.surf.maven.plugin.utilApache Jackrabbit uses the ISO 8601 format for persisting dates, and there is a helper class to parse them:org.apache.jackrabbit.util.ISO8601Comes with jackrabbit-jcr-commons.SimpleDateFormat for JAVA 1.7 has a cool pattern for ISO 8601 format.Class SimpleDateFormatHere is what I did:As others have mentioned Android does not have a good way to support parsing/formatting ISO 8601 dates using classes included in the SDK.  I have written this code multiple times so I finally created a Gist that includes a DateUtils class that supports formatting and parsing ISO 8601 and RFC 1123 dates.  The Gist also includes a test case showing what it supports.https://gist.github.com/mraccola/702330625fad8eebe7d3Do it like this:Here is the output:Wed Oct 19 15:15:36 CST 2016The workaround for Java 7+ is using SimpleDateFormat:\nDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSSX", Locale.US); This code can parse ISO8601 format like:  But on Java6, SimpleDateFormat doesn\'t understand X character and will throw\nIllegalArgumentException: Unknown pattern character \'X\'\nWe need to normalize ISO8601 date to the format readable in Java 6 with SimpleDateFormat.Method above to replace [Z with +0000] or [+01:00 with +0100] when error occurs in Java 6 (you can detect Java version and replace try/catch with if statement).Use string like \nLocalDate.parse(((String) data.get("d_iso8601")),DateTimeFormatter.ISO_DATE)I had a similar need: I needed to be able to parse any date ISO8601 compliant without knowing the exact format in advance, and I wanted a lightweight solution which would also work on Android.When I googled my needs I stumbled upon this question, and noticed that AFAIU, no answer completely fit my needs. So I developed jISO8601  and pushed it on maven central.Just add in you pom.xml:and then you\'re good to go:Hopes it help.To just format a date like this the following worked for me in a Java 6 based application. There is a DateFormat class JacksonThymeleafISO8601DateFormat in the thymeleaf project which inserts the missing colon:https://github.com/thymeleaf/thymeleaf/blob/40d27f44df7b52eda47d1bc6f1b3012add6098b3/src/main/java/org/thymeleaf/standard/serializer/StandardJavaScriptSerializer.javaI used it for ECMAScript date format compatibilty.Java has a dozen different ways to parse a date-time, as the excellent answers here demonstrate. But somewhat amazingly, none of Java\'s time classes fully implement ISO 8601!With Java 8, I\'d recommend:That will handle examples both in UTC and with an offset, like "2017-09-13T10:36:40Z" or "2017-09-13T10:36:40+01:00". It will do for most use cases.But it won\'t handle examples like "2017-09-13T10:36:40+01", which is a valid ISO 8601 date-time.\nIt also won\'t handle date only, e.g. "2017-09-13".If you have to handle those, I\'d suggest using a regex first to sniff the syntax.There\'s a nice list of ISO 8601 examples here with lots of corner cases: https://www.myintervals.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/ I\'m not aware of any Java class that could cope with all of them.Base Function Courtesy : @wrygiel. This function can convert ISO8601 format to Java Date which can handle the offset values. As per the definition of ISO 8601 the offset can be mentioned in different formats.This class has static methods to convert Sample ISO8601 Strings}This seemed to work best for me:I needed to convert to/fro JavaScript date strings to Java. I found the above works with the recommendation. There were some examples using SimpleDateFormat that were close but they did not seem to be the subset as recommended by: http://www.w3.org/TR/NOTE-datetimeand supported by PLIST and JavaScript Strings and such which is what I needed.This seems to be the most common form of ISO8601 string out there, and a good subset. The examples they give are:I also have a fast version:...I have not benchmarked it, but I am guess it will be pretty fast. It seems to work. :)I think what a lot of people want to do is parse JSON date strings. There is a good chance if you come to this page that you might want to convert a JavaScript JSON date to a Java date.To show what a JSON date string looks like:The JSON date string is 2013-12-14T01:55:33.412Z.Dates are not covered by JSON spec per say, but the above is a very specific ISO 8601 format, while ISO_8601 is much much bigger and that is a mere subset albeit a very important one.See http://www.json.org\nSee http://en.wikipedia.org/wiki/ISO_8601\nSee http://www.w3.org/TR/NOTE-datetimeAs it happens I wrote a JSON parser and a PLIST parser both of which use ISO-8601 but not the same bits.I wrote two ways to do this for my project. One standard, one fast.Again, JSON date string is a very specific implementation of ISO 8601....(I posted the other one in the other answer which should work for PLIST dates, which are a different ISO 8601 format).The JSON date is as follows:PLIST files (ASCII non GNUNext) also uses ISO 8601 but no miliseconds so... not all ISO-8601 dates are the same. (At least I have not found one that uses milis yet and the parser I have seen skip the timezone altogether OMG).Now for the fast version (you can find it in Boon).Note that Reflection.toCharArray uses unsafe if available but defaults to string.toCharArray if not.(You can take it out of the example by replacing Reflection.toCharArray ( string ) with string.toCharArray()).The isJsonDate is implemented as follows:Anyway... my guess is that quite a few people who come here.. might be looking for the JSON Date String and although it is an ISO-8601 date, it is a very specific one that needs a very specific parse.See https://github.com/RichardHightower/boon\nBoon has a PLIST parser (ASCII) and a JSON parser. The JSON parser is the fastest Java JSON parser that I know of. Independently verified by the Gatling Performance dudes.https://github.com/gatling/json-parsers-benchmarkIt has the fastest JSON parser for streams, readers, bytes[], char[], CharSequence (StringBuilder, CharacterBuffer), and String.See more benchmarks at:https://github.com/RichardHightower/json-parsers-benchmark