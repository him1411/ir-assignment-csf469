How do I use Assert (or other Test class?) to verify that an exception has been thrown?For "Visual Studio Team Test" it appears you apply the ExpectedException attribute to the test\'s method.Sample from the documentation here: A Unit Testing Walkthrough with Visual Studio Team TestUsually your testing framework will have an answer for this. But if it\'s not flexible enough, you can always do this:As @Jonas points out, this DOES NOT work for catching a base Exception:If you absolutely must catch Exception, you need to rethrow the Assert.Fail(). But really, this is a sign you shouldn\'t be hand-writing this; check your test framework for options, or see if you can throw a more meaningful exception to test for.You should be able to adapt this approach to whatever you like -- including specifying what kinds of exceptions to catch. If you only expect certain types, finish the catch blocks off with:My preferred method for implementing this is to write a method called Throws, and use it just like any other Assert method. Unfortunately, .NET doesn\'t allow you to write a static extension method, so you can\'t use this method as if it actually belongs to the build in Assert class; just make another called MyAssert or something similar. The class looks like this:That means that your unit test looks like this:Which looks and behaves much more like the rest of your unit test syntaxes.If you\'re using MSTest, which originally didn\'t have an ExpectedException attribute, you could do this:Be wary of using ExpectedException, as it can lead to several pitfalls as demonstrated here:http://geekswithblogs.net/sdorman/archive/2009/01/17/unit-testing-and-expected-exceptions.aspxAnd here:http://xunit.github.io/docs/comparisons.htmlIf you need to test for exceptions, there are less frowned upon ways. You can use the try{act/fail}catch{assert} method, which can be useful for frameworks that don\'t have direct support for exception tests other than ExpectedException. A better alternative is to use xUnit.NET, which is a very modern, forward looking, and extensible unit testing framework that has learned from all the others mistakes, and improved. One such improvement is Assert.Throws, which provides a much better syntax for asserting exceptions. You can find xUnit.NET at github: http://xunit.github.io/In a project i\xc2\xb4m working on we have another solution doing this.First I don\xc2\xb4t like the ExpectedExceptionAttribute becuase it does take in consideration which method call that caused the Exception.I do this with a helpermethod instead.TestHelperMethodNeat, isn\xc2\xb4t it;)if you use NUNIT, you can do something like this:\nIt is also possible to store the thrown exception in order to validate it further:See: http://nunit.org/docs/2.5/exceptionAsserts.htmlIt is an attribute on the test method... you don\'t use Assert. Looks like this:You can download a package from Nuget using: PM> Install-Package MSTestExtensions that adds Assert.Throws() syntax in the style of nUnit/xUnit to MsTest.High level instructions: download the assembly and inherit from BaseTest and you can use the Assert.Throws() syntax.The main method for the Throws implementation looks as follows:Disclosure: I put together this package.More Info: http://www.bradoncode.com/blog/2012/01/asserting-exceptions-in-mstest-with.htmlI do not recommend using the ExpectedException attribute (since it\'s too constraining and error-prone) or to write a try/catch block in each test (since it\'s too complicated and error-prone).  Use a well-designed assert method -- either provided by your test framework or write your own.  Here\'s what I wrote and use.  Example uses:NOTESReturning the exception instead of supporting a validation callback is a reasonable idea except that doing so makes the calling syntax of this assert very different than other asserts I use.Unlike others, I use \'propagates\' instead of \'throws\' since we can only test whether an exception propagates from a call. We can\'t test directly that an exception is thrown.  But I suppose you could image throws to mean: thrown and not caught.FINAL THOUGHTBefore switching to this sort of approach I considered using the ExpectedException attribute when a test only verified the exception type and using a try/catch block if more validation was required.  But, not only would I have to think about which technique to use for each test, but changing the code from one technique to the other as needs changed was not trivial effort.  Using one consistent approach saves mental effort.  So in summary, this approach sports: ease-of-use, flexibility and robustness (hard to do it wrong).The helper provided by @Richiban above works great except it doesn\'t handle the situation where an exception is thrown, but not the type expected. The following addresses that:Well i\'ll pretty much sum up what everyone else here said before...Anyways, here\'s the code i built according to the good answers :) All is left to do is copy and use...This is going to depend on what test framework are you using?In MbUnit, for example, you can specify the expected exception with an attribute to ensure that you are getting the exception you really expect.Since you mention using other test classes, a better option than the ExpectedException attribute is to use Shoudly\'s Should.Throw.Let\'s say we have a requirement that the customer must have an address to create an order. If not, the CreateOrderForCustomer method should result in an ArgumentException. Then we could write:This is better than using an ExpectedException attribute because we are being specific about what should throw the error. This makes requirements in our tests clearer and also makes diagnosis easier when the test fails.Note there is also a Should.ThrowAsync for asynchronous method testing.Check out nUnit Docs for examples about: MSTest now has an Assert.ThrowsException function which can be used like this:In case of using NUnit, try this:Even though this is an old question, I would like to add a new thought to the discussion. I have extended the Arrange, Act, Assert pattern to be Expected, Arrange, Act, Assert. You can make an expected exception pointer, then assert it was assigned to. This feels cleaner than doing your Asserts in a catch block, leaving your Act section mostly just for the one line of code to call the method under test. You also don\'t have to Assert.Fail(); or return from multiple points in the code. Any other exception thrown will cause the test to fail, because it won\'t be caught, and if an exception of your expected type is thrown, but the it wasn\'t the one you were expecting, Asserting against the message or other properties of the exception help make sure your test won\'t pass inadvertently.As an alternative you can try testing exceptions are in fact being thrown with the next 2 lines in your test.In VS built-in unit testing if you simply want to verify that "any exception" is thrown, but you don\'t know the type, you can use a catch all: