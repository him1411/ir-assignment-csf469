I have a program that writes information to stdout and stderr, and I need to grep through what\'s coming to stderr, while disregarding stdout.I can of course do it in 2 steps:but I would prefer to be able to do this without temp files. Are there any smart piping tricks?First redirect stderr to stdout \xe2\x80\x94 the pipe; then redirect stdout to /dev/null (without changing where stderr is going):For the details of I/O redirection in all its variety, see the chapter on Redirections in the Bash reference manual.Note that the sequence of I/O redirections is interpreted left-to-right, but pipes are set up before the I/O redirections are interpreted.  File descriptors such as 1 and 2 are references to open file descriptions.  The operation 2>&1 makes file descriptor 2 aka stderr refer to the same open file description as file descriptor 1 aka stdout is currently referring to (see dup2() and open()).  The operation >/dev/null then changes file descriptor 1 so that it refers to an open file description for /dev/null, but that doesn\'t change the fact that file descriptor 2 refers to the open file description which file descriptor 1 was originally pointing to \xe2\x80\x94 namely, the pipe.Or to swap the output from stderr and stdout over use:-This creates a new file descriptor (3) and assigns it to the same place as 1 (stdout), then assigns fd 1 (stdout) to the same place as fd 2 (stderr) and finally assigns fd 2 (stderr) to the same place as fd 3 (stdout).  Stderr is now available as stdout and old stdout preserved in stderr.  Maybe be overkill but hopefully gives more details on bash file descriptors (there are 9 available to each process).In Bash, you can also redirect to a subshell using process substitution:For the case at hand:Combining the best of these answers, if you do:command 2> >(grep -v something 1>&2)...then all stdout is preserved as stdout and all stderr is preserved as stderr, but you won\'t see any lines in stderr beginning with the string "something".This has the unique advantage of not reversing or discarding stout and stderr, nor smushing them together, nor using any temporary files.It\'s much easier to visualize things if you think about what\'s really going on with "redirects" and "pipes." Redirects and pipes in bash do one thing: modify where the process file descriptors 0, 1, and 2 point to (see /proc/[pid]/fd/*). When a pipe or "|" operator is present on the command line, the first thing to happen is that bash creates a fifo and points the left side command\'s FD 1 to this fifo, and points the right side command\'s FD 0 to the same fifo. Next, the redirect operators for each side are evaluated from left to right, and the current settings are used whenever duplication of the descriptor occurs. This is important because since the pipe was set up first, the FD1 (left side) and FD0 (right side) are already changed from what they might normally have been, and any duplication of these will reflect that fact.Therefore, when you type something like the following:Here is what happens, in order:So, all output that "command" writes to its FD 2 (stderr) makes its way to the pipe and is read by "grep" on the other side. All output that "command" writes to its FD 1 (stdout) makes its way to /dev/null. If instead, you run the following:Here\'s what happens:So, all stdout and stderr from "command" go to /dev/null. Nothing goes to the pipe, and thus "grep" will close out without displaying anything on the screen.Also note that redirects (file descriptors) can be read-only (<), write-only (>), or read-write (<>). A final note. Whether a program writes something to FD1 or FD2, is entirely up to the programmer. Good programming practice dictates that error messages should go to FD 2 and normal output to FD 1, but you will often find sloppy programming that mixes the two or otherwise ignores the convention. Are you using bash? If so:http://www.gnu.org/software/bash/manual/bashref.html#PipelinesFor those who want to redirect stdout and stderr permanently to files, grep on stderr, but keep the stdout to write messages to a tty:This will redirect command1 stderr to command2 stdin, while leaving command1 stdout as is.Taken from LDPI try follow, find it work as well, 