PHP treats all arrays as associative, so there aren\'t any built in functions. Can anyone recommend a fairly efficient way to check if an array contains only numeric keys?Basically, I want to be able to differentiate between this:and this:You have asked two questions that are not quite equivalent:Consider which of these behaviours you actually need. (It may be that either will do for your purposes.)The first question (simply checking that all keys are numeric) is answered well by Captain kurO.For the second question (checking whether the array is zero-indexed and sequential), you can use the following function:To merely check whether the array has non-integer keys (not whether the array is sequentially-indexed or zero-indexed):If there is at least one string key, $array will be regarded as an associative array.Surely this is a better alternative.Many commenters in this question don\'t understand how arrays work in PHP. From the array documentation:A key may be either an integer or a string. If a key is the standard representation of an integer, it will be interpreted as such (i.e. "8" will be interpreted as 8, while "08" will be interpreted as "08"). Floats in key are truncated to integer. The indexed and associative array types are the same type in PHP, which can both contain integer and string indices.In other words, there is no such thing as an array key of "8" because it will always be (silently) converted to the integer 8. So trying to differentiate between integers and numeric strings is unnecessary.If you want the most efficient way to check an array for non-integer keys without making a copy of part of the array (like array_keys() does) or all of it (like foreach does):This works because key() returns NULL when the current array position is invalid and NULL can never be a valid key (if you try to use NULL as an array key it gets silently converted to "").As stated by the OP:PHP treats all arrays as associativeit is not quite sensible (IMHO) to write a function that checks if an array is associative. So first thing first: what is a key in a PHP array?:The key can either be an integer or a string.That means there are 3 possible cases:We can check each case with the following functions.Note: This function returns true for empty arrays too.Note: This function returns true for empty arrays too.Note: This function returns true for empty arrays too.It follows that:Now, for an array to be a "genuine" array that we are all accustomed to, meaning:We can check with the following function.Note: This function returns true for empty arrays too.The keys for these arrays are integers:The keys for these arrays are strings:If you think the key in array("13" => "b") is a string, you are wrong. From the doc here:Strings containing valid integers will be cast to the integer type. E.g. the key "8" will actually be stored under 8. On the other hand "08" will not be cast, as it isn\'t a valid decimal integer.For example, the key for these arrays are integers:But the key for these arrays are strings:What\'s more, according to the doc,The size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that\'s 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18, except for Windows, which is always 32 bit. PHP does not support unsigned integers.So the key for this array may or may not be an integer - it depends on your platform.Even worse, PHP tends to be buggy if the integer is near the 231 = 2,147,483,648 boundary (see bug 51430, bug 52899). For example, on my local environment (PHP 5.3.8 on XAMPP 1.7.7 on Windows 7), var_dump(array("2147483647" => "b")) givesbut on this live demo on codepad (PHP 5.2.5), the same expression givesSo the key is an integer in one environment but a string in another, even though 2147483647 is a valid signed 32-bit integer.Speed-wise:Memory-wise:Actually the most efficient way is thus:This works because it compares the keys (which for a sequential array are always 0,1,2 etc) to the keys of the keys (which will always be 0,1,2 etc).I\'ve used both array_keys($obj) !== range(0, count($obj) - 1) and array_values($arr) !== $arr (which are duals of each other, although the second is cheaper than the first) but both fail for very large arrays.This is because array_keys and array_values are both very costly operations (since they build a whole new array of size roughly that of the original).The following function is more robust than the methods provided above:Also note that if you don\'t care to differentiate sparse arrays from associative arrays you can simply return \'assoc\' from both if blocks.Finally, while this might seem much less "elegant" than a lot of "solutions" on this page, in practice it is vastly more efficient. Almost any associative array will be detected instantly. Only indexed arrays will get checked exhaustively, and the methods outlined above not only check indexed arrays exhaustively, they duplicate them.I think the following two functions are the best way to go for checking \'if an array is associative or numeric\'. Since \'numeric\' could mean only numeric keys or only sequential numeric keys, two functions are listed below that check either condition:The first function checks if each key is an integer value. The second function checks if each key is an integer value and in addition checks if all keys are sequential starting at $base, which defaults to 0 and thus can be omitted if you do not need to specify another base value. key($my_array) returns null if the read pointer is moved past the end of the array, which is what ends the for loop and makes the statement after the for loop return true if all keys were integer. If not, the loop ends prematurely because a key is of type string, and the statement after the for loop will return false. The latter function in addition adds one to $base after each compare, to be able to check if the next key is of the correct value. The strict compare makes it also check if the key is of type integer. The $base = (int) $base part in the first section of the for loop can be left out when $base is omitted or if you make sure it is only called using an integer. But since I can\'t be sure for everybody, I left it in. The statement is executed only once, anyway. I think these are the most efficient solutions:Remember that an array key can only be an integer or a string, and a strictly numeric string such as "1" (but not "01") will be translated into an integer. Which is what makes checking for an integer key the only needed operation besides counting if you want the array to be sequential. Naturally, if is_indexed_array returns false the array can be seen as associative. I say \'seen\', because in fact they all are.This function can handle:the idea is simple: if one of the keys is NOT an integer, it is associative array, otherwise it\'s sequential.I noticed two popular approaches for this question: one using array_values() and other using key(). To find out which is faster, I wrote a small program:\nOutput for the program on PHP 5.2 on CentOS is as follows:Time taken with method #1 = 10.745ms\n  Time taken with method #2 = 18.239msOutput on PHP 5.3 yielded similar results. Obviously using array_values() is much faster.Unless PHP has a builtin for that, you won\'t be able to do it in less than O(n) - enumerating over all the keys and checking for integer type. In fact, you also want to make sure there are no holes, so your algorithm might look like:But why bother? Just assume the array is of the type you expect. If it isn\'t, it will just blow up in your face - that\'s dynamic programming for you! Test your code and all will be well...This would work too (demo):Please note that the main point of this answer is to inform you about the existence of SplFixedArray and not to encourage you to use Exceptions for these kinds of tests.By using xarray PHP extensionYou can do this very fast (about 30+ times faster in PHP 5.6): Or:My solution:array_merge on a single array will reindex all integer keys, but not other. For example:So if a list (a non-associative array) is created [\'a\', \'b\', \'c\'] then a value is removed unset($a[1]) then array_merge is called, the list is reindexed starting from 0.Here\'s the method I use:Note that this doesn\'t account for special cases like:Sorry, can\'t help you with that. It\'s also somewhat performant for decently sized arrays, as it doesn\'t make needless copies. It is these little things that makes Python and Ruby so much nicer to write in... :PBoth of these examples, which scored the most points do not work correctly with arrays like $array = array(\'foo\' => \'bar\', 1)I think the definition of a scalar array will vary by application.  That is, some applications will require a more strict sense of what qualifies as a scalar array, and some applications will require a more loose sense.Below I present 3 methods of varying strictness.Could this be the solution?The caveat is obviously that the array cursor is reset but I\'d say probably the function is used before the array is even traversed or used.Fast, concise, and memory efficient. No expensive comparisons, function calls or array copying.I know it\'s a bit pointless adding an answer to this huge queue, but here\'s a readable O(n) solution that doesn\'t require duplicating any values:Rather than check the keys to see if they are all numeric, you iterate over the keys that would be there for a numeric array and make sure they exist.One more fast from source.\nFit encoding of json_encode (and bson_encode). So has javascript Array compliance.answers are already given but there\'s too much disinformation about performance.\nI wrote this little benchmark script that shows that the foreach method is the fastest.Disclaimer: following methods were copy-pasted from the other answersresults:There are many answers already, but here is the method that Laravel relies on within its Arr class: Source: https://github.com/laravel/framework/blob/5.4/src/Illuminate/Support/Arr.phpOne way to approach this is to piggyback on json_encode, which already has its own internal method of differentiating between an associative array and an indexed array in order to output the correct JSON.You can do this by checking to see if the first character returned after encoding is a { (associative array) or a [ (indexed array).I compare the difference between the keys of the array and the keys of the result of array_values() of the array, which will always be an array with integer indices. If the keys are the same, it\'s not an associative array.Modification on the most popular answer.\nThis takes a little more processing, but is more accurate.  In my opinion, an array should be accepted as associative if any of its keys is not integer e.g. float numbers and empty string \'\'.Also non-sequenced integers has to be seen as associative like (0,2,4,6) because these kind of arrays cannot be used with for loops by this way:The second part of the function below does check if the keys are indexed or not.It also works for keys with negative values. For example (-1,0,1,2,3,4,5)