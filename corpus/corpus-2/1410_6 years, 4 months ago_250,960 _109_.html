The activity hosting this fragment has its onActivityResult called when the camera activity returns.My fragment starts an activity for a result with the intent sent for the camera to take a picture. The picture application loads fine, takes a picture, and returns. The onActivityResult however is never hit. I\'ve set breakpoints, but nothing is triggered. Can a fragment have onActivityResult? I\'d think so since it\'s a provided function. Why isn\'t this being triggered?The hosting activity overrides onActivityResult(), but it did not make a call to super.onActivityResult() for unhandled result codes. Apparently, even though the fragment is the one making the startActivityForResult() call, the activity gets the first shot at handling the result. This makes sense when you consider the modularity of fragments. Once I implemented super.onActivityResult() for all unhandled results, the fragment got a shot at handling the result.And also from @siqing answer:To get the result in your fragment make sure you call startActivityForResult(intent,111); instead of getActivity().startActivityForResult(intent,111); inside your fragment.I think you called getActivity().startActivityForResult(intent,111);. You should call startActivityForResult(intent,111);.Option 1:If you\'re calling startActivityForResult() from the fragment then you should call startActivityForResult(), not getActivity().startActivityForResult(), as it will result in fragment onActivityResult().If you\'re not sure where you\'re calling on startActivityForResult() and how you will be calling methods.Option 2:Since Activity gets the result of onActivityResult(), you will need to override the activity\'s onActivityResult() and call super.onActivityResult() to propagate to the respective fragment for unhandled results codes or for all.If above two options do not work, then refer to option 3 as it will definitely work.Option 3:An explicit call from fragment to the onActivityResult function is as follows.In the parent Activity class, override the onActivityResult() method and even override the same in the Fragment class and call as the following code.In the parent class:In the child class:I\'m having this same problem with the ChildFragmentManager. The manager will not pass the result to the nested fragment, you have to do that manually in your base fragment.In case you don\'t know fragments in your activity just enumerate them all and send activity result arguments:Original post.FragmentActivity replaces requestCode by a modified one. After that, when onActivityResult() will be invoked, FragmentActivity parses the higher 16 bits and restores the index of the original Fragment. Look at this scheme:If you have a few fragments at the root level there are no problems. But if you have nested fragments, for example Fragment with a few tabs inside ViewPager, you guaranteed will face with a problem (or already faced it).Because only one index is stored inside requestCode. That is index of Fragment inside its FragmentManager. When we are using nested fragments, there are child FragmentManagers, which have their own list of Fragments. So, it\'s necessary to save the whole chain of indices, starting from root FragmentManager.How do we resolve this issue? There is common workaround solution in this post.GitHub: https://github.com/shamanland/nested-fragment-issueThis is one of the most popular issue. We can found lots of thread regarding this issue. But none of them is useful for ME. So I have solved this problem using this solution.Let\'s first understand why this is happening.We can call startActivityForResult directly from Fragment but actually mechanic behind are all handled by Activity.Once you call startActivityForResult from a Fragment, requestCode will be changed to attach Fragment\'s identity to the code. That will let Activity be able to track back that who send this request once result is received.Once Activity was navigated back, the result will be sent to Activity\'s onActivityResult with the modified requestCode which will be decoded to original requestCode + Fragment\'s identity. After that, Activity will send the Activity Result to that Fragment through onActivityResult. And it\'s all done.The problem is:Activity could send the result to only the Fragment that has been attached directly to Activity but not the nested one. That\'s the reason why onActivityResult of nested fragment would never been called no matter what.Solution: 1) Start Intent in your Fragment by below code:2) Now in your Parent Activity override **onActivityResult() :**You have to call this in parent activity to make it work.3) In your fragment call:That\'s it.\nWith this solution, it could be applied for any single fragment whether it is nested or not. And yes, it also covers all the case! Moreover, the codes are also nice and clean.FOR MANY NESTED FRAGMENTS (for example, when using a ViewPager in a fragment)In your main activity:In your fragment:In your nested fragmentCall activityuniqueInstanceInt - replace it with an int that is unique among the nested fragments to prevent another fragment treat the answer.Receive responseAttentionA number between 0 and 65536 need be used in uniqueInstanceInt for error avoid "Can only use lower 16 bits for requestCode".I can add two advices if someone still cannot make it. In Manifest.xml file, make sure the hosting activity didn\'t finish when call back and the activity to be started has the launch mode as standard.\nSee details as below:For Hosting activity, set the no history property as false if haveFor Activity to be started, set the launch mode as standard if haveI also met this problem in a Fragment. And I called startActivityForResult in a DialogFragment. But now this problem has been resolved: \nFragmentClassname.this.startActivityForResult.Solution 1:Call startActivityForResult(intent, REQUEST_CODE); instead of getActivity().startActivityForResult(intent, REQUEST_CODE);.Solution 2:When startActivityForResult(intent, REQUEST_CODE); is called the activity\'s onActivityResult(requestCode,resultcode,intent) is invoked, and then you can call fragments onActivityResult() from here, passing the requestCode, resultCode and intent.Inside your fragment, callwhere this is referring to the fragment. Otherwise do as @Clevester said:I also had to callin the parent activity\'s onActivityResult to make it work.(I adapted this answer from @Clevester\'s answer.)In short,In fragment, declare Fragment fragment = this;after that use fragment.startActivityForResult.The result will return in activityResult.In my case it was an Android bug (http://technet.weblineindia.com/mobile/onactivityresult-not-getting-called-in-nested-fragments-android/), if you use supported FragmentActivity you have to use getSupportFragmentManager instead of getChildFragmentManager:You can simply override BaseActivity onActivityResult on fragment baseActivity.startActivityForResult .On BaseActivity add interface and override onActivityResult.On Fragment implements OnBaseActivityResult This workaround will do the trick.If the above problem is faced at Facebook login then you can use the below code in a parent activity of your fragment like:Or:And add the below call in your fragment...In your main activity:In your main top level fragment(ViewPager fragment):In YourFragment (nested fragment):Most of these answers keep saying that you have to call super.onActivityResult(...) in your host Activity for your Fragment. But that did not seem to be working for me.So, in your host Activity you should call your Fragments onActivityResult(...) instead. Here is an example.At some point in your HostActivity you will need to assign this.myFragment the Fragment you are using. Or, use the FragmentManager to get the Fragment instead of keeping a reference to it in your HostActivity. Also, check for null before you try to call the this.myFragment.onActivityResult(...);.As Ollie C mentioned, there is an active bug for the support library using returned values to onActivityResult when you are using nested fragments. I just hit it :-(.See Fragment.onActivityResult not called when requestCode != 0.I have a strong suspicion that all of the answers here are nothing more than hacks. I\'ve tried them all and many others, but without any reliable conclusion as there is always some sort of stupid issue. I for one cannot rely on inconsistent results. If you look at the official Android API documentation for Fragments you will see Google clearly states the following:Call startActivityForResult(Intent, int) from the fragment\'s containing Activity.See: Android Fragment APISo, it would seem that the most correct and reliable approach would be to actually call startActivityForResult() from the hosting activity and also handle the resulting onActivityResult() from there.Your code has a nested fragment. Calling super.onActivityForResult doesn\'t workYou don\'t want to modify every activity that your fragment can be called from and or make a work around calling every fragment in the fragment chain.Here is one of many working solutions. create a fragment on the fly and wire it directly to the activity with the support fragment manager. Then call startActivityForResult from the newly created fragment.My Problem was with the Host activity I found it with a set             android:launchMode="standard" I removed it temporary an it work !I have handled the issue by writing a base class that extends Fragment, and in onactivityresult of the activity I have identified the currently running fragment using the fragmenttag, and called a user-defined method in fragmentbase class. This will fire an event in the currently running fragment.One of the simplest way is to start an activity from your fragment. Then, add you call startActivityForResult(intent,"1"); from your Activity and add onActivityResult in your activityI just make a workaround method:In your Fragment, before startActivityResult, setAfter onActivityResult <-- in FragmentSimply use the below code for the fragment.onActivityResult will call without calling its parent.One point no one has mention that make sure your Host Activity launch mode must not set to singleInstance or singleTask.onActivityResult will not work if your launch mode set to SingleInstance or SingleTask. or you call your activity using these IntentFiltersstandard or singleTop launch mode will work fine.If there is trouble with the method onActivityResult that is inside the fragment class, and you want to update something that\'s is also inside the fragment class, use:Just add the this.variable as shown in the code above. Otherwise the method will be called within the parent activity and the variable will not updated of the current instance.I tested it also by putting this block of code into the MainActivity, replacing this with the HomeFragment class and having the variables static. I got results as I expected.So if you want to have the fragment class having its own implementation of onActivityResult, the code example above is the answer.If you are using nested fragments, this is also working:In addition to this, you have to call super.onActivityResult from parent activity and fill the onActivityResult method of the fragment.