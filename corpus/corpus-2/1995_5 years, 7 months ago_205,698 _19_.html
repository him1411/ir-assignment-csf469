Using gitk log, I could not spot a difference between the two. How can I observe the difference (with a git command or some tool)?The --no-ff flag prevents git merge from executing a "fast-forward" if it detects that your current HEAD is an ancestor of the commit you\'re trying to merge. A fast-forward is when, instead of constructing a merge commit, git just moves your branch pointer to point at the incoming commit. This commonly occurs when doing a git pull without any local changes.However, occasionally you want to prevent this behavior from happening, typically because you want to maintain a specific branch topology (e.g. you\'re merging in a topic branch and you want to ensure it looks that way when reading history). In order to do that, you can pass the --no-ff flag and git merge will always construct a merge instead of fast-forwarding.Similarly, if you want to execute a git pull or use git merge in order to explicitly fast-forward, and you want to bail out if it can\'t fast-forward, then you can use the --ff-only flag. This way you can regularly do something like git pull --ff-only without thinking, and then if it errors out you can go back and decide if you want to merge or rebase.Here is a site with a clear explanation and graphical illustration of using git merge --no-ff:Until I saw this, I was completely lost with git. Using --no-ff allows someone reviewing history to clearly see the branch you checked out to work on. (that link points to github\'s "network" visualization tool) And here is another great reference with illustrations. This reference complements the first one nicely with more of a focus on those less acquainted with git. If you are like me, and not a Git-guru, my answer here describes handling the deletion of files from git\'s tracking without deleting them from the local filesystem, which seems poorly documented but often occurrence. Another newb situation is getting current code, which still manages to elude me.I updated a package to my website and had to go back to my notes to see my workflow; I thought it useful to add an example to this answer. My workflow of git commands:Below: actual usage, including explanations.\nNote: the output below is snipped; git is quite verbose.Notice 3 things from above:\n1) In the output you can see the changes from the ECC package\'s upgrade, including the addition of new files.\n2) Also notice there are two files (not in the /ecc folder) I deleted independent of this change. Instead of confusing those file deletions with ecc, I\'ll make a different cleanup branch later to reflect those files\' deletion.\n3) I didn\'t follow my workflow! I forgot about git while I was trying to get ecc working again. Below: rather than do the all-inclusive git commit -am "updated ecc package" I normally would, I only wanted to add the files in the /ecc folder. Those deleted files weren\'t specifically part of my git add, but because they already were tracked in git, I need to remove them from this branch\'s commit:\nHaving used this process 10+ times in a day, I have taken to writing batch scripts to execute the commands, so I made an almost-proper git_update.sh <branch> <"commit message"> script for doing the above steps. Here is the Gist source for that script. Instead of git commit -am I am selecting files from the "modified" list produced via git status and then pasting those in this script. This came about because I made dozens of edits but wanted varied branch names to help group the changes.The --no-ff option ensures that a fast forward merge will not happen, and that a new commit object will always be created. This can be desirable if you want git to maintain a history of feature branches. \n            \nIn the above image, the left side is an example of the git history after using git merge --no-ff and the right side is an example of using git merge where an ff merge was possible.EDIT: A previous version of this image indicated only a single parent for the merge commit. Merge commits have multiple parent commits which git uses to maintain a history of the "feature branch" and of the original branch. The multiple parent links are highlighted in green.This is an old question, and this is somewhat subtly mentioned in the other posts, but the explanation that made this click for me is that non fast forward merges will require a separate commit.