Can somebody recommend the best way to convert a string in the format \'January 2, 2010\' to a date in java?  Ultimately, I want to break out the month, the day, and the year as integers so that I can use:to convert the date into time.Don\'t do it, that\'s the hard way.  Moreover, those setter methods of java.util.Date are deprecated since Java 1.1 (1997). Simply format date using SimpleDateFormat using a format pattern matching the input string.In your specific case of "January 2, 2010" as input string, "January" is the full text month, so use MMMM pattern for it, "2" is the short day-of-month, so use d pattern for it, "2010" is the 4-digit year, so use yyyy pattern for it.Note the importance of explicit Locale argument. If you omit it, then it will use the default locale which is not necessarily English as used in the month name of the input string. If the locale doesn\'t match with the input string, then you would confusingly get a java.text.ParseException even though when the format pattern seems valid.Here\'s an extract of relevance from the javadoc, listing all available format patterns:Note that the patterns are case sensitive and that text based patterns of 4 characters or more represents the full form, otherwise a short or abbreviated form is used if available. So e.g. MMMMM or more is unnecessary.Here are some examples of valid SimpleDateFormat patterns to parse a given string to date:Important note is that SimpleDateFormat is not thread safe. In other words, you should never declare and assign it as a static or instance variable and then reuse from different methods/threads. You should always create it brand new within the method local scope.If you happen to be on Java 8 already, then use DateTimeFormatter (also here, click the link to see all predefined formatters and available format patterns; the tutorial is available here). This new API is inspired by JodaTime.Note: if your format pattern happens to contain the time part as well, then use LocalDateTime#parse(text, formatter) instead of LocalDate#parse(text, formatter). And, if your format pattern happens to contain the time zone as well, then use ZonedDateTime#parse(text, formatter) instead.Here\'s an extract of relevance from the javadoc, listing all available format patterns:Do note that it has several predefined formatters for the more popular patterns. So instead of e.g. DateTimeFormatter.ofPattern("EEE, d MMM yyyy HH:mm:ss Z", Locale.ENGLISH);, you could use DateTimeFormatter.RFC_1123_DATE_TIME. This is possible because they are, on the contrary to SimpleDateFormat, thread safe. You could thus also define your own, if necessary.For particular input string format, you don\'t need to use an explicit DateTimeFormatter: a standard ISO 8601 date, like 2016-09-26T17:44:57Z,  can be parsed directly with LocalDateTime#parse(text) as it already uses the ISO_LOCAL_DATE_TIME formatter. Similarly, LocalDate#parse(text) parses a ISO date without the time component (see ISO_LOCAL_DATE), and ZonedDateTime#parse(text) parses an ISO date with an offset and time zone added (see ISO_ZONED_DATE_TIME).Ah yes the Java Date discussion, again.  To deal with date manipulation we use Date, Calendar, GregorianCalendar, and SimpleDateFormat.  For example using your January date as input:Then you can manipulate that with something like:With Java 8 we get a new Date / Time API (JSR 310).The following way can be used to parse the date in Java 8 without relying on Joda-Time:LocalDate is the standard Java 8 class for representing a date (without time). If you want to parse values that contain date and time information you should use LocalDateTime. For values with timezones use ZonedDateTime. Both provide a parse() method similar to LocalDate:The list formatting characters from DateTimeFormatter Javadoc:While some of the answers are technically correct, they are not advisable. A few notes about Joda-Time follow.In Joda-Time, a DateTime object truly knows its own assigned time zone. This contrasts the java.util.Date class which seems to have a time zone but does not.Note in the example code below how we pass a time zone object to the formatter which parses the string. That time zone is used to interpret that date-time as having occurred in that time zone. So you need to think about and determine the time zone represented by that string input.Since you have no time portion in your input string, Joda-Time assigns the first moment of the day of the specified time zone as the time-of-day. Usually this means 00:00:00 but not always, because of Daylight Saving Time (DST) or other anomalies. By the way, you can do the same to any DateTime instance by calling withTimeAtStartOfDay.The characters used in a formatter\'s pattern are similar in Joda-Time to those in java.util.Date/Calendar but not exactly the same. Carefully read the doc.We usually use the immutable classes in Joda-Time. Rather than modify an existing Date-Time object, we call methods that create a new fresh instance based on the other object with most aspects copied except where alterations were desired. An example is the call to withZone in last line below. Immutability helps to make Joda-Time very thread-safe, and can also make some work more clear.You will need java.util.Date objects for use with other classes/framework that do not know about Joda-Time objects. Fortunately, it is very easy to move back and forth.Going from a java.util.Date object (here named date) to Joda-Time DateTime\xe2\x80\xa6Going the other direction from Joda-Time to a java.util.Date object\xe2\x80\xa6When run\xe2\x80\xa6While on dealing with SimpleDateFormat Class, its important to remember that Date is not Thread-safe and you can not share a single Date object with multiple thread.Also there is big difference between "m" and "M" where small case is used for minutes and capital case is used for Month. Same with "d" and "D". This can cause subtle bugs which often get overlooked. See Javadoc or Guide to Convert String to Date in Java for more detailsThanks for posters. Updated answer and test more. It works fine for me.\nHave Fun! @.@Also SimpleDateFormat is not available with some of the client side technologies like gwt.\nIts a good idea to go for Calendar.getInstance() and your requirement is to compare two dates go for long date.My humble test program. I use it to play around with the formatter and look-up long dates that I find in log-files (but who has put them there...).My test program:Test results:Simple two formtter we are used\n1) which format date we want?\n2) Which format date actully present?\nWe parse full date to time format.date="2016-05-06 16:40:32";I had a task where I had to write a code that would take any string and attempt to convert it to date when the string\'s format is not known in advance. I wrote an interesting utility. Here is the article that describes the idea: Java 8 java.time package: parsing any string to date. This was implemented in Java 8 but the idea could be implemented in earlier versions as wellTry thisYou can use SimpleDateformat for  change string to date 