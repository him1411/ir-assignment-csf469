Someone mentioned it in the IRC, but google doesn\'t have a good answer."Slicing" is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is "sliced" away.For example, So an object of type B has two data members, foo and bar.Then if you were to write this:Then the information in b about member bar is lost in a.Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you\'re dealing with two classes A and B, where B derives (publicly) from A.In this situation, C++ lets you pass an instance of B to  A\'s assignment operator (and also to the copy constructor). This works because an instance of B can be converted to a const A&, which is what assignment operators and copy-constructors expect their arguments to be.Nothing bad happens there - you asked for an instance of A which is a copy of B, and that\'s exactly what you get. Sure, a won\'t contain some of b\'s members, but how should it? It\'s an A, after all, not a B, so it hasn\'t even heard about these members, let alone would be able to store them.You might think that b2 will be a copy of b1 afterwards. But, alas, it\'s not! If you inspect it, you\'ll discover that b2 is a Frankensteinian creature, made from some chunks of b1 (the chunks that B inherits from A), and some chunks of b2 (the chunks that only B contains). Ouch!What happened? Well, C++ by default doesn\'t treat assignment operators as virtual. Thus, the line a_ref = b1 will call the assignment operator of A, not that of B. This is because for non-virtual functions, the declared type (which is A&) determines which function is called, as opposed to the actual type (which would be B, since a_ref references an instance of B). Now, A\'s assignment operator obviously knows only about the members declared in A, so it will copy only those, leaving the members added in B unchanged.Assigning only to parts of an object usually makes little sense, yet C++ unfortunately provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator virtual. This will guarantee that it\'s always the actual type\'s assignment operator which is called, not the declared type\'s. The second step is to use dynamic_cast to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member assign(), since B\'s assign() will probably want to use A\'s assign() to copy A\'s members.Note that, for pure convenience, B\'s operator= covariantly overrides the return type, since it knows that it\'s returning an instance of B.If You have a base class A and a derived class B, then You can do the following.Now the method wantAnA needs a copy of derived. However, the object derived cannot be copied completely, as the class B could invent additional member variables which are not in its base class A.Therefore, to call wantAnA, the compiler will "slice off" all additional members of the derived class. The result might be an object you did not want to create, becauseThird match in google for "C++ slicing" gives me this Wikipedia article http://en.wikipedia.org/wiki/Object_slicing and this (heated, but the first few posts define the problem) : http://bytes.com/forum/thread163565.htmlSo it\'s when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn\'t got room to store it, so the additional information gets "sliced off".If those links don\'t give enough info for a "good answer" please edit your question to let us know what more you\'re looking for.The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B\'s additional data. Then, when the additional data gets sliced off, p is pointing to garbage.These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:The output is:1. THE DEFINITION OF SLICING PROBLEMIf D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. EXAMPLEAlthough the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the slicing problem.2. HOW TO FIX THE SLICING PROBLEMTo defeat the problem, we use pointers to dynamic variables.EXAMPLEIn this case, none of the data members or member functions of the dynamic variable\nbeing pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve "normal" object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.The short answers is that you slice the object by assigning a derived object to a base object by value, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn\'t exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.Also thought someone should also mention what you should do to avoid slicing...\nGet a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.It seems to me, that slicing isn\'t so much a problem other than when your own classes and program are poorly architected/designed.If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I\'m guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.OK, I\'ll give it a try after reading many posts explaining object slicing but not how it becomes problematic. The vicious scenario that can result in memory corruption is the following:Find similar answers here:http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.htmlSlicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    Explanation:\nConsider the following class declaration:As baseclass copy functions don\'t know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.\nThis is called Object Slicing.Here is an Example: It will generate: