I know how delegates work, and I know how I can use them.But how do I create them?An Objective-C delegate is an object that has been assigned to the delegate property another object. To create one, you simply define a class that implements the delegate methods you\'re interested in, and mark that class as implementing the delegate protocol.For example, suppose you have an UIWebView. If you\'d like to implement its delegate\'s webViewDidStartLoad: method, you could create a class like this:Then you could create an instance of MyClass and assign it as the web view\'s delegate:On the UIWebView side, it probably has code similar to this to see if the delegate responds to the webViewDidStartLoad: message using respondsToSelector: and send it if appropriate.The delegate property itself is typically declared weak (in ARC) or assign (pre-ARC) to avoid retain loops, since the delegate of an object often holds a strong reference to that object. (For example, a view controller is often the delegate of a view it contains.)To define your own delegates, you\'ll have to declare their methods somewhere, as discussed in the Apple Docs on protocols. You usually declare a formal protocol. The declaration, paraphrased from UIWebView.h, would look like this:This is analogous to an interface or abstract base class, as it creates a special type for your delegate, UIWebViewDelegate in this case. Delegate implementors would have to adopt this protocol:And then implement the methods in the protocol. For methods declared in the protocol as @optional (like most delegate methods), you need to check with -respondsToSelector: before calling a particular method on it. Delegate methods are typically named starting with the delegating class name, and take the delegating object as the first parameter. They also often use a will-, should-, or did- form. So, webViewDidStartLoad: (first parameter is the web view) rather than loadStarted (taking no parameters) for example. Instead of checking whether a delegate responds to a selector every time we want to message it, you can cache that information when delegates are set. One very clean way to do this is to use a bitfield, as follows:Then, in the body, we can check that our delegate handles messages by accessing our delegateRespondsTo struct, rather than by sending -respondsToSelector: over and over again.Before protocols existed, it was common to use a category on NSObject to declare the methods a delegate could implement. For example, CALayer still does this:This essentially tells the compiler that any object might implement displayLayer:.You would then use the same -respondsToSelector: approach as described above to call this method. Delegates simply implement this method and assign the delegate property, and that\'s it (there\'s no declaring you conform to a protocol). This method is common in Apple\'s libraries, but new code should use the more modern protocol approach above, since this approach pollutes NSObject (which makes autocomplete less useful) and makes it hard for the compiler to warn you about typos and similar errors.The approved answer is great, but if you\'re looking for a 1 minute answer try this:MyClass.h file should look like this (add delegate lines with comments!)MyClass.m file should look like thisTo use your delegate in another class (UIViewController called MyVC in this case) MyVC.h:MyVC.m:Implement delegate methodWhen using the formal protocol method for creating delegate support, I\'ve found that you can ensure proper type checking (albeit, runtime, not compile time) by adding something like:in your delegate accessor (setDelegate) code.  This helps minimize mistakes.Please! check below simple step by step tutorial to understand how Delegates works in iOS.Delegate in iOSI have created two ViewControllers (for sending data from one to another)Maybe this is more along the lines of what you are missing:If you are coming from a C++ like viewpoint, delegates takes a little getting used to - but basically \'they just work\'. The way it works is that you set some object that you wrote as the delegate to NSWindow, but your object only has implementations (methods) for one or a few of the many possible delegate methods. So something happens, and NSWindow wants to call your object - it just uses Objective-c\'s respondsToSelector method to determine if your object wants that method called, and then calls it. This is how objective-c works - methods are looked up on demand. It is totally trivial to do this with your own objects, there is nothing special going on, you could for instance have an NSArray of 27 objects, all different kinds of objects, only 18 some of them having the method -(void)setToBue; The other 9 don\'t. So to call setToBlue on all of 18 that need it done, something like this:The other thing about delegates is that they are not retained, so you always have to set the delegate to nil in your MyClass dealloc method. As a good practice recommended by Apple, it\'s good for the delegate (which is a protocol, by definition), to conform to NSObject protocol.& to create optional methods within your delegate (i.e. methods which need not necessarily be implemented), you can use the @optional annotation like this :So when using methods that you have specified as optional, you need to (in your class) check with respondsToSelector if the view (that is conforming to your delegate) has actually implemented your optional method(s) or not.I think all these answers make a lot of sense once you understand delegates. Personally I came from the land of C/C++ and before that procedural languages like Fortran etc so here is my 2 min take on finding similar analogues in C++ paradigm.If I were to explain delegates to a C++/Java programmer I would say What are delegates ?\nThese are static pointers to classes within another class. Once you assign a pointer, you can call functions/methods in that class. Hence some functions of your class are "delegated" (In C++ world - pointer to by a class object pointer) to another class.What are protocols ?\nConceptually it serves as similar purpose as to the header file of the class you are assigning  as a delegate class. A protocol is a explicit way of defining what methods needs to be implemented in the class who\'s pointer was set as a delegate within a class.How can I do something similar in C++?\nIf you tried to do this in C++, you would by defining pointers to classes (objects) in the class definition and then wiring them up to other classes that will provide additional functions as delegates to your base class. But this wiring needs to be maitained within the code and will be clumsy and error prone. Objective C just assumes that programmers are not best at maintaining this decipline and provides compiler restrictions to enforce a clean implementation.A delegate is just a class that does some work for another class. Read the following code for a somewhat silly (but hopefully enlightening) Playground example that shows how this is done in Swift.In actual practice, delegates are often used in the following situations The classes don\'t need to know anything about each other beforehand except that the delegate class conforms to the required protocol.I highly recommend reading the following two articles. They helped me understand delegates even better than the documentation did.lets say you have a class that you developed and want to declare a delegate property to be able to notify it when some event happens :so you declare a protocol in MyClass header file (or a separate header file) , and declare the required/optional event handlers that your delegate must/should implement , then declare a property in MyClass of type (id< MyClassDelegate>) which means any objective c class that conforms to the protocol MyClassDelegate , you\'ll notice that the delegate property is declared as weak , this is very important to prevent retain cycle (most often the delegate retains the MyClass instance so if you declared the delegate as retain, both of them will retain each other and neither of them will ever be released).you will notice also that the protocol methods passes the MyClass instance to the delegate as parameter , this is best practice in case the delegate want to call some methods on MyClass instance and also helps when the delegate declares itself as MyClassDelegate to multiple MyClass instances , like when you have multiple UITableView\'s instances in your ViewController and declares itself as a UITableViewDelegate to all of them.and inside your MyClass you notify the delegate with declared events as follows :you first check if your delegate responds to the protocol method that you are about to call in case the delegate doesn\'t implement it and the app will crash then (even if the protocol method is required).Ok, this is not really an answer to the question, but if you are looking up how to make your own delegate maybe something far simpler could be a better answer for you.I hardly implement my delegates because I rarely need. I can have ONLY ONE delegate for a delegate object. So if you want your delegate for one way communication/passing data than you are much better of with notifications. NSNotification can pass objects to more than one recipients and it is very easy to use.\nIt works like this:MyClass.m file should look like thisTo use your notification in another classes:\nAdd class as an observer:Implement the selector:Don\'t forget to remove your class as an observer if Here is a simple method to create delegates Create Protocol in .h file. Make sure that is defined before the protocol using @class followed by the name of the UIViewController < As the protocol I am going to use is UIViewController class>.Step : 1 : Create a new class Protocol named "YourViewController" which will be the subclass of UIViewController class and assign this class to the second ViewController. Step : 2 : Go to the "YourViewController" file and modify it as below:The methods defined in the protocol behavior can be controlled with @optional and @required as part of the protocol definition.Step : 3 :\nImplementation of Delegate//test whether the method has been defined before you call it To create your own delegate, first you need to create a protocol and declare the necessary methods, without implementing. And then implement this protocol into your header class where you want to implement the delegate or delegate methods.A protocol must be declared as below:This is the service class where some task should be done. It shows how to define delegate and how to set the delegate. In the implementation class after the task is completed the delegate\'s the methods are called.This is the main view class from where the service class is called by setting the delegate to itself. And also the protocol is implemented in the header class.That\'s it, and by implementing delegate methods in this class, control will come back once the operation/task is done.Disclaimer: this is the Swift version of how to create a delegate.So, what are delegates? \xe2\x80\xa6in software development, there are general reusable solution architectures that help to solve commonly occurring problems within a given context, these \xe2\x80\x9ctemplates\xe2\x80\x9d, so to speak, are best known as design patterns.\nDelegates are a design pattern that allows one object to send messages to another object when a specific event happens.\nImagine an object A calls an object B to perform an action. Once the action is complete, object A should know that B has completed the task and take necessary action, this can be achieved with the help of delegates!For a better explanation, I am going to show you how to create a custom delegate that passes data between classes, with Swift in a simple application, start by downloading or cloning this starter project and run it!\nhttps://github.com/jamesrochabrun/DelegateTutorialYou can see an app with two classes, ViewController A and ViewController B. B has two views that on tap changes the background color of the ViewController, nothing too complicated right? well now let\xe2\x80\x99s think in an easy way to also change the background color of class A when the views on class B are tapped.The problem is that this views are part of class B and have no idea about class A, so we need to find a way to communicate between this two classes, and that\xe2\x80\x99s where delegation shines.\nI divided the implementation into 6 steps so you can use this as a cheat sheet when you need it.step 1: Look for the pragma mark step 1 in ClassBVC file and add thisThe first step is to create a protocol, in this case, we will create the protocol in class B, inside the protocol you can create as many functions that you want based on the requirements of your implementation. In this case, we just have one simple function that accepts an optional UIColor as an argument.\nIs a good practice to name your protocols adding the word delegate at the end of the class name, in this case, ClassBVCDelegate.step 2: Look for the pragma mark step 2 in ClassVBC and add thisHere we just create a delegate property for the class, this property must adopt the protocol type, and it should be optional. Also, you should add the weak keyword before the property to avoid retain cycles and potential memory leaks, if you don\xe2\x80\x99t know what that means don\xe2\x80\x99t worry for now, just remember to add this keyword.step 3: Look for the pragma mark step 3 inside the handleTap method in ClassBVC and add thisOne thing that you should know, run the app and tap on any view, you won\xe2\x80\x99t see any new behavior and that\xe2\x80\x99s correct but the thing that I want to point out is that the app it\xe2\x80\x99s not crashing when the delegate is called, and it\xe2\x80\x99s because we create it as an optional value and that\xe2\x80\x99s why it won\xe2\x80\x99t crash even the delegated doesn\xe2\x80\x99t exist yet. Let\xe2\x80\x99s now go to ClassAVC file and make it, the delegated.step 4: Look for the pragma mark step 4 inside the handleTap method in ClassAVC and add this next to your class type like this.Now ClassAVC adopted the ClassBVCDelegate protocol, you can see that your compiler is giving you an error that says \xe2\x80\x9cType \xe2\x80\x98ClassAVC does not conform to protocol \xe2\x80\x98ClassBVCDelegate\xe2\x80\x99 and this only means that you didn\xe2\x80\x99t use the methods of the protocol yet, imagine that when class A adopts the protocol is like signing a contract with class B and this contract says \xe2\x80\x9cAny class adopting me MUST use my functions!\xe2\x80\x9dQuick note: If you come from an Objective-C background you are probably thinking that you can also shut up that error making that method optional, but for my surprise, and probably yours, Swift language does not support optional protocols, if you want to do it you can create an extension for your protocol or use the @objc keyword in your protocol implementation. Personally, If I have to create a protocol with different optional methods I would prefer to break it into different protocols, that way I will follow the concept of giving one single responsibility to my objects, but it can vary based on the specific implementation.here is a good article about optional methods.\nhttps://www.avanderlee.com/swift-2-0/optional-protocol-methods/step 5: Look for the pragma mark step 5 inside the prepare for segue method and add thisHere we are just creating an instance of ClassBVC and assign its delegate to self, but what is self here? well, self is the ClassAVC which has been delegated!step 6: Finally, look for the pragma step 6 in ClassAVC and let\xe2\x80\x99s use the functions of the protocol, start typing func changeBackgroundColor and you will see that it\xe2\x80\x99s auto-completing it for you. You can add any implementation inside it, in this example, we will just change the background color, add this.Now run the app!Delegates are everywhere and you probably use them without even notice, if you create a table view in the past you used delegation, many classes of UIKIT works around them and many other frameworks too, they solve these main problems.Congratulations, you just implement a custom delegate, I know that you are probably thinking, so much trouble just for this? well, delegation is a very important design pattern to understand if you want to become an iOS developer, and always keep in mind that they have one to one relationship between objects.You can see the original tutorial here\nhttps://medium.com/compileswift/implementing-delegates-in-swift-step-by-step-d3211cbac3efDelegate :- CreateSend and please assign delegate to view you are sending dataViewController.hViewController.mMainViewController.mMethod://5. Implement the method in the class .m\n-(void)didRemoveCellWithTag:(NSInteger)tag\n{\n   NSLog@("Tag %d",tag);}In my point of view create  separate class for that delegate method and you can use where you want.in my Custom DropDownClass.hafter that in.m file create array with objects,Here all are set for Custom delegate class.after that you can use this delegate method where you want.for example...in my another viewcontroller import after that create action for calling delegate method like thisafter that call delegate method like thisLet\'s start with an example , if we buy a product online ,it goes through process like shipping/delivery handled by different teams.So if shipping gets completed ,shipping team should notify delivery team & it should be one to one communication as broadcasting this information would be overhead for other people / vendor might want to pass this information only to required people.So if we think in terms of our app, an event can be an online order & different teams can be like multiple views.Here is code consider ShippingView as Shipping team & DeliveryView as delivery team :