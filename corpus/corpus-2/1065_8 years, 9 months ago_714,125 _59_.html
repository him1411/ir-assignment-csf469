How can I convert an std::string to a char* or a const char*?If you just want to pass a std::string to a function that needs const char* you can use If you want to get a writable copy, like char *, you can do that with this:Edit: Notice that the above is not exception safe. If anything between the new call and the delete call throws, you will leak memory, as nothing will call delete for you automatically. There are two immediate ways to solve this.boost::scoped_array will delete the memory for you upon going out of scope:This is the standard way (does not require any external library). You use std::vector, which completely manages the memory for you.Given say...How to get a character pointer that\'s valid while x remains in scope and isn\'t modified furtherC++11 simplifies things; the following all give access to the same internal string buffer:All the above pointers will hold the same value - the address of the first character in the buffer.  Even an empty string has a "first character in the buffer", because C++11 guarantees to always keep an extra NUL/0 terminator character after the explicitly assigned string content (e.g. std::string("this\\0that", 9) will have a buffer holding "this\\0that\\0").Given any of the above pointers:Only for the non-const pointer from &x[0]:Writing a NUL elsewhere in the string does not change the string\'s size(); string\'s are allowed to contain any number of NULs - they are given no special treatment by std::string (same in C++03).In C++03, things were considerably more complicated (key differences highlighted):x.data()&x[0]x.c_str()Whichever way you get a pointer, you must not access memory further along from the pointer than the characters guaranteed present in the descriptions above.  Attempts to do so have undefined behaviour, with a very real chance of application crashes and garbage results even for reads, and additionally wholesale data, stack corruption and/or security vulnerabilities for writes.If you call some string member function that modifies the string or reserves further capacity, any pointer values returned beforehand by any of the above methods are invalidated.  You can use those methods again to get another pointer.  (The rules are the same as for iterators into strings).See also How to get a character pointer valid even after x leaves scope or is modified further below....From C++11, use .c_str() for ASCIIZ data, and .data() for "binary" data (explained further below).In C++03, use .c_str() unless certain that .data() is adequate, and prefer .data() over &x[0] as it\'s safe for empty strings.......try to understand the program enough to use data() when appropriate, or you\'ll probably make other mistakes...The ASCII NUL \'\\0\' character guaranteed by .c_str() is used by many functions as a sentinel value denoting the end of relevant and safe-to-access data.  This applies to both C++-only functions like say fstream::fstream(const char* filename, ...) and shared-with-C functions like strchr(), and printf().Given C++03\'s .c_str()\'s guarantees about the returned buffer are a super-set of .data()\'s, you can always safely use .c_str(), but people sometimes don\'t because:As a further hint, if a function\'s parameters require the (const) char* but don\'t insist on getting x.size(), the function probably needs an ASCIIZ input, so .c_str() is a good choice (the function needs to know where the text terminates somehow, so if it\'s not a separate parameter it can only be a convention like a length-prefix or sentinel or some fixed expected length).You\'ll need to copy the contents of the string x to a new memory area outside x.  This external buffer could be in many places such as another string or character array variable, it may or may not have a different lifetime than x due to being in a different scope (e.g. namespace, global, static, heap, shared memory, memory mapped file).To copy the text from std::string x into an independent character array:So, above you\'ve seen how to get a (const) char*, and how to make a copy of the text independent of the original string, but what can you do with it?  A random smattering of examples...Use the .c_str() method for const char *.You can use &mystring[0] to get a char * pointer, but there are a couple of gotcha\'s: you won\'t necessarily get a zero terminated string, and you won\'t be able to change the string\'s size. You especially have to be careful not to add characters past the end of the string or you\'ll get a buffer overrun (and probable crash).There was no guarantee that all of the characters would be part of the same contiguous buffer until C++11, but in practice all known implementations of std::string worked that way anyway; see Does \xe2\x80\x9c&s[0]\xe2\x80\x9d point to contiguous characters in a std::string?.Note that many string member functions will reallocate the internal buffer and invalidate any pointers you might have saved. Best to use them immediately and then discard.C++17 (upcoming standard) changes the synopsis of the template basic_string adding a non const overload of data():charT* data() noexcept;Returns: A pointer p such that p + i == &operator for each i in [0,size()].From C++11 onwards, the standard says:const_reference operator[](size_type pos) const;  reference operator[](size_type pos); Returns: *(begin() + pos) if pos < size(), otherwise a reference to an object of type CharT with value CharT(); the referenced value shall not be modified.const charT* c_str() const noexcept;const charT* data() const noexcept;Returns: A pointer p such that p + i == &operator[](i) for each i in [0,size()].There are severable possible ways to get a non const character pointer.ProConsProConsProConsProConsProConI am working with an API with a lot of functions get as an input a char*.I have created a small class to face this kind of problem, I have implemented the RAII idiom.And you can use it as:I have called the class DeepString because it is creating a deep and unique copy (the DeepString is not copyable) of an existing string.Just see this :However , note that this will return a const char *.For a char *, use strcpy to copy it into another char array.Try this 