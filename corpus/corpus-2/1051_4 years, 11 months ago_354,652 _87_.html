I\'m finding that I need to update my page to my scope manually more and more since building an application in angular.The only way I know of to do this is to call $apply() from the scope of my controllers and directives. The problem with this is that it keeps throwing an error to the console that reads  :Error: $digest already in progressDoes anyone know how to avoid this error or achieve the same thing but in a different way?Don\'t use this pattern - This will end up causing more errors than it solves. Even though you think it fixed something, it didn\'t. You can check if a $digest is already in progress by checking $scope.$$phase. $scope.$$phase will return "$digest" or "$apply" if a $digest or $apply is in progress. I believe the difference between these states is that $digest will process the watches of the current scope and its children, and $apply will process the watchers of all scopes.To @dnc253\'s point, if you find yourself calling $digest or $apply frequently, you may be doing it wrong. I generally find I need to digest when I need to update the scope\'s state as a result of a DOM event firing outside the reach of Angular. For example, when a twitter bootstrap modal becomes hidden. Sometimes the DOM event fires when a $digest is in progress, sometimes not. That\'s why I use this check. I would love to know a better way if anyone knows one.From comments: \nby @anddoutoiangular.js Anti PatternsFrom a recent discussion with the Angular guys on this very topic: For future-proofing reasons, you should not use $$phaseWhen pressed for the "right" way to do it, the answer is currentlyI recently ran into this when writing angular services to wrap the facebook, google, and twitter APIs which, to varying degrees, have callbacks handed in.Here\'s an example from within a service. (For the sake of brevity, the rest of the service -- that set up variables, injected $timeout etc. -- has been left off.)Note that the delay argument for $timeout is optional and will default to 0 if left unset ($timeout calls $browser.defer which defaults to 0 if delay isn\'t set)A little non-intuitive, but that\'s the answer from the guys writing Angular, so it\'s good enough for me!The digest cycle is a synchronous call. It won\'t yield control to the browser\'s event loop until it is done. There are a few ways to deal with this. The easiest way to deal with this is to use the built in $timeout, and a second way is if you are using underscore or lodash (and you should be), call the following:or if you have underscore:We tried several workarounds, and we hated injecting $rootScope into all of our controllers, directives, and even some factories. So, the $timeout and _.defer have been our favorite so far. These methods successfully tell angular to wait until the next animation loop, which will guarantee that the current scope.$apply is over. Many of the answers here contain good advices but can also lead to confusion. Simply using $timeout is not the best nor the right solution.\nAlso, be sure to read that if you are concerned by performances or scalability.$$phase is private to the framework and there are good reasons for that.$timeout(callback) will wait until the current digest cycle (if any) is done, then execute the callback, then run at the end a full $apply.$timeout(callback, delay, false) will do the same (with an optional delay before executing the callback), but will not fire an $apply (third argument) which saves performances if you didn\'t modify your Angular model ($scope).$scope.$apply(callback) invokes, among other things, $rootScope.$digest, which means it will redigest the root scope of the application and all of its children, even if you\'re within an isolated scope.$scope.$digest() will simply sync its model to the view, but will not digest its parents scope, which can save a lot of performances when working on an isolated part of your HTML with an isolated scope (from a directive mostly). $digest does not take a callback: you execute the code, then digest.$scope.$evalAsync(callback) has been introduced with angularjs 1.2, and will probably solve most of your troubles. Please refer to the last paragraph to learn more about it.if you get the $digest already in progress error, then your architecture is wrong: either you don\'t need to redigest your scope, or you should not be in charge of that (see below).When you get that error, you\'re trying to digest your scope while it\'s already in progress: since you don\'t know the state of your scope at that point, you\'re not in charge of dealing with its digestion.And if you know what you\'re doing and working on an isolated small directive while part of a big Angular application, you could prefer $digest instead over $apply to save performances.A new, powerful method has been added to any $scope: $evalAsync. Basically, it will execute its callback within the current digest cycle if one is occurring, otherwise a new digest cycle will start executing the callback.That is still not as good as a $scope.$digest if you really know that you only need to synchronize an isolated part of your HTML (since a new $apply will be triggered if none is in progress), but this is the best solution when you are executing a function which you cannot know it if will be executed synchronously or not, for instance after fetching a resource potentially cached: sometimes this will require an async call to a server, otherwise the resource will be locally fetched synchronously.In these cases and all the others where you had a !$scope.$$phase, be sure to use $scope.$evalAsync( callback )Handy little helper method to keep this process DRY: See http://docs.angularjs.org/error/$rootScope:inprogThe problem arises when you have a call to $apply that is sometimes run asynchronously outside of Angular code (when $apply should be used) and sometimes synchronously inside Angular code (which causes the $digest already in progress error).This may happen, for example, when you have a library that asynchronously fetches items from a server and caches them.  The first time an item is requested, it will be retrieved asynchronously so as not to block code execution.  The second time, however, the item is already in cache so it can be retrieved synchronously.The way to prevent this error is to ensure that the code that calls $apply is run asynchronously.  This can be done by running your code inside a call to $timeout with the delay set to 0 (which is the default).  However, calling your code inside $timeout removes the necessity to call $apply, because $timeout will trigger another $digest cycle on its own, which will, in turn, do all the necessary updating, etc.SolutionIn short, instead of doing this:do this:Only call $apply when you know the code running it will always be run outside of Angular code (e.g. your call to $apply will happen inside a callback that is called by code outside of your Angular code).Unless someone is aware of some impactful disadvantage to using $timeout over $apply, I don\'t see why you couldn\'t always use $timeout (with zero delay) instead of $apply, as it will do approximately the same thing.I had the same problem with third parties scripts like CodeMirror for example and Krpano,\nand even using safeApply methods mentioned here haven\'t solved the error for me.But what do has solved it is using $timeout service (don\'t forget to inject it first).Thus, something like:and if inside your code you are using thisperhaps because it\'s inside a factory directive\'s controller or just need some kind of binding, then you would do something like:When you get this error, it basically means that it\'s already in the process of updating your view. You really shouldn\'t need to call $apply() within your controller. If your view isn\'t updating as you would expect, and then you get this error after calling $apply(), it most likely means you\'re not updating the the model correctly. If you post some specifics, we could figure out the core problem.The shortest form of safe $apply is:You can also use evalAsync. It will run sometime after digest has finished!Sometimes you will still get errors if you use this way (https://stackoverflow.com/a/12859093/801426).Try this:You should use $evalAsync or $timeout according to the context.This is a link with a good explanation: http://www.bennadel.com/blog/2605-scope-evalasync-vs-timeout-in-angularjs.htmI would advise you to use a custom event rather than triggering a digest cycle.I\'ve come to find that broadcasting custom events and registering listeners for this events is a good solution for triggering an action you wish to occur whether or not you are in a digest cycle. By creating a custom event you are also being more efficient with your code because you are only triggering listeners subscribed to said event and NOT triggering all watches bound to the scope as you would if you invoked scope.$apply.yearofmoo did a great job at creating a reusable $safeApply function for us : https://github.com/yearofmoo/AngularJS-Scope.SafeApplyUsage :I have been able to solve this problem by calling $eval instead of $apply in places where I know that the $digest function will be running.According to the docs, $apply basically does this:In my case, an ng-click changes a variable within a scope, and a $watch on that variable changes other variables which have to be $applied. This last step causes the error "digest already in progress".By replacing $apply with $eval inside the watch expression the scope variables get updated as expected.Therefore, it appears that if digest is going to be running anyways because of some other change within Angular, $eval\'ing is all you need to do.use $scope.$$phase || $scope.$apply(); insteadUnderstanding that the Angular documents call checking the $$phase an anti-pattern, I tried to get $timeout and _.defer to work.The timeout and deferred methods create a flash of unparsed {{myVar}} content in the dom like a FOUT. For me this was not acceptable. It leaves me without much to be told dogmatically that something is a hack, and not have a suitable alternative.The only thing that works every time is:if(scope.$$phase !== \'$digest\'){ scope.$digest() }.I don\'t understand the danger of this method, or why it\'s described as a hack by people in the comments and the angular team. The command seems precise and easy to read:"Do the digest unless one is already happening"In CoffeeScript it\'s even prettier:scope.$digest() unless scope.$$phase is \'$digest\'What\'s the issue with this? Is there an alternative that won\'t create a FOUT? $safeApply looks fine but uses the $$phase inspection method, too.This is my utils service:and this is an example for it\'s usage:I have been using this method and it seems to work perfectly fine. This just waits for the time the cycle has finished and then triggers apply(). Simply call the function apply(<your scope>) from anywhere you want.similar to answers above but this has worked faithfully for me...\nin a service add:You can use $timeoutto prevent the error.  Found this: https://coderwall.com/p/ngisma where Nathan Walker (near bottom of page) suggests a decorator in $rootScope to create func \'safeApply\', code:This will be solve your problem: