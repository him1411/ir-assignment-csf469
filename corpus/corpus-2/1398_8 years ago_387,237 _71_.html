How can I generate random 8 character alphanumeric strings in C#?I heard LINQ is the new black, so here\'s my attempt using LINQ:(Note: The use of the Random class makes this unsuitable for anything security related, such as creating passwords or tokens.\n           Use the RNGCryptoServiceProvider class if you need a strong random number generator.)Not as elegant as the Linq solution. (-:(Note: The use of the Random class makes this unsuitable for anything security related, such as creating passwords or tokens. Use the RNGCryptoServiceProvider class if you need a strong random number generator.)This implementation (found via google) looks sound to me.Unlike some of the alternatives presented, this one is cryptographically sound.Picked that one from a discussion of alternatives hereWhy not just use a Guid?Just tested with 100,000 iterations, generated only one duplicate.Edit: Technically you do not need the call to .Replace. The  dash comes after the first 8 characters in a Guid. I\xe2\x80\x99m used to having to generate 16 char random numbers for a project I work on. Should be:Edit 2: If you need to generate more then 8 characters, you can do what richardtallent mentions below and use "n" as the format value of the .ToString method, which removes the dashes:Edit 3: To get full range of alphanumeric characters you can use:Here\'s an example that I stole from Sam Allen example at Dot Net PerlsIf you only need 8 characters, then use Path.GetRandomFileName() in the System.IO namespace. Sam says using the "Path.GetRandomFileName method here is sometimes superior, because it uses RNGCryptoServiceProvider for better randomness. However, it is limited to 11 random characters."GetRandomFileName always returns a 12 character string with a period at the 9th character. So you\'ll need to strip the period (since that\'s not random) and then take 8 characters from the string. Actually, you could just take the first 8 characters and not worry about the period.PS: thanks SamThe main goals of my code are:The first property is achieved by taking a 64 bit value modulo the alphabet size. For small alphabets (such as the 62 characters from the question) this leads to negligible bias. The second and third property are achieved by using RNGCryptoServiceProvider instead of System.Random.The simplest:You can get better performance if you hard code the char array and rely on System.Random:If ever you worry the English alphabets can change sometime around and you might lose business, then you can avoid hard coding, but should perform slightly worse (comparable to Path.GetRandomFileName approach)The last two approaches looks better if you can make them an extension method on System.Random instance.Just some performance comparisons of the various answers in this thread:Tested in LinqPad.  For string size of 10, generates:And the performance numbers tend to vary slightly, very occasionally NonOptimized is actually faster, and sometimes ForLoop and GenerateRandomString switch who\'s in the lead.One line code Membership.GeneratePassword() does the trick :) Here is a demo for the same.If you just need a pseudo-random alphanumeric code, that is user friendly, and derived from an integer value, I have provided a solution here:Generating pseudo-random alphanumeric valuesIt has the advantage that each key generated is guaranteed to be unique.Another option could be to use Linq and aggregate random chars into a stringbuilder.We also use custom string random but we implemented is as a string\'s helper so it provides some flexibility... UsageorThe code written by Eric J. is quite sloppy (it is quite clear that it is from 6 years ago... he probably wouldn\'t write that code today), and there are even some problems.Unlike some of the alternatives presented, this one is cryptographically sound.Untrue... There is a bias in the password (as written in a comment), bcdefgh are a little more probable than the others (the a isn\'t because by the GetNonZeroBytes it isn\'t generating bytes with a value of zero, so the bias for the a is balanced by it), so it isn\'t really cryptographically sound.This should correct all the problems.Horrible, I know, but I just couldn\'t help myself:Question: Why should I waste my time using Enumerable.Range instead of typing in "ABCDEFGHJKLMNOPQRSTUVWXYZ0123456789"?Answer: Magic strings are BAD. Did ANYONE notice there was no "I" in my string at the top? My mother taught me not to use magic strings for this very reason...n.b. 1: As many others like @dtb said, don\'t use System.Random if you need cryptographic security...n.b. 2: This answer isn\'t the most efficient or shortest, but I wanted the space to separate the answer from the question. The purpose of my answer is more to warn against magic strings than to provide a fancy innovative answer.I was looking for a more specific answer, where I want to control the format of the random string and came across this post.  For example: license plates (of cars) have a specific format (per country) and I wanted to created random license plates.\nI decided to write my own extension method of Random for this.  (this is in order to reuse the same Random object, as you could have doubles in multi-threading scenarios).\nI created a gist (https://gist.github.com/SamVanhoutte/808845ca78b9c041e928), but will also copy the extension class here: A slightly cleaner version of DTB\'s solution.Your style preferences may vary.Try to combine two parts: unique (sequence, counter or date ) and randomTests:A solution without using Random :My simple one line code works for me :)Here is a variant of Eric J\'s solution, i.e. cryptographically sound, for WinRT (Windows Store App):If performance matters (especially when length is high):After reviewing the other answers and considering CodeInChaos\' comments, along with CodeInChaos still biased (although less) answer, I thought a final ultimate cut and paste solution was needed. So while updating my answer I decided to go all out.For an up to date version of this code, please visit the new Hg repository on Bitbucket: https://bitbucket.org/merarischroeder/secureswiftrandom. I recommend you copy and paste the code from: https://bitbucket.org/merarischroeder/secureswiftrandom/src/6c14b874f34a3f6576b0213379ecdf0ffc7496ea/Code/Alivate.SolidSwiftRandom/SolidSwiftRandom.cs?at=default&fileviewer=file-view-default (make sure you click the Raw button to make it easier to copy and make sure you have the latest version, I think this link goes to a specific version of the code, not the latest).Updated notes:End solution to question:But you need my new (untested) class:For history - my older solution for this answer, used Random object:Performance:I know this one is not the best way. But you can try this.Now in one-liner flavour.I don\'t know how cryptographically sound this is, but it\'s more readable and concise than the more intricate solutions by far (imo), and it should be more "random" than System.Random-based solutions.I can\'t decide if I think this version or the next one is "prettier", but they give the exact same results:Granted, it isn\'t optimized for speed, so if it\'s mission critical to generate millions of random strings every second, try another one!NOTE: This solution doesn\'t allow for repetitions of symbols in the alphabet, and the alphabet MUST be of equal or greater size than the output string, making this approach less desirable in some circumstances, it all depends on your use-case.If your values are not completely random, but in fact may depend on something - you may compute an md5 or sha1 hash of that \'somwthing\' and then truncate it to whatever length you want.Also you may generate and truncate a guid.Here is a mechanism to generate a random alpha-numeric string (I use this to generate passwords and test data) without defining the alphabet and numbers,CleanupBase64 will remove necessary parts in the string and keep adding random alpha-numeric letters recursively.  Very simple solution. It uses ASCII values and just generates "random" characters in between them.