This question already has an answer here:What is the best way to compare objects in JavaScript?Example:I know that two objects are equal if they refer to the exact same object, but is there a way to check if they have the same attributes\' values?The following way works for me, but is it the only possibility?Unfortunately there is no perfect way, unless you use _proto_ recursively and access all non-enumerable properties, but this works in Firefox only.So the best I can do is to guess usage scenarios.Works when you have simple JSON-style objects without methods and DOM nodes inside:The ORDER of the properties IS IMPORTANT, so this method will return false for following objects:Compares objects without digging into prototypes, then compares properties\' projections recursively, and also compares constructors.This is almost correct algorithm:Known issues (well, they have very low priority, probably you\'ll never notice them):Tests: passes tests are from How to determine equality for two JavaScript objects?.Here is my commented solution (gory details after the code):In developing this solution, I took a particular look at corner cases, efficiency, yet trying to yield a simple solution that works, hopefully with some elegance. JavaScript allows both null and undefined properties and objects have prototypes chains that can lead to very different behaviors if not checked.First I have chosen to extend Object instead of Object.prototype, mostly because null could not be one of the objects of the comparison and that I believe that null should be a valid object to compare with another. There are also other legitimate concerns noted by others regarding the extension of Object.prototype regarding possible side effects on other\'s code.Special care must taken to deal the possibility that JavaScript allows object properties can be set to undefined, i.e. there exists properties which values are set to undefined. The above solution verifies that both objects have the same properties set to undefined to report equality. This can only be accomplished by checking the existence of properties using Object.hasOwnProperty( property_name ). Also note that JSON.stringify() removes properties that are set to undefined, and that therefore comparisons using this form will ignore properties set to the value undefined. Functions should be considered equal only if they share the same reference, not just the same code, because this would not take into account these functions prototype. So comparing the code string does not work to guaranty that they have the same prototype object.The two objects should have the same prototype chain, not just the same properties. This can only be tested cross-browser by comparing the constructor of both objects for strict equality. ECMAScript 5 would allow to test their actual prototype using Object.getPrototypeOf(). Some web browsers also offer a __proto__ property that does the same thing. A possible improvement of the above code would allow to use one of these methods whenever available.The use of strict comparisons is paramount here because 2 should not be considered equal to "2.0000", nor false should be considered equal to null, undefined, or 0.Efficiency considerations lead me to compare for equality of properties as soon as possible. Then, only if that failed, look for the typeof these properties. The speed boost could be significant on large objects with lots of scalar properties.No more that two loops are required, the first to check properties from the left object, the second to check properties from the right and verify only existence (not value), to catch these properties which are defined with the undefined value.Overall this code handles most corner cases in only 16 lines of code (without comments).Update (8/13/2015). I have implemented a better version, as the function value_equals() that is faster, handles properly corner cases such as NaN and 0 different than -0, optionally enforcing objects\' properties order and testing for cyclic references, backed by more than 100 automated tests as part of the Toubkal project test suite.Certainly not the only way - you could prototype a method (against Object here but I certainly wouldn\'t suggest using Object for live code) to replicate C#/Java style comparison methods.Edit, since a general example seems to be expected:Note that testing methods with toString() is absolutely not good enough but a method which would be acceptable is very hard because of the problem of whitespace having meaning or not, never mind synonym methods and methods producing the same result with different implementations. And the problems of prototyping against Object in general.The following algorithm will deal with self-referential data structures, numbers, strings, dates, and of course plain nested javascript objects:Objects are considered equivalent whenFunctions are not considered identical by function text.  This test is insufficient because functions may have differing closures.  Functions are only considered equal if === says so (but you could easily extend that equivalent relation should you choose to do so).Infinite loops, potentially caused by circular datastructures, are avoided.  When areEquivalent attempts to disprove equality and recurses into an object\'s properties to do so, it keeps track of the objects for which this sub-comparison is needed.  If equality can be disproved, then some reachable property path differs between the objects, and then there must be a shortest such reachable path, and that shortest reachable path cannot contain cycles present in both paths; i.e. it is OK to assume equality when recursively comparing objects.  The assumption is stored in a property areEquivalent_Eq_91_2_34, which is deleted after use, but if the object graph already contains such a property, behavior is undefined.  The use of such a marker property is necessary because javascript doesn\'t support dictionaries using arbitrary objects as keys.Simple way to compare ONE-LEVEL only objects.I wrote this piece of code for object comparison, and it seems to work. check the assertions:if you want to check for methods explicitly you can use the method.toSource() or method.toString() methods.I have modified a bit the code above. for me 0 !== false and null !== undefined. If you do not need such strict check remove one "=" sign in "this[p] !== x[p]" inside the code.Then I have tested it with next objects:a==b expected true; returned truea==c expected false; returned falsec==d expected false; returned falsea==e expected false; returned falsef==g expected true; returned trueh==g expected false; returned falsei==j expected true; returned trued==k expected false; returned falsek==l expected false; returned falseHere is my version, pretty much stuff from this thread is integrated (same counts for the test cases):Here is my TestCase:If you work without the JSON library, maybe this will help you out: