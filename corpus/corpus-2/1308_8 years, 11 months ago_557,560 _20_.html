What is the prefered method for creating a byte array from an input stream? Here is my current solution with .NET 3.5. Is it still a better idea to read and write chunks of the stream?It really depends on whether or not you can trust s.Length. For many streams, you just don\'t know how much data there will be. In such cases - and before .NET 4 - I\'d use code like this:With .NET 4 and above, I\'d use Stream.CopyTo, which is basically equivalent to the loop in my code - create the MemoryStream, call stream.CopyTo(ms) and then return ms.ToArray(). Job done.I should perhaps explain why my answer is longer than the others. Stream.Read doesn\'t guarantee that it will read everything it\'s asked for. If you\'re reading from a network stream, for example, it may read one packet\'s worth and then return, even if there will be more data soon. BinaryReader.Read will keep going until the end of the stream or your specified size, but you still have to know the size to start with.The above method will keep reading (and copying into a MemoryStream) until it runs out of data. It then asks the MemoryStream to return a copy of the data in an array. If you know the size to start with - or think you know the size, without being sure - you can construct the MemoryStream to be that size to start with. Likewise you can put a check at the end, and if the length of the stream is the same size as the buffer (returned by MemoryStream.GetBuffer) then you can just return the buffer. So the above code isn\'t quite optimised, but will at least be correct. It doesn\'t assume any responsibility for closing the stream - the caller should do that.See this article for more info (and an alternative implementation).While Jon\'s answer is correct, he is rewriting code that already exists in CopyTo. So for .Net 4 use Sandip\'s solution, but for previous version of .Net use Jon\'s answer. Sandip\'s code would be improved by use of "using" as exceptions in CopyTo are, in many situations, quite likely and would leave the MemoryStream not disposed.Just want to point out that in case you have a MemoryStream you already have memorystream.ToArray() for that. Also, if you are dealing with streams of unknown or different subtypes and you can receive a MemoryStream, you can relay on said method for those cases and still use the accepted answer for the others, like this:just my couple cents... the practice that I often use is to organize the methods like this as a custom helperadd namespace to the config file and use it anywhere you wishI get a compile time error with Bob\'s (i.e. the questioner\'s) code. Stream.Length is a long whereas BinaryReader.ReadBytes takes an integer parameter. In my case, I do not expect to be dealing with Streams large enough to require long precision, so I use the following:You can even make it fancier with extensions:And then call it as a regular method:The one above is ok...but you will encounter data corruption when you send stuff over SMTP (if you need to). I\'ve altered to something else that will help to correctly send byte for byte:\n\'i was able to make it work on a single line:as clarified by johnnyRose, Above code will only work for MemoryStreamYou can use this extension method.