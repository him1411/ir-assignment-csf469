What\'s the proper way to declare custom exception classes in modern Python? My primary goal is to follow whatever standard other exception classes have, so that (for instance) any extra string I include in the exception is printed out by whatever tool caught the exception.By "modern Python" I mean something that will run in Python 2.5 but be \'correct\' for the Python 2.6 and Python 3.* way of doing things. And by "custom" I mean an Exception object that can include extra data about the cause of the error: a string, maybe also some other arbitrary object relevant to the exception.I was tripped up by the following deprecation warning in Python 2.6.2:It seems crazy that BaseException has a special meaning for attributes named message. I gather from PEP-352 that attribute did have a special meaning in 2.5 they\'re trying to deprecate away, so I guess that name (and that one alone) is now forbidden? Ugh.I\'m also fuzzily aware that Exception has some magic parameter args, but I\'ve never known how to use it. Nor am I sure it\'s the right way to do things going forward; a lot of the discussion I found online suggested they were trying to do away with args in Python 3.Update: two answers have suggested overriding __init__, and __str__/__unicode__/__repr__. That seems like a lot of typing, is it necessary?Maybe I missed the question, but why not:Edit: to override something (or pass extra args), do this:That way you could pass dict of error messages to the second param, and get to it later with e.errorsWith modern Python Exceptions, you don\'t need to abuse .message, or override .__str__() or .__repr__() or any of it. If all you want is an informative message when your exception is raised, do this:That will give a traceback ending with MyException: My hovercraft is full of eels.If you want more flexibiilty from the exception, you could pass a dictionary as the argument:However, to get at those details in an except block is a bit more complicated; they are stored in the args attribute, which is a list. You would need to do something like this:It is still possible to pass in multiple items into the exception, but this will be deprecated in the future. If you do need more than a single piece of information, then you should consider fully subclassing Exception.This is fine, unless your exception is really a type of a more specific exception:Or better (maybe perfect), instead of pass give a docstring:From the docsExceptionAll built-in, non-system-exiting exceptions are derived from this class. \n  All user-defined exceptions should also be derived from this\n  class.That means that if your exception is a type of a more specific exception, subclass that exception instead of the generic Exception (and the result will be that you still derive from Exception as the docs recommend). Also, you can at least provide a docstring (and not be forced to use the pass keyword):Set attributes you create yourself with a custom __init__. Avoid passing a dict as a positional argument, future users of your code will thank you. If you use the deprecated message attribute, assigning it yourself will avoid a DeprecationWarning:There\'s really no need to write your own __str__ or __repr__. The builtin ones are very nice, and your cooperative inheritance ensures that you use it.Maybe I missed the question, but why not:Again, the problem with the above is that in order to catch it, you\'ll either have to name it specifically (importing it if created elsewhere) or catch Exception, (but you\'re probably not prepared to handle all types of Exceptions, and you should only catch exceptions you are prepared to handle). Similar criticism to the below, but additionally that\'s not the way to initialize via super, and you\'ll get a DeprecationWarning if you access the message attribute:Edit: to override something (or pass extra args), do this:That way you could pass dict of error messages to the second param, and get to it later with e.errorsIt also requires exactly two arguments to be passed in (aside from the self.) No more, no less. That\'s an interesting constraint that future users may not appreciate. To be direct - it violates Liskov substitutability.I\'ll demonstrate both errors:Compared to: see how exceptions work by default if one vs more attributes are used (tracebacks omitted):so you might want to have a sort of "exception template", working as an exception itself, in a compatible way:this can be done easily with this subclassand if you don\'t like that default tuple-like representation, just add __str__ method to the ExceptionTemplate class, like:and you\'ll haveYou should override __repr__ or __unicode__ methods instead of using message, the args you provide when you construct the exception will be in the args attribute of the exception object.No, "message" is not forbidden. It\'s just deprecated. You application will work fine with using message. But you may want to get rid of the deprecation error, of course.When you create custom Exception classes for your application, many of them do not subclass just from Exception, but from others, like ValueError or similar. Then you have to adapt to their usage of variables.And if you have many exceptions in your application it\'s usually a good idea to have a common custom base class for all of them, so that users of your modules can doAnd in that case you can do the __init__ and __str__ needed there, so you don\'t have to repeat it for every exception. But simply calling the message variable something else than message does the trick.In any case, you only need the __init__ or __str__ if you do something different from what Exception itself does. And because if the deprecation, you then need both, or you get an error. That\'s not a whole lot of extra code you need per class. ;)