I\'m using the Excel interop in C# (ApplicationClass) and have placed the following code in my finally clause:Although this kind of works, the Excel.exe process is still in the background even after I close Excel. It is only released once my application is manually closed.What am I doing wrong, or is there an alternative to ensure interop objects are properly disposed of?Excel does not quit because your application is still holding references to COM objects.I guess you\'re invoking at least one member of a COM object without assigning it to a variable.For me it was the excelApp.Worksheets object which I directly used without assigning it to a variable:I didn\'t know that internally C# created a wrapper for the Worksheets COM object which didn\'t get released by my code (because I wasn\'t aware of it) and was the cause why Excel was not unloaded.I found the solution to my problem on this page, which also has a nice rule for the usage of COM objects in C#:Never use two dots with COM objects.So with this knowledge the right way of doing the above is:You can actually release your Excel Application object cleanly, but you do have to take care. The advice to maintain a named reference for absolutely every COM object you access and then explicitly release it via Marshal.FinalReleaseComObject() is correct in theory, but, unfortunately, very difficult to manage in practice. If one ever slips anywhere and uses "two dots", or iterates cells via a for each loop, or any other similar kind of command, then you\'ll have unreferenced COM objects and risk a hang. In this case, there would be no way to find the cause in the code; you would have to review all your code by eye and hopefully find the cause, a task that could be nearly impossible for a large project.The good news is that you do not actually have to maintain a named variable reference to every COM object you use. Instead, call GC.Collect() and then GC.WaitForPendingFinalizers() to release all the (usually minor) objects to which you do not hold a reference, and then explicitly release the objects to which you do hold a named variable reference. You should also release your named references in reverse order of importance: range objects first, then worksheets, workbooks, and then finally your Excel Application object.For example, assuming that you had a Range object variable named xlRng, a Worksheet variable named xlSheet, a Workbook variable named xlBook and an Excel Application variable named xlApp, then your cleanup code could look something like the following:In most code examples you\'ll see for cleaning up COM objects from .NET, the GC.Collect() and GC.WaitForPendingFinalizers() calls are made TWICE as in:This should not be required, however, unless you are using Visual Studio Tools for Office (VSTO), which uses finalizers that cause an entire graph of objects to be promoted in the finalization queue. Such objects would not be released until the next garbage collection. However, if you are not using VSTO, you should be able to call GC.Collect() and GC.WaitForPendingFinalizers() just once.I know that explicitly calling GC.Collect() is a no-no (and certainly doing it twice sounds very painful), but there is no way around it, to be honest. Through normal operations you will generate hidden objects to which you hold no reference that you, therefore, cannot release through any other means other than calling GC.Collect().This is a complex topic, but this really is all there is to it. Once you establish this template for your cleanup procedure you can code normally, without the need for wrappers, etc. :-)I have a tutorial on this here:Automating Office Programs with VB.Net / COM InteropIt\'s written for VB.NET, but don\'t be put off by that, the principles are exactly the same as when using C#.Preface: my answer contains two solutions, so be careful when reading and don\'t miss anything.There are different ways and advices of how to make Excel instance unload, such as:  Releasing EVERY com object explicitly\nwith Marshal.FinalReleaseComObject()\n(not forgetting about implicitly\ncreated com-objects). To release\nevery created com object, you may use\nthe rule of 2 dots mentioned here:\nHow do I properly clean up Excel interop objects?Calling GC.Collect() and\nGC.WaitForPendingFinalizers() to make\nCLR release unused com-objects * (Actually, it works, see my second solution for details)Checking if com-server-application\nmaybe shows a message box waiting for\nthe user to answer (though I am not\nsure it can prevent Excel from\nclosing, but I heard about it a few\ntimes)Sending WM_CLOSE message to the main\nExcel windowExecuting the function that works\nwith Excel in a separate AppDomain.\nSome people believe Excel instance\nwill be shut, when AppDomain is\nunloaded.Killing all excel instances which were instantiated after our excel-interoping code started.BUT! Sometimes all these options just don\'t help or can\'t be appropriate!For example, yesterday I found out that in one of my functions (which works with excel) Excel keeps running after the function ends. I tried everything! I thoroughly checked the whole function 10 times and added Marshal.FinalReleaseComObject() for everything! I also had GC.Collect() and GC.WaitForPendingFinalizers(). I checked for hidden message boxes. I tried to send WM_CLOSE message to the main Excel window. I executed my function in a separate AppDomain and unloaded that domain. Nothing helped! The option with closing all excel instances is inappropriate, because if the user starts another Excel instance manually, during execution of my function which works also with Excel, then that instance will also be closed by my function. I bet the user will not be happy! So, honestly, this is a lame option (no offense guys). So I spent a couple of hours before I found a good (in my humble opinion) solution: Kill excel process by hWnd of its main window (it\'s a first solution).Here is the simple code:As you can see I provided two methods, according to Try-Parse pattern (I think it is appropriate here): one method doesn\'t throw exception if the Process could not be killed (for example the process doesn\'t exist anymore), and another method throws exception if the Process was not killed. The only weak place in this code is security permissions. Theoretically, user may not have permissions to kill the process, but in 99.99% of all cases user has such permissions. I also tested it with a guest account - it works perfectly.So, your code, working with Excel, can look like this:Voila! Excel is terminated! :)Ok, let\'s go back to the second solution, as I promised in the beginning of the post.\nThe second solution is to call GC.Collect() and GC.WaitForPendingFinalizers(). Yes, they actually work, but you need to be careful here!\nMany people say (and I said) that calling GC.Collect() doesn\'t help. But the reason it wouldn\'t help is if there are still references to COM objects! One of the most popular reasons for GC.Collect() not being helpful is running the project in Debug-mode. In debug-mode objects that are not really referenced anymore will not be garbage collected until the end of the method.\nSo, if you tried GC.Collect() and GC.WaitForPendingFinalizers() and it didn\'t help, try to do the following:  1) Try to run your project in Release mode and check if Excel closed correctly  2) Wrap the method working with Excel in a separate method.\nSo, instead of something like this:you write:Now, Excel will close =)UPDATE: Added C# code, and link to Windows JobsI spent sometime trying to figure out this problem, and at the time XtremeVBTalk was the most active and responsive.  Here is a link to my original post, Closing an Excel Interop process cleanly, even if your application crashes. Below is a summary of the post, and the code copied to this post. I found this to be a clean solution because the OS is doing real work of cleaning up.  All you have to do is register the Excel process.Windows Job CodeWraps the Win32 API Calls to register Interop processes.Note about Constructor codeCauses all processes associated with the job to terminate when the\n  last handle to the job is closed.Extra Win32 API Call to get the Process ID (PID)Using the codeThis worked for a project I was working on:We learned that it was important to set every reference to an Excel COM object to null when you were done with it. This included Cells, Sheets, and everything.Anything that is in the Excel namespace needs to be released. PeriodYou can\'t be doing:You have to be doingfollowed by the releasing of the objects.I found a useful generic template that can help implement the correct disposal pattern for COM objects, that need Marshal.ReleaseComObject called when they go out of scope:Usage:Template:Reference:http://www.deez.info/sengelha/2005/02/11/useful-idisposable-class-3-autoreleasecomobject/I cant believe this problem has haunted the world for 5 years.... If you have created an application, you need to shut it down first before removing the link.when closingWhen you new an excel application, it opens a excel program in the background. You need to command that excel program to quit before you release the link because that excel program is not part of your direct control. Therefore, it will stay open if the link is released!Good programming everyone~~Common developers, none of your solutions worked for me, \nso I decide to implement a new trick.First let specify "What is our goal?" => "Not to see excel object after our job in task manager" Ok. Let no to challenge and start destroying it, but consider not to destroy other instance os Excel which are running in parallel.So , get the list of current processors and fetch PID of EXCEL processes , then once your job is done, we have a new guest in processes list with a unique PID ,find and destroy just that one.< keep in mind any new excel process during your excel job will be detected as new and destroyed >\n < A better solution is to capture PID of new created excel object and just destroy that>This resolves my issue, hope yours too.First - you never have to call Marshal.ReleaseComObject(...) or Marshal.FinalReleaseComObject(...) when doing Excel interop. It is a confusing anti-pattern, but any information about this, including from Microsoft, that indicates you have to manually release COM references from .NET is incorrect. The fact is that the .NET runtime and garbage collector correctly keep track of and clean up COM references. For your code, this means you can remove the whole `while (...) loop at the top.Second, if you want to ensure that the COM references to an out-of-process COM object are cleaned up when your process ends (so that the Excel process will close), you need to ensure that the garbage collector runs. You do this correctly with calls to GC.Collect() and GC.WaitForPendingFinalizers(). Calling this twice is safe, and ensures that cycles are definitely cleaned up too (though I\'m not sure it\'s needed, and would appreciate an example that shows this).Third, when running under the debugger, local references will be artificially kept alive until the end of the method (so that local variable inspection works). So  GC.Collect() calls are not effective for cleaning object like rng.Cells from the same method. You should split the code doing the COM interop from the GC cleanup into separate methods. (This was a key discovery for me, from one part of the answer posted here by @nightcoder.)The general pattern would thus be:There is a lot of false information and confusion about this issue, including many posts on MSDN and on Stack Overflow (and especially this question!).What finally convinced me to have a closer look and figure out the right advice was blog post Marshal.ReleaseComObject Considered Dangerous together with finding the issue with references kept alive under the debugger that was confusing my earlier testing.The accepted answer here is correct, but also take note that not only "two dot" references need to be avoided, but also objects that are retrieved via the index.  You also do not need to wait until you are finished with the program to clean up these objects, it\'s best to create functions that will clean them up as soon as you\'re finished with them, when possible.  Here is a function I created that assigns some properties of a Style object called xlStyleHeader:Notice that I had to set xlBorders[Excel.XlBordersIndex.xlEdgeBottom] to a variable in order to clean that up (Not because of the two dots, which refer to an enumeration which does not need to be released, but because the object I\'m referring to is actually a Border object that does need to be released).This sort of thing is not really necessary in standard applications, which do a great job of cleaning up after themselves, but in ASP.NET applications, if you miss even one of these, no matter how often you call the garbage collector, Excel will still be running on your server.  It requires a lot of attention to detail and many test executions while monitoring the Task Manager when writing this code, but doing so saves you the hassle of desperately searching through pages of code to find the one instance you missed.  This is especially important when working in loops, where you need to release EACH INSTANCE of an object, even though it uses the same variable name each time it loops.To add to reasons why Excel does not close, even when you create direct refrences to each object upon read, creation, is the \'For\' loop.This sure seems like it has been over-complicated. From my experience, there are just three key things to get Excel to close properly:1: make sure there are no remaining references to the excel application you created (you should only have one anyway; set it to null)2: call GC.Collect()3: Excel has to be closed, either by the user manually closing the program, or by you calling Quit on the Excel object. (Note that Quit will function just as if the user tried to close the program, and will present a confirmation dialog if there are unsaved changes, even if Excel is not visible. The user could press cancel, and then Excel will not have been closed.)1 needs to happen before 2, but 3 can happen anytime.One way to implement this is to wrap the interop Excel object with your own class, create the interop instance in the constructor, and implement IDisposable with Dispose looking something likeThat will clean up excel from your program\'s side of things. Once Excel is closed (manually by the user or by you calling Quit) the process will go away. If the program has already been closed, then the process will disappear on the GC.Collect() call.(I\'m not sure how important it is, but you may want a GC.WaitForPendingFinalizers() call after the GC.Collect() call but it is not strictly necessary to get rid of the Excel process.)This has worked for me without issue for years. Keep in mind though that while this works, you actually have to close gracefully for it to work. You will still get accumulating excel.exe processes if you interrupt your program before Excel is cleaned up (usually by hitting "stop" while your program is being debugged).After tryingthe final solution that works for me is to move one set ofthat we added to the end of the function to a wrapper, as follows:I\'ve traditionally followed the advice found in VVS\'s answer.  However, in an effort to keep this answer up-to-date with the latest options, I think all my future projects will use the "NetOffice" library, available on CodePlex.NetOffice is a complete replacement for the Office PIAs and is completely version-agnostic. It\'s a collection of Managed COM wrappers that can handle the cleanup that often causes such headaches when working with Microsoft Office in .NET.Some key features are:\n - Mostly version-independent (and version-dependant features are documented)\n - No dependencies\n - No PIA\n - No registration\n - No VSTOI am in no way affiliated with the project; I just genuinely appreciate the stark reduction in headaches.You need to be aware that Excel is very sensitive to the culture you are running under as well.You may find that you need to set the culture to EN-US before calling Excel functions.\nThis does not apply to all functions - but some of them.This applies even if you are using VSTO.For details: http://support.microsoft.com/default.aspx?scid=kb;en-us;Q320369"Never use two dots with COM objects" is a great rule of thumb to avoid leakage of COM references, but Excel PIA can lead to leakage in more ways than apparent at first sight.One of these ways is subscribing to any event exposed by any of the Excel object model\'s COM objects.For example, subscribing to the Application class\'s WorkbookOpen event.COM classes expose a group of events through call-back interfaces. In order to subscribe to events, the client code can simply register an object implementing the call-back interface and the COM class will invoke its methods in response to specific events. Since the call-back interface is a COM interface, it is the duty of the implementing object to decrement the reference count of any COM object it receives (as a parameter) for any of the event handlers.Excel PIA exposes COM events of Excel Application class as conventional .NET events. Whenever the client code subscribes to a .NET event (emphasis on \'a\'), PIA creates an instance of a class implementing the call-back interface and registers it with Excel.Hence, a number of call-back objects get registered with Excel in response to different subscription requests from the .NET code. One call-back object per event subscription.A call-back interface for event handling means that, PIA has to subscribe to all interface events for every .NET event subscription request. It cannot pick and choose. On receiving an event call-back, the call-back object checks if the associated .NET event handler is interested in the current event or not and then either invokes the handler or silently ignores the call-back.All these call-back objects do not decrement the reference count of any of the COM objects they receive (as parameters) for any of the call-back methods (even for the ones that are silently ignored). They rely solely on the CLR garbage collector to free up the COM objects.Since GC run is non-deterministic, this can lead to the holding off of Excel process for a longer duration than desired and create an impression of a \'memory leak\'.The only solution as of now is to avoid the PIA\xe2\x80\x99s event provider for the COM class and write your own event provider which deterministically releases COM objects.For the Application class, this can be done by implementing the AppEvents interface and then registering the implementation with Excel by using IConnectionPointContainer interface. The Application class (and for that matter all COM objects exposing events using callback mechanism) implements the IConnectionPointContainer interface.As others have pointed out, you need to create an explicit reference for every Excel object you use, and call Marshal.ReleaseComObject on that reference, as described in this KB article.  You also need to use try/finally to ensure ReleaseComObject is always called, even when an exception is thrown.  I.e. instead of:you need to do something like:You also need to call Application.Quit before releasing the Application object if you want Excel to close.As you can see, this quickly becomes extremely unwieldy as soon as you try to do anything even moderately complex.  I have successfully developed .NET applications with a simple wrapper class that wraps a few simple manipulations of the Excel object model (open a workbook, write to a Range, save/close the workbook etc).  The wrapper class implements IDisposable, carefully implements Marshal.ReleaseComObject on every object it uses, and does not pubicly expose any Excel objects to the rest of the app.But this approach doesn\'t scale well for more complex requirements.  This is a big deficiency of .NET COM Interop.  For more complex scenarios, I would seriously consider writing an ActiveX DLL in VB6 or other unmanaged language to which you can delegate all interaction with out-proc COM objects such as Office.  You can then reference this ActiveX DLL from your .NET application, and things will be much easier as you will only need to release this one reference.I followed this exactly... But I still ran into issues 1 out of 1000 times. Who knows why. Time to bring out the hammer...Right after the Excel Application class is instantiated I get a hold of the Excel process that was just created.Then once I\'ve done all the above COM clean-up, I make sure that process isn\'t running. If it is still running, kill it!\xc2\xa8\xc2\xb0\xc2\xba\xc2\xa4\xc3\xb8\xe2\x80\x9e\xc2\xb8 Shoot Excel proc and chew bubble gum \xc2\xb8\xe2\x80\x9e\xc3\xb8\xc2\xa4\xc2\xba\xc2\xb0\xc2\xa8When all the stuff above didn\'t work, try giving Excel some time to close its sheets:Make sure that you release all objects related to Excel!I spent a few hours by trying several ways. All are great ideas but I finally found my mistake: If you don\'t release all objects, none of the ways above can help you like in my case. Make sure you release all objects including range one!The options are together here.The two dots rule did not work for me. In my case I created a method to clean my resources as follows:You should be very careful using Word/Excel interop applications. After trying all the solutions we still had a lot of "WinWord" process left open on server (with more than 2000 users).After working on the problem for hours, I realized that if I open more than a couple of documents using Word.ApplicationClass.Document.Open() on different threads simultaneously, IIS worker process (w3wp.exe) would crash leaving all WinWord processes open!So I guess there is no absolute solution to this problem, but switching to other methods such as Office Open XML development.A great article on releasing COM objects is 2.5 Releasing COM Objects (MSDN).The method that I would advocate is to null your Excel.Interop references if they are non-local variables, and then call GC.Collect() and GC.WaitForPendingFinalizers() twice. Locally scoped Interop variables will be taken care of automatically.This removes the need to keep a named reference for every COM object.Here\'s an example taken from the article:These words are straight from the article:In almost all situations, nulling the RCW reference and forcing a garbage collection will clean up properly. If you also call GC.WaitForPendingFinalizers, garbage collection will be as deterministic as you can make it. That is, you\'ll be pretty sure exactly when the object has been cleaned up\xe2\x80\x94on the return from the second call to WaitForPendingFinalizers. As an alternative, you can use Marshal.ReleaseComObject. However, note that you are very unlikely to ever need to use this method.My solutionThe accepted answer did not work for me. The following code in the destructor did the job.I think that some of that is just the way that the framework handles Office applications, but I could be wrong. On some days, some applications clean up the processes immediately, and other days it seems to wait until the application closes. In general, I quit paying attention to the details and just make sure that there aren\'t any extra processes floating around at the end of the day.Also, and maybe I\'m over simplifying things, but I think you can just...Like I said earlier, I don\'t tend to pay attention to the details of when the Excel process appears or disappears, but that usually works for me.  I also don\'t like to keep Excel processes around for anything other than the minimal amount of time, but I\'m probably just being paranoid on that.As some have probably already written, it\'s not just important how you close the Excel (object); it\'s also important how you open it and also by the type of the project.In a WPF application, basically the same code is working without or with very few problems.I have a project in which the same Excel file is being processed several times for different parameter value - e.g. parsing it based on values inside a generic list. I put all Excel-related functions into the base class, and parser into a subclass (different parsers use common Excel functions). I didn\'t want that Excel is opened and closed again for each item in a generic list, so I\'ve opened it only once in the base class and close it in the subclass. I had problems when moving the code into a desktop application. I\'ve tried many of the above mentioned solutions. GC.Collect() was already implemented before, twice as suggested.Then I\'ve decided that I will move the code for opening Excel to a subclass. Instead of opening only once, now I create a new object (base class) and open Excel for every item and close it at the end. There is some performance penalty, but based on several tests Excel processes are closing without problems (in debug mode), so also temporary files are removed. I will continue with testing and write some more if I will get some updates.The bottom line is: You must also check the initialize code, especially if you have many classes, etc.Use:Declare it, add code in the finally block: