I have a project with a Git submodule. It is from an ssh://... URL, and is on commit A. Commit B has been pushed to that URL, and I want the submodule to retrieve the commit, and change to it.Now, my understanding is that git submodule update should do this, but it doesn\'t. It doesn\'t do anything (no output, success exit code). Here\'s an example:I\'ve also tried git fetch mod, which appears to do a fetch (but can\'t possibly, because it\'s not prompting for a password!), but git log and git show deny the existence of new commits. Thus far I\'ve just been rm-ing the module and re-adding it, but this is both wrong in principle and tedious in practice.The git submodule update command actually tells Git that you want your submodules to each check out the commit already specified in the index of the superproject.  If you want to update your submodules to the latest commit available from their remote, you will need to do this directly in the submodules.So in summary:Or, if you\'re a busy person:Git 1.8.2 features a new option --remote that will enable exactly this behavior. Runningwill fetch the latest changes from upstream in each submodule, merge them in, and check out the latest revision of the submodule. As the docs put it:This option is only valid for the update command. Instead of using the superproject\xe2\x80\x99s recorded SHA-1 to update the submodule, use the status of the submodule\xe2\x80\x99s remote-tracking branch.This is equivalent to running git pull in each submodule, which is generally exactly what you want.in your project parent directory run: or if you have recursive submodules run:sometimes this still doesn\'t work it is because somehow you have local changes in the local submodule directory while the submodule is being updated.Most of the time the local change might not be the one you want to commit. It can happen due to a file deletion in your submodule etc. If so, do a reset in your local submodule directory and in your project parent directory run again:Your main project points to a particular commit that the submodule should be at.  What git submodule update does is to try to checkout that commit in each submodule that has been initialized.  The submodule is really an independent repository - just creating a new commit in the submodule and pushing that isn\'t enough, you also need to explicitly add the new version of the submodule in the main project.So, in your case, you should find the right commit in the submodule - let\'s assume that\'s the tip of master:Now go back to the main project, stage the submodule and commit that:Now push your new version of the main project:From this point on, if anyone else updates their main project, then git submodule update for them will update the submodule, assuming it\'s been initialized.Seems like 2 different scenarios are being mixed together in this discussion:Scenario 1Using my parent repo\'s pointers to submodules, I want to check out the commit in each submodule, that the parent repo is pointing to, possibly after first iterating through all submodules and updating/pulling these from remote.This is, as pointed out, done withScenario 2, which I think is what OP is aiming atNew stuff has happened in 1 or more submodules, and I want to 1) pull these changes and 2) update the parent repo to point to the HEAD (latest) commit of this/these submodules.This would be done byNot very practical, since you would have to hardcode n paths to all n submodules in e.g. a script to update the parent repo\'s commit pointers.What would be cool would be for an automated iteration through each submodule, updating the parent repo pointer (using git add) to point to the head of the submodule(s).For this, I made this small bash-script:git-update-submodules.shTo run it, executeElaborationFirst of all, I assume that the branch with name $BRANCH (2nd argument) exists on all repo\'s. Feel free to make this even more complex.First couple sections is some checking that the arguments are there. Then I pull the parent repo\'s latest stuff (I prefer to use --ff (fast-forwarding) whenever I\'m just doing pulls. I have rebase off, btw). Then some submodule initializing, might be necessary, if new submodules have been added or are not initialized yet:Then I update/pull all submodules:Notice a few things: First of all, I\'m chaining some git commands using && - meaning previous command must execute w/o error.After possible successful pull (if new stuff was found on the remote), I do a push to ensure, that a possible merge-commit is not left behind on the client. Again, only happens if a pull actually brought in new stuff. Finally, the final || true is ensuring that script continues on errors. To make this work, everything in the iteration must be wrapped in the double-quotes and the git-commands are wrapped in parantheses (operator precedence).My favourite part:Iterate all submodules - with --quiet, which removes the \'Entering MODULE_PATH\' output. Using \'echo $path\' (must be in single-quotes), the path to the submodule gets written to output.This list of relative submodule paths is captured in an array ($(...)) - finally iterate this and do git add $i to update the parent repo.Finally, a commit with some message explaining that the parent repo was updated. This commit will be ignored by default, if nothing was done. Push this to origin, and you\'re done.I have a script running this in a jenkins-job, that chains to a scheduled automated deployment afterwards, and it works like a charm.I hope this will be of help to someone.@Jason is correct in a way but not entirely.update Update the registered submodules,\n  i.e. clone missing submodules and\n  checkout the commit specified in the\n  index of the containing repository.\n  This will make the submodules HEAD be\n  detached unless --rebase or --merge is\n  specified or the key\n  submodule.$name.update is set to\n  rebase or merge.So, git submodule update does checkout, but thing is, it is to the commit in the index of the containing repository. It does not yet know of the new commit upstream at all. So go to your submodule, get the commit you want and commit the updated submodule state in the main repo and then do the git submodule updateHere\'s an awesome one-liner to update everything to the latest on master:Thanks to Mark JaquithPlain and simple, to fetch the submodules:and now proceed updating them to latest master branch (for example):