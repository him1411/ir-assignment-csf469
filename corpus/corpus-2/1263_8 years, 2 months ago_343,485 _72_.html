I have some questions regarding the usage and significance of the synchronized keyword. The synchronized keyword is all about different threads reading and writing to the same variables, objects and resources.  This is not a trivial topic in Java, but here is a quote from Sun:synchronized methods enable a simple\n  strategy for preventing thread\n  interference and memory consistency\n  errors: if an object is visible to\n  more than one thread, all reads or\n  writes to that object\'s variables are\n  done through synchronized methods.In a very, very small nutshell: When you have two threads that are reading and writing to the same \'resource\', say a variable named foo, you need to ensure that these threads access the variable in an atomic way.  Without the synchronized keyword, your thread 1 may not see the change thread 2 made to foo, or worse, it may only be half changed.  This would not be what you logically expect.Again, this is a non-trivial topic in Java.  To learn more, explore topics here on SO and the Interwebs  about:Keep exploring these topics until the name "Brian Goetz" becomes permanently associated with the term "concurrency" in your brain.  Well, I think we had enough of theoretical explanations, so consider this codeNote: synchronized blocks the next thread\'s call to method test() as long as the previous thread\'s execution is not finished. Threads can access this method one at a time. Without synchronized all threads can access this method simultaneously.When a thread calls the synchronized method \'test\' of the object (here object is an instance of \'TheDemo\' class) it acquires the lock of that object, any new thread cannot call ANY synchronized method of the same object as long as previous thread which had acquired the lock does not release the lock.Similar thing happens when any static synchronized method of the class is called. The thread acquires the lock associated with the class(in this case any non static synchronized method of an instance of that class can be called by any thread because that object level lock is still available). Any other thread will not be able to call any static synchronized method of the class as long as the class level lock is not released by the thread which currently holds the lock.Output with synchronisedOutput without synchronizedThe synchronized keyword prevents concurrent access to a block of code or object by multiple Threads.  By default, a Hashtable is synchronized, so only one thread can access the table at a time.  On usage of non-synchronized constructs like HashMap,you must build thread safety features in your code to prevent memory consistency errors.synchronized means that in a multi threaded environment, an object having  synchronized method(s)/block(s) does not let two threads to access the synchronized method(s)/block(s) of code at the same time. This means that one thread can\'t read while another thread updates it.The second thread will instead wait until the first thread completes its execution. The overhead is speed, but the advantage is guaranteed consistency of data.If your application is single threaded though, synchronized blocks does not provide benefits.The synchronized keyword causes a thread to obtain a lock when entering the method, so that only one thread can execute the method at the same time (for the given object instance, unless it is a static method).This is frequently called making the class thread-safe, but I would say this is a euphemism. While it is true that synchronization protects the internal state of the Vector from getting corrupted, this does not usually help the user of Vector much. Consider this:Even though the methods involved are synchronized, because they are being locked and unlocked individually, two unfortunately timed threads can create a vector with two elements.So in effect, you have to synchronize in your application code as well.Because method-level synchronization is a) expensive when you don\'t need it and b) insufficient when you need synchronization, there are now un-synchronized replacements (ArrayList in the case of Vector).More recently, the concurrency package has been released, with a number of clever utilities that take care of multi-threading issues.Synchronized keyword in Java has to do with thread-safety, that is, when multiple threads read or write the same variable.\nThis can happen directly (by accessing the same variable) or indirectly (by using a class that uses another class that accesses the same variable).The synchronized keyword is used to define a block of code where multiple threads can access the same variable in a safe way.Syntax-wise the synchronized keyword takes an Object as it\'s parameter (called a lock object), which is then followed by a { block of code }.When execution encounters this keyword, the current thread tries to "lock/acquire/own" (take your pick) the lock object and execute the associated block of code after the lock has been acquired.Any writes to variables inside the synchronized code block are guaranteed to be visible to every other thread that similarly executes code inside a synchronized code block using the same lock object.Only one thread at a time can hold the lock, during which time all other threads trying to acquire the same lock object will wait (pause their execution). The lock will be released when execution exits the synchronized code block.Adding synchronized keyword to a method definition is equal to the entire method body being wrapped in a synchronized code block with the lock object being this (for instance methods) and ClassInQuestion.getClass() (for class methods).- Instance method is a method which does not have static keyword.\n- Class method is a method which has static keyword.Without synchronization, it is not guaranteed in which order the reads and writes happen, possibly leaving the variable with garbage.\n(For example a variable could end up with half of the bits written by one thread and half of the bits written by another thread, leaving the variable in a state that neither of the threads tried to write, but a combined mess of both.)It is not enough to complete a write operation in a thread before (wall-clock time) another thread reads it, because hardware could have cached the value of the variable, and the reading thread would see the cached value instead of what was written to it.Thus in Java\'s case, you have to follow the Java Memory Model to ensure that threading errors do not happen.\nIn other words: Use synchronization, atomic operations or classes that use them for you under the hoods.http://docs.oracle.com/javase/specs/jls/se8/html/index.html\n  Java\xc2\xae Language Specification, 2015-02-13Think of it as a kind of turnstile like you might find at a football ground. There are parallel steams of people wanting to get in but at the turnstile they are \'synchronised\'. Only one person at a time can get through. All those wanting to get through will do, but they may have to wait until they can go through.What is the synchronized keyword?Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: thread interference and memory consistency errors. The tool needed to prevent these errors is synchronization. Synchronized blocks or methods prevents thread interference and make sure that data is consistent. At any point of time, only one thread can access a synchronized block or method (critical section) by acquiring a lock. Other thread(s) will wait for release of lock to access critical section. When are methods synchronized?Methods are synchronized when you add synchronized to method definition or declaration. You can also synchronize a particular block of code with-in a method. What does it mean pro grammatically and logically?It means that only one thread can access critical section by acquiring a lock. Unless this thread release this lock, all other thread(s) will have to wait to acquire a lock. They don\'t have access to enter critical section with out acquiring lock.This can\'t be done with a magic. It\'s programmer  responsibility to identify critical section(s) in application and guard it accordingly. Java provides a framework to guard your application, but where and what all sections to be guarded is the responsibility of programmer.More details from java documentation pageIntrinsic Locks and Synchronization:Synchronization is built around an internal entity known as the intrinsic lock or monitor lock. Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object\'s state and establishing happens-before relationships that are essential to visibility.Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object\'s fields has to acquire the object\'s intrinsic lock before accessing them, and then release the intrinsic lock when it\'s done with them.A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock. Making methods synchronized has two effects:First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads.Look for other alternatives to synchronization in :Avoid synchronized(this) in Java?To my understanding synchronized basically means that the compiler write a monitor.enter and monitor.exit around your method. As such it may be thread safe depending on how it is used (what I mean is you can write an object with synchronized methods that isn\'t threadsafe depending on what your class does).I know that you have already gotten your answer . I write this, only to help the people who have the same question and are looking up this page for an answer . \nhere is an  explanation from java documentation : \nConsider the following code : if count is an instance of   SynchronizedCounter then making these methods synchronized has two effects:synchronized simple means no two threads can access the block/method simultaneously. When we say any block/method of a class is synchronized it means only one thread can access them at a time. Internally the thread which tries to access it first take a lock on that object and as long as this lock is not available no other thread can access any of the synchronized methods/blocks of that instance of the class.Note another thread can access a method of the same object which is not defined to be synchronized. A thread can release the lock by callingSynchronized simply means that multiple threads if associated with single object can prevent dirty read and write if synchronized block is used on particular object. To give you more clarity , lets take an example :We\'ve created two MyRunnable class objects , runnable1 being shared with thread 1 and thread 3 & runnable2 being shared with thread 2 only.\nNow when t1 and t3 starts without synchronized being used , PFB output which suggest that both threads 1 and 3 simultaneously affecting var value where for thread 2 , var has its own memory.Using Synchronzied, thread 3 waiting for thread 1 to complete in all scenarios. There are two locks acquired , one on runnable1 shared by thread 1 and thread 3 and another on runnable2 shared by thread 2 only.What the other answers are missing is one important aspect: memory barriers. Thread synchronization basically consists of two parts: serialization and visibility. I advise everyone to google for "jvm memory barrier", as it is a non-trivial and extremely important topic (if you modify shared data accessed by multiple threads). Having done that, I advise looking at java.util.concurrent package\'s classes that help to avoid using explicit synchronization, which in turn helps keeping programs simple and efficient, maybe even preventing deadlocks.One such example is ConcurrentLinkedDeque. Together with the command pattern it allows to create highly efficient worker threads by stuffing the commands into the concurrent queue -- no explicit synchronization needed, no deadlocks possible, no explicit sleep() necessary, just poll the queue by calling take().In short: "memory synchronization" happens implicitly when you start a thread, a thread ends, you read a volatile variable, you unlock a monitor (leave a synchronized block/function) etc. This "synchronization" affects (in a sense "flushes") all writes done before that particular action. In the case of the aforementioned ConcurrentLinkedDeque, the documentation "says":Memory consistency effects: As with other concurrent collections,\n  actions in a thread prior to placing an object into a\n  ConcurrentLinkedDeque happen-before actions subsequent to the access\n  or removal of that element from the ConcurrentLinkedDeque in another\n  thread.This implicit behavior is a somewhat pernicious aspect because most Java programmers without much experience will just take a lot as given because of it. And then suddenly stumble over this thread after Java isn\'t doing what it is "supposed" to do in production where there is a different work load -- and it\'s pretty hard to test concurrency issues.synchronized is a keyword in Java which is used to make happens before relationship in multithreading environment to avoid memory inconsistency and thread interference error.