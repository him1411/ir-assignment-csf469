What is POSIX? I read the Wikipedia article and I read it ever time I encounter the term. Fact is that I never really understood what it is.Can anyone please explain it to me by explaining "the need for POSIX" too?POSIX is a family of standards, specified by the IEEE, to clarify and make uniform the application programming interfaces (and ancillary issues, such as commandline shell utilities) provided by Unix-y operating systems.  When you write your programs to rely on POSIX standards, you can be pretty sure to be able to port them easily among a large family of Unix derivatives (including Linux, but not limited to it!); if and when you use some Linux API that\'s not standardized as part of Posix, you will have a harder time if and when you want to port that program or library to other Unix-y systems (e.g., MacOSX) in the future.Most important things POSIX 7 definesC APIGreatly extends ANSI C with things like:Those APIs also determine underlying system concepts on which they depend, e.g. fork requires a concept of a process.Many Linux system calls exist to implement a specific POSIX C API function and make Linux compliant, e.g. sys_write, sys_read, ...Major Linux desktop implementation: glibc, which in many cases just provides a shallow wrapper to system calls.CLI utilitiesE.g.: cd, ls, echo, ...Many utilities are direct shell front ends for a corresponding C API function, e.g. mkdir.Major Linux desktop implementation: GNU Coreutils for the small ones, separate GNU projects for the big ones: sed, grep, awk, ... Some CLI utilities are implemented by Bash as built-ins.Shell languageE.g., a=b; echo "$a"Major Linux desktop implementation: GNU Bash.Environment variablesE.g.: HOME, PATH.Program exit statusANSI C says 0 or EXIT_SUCCESS for success, EXIT_FAILURE for failure, and leaves the rest implementation defined.POSIX adds:126: command found but not executable.127: command not found.> 128: terminated by a signal.But POSIX does not seem to specify the 128 + SIGNAL_ID rule used by Bash: https://unix.stackexchange.com/questions/99112/default-exit-code-when-process-is-terminatedRegular expressionThere are two types: BRE (Basic) and ERE (Extended). Basic is deprecated and only kept to not break APIs.Those are implemented by C API functions, and used throughout CLI utilities, e.g. grep accepts BREs by default, and EREs with -E.E.g.: echo \'a.1\' | grep -E \'a.[[:digit:]]\'Major Linux implementation: glibc implements the functions under regex.h which programs like grep can use as backend.Directory strutureE.g.: /dev/null, /tmpThe Linux FHS greatly extends POSIX.FilenamesSee also: what is posix compliance for filesystem?Command line utility API conventionsNot mandatory, used by POSIX, but almost nowhere else, notably not in GNU. But true, it is too restrictive, e.g. single letter flags only (e.g. -a), no double hyphen long versions (e.g. --all).A few widely used conventions:See also: Are there standards for Linux command line switches and arguments?Who conforms to POSIX?Many systems follow POSIX closely, but few are actually certified by the Open Group which maintains the standard. Notable certified ones include:Most Linux distros are very compliant, but not certified because they don\'t want to pay the compliance check.See the wiki page.WindowsWindows implemented POSIX on some of its professional distributions. Since it was an optional feature, programmers could not rely on it for most end user applications. Support was deprecated in Windows 8:In 2016 a new official Linux-like API called "Windows Subsystem for Linux" was announced. It includes Linux system calls, ELF running, parts of the /proc filesystem, Bash, GCC, (TODO likely glibc?), apt-get and more: https://channel9.msdn.com/Events/Build/2016/P488 so I believe that it will allow Windows to run much, if not all, of POSIX. However, it is focused on developers / deployment instead of end users. In particular, there were no plans to allow access to the Windows GUI. Historical overview of the official Microsoft POSIX compatibility: http://brianreiter.org/2010/08/24/the-sad-history-of-the-microsoft-posix-subsystem/Cygwin is a well known GPL third-party project for that "provides substantial POSIX API functionality" for Windows, but requires that you "rebuild your application from source if you want it to run on Windows". MSYS2 is a related project that seems to add more functionality on top of Cygwin.Bonus levelThe Linux Standard Base further extends POSIX.Use the non-frames indexes, they are much more readable and searchable: http://pubs.opengroup.org/onlinepubs/9699919799/nfindex.htmlGet a full zipped version of the HTML pages for grepping:  Is there a listing of the POSIX API / functions?POSIX is:POSIX (pronounced /\xcb\x88p\xc9\x92z\xc9\xaaks/) or\n  "Portable Operating System Interface\n  [for Unix]"1 is the name of a family\n  of related standards specified by the\n  IEEE to define the application\n  programming interface (API), along\n  with shell and utilities interfaces\n  for software compatible with variants\n  of the Unix operating system, although\n  the standard can apply to any\n  operating system.Basically it was a set of measures to ease the pain of development and usage of different flavours of UNIX by having a (mostly) common API and utilities. Limited POSIX compliance also extended to various versions of Windows.Let me give the churlish "unofficial" explanation.POSIX is a set of standards which attempts to distinguish "UNIX" and UNIX-like systems from those which are incompatible with them.  It was created by the U.S. government for procurement purposes.  The idea was that the U.S. federal procurements needed a way to legally specify the requirements for various sorts of bids and contracts in a way that could be used to exclude systems to which a given existing code base or programming staff would NOT be portable.Since POSIX was written post facto ... to describe a loosely similar set of competing systems ... it was NOT written in a way that could be implemented.So, for example, Microsoft\'s NT was written with enough POSIX conformance to qualify for some bids ... even though the POSIX subsystem was essentially useless in terms of practical portability and compatibility with UNIX systems.Various other standards for UNIX have been written over the decades.  Things like the SPEC1170 (specified eleven hundred and seventy function calls which had to be implemented compatibly) and various incarnations of the SUS (Single UNIX Specification).For the most part these "standards" have been inadequate to any practical technical application.  They most exist for argumentation, legal wrangling and other dysfunctional reasons.POSIX is a set of standards put forth by IEEE and The Open Group that describes how an ideal Unix would operate. Programmers, users, and administrators can all become familiar with the POSIX document, and expect a POSIX-complaint Unix to provide all of the standard facilities mentioned.Since every Unix does things a little differently -- Solaris, Mac OS X, IRIX, BSD, and Linux all have their quirks -- POSIX is especially useful to those in the industry as it defines a standard environment to operate in.  For example, most of the functions in the C library are based in POSIX; a programmer can, therefore, use one in his application and expect it to behave the same across most Unices.However, the divergent areas of Unix are typically the focus, rather than the standard ones.The great thing about POSIX is that you\'re welcome to read it yourself:The Open Group Base Specifications Issue 7Issue 7 is known as POSIX.1-2008, and there are new things in there -- however, Google-fu for POSIX.1 and such will allow you to see the entire history behind what Unix is.POSIX is a standard for operating systems that was supposed to make it easier to write cross-platform software. It\'s an especially big deal in the world of Unix.In 1985, individuals from companies throughout the computer industry\n  joined together to develop the POSIX (Portable Operating System\n  Interface for Computer Environments) standard, which is based largely\n  on the UNIX System V Interface Definition (SVID) and other earlier\n  standardization efforts. These efforts were spurred by the U.S.\n  government, which needed a standard computing environment to minimize\n  its training and procurement costs. Released in 1988, POSIX is a group\n  of IEEE standards that define the API, shell, and utility interfaces\n  for an operating system. Although aimed at UNIX-like systems, the\n  standards can apply to any compatible operating system. Now that these\n  stan- dards have gained acceptance, software developers are able to\n  develop applications that run on all conforming versions of UNIX,\n  Linux, and other operating systems.From the book: A Practical Guide To LinuxThis standard provides a common basis for Unix-like operating systems. It specifies how the shell should work, what to expect from commands like ls and grep, and a number of C libraries that C authors can expect to have available.For example, the pipes that command-line users use to string together commands are specified in detail here, which means C\xe2\x80\x99s popen (pipe open) function is POSIX-standard, not ISO C-standard.POSIX defines set of standards for an operating system or a program.\nThe goal is to write new software that is compatible with UNIX-like systems.For example a program runs on Linux is also can be compile and run on other UNIX-like systems like Solaris, HP-UX, and AIX etc..The most popular examples are GNU Bash which is 100% POSIX compliance and gawk utility.Posix governs interoperability, portability, and in other areas such as the usage and mechanism of fork, permissions and filesystem standards such as /etc, /var, /usr and so on . Hence, when developers write a program under a Posix compliant system such as for example Linux, it is generally, not always, guaranteed to run on another posix compliant system such as IBM\'s AIX system or other commercial variants of Unix. Posix is a good thing to have as such it eases the software development for maximum portability which it strives for. Hope this answer makes sense. Thanks to Jed Smith & Tinkertim for pointing out my error - my bad!!! :(Posix is more as an OS, it is an "OS standard". You can imagine it as an imaginary OS, which actually doesn\'t exist but it has a documentation. These papers are the "posix standard", defined by the IEEE, which is the big standard organization of the USA.\nThe OSes implementing this specification are "Posix-compliant".Government regulations prefer Posix-compliant solutions in their investments, thus being Posix-compliant has a significant financial advantage, particularly for the big IT companies of the USA.The reward for an OS being fully posix compliant, that it is a guarantee that it will compile and run all Posix-compliant applications seamlessly.Linux is the most well-known one. OSX, Solaris, NetBSD and Windows NT play here as well. Free- and OpenBSD are only "nearly" Posix-compliant. The posix-compliance of the WinNT is only a pseudo-solution to avoid this government regulation above.When you write your programs to rely on POSIX standards, you can be pretty sure to be able to port them easily among a large family of Unix derivatives (including Linux, but not limited to it!); if and when you use some Linux API that\'s not standardized as part of Posix, you will have a harder time if and when you want to port that program or library to other Unix-y systems (e.g., MacOSX) in the future.