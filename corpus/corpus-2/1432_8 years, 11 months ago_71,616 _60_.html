In many C/C++ macros I\'m seeing the code of the macro wrapped in what seems like a meaningless do while loop.  Here are examples.I can\'t see what the do while is doing.  Why not just write this without it?The do ... while and if ... else are there to make it so that a\nsemicolon after your macro always means the same thing.  Let\'s say you\nhad something like your second macro.Now if you were to use BAR(X); in an if ... else statement, where the bodies of the if statement were not wrapped in curly brackets, you\'d get a bad surprise.The above code would expand intowhich is syntactically incorrect, as the else is no longer associated with the if.  It doesn\'t help to wrap things in curly braces within the macro, because a semicolon after the braces is syntactically incorrect.There are two ways of fixing the problem.  The first is to use a comma to sequence statements within the macro without robbing it of its ability to act like an expression.The above version of bar BAR expands the above code into what follows, which is syntactically correct.This doesn\'t work if instead of f(X) you have a more complicated body of code that needs to go in its own block, say for example to declare local variables.  In the most general case the solution is to use something like do ... while to cause the macro to be a single statement that takes a semicolon without confusion.You don\'t have to use do ... while, you could cook up something with if ... else as well, although when if ... else expands inside of an if ... else it leads to a "dangling else", which could make an existing dangling else problem even harder to find, as in the following code.The point is to use up the semicolon in contexts where a dangling semicolon is erroneous.  Of course, it could (and probably should) be argued at this point that it would be better to declare BAR as an actual function, not a macro.In summary, the do ... while is there to work around the shortcomings of the C preprocessor.  When those C style guides tell you to lay off the C preprocessor, this is the kind of thing they\'re worried about.Macros are copy/pasted pieces of text the pre-processor will put in the genuine code; the macro\'s author hopes the replacement will produce valid code.There are three good "tips" to succeed in that:Normal code is usually ended by a semi-colon. Should the user view code not needing one...This means the user expects the compiler to produce an error if the semi-colon is absent.But the real real good reason is that at some time, the macro\'s author will perhaps need to replace the macro with a genuine function (perhaps inlined). So the macro should really behave like one.So we should have a macro needing semi-colon.As shown in jfm3\'s answer, sometimes the macro contains more than one instruction. And if the macro is used inside a if statement, this will be problematic:This macro could be expanded as:The g function will be executed regardless of the value of bIsOk.This means that we must have to add a scope to the macro:If the macro is something like:We could have another problem in the following code:Because it would expand as:This code won\'t compile, of course. So, again, the solution is using a scope:The code behaves correctly again.There is one C/C++ idiom that produces this effect: The do/while loop:The do/while can create a scope, thus encapsulating the macro\'s code, and needs a semi-colon in the end, thus expanding into code needing one.The bonus?The C++ compiler will optimize away the do/while loop, as the fact its post-condition is false is known at compile time. This means that a macro like:will expand correctly asand is then compiled and optimized away as@jfm3 - You have a nice answer to the question.  You might also want to add that the macro idiom also prevents the possibly more dangerous (because there\'s no error) unintended behavior with simple \'if\' statements:expands to:which is syntactically correct so there\'s no compiler error, but has the probably unintended consequence that g() will always be called.The above answers explain the meaning of these constructs, but there is a significant difference between the two that was not mentioned. In fact, there is a reason to prefer the do ... while to the if ... else construct.The problem of the if ... else construct is that it does not force you to put the semicolon. Like in this code:Although we left out the semicolon (by mistake), the code will expand toand will silently compile (although some compilers may issue a warning for unreachable code). But the printf statement will never be executed.do ... while construct does not have such problem, since the only valid token after the while(0) is a semicolon.While it is expected that compilers optimize away the do { ... } while(false); loops, there is another solution which would not require that construct. The solution is to use the comma operator:or even more exotically:While this will work well with separate instructions, it will not work with cases where variables are constructed and used as part of the #define :With this one would be forced to use the do/while construct.Jens Gustedt\'s P99 preprocessor library (yes, the fact that such a thing exists blew my mind too!) improves on the if(1) { ... } else construct in a small but significant way by defining the following:The rationale for this is that, unlike the do { ... } while(0) construct, break and continue still work inside the given block, but the ((void)0) creates a syntax error if the semicolon is omitted after the macro call, which would otherwise skip the next block.  (There isn\'t actually a "dangling else" problem here, since the else binds to the nearest if, which is the one in the macro.)  If you are interested in the sorts of things that can be done more-or-less safely with the C preprocessor, check out that library.For some reasons I can\'t comment on the first answer...Some of you showed macros with local variables, but nobody mentioned that you can\'t just use any name in a macro! It will bite the user some day! Why? Because the input arguments are substituted into your macro template. And in your macro examples you\'ve use the probably most commonly used variabled name i.For example when the following macrois used in the following functionthe macro will not use the intended variable i, that is declared at the beginning of some_func, but the local variable, that is declared in the do ... while loop of the macro.Thus, never use common variable names in a macro!I don\'t think it was mentioned so consider thiswould be translated intonotice how i++ is evaluated twice by the macro. This can lead to some interesting errors.Better than do {} while (0) and if (1) {} else, one can simply use ({}):And this syntax is compatible with return values (do {} while (0) isn\'t), as in:I have found this trick very helpful is in situations where you have to sequentially process a particular value. At each level of processing, if some error or invalid condition occurs, you can avoid further processing and break out early. e.g.