How do I check whether a variable is an integer?If you need to do this, dounless you are in Python 2.x in which case you wantDo not use type. It is almost never the right answer in Python, since it blocks all the flexibility of polymorphism. For instance, if you subclass int, your new class should register as an int, which type will not do:This adheres to Python\'s strong polymorphism: you should allow any object that behaves like an int, instead of mandating that it be one.The classical Python mentality, though, is that it\'s easier to ask forgiveness than permission. In other words, don\'t check whether x is an integer; assume that it is and catch the exception results if it isn\'t:This mentality is slowly being overtaken by the use of abstract base classes, which let you register exactly what properties your object should have (adding? multiplying? doubling?) by making it inherit from a specially-constructed class. That would be the best solution, since it will permit exactly those objects with the necessary and sufficient attributes, but you will have to read the docs on how to use it.All proposed answers so far seem to miss the fact that a double (floats in python are actually doubles) can also be an integer (if it has nothing after the decimal point).  I use the built-in is_integer() method on doubles to check this.Example (to do something every xth time in a for loop):Edit:You can always convert to a float before calling this method. The three possibilities:Otherwise, you could check if it is an int first like Agostino said:If you really need to check then it\'s better to use abstract base classes rather than concrete classes. For an integer that would mean:This doesn\'t restrict the check to just int, or just int and long, but also allows other user-defined types that behave as integers to work.See here for more.Note that this does not help if you\'re looking for int-like attributes. In this case you may also want to check for long:I\'ve seen checks of this kind against an array/index type in the Python source, but I don\'t think that\'s visible outside of C.Token SO reply: Are you sure you should be checking its type? Either don\'t pass a type you can\'t handle, or don\'t try to outsmart your potential code reusers, they may have a good reason not to pass an int to your function.Rather than over complicate things, why not just a simpleWhy not try something like:it\'s really astounding to see such a heated discussion coming up when such a basic, valid and, i believe, mundane question is being asked. some people have pointed out that type-checking against int (and long) might loose cases where a big decimal number is encountered. quite right.some people have pointed out that you should \'just do x + 1 and see whether that fails. well, for one thing, this works on floats too, and, on the other hand, it\'s easy to construct a class that is definitely not very numeric, yet defines the + operator in some way.i am at odds with many posts vigorously declaring that you should not check for types. well, GvR once said something to the effect that in pure theory, that may be right, but in practice, isinstance often serves a useful purpose (that\'s a while ago, don\'t have the link; you can read what GvR says about related issues in posts like this one).what is funny is how many people seem to assume that the OP\'s intent was to check whether the type of a given x is a numerical integer type\xe2\x80\x94what i understood is what i normally mean when using the OP\'s words: whether x represents an integer number. and this can be very important: like ask someone how many items they\'d want to pick, you may want to check you get a non-negative integer number back. use cases like this abound. it\'s also, in my opinion, important to see that (1) type checking is but ONE\xe2\x80\x94and often quite coarse\xe2\x80\x94measure of program correctness, because (2) it is often bounded values that make sense, and out-of-bounds values that make nonsense. sometimes just some intermittent values make sense\xe2\x80\x94like considering all numbers, only those real (non-complex), integer numbers might be possible in a given case. funny non-one seems to mention checking for x == math.floor( x ). if that should give an error with some big decimal class, well, then maybe it\'s time to re-think OOP paradigms. there is also PEP 357 that considers how to use not-so-obviously-int-but-certainly-integer-like values to be used as list indices. not sure whether i like the solution.A simple method I use in all my software is this. It checks whether the variable is made up of numbers.If you want to check that a string consists of only digits, but converting to an int won\'t help, you can always just use regex.In this case, if x were "hello", converting it to a numeric type would throw a ValueError, but data would also be lost in the process. Using a regex and catching an AttributeError would allow you to confirm numeric characters in a string with, for instance, leading 0\'s.If you didn\'t want it to throw an AttributeError, but instead just wanted to look for more specific problems, you could vary the regex and just check the match:That actually shows you where the problem occurred without the use of exceptions. Again, this is not for testing the type, but rather the characters themselves. This gives you much more flexibility than simply checking for types, especially when converting between types can lose important string data, like leading 0\'s.Found a related question here on SO itself.Python developers prefer to not check types but do a type specific operation and catch a TypeError exception. But if you don\'t know the type then you have the following.why not just check if the value you want to check is equal to itself cast as an integer as shown below?If the variable is entered like a string (e.g. \'2010\'): Before using this I worked it out with try/except and checking for (int(variable)), but it was longer code. I wonder if there\'s any difference in use of resources or speed.use the int function to helpA simple way to do this is to directly check if the remainder on division by 1 is 0 or not.I was writing a program to check if a number was square and I encountered this issue, the \ncode I used was:To tell if the number was an integer I converted the float number you get from square rooting the user input to a rounded integer (stored as the value ), if those two numbers were equal then the first number must have been an integer, allowing the program to respond. This may not be the shortest way of doing this but it worked for me. If you just need the value, operator.index (__index__ special method) is the way to go in my opinion. Since it should work for all types that can be safely cast to an integer. I.e. floats fail, integers, even fancy integer classes that do not implement the Integral abstract class work by duck typing.operator.index is what is used for list indexing, etc. And in my opinion it should be used for much more/promoted.In fact I would argue it is the only correct way to get integer values if you want to be certain that floating points, due to truncating problems, etc. are rejected and it works with all integral types (i.e. numpy, etc.) even if they may not (yet) support the abstract class. This is what __index__ was introduced for!If you want to check with no regard for Python version (2.x vs 3.x), use six (PyPI) and it\'s integer_types attribute:Within six (a very light-weight single-file module), it\'s simply doing this:If you have not int you can do just this:A more general approach that will attempt to check for both integers and integers given as strings will beHere is a simple example how you can determine an integerIf you are reading from a file and you have an array or dictionary with values of multiple datatypes, the following will be useful.\nJust check whether the variable can be type casted to int(or any other datatype you want to enforce) or not. you can do this by:and it will return \'this works\'... but if you change name to int(1) then it will return \'this does not work\' because it is now a string...\nyou can also try:and the same thing will happenThere is another option to do the type check. For example:You can do this.    Consider the case x = n**(1.0/m), where n=10**5, m=5. \nIn Python, x will be 10.000000000000002, which is only not integer because of floating point arithmetic operations.So I\'d checkI\'ve tested it with this code:It outputs True for all a and b.Call this function:This\'ll work to check out whether number is an integer or not 