I know that attributes are extremely useful. There are some predefined ones such as [Browsable(false)] which allows you to hide properties in the properties tab. Here is a good question explaining attributes: What are attributes in .NET?What are the predefined attributes (and their namespace) you actually use in your projects? [DebuggerDisplay] can be really helpful to quickly see customized output of a Type when you mouse over the instance of the Type during debugging. example:This is how it should look in the debugger:alt text http://serialize.wordpress.com/files/2008/10/temp.jpgAlso, it is worth mentioning that [WebMethod] attribute with CacheDuration property set can avoid unnecessary execution of the web service method. System.Obsolete is one of the most useful attributes in the framework, in my opinion. The ability to raise a warning about code that should no longer be used is very useful. I love having a way to tell developers that something should no longer be used, as well as having a way to explain why and point to the better/new way of doing something.The Conditional attribute is pretty handy too for debug usage. It allows you to add methods in your code for debug purposes that won\'t get compiled when you build your solution for release.Then there are a lot of attributes specific to Web Controls that I find useful, but those are more specific and don\'t have any uses outside of the development of server controls from what I\'ve found.[Flags] is pretty handy. Syntactic sugar to be sure, but still rather nice.Leppie points out something I hadn\'t realized, and which rather dampens my enthusiasm for this attribute: it does not instruct the compiler to allow bit combinations as valid values for enumeration variables, the compiler allows this for enumerations regardless. My C++ background showing through... sighI like [DebuggerStepThrough] from System.Diagnostics. It\'s very handy for avoiding stepping into those one-line do-nothing methods or properties (if you\'re forced to work in an early .Net without automatic properties). Put the attribute on a short method or the getter or setter of a property, and you\'ll fly right by even when hitting "step into" in the debugger.For what it\'s worth, here\'s a list of all .NET attributes.  There are several hundred.I don\'t know about anyone else but I have some serious RTFM to do!My vote would be for [Conditional]You can use this to add a function with advanced debugging features; like Debug.Write, it is only called in debug builds, and so allows you to encapsulate complex debug logic outside the main flow of your program.I always use the DisplayName, Description and DefaultValue attributes over public properties of my user controls, custom controls or any class I\'ll edit through a property grid. These tags are used by the .NET PropertyGrid to format the name, the description panel, and bolds values that are not set to the default values.I just wish Visual Studio\'s IntelliSense would take the Description attribute into account if no XML comment are found. It would avoid having to repeat the same sentence twice.[Serializable] is used all the time for serializing and deserializing objects to and from external data sources such as xml or from a remote server. More about it here.In Hofstadtian spirit, the [Attribute] attribute is very useful, since it\'s how you create your own attributes. I\'ve used attributes instead of interfaces to implement plugin systems, add descriptions to Enums, simulate multiple dispatch and other tricks.Here is the post about interesting attribute InternalsVisibleTo. Basically what it does it mimics C++ friends access functionality. It comes very handy for unit testing.I\'ve found [DefaultValue] to be quite useful.I\'d suggest [TestFixture] and [Test] - from the nUnit library.Unit tests in your code provide safety in refactoring and codified documentation.  as this allows you to ignore (in any xml serialisation) \'parent\' objects that would otherwise cause exceptions when saving.It\'s not well-named, not well-supported in the framework, and shouldn\'t require a parameter, but this attribute is a useful marker for immutable classes:I like using the [ThreadStatic] attribute in combination with thread and stack based programming.  For example, if I want a value that I want to share with the rest of a call sequence, but I want to do it out of band (i.e. outside of the call parameters), I might employ something like this.Later in my code, I can use this to provide contextual information out of band to people downstream from my code.  Example:The ThreadStatic attribute allows me to scope the call only to the thread in question avoiding the messy problem of data access across threads.DesignerSerializationVisibilityAttribute is very useful. When you put a runtime property on a control or component, and you don\'t want the designer to serialize it, you use it like this:The DebuggerHiddenAttribute which allows to avoiding step into code which should be not be debugged.Also it prevents from showing methods in stack trace, useful when having a method which just wraps another method:If you now call GetElementAt(new Vector2(10, 10)) and a error occurs at the wrapped method, the call stack is not showing the method which is calling the method which throws the error.I have been using the [DataObjectMethod] lately. It describes the method so you can use your class with the ObjectDataSource ( or other controls).More infoOnly a few attributes get compiler support, but one very interesting use of attributes is in AOP: PostSharp uses your bespoke attributes to inject IL into methods, allowing all manner of abilities... log/trace being trivial examples - but some other good examples are things like automatic INotifyPropertyChanged implementation (here).Some that occur and impact the compiler or runtime directly:For things that are checked manually via reflection - I\'m a big fan of the System.ComponentModel attributes; things like [TypeDescriptionProvider(...)], [TypeConverter(...)],  and [Editor(...)] which can completely change the behavior of types in data-binding scenarios (i.e. dynamic properties etc).If I were to do a code coverage crawl, I think these two would be top:In our current project, we useIt controls accessibility of an individual managed type or member, or of all types within an assembly, to COM.More InfoTells the designer to expand the properties which are classes (of your control)Instructs obfuscation tools to take the specified actions for an assembly, type, or member. (Although typically you use an Assembly level [assembly:ObfuscateAssemblyAttribute(true)]The attributes I use the most are the ones related to XML Serialization.XmlRootXmlElementXmlAttributeetc...Extremely useful when doing any quick and dirty XML parsing or serializing.Being a middle tier developer I likeSystem.ComponentModel.EditorBrowsableAttribute Allows me to hide properties so that the UI developer is not overwhelmed with properties that they don\'t need to see.System.ComponentModel.BindableAttribute Some things don\'t need to be databound. Again, lessens the work the UI developers need to do.I also like the DefaultValue that Lawrence Johnston mentioned.System.ComponentModel.BrowsableAttribute and the Flags are used regularly.I use \nSystem.STAThreadAttribute\n      System.ThreadStaticAttribute\nwhen needed.By the way. I these are just as valuable for all the .Net framework developers.Off the top of my head, here is a quick list, roughly sorted by frequency of use, of predefined attributes I actually use in a big project (~500k LoCs):Flags, Serializable, WebMethod, COMVisible, TypeConverter, Conditional, ThreadStatic, Obsolete, InternalsVisibleTo, DebuggerStepThrough.[EditorBrowsable(EditorBrowsableState.Never)] allows you to hide properties and methods from IntelliSense if the project is not in your solution. Very helpful for hiding invalid flows for fluent interfaces. How often do you want to GetHashCode() or Equals()?For MVC [ActionName("Name")] allows you to have a Get action and Post action with the same method signature, or to use dashes in the action name, which otherwise would not be possible without creating a route for it.[DeploymentItem("myFile1.txt")]\nMSDN Doc on DeploymentItemThis is really useful if you are testing against a file or using the file as input to your test. I consider that is important to mention here that the following attributes are also very important:Indicates that the COM threading model for an application is single-threaded apartment (STA). For example this attribute is used in Windows Forms Applications:And also ...Suppresses reporting of a specific static analysis tool rule violation, allowing multiple suppressions on a single code artifact.For example:[System.Security.Permissions.PermissionSetAttribute] allows security actions for a PermissionSet to be applied to code using declarative security.I generates data entity class via CodeSmith and I use attributes for some validation routine. Here is an example:And I got an utility class to do the validation based on the attributes attached to the data entity class. Here is the code: