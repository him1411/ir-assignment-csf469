I have heard lots of raving about Akka framework (Java/Scala service platform), but so far have not seen many actual examples of use cases it would be good for. So I would be interested in hearing about things developers have used it succesfully.Only one limitation: please do not include case of writing a chat server. \n(why? since this has been overused as an example for lots of similar things)I have used it so far in two real projects very successfully. both are in the near real-time traffic information field (traffic as in cars on highways), distributed over several nodes, integrating messages between several parties, reliable backend systems. I\'m not at liberty to give specifics on clients yet, when I do get the OK maybe it can be added as a reference. Akka has really pulled through on those projects, even though we started when it was on version 0.7. (we are using scala by the way)One of the big advantages is the ease at which you can compose a system out of actors and messages with almost no boilerplating, it scales extremely well without all the complexities of hand-rolled threading and you get asynchronous message passing between objects almost for free.It is very good in modeling any type of asynchronous message handling. I would prefer to write any type of (web) services system in this style than any other style. (Have you ever tried to write an asynchronous web service (server side) with JAX-WS? that\'s a lot of plumbing). So I would say any system that does not want to hang on one of its components because everything is implicitly called using synchronous methods, and that one component is locking on something. It is very stable and the let-it-crash + supervisor solution to failure really works well. Everything is easy to setup programmatically and not hard to unit test.Then there are the excellent add-on modules.\nThe Camel module really plugs in well into Akka and enables such easy development of asynchronous services with configurable endpoints. I\'m very happy with the framework and it is becoming a defacto standard for the connected systems that we build.Disclaimer: I am the PO for AkkaBesides offering a concurrency smorgasbord that is much simpler to reason about and to get correct (actors, agents, dataflow concurrency) and with concurrency control in the form of STM.Here are some use-cases you might consider:An example of how we use it would be on a priority queue of debit/credit card transactions. We have millions of these and the effort of the work depends on the input string type. If the transaction is of type CHECK we have very little processing but if it is a point of sale then there is lots to do such as merge with meta data (category, label, tags, etc) and provide services (email/sms alerts, fraud detection, low funds balance, etc). \nBased on the input type we compose classes of various traits (called mixins) necessary to handle the job and then perform the work. All of these jobs come into the same queue in realtime mode from different financial institutions. Once the data is cleansed it is sent to different data stores for persistence, analytics, or pushed to a socket connection, or to Lift comet actor. Working actors are constantly self load balancing the work so that we can process the data as fast as possible. We can also snap in additional services, persistence models, and stm for critical decision points. The Erlang OTP style message passing on the JVM makes a great system for developing realtime systems on the shoulders of existing libraries and application servers. Akka allows you to do message passing like you would in a traditional esb but with speed! It also gives you tools in the framework to manage the vast amount of actor pools, remote nodes, and fault tolerance that you need for your solution. We use Akka to process REST calls asynchronously - together with async web server (Netty-based) we can achieve 10 fold improvement on the number of users served per node/server, comparing to traditional thread per user request model.Tell it to your boss that your AWS hosting bill is going to drop by the factor of 10 and it is a no-brainer! Shh... dont tell it to Amazon though... :)If you abstract the chat server up a level, then you get the answer.Akka provides a messaging system that is akin to Erlang\'s "let it crash" mentality.So examples are things that need varying levels of durability and reliability of messaging:The nice things about Akka are the choices it affords for persistence, it\'s STM implementation, REST server and fault-tolerance.Don\'t get annoyed by the example of a chat server, think of it as an example of a certain class of solution.With all their excellent documentation, I feel like a gap is this exact question, use-cases and examples.  Keeping in mind the examples are non-trivial. (Written with only experience of watching videos and playing with the source, I have implemented nothing using akka.)We are using Akka in a large scale Telco project (unfortunately I can\'t disclose a lot of details).\nAkka actors are deployed and accessed remotely by a web application. In this way, we have a simplified RPC model based on Google protobuffer and we achieve parallelism using Akka Futures.\nSo far, this model has worked brilliantly. One note: we are using the Java API.We use Akka in several projects at work, the most interesting of which is related to vehicle crash repair.  Primarily in the UK but now expanding to the US, Asia, Australasia and Europe.\nWe use actors to ensure that crash repair information is provided realtime to enable the safe and cost effective repair of vehicles.The question with Akka is really more \'what can\'t you do with Akka\'.  Its ability to integrate with powerful frameworks, its powerful abstraction and all of the fault tolerance aspects make it a very comprehensive toolkit.You can use Akka for several different kinds of things.I was working on a website, where I migrated the technology stack to Scala and Akka. We used it for pretty much everything that happened on the website. Even though you might think a Chat example is bad, all are basically the same:Especially the live updates are easy since they boil down to what a Chat example ist. The services part is another interesting topic because you can simply choose to use remote actors and even if your app is not clustered, you can deploy it to different machines with ease.I am also using Akka for a PCB autorouter application with the idea of being able to scale from a laptop to a data center. The more power you give it, the better the result will be. This is extremely hard to implement if you try to use usual concurrency because Akka gives you also location transparency.Currently as a free time project, I am building a web framework using only actors. Again the benefits are scalability from a single machine to an entire cluster of machines. Besides, using a message driven approach makes your software service oriented from the start. You have all those nice components, talking to each other but not necessarily knowing each other, living on the same machine, not even in the same data center.And since Google Reader shut down I started with a RSS reader, using Akka of course. It is all about encapsulated services for me. As a conclusion: The actor model itself is what you should adopt first and Akka is a very reliable framework helping you to implement it with a lot of benefits you will receive along the way.We are using akka with its camel plugin to distribute our analysis and trending processing for twimpact.com. We have to process between 50 and 1000 messages per second. In addition to multi-node processing with camel it is also used to distribute work on a single processor to multiple workers for maximum performance. Works quite well, but requires some understanding of how to handle congestions.I was trying out my hands on Akka (Java api). What I tried was to compare Akka\'s actor based concurrency model with that of plain Java concurrency model (java.util.concurrent classes).The use case was a simple canonical map reduce implementation of character count. The dataset was a collection of randomly generated strings (400 chars in length), and calculate the number of vowels in them.For Akka I used a BalancedDispatcher(for load balancing amongst threads) and RoundRobinRouter (to keep a limit on my function actors). For Java, I used simple fork join technique (implemented without any work stealing algorithm) that would fork map/reduce executions and join the results. Intermediate results were held in blocking queues to make even the joining as parallel as possible. Probably, if I am not wrong, that would mimic somehow the "mailbox" concept of Akka actors, where they receive messages.Observation:\nTill medium loads (~50000 string input) the results were comparable, varying slightly in different iterations. However, as I increased my load to ~100000 it would hang the Java solution. I configured the Java solution with 20-30 threads under this condition and it failed in all iterations. Increasing the load to 1000000, was fatal for Akka as well. I can share the code with anyone interested to have a cross check.So for me, it seems Akka scales out better than traditional Java multithreaded solution. And probably the reason is the under the hood magic of Scala.If I can model a problem domain as an event driven message passing one, I think Akka is a good choice for the JVM. Test performed on:\nJava version:1.6\nIDE: Eclipse 3.7\nWindows Vista 32 bit. 3GB ram. Intel Core i5 processor, 2.5 GHz clock speedPlease note, the problem domain used for the test can be debated and I tried to be as much fair as my Java knowledge allowed :-)We use Akka in spoken dialog systems (primetalk). Both internally and externally. In order to simultaneously run a lot of telephony channels on a single cluster node it is obviously necessary to have some multithreading framework. Akka works just perfect. We have previous nightmare with the java-concurrency. And with Akka it is just like a swing \xe2\x80\x94 it simply works. Robust and reliable. 24*7, non-stop.Inside a channel we have real-time stream of events that are processed in parallel. In particular:\n- lengthy automatic speech recognition \xe2\x80\x94 is done with an actor;\n- audio output producer that mixes a few audio sources (including synthesized speech);\n- text-to-speech conversion is a separate set of actors shared between channels;\n- semantic and knowledge processing.To make interconnections of complex signal processing we use SynapseGrid. It has the benefit of compile-time checking of the DataFlow in the complex actor systems.I\'ve recently implemented the canonical map-reduce example in Akka: Word count. So it\'s one use case of Akka: better performance. It was more of a experiment of JRuby and Akka\'s actors than anything else, but it also shows that Akka is not Scala or Java only: it works on all languages on top of JVM.