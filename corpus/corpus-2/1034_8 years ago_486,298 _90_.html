I know that global variables in C sometimes have the extern keyword. What is an extern variable? What is the declaration like? What is its scope?This is related to sharing variables across source files, but how does that work precisely? Where do I use extern?Using extern is only of relevance when the program you\'re building\nconsists of multiple source files linked together, where some of the\nvariables defined, for example, in source file file1.c need to be\nreferenced in other source files, such as file2.c.It is important to understand the difference between defining a\nvariable and declaring a variable:You may declare a variable multiple times (though once is sufficient);\nyou may only define it once within a given scope.Although there are other ways of doing it, the clean, reliable way to\ndeclare and define global variables is to use a header file file3.h to\ncontain an extern declaration of the variable.  The header is\nincluded by the one source file that defines the variable and by all the\nsource files that reference the variable.  For each program, one source\nfile (and only one source file) defines the variable.  Similarly, one\nheader file (and only one header file) should declare the variable.That\'s the best way to use them.The next two files complete the source for prog1:Rules to be broken by experts only, and only with good reason:If you\'re not an experienced C programmer, you could (and perhaps should) stop reading here.With some (indeed, many) C compilers, you can get away with what\'s\ncalled a \'common\' definition of a variable too.  \'Common\', here, refers\nto a technique used in Fortran for sharing variables between source\nfiles, using a (possibly named) COMMON block.  What happens here is that\neach of a number of files provides a tentative definition of the\nvariable.  As long as no more than one file provides an initialized\ndefinition, then the various files end up sharing a common single\ndefinition of the variable:This technique does not conform to the letter of the C standard and the\n\'one definition rule\', but the C standard lists it as a common variation\non its one definition rule.\nBecause this technique is not always supported, it is best to avoid\nusing it, especially if your code needs to be portable.  Using this\ntechnique, you can also end up with unintentional type punning.  If one\nof the files declared i as a double instead of as an int, C\'s\ntype-unsafe linkers probably would not spot the mismatch.  If you\'re on\na machine with 64-bit int and double, you\'d not even get a warning;\non a machine with 32-bit int and 64-bit double, you\'d probably get a\nwarning about the different sizes \xe2\x80\x94 the linker would use the largest\nsize, exactly as a Fortran program would take the largest size of any\ncommon blocks.This is mentioned in the C standard in informative Annex J as a common\nextension:J.5.11 Multiple external definitionsThere may be more than one external definition for the identifier of an\n  object, with or without the explicit use of the keyword extern; if the\n  definitions disagree, or more than one is initialized, the behavior is\n  undefined (6.9.2).The next two files complete the source for prog2:As noted in comments here, and as stated in my answer to a similar\nquestion, using multiple definitions for a global variable leads to\nundefined behaviour, which is the standard\'s way of saying "anything\ncould happen".  One of the things that can happen is that the program\nbehaves as you expect; and J.5.11 says, approximately, "you might be\nlucky more often than you deserve".  But a program that relies on\nmultiple definitions of an extern variable \xe2\x80\x94 with or without the\nexplicit \'extern\' keyword \xe2\x80\x94 is not a strictly conforming program and not\nguaranteed to work everywhere.  Equivalently: it contains a bug which\nmay or may not show itself.Note 1: if the header defines the variable without the extern keyword,\nthen each file that includes the header creates a tentative definition\nof the variable.Note 2: if the header defines and initializes the variable, then only\none source file in a given program can use the header.Note 3: if the header defines a static variable (with or without\ninitialization), then each source file ends up with its own private\nversion of the \'global\' variable.If the variable is actually a complex array, for example, this can lead\nto extreme duplication of code.  It can, very occasionally, be a\nsensible way to achieve some effect, but that is rather unusual.Use the header technique I showed first.  It works reliably and\neverywhere.  Note, in particular, that the header declaring the\nglobal_variable is included in every file that uses it \xe2\x80\x94 including the\none that defines it.  This ensures that everything is self-consistent.Similar concerns arise with declaring and defining functions \xe2\x80\x94 analogous\nrules apply.  But the question was about variables specifically, so I\'ve\nkept the answer to variables only.(The complete programs use functions, so function declarations have\ncrept in.  I use the keyword extern in front of function declarations\nin headers to match the extern in front of variable declarations in\nheaders.  Many people prefer not to use extern in front of functions;\nthe compiler doesn\'t care \xe2\x80\x94 and ultimately, neither do I as long as\nyou\'re consistent.)If you\'re not an experienced C programmer, you probably should stop reading here.Late Major AdditionOne concern that is sometimes (and legitimately) raised about the\n\'declarations in headers, definitions in source\' mechanism described\nhere is that there are two files to be kept synchronized \xe2\x80\x94 the header\nand the source.  This is usually followed up with an observation that a\nmacro can be used so that the header serves double duty \xe2\x80\x94 normally\ndeclaring the variables, but when a specific macro is set before the\nheader is included, it defines the variables instead.Another concern can be that the variables need to be defined in each of\na number of \'main programs\'.  This is normally a spurious concern; you\ncan simply introduce a C source file to define the variables and link\nthe object file produced with each of the programs.A typical scheme works like this, using the original global variable\nillustrated in file3.h:The next two files complete the source for prog3:The problem with this scheme as shown is that it does not provide for\ninitialization of the global variable.  With C99 or C11 and variable argument\nlists for macros, you could define a macro to support initialization too.\n(With C89 and no support for variable argument lists in macros, there is no\neasy way to handle arbitrarily long initializers.)Reverse contents of #if and #else blocks, fixing bug identified by\nDenis KniazhevClearly, the code for the oddball structure is not what you\'d normally\nwrite, but it illustrates the point.  The first argument to the second\ninvocation of INITIALIZER is { 41 and the remaining argument\n(singular in this example) is 43 }.  Without C99 or similar support\nfor variable argument lists for macros, initializers that need to\ncontain commas are very problematic.Correct header file3b.h included (instead of fileba.h) per\nDenis KniazhevThe next two files complete the source for prog4:Any header should be protected against reinclusion, so that type\ndefinitions (enum, struct or union types, or typedefs generally) do not\ncause problems.  The standard technique is to wrap the body of the\nheader in a header guard such as:The header might be included twice indirectly.  For example, if\nfile4b.h includes file3b.h for a type definition that isn\'t shown,\nand file1b.c needs to use both header file4b.h and file3b.h, then\nyou have some more tricky issues to resolve.  Clearly, you might revise\nthe header list to include just file4b.h.  However, you might not be\naware of the internal dependencies \xe2\x80\x94 and the code should, ideally,\ncontinue to work.Further, it starts to get tricky because you might include file4b.h\nbefore including file3b.h to generate the definitions, but the normal\nheader guards on file3b.h would prevent the header being reincluded.So, you need to include the body of file3b.h at most once for\ndeclarations, and at most once for definitions, but you might need both\nin a single translation unit (TU \xe2\x80\x94 a combination of a source file and\nthe headers it uses).However, it can be done subject to a not too unreasonable constraint.\nLet\'s introduce a new set of file names:In these examples, file5c.c and file6c.c directly include the header\nfile2c.h several times, but that is the simplest way to show that the\nmechanism works.  It means that if the header was indirectly included\ntwice, it would also be safe.The restrictions for this to work are:The next source file completes the source (provides a main program) for prog5, prog6 and prog7:This scheme avoids most problems.  You only run into a problem if a\nheader that defines variables (such as file2c.h) is included by\nanother header (say file7c.h) that defines variables.  There isn\'t an\neasy way around that other than "don\'t do it".You can partially work around the problem by revising file2c.h into\nfile2d.h:The issue becomes \'should the header include #undef DEFINE_VARIABLES?\'\nIf you omit that from the header and wrap any defining invocation with\n#define and #undef:in the source code (so the headers never alter the value of\nDEFINE_VARIABLES), then you should be clean.  It is just a nuisance to\nhave to remember to write the the extra line.  An alternative might be:This is getting a tad convoluted, but seems to be secure (using the\nfile2d.h, with no #undef DEFINE_VARIABLES in the file2d.h).The next two files complete the source for prog8 and prog9:However, the problems are relatively unlikely to occur in practice,\nespecially if you take the standard advice toDoes this exposition miss anything?Confession: The \'avoiding duplicated code\' scheme outlined here was\ndeveloped because the issue affects some code I work on (but don\'t own),\nand is a niggling concern with the scheme outlined in the first part of\nthe answer.  However, the original scheme leaves you with just two\nplaces to modify to keep variable definitions and declarations\nsynchronized, which is a big step forward over having exernal variable\ndeclarations scattered throughout the code base (which really matters\nwhen there are thousands of files in total).  However, the code in the\nfiles with the names fileNc.[ch] (plus external.h and externdef.h)\nshows that it can be made to work.  Clearly, it would not be hard to\ncreate a header generator script to give you the standardized template\nfor a variable defining and declaring header file.NB These are toy programs with just barely enough code to make them\nmarginally interesting.  There is repetition within the examples that\ncould be removed, but isn\'t to simplify the pedagogical explanation.\n(For example: the difference between prog5.c and prog8.c is the name\nof one of the headers that are included.  It would be possible to\nreorganize the code so that the main() function was not repeated, but\nit would conceal more than it revealed.)An extern variable is a declaration (thanks to sbi for the correction) of a variable which is defined in another translation unit. That means the storage for the variable is allocated in another file.Say you have two .c-files test1.c and test2.c. If you define a global variable int test1_var; in test1.c and you\'d like to access this variable in test2.c you have to use extern int test1_var; in test2.c.Complete sample:Extern is the keyword you use to declare that the variable itself resides in another translation unit.So you can decide to use a variable in a translation unit and then access it from another one, then in the second one you declare it as extern and the symbol will be resolved by the linker.If you don\'t declare it as extern you\'ll get 2 variables named the same but not related at all, and an error of multiple definitions of the variable.I like to think of an extern variable as a promise that you make to the compiler.When encountering an extern, the compiler can only find out its type, not where it "lives", so it can\'t resolve the reference.You are telling it, "Trust me.  At link time this reference will be resolvable."extern tells the compiler to trust you that the memory for this variable is declared elsewhere, so it doesnt try to allocate/check memory.  Therefore, you can compile a file that has reference to an extern, but you can not link if that memory is not declared somewhere.Useful for global variables and libraries, but dangerous because the linker does not type check.Adding an extern turns a variable definition into a variable declaration. See this thread as to what\'s the difference between a declaration and a definition. The correct interpretation of extern is that you tell something to the compiler. You tell the compiler that, despite not being present right now, the variable declared will somehow be found by the linker (typically in another object (file)). The linker will then be the lucky guy to find everything and put it together, whether you had some extern declarations or not.In C a variable inside a file say example.c is given local scope. The compiler expects that the variable would have its definition inside the same file example.c and when it does not find the same , it would throw an error.A function on the other hand has by default global scope . Thus you do not have to explicitly mention to the compiler "look dude...you might find the definition of this function here". For a function including the file which contains its declaration is enough.(The file which you actually call a header file). \n   For example consider the following 2 files :\n example.c example1.cNow when you compile the two files together, using the following commands :step 1)cc -o ex example.c example1.c\nstep 2)./ex You get the following output : The value of a is <5>extern keyword is used with the variable for its identification as a global variable. It also represents that you can use the variable declared using extern\n  keyword in any file though it is declared/defined in other file.but how does that work precisely?Let\'s see how GCC 4.8 ELF implements itmain.c:Compile and decompile:Output contains:The System V ABI Update ELF spec "Symbol Table" chapter explains:SHN_UNDEF This section table index means the symbol is undefined. When the link editor combines this object file with another that defines the indicated symbol, this file\'s references to the symbol will be linked to the actual definition.which is basically the behavior the C standard gives to extern variables.From now on, it is the job of the linker to make the final program, but the extern information has already been extracted from the source code into the object file.First off, the extern keyword is not used for defining a variable; rather it is used for declaring a variable. I can say extern is a storage class, not a data type.extern is used to let other C files or external components know this variable is already defined somewhere. Example: if  you are building a library, no need to define global variable mandatorily somewhere in library itself. The library will be compiled directly, but while linking the file, it checks for the definition.extern\nallows one module of your program to access a global variable or function declared in another module of your program.\nYou usually have extern variables declared in header files.If you don\'t want a program to access your variables or functions, you use static which tells the compiler that this variable or function cannot be used outside of this module.extern is used so one first.c file can have full access to a global parameter in another second.c file.The extern can be declared in the first.c file or in any of the header files first.c includes.extern simply means a variable is defined elsewhere (i.e., in another file).