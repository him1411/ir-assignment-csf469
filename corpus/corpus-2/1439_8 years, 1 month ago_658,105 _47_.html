How do I read an entire InputStream into a byte array?You can use Apache Commons IO to handle this and similar tasks.The IOUtils type has a static method to read an InputStream and return a byte[].Internally this creates a ByteArrayOutputStream and copies the bytes to the output, then calls toByteArray(). It handles large files by copying the bytes in blocks of 4KiB.You need to read each byte from your InputStream and write it to a ByteArrayOutputStream.  You can then retrieve the underlying byte array by calling toByteArray(); e.g.Use vanilla Java\'s DataInputStream and its readFully Method (exists since at least Java 1.4):There are some other flavors of this method, but I use this all the time for this use case.If you happen to use google guava, it\'ll be as simple as :Finally, after twenty years, a simple solution without the need for a 3rd party library is in sight, thanks to the upcoming Java\xc2\xa09:Note also the convenience methods readNBytes(byte[] b, int off, int len) and transferTo(OutputStream) addressing recurring needs.Do you really need the image as a byte[]? What exactly do you expect in the byte[] - the complete content of an image file, encoded in whatever format the image file is in, or RGB pixel values?Other answers here show you how to read a file into a byte[]. Your byte[] will contain the exact contents of the file, and you\'d need to decode that to do anything with the image data.Java\'s standard API for reading (and writing) images is the ImageIO API, which you can find in the package javax.imageio. You can read in an image from a file with just a single line of code:This will give you a BufferedImage, not a byte[]. To get at the image data, you can call getRaster() on the BufferedImage. This will give you a Raster object, which has methods to access the pixel data (it has several getPixel() / getPixels() methods).Lookup the API documentation for javax.imageio.ImageIO, java.awt.image.BufferedImage, java.awt.image.Raster etc.ImageIO supports a number of image formats by default: JPEG, PNG, BMP, WBMP and GIF. It\'s possible to add support for more formats (you\'d need a plug-in that implements the ImageIO service provider interface).See also the following tutorial: Working with ImagesIf you don\'t want to use the Apache commons-io library, this snippet is taken from the sun.misc.IOUtils class. It\'s nearly twice as fast as the common implementation using ByteBuffers:@Adamski: You can avoid buffer entirely.Code copied from http://www.exampledepot.com/egs/java.io/File2ByteArray.html (Yes, it is very verbose, but needs half the size of memory as the other solution.)As always, also Spring framework (spring-core since 3.2.2) has something for you: StreamUtils.copyToByteArray()I know it\'s too late but here I think is cleaner solution that\'s more readable...See the InputStream.available() documentation:It is particularly important to realize that you must not use this\n  method to size a container and assume that you can read the entirety\n  of the stream without needing to resize the container. Such callers\n  should probably write everything they read to a ByteArrayOutputStream\n  and convert that to a byte array. Alternatively, if you\'re reading\n  from a file, File.length returns the current length of the file\n  (though assuming the file\'s length can\'t change may be incorrect,\n  reading a file is inherently racy).I tried to edit @numan\'s answer with a fix for writing garbage data but edit was rejected. While this short piece of code is nothing brilliant I can\'t see any other better answer. Here\'s what makes most sense to me:btw ByteArrayOutputStream need not be closed. try/finally constructs omitted for readabilityThis is my copy-paste version:Java 7 and later:Java 9 will give you finally a nice method:In-case someone is still looking for a solution without a dependency && If you have a file.1) DataInputStream2) ByteArrayOutputStream3) RandomAccessFileJava 8 way (thanks to BufferedReader and Adam Bien)Note that this solution wipes carriage return (\'\\r\') and can be inappropriate.Here is an optimized version, that tries to avoid copying data bytes as much as possible:You\'re doing an extra copy if you use ByteArrayOutputStream. If you know the length of the stream before you start reading it (e.g. the InputStream is actually a FileInputStream, and you can call file.length() on the file, or the InputStream is a zipfile entry InputStream, and you can call zipEntry.length()), then it\'s far better to write directly into the byte[] array -- it uses half the memory, and saves time.N.B. the last line above deals with files getting truncated while the stream is being read, if you need to handle that possibility, but if the file gets longer while the stream is being read, the contents in the byte[] array will not be lengthened to include the new file content, the array will simply be truncated to the old length inputStreamLength.I use this.Below CodesORThe other case to get correct byte array via stream, after send request to server and waiting for the response.This works for me,readSourceContent()encodeString()Wrap it in a DataInputStream if that is off the table for some reason, just use read to hammer on it until it gives you a -1 or the entire block you asked for.You can try Cactoos: