I\'m hoping there\'s something in the same conceptual space as the old VB6 IsNumeric() function?This works regardless of whether the variable contains is a string or number.Of course, you can negate this if you need to. For example, to implement the IsNumeric example you gave:only works if the string only contains numeric characters, else it returns NaN.useful for converting \'12px\' to 12, for example.Bear in mind that, unlike +num, parseInt (as the name suggests) will convert a float into an integer by chopping off everything following the decimal point (if you want to use parseInt() because of this behaviour, you\'re probably better off with Math.floor() instead):Empty strings may be a little counter-intuitive. +num converts empty strings to zero, and isNaN() assumes the same:But parseInt() does not agree:And you could go the RegExp-way:Try the isNan function:The isNaN() function determines whether a value is an illegal number (Not-a-Number).This function returns true if the value equates to NaN. Otherwise it returns false.This function is different from the Number specific Number.isNaN() method.Â  The global isNaN() function, converts the tested value to a Number, then tests it.Number.isNan() does not convert the values to a Number, and will not return true for any value that is not of the type Number...If you\'re just trying to check if a string is a whole number (no decimal places), regex is a good way to go. Other methods such as isNaN are too complicated for something so simple.If you really want to make sure that a string contains only a number, any number (integer or floating point), and exactly a number, you cannot use parseInt()/ parseFloat(), Number(), or !isNaN() by themselves.  Note that !isNaN() is actually returning true when Number() would return a number, and false when it would return NaN, so I will exclude it from the rest of the discussion.The problem with parseFloat() is that it will return a number if the string contains any number, even if the string doesn\'t contain only and exactly a number:The problem with Number() is that it will return a number in cases where the passed value is not a number at all!The problem with rolling your own regex is that unless you create the exact regex for matching a floating point number as Javascript recognizes it you are going to miss cases or recognize cases where you shouldn\'t.  And even if you can roll your own regex, why?  There are simpler built-in ways to do it.However, it turns out that Number() (and isNaN()) does the right thing for every case where parseFloat() returns a number when it shouldn\'t, and vice versa.  So to find out if a string is really exactly and only a number, call both functions and see if they both return true:Old question, but there are several points missing in the given answers.Scientific notation.!isNaN(\'1e+30\') is true, however in most of the cases when people ask for numbers, they do not want to match things like 1e+30.Large floating numbers may behave weirdObserve (using Node.js):On the other hand:So, if one expects String(Number(s)) === s, then better limit your strings to 15 digits at most (after omitting leading zeros).InfinityGiven all that, checking that the given string is a number satisfying all of the following:is not such an easy task. Here is a simple version:However, even this one is far from complete. Leading zeros are not handled here, but they do screw the length test.parseInt(), but be aware that this function is a bit different in the sense that it for example returns 100 for parseInt("100px").Well, I\'m using this one I made...It\'s been working so far:If you spot any problem with it, tell me, please.You can use the result of Number when passing an argument to its constructor.If the argument (a string) cannot be converted into a number, it returns NaN, so you can determinate if the string provided was a valid number or not.Notes: Note when passing empty string or  \'\\t\\t\' and \'\\n\\t\' as Number will return 0; Passing true will return 1 and false returns 0.Maybe there are one or two people coming across this question who need a much stricter check than usual (like I did). In that case, this might be useful:Beware! This will reject strings like .1, 40.000, 080, 00.1. It\'s very picky - the string must match the "most minimal perfect form" of the number for this test to pass.It uses the String and Number constructor to cast the string to a number and back again and thus checks if the JavaScript engine\'s "perfect minimal form" (the one it got converted to with the initial Number constructor) matches the original string.I have tested and Michael\'s solution is best. Vote for his answer above (search this page for "If you really want to make sure that a string" to find it). In essence, his answer is this:It works for every test case, which I documented here:\nhttps://jsfiddle.net/wggehvp9/5/Many of the other solutions fail for these edge cases:\n\' \', null, "", true, and [].\nIn theory, you could use them, with proper error handling, for example:orwith special handling for \n/\\s/, null, "", true, false, [] (and others?)Quote:isNaN(num)         // returns true if the variable does NOT contain a valid numberis not entirely true if you need to check for leading/trailing spaces - for example when a certain quantity of digits is required, and you need to get, say, \'1111\' and not \' 111\' or \'111 \' for perhaps a PIN input.Better to use:Why is jQuery\'s implementation not good enough?Michael suggested something like this (although I\'ve stolen "user1691651 - John"\'s altered version here):The following is a solution with most likely bad performance, but solid results. It is a contraption made from the jQuery 1.12.4 implementation and Michael\'s answer, with an extra check for leading/trailing spaces (because Michael\'s version returns true for numerics with leading/trailing spaces):The latter version has two new variables, though. One could get around one of those, by doing:I haven\'t tested any of these very much, by other means than manually testing the few use-cases I\'ll be hitting with my current predicament, which is all very standard stuff. This is a "standing-on-the-shoulders-of-giants" situation.PFB the working solution:My attempt at a slightly confusing, Pherhaps not the best solutionIn my application we are only allowing a-z A-Z and 0-9 characters. I found the answer above using " string % 1 === 0" worked unless the string began with 0xnn (like 0x10) and then it would return it as numeric when we didn\'t want it to. The following simple trap in my numeric check seems to do the trick in our specific cases.    Warning : This might be exploiting a longstanding bug in Javascript and Actionscript [Number("1" + the_string) % 1 === 0)],  I can\'t speak for that, but it is exactly what we needed.My solution:You can add additional conditions inside the loop, to fit you particular needs.If anyone ever gets this far down, I spent some time hacking on this trying to patch moment.js (https://github.com/moment/moment). Here\'s something that I took away from it:Handles the following cases:True! :False! :Ironically, the one I am struggling with the most:Any suggestions welcome. :]I do it like this:Of course isString() will be tripped up here if you pass some other object that has \'length\' defined.