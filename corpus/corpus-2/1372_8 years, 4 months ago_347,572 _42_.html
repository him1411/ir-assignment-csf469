I\'m writing a program in C# that needs to repeatedly access 1 image file. Most of the time it works, but if my computer\'s running fast, it will try to access the file before it\'s been saved back to the filesystem and throw an error: "File in use by another process".I would like to find a way around this, but all my Googling has only yielded creating checks by using exception handling. This is against my religion, so I was wondering if anyone has a better way of doing it?Updated NOTE on this solution: Checking with FileAccess.ReadWrite will fail for Read-Only files so the solution has been modified to check with FileAccess.Read. While this solution works because trying to check with FileAccess.Read will fail if the file has a Write or Read lock on it, however, this solution will not work if the file doesn\'t have a Write or Read lock on it, i.e. it has been opened (for reading or writing) with FileShare.Read or FileShare.Write access.ORIGINAL:\nI\'ve used this code for the past several years, and I haven\'t had any issues with it.Understand your hesitation about using exceptions, but you can\'t avoid them all of the time:You can suffer from a thread race condition on this which there are documented examples of this being used as a security vulnerability.  If you check that the file is available, but then try and use it you could throw at that point, which a malicious user could use to force and exploit in your code.Your best bet is a try catch / finally which tries to get the file handle.Use this to check if a file is locked:For performance reasons I recommend you read the file content in the same operation. Here are some examples:Try it out yourself:Here\'s a powershell version of the accepted answer.Perhaps you could use a FileSystemWatcher and watch for the Changed event.I haven\'t used this myself, but it might be worth a shot. If the filesystemwatcher turns out to be a bit heavy for this case, I would go for the try/catch/sleep loop.the only way I know of is to use the Win32 exclusive lock API which isn\'t too speedy, but examples exist.Most people, for a simple solution to this, simply to try/catch/sleep loops.You can return a task which gives you a stream as soon as it becomes available. It\'s a simplified solution, but it is a good starting point. It\'s thread safe.You can use this stream as usual:Hope this helps!In my experience, you usually want to do this, then \'protect\' your files to do something fancy and then use the \'protected\' files. If you have just one file you want to use like this, you can use the trick that\'s explained in the answer by Jeremy Thompson. However, if you attempt to do this on lots of files (say, for example when you\'re writing an installer), you\'re in for quite a bit of hurt.A very elegant way this can be solved is by using the fact that your file system will not allow you to change a folder name if one of the files there it\'s being used. Keep the folder in the same file system and it\'ll work like a charm.Do note that you should be aware of the obvious ways this can be exploited. After all, the files won\'t be locked. Also, be aware that there are other reasons that can result in your Move operation to fail. Obviously proper error handling (MSDN) can help out here.For individual files I\'d stick with the locking suggestion posted by Jeremy Thompson.Just use the exception as intended.  Accept that the file is in use and try again, repeatedly until your action is completed.  This is also the most efficient because you do not waste any cycles checking the state before acting.Use the function below, for exampleReusable method that times out after 2 secondsThe accepted answers above suffer an issue where if file has been opened for writing with a FileShare.Read mode or if the file has a Read-Only attribute the code will not work. This modified solution works most reliably, with two things to keep in mind (as true for the accepted solution also):Keeping the above in mind, this checks if the file is either locked for writing or locked to prevent reading:Here is some code that as far as I can best tell does the same thing as the accepted answer but with less code:However I think it is more robust to do it in the following manner:Try and move/copy the file to a temp dir. If you can, it has no lock and you can safely work in the temp dir without getting locks. Else just try to move it again in x seconds.You can use my library for accessing files from multiple apps.You can install it from nuget: Install-Package Xabe.FileLockIf you want more information about it check\nhttps://github.com/tomaszzmuda/Xabe.FileLockfileLock.Acquire method will return true only if can lock file exclusive for this object.\nBut app which uploading file must do it in file lock too.\nIf object is inaccessible metod returns false.I use this workaround, but i have a timespan between when i check the file locking with IsFileLocked function and when i open the file. In this timespan some other thread can open the file, so i will get IOException.So, i added extra code for this. In my case i want load XDocument:What do you think? Can i change some thing? Maybe i did not have to use IsFileBeingUsed function at all?ThanksHave you heard of a sigleton class. if you force all your image manipulations through this class and queue all the function calls, you will have atomicity. the only problem with this is that you need to host the class in a process.I had a similar problem and did something that seemed to work, it was using exception handling though...I put a counter in to keep trying 100 times to stop endless loop.See below...