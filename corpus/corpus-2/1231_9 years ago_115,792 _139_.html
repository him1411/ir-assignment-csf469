When should I use an interface and when should I use a base class? Should it always be an interface if I don\'t want to actually define a base implementation of the methods?If I have a Dog and Cat class. Why would I want to implement IPet instead of PetBase? I can understand having interfaces for ISheds or IBarks (IMakesNoise?), because those can be placed on a pet by pet basis, but I don\'t understand which to use for a generic Pet.\nLet\'s take your example of a Dog and a Cat class, and let\'s illustrate using C#:Both a dog and a cat are animals, specifically, quadruped mammals (animals are waaay too general). Let us assume that you have an abstract class Mammal, for both of them:This base class will probably have default methods such as:All of which are behavior that have more or less the same implementation between either species. To define this you will have:Now let\'s suppose there are other mammals, which we will usually see in a zoo:This will still be valid because at the core of the functionality Feed() and Mate() will still be the same.However, giraffes, rhinoceros, and hippos are not exactly animals that you can make pets out of. That\'s where an interface will be useful:The implementation for the above contract will not be the same between a cat and dog; putting their implementations in an abstract class to inherit will be a bad idea. Your Dog and Cat definitions should now look like:Theoretically you can override them from a higher base class, but essentially an interface allows you to add on only the things you need into a class without the need for inheritance.Consequently, because you can usually only inherit from one abstract class (in most statically typed OO languages that is... exceptions include C++) but be able to implement multiple interfaces, it allows you to construct objects in a strictly as required basis.Well, Josh Bloch said himself in Effective Java 2d:Some main points:Existing classes can be easily retrofitted to implement a new\n  interface. All you have to do is add\n  the required methods if they don\xe2\x80\x99t yet\n  exist and add an implements clause to\n  the class declaration. Interfaces are ideal for defining mixins. Loosely speaking, a\n  mixin is a type that a class can\n  implement in addition to its \xe2\x80\x9cprimary\n  type\xe2\x80\x9d to declare that it provides\n  some optional behavior. For example,\n  Comparable is a mixin interface that\n  allows a class to declare that its\n  instances are ordered with respect to\n  other mutually comparable objects.Interfaces allow the construction of nonhierarchical type\n  frameworks. Type hierarchies are\n  great for organizing some things, but\n  other things don\xe2\x80\x99t fall neatly into a\n  rigid hierarchy. Interfaces enable safe, powerful functionality enhancements via the\n  wrap- per class idiom. If you use\n  abstract classes to define types, you\n  leave the programmer who wants to add\n  functionality with no alternative but\n  to use inheritance. Moreover, you can combine the virtues\n  of interfaces and abstract classes by\n  providing an abstract skeletal\n  implementation class to go with each\n  nontrivial interface that you export.On the other hand, interfaces are very hard to evolve. If you add a method to an interface it\'ll break all of it\'s implementations.PS.: Buy the book. It\'s a lot more detailed.Modern style is to define IPet and PetBase.The advantage of the interface is that other code can use it without any ties whatsoever to other executable code.  Completely "clean."  Also interfaces can be mixed.But base classes are useful for simple implementations and common utilities.  So provide an abstract base class as well to save time and code.Interfaces and base classes represent two different forms of relationships.Inheritance (base classes) represent an "is-a" relationship. E.g. a dog or a cat "is-a" pet. This relationship always represents the (single) purpose of the class (in conjunction with the "single responsibility principle").Interfaces, on the other hand, represent additional features of a class. I\'d call it an "is" relationship, like in "Foo is disposable", hence the IDisposable interface in C#.In general, you should favor interfaces over abstract classes. One reason to use an abstract class is if you have common implementation among concrete classes. Of course, you should still declare an interface (IPet) and have an abstract class (PetBase) implement that interface.Using small, distinct interfaces, you can use multiples to further improve flexibility. Interfaces allow the maximum amount of flexibility and portability of types across boundaries. When passing references across boundaries, always pass the interface and not the concrete type. This allows the receiving end to determine concrete implementation and provides maximum flexibility. This is absolutely true when programming in a TDD/BDD fashion.The Gang of Four stated in their book "Because inheritance exposes a subclass to details of its parent\'s implementation, it\'s often said that \'inheritance breaks encapsulation". I believe this to be true.This is pretty .NET specific, but the Framework Design Guidelines book argues that in general classes give more flexibility in an evolving framework.  Once an interface is shipped, you don\'t get the chance to change it without breaking code that used that interface.  With a class however, you can modify it and not break code that links to it. As long you make the right modifications, which includes adding new functionality, you will be able to extend and evolve your code.Krzysztof Cwalina says on page 81:Over the course of the three versions of the .NET Framework, I have talked about this guideline with quite a few developers on our team.  Many of them, including those who initially disagreed with the guidelines, have said that they regret having shipped some API as an interface.  I have not heard of even one case in which somebody regretted that they shipped a class.That being said there certainly is a place for interfaces.  As a general guideline always provide an abstract base class implementation of an interface if for nothing else as an example of a way to implement the interface.  In the best case that base class will save a lot of work.Juan,I like to think of interfaces as a way to characterize a class.  A particular dog breed class, say a YorkshireTerrier, may be a descended of the parent dog class, but it is also implements IFurry, IStubby, and IYippieDog.  So the class defines what the class is but the interface tells us things about it.The advantage of this is it allows me to, for example, gather all the IYippieDog\'s and throw them into my Ocean collection.  So now I can reach across a particular set of objects and find ones that meet the criteria I am looking at without inspecting the class too closely.I find that interfaces really should define a sub-set of the public behavior of a class.  If it defines all the public behavior for all the classes that implement then it usually does not need to exist.  They do not tell me anything useful.This thought though goes counter to the idea that every class should have an interface and you should code to the interface.  That\'s fine, but you end up with a lot of one to one interfaces to classes and it makes things confusing.  I understand that the idea is it does not really cost anything to do and now you can swap things in and out with ease.  However, I find that I rarely do that.  Most of the time I am just modifying the existing class in place and have the exact same issues I always did if the public interface of that class needs changing, except I now have to change it in two places.So if you think like me you would definitely say that Cat and Dog are IPettable.  It is a characterization that matches them both.The other piece of this though is should they have the same base class?  The question is do they need to be broadly treated as the same thing.  Certainly they are both Animals, but does that fit how we are going to use them together.  Say I want to gather all Animal classes and put them in my Ark container.Or do they need to be Mammals?  Perhaps we need some kind of cross animal milking factory?Do they even need to be linked together at all?  Is it enough to just know they are both IPettable?I often feel the desire to derive a whole class hierarchy when I really just need one class.   I do it in anticipation someday I might need it and usually I never do.  Even when I do, I usually find I have to do a lot to fix it.  That\xe2\x80\x99s because the first class I am creating is not the Dog, I am not that lucky, it is instead the Platypus.  Now my entire class hierarchy is based on the bizarre case and I have a lot of wasted code. You might also find at some point that not all Cats are IPettable (like that hairless one).  Now you can move that Interface to all the derivative classes that fit.  You will find that a much less breaking change that all of a sudden Cats are no longer derived from PettableBase.Here is the basic and simple definiton of interface and base class:cheersI recommend using composition instead of inheritence whenever possible.  Use interfaces but use member objects for base implementation.  That way, you can define a factory that constructs your objects to behave in a certain way.  If you want to change the behavior then you make a new factory method (or abstract factory) that creates different types of sub-objects.In some cases, you may find that your primary objects don\'t need interfaces at all, if all of the mutable behavior is defined in helper objects.So instead of IPet or PetBase, you might end up with a Pet which has an IFurBehavior parameter.  The IFurBehavior parameter is set by the CreateDog() method of the PetFactory.  It is this parameter which is called for the shed() method.If you do this you\'ll find your code is much more flexible and most of your simple objects deal with very basic system-wide behaviors.I recommend this pattern even in multiple-inheritence languages.Explained well in this Java World articlePersonally I tend to use interfaces to define interfaces - i.e. parts of the system design that specify how something should be accessed. It\'s not uncommon that I will have a class implementing 1 or more interfaces.Abstract classes I use as a basis for something else.The following is an extract from the above mentioned article JavaWorld.com article, author Tony Sintes, 04/20/01Choosing interfaces and abstract classes is not an either/or proposition. If you need to change your design, make it an interface. However, you may have abstract classes that provide some default behavior. Abstract classes are excellent candidates inside of application frameworks.Abstract classes let you define some behaviors; they force your subclasses to provide others. For example, if you have an application framework, an abstract class may provide default services such as event and message handling. Those services allow your application to plug in to your application framework. However, there is some application-specific functionality that only your application can perform. Such functionality might include startup and shutdown tasks, which are often application-dependent. So instead of trying to define that behavior itself, the abstract base class can declare abstract shutdown and startup methods. The base class knows that it needs those methods, but an abstract class lets your class admit that it doesn\'t know how to perform those actions; it only knows that it must initiate the actions. When it is time to start up, the abstract class can call the startup method. When the base class calls this method, Java calls the method defined by the child class.Many developers forget that a class that defines an abstract method can call that method as well. Abstract classes are an excellent way to create planned inheritance hierarchies. They\'re also a good choice for nonleaf classes in class hierarchies.Some say you should define all classes in terms of interfaces, but I think recommendation seems a bit extreme. I use interfaces when I see that something in my design will change frequently.For example, the Strategy pattern lets you swap new algorithms and processes into your program without altering the objects that use them. A media player might know how to play CDs, MP3s, and wav files. Of course, you don\'t want to hardcode those playback algorithms into the player; that will make it difficult to add a new format like AVI. Furthermore, your code will be littered with useless case statements. And to add insult to injury, you will need to update those case statements each time you add a new algorithm. All in all, this is not a very object-oriented way to program.With the Strategy pattern, you can simply encapsulate the algorithm behind an object. If you do that, you can provide new media plug-ins at any time. Let\'s call the plug-in class MediaStrategy. That object would have one method: playStream(Stream s). So to add a new algorithm, we simply extend our algorithm class. Now, when the program encounters the new media type, it simply delegates the playing of the stream to our media strategy. Of course, you\'ll need some plumbing to properly instantiate the algorithm strategies you will need.This is an excellent place to use an interface. We\'ve used the Strategy pattern, which clearly indicates a place in the design that will change. Thus, you should define the strategy as an interface. You should generally favor interfaces over inheritance when you want an object to have a certain type; in this case, MediaStrategy. Relying on inheritance for type identity is dangerous; it locks you into a particular inheritance hierarchy. Java doesn\'t allow multiple inheritance, so you can\'t extend something that gives you a useful implementation or more type identity.Also keep in mind not to get swept away in OO (see blog) and always model objects based on behavior required, if you were designing an app where the only behavior you required was a generic name and species for an animal then you would only need one class Animal with a property for the name, instead of millions of classes for every possible animal in the world.Interfaces should be small. Really small. If you\'re really breaking down your objects, then your interfaces will probably only contain a few very specific methods and properties.Abstract classes are shortcuts. Are there things that all derivatives of PetBase share that you can code once and be done with? If yes, then it\'s time for an abstract class.Abstract classes are also limiting. While they give you a great shortcut to producing child objects, any given object can only implement one abstract class. Many times, I find this a limitation of Abstract classes, and this is why I use lots of interfaces.Abstract classes may contain several interfaces. Your PetBase abstract class may implement IPet (pets have owners) and IDigestion (pets eat, or at least they should). However, PetBase will probably not implement IMammal, since not all pets are mammals and not all mammals are pets. You may add a MammalPetBase that extends PetBase and add IMammal. FishBase could have PetBase and add IFish. IFish would have ISwim and IUnderwaterBreather as interfaces.Yes, my example is extensively over-complicated for the simple example, but that\'s part of the great thing about how interfaces and abstract classes work together.I have a rough rule-of-thumbFunctionality: likely to be different in all parts: Interface.Data, and functionality, parts will be mostly the same, parts different: abstract class.Data, and functionality, actually working, if extended only with slight changes: ordinary (concrete) classData and functionality, no changes planned: ordinary (concrete) class with final modifier.Data, and maybe functionality: read-only: enum members.This is very rough and ready and not at all strictly defined, but there is a spectrum from interfaces where everything is intended to be changed to enums where everything is fixed a bit like a read-only file.The case for Base Classes over Interfaces was explained well in the Submain .NET Coding Guidelines:Base Classes vs. Interfaces \n  An interface type is a partial\n  description of a value, potentially\n  supported by many object types. Use\n  base classes instead of interfaces\n  whenever possible. From a versioning\n  perspective, classes are more flexible\n  than interfaces. With a class, you can\n  ship Version 1.0 and then in Version\n  2.0 add a new method to the class. As long as the method is not abstract,\n  any existing derived classes continue\n  to function unchanged.Because interfaces do not support\n  implementation inheritance, the\n  pattern that applies to classes does\n  not apply to interfaces. Adding a\n  method to an interface is equivalent\n  to adding an abstract method to a base\n  class; any class that implements the\n  interface will break because the class\n  does not implement the new method.\n  Interfaces are appropriate in the\n  following situations:One important difference is that you can only inherit one base class, but you can implement many interfaces.  So you only want to use a base class if you are absolutely certain that you won\'t need to also inherit a different base class.  Additionally, if you find your interface is getting large then you should start looking to break it up into a few logical pieces that define independent functionality, since there\'s no rule that your class can\'t implement them all (or that you can define a different interface that just inherits them all to group them).When I first started learning about object-oriented programming, I made the easy and probably common mistake of using inheritance to share common behavior - even where that behavior was not essential to the nature of the object.To further build on an example much used in this particular question, there are lots of things that are petable - girlfriends, cars, fuzzy blankets... - so I might have had a Petable class that provided this common behavior, and various classes inheriting from it.However, being petable is not part of the nature of any of these objects. There are vastly more important concepts that are essential to their nature - the girlfriend is a person, the car is a land vehicle, the cat is a mammal...Behaviors should be assigned first to interfaces (including the default interface of the class), and promoted to a base class only if they are (a) common to a large group of classes that are subsets of a larger class - in the same sense that "cat" and "person" are subsets of "mammal".The catch is, after you understand object-oriented design sufficiently better than I did at first, you\'ll normally do this automatically without even thinking about it. So the bare truth of the statement "code to an interface, not an abstract class" becomes so obvious you have a hard time believing anyone would bother to say it - and start trying to read other meanings into it.Another thing I\'d add is that if a class is purely abstract - with no non-abstract, non-inherited members or methods exposed to child, parent, or client - then why is it a class? It could be replaced, in some cases by an interface and in other cases by Null.Previous comments about using abstract classes for common implementation is definitely on the mark.  One benefit I haven\'t seen mentioned yet is that the use of interfaces makes it much easier to implement mock objects for the purpose of unit testing.  Defining IPet and PetBase as Jason Cohen described enables you to mock different data conditions easily, without the overhead of a physical database (until you decide it\'s time to test the real thing).Don\'t use a base class unless you know what it means, and that it applies in this case.  If it applies, use it, otherwise, use interfaces.  But note the answer about small interfaces.Public Inheritance is overused in OOD and expresses a lot more than most developers realize or are willing to live up to.  See the Liskov Substitutablity PrincipleIn short, if A "is a" B then A requires no more than B and delivers no less than B, for every method it exposes.Conceptually, an Interface is used to formally and semi-formally define a set of methods that an object will provide. Formally means a set of method names and signatures, semi-formally means human readable documentation associated with those methods. Interfaces are only descriptions of an API (after all, API stands for Application Programmer Interface), they can\'t contain any implementation, and it\'s not possible to use or run an Interface. They only make explicit the contract of how you should interact with an object. Classes provide an implementation, they can declare that they implement zero, one or more Interfaces. If a Class is intended to be inherited, the convention is to prefix the Class name with "Base".There is a distinction between a Base Class and an Abstract Base Classes (ABC). ABCs mix interface and implementation together. Abstract outside of computer programming means "summary", that is "Abstract == Interface". An Abstract Base Class can then describe both an interface, as well as an empty, partial or complete implementation that is intended to be inherited.Opinions on when to use Interfaces versus Abstract Base Classes versus just Classes is going to vary wildly based on both what you are developing, and which language you are developing in. Interfaces are often associated only with statically typed languages such as Java or C#, but dynamically typed languages can also have Interfaces and Abstract Base Classes. In Python for example, the distinction is made clear between a Class, which declares that it implements an Interface, and an object, which is an instance of a Class, and is said to provide that Interface. It\'s possible in a dynamic language that two objects that are both instances of the same Class, can declare that they provide completely different interfaces. In Python this is only possible for object attributes, while methods are shared state between all objects of a Class. However in Ruby, objects can have per-instance methods, so it\'s possible that the Interface between two objects of the same Class can vary as much as the programmer desires (however, Ruby doesn\'t have any explicit way of declaring Interfaces).In dynamic languages the Interface to an object is often implicitly assumed, either by introspecting an object and asking it what methods it provides (Look Before You Leap) or preferably by simply attempting to use the desired Interface on an object and catching exceptions if the object doesn\'t provide that Interface (Easier to Ask Forgiveness than Permission). This can lead to "false positives" where two Interfaces have the same method name but are semantically different, however the trade-off is that your code is more flexible since you don\'t need to over specify up-front to anticipate all possible uses of your code.Another option to keep in mind is using the "has-a" relationship, aka "is implemented in terms of" or "composition."  Sometimes this is a cleaner, more flexible way to structure things than using "is-a" inheritance.It may not make as much sense logically to say that Dog and Cat both "have" a Pet, but it avoids common multiple inheritance pitfalls:Yes, this example shows that there is a lot of code duplication and lack of elegance involved in doing things this way.  But one should also appreciate that this helps to keep Dog and Cat decoupled from the Pet class (in that Dog and Cat do not have access to the private members of Pet), and it leaves room for Dog and Cat to inherit from something else--possibly the Mammal class.Composition is preferable when no private access is required and you don\'t need to refer to Dog and Cat using generic Pet references/pointers.  Interfaces give you that generic reference capability and can help cut down on the verbosity of your code, but they can also obfuscate things when they are poorly organized.  Inheritance is useful when you need private member access, and in using it you are committing yourself to highly coupling your Dog and Cat classes to your Pet class, which is a steep cost to pay.Between inheritance, composition, and interfaces there is no one way that is always right, and it helps to consider how all three options can be used in harmony.  Of the three, inheritance is typically the option that should be used the least often.Prefer interfaces over abstract classesRationale,\nthe main points to consider [two already mentioned here] are :[1] It adds more code, of course, but if brevity is your primary concern, you probably should have avoided Java in the first place![2] Joshua Bloch, Effective Java, items 16-18.[3] http://www.codeproject.com/KB/ar...It depends on your requirements.  If IPet is simple enough, I would prefer to implement that.  Otherwise, if PetBase implements a ton of functionality you don\'t want to duplicate, then have at it.The downside to implementing a base class is the requirement to override (or new) existing methods.  This makes them virtual methods which means you have to be careful about how you use the object instance.Lastly, the single inheritance of .NET kills me.  A naive example: Say you\'re making a user control, so you inherit UserControl.  But, now you\'re locked out of also inheriting PetBase.  This forces you to reorganize, such as to make a PetBase class member, instead.@Joel: Some languages (e.g., C++) allow multiple-inheritance.I usually don\'t implement either until I need one.  I favor interfaces over abstract classes because that gives a little more flexibility.  If there\'s common behavior in some of the inheriting classes I move that up and make an abstract base class.  I don\'t see the need for both, since they essentially server the same purpose, and having both is a bad code smell (imho) that the solution has been over-engineered.Regarding C#, in some senses interfaces and abstract classes can be interchangeable. However, the differences are: i) interfaces cannot implement code; ii) because of this, interfaces cannot call further up the stack to subclass; and iii) only can abstract class may be inherited on a class, whereas multiple interfaces may be implemented on a class.Source: http://jasonroell.com/2014/12/09/interfaces-vs-abstract-classes-what-should-you-use/C# is a wonderful language that has matured and evolved over the last 14 years. This is great for us developers because a mature language provides us with a plethora of language features that are at our disposal.However, with much power becomes much responsibility. Some of these features can be misused, or sometimes it is hard to understand why you would choose to use one feature over another. Over the years, a feature that I have seen many developers struggle with is when to choose to use an interface or to choose to use an abstract class. Both have there advantages and disadvantages and the correct time and place to use each. But how to we decide???Both provide for reuse of common functionality between types. The most obvious difference right away is that interfaces provide no implementation for their functionality whereas abstract classes allow you to implement some \xe2\x80\x9cbase\xe2\x80\x9d or \xe2\x80\x9cdefault\xe2\x80\x9d behavior and then have the ability to \xe2\x80\x9coverride\xe2\x80\x9d this default behavior with the classes derived types if necessary.This is all well and good and provides for great reuse of code and adheres to the DRY (Don\xe2\x80\x99t Repeat Yourself) principle of software development. Abstract classes are great to use when you have an \xe2\x80\x9cis a\xe2\x80\x9d relationship.For example: A golden retriever \xe2\x80\x9cis a\xe2\x80\x9d type of dog. So is a poodle. They both can bark, as all dogs can. However, you might want to state that the poodle park is significantly different than the \xe2\x80\x9cdefault\xe2\x80\x9d dog bark. Therefor, it could make sense for you to implement something as follows:As you can see, this would be a great way to keep your code DRY and allow for the base class implementation be called when any of the types can just rely on the default Bark instead of a special case implementation. The classes like GoldenRetriever, Boxer, Lab could all could inherit the \xe2\x80\x9cdefault\xe2\x80\x9d (bass class) Bark at no charge just because they implement the Dog abstract class.But I\xe2\x80\x99m sure you already knew that.You are here because you want to understand why you might want to choose an interface over an abstract class or vice versa. Well one reason you may want to choose an interface over an abstract class is when you don\xe2\x80\x99t have or want to prevent a default implementation. This is usually because the types that are implementing the interface not related in an \xe2\x80\x9cis a\xe2\x80\x9d relationship. Actually, they don\xe2\x80\x99t have to be related at all except for the fact that each type \xe2\x80\x9cis able\xe2\x80\x9d or has \xe2\x80\x9cthe ablity\xe2\x80\x9d to do something or have something.Now what the heck does that mean? Well, for example: A human is not a duck\xe2\x80\xa6and a duck is not a human. Pretty obvious. However, both a duck and a human have \xe2\x80\x9cthe ability\xe2\x80\x9d to swim (given that the human passed his swimming lessons in 1st grade :) ). Also, since a duck is not a human or vice versa, this is not an \xe2\x80\x9cis a\xe2\x80\x9d realationship, but instead an \xe2\x80\x9cis able\xe2\x80\x9d relationship and we can use an interface to illustrate that:Using interfaces like the code above will allow you to pass an object into a method that \xe2\x80\x9cis able\xe2\x80\x9d to do something.  The code doesn\xe2\x80\x99t care how it does it\xe2\x80\xa6All it knows is that it can call the Swim method on that object and that object will know which behavior take at run-time based on its type.Once again, this helps your code stay DRY so that you would not have to write multiple methods that are calling the object to preform the same core function (ShowHowHumanSwims(human), ShowHowDuckSwims(duck), etc.)Using an interface here allows the calling methods to not have to worry about what type is which or how the behavior is implemented. It just knows that given the interface, each object will have to have implemented the Swim method so it is safe to call it in its own code and allow the behavior of the Swim method be handled within its own class.Summary:So my main rule of thumb is use an abstract class when you want to implement a \xe2\x80\x9cdefault\xe2\x80\x9d functionality for a class hierarchy or/and the classes or types you are working with share a \xe2\x80\x9cis a\xe2\x80\x9d relationship (ex. poodle \xe2\x80\x9cis a\xe2\x80\x9d type of dog).On the other hand use an interface when you do not have an \xe2\x80\x9cis a\xe2\x80\x9d relationship but have types that share \xe2\x80\x9cthe ability\xe2\x80\x9d to do something or have something (ex. Duck \xe2\x80\x9cis not\xe2\x80\x9d a human. However, duck and human share \xe2\x80\x9cthe ability\xe2\x80\x9d to swim).Another difference to note between abstract classes and interfaces is that a class can implement one to many interfaces but a class can only inherit from ONE abstract class (or any class for that matter). Yes, you can nest classes and have an inheritance hierarchy (which many programs do and should have) but you cannot inherit two classes in one derived class definition (this rule applies to C#. In some other languages you are able to do this, usually only because of the lack of interfaces in these languages).Also remember when using interfaces to adhere to the Interface Segregation Principle (ISP). ISP states that no client should be forced to depend on methods it does not use. For this reason interfaces should be focused on specific tasks and are usually very small (ex. IDisposable, IComparable ).Another tip is if you are developing small, concise bits of functionality, use interfaces. If you are designing large functional units, use an abstract class.Hope this clears things up for some people!Also if you can think of any better examples or want to point something out, please do so in the comments below!An inheritor of a base class should have an "is a" relationship.  Interface represents An "implements a" relationship.\nSo only use a base class when your inheritors will maintain the is a relationship.Use Interfaces to enforce a contract ACROSS families of unrelated classes. For example, you might have common access methods for classes that represent collections, but contain radically different data i.e. one class might represent a result set from a query, while the other might represent the images in a gallery. Also, you can implement multiple interfaces, thus allowing you to blend (and signify) the capabilities of the class.Use Inheritance when the classes bear a common relationship and therefore have a similair structural and behavioural signature, i.e. Car, Motorbike, Truck and SUV are all types of road vehicle that might contain a number of wheels, a top speedBy def, interface provides a layer to communicate with other code. All the public properties and methods of a class are by default implementing implicit interface. We can also define an interface as a role, when ever any class needs to play that role, it has to implement it giving it different forms of implementation depending on the class implementing it. Hence when you talk about interface, you are talking about polymorphism and when you are talking about base class, you are talking about inheritance.  Two concepts of oops !!!