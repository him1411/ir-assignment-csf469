In C#, what makes a field different from a property, and when should a field be used instead of a property?Properties expose fields.  Fields should (almost always) be kept private to a class and accessed via get and set properties.  Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things that use your class.@Kent points out that Properties are not required to encapsulate fields, they could do a calculation on other fields, or serve other purposes.@GSS points out that you can also do other logic, such as validation, when a property is accessed, another useful feature.Object orientated programming principles say that, the internal workings of a class should be hidden from the outside world. If you expose a field you\'re in essence exposing the internal implementation of the class. Therefore we wrap fields with Properties (or methods in Java\'s case) to give us the ability to change the implementation without breaking code depending on us. Seeing as we can put logic in the Property also allows us to perform validation logic etc if we need it.\nC# 3 has the possibly confusing notion of autoproperties. This allows us to simply define the Property and the C#3 compiler will generate the private field for us.An important difference is that interfaces can have properties but not fields. This, to me, underlines that properties should be used to define a class\'s public interface while fields are meant to be used in the private, internal workings of a class. As a rule I rarely create public fields and similarly I rarely create non-public properties.I\'ll give you a couple examples of using properties that might get the gears turning:Using Properties, you can throw an event, when the value of the property is changed (aka. PropertyChangedEvent) or before the value is changed to support cancelation. This is not possible with (direct access to) fields.Since many of them have explained with technical pros and cons of Properties and Field, it\'s time to get into real time examples.1. Properties allows you to set the read-only access levelConsider the case of dataTable.Rows.Count and dataTable.Columns[i].Caption. They come from the class DataTable and both are public to us. The difference in the access-level to them is that we cannot set value to dataTable.Rows.Count but we can read and write to dataTable.Columns[i].Caption. Is that possible through Field? No!!! This can be done with Properties only.2. Properties in PropertyGridYou might have worked with Button in Visual Studio. Its properties are shown in the PropertyGrid like Text,Name etc. When we drag and drop a button, and when we click the properties, it will automatically find the class Button and filters Properties and show that in PropertyGrid (where PropertyGrid won\'t show Field even though they are public).In PropertyGrid, the properties Name and Text will be shown, but not SomeProperty. Why??? Because Properties can accept Attributes. It does not show in case where [Browsable(false)] is false.3. Can execute statements inside Properties4. Only Properties can be used in Binding SourceBinding Source helps us to decrease the number of lines of code. Fields are not accepted by BindingSource. We should use Properties for that.5. Debugging modeConsider we are using Field to hold a value. At some point we need to debug and check where the value is getting null for that field. It will be difficult to do where the number of lines of code are more than 1000. In such situations we can use Property and can set debug mode inside Property.A field is a variable that is declared directly in a class or struct. A class or struct may have instance fields or static fields or both. Generally, you should use fields only for variables that have private or protected accessibility. Data that your class exposes to client code should be provided through methods, properties and indexers. By using these constructs for indirect access to internal fields, you can guard against invalid input values.A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they are actually special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods.\nProperties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code. A get property accessor is used to return the property value, and a set accessor is used to assign a new value.Properties have the primary advantage of allowing you to change the way data on an object is accessed without breaking it\'s public interface. For example, if you need to add extra validation, or to change a stored field into a calculated you can do so easily if you initially exposed the field as a property. If you just exposed a field directly, then you would have to change the public interface of your class to add the new functionality. That change would break existing clients, requiring them to be recompiled before they could use the new version of your code. If you write a class library designed for wide consumption (like the .NET Framework, which is used by millions of people), that can be a problem. However, if you are writing a class used internally inside a small code base (say <= 50 K lines), it\'s really not a big deal, because no one would be adversely affected by your changes. In that case it really just comes down to personal preference.Properties support asymmetric access, i.e. you can have either a getter and a setter or just one of the two. Similarly properties support individual accessibility for getter/setter. Fields are always symmetric, i.e. you can always both get and set the value. Exception to this is readonly fields which obviously cannot be set after initialization.Properties may run for a very long time, have side effects, and may even throw exceptions. Fields are fast, with no side effects, and will never throw exceptions. Due to side effects a property may return a different value for each call (as may be the case for DateTime.Now, i.e. DateTime.Now is not always equal to DateTime.Now). Fields always return the same value.Fields may be used for out / ref parameters, properties may not. \nProperties support additional logic \xe2\x80\x93 this could be used to implement lazy loading among other things.Properties support a level of abstraction by encapsulating whatever it means to get/set the value. Use properties in most / all cases, but try to avoid side effects. In the background a property is compiled into methods. So a Name property is compiled into get_Name() and set_Name(string value). You can see this if you study the compiled code. \nSo there is a (very) small performance overhead when using them. Normally you will always use a Property if you expose a field to the outside, and you will often use it internally if you need to do validation of the value.When you want your private variable(field) to be accessible to object of your class from other classes you need to create properties for those variables.for example if I have  variables named as "id" and "name" which is private \nbut there might be situation where this variable needed for read/write operation outside of the class. At that situation , property can help me to get that variable to read/write depending upon the get/set defined for the property. A property can be a readonly / writeonly / readwrite both.here is the demoThe second question here, "when should a field be used instead of a property?", is only briefly touched on in this other answer and kinda this one too, but not really much detail.In general, all the other answers are spot-on about good design: prefer exposing properties over exposing fields.  While you probably won\'t regularly find yourself saying "wow, imagine how much worse things would be if I had made this a field instead of a property", it\'s so much more rare to think of a situation where you would say "wow, thank God I used a field here instead of a property."But there\'s one advantage that fields have over properties, and that\'s their ability to be used as "ref" / "out" parameters.  Suppose you have a method with the following signature:and suppose that you want to use that method to transform an array created like this:Here\'s I think the fastest way to do it, since X and Y are properties:And that\'s going to be pretty good!  Unless you have measurements that prove otherwise, there\'s no reason to throw a stink.  But I believe it\'s not technically guaranteed to be as fast as this:Doing some measurements myself, the version with fields takes about 61% of the time as the version with properties (.NET 4.6, Windows 7, x64, release mode, no debugger attached).  The more expensive the TransformPoint method gets, the less pronounced that the difference becomes.  To repeat this yourself, run with the first line commented-out and with it not commented-out.Even if there were no performance benefits for the above, there are other places where being able to use ref and out parameters might be beneficial, such as when calling the Interlocked or Volatile family of methods.  Note: In case this is new to you, Volatile is basically a way to get at the same behavior provided by the volatile keyword.  As such, like volatile, it doesn\'t magically solve all thread-safety woes like its name suggests that it might.I definitely don\'t want to seem like I\'m advocating that you go "oh, I should start exposing fields instead of properties."  The point is that if you need to regularly use these members in calls that take "ref" or "out" parameters, especially on something that might be a simple value type that\'s unlikely to ever need any of the value-added elements of properties, an argument can be made.Also, properties allow you to use logic when setting values.So you can say you only want to set a value to an integer field, if the value is greater than x, otherwise throw an exception.Really useful feature.If you are going to use thread primitives you are forced to use fields. Properties can break your threaded code. Apart from that, what cory said is correct.(This should really be a comment, but I can\'t post a comment, so please excuse if it is not appropriate as a post). I once worked at a place where the recommended practice was to use public fields instead of properties when the equivalent property def would just have been accessing a field, as in :Their reasoning was that the public field could be converted into a property later in future if required. It seemed a little strange to me at the time. Judging by these posts, it looks like not many here would agree either. What might you have said to try to change things ?Edit : I should add that all of the code base at this place was compiled at the same time, so they might have thought that changing the public interface of classes (by changing a public field to a property) was not a problem. This page on MSDN has a comparison and tips on which one to use when:https://msdn.microsoft.com/en-us/library/9d65as2e(v=vs.90).aspxFields are ordinary member variables or member instances of a class. Properties are an abstraction to get and set their values. Properties are also called accessors because they offer a way to change and retrieve a field if you expose a field in the class as private. Generally, you should declare your member variables private, then declare or define properties for them. Properties encapsulate fields, thus enabling you to perform additional processing on the value to be set or retrieved. It is typically overkill to use properties if you will not be doing any pre- or postprocessing on the field value.Technically, i don\'t think that there is a difference, because properties are just wrappers around fields created by the user or automatically created by the compiler.The purpose of properties is to enforce encapsuation and to offer a lightweight method-like feature.\nIt\'s just a bad practice to declare fields as public, but it does not have any issues.IMO, Properties are just the "SetXXX()" "GetXXX()" functions/methods/interfaces pairs we used before, but they are more concise and elegant.Traditionally private fields are set via getter and setter methods.  For the sake of less code you can use properties to set fields instead.when you have a class which is "Car". The properties are color,shape..Where as fields are variables defined within the scope of a class.From Wikipedia -- Object-oriented programming:Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. (emphasis added)Properties are actually part of an object\'s behavior, but are designed to give consumers of the object the illusion/abstraction of working with the object\'s data.Properties are special kind of class member, In properties we use a predefined Set or Get method.They use accessors through which we can read, written or change the values of the private fields.For example, let us take a class named Employee, with private fields for name, age and Employee_Id. We cannot access these fields from outside the class , but we can access these private fields through properties.Why do we use properties?Making the class field public & exposing it is risky, as you will not have control what gets assigned & returned.To understand this clearly with an example lets take a student class who have ID, passmark, name. Now in this example some problem with public fieldTo remove this problem We use Get and set method.Now we take an example of get and set methodMy design of a field is that a field needs to be modified only by its parent, hence the class. Result the variable becomes private, then to be able to give the right to read the classes / methods outside I go through the system of property with only the Get. The field is then retrieved by the property and read-only! If you want to modify it you have to go through methods (for example the constructor) and I find that thanks to this way of making you secure, we have better control over our code because we "flange". One could very well always put everything in public so every possible case, the notion of variables / methods / classes etc ... in my opinion is just an aid to the development, maintenance of the code. For example, if a person resumes a code with public fields, he can do anything and therefore things "illogical" in relation to the objective, the logic of why the code was written. It\'s my point of view.When i use a classic model private field / public readonly properties,for 10 privates fields i should write 10 publics properties! The code can be really big faster. I discover the private setter and now i only use public properties with a private setter.\nThe setter create in background a private field.That why my old classic programming style was:My new programming style:Additional info:\nBy default, get and set accessors are as accessible as the property itself.\nYou can control/restrict accessor accessibility individually (for get and set) by applying more restrictive access modifiers on them.Example:Here get is still publicly accessed (as the property is public), but set is protected (a more restricted access specifier).Properties are used to expose field. They use accessors(set, get) through which the values of the private fields can be read, written or manipulated.Properties do not name the storage locations. Instead, they have accessors that read, write, or compute their values.Using properties we can set validation on the type of data that is set on a field.For example we have private integer field age on that we should allow positive values since age cannot be negative.We can do this in two ways using getter and setters and using property.Auto Implemented property if we don\'t logic in get and set accessors we can use auto implemented property. When use auto-implemented property compiles creates a private, anonymous field that can only be accessed through get and set accessors.Abstract Properties\nAn abstract class may have an abstract property, which should be implemented in the derived classWe can privately set a property\nIn this we can privately set the auto property(set with in the class)You can achieve same with this code. In this property set feature is not available as we have to set value to field directly.Think about it : You have a room and a door to enter this room. If you want to check how who is coming in and secure your room, then you should use properties otherwise they won\'t be any door and every one easily come in w/o any regulationPeople is getting in to sectionOne pretty easily, there wasn\'t any checkingNow you checked the person and know about whether he has something evil with him