I was exploring the Java 8 source and found this particular part of code very surprising:Is Math::max something like a method pointer? How does a normal static method get converted to IntBinaryOperator?Usually, one would call the reduce method using Math.max(int, int) as follows:That requires a lot of syntax for just calling Math.max. That\'s where lambda expressions come into play. Since Java 8 it is allowed to do the same thing in a much shorter way:How does this work? The java compiler "detects", that you want to implement a method that accepts two ints and returns one int. This is equivalent to the formal parameters of the one and only method of interface IntBinaryOperator (the parameter of method reduce you want to call). So the compiler does the rest for you - it just assumes you want to implement IntBinaryOperator.But as Math.max(int, int) itself fulfills the formal requirements of IntBinaryOperator, it can be used directly. Because Java 7 does not have any syntax that allows a method itself to be passed as an argument (you can only pass method results, but never method references), the :: syntax was introduced in Java 8 to reference methods:Note that this will be interpreted by the compiler, not by the JVM at runtime! Although it produces different bytecodes for all three code snippets, they are semantically equal, so the last two can be considered to be short (and probably more efficient) versions of the IntBinaryOperator implementation above!(See also Translation of Lambda Expressions):: is called Method Reference. It is basically a reference to a single method. i.e. it refers to an existing method by name.  Short Explanation:\nBelow is an example of a reference to a static method:square can be passed around just like object reference\'s and trigger when at need. In fact, it can be perfectly used as a reference to a normal method of an object and not just static ones. Function above is a functional interface. Well to fully explain ::, it is important to understand functional interface. Plainly, function interface is an interface with just one abstract method. For example: Runnable, Callable, ActionListener and so. Function above is a functional interface with just one method apply. It takes one argument and produces a result. The reason why :: are awesome is because:Method references are expressions which have the same treatment as\n  lambda\'s, but instead of providing a lambda body, they refer an existing method by namei.e. Just like writing lambda body:You can simply do:At runtime they behave exactly the same. The bytecode may/not be the same (For above case, it generates the same bytecode (compile above and check javap -c))The only major criteria to satisfy is: the method you provide should have a similar signature to method of the functional interface you use as object reference.Below is illegal:square expects an argument and returns a double. get method in Supplier expects an argument but doesn\'t return anything. So it is an error. Method Reference refers to a method of the functional interface (As mentioned, functional interface can only have one method). Some more examples: accept method in Consumer takes an input but doesn\'t return anything.Above getRandom takes no argument and returns a double. So any functional interface that satisfies the criteria of: take no argument and return double can be used. Another example:In case of Parameterized Types:Method Reference can be obtained in different styles, but fundamentally they all mean the same and can simply be visualized as a lambda:For further reference: http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.htmlYes, that true. The :: operator it is used for method referencing. So, one can extract static methods from classes by using it or methods from objects. The same operator can be used even for constructors. All cases mentioned here are exemplified in the code sample bellow.The official documentation from Oracle can be found here.You can have a better overview of the JDK 8 changes in this article. In the Method/Constructor referencing section a code example is also provided:This is a method reference in Java 8.  The oracle documentation is here.As stated in the documentation...The method reference Person::compareByAge is a reference to a static\n  method.The following is an example of a reference to an instance method of a\n  particular object:The method reference myComparisonProvider::compareByName invokes the method compareByName\n  that is part of the object myComparisonProvider. The JRE infers the\n  method type arguments, which in this case are (Person, Person).:: is a new operator included in Java 8 that is used to refer a method of an existing class. You can refer static methods and non-static methods of a class.For referring static methods, the syntax is:For referring non-static methods, the syntax isAndThe only prerequisite for referring a method is that method exists in a functional interface, which must be compatible with the method reference. Method references, when evaluated, create an instance of the functional interface. Found on: http://www.speakingcs.com/2014/08/method-references-in-java-8.htmlIt seems its little late but here are my two cents. A lambada expression is used to create anonymous methods. It does nothing but call an existing method, but it is clearer to refer to the method directly by its name. And method reference enables us to do that using method-reference operator :: .Consider the following simple class where each employee has a name and grade.Suppose we have a list of employees returned by some method and we want to sort the employees by their grade. We know we can make use of anonymous class as:where getDummyEmployee() is some method as:  Now we know that Comparable is a Functional Interface. A Functional Interface is the one with exactly one abstract method (though it may contain one or more default or static methods). So we can use lambada expression as:It seems all good but what if the class Employee also provides similar method:In this case using the method name itself will be more clear. Hence we can directly refer to method by using method reference as:As per docs there are four kinds of method references:The :: is known as method references. Lets say  we want to call a calculatePrice method of class Purchase. Then we can write it as:It can also be seen as short form of writing the lambda expression Because method references are converted into lambda expressions.:: Operator was introduced in java 8 for method references. A method reference is the shorthand syntax for a lambda expression that executes just ONE method. Here\'s the general syntax of a method reference:We know that we can use lambda expressions instead of using an anonymous class. But sometimes, the lambda expression is really just a call to some method, for example:To make the code clearer, you can turn that lambda expression into a method reference:At runtime they behave a exactly the same.The bytecode may/not be same (For above Incase,it generates the same bytecode(complie above and check javaap  -c;))At runtime they behave a exactly the same.method(math::max);,it generates the same math (complie above and check javap -c;))return reduce(Math::max); is NOT EQUAL to return reduce(max());But it means, something like this:You can just save 47 keystrokes if you write like thisIn java-8 Streams Reducer in simple works is a function which takes two values as input and returns result after some calculation. this result is fed in next iteration.in case of Math:max function, method keeps returning max of two values passed and in the end you have largest number in hand.Since many answers here explained well :: behaviour, additionally I would like to clarify that :: operator doesnt need to have exactly same signature as the referring Functional Interface if it is used for instance variables. Lets assume we need a BinaryOperator which has type of TestObject. In traditional way its implemented like this:As you see in anonymous implementation it requires two TestObject argument and returns a TestObject object as well. To satisfy this condition by using :: operator we can start with a static method:and then call:Ok it compiled fine. What about if we need an instance method? Lets update TestObject with instance method:Now we can access instance as below:This code compiles fine, but below one not:My eclipse tell me "Cannot make a static reference to the non-static method testInstance(TestObject, TestObject) from the type TestObject ..."Fair enough its an instance method, but if we overload testInstance as below:And call:The code will just compile fine. Because it will call testInstance with single parameter instead of double one. Ok so what happened our two parameter? Lets printout and see:Which will output:Ok so JVM is smart enough to call param1.testInstance(param2). Can we use testInstance from another resource but not TestObject, i.e.:And call:It will just not compile and compiler will tell: "The type TestUtil does not define testInstance(TestObject, TestObject)". So compiler will look for a static reference if it is not the same type. Ok what about polymorphism? If we remove final modifiers and add our SubTestObject class:And call:It will not compile as well, compiler will still look for static reference. But below code will compile fine since it is passing is-a test:*I am just studying so I have figured out by try and see, feel free to correct me if I am wrongI found this source very interesting.In fact, it is the Lambda that turns into a Double Colon.\nThe Double Colon is more readable.\nWe follow those steps:STEP1:STEP2:STEP3: