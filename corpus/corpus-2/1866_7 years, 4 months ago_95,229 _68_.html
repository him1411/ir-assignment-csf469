JavaScript is known to be single-threaded in all modern browser implementations, but is that specified in any standard or is it just by tradition? Is it totally safe to assume that JavaScript is always single-threaded?That\'s a good question. I\'d love to say \xe2\x80\x9cyes\xe2\x80\x9d. I can\'t.JavaScript is usually considered to have a single thread of execution visible to scripts(*), so that when your inline script, event listener or timeout is entered, you remain completely in control until you return from the end of your block or function.(*: ignoring the question of whether browsers really implement their JS engines using one OS-thread, or whether other limited threads-of-execution are introduced by WebWorkers.)However, in reality this isn\'t quite true, in sneaky nasty ways.The most common case is immediate events. Browsers will fire these right away when your code does something to cause them:Results in log in, blur, log out on all except IE. These events don\'t just fire because you called focus() directly, they could happen because you called alert(), or opened a pop-up window, or anything else that moves the focus.This can also result in other events. For example add an i.onchange listener and type something in the input before the focus() call unfocuses it, and the log order is log in, change, blur, log out, except in Opera where it\'s log in, blur, log out, change and IE where it\'s (even less explicably) log in, change, log out, blur.Similarly calling click() on an element that provides it calls the onclick handler immediately in all browsers (at least this is consistent!).(I\'m using the direct on... event handler properties here, but the same happens with addEventListener and attachEvent.)There\'s also a bunch of circumstances in which events can fire whilst your code is threaded in, despite you having done nothing to provoke it. An example:Hit alert and you\'ll get a modal dialogue box. No more script executes until you dismiss that dialogue, yes? Nope. Resize the main window and you will get alert in, resize, alert out in the textarea.You might think it\'s impossible to resize a window whilst a modal dialogue box is up, but not so: in Linux, you can resize the window as much as you like; on Windows it\'s not so easy, but you can do it by changing the screen resolution from a larger to a smaller one where the window doesn\'t fit, causing it to get resized.You might think, well, it\'s only resize (and probably a few more like scroll) that can fire when the user doesn\'t have active interaction with the browser because script is threaded. And for single windows you might be right. But that all goes to pot as soon as you\'re doing cross-window scripting. For all browsers other than Safari, which blocks all windows/tabs/frames when any one of them is busy, you can interact with a document from the code of another document, running in a separate thread of execution and causing any related event handlers to fire.Places where events that you can cause to be generated can be raised whilst script is still threaded:when the modal popups (alert, confirm, prompt) are open, in all browsers but Opera;during showModalDialog on browsers that support it;the \xe2\x80\x9cA script on this page may be busy...\xe2\x80\x9d dialogue box, even if you choose to let the script continue to run, allows events like resize and blur to fire and be handled even whilst the script is in the middle of a busy-loop, except in Opera.a while ago for me, in IE with the Sun Java Plugin, calling any method on an applet could allow events to fire and script to be re-entered. This was always a timing-sensitive bug, and it\'s possible Sun have fixed it since (I certainly hope so).probably more. It\'s been a while since I tested this and browsers have gained complexity since.In summary, JavaScript appears to most users, most of the time, to have a strict event-driven single thread of execution. In reality, it has no such thing. It is not clear how much of this is simply a bug and how much deliberate design, but if you\'re writing complex applications, especially cross-window/frame-scripting ones, there is every chance it could bite you\xe2\x80\x89\xe2\x80\x94\xe2\x80\x89and in intermittent, hard-to-debug ways.If the worst comes to the worst, you can solve concurrency problems by indirecting all event responses. When an event comes in, drop it in a queue and deal with the queue in order later, in a setInterval function. If you are writing a framework that you intend to be used by complex applications, doing this could be a good move. postMessage will also hopefully soothe the pain of cross-document scripting in the future.I\'d say yes - because virtually all existing (at least all non-trivial) javascript code would break if a browser\'s javascript engine were to run it asynchronously.Add to that the fact that HTML5 already specifies Web Workers (an explicit, standardized API for multi-threading javascript code) introducing multi-threading into the basic Javascript would be mostly pointless.(Note to others commenters: Even though setTimeout/setInterval, HTTP-request onload events (XHR), and UI events (click, focus, etc.) provide a crude impression of multi-threadedness - they are still all executed along a single timeline - one at a time - so even if we don\'t know their execution order beforehand, there\'s no need to worry about external conditions changing during the execution of an event handler, timed function or XHR callback.)Yes, although you can still suffer some of the issues of concurrent programming (mainly race conditions) when using any of the asynchronous APIs such as setInterval and xmlhttp callbacks.Yes, although Internet Explorer 9 will compile your Javascript on a separate thread in preparation for execution on the main thread. This doesn\'t change anything for you as a programmer, though.Actually, a parent window can communicate with child or sibling windows or frames that have their own execution threads running.JavaScript/ECMAScript is designed to live within a host environment. That is, JavaScript doesn\'t actually do anything unless the host environment decides to parse and execute a given script, and provide environment objects that let JavaScript actually be useful (such as the DOM in browsers).I think a given function or script block will execute line-by-line and that is guaranteed for JavaScript. However, perhaps a host environment could execute multiple scripts at the same time. Or, a host environment could always provide an object that provides multi-threading. setTimeout and setInterval are examples, or at least pseudo-examples, of a host environment providing a way to do some concurrency (even if it\'s not exactly concurrency).No.I\'m going against the crowd here, but bear with me. A single JS script is intended to be effectively single threaded, but this doesn\'t mean that it can\'t be interpreted differently.Let\'s say you have the following code...This is written with the expectation that by the end of the loop, the list must have 10000 entries which are the index squared, but the VM could notice that each iteration of the loop does not affect the other, and reinterpret using two threads.First threadSecond threadI\'m simplifying here, because JS arrays are more complicated then dumb chunks of memory, but if these two scripts are able to add entries to the array in a thread-safe way, then by the time both are done executing it\'ll have the same result as the single-threaded version.While I\'m not aware of any VM detecting parallelizable code like this, it seems likely that it could come into existence in the future for JIT VMs, since it could offer more speed in some situations.Taking this concept further, it\'s possible that code could be annotated to let the VM know what to convert to multi-threaded code.Since Web Workers are coming to Javascript, it\'s unlikely that this... uglier system will ever come into existence, but I think it\'s safe to say Javascript is single-threaded by tradition.I would say that the specification does not prevent someone from creating an engine that runs javascript on multiple threads, requiring the code to perform synchronization for accessing shared object state.I think the single-threaded non-blocking paradigm came out of the need to run javascript in browsers where ui should never block.Nodejs has followed the browsers\' approach.Rhino engine however, supports running js code in different threads. The executions cannot share context, but they can share scope.\nFor this specific case the documentation states:..."Rhino guarantees that accesses to properties of JavaScript objects are atomic across threads, but doesn\'t make any more guarantees for scripts executing in the same scope at the same time.If two scripts use the same scope simultaneously, the scripts are responsible for coordinating any accesses to shared variables."From reading Rhino documentation I conclude that that it can be possible for someone to write a javascript api that also spawns new javascript threads, but the api would be rhino-specific (e.g. node can only spawn a new process).I imagine that even for an engine that supports multiple threads in javascript there should be compatibility with scripts that do not consider multi-threading or blocking.Concearning browsers and nodejs the way I see it is:Is all js code executed in a single thread? : Yes.Can js code cause other threads to run? : Yes.Can these threads mutate js execution context?: No. But they can (directly/indirectly(?)) append to the event queue.So, in case of browsers and nodejs (and probably a lot of other engines) javascript is not multithreaded but the engines themselves are.Well, Chrome is multiprocess, and I think every process deals with its own Javascript code, but as far as the code knows, it is "single-threaded".There is no support whatsoever in Javascript for multi-threading, at least not explicitly, so it does not make a difference.@Bobince is providing a really opaque answer.Riffing off of M\xc3\xa1r \xc3\x96rlygsson\'s answer, Javascript is always single-threaded because of this simple fact: Everything in Javascript is executed along a single timeline.That is the strict definition of a single-threaded programming language.I\'ve tried @bobince\'s example with a slight modifications:So, when you press Run, close alert popup and do a "single thread", you should see something like this:But if you try to run this in Opera or Firefox stable on Windows and minimize/maximize window with alert popup on screen, then there will be something like this:I don\'t want to say, that this is "multithreading", but some piece of code had executed in a wrong time with me not expecting this, and now I have a corrupted state.\nAnd better to know about this behavior.Related to this thread. I\'m a bit confused about the concurrency model in JavaScript:Is each event processed completely before any other event is processed in the single-threaded Event Loop? As you can read on MDN. So, if the runtime is executing a callback (callback1) and inside callback1 you dispatch an event (with an associated callback2), does the runtime finish the execution of the current callback1 before starting the execution of callback2? As I can see from my tests, the answer is no. Which is a bit scary (race conditions)... I\'m using dispathEvent to trigger a custom event in these tests. Does dispatchEvent have some sort of "preference" for the runtime?Demo:After the execution x is 1. But if MDN docs are correct, you should expect 2...Try to nest two setTimeout functions within each other and they will behave multithreaded (ie; the outer timer won\'t wait for the inner one to complete before executing its function).