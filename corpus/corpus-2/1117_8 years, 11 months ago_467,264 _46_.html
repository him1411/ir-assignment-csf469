Are disabling and enabling foreign key constraints supported in SQL Server? Or is my only option to drop and then re-create the constraints?If you want to disable all constraints in the database just run this code:To switch them back on, run: (the print is optional of course and it is just listing the tables)I find it useful when populating data from one database to another. It is much better approach than dropping constraints. As you mentioned it comes handy when dropping all the data in the database and repopulating it (say in test environment). If you are deleting all the data you may find this solution to be helpful.Also sometimes it is handy to disable all triggers as well, you can see the complete solution here.http://www.sqljunkies.com/WebLog/roman/archive/2005/01/30/7037.aspxYour best option is to DROP and CREATE foreign key constraints.I didn\'t find examples in this post that would work for me "as-is", one would not work if foreign keys reference different schemas, the other would not work if foreign key references multiple columns. This script considers both, multiple schemas and multiple columns per foreign key.Here is the script that generates "ADD CONSTRAINT" statements, for multiple columns it will separate them by comma (be sure to save this output before executing DROP statements):Here is the script that generates "DROP CONSTRAINT" statements:I use this script to check constraint status.\nit\'s very helpfullThe SQL-92 standard allows for a constaint to be declared as DEFERRABLE so that it can be deferred (implicitly or explicitly) within the scope of a transaction. Sadly, SQL Server is still missing this SQL-92 functionality.For me, changing a constraint to NOCHECK is akin to changing the database structure on the fly -- dropping constraints certainly is -- and something to be avoided (e.g. users require increased privileges).I do agree with you, Hamlin. When you are transfer data using SSIS or when want to replicate data, it seems quite necessary to temporarily disable or drop foreign key constraints and then re-enable or recreate them. In these cases, referential integrity is not an issue, because it is already maintained in the source database. Therefore, you can rest assured regarding this matter.First post :)For the OP, kristof\'s solution will work, unless there are issues with massive data and transaction log balloon issues on big deletes.  Also, even with tlog storage to spare, since deletes write to the tlog, the operation can take a VERY long time for tables with hundreds of millions of rows.I use a series of cursors to truncate and reload large copies of one of our huge production databases frequently.  The solution engineered accounts for multiple schemas, multiple foreign key columns, and best of all can be sproc\'d out for use in SSIS.It involves creation of three staging tables (real tables) to house the DROP, CREATE, and CHECK FK scripts, creation and insertion of those scripts into the tables, and then looping over the tables and executing them.  The attached script is four parts: 1.) creation and storage of the scripts in the three staging (real) tables, 2.) execution of the drop FK scripts via a cursor one by one, 3.) Using sp_MSforeachtable to truncate all the tables in the database other than our three staging tables and 4.) execution of the create FK and check FK scripts at the end of your ETL SSIS package.  Run the script creation portion in an Execute SQL task in SSIS.  Run the "execute Drop FK Scripts" portion in a second Execute SQL task. Put the truncation script in a third Execute SQL task, then perform whatever other ETL processes you need to do prior to attaching the CREATE and CHECK scripts in a final Execute SQL task (or two if desired) at the end of your control flow.Storage of the scripts in real tables has proven invaluable when the re-application of the foreign keys fails as you can select * from sync_CreateFK, copy/paste into your query window, run them one at a time, and fix the data issues once you find ones that failed/are still failing to re-apply.  Do not re-run the script again if it fails without making sure that you re-apply all of the foreign keys/checks prior to doing so, or you will most likely lose some creation and check fk scripting as our staging tables are dropped and recreated prior to the creation of the scripts to execute.Find the constraintExecute the SQL generated by this SQLSafeway.Note: Added solution for droping the constraint so that table can be dropped or modified without any constraint error.WITH CHECK CHECK is almost certainly required!This point was raised in some of the answers and comments but I feel that it is important enough to call it out again.Re-enabling a constraint using the following command (no WITH CHECK) will have some serious drawbacks.WITH CHECK | WITH NOCHECK Specifies whether the data in the table is or is not validated against\n  a newly added or re-enabled FOREIGN KEY or CHECK constraint. If not\n  specified, WITH CHECK is assumed for new constraints, and WITH NOCHECK\n  is assumed for re-enabled constraints.If you do not want to verify new CHECK or FOREIGN KEY constraints\n  against existing data, use WITH NOCHECK. We do not recommend doing\n  this, except in rare cases. The new constraint will be evaluated in\n  all later data updates. Any constraint violations that are suppressed\n  by WITH NOCHECK when the constraint is added may cause future updates\n  to fail if they update rows with data that does not comply with the\n  constraint. The query optimizer does not consider constraints that are defined\n  WITH NOCHECK. Such constraints are ignored until they are re-enabled\n  by using ALTER TABLE table WITH CHECK CHECK CONSTRAINT ALL.Note: WITH NOCHECK is the default for re-enabling constraints. I have to wonder why...The sys.foreign_keys system view provides some visibility into the issue. Note that it has both an is_disabled and an is_not_trusted column. is_disabled indicates whether future data manipulation operations will be validated against the constraint. is_not_trusted indicates whether all of the data currently in the table has been validated against the constraint.Are your constraints to be trusted? Find out...Right click the table design and go to Relationships and choose the foreign key on the left-side pane and in the right-side pane, set Enforce foreign key constraint to \'Yes\' (to enable foreign key constraints) or \'No\' (to disable it).\nYou should actually be able to disable foreign key constraints the same way you temporarily disable other constraints:Just make sure you\'re disabling the constraint on the first table listed in the constraint name. For example, if my foreign key constraint was FK_LocationsEmployeesLocationIdEmployeeId, I would want to use the following:even though violating this constraint will produce an error that doesn\'t necessarily state that table as the source of the conflict.I have a more useful version if you are interested. I lifted a bit of code from here http://www.dbaservices.com.au/news/drop-recreate-foreign-key-constraints/ modifying it to allow for an array of tables into the stored procedure and it populates the drop, truncate, add statements before executing all of them. This gives you control to decide which tables need truncating.One script to rule them all: this combines truncate and delete commands with sp_MSforeachtable so that you can avoid dropping and recreating constraints - just specify the tables that need to be deleted rather than truncated and for my purposes I have included an extra schema filter for good measure (tested in 2008r2)Answer marked \'905\' looks good but does not work.Following worked for me. Any Primary Key, Unique Key, or Default constraints CAN NOT be disabled. In fact, if \'sp_helpconstraint \'\' shows \'n/a\' in status_enabled - Means it can NOT be enabled/disabled.-- To generate script to DISABLE-- To generate script to ENABLE