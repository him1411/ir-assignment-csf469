Is it possible to construct a snippet of code in Java that would make a hypothetical java.lang.ChuckNorrisException uncatchable?Thoughts that came to mind are using for example interceptors or aspect-oriented programming.I haven\'t tried this, so I don\'t know if the JVM would restrict something like this, but maybe you could compile code which throws ChuckNorrisException, but at runtime provide a class definition of ChuckNorrisException which does not extend Throwable.UPDATE:It doesn\'t work. It generates a verifier error:UPDATE 2:Actually, you can get this to work if you disable the byte code verifier! (-Xverify:none)UPDATE 3:For those following from home, here is the full script:Create the following classes:Compile classes:Run:Comment out "extends RuntimeException" and recompile ChuckNorrisException.java only :Run:Run without verification:After having pondered this, I have successfully created an uncatchable exception. I chose to name it JulesWinnfield, however, rather than Chuck, because it is one mushroom-cloud-laying-mother-exception. Furthermore, it might not be exactly what you had in mind, but it certainly can\'t be caught. Observe:Et voila! Uncaught exception.Output:run:Say \'What\' again! I dare you! I double dare you! Java Result: 8BUILD SUCCESSFUL (total time: 0 seconds)When I have a little more time, I\'ll see if I can\'t come up with something else, as well.Also, check this out:Causes a stack overflow - again, exceptions remain uncaught.With such an exception it would obviously be mandatory to use a System.exit(Integer.MIN_VALUE); from the constructor because this is what would happen if you threw such an exception ;)Any code can catch Throwable. So no, whatever exception you create is going to be a subclass of Throwable and will be subject to being caught. (Granted, technically this exception is never actually thrown, but a proper ChuckNorrisException can\'t be thrown -- it throws you first.)Any exception you throw has to extend Throwable, so it can be always caught. So answer is no.If you want to make it difficult to handle, you can override methods getCause(), getMessage(), getStackTrace(), toString() to throw another java.lang.ChuckNorrisException.My answer is based on @jtahlborn\'s idea, but it\'s a fully working Java program, that can be packaged into a JAR file and even deployed to your favorite application server as a part of a web application.First of all, let\'s define ChuckNorrisException class so that it doesn\'t crash JVM from the beginning (Chuck really loves crashing JVMs BTW :)Now goes Expendables class to construct it:And finally the Main class to kick some butt:Compile and run it with following command:You will get following output:No surprise - it\'s a roundhouse kick after all :)In the constructor you could start a thread which repeatedly calls originalThread.stop (ChuckNorisException.this) The thread could catch the exception repeatedly but would keep throwing it until it dies.No. All exceptions in Java must subclass java.lang.Throwable, and although it may not be good practice, you can catch every type of exception like so:See the java.lang.Throwable documentation for more information.If you\'re trying to avoid checked exceptions (ones that must be explicitly handled) then you will want to subclass Error, or RuntimeException.The only ChuckNorrisExceptions in Java should be OutOfMemoryError and StackOverflowError.You can actually "catch" them in the means that a catch(OutOfMemoryError ex) will execute in case the exception is thrown, but that block will automatically rethrow the exception to the caller.I don\'t think that public class ChuckNorrisError extends Error does the trick but you could give it a try. I found no documentation about extending ErrorActually the accepted answer is not so nice because Java needs to be run without verification, i.e. the code would not work under normal circumstances.AspectJ to the rescue for the real solution!Exception class:Aspect:Sample application:Output:Is it possible to construct a snippet of code in java that would make a hypothetical java.lang.ChuckNorrisException uncatchable?Yes, and here\'s the answer: Design your java.lang.ChuckNorrisException such that it is not an instance of java.lang.Throwable. Why? An unthrowable object is uncatchable by definition because you can never catch something that can never be thrown.A variant on the theme is the surprising fact that you can throw undeclared checked exceptions from Java code. Since it is not declared in the methods signature, the compiler won\'t let you catch the exception itself, though you can catch it as java.lang.Exception.Here\'s a helper class that lets you throw anything, declared or not:Now throw SneakyThrow.sneak(new ChuckNorrisException()); does throw a ChuckNorrisException, but the compiler complains inabout catching an exception that is not thrown if ChuckNorrisException is a checked exception.You can keep ChuckNorris internal or private and encapsulate him or swollow him...try { doChuckAction(); } catch(ChuckNorrisException cne) { /*do something else*/ }Two fundamental problems with exception handling in Java are that it uses the type of an exception to indicate whether action should be taken based upon it, and that anything which takes action based upon an exception (i.e. "catch"es it) is presumed to resolve the underlying condition.  It would be useful to have a means by which an exception object could decide which handlers should execute, and whether the handlers that have executed so far have cleaned things up enough for the present method to satisfy its exit conditions.  While this could be used to make "uncatchable" exceptions, two bigger uses would be to (1) make exceptions which will only be considered handled when they\'re caught by code that actually knows how to deal with them, and (2) allow for sensible handling of exceptions which occur in a finally block (if a FooException during a finally block during the unwinding of a BarException, both exceptions should propagate up the call stack; both should be catchable, but unwinding should continue until both have been caught).  Unfortunately, I don\'t think there would be any way to make existing exception-handling code work that way without breaking things.It is easily possible to simulate a uncaught exception on the current thread. This will trigger the regular behavior of an uncaught exception, and thus gets the job done semantically. It will, however, not necessarily stop the current thread\'s execution, as no exception is actually thrown.This is actually useful in (very rare) situations, for example when proper Error handling is required, but the method is invoked from a framework catching (and discarding) any Throwable.Call System.exit(1) in the finalize, and just throw a copy of the exception from all the other methods, so that the program will exit.Add a throw clause at the end. It\'s a big risk, because nobody throws Chuck Norris! =)