I\'m creating a function where I need to pass an object so that it can be modified by the function. What is the difference between:andWhich should I use and why?ref tells the compiler that the object is initialized before entering the function, while out tells the compiler that the object will be initialized inside the function. So while ref is two-ways, out is out-only.The ref modifier means that:The out modifier means that:Let\'s say Dom shows up at Peter\'s cubicle about the memo about the TPS reports. If Dom were a ref argument, he would have a printed copy of the memo. If Dom were an out argument, he\'d make Peter print a new copy of the memo for him to take with him.I am going to try my hand at an explanation:I think we understand how the value types work right?  Value types are (int, long, struct etc.).  When you send them in to a function without a ref command it COPIES the data. Anything you do to that data in the function only affects the copy, not the original.  The ref command sends the ACTUAL data and any changes will affect the data outside the function. Ok on to the confusing part, reference types:Lets create a reference type:When you new up someobject, two parts are created:Now when you send in someobject into a method without ref it COPIES the reference pointer, NOT the data.  So you now have this:Two references pointing to the same object.  If you modify a property on someobject using reference2 it will affect the same data pointed to by reference1.  If you null out reference2 or point it to new data it will not affect reference1 nor the data reference1 points to.Now what happens when you send someobject by ref to a method?\nThe actual reference to someobject gets sent to the method.  So you now have only one reference to the data:But what does this mean?  It acts exactly the same as sending someobject not by ref except for two main thing:1) When you null out the reference inside the method it will null the one outside the method.2) You can now point the reference to a completely different data location and the reference outside the function will now point to the new data location.ref is in and out.You should use out in preference wherever it suffices for your requirements.Extending the Dog, Cat example. The second method with ref changes the object referenced by the caller. Hence "Cat" !!!In C#, a method can return only one value. If you like to return more than one value, you can use the out keyword. The out modifier return as return-by-reference. The simplest answer is that the keyword \xe2\x80\x9cout\xe2\x80\x9d is used to get the value from the method.In C#, when you pass a value type such as int, float, double etc. as an argument to the method parameter, it is passed by value. Therefore, if you modify the parameter value, it does not affect argument in the method call. But if you mark the parameter with \xe2\x80\x9cref\xe2\x80\x9d keyword, it will reflect in the actual variable. Since you\'re passing in a reference type (a class) there is no need use ref because per default only a reference to the actual object is passed and therefore you always change the object behind the reference.Example:As long you pass in a class you don\'t have to use ref if you want to change the object inside your method."Baker"That\'s because the first one changes your string-reference to point to "Baker". Changing the reference is possible because you passed it via the ref keyword (=> a reference to a reference to a string).\nThe Second call gets a copy of the reference to the string.string looks some kind of special at first. But string is just a reference class and if you define then s is a reference to a string class that contains the text "Able"!\nAnother assignment to the same variable viadoes not change the original string but just creates a new instance and let s point to that instance!You can try it with the following little code example:What do you expect?\nWhat you will get is still "Able" because you just set the reference in s to another instance while s2 points to the original instance.EDIT:\nstring is also immutable which means there is simply no method or property that modifies an existing string instance (you can try to find one in the docs but you won\'t fins any :-) ). All string manipulation methods return a new string instance! (That\'s why you often get a better performance when using the StringBuilder class)ref and out behave similarly except following differences.Out: \nA return statement can be used for returning only one value from a function. However, using output parameters, you can return two values from a function. Output parameters are like reference parameters, except that they transfer data out of the method rather than into it.The following example illustrates this:ref:\nA reference parameter is a reference to a memory location of a variable. When you pass parameters by reference, unlike value parameters, a new storage location is not created for these parameters. The reference parameters represent the same memory location as the actual parameters that are supplied to the method.In C#, you declare the reference parameters using the ref keyword. The following example demonstrates this:ref means that the value in the ref parameter is already set, the method can read and modify it.\nUsing the ref keyword is the same as saying that the caller is responsible for initializing the value of the parameter.out tells the compiler that the initialization of object is the responsibility of\nthe function, the function has to assign to the out parameter. \nIt\'s not allowed to leave it unassigned.Read here.ref  and out work just  like passing by references and passing by pointers as in C++. For ref, the argument must declared and initialized.For out, the argument must declared but  may or may not be initializedFor those that learn by example (like me) here\'s what Anthony Kolesov is saying.I\'ve created some minimal examples of ref, out, and others to illustrate the point. I\'m not covering best practices, just examples to understand the differences.https://gist.github.com/2upmedia/6d98a57b68d849ee7091They\'re pretty much the same - the only difference is that a variable you pass as an out parameter doesn\'t need to be initialised, and the method using the ref parameter has to set it to something.Ref parameters are for data that might be modified, out parameters are for data that\'s an additional output for the function (eg int.TryParse) that are already using the return value for something.you can check this code it will describe you its complete differnce\nwhen you use "ref" its mean that u already initialize that int/stringbut\n when you use "out"\nit works in both conditions wheather u initialize that int/string or not\nbut u must initialize that int/string in that function Below I have shown an example using both Ref and out. Now, you all will be cleared about ref and out. In below mentioned example when i comment //myRefObj = new myClass { Name = "ref outside called!! " };\nline, will get an error saying "Use of unassigned local variable \'myRefObj\'", but there is no such error in out.Where to use Ref: when we are calling a procedure with an in parameter and the same parameter will be used to store the output of that proc.Where to use Out: when we are calling a procedure with no in parameter and teh same param will be used to return the value from that proc.\nAlso note the outputFrom the standpoint of a method which receives a parameter, the difference between ref and out is that C# requires that methods must write to every out parameter before returning, and must not do anything with such a parameter, other than passing it as an out parameter or writing to it, until it has been either passed as an out parameter to another method or written directly.  Note that some other languages do not impose such requirements; a virtual or interface method which is declared in C# with an out parameter may be overridden in another language which does not impose any special restrictions on such parameters.From the standpoint of the caller, C# will in many circumstances assume when calling a method with an out parameter will cause the passed variable to be written without having been read first.  This assumption may not be correct when calling methods written in other languages.  For example:If myDictionary identifies an IDictionary<TKey,TValue> implementation written in a language other than C#, even though MyStruct s = new MyStruct(myDictionary); looks like an assignment, it could potentially leave s unmodified.Note that constructors written in VB.NET, unlike those in C#, make no assumptions about whether called methods will modify any out parameters, and clear out all fields unconditionally.  The odd behavior alluded to above won\'t occur with code written entirely in VB or entirely in C#, but can occur when code written in C# calls a method written in VB.NET.Ref:\nThe ref keyword is used to pass an argument as a reference. This means that when value of that parameter is changed in the method, it gets reflected in the calling method. An argument that is passed using a ref keyword must be initialized in the calling method before it is passed to the called method.Out:\nThe out keyword is also used to pass an argument like ref keyword, but the argument can be passed without assigning any value to it. An argument that is passed using an out keyword must be initialized in the called method before it returns back to calling method.Ref and out in method overloadingBoth ref and out cannot be used in method overloading simultaneously. However, ref and out are treated differently at run-time but they are treated same at compile time (CLR doesn\'t differentiates between the two while it created IL for ref and out).If you want to pass your parameter as a ref then you should initialize it before passing parameter to the function else compiler itself will show the error.But in case of out parameter you don\'t need to initialize the object parameter before passing it to the method.You can initialize the object in the calling method itself.The ref is here well explained, but keep in mind that the ref might be called with uninitialized object.See this example - note the scope of the s1Authoring Time:(1) We create the calling method Main()(2) it creates a List object (which is a reference type object) and stores it in the variable myList.During Runtime:(3) Runtime allocates a memory on stack at #00, wide enough to store an address (#00 = myList, since variable names are really just aliases for memory locations)(4) Runtime creates a list object on heap at memory location #FF( all these addresses are for example sakes)(5) Runtime would then store the starting address #FF of the object at #00(or in words, stores the reference of the List object in the pointer myList)Back to Authoring Time:(6) We then pass the List object as argument myParamList to the called method modifyMyList and assign a new List object to itDuring Runtime:(7) Runtime starts the call routine for the called method and as part of it, checks the type of parameters.(8) Upon finding the reference type, it allocates a memory on stack at #04 for aliasing the parameter variable myParamList.(9) It then stores the value #FF in it as well.(10) Runtime creates a list object on heap at memory location #004 and replaces #FF in #04 with this value(or dereferenced the original List object and pointed to the new List object in this method)The address in #00 is not altered and retains the reference to #FF(or the original myList pointer is not disturbed).The ref keyword is a compiler directive to skip the generation of runtime code for (8) and (9) which means there will be no heap allocation for method parameters. It will use the original #00 pointer to operate on the object at #FF. If the original pointer is not initialised, the runtime will halt complaining it can\xe2\x80\x99t proceed since the variable isn\xe2\x80\x99t initialisedThe out keyword is a compiler directive which pretty much is the same as ref with a slight modification at (9) and (10). The compiler expects the argument to be uninitialised and will continue with (8), (4) and (5) to create an object on heap and to stores its starting address in the argument variable. No uninitialised error will be thrown and any previous reference stored will be lost.Mind well that the reference parameter which is passed inside the function is directly worked on.For example,This will write Dog, not Cat. Hence you should directly work on someObject.I may not be so good at this, but surely strings (even though they are technically reference types and live on the heap) are passed by value, not reference?This why you need ref if you want changes to exist outside of the scope of the function making them, you aren\'t passing a reference otherwise.As far as I am aware you only need ref for structs/value types and string itself, as string is a reference type that pretends it is but is not a value type.I could be completely wrong here though, I am new. 