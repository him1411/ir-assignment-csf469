I keep hearing a lot about functors in C++. Can someone give me an overview as to what they are and in what cases they would be useful?A functor is pretty much just a class which defines the operator(). That lets you create objects which "look like" a function:There are a couple of nice things about functors. One is that unlike regular functions, they can contain state. The above example creates a function which adds 42 to whatever you give it. But that value 42 is not hardcoded, it was specified as a constructor argument when we created our functor instance. I could create another adder, which added 27, just by calling the constructor with a different value. This makes them nicely customizable.As the last lines show, you often pass functors as arguments to other functions such as std::transform or the other standard library algorithms. You could do the same with a regular function pointer except, as I said above, functors can be "customized" because they contain state, making them more flexible (If I wanted to use a function pointer, I\'d have to write a function which added exactly 1 to its argument. The functor is general, and adds whatever you initialized it with), and they are also potentially more efficient. In the above example, the compiler knows exactly which function std::transform should call. It should call add_x::operator(). That means it can inline that function call. And that makes it just as efficient as if I had manually called the function on each value of the vector.If I had passed a function pointer instead, the compiler couldn\'t immediately see which function it points to, so unless it performs some fairly complex global optimizations, it\'d have to dereference the pointer at runtime, and then make the call.Little addition. You can use boost::function, to create functors from functions and methods, like this:and you can use boost::bind to add state to this functorand most useful, with boost::bind and boost::function you can create functor from class method, actually this is a delegate:You can create list or vector of functorsThere is one problem with all this stuff, compiler error messages is not human readable :)A Functor is a object which acts like a function.\nBasically, a class which defines operator().The real advantage is that a functor can hold state. Like others have mentioned, a functor is an object that acts like a function, i.e. it overloads the function call operator.Functors are commonly used in STL algorithms. They are useful because they can hold state before and between function calls, like a closure in functional languages. For example, you could define a MultiplyBy functor that multiplies its argument by a specified amount:Then you could pass a MultiplyBy object to an algorithm like std::transform:Another advantage of a functor over a pointer to a function is that the call can be inlined in more cases. If you passed a function pointer to transform, unless that call got inlined and the compiler knows that you always pass the same function to it, it can\'t inline the call through the pointer.Name "functor" has been traditionaly used in category theory long before C++ appeared on the scene. This has nothing to do with C++ concept of functor. It\'s better to use name function object instead of what we call "functor" in C++. This is how other programming languages call similar constructs.Used instead of plain function:Features:Cons:Used instead of function pointer:Features:Cons:Used instead of virtual function:Features:Cons:For the newbies like me among us: after a little research I figured out what the code jalf posted did.A functor is a class or struct object which can be "called" like a function. This is made possible by overloading the () operator. The () operator (not sure what its called) can take any number of arguments. Other operators only take two i.e. the + operator can only take two values (one on each side of the operator) and return whatever value you have overloaded it for. You can fit any number of arguments inside a () operator which is what gives it its flexibility.To create a functor first you create your class. Then you create a constructor to the class with a parameter of your choice of type and name. This is followed in the same statement by an initializer list (which uses a single colon operator, something I was also new to) which constructs the class member objects with the previously declared parameter to the constructor. Then the () operator is overloaded. Finally you declare the private objects of the class or struct you have created.My code (I found jalf\'s variable names confusing)If any of this is inaccurate or just plain wrong feel free to correct me! A functor is a higher-order function that applies a function to the parametrized(ie templated) types. It is a generalization of the map higher-order function. For example, we could define a functor for std::vector like this:This function takes a std::vector<T> and returns std::vector<U> when given a function F that takes a T and returns a U. A functor doesn\'t have to be defined over container types, it can be defined for any templated type as well, including std::shared_ptr:Heres a simple example that converts the type to a double:There are two laws that functors should follow. The first is the identity law, which states that if the functor is given an identity function, it should be the same as applying the identity function to the type, that is fmap(identity, x) should be the same as identity(x):The next law is the composition law, which states that if the functor is given a composition of two functions, it should be the same as applying the functor for the first function and then again for the second function. So, fmap(std::bind(f, std::bind(g, _1)), x) should be the same as fmap(f, fmap(g, x)):Here\'s an actual situation where I was forced to use a Functor to solve my problem:I have a set of functions (say, 20 of them), and they are all identical, except each calls a different specific function in 3 specific spots.This is incredible waste, and code duplication.  Normally I would just pass in a function pointer, and just call that in the 3 spots. (So the code only needs to appear once, instead of twenty times.)But then I realized, in each case, the specific function required a completely different parameter profile! Sometimes 2 parameters, sometimes 5 parameters, etc.Another solution would be to have a base class, where the specific function is an overridden method in a derived class. But do I really want to build all of this INHERITANCE, just so I can pass a function pointer????SOLUTION:  So what I did was, I made a wrapper class (a "Functor") which is able to call any of the functions I needed called.  I set it up in advance (with its parameters, etc) and then I pass it in instead of a function pointer.  Now the called code can trigger the Functor, without knowing what is happening on the inside. It can even call it multiple times (I needed it to call 3 times.)That\'s it -- a practical example where a Functor turned out to be the obvious and easy solution, which allowed me to reduce code duplication from 20 functions to 1.Except for used in callback, C++ functors can also help to provide a Matlab liking access style  to a matrix  class. There is a example.Functors are used in gtkmm to connect some GUI button to an actual C++ function or method.If you use the pthread library to make your app multithreaded, Functors can help you.\nTo start a thread, one of the arguments of the pthread_create(..) is the function pointer to be executed on his own thread.\n But there\'s one inconvenience. This pointer can\'t be a pointer to a method, unless it\'s a static method, or unless you specify it\'s class, like class::method. And another thing, the interface of your method can only be:So you can\'t run (in a simple obvious way), methods from your class in a thread without doing something extra.  A very good way of dealing with threads in C++, is creating your own Thread class. If you wanted to run methods from MyClass class, what I did was, transform those methods into Functor derived classes.  Also, the Thread class has this method:\nstatic void* startThread(void* arg)\nA pointer to this method will be used as an argument to call pthread_create(..).    And what startThread(..) should receive in arg is a void* casted reference to an instance in heap of any Functor derived class, which will be casted back to Functor* when executed, and then called it\'s run() method.To add on ,I have used function objects to fit an existing legacy method to the command pattern; (only place where the beauty of OO paradigm true OCP I felt );\n Also adding here the related function adapter pattern.Suppose your method has the signature:We will see how we can fit it for the Command pattern - for this, first, you have to write a member function adapter so that it can be called as a function object.Note - this is ugly, and may be you can use the Boost bind helpers etc., but if you can\'t or don\'t want to, this is one way.Also, we need a helper method mem_fun3 for the above class to aid in calling.}Now, in order to bind the parameters, we have to write a binder function. So, here it goes:And, a helper function to use the binder3 class - bind3:Now, we have to use this with the Command class; use the following typedef:Here is how you call it:Note: f3(); will call the method task1->ThreeParameterTask(21,22,23);.The full context of this pattern at the following linkLike has been repeated, functors are classes that can be treated as functions (overload operator ()).They are most useful for situations in which you need to associate some data with repeated or delayed calls to a function.For example, a linked-list of functors could be used to implement a basic low-overhead synchronous coroutine system, a task dispatcher, or interruptable file parsing.\nExamples:Of course, these examples aren\'t that useful in themselves. They only show how functors can be useful, the functors themselves are very basic and inflexible and this makes them less useful than, for example, what boost provides.Functor can also be used to simulate defining a local function within a function. Refer to the  question and another.But a local functor can not access outside auto variables. The lambda (C++11) function is a better solution.A big advantage of implementing functions as functors is that they can maintain and reuse state between calls. For example, many dynamic programming algorithms, like the Wagner-Fischer algorithm for calculating the Levenshtein distance between strings, work by filling in a large table of results. It\'s very inefficient to allocate this table every time the function is called, so implementing the function as a functor and making the table a member variable can greatly improve performance.Below is an example of implementing the Wagner-Fischer algorithm as a functor. Notice how the table is allocated in the constructor, and then reused in operator(), with resizing as necessary.I have "discovered" a very interesting use of functors: I use them when I have not a good name for one method, as a functor is a method without name ;-)