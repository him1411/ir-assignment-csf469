Can someone give me the code to encrypt and decrypt a string in C#?EDIT 2013-Oct: Although I\'ve edited this answer over time to address shortcomings, please see jbtule\'s answer for a more robust, informed solution.https://stackoverflow.com/a/10366194/188474Original Answer:Here\'s a working example derived from the "RijndaelManaged Class" documentation and the MCTS Training Kit.  EDIT 2012-April: This answer was edited to pre-pend the IV per jbtule\'s suggestion and as illustrated here:http://msdn.microsoft.com/en-us/library/system.security.cryptography.aesmanaged%28v=vs.95%29.aspxGood luck!Modern Examples of Symmetric Authenticated Encryption of a string. The general best practice for symmetric encryption is to use Authenticated Encryption with Associated Data (AEAD), however this isn\'t a part of the standard .net crypto libraries. So the first example uses AES256 and then HMAC256, a two step Encrypt then MAC, which requires more overhead and more keys.The second example uses the simpler practice of AES256-GCM using the open source Bouncy Castle (via nuget).Both examples have a main function that takes secret message string, key(s) and an optional non-secret payload and return and authenticated encrypted string optionally prepended with the non-secret data. Ideally you would use these with 256bit key(s) randomly generated see NewKey().Both examples also have a helper methods that use a string password to generate the keys. These helper methods are provided as a convenience to match up with other examples, however they are far less secure because the strength of the password is going to be far weaker than a 256 bit key.Update:\nAdded byte[] overloads, and only the Gist has the full formatting with 4 spaces indent and api docs due to StackOverflow answer limits..NET Built-in Encrypt(AES)-Then-MAC(HMAC) [Gist]Bouncy Castle AES-GCM [Gist]Here is an example using RSA. Important: There is a limit to the size of data you can encrypt with the RSA encryption, KeySize - MinimumPadding. e.g. 256 bytes (assuming 2048 bit key) - 42 bytes (min OEAP padding) = 214 bytes (max plaintext size)Replace your_rsa_key with your RSA key.For more info, visit MSDN - RSACryptoServiceProvider BouncyCastle is a great Crypto library for .NET, it\'s available as a Nuget package for install into your projects.  I like it a lot more than what\'s currently available in the System.Security.Cryptography library.  It gives you a lot more options in terms of available algorithms, and provides more modes for those algorithms.This is an example of an implementation of TwoFish, which was written by Bruce Schneier (hero to all us paranoid people out there).   It\'s a symmetric algorithm like the Rijndael\n(aka AES).  It was one of the three finalists for the AES standard and sibling to another famous algorithm written by Bruce Schneier called BlowFish.First thing with bouncycastle is to create an encryptor class, this will make it easier to implement other block ciphers within the library.  The following encryptor class takes in a generic argument T where T implements IBlockCipher and has a default constructor.UPDATE:  Due to popular demand I have decided to implement generating a random IV as well as include an HMAC into this class.  Although from a style perspective this goes against the SOLID principle of single responsibility, because of the nature of what this class does I reniged.  This class will now take two generic parameters, one for the cipher and one for the digest.  It automatically generates the IV using RNGCryptoServiceProvider to provide good RNG entropy, and allows you to use whatever digest algorithm you want from BouncyCastle to generate the MAC.Next just call the encrypt and decrypt methods on the new class, here\'s the example using twofish:It\'s just as easy to substitute another block cipher like TripleDES:Finally if you want to use AES with SHA256 HMAC you can do the following:The hardest part about encryption actually deals with the keys and not the algorithms.  You\'ll have to think about where you store your keys, and if you have to, how you exchange them.  These algorithms have all withstood the test of time, and are extremely hard to break. Someone who wants to steal information from you isn\'t going to spend eternity doing cryptanalysis on your messages, they\'re going to try to figure out what or where your key is.  So #1 choose your keys wisely, #2 store them in a safe place, if you use a web.config and IIS then you can encrypt parts of the the web.config, and finally if you have to exchange keys make sure that your protocol for exchanging the key is secure.Update 2\nChanged compare method to mitigate against timing attacks.  See more info here http://codahale.com/a-lesson-in-timing-attacks/ .  Also updated to default to PKCS7 padding and added new constructor to allow end user the ability to choose which padding they would like to use.  Thanks @CodesInChaos for the suggestions.If you are using ASP.Net you can now use built in functionality in .Net 4.0 onwards.System.Web.Security.MachineKey.Net 4.5 has MachineKey.Protect() and MachineKey.Unprotect()..Net 4.0 has MachineKey.Encode() and MachineKey.Decode(). You should just set the MachineKeyProtection to \'All\'.Outside of ASP.Net this class seems to generate a new key with every app restart so doesn\'t work. With a quick peek in ILSpy it looks to me like it generates its own defaults if the appropriate app.settings are missing. So you may actually be able to set it up outside ASP.Net.I haven\'t been able to find a non-ASP.Net equivalent outside the System.Web namespace.EncryptionDecryption:    Disclaimer: This solution should only be used for data at rest that is not exposed to the public (for example - a configuration file or DB). Only in this scenario, the quick-and-dirty solution can be considered better than @jbtule\'s solution, due to lower maintanance.Original post:\nI found jbtule\'s answer a bit complicated for a quick and dirty secured AES string encryption and Brett\'s answer had a bug with the Initialization Vector being a fixed value making it vulnerable to padding attacks, so I fixed Brett\'s code and added a random IV that is added to the chipered string, creating a different encrypted value each and every encryption of the same value:Encryption:Decryption:Replace EncryptionKey with your key.\nIn my implementation, the key is being saved in the configuration file (web.config\\app.config) as you shouldn\'t save it hard coded. The configuration file should be also encrypted so the key won\'t be saved as clear text in it.With the reference of Encrypt and Decrypt a String in c#, I found one of good solution :For EncryptFor DecryptHere is a simple example of encrypting strings in C# using AES CBC mode with random IV and HMAC and password-derived keys, to show the basic moving parts:If you got here looking for PGP encryption, in the following comment on an example of how to use PGP encryption via BouncyCastle, the PGPEncryptDecrypt class seems to work basically out of the box:http://blogs.microsoft.co.il/kim/2009/01/23/pgp-zip-encrypted-files-with-c/#comment-611002Too long to paste here, slightly modified:  https://gist.github.com/zaus/c0ea1fd8dad5d9590af1To support mattmanser answer. Here\'s an example using MachineKey class to encrypt/decrypt URL safe values. Something to bear in mind, as mentioned before, this will use Machine config settings (https://msdn.microsoft.com/en-us/library/ff649308.aspx). You can set encryption and decryption key/algorithm manually (you might need this specially if your site is running on multiple servers) in web.config file. You can generate keys from IIS (see here: https://blogs.msdn.microsoft.com/vijaysk/2009/05/13/iis-7-tip-10-you-can-generate-machine-keys-from-the-iis-manager/) or can use an online machine key generator like: http://www.developerfusion.com/tools/generatemachinekey/An alternative to BouncyCastle for AES-GCM encryption is libsodium-net. It wraps the libsodium C library. One nice advantage is that it uses the AES-NI extension in CPUs for very fast encryption. The down side is that it won\'t work at all if the CPU doesn\'t have the extension. There\'s no software fall back.This is the class that was placed here by Brett. However I made a slight edit since I was receiving the error \'Invalid length for a Base-64 char array\' when using it for URL strings to encrypt and decrypt.Encryption is a very common matter in programming. I think it is better to install a package to do the task for you. Maybe a simple open source Nuget project like \nSimple Aes EncryptionThe key is in the config file and therefore it is easy to change in the production environment, and I don\'t see any drawbacksCopied in my answer here from a similar question: Simple two-way encryption for C#.Based on multiple answers and comments.Code:Here is simple Snippet originally by ASP Snippets   A good algorithm to securely encrypt data is BCrypt:Besides incorporating a salt to protect against rainbow table attacks,\n  bcrypt is an adaptive function: over time, the iteration count can be\n  increased to make it slower, so it remains resistant to brute-force\n  search attacks even with increasing computation power.There\'s a nice .NET implementation of BCrypt that is available also as a NuGet package.AES Algorithm:for simplicity i made for myself this function that i use for non crypto purposes : replace "yourpassphrase" with your password ...}I want to give you my contribute, with my code for AES Rfc2898DeriveBytes (here the documentation) algorhytm, written in C# (.NET framework 4) and fully working also for limited platforms, as .NET Compact Framework for Windows Phone 7.0+ (not all platforms support every criptographic method of the .NET framework!).I hope this can help anyone!You have to use the namespace using System.Security.Cryptography; and useHashing is a bool type either true or false. String variable "key" should be same for Encryption and for Decryption