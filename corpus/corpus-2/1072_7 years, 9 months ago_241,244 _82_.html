Is there a method like isiterable? The only solution I have found so far is to callBut I am not sure how fool-proof this is.Checking for __iter__ works on sequence types, but it would fail on e.g. strings in Python 2. I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):The iter built-in checks for the __iter__ method or in the case of strings the __getitem__ method. In Python 2, to check if an object is "list like" and not "string like" then the key is the attributes __getitem__ and __iter__:Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object. The Python glossary:Pythonic programming style that determines an object\'s type by inspection of its method or attribute signature rather than by explicit relationship to some type object ("If it looks like a duck and quacks like a duck, it must be a duck.") By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). Instead, it typically employs the EAFP (Easier to Ask Forgiveness than Permission) style of programming....The collections module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:NB: generic behavior changed in Python 3 (strings are now iterable), so be careful if you want to use iter to differentiate between types.\nSee "iterable but not string" for details.Use the Abstract Base Classes. They need at least Python 2.6 and work only for new-style classes.This isn\'t sufficient: the object returned by __iter__ must implement the iteration protocol (i.e. next method). See the relevant section in the documentation.In Python, a good practice is to "try and see" instead of "checking".I\'d like to shed a little bit more light on the interplay of iter, __iter__ and __getitem__ and what happens behind the curtains. Armed with that knowledge, you will be able to understand why the best you can do isI will list the facts first and then follow up with a quick reminder of what happens when you employ a for loop in python, followed by a discussion to illustrate the facts.You can get an iterator from any object o by calling iter(o) if at least one of the following conditions holds true: a) o has an __iter__ method which returns an iterator object. An iterator is any object with an __iter__ and a __next__ (Python 2: next) method. b) o has a __getitem__ method.Checking for an instance of Iterable or Sequence, or checking for the\nattribute __iter__ is not enough.If an object o implements only __getitem__, but not __iter__, iter(o) will construct\nan iterator that tries to fetch items from o by integer index, starting at index 0. The iterator will catch any IndexError (but no other errors) that is raised and then raises StopIteration itself.In the most general sense, there\'s no way to check whether the iterator returned by iter is sane other than to try it out.If an object o implements __iter__, the iter function will make sure\nthat the object returned by __iter__ is an iterator. There is no sanity check\nif an object only implements __getitem__.__iter__ wins. If an object o implements both __iter__ and __getitem__, iter(o) will call __iter__.If you want to make your own objects iterable, always implement the __iter__ method.In order to follow along, you need an understanding of what happens when you employ a for loop in Python. Feel free to skip right to the next section if you already know.When you use for item in o for some iterable object o, Python calls iter(o) and expects an iterator object as the return value. An iterator is any object which implements a __next__ (or next in Python 2) method and an __iter__ method. By convention, the __iter__ method of an iterator should return the object itself (i.e. return self). Python then calls next on the iterator until StopIteration is raised. All of this happens implicitly, but the following demonstration makes it visible:Iteration over a DemoIterable:On point 1 and 2: getting an iterator and unreliable checksConsider the following class:Calling iter with an instance of BasicIterable will return an iterator without any problems because BasicIterable implements __getitem__.However, it is important to note that b does not have the __iter__ attribute and is not considered an instance of Iterable or Sequence:This is why Fluent Python by Luciano Ramalho recommends calling iter and handling the potential TypeError as the most accurate way to check whether an object is iterable. Quoting directly from the book:As of Python 3.4, the most accurate way to check whether an object x is iterable is to call iter(x) and handle a TypeError exception if it isn\xe2\x80\x99t. This is more accurate than using isinstance(x, abc.Iterable) , because iter(x) also considers the legacy __getitem__ method, while the Iterable ABC does not.On point 3: Iterating over objects which only provide __getitem__, but not __iter__Iterating over an instance of BasicIterable works as expected: Python\nconstructs an iterator that tries to fetch items by index, starting at zero, until an IndexError is raised. The demo object\'s __getitem__ method simply returns the item which was supplied as the argument to __getitem__(self, item) by the iterator returned by iter.Note that the iterator raises StopIteration when it cannot return the next item and that the IndexError which is raised for item == 3 is handled internally. This is why looping over a BasicIterable with a for loop works as expected:Here\'s another example in order to drive home the concept of how the iterator returned by iter tries to access items by index. WrappedDict does not inherit from dict, which means instances won\'t have an __iter__ method.Note that calls to __getitem__ are delegated to dict.__getitem__ for which the square bracket notation is simply a shorthand.On point 4 and 5: iter checks for an iterator when it calls __iter__:When iter(o) is called for an object o, iter will make sure that the return value of __iter__, if the method is present, is an iterator. This means that the returned object\nmust implement __next__ (or next in Python 2) and __iter__. iter cannot perform any sanity checks for objects which only\nprovide __getitem__, because it has no way to check whether the items of the object are accessible by integer index.Note that constructing an iterator from FailIterIterable instances fails immediately, while constructing an iterator from FailGetItemIterable succeeds, but will throw an Exception on the first call to __next__.On point 6: __iter__ winsThis one is straightforward. If an object implements __iter__ and __getitem__, iter will call __iter__. Consider the following classand the output when looping over an instance:On point 7: your iterable classes should implement __iter__You might ask yourself why most builtin sequences like list implement an __iter__ method when __getitem__ would be sufficient.After all, iteration over instances of the class above, which delegates calls to __getitem__ to list.__getitem__ (using the square bracket notation), will work fine:The reasons your custom iterables should implement __iter__ are as follows:That is why any Python sequence is iterable: they all implement __getitem__ . In fact,\n  the standard sequences also implement __iter__, and yours should too, because the\n  special handling of __getitem__ exists for backward compatibility reasons and may be\n  gone in the future (although it is not deprecated as I write this).Don\'t run checks to see if your duck really is a duck to see if it is iterable or not, treat it as if it was and complain if it wasn\'t.In Python <= 2.5, you can\'t and shouldn\'t - iterable was an "informal" interface.But since Python 2.6 and 3.0 you can leverage the new ABC (abstract base class) infrastructure along with some builtin ABCs which are available in the collections module:Now, whether this is desirable or actually works, is just a matter of conventions. As you can see, you can register a non-iterable object as Iterable - and it will raise an exception at runtime. Hence, isinstance acquires a "new" meaning - it just checks for "declared" type compatibility, which is a good way to go in Python.On the other hand, if your object does not satisfy the interface you need, what are you going to do? Take the following example:If the object doesn\'t satisfy what you expect, you just throw a TypeError, but if the proper ABC has been registered, your check is unuseful. On the contrary, if the __iter__ method is available Python will automatically recognize object of that class as being Iterable.So, if you just expect an iterable, iterate over it and forget it. On the other hand, if you need to do different things depending on input type, you might find the ABC infrastructure pretty useful.The best solution I\'ve found so far:hasattr(obj, \'__contains__\')which basically checks if the object implements the in operator.Advantages (none of the other solutions has all three):Notes: I found a nice solution here:You could try this:If we can make a generator that iterates over it (but never use the generator so it doesn\'t take up space), it\'s iterable. Seems like a "duh" kind of thing. Why do you need to determine if a variable is iterable in the first place?According to the Python 2 Glossary, iterables areall sequence types (such as list, str, and tuple) and some non-sequence types like dict and file and objects of any classes you define with an __iter__() or __getitem__() method. Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), ...). When an iterable object is passed as an argument to the built-in function iter(), it returns an iterator for the object.Of course, given the general coding style for Python based on the fact that it\'s \xe2\x80\x9cEasier to ask for forgiveness than permission.\xe2\x80\x9d, the general expectation is to useBut if you need to check it explicitly, you can test for an iterable by hasattr(object_in_question, "__iter__") or hasattr(object_in_question, "__getitem__"). You need to check for both, because strs don\'t have an __iter__ method (at least not in Python 2, in Python 3 they do) and because generator objects don\'t have a __getitem__ method.I often find convenient, inside my scripts, to define an iterable function.\n(Now incorporates Alfe\'s suggested simplification):so you can test if any object is iterable in the very readable formas you would do with thecallable functionEDIT: if you have numpy installed, you can simply do: from numpy import iterable, \nwhich is simply something likeIf you do not have numpy, you can simply implement this code, or the one above.pandas has a built-in function like that:The easiest way, respecting the Python\'s duck typing, is to catch the error (Python knows perfectly what does it expect from an object to become an iterator):Notes:I think I understand your concern: How does callable exists as a check if I could also rely on duck typing to raise an AttributeError if __call__ is not defined for my object, but that\'s not the case for iterable checking?I don\'t know the answer, but you can either implement the function I (and other users) gave, or just catch the exception in your code (your implementation in that part will be like the function I wrote - just ensure you isolate the iterator creation from the rest of the code so you can capture the exception and distinguish it from another TypeError.This will say yes to all manner of iterable objects, but it will say no to strings in Python 2. (That\'s what I want for example when a recursive function could take a string or a container of strings.  In that situation, asking forgiveness may lead to obfuscode, and it\'s better to ask permission first.)Many other strategies here will say yes to strings. Use them if that\'s what you want.The O.P. hasattr(x, \'__iter__\') approach will also say no to strings, but thanks @LuisMasuelli for noticing it will let you down on a buggy __iter__.Note, in Python 3 True == is_iterable(b"string") and True == is_iterable("string".encode(\'utf-8\')).The isiterable func at the following code returns True if object is iterable. if it\'s not iterable returns Falseexample