I have an array:  array( 4 => \'apple\', 7 => \'orange\', 13 => \'plum\' )I would like to get the first element of this array. Expected result: string apple One requirement: it cannot be done with passing by reference, so array_shift is not a good solution.How can I do this?Original answer, but costly (O(n)):In O(1):Edited with suggestions from comments for other use cases etc...If modifying (in the sense of resetting array pointers) of $array is not a problem, you might use:This should be theoretically more efficient, if a array "copy" is needed:With PHP 5.4+ (but might cause an index error if empty):As Mike pointed out (the easiest possible way):If you want to get the key: (execute it after reset)From PHP\'s documentation:mixed reset ( array &$array );Description:reset() rewinds array\'s internal pointer to the first element and returns the value of the first array element, or FALSE if the array is\n  empty.Hope this helps. :)If you don\'t want to lose the current pointer position, just create an alias for the array.You can get Nth element with a language construct "list":with array_keys function you can do the same for keys:simply current($array) can solve PHP 5.4+:Suppose:Just use:to get first element orto get first key.Or you can unlink the first if you want to remove it.Some arrays don\'t work with functions like list, reset or current. Maybe they\'re "faux" arrays - partially implementing ArrayIterator, for example.If you want to pull the first value regardless of the array, you can short-circuit an iterator:Your value will then be available in $value and the loop will break after the first iteration. This is more efficient than copying a potentially large array to a function like array_unshift(array_values($arr)).You can grab the key this way too:If you\'re calling this from a function, simply return early:Simply do:I would do echo current($array) . This is much more efficient than array_values() because the each() function does not copy the entire array.For more info see http://www.php.net/manual/en/function.each.phpMost of these work! BUT for a quick single line (low resource) call:A kludgy way is:Output:I think using array_values would be your best bet here. You could return the value at index zero from the result of that function to get \'apple\'.This is a little late to the game, but I was presented with a problem where my array contained array elements as children inside it, and thus I couldn\'t just get a string representation of the first array element. By using PHP\'s current() function, I managed this:Thanks to all the current solutions helped me get to this answer, I hope this helps someone sometime!A small change to what Sarfraz posted is:From Laravel\'s helpers:The array being passed by value to the function, the reset() affects the internal pointer of a copy of the array, it doesn\'t touch the original array. (note it returns false if the array is empty)Usage example: Also, here is an alternative. It\'s very marginally faster, but more interesting, it lets easily change the default value if the array is empty:Use:By default, array_slice does not preserve keys, so we can safely use zero as the index.Two solutions for you.Solution 1 - Just use the key. You have not said, that you can not use it. :)Solution 2 - array_flip() + key()Solution 3 - array_keys()Get first element:Get last elementThis is not soo simple response in real world. Supost that we have this examples of possibles responses that you can find in some libraries. Like you can see, we have several \'one line\' solutions that work well in some cases, but not in all.In my opinion, you have should that handler only with arrays.Now talking about performance, assuming that we have always array, like this:array_shift is more fast that reset, that is more fast that [count()-1] and this three are more fast that array_values and array_sliceI like the "list" example, but "list" only works on the left-hand-side of an assignment. If we don\'t want to assign a variable, we would be forced to make up a temporary name, which at best pollutes our scope and at worst overwrites an existing value:The above will overwrite any existing value of $x, and the $x variable will hang around as long as this scope is active (the end of this function/method, or forever if we\'re in the top-level). This can be worked around using call_user_func and an anonymous function, but it\'s clunky:If we use anonymous functions like this, we can actually get away with reset and array_shift, even though they use pass-by-reference. This is because calling a function will bind its arguments, and these arguments can be passed by reference: However, this is actually overkill, since call_user_func will perform this temporary assignment internally. This lets us treat pass-by-reference functions as if they were pass-by-value, without any warnings or errors:Also worth bearing in mind the context in which you\'re doing this, as an exhaustive check can be expensive and not always necessary.For example, this solution works fine for the situation in which I\'m using it (but obviously can\'t be relied on in all cases...)Use array_keys() to access the keys of your associative array as a numerical indexed array, which is then again can be used as key for the array.When the solution is arr[0]:(Note, that since the array with the keys is 0-based index, the 1st\n  element is index 0)You can use a variable and then subtract one, to get your logic, that 1 => \'apple\'.Output:Well, for simplicity- just use:Output:By the first method not just the first element, but can treat an associative array like an indexed array.I don\'t like fiddling with the array\'s internal pointer, but it\'s also inefficient to build a second array with array_keys() or array_values(), so I usually define this:Old post but anyway... I imagine the author just was looking for a way to get the first element of array after getting it from some function (mysql_fetch_row for example) without generating a STRICT "Only variables should be passed by reference". If it so, almos all ways described here will get this message... and some of them uses a lot of additional memory duplicating an array (or some part of it). An easy way to avoid it is just assigning the value inline before calling any of those functions:This way you don\'t get the STRICT message on screen neither in logs and you don\'t create any additional arrays. It works with both indexed AND associative arraysNice one with a combination of array_slice and implode: