I have seen this mentioned a few times and I am not clear on what it means. When and why would you do this? I know what interfaces do, but the fact I am not clear on this makes me think I am missing out on using them correctly. Is it just so if you were to do:You could use any class that implements IInterface? When would you need to do that? The only thing I can think of is if you have a method and you are unsure of what object will be passed expect for it implementing IInterface. I cannot think how often you would need to do that... (Also, how could you write a method that takes in an object that implements an interface? Is that possible?)Sorry if I completely missed the point. There are some wonderful answers on here to this questions that get into all sorts of great detail about interfaces and loosely coupling code, inversion of control and so on.  There are some fairly heady discussions, so I\'d like to take the opportunity to break things down a bit for understanding why an interface is useful.When I first started getting exposed to interfaces, I too was confused about their relevance.  I didn\'t understand why you needed them.  If we\'re using a language like Java or C#, we already have inheritance and I viewed interfaces as a weaker form of inheritance and thought, "why bother?"  In a sense I was right, you can think of interfaces as sort of a weak form of inheritance, but beyond that I finally understood their use as a language construct by thinking of them as a means of classifying common traits or behaviors that were exhibited by potentially many non-related classes of objects.For example -- say you have a SIM game and have the following classes:Clearly, these two objects have nothing in common in terms of direct inheritance.  But, you could say they are both annoying.  Let\'s say our game needs to have some sort of random thing that annoys the game player when they eat dinner.  This could be a HouseFly or a Telemarketer or both -- but how do you allow for both with a single function?  And how do you ask each different type of object to "do their annoying thing" in the same way?The key to realize is that both a Telemarketer and HouseFly share a common loosely interpreted behavior even though they are nothing alike in terms of modeling them.  So, let\'s make an interface that both can implement:We now have two classes that can each be annoying in their own way.  And they do not need to derive from the same base class and share common inherent characteristics -- they simply need to satisfy the contract of IPest -- that contract is simple.  You just have to BeAnnoying.  In this regard, we can model the following:Here we have a dining room that accepts a number of diners and a number of pests -- note the use of the interface.  This means that in our little world, a member of the pests array could actually be a Telemarketer object or a HouseFly object.The ServeDinner method is called when dinner is served and our people in the dining room are supposed to eat.  In our little game, that\'s when our pests do their work -- each pest is instructed to be annoying by way of the IPest interface.  In this way, we can easily have both Telemarketers and HouseFlys be annoying in each of their own ways -- we care only that we have something in the DiningRoom object that is a pest, we don\'t really care what it is and they could have nothing in common with other.  This very contrived pseudo-code example (that dragged on a lot longer than I anticipated) is simply meant to illustrate the kind of thing that finally turned the light on for me in terms of when we might use an interface.  I apologize in advance for the silliness of the example, but hope that it helps in your understanding.  And, to be sure, the other posted answers you\'ve received here really cover the gamut of the use of interfaces today in design patterns and development methodologies.  The specific example I used to give to students is that they should writeinstead ofThese look exactly the same in a short program, but if you go on to use myList 100 times in your program you can start to see a difference.  The first declaration ensures that you only call methods on myList that are defined by the List interface (so no ArrayList specific methods).  If you\'ve programmed to the interface this way, later on you can decide that you really needand you only have to change your code in that one spot.  You already know that the rest of your code doesn\'t do anything that will be broken by changing the implementation because you programmed to the interface.The benefits are even more obvious (I think) when you\'re talking about method parameters and return values.  Take this for example:That method declaration ties you to two concrete implementations (ArrayList and HashMap). As soon as that method is called from other code, any changes to those types probably mean you\'re going to have to change the calling code as well. It would be better to program to the interfaces.Now it doesn\'t matter what kind of List you return, or what kind of Map is passed in as a parameter. Changes that you make inside the doSomething method won\'t force you to change the calling code.Programming to an interface is saying, "I need this functionality and I don\'t care where it comes from."Consider (in Java), the List interface versus the ArrayList and LinkedList concrete classes. If all I care about is that I have a data structure containing multiple data items that I should access via iteration, I\'d pick a List (and that\'s 99% of the time). If I know that I need constant-time insert/delete from either end of the list, I might pick the LinkedList concrete implementation (or more likely, use the Queue interface). If I know I need random access by index, I\'d pick the ArrayList concrete class.You should look into Inversion of Control:In such a scenario, you wouldn\'t write this:You would write something like this:This would go into a rule-based setup in the container object, and construct the actual object for you, which could be ObjectWhatever. The important thing is that you could replace this rule with something that used another type of object altogether, and your code would still work.If we leave IoC off the table, you can write code that knows that it can talk to an object that does something specific, but not which type of object or how it does it.This would come in handy when passing parameters.As for your parenthesized question "Also, how could you write a method that takes in a object that implements a Interface? Is that possible?", in C# you would simply use the interface type for the parameter type, like this:this plugs right into the "talk to an object that does something specific". The method defined above knows what to expect from the object, that it implements everything in IInterface, but it doesn\'t care which type of object it is, only that it adheres to the contract, which is what an interface really is.For instance, you\'re probably familiar with calculators and have probably used quite a few in your days, but most of the time they\'re all different. You, on the other hand, knows how a standard calculator should work, so you\'re able to use them all, even if you can\'t use the specific features that each calculator has that none of the other has.This is the beauty of interfaces. You can write a piece of code, that knows that it will get objects passed to it that it can expect a certain behaviour from. It doesn\'t care one hoot what kind of object it is, only that it supports the behaviour needed.Let me give you a concrete example.We have a custom-built translation system for windows forms. This system loops through controls on a form, and translates text in each. The system knows how to handle basic controls, like the-type-of-control-that-has-a-Text-property, and similar basic stuff, but for anything basic, it falls short.Now, since controls inherit from pre-defined classes that we have no control over, we could do one of three things:So we did nr. 3. All our controls implement ILocalizable, which is an interface that gives us one method, the ability to translate "itself" through a container of translation text/rules. As such, the form doesn\'t need to know which kind of control it has found, only that it implements the specific interface, and knows that there is a method there it can call to localize the control.Using interfaces is a key factor in making your code easily testable in addition to removing unnecessary couplings between your classes.  By creating an interface that defines the operations on your class, you allow classes that want to use that functionality the ability to use it without depending on your implementing class directly.  If later on you decide to change and use a different implementation, you need only change the part of the code where the implementation is instantiated.  The rest of the code need not change because it depends on the interface, not the implementing class.This is very useful in creating unit tests.  In the class under test you have it depend on the interface and inject an instance of the interface into the class (or a factory that allows it to build instances of the interface as needed) via the constructor or a property settor.  The class uses the provided (or created) interface in its methods.  When you go to write your tests, you can mock or fake the interface and provide an interface that responds with data configured in your unit test.  You can do this because your class under test deals only with the interface, not your concrete implementation.  Any class implementing the interface, including your mock or fake class, will do.EDIT: Below is a link to an article where Erich Gamma discusses his quote, "Program to an interface, not an implementation."http://www.artima.com/lejava/articles/designprinciples.htmlProgramming to an interface has absolutely nothing to do with abstract interfaces like we see in Java or .NET. It isn\'t even an OOP concept.What it really means is don\'t go messing around with the internals of an object or data structure. Use the Abstract Program Interface, or API, to interact with your data. In Java or C# that means using public properties and methods instead of raw field access. For C that means using functions instead of raw pointers.EDIT: And with databases it means using views and stored procedures instead of direct table access.Code to the Interface Not the Implementation has NOTHING to do with Java nor its Interface construct. This concept was brought to prominence in the Patterns / Gang of Four book, but was most probably around well before that. The concept certainly existed well before Java ever existed. The Java Interface construct was originally created to aid in this idea (among other things), and people have become too focused on the construct as the centre of the meaning rather than the original intent. However it is the reason we have public and private methods and attributes in Java, C++, C#, etc.It means just interact with an object or system\'s public interface. Don\'t worry or even anticipate how it does what it does internally. Don\'t worry about how it is implemented. In object oriented code it is why we have public vs private methods/attributes. We are intended to use the public methods because the private methods are there only for use internally, within the class. They make up the implementation of the class and can be changed as required without changing the public interface. Assume that in terms of functionality, a method on a class will perform the same operation with the same expected result every time you call it with the same parameters. It allows the author to change how the class works, its implementation, without breaking how people interact with it.And you can program to the interface not the implementation without ever using an Interface construct. You can program to the interface not the implementation in C++, which does not have an Interface construct. You can integrate two massive enterprise systems much more robustly as long as they interact through public interfaces (contracts) rather than calling methods on objects internal to the systems. The interfaces are expected to always react the same expected way given the same input parameters; if implemented to the interface and not the implementation. The concept works in many places.Shake the thought that Java Interfaces have anything what-so-ever to do with the concept of \'Program to the Interface, Not the Implementation\'. They can help apply the concept, but they are not the concept. It sounds like you understand how interfaces work but are unsure of when to use them and what advantages they offer. Here are a few examples of when an interface would make sense:then I could create GoogleSearchProvider, YahooSearchProvider, LiveSearchProvider etc.then create JpegImageLoader, GifImageLoader, PngImageLoader, etc.Most add-ins and plugin sytems work off interfaces.Another popular use is for the Repository pattern. Say I want to load a list of zip codes from different sourcesthen I could create an XMLZipCodeRepository, SQLZipCodeRepository, CSVZipCodeRepository, etc. For my web applications I often create XML repositories early on so I can get something up and running prior to the Sql Database being ready. Once the database is ready I write an SQLRepository to replace the XML version. The rest of my code remains unchanged since it runs soley off of interfaces.Methods can accept interfaces such as:If you program in Java, JDBC is a good example.  JDBC defines a set of interfaces but says nothing about the implementation.  Your applications can be written against this set of interfaces.  In theory, you pick some JDBC driver and your application would just work.  If you discover there\'s a faster or "better" or cheaper JDBC driver or for whatever reason, you can again in theory re-configure your property file, and without having to make any change in your application, your application would still work.Programming to Interfaces is awesome, it promotes loose coupling. As @lassevk mentioned, Inversion of Control is a great use of this.In addition, look into SOLID principals. here is a video seriesIt goes through a hard coded (strongly coupled example) then looks at interfaces, finally progressing to a IoC/DI tool (NInject)It makes your code a lot more extensible and easier to maintain when you have sets of similar classes.  I am a junior programmer, so I am no expert, but I just finished a project that required something similar.I work on client side software that talks to a server running a medical device.  We are developing a new version of this device that has some new components that the customer must configure at times.  There are two types of new components, and they are different, but they are also very similar.  Basically, I had to create two config forms, two lists classes, two of everything.  I decided that it would be best to create an abstract base class for each control type that would hold almost all of the real logic, and then derived types to take care of the differences between the two components.  However, the base classes would not have been able to perform operations on these components if I had to worry about types all of the time (well, they could have, but there would have been an "if" statement or switch in every method).I defined a simple interface for these components and all of the base classes talk to this interface.  Now when I change something, it pretty much \'just works\' everywhere and I have no code duplication.In addition to the already selected answer (and the various informative posts here), I would highly recommend grabbing a copy of Head First Design Patterns.  It is a very easy read and will answer your question directly, explain why it is important, and show you many programming patterns you can use to make use of that principle (and others).A lot of explanation out there, but to make it even more simpler.\nTake for instance a List. One can implement a list with as: By building to an interface, say a List. You only code as to definition of List or what List means in reality.You could use any type of implementation internally say an array implementation. But suppose you wish to change the implementation for some reason say a bug or performance. Then you just have to change the declaration List<String> ls = new ArrayList<String>() to List<String> ls = new LinkedList<String>().No where else in code, will you have to change anything else; Because everything else was built on definition of List. I am a late comer to this question, but I want to mention here that the line "Program to an interface, not an implementation" had some good discussion in the GoF (Gang of Four) Design Patterns book.It stated, on p. 18:Program to an interface, not an implementationDon\'t declare variables to be instances of particular concrete classes. Instead, commit only to an interface defined by an abstract class. You will find this to be a common theme of the design patterns in this book.and above that, it began with:There are two benefits to manipulating objects solely in terms of the interface defined by abstract classes:So in other words, don\'t write it your classes so that it has a quack() method for ducks, and then a bark() method for dogs, because they are too specific for a particular implementation of a class (or subclass).  Instead, write the method using names that are general enough to be used in the base class, such as giveSound() or move(), so that they can be used for ducks, dogs, or even cars, and then the client of your classes can just say .giveSound() rather than thinking about whether to use quack() or bark() or even determine the type before issuing the correct message to be sent to the object.To add to the existing posts, sometimes coding to interfaces helps on large projects when developers work on separate components simultaneously. All you need is to define interfaces upfront and write code to them while other developers write code to the interface you are implementing.It is also good for Unit Testing, you can inject your own classes (that meet the requirements of the interface) into a class that depends on itSo, just to get this right, the advantage of a interface is that I can separate the calling of a method from any particular class. Instead creating a instance of the interface, where the implementation is given from whichever class I choose that implements that interface. Thus allowing me to have many classes, which have similar but slightly different functionality and in some cases (the cases related to the intention of the interface) not care which object it is.For example, I could have a movement interface. A method which makes something \'move\' and any object (Person, Car, Cat) that implements the movement interface could be passed in and told to move. Without the method every knowing the type of class it is. Imagine you have a product called \'Zebra\' that can be extended by plugins. It finds the plugins by searching for DLLs in some directory. It loads all those DLLs and uses reflection to find any classes that implement IZebraPlugin, and then calls the methods of that interface to communicate with the plugins. This makes it completely independent of any specific plugin class - it doesn\'t care what the classes are. It only cares that they fulfill the interface specification. Interfaces are a way of defining points of extensibility like this. Code that talks to an interface is more loosely coupled - in fact it is not coupled at all to any other specific code. It can inter-operate with plugins written years later by people who have never met the original developer.You could instead use a base class with virtual functions - all plugins would be derived from the base class. But this is much more limiting because a class can only have one base class, whereas it can implement any number of interfaces.C++ explanation.Think of an interface as your classes public methods.You then could create a template that \'depends\' on these public methods in order to carry out it\'s own function (it makes function calls defined in the classes public interface). Lets say this template is a container, like a Vector class, and the interface it depends on is a search algorithm.Any algorithm class that defines the functions/interface Vector makes calls to will satisfy the \'contract\' (as someone explained in the original reply). The algorithms don\'t even need to be of the same base class; the only requirement is that the functions/methods that the Vector depends on (interface) is defined in your algorithm.The point of all of this is that you could supply any different search algorithm/class just as long as it supplied the interface that Vector depends on (bubble search, sequential search, quick search).You might also want to design other containers (lists, queues) that would harness the same search algorithm as Vector by having them fulfill the interface/contract that your search algorithms depends on.This saves time (OOP principle \'code reuse\') as you are able to write an algorithm once instead of again and again and again specific to every new object you create without over-complicating the issue with an overgrown inheritance tree.As for \'missing out\' on how things operate; big-time (at least in C++), as this is how most of the Standard TEMPLATE Library\'s framework operates.Of course when using inheritance and abstract classes the methodology of programming to an interface changes; but the principle is the same, your public functions/methods are your classes interface.This is a huge topic and one of the the cornerstone principles of Design Patterns.In Java these concrete classes all implement the CharSequence interface:CharBuffer, String, StringBuffer,\n  StringBuilderThese concrete classes do not have a common parent class other than Object, so there is nothing that relates them, other than the fact they each have something to do with arrays of characters, representing such, or manipulating such. For instance, the characters of String cannot be changed once a String object is instantiated, whereas the characters of StringBuffer or StringBuilder can be edited.Yet each one of these classes is capable of suitably implementing the CharSequence interface methods:In some cases Java class library classes that used to accept String have been revised to now accept the CharSequence interface. So if you have an instance of StringBuilder, instead of extracting a String object (which means instantiating a new object instance), can instead just pass the StringBuilder itself as it implements the CharSequence interface.The Appendable interface that some classes implement has much the same kind of benefit for any situation where characters can be appended to an instance of the underlying concrete class object instance. All of these concrete classes implement the Appendable interface:BufferedWriter, CharArrayWriter,\n  CharBuffer, FileWriter, FilterWriter,\n  LogStream, OutputStreamWriter,\n  PipedWriter, PrintStream, PrintWriter,\n  StringBuffer, StringBuilder,\n  StringWriter, WriterIn simple terms...\nIf I\'m writing a new class Swimmer to add the functionality swim() and need to use an object of class say Dog, and this Dog class implements interface Animal which declares swim()[To better understand...you may draw a diagram as to what I am talking about]. At the top of the hierarchy(Animal) it\'s very abstract while at the bottom (Dog) it\'s very concrete. The way I think about "programming to interfaces" is that, as I write Swimmer class, I want to write my code against the interface that\'s as far up that hierarchy which in this case is Animal object. An interface is free from implementation details and thus makes your code loosely-coupled. The implementation details can be changed with time, however it would not affect the remaining code since all you are interacting is with the interface and not the implementation. You don\'t care what the implementation is like...all you know is that there will be a class that would implement the interface.short story:Postman is asked to go home by home and receive the covers contains (letters,documents,cheques,giftcard,application,loveletter) with address written on it to deliver.Suppose there is no cover and ask post man to go home by home and receive all the things and deliver to other person the postman can get confuse,so better \nwrap it with cover(in our story it is interface) then he will do his job fine.Now postman job is to receive and deliver the covers only..(he dont bothered what is inside in the cover).Create type of interface not actual type, but implement with actual type.Create to interface means your components get Fits into the rest of code easilyI give you example.you have AirPlane interface as below.Suppose you have methods in your Controller class of Planes likeandimplemented in your program. It will not BREAK your code.\nI mean, it need not to change as long as it accepts arguments as AirPlane.Because it will accept any Airplane despite of actual type, flyer, highflyr, fighter, etc.Also, in a collection:List<Airplane> plane; // Will take all your planes.The following example will clear your understanding.You have a fighter plane that implements it, soThe same thing for HighFlyer and other clasess:Now think your controller classes using AirPlane several times,Suppose your Controller class is ControlPlane like below,here magic comes as you may make your new AirPlane type instances as many as you want and you are not changing code of ControlPlane class.you can add instance..you may remove instances.. of previously created types too.Q: - ... "You could use any class that implements interface?"\n  A: - Yes.Q: -... "When would you need to do that?"\n  A: - Each time you need a class(es) that implements interface(s).Note: we couldn\'t instantiate an interface not implemented by a class - True. AnIntf anInst = new Aclass();\n  // we could do this only if Aclass implements AnIntf.\n  // anInst will have Aclass reference.Note:\nNow we could understand what happend if Bclass and Cclass implements same Dintf.What we have:\nsame interface prototypes (functions names in interface), and call different implementations.Bibliography:\nPrototypes - wikipediaInterface is like contract where you want your implementation class to implement methods written in contract(Interface).Since java does not provide multiple inheritance,programming to interface is a good way to achieve purpose of multiple inheritance.If you have a class A that is already extending some other class B but you want that class A should also follow certain guidelines or implement certain contract then you can do so by programming to interface strategy.It can be advantageous to program to interfaces, even when we are not depending on abstractions.Programming to interfaces forces us to use a contextually appropriate subset of an object. That helps because it: For example, consider a Person class that implements the Friend and the Employee interface.In the context of the person\'s birthday, we program to the Friend interface, to prevent treating the person like an Employee.In the context of the person\'s work, we program to the Employee interface, to prevent blurring workplace boundaries.Great. We have behaved appropriately in different contexts, and our software is working well.Far into the future, if our business changes to work with dogs, we can change the software fairly easily. First, we create Dog class that implements both Friend and Employee. Then, we safely change new Person() to new Dog(). Even if both functions have thousands of lines of code, that simple edit will work because we know the following are true:On the other hand, if either party or workplace were to have programmed against Person, there would be a risk of both having Person-specific code. Changing from Person to Dog would require us to comb through the code to extirpate any Person-specific code that Dog does not support.The moral: programming to interfaces helps our code to behave appropriately and to be ready for change. It also prepares our code to depend on abstractions, which brings even more advantages. Also I see a lot of good and explanatory answers here, so I want to give my point of view here, including some extra information what I noticed when using this method.Unit testingFor the last two years, I have written a hobby project and I did not write unit tests for it. After writing about 50K lines I found out it would be really necessary to write unit tests.\nI did not use interfaces (or very sparingly) ... and when I made my first unit test, I found out it was complicated. Why?Because I had to make a lot of class instances, used for input as class variables and/or parameters. So the tests look more like integration tests (having to make a complete \'framework\' of classes since all was tied together).Fear of interfaces\nSo I decided to use interfaces. My fear was that I had to implement all functionality everywhere (in all used classes) multiple times. In some way this is true, however, by using inheritance it can be reduced a lot.Combination of interfaces and inheritance\nI found out the combination is very good to be used. I give a very simple example.This way copying code is not necessary, while still having the benefit of using a car as interface (ICar).Let\'s start out with some definitions first:Interface n. The set of all signatures defined by an object\'s operations is called the interface to the objectType n. A particular interfaceA simple example of an interface as defined above would be all the PDO object methods such as query(), commit(), close() etc., as a whole, not separately. These methods, i.e. its interface define the complete set of messages, requests that can be sent to the object.A type as defined above is a particular interface. I will use the made-up shape interface to demonstrate: draw(), getArea(), getPerimeter() etc..If an object is of the Database type we mean that it accepts messages/requests of the database interface, query(), commit() etc.. Objects can be of many types. You can have a database object be of the shape type as long as it implements its interface, in which case this would be sub-typing.Many objects can be of many different interfaces/types and implement that interface differently. This allows us to substitute objects, letting us choose which one to use. Also known as polymorphism.The client will only be aware of the interface and not the implementation. So in essence programming to an interface would involve making some type of abstract class such as Shape with the interface only specified i.e. draw(), getCoordinates(), getArea() etc.. And then have different concrete classes implement those interfaces such as a Circle class, Square class, Triangle class. Hence program to an interface not an implementation.Program to an interface allows to change implementation of contract defined by interface seamlessly. It allows loose coupling between contract and specific implementations. IInterface classRef = new ObjectWhatever()You could use any class that implements IInterface? When would you need to do that?Have a look at this SE question for good example. Why should the interface for a Java class be preferred?does using an Interface hit performance?if so how much?Yes. It will have slight performance overhead in sub-seconds. But if your application has requirement to change the implementation of interface dynamically, don\'t worry about performance impact. how can you avoid it without having to maintain two bits of code?Don\'t try to avoid multiple implementations of interface if your application need them. In absence of tight coupling of interface with one specific implementation,  you may have to deploy the patch to change one implementation to other implementation. One good use case: Implementation of Strategy pattern:Strategy pattern example in java with Context classHere is a simple example to illustrate when you program a flight booking system.