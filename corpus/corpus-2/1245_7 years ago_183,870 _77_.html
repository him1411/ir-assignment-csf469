I\'ve always been told never to represent money with double or float types, and this time I pose the question to you: why? I\'m sure there is a very good reason, I simply do not know what it is.Because floats and doubles cannot accurately represent the base 10 multiples we use for money. This issue isn\'t just for Java, it\'s for any programming language that uses native floating-point types, as it stems from how computers handle floating-point numbers by default.This is how an IEEE-754 floating-point number works: it dedicates a bit for the sign, a few bits to store an exponent for the base, and the rest for a multiple of that elevated base. This leads to numbers like 10.25 being represented in a form similar to 1025 * 10-2; except that instead of the base being 10, for floats and doubles, it\'s two, so that would be 164 * 2-4. (That\'s still not exactly how they are represented in hardware, but this is simple enough and the math holds the same way.)Even in base 10, this notation cannot accurately represent most simple fractions. For instance, with most calculators, 1/3 results in a repeating 0.333333333333, with as many 3\'s as the digital display allows, because you just can\'t write 1/3 in decimal notation. However, for the purpose of money (at least for countries whose money value is within an order of magnitude of the US dollar), in most scenarios all you need is to be able to store multiples of 10-2, so we don\'t really care if 1/3 doesn\'t have an exact representation as an integer times a power of 10, and even the cheapest calculators handle cents just fine.The problem with floats and doubles is that the vast majority of money-like numbers don\'t have an exact representation as a integer times a power of two. In fact, the only fractions of a hundred between 0/100 and 100/100 (which are significant when dealing with money because they\'re integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount.Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you\'ll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the BigDecimal class, and C# has the decimal type.From Bloch, J., Effective Java, 2nd ed, Item 48:The float and double types are\n  particularly ill-suited for monetary\n  calculations because it is impossible\n  to represent 0.1 (or any other\n  negative power of ten) as a float or\n  double exactly.For example, suppose you have $1.03\n  and you spend 42c. How much money do\n  you have left?prints out 0.6100000000000001.The right way to solve this problem is\n  to use BigDecimal, int or long\n  for monetary calculations.This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are "wrong" in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.I\'m troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,results inFloats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:this probably isn\'t how you want to represent $1.01.The problem is that the IEEE spec doesn\'t have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can\'t close their account, it\'s better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.It\'s not that the error isn\'t controllable if you round: see this article by Peter Lawrey. It\'s just easier not to have to round in the first place. Most applications that handle money don\'t call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesn\xe2\x80\x99t produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.Output:While it\'s true that floating point type can represent only approximatively decimal data, it\'s also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.Usually because the double type has a precision less than 16 figures. If you require better precision it\'s not a suitable type. Also approximations can accumulate.It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.As said earlier "Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you\xe2\x80\x99ll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required."Finally Java has a standard way to work with Currency And Money!JSR 354: Money and Currency APIJSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link: JSR 354: Money and Currency API DownloadThe specification consists of the following things:Sample Examples of JSR 354: Money and Currency API:An example of creating a MonetaryAmount and printing it to the console looks like this::When using the reference implementation API, the necessary code is much simpler:The API also supports calculations with MonetaryAmounts:CurrencyUnit and MonetaryAmountMonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:MonetaryAmounts can be rounded using a rounding operator:When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.Custom MonetaryAmount operationsResources: Handling money and currencies in Java with JSR 354Looking into the Java 9 Money and Currency API (JSR 354)See Also: JSR 354 - Currency and MoneyI\'ll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn\'t want to touch floating point numbers with a ten foot pole.If your computation involves various steps, arbitrary precision arithmetic won\'t cover you 100%.The only reliable way to use perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to a decimal notation in last step.Arbitrary precision won\'t help because there always can be numbers that has so much decimal places, or some results such as 0.6666666... No arbitrary representation will cover the last example. So you will have small errors in each step.This errors will add-up, may eventually become not easy to ignore anymore. This is called Error Propagation.Some example... this works (actually don\'t work as expected), on almost any programming language... I\'ve tried with Delphi, VBScript, Visual Basic, JavaScript and now with Java/Android:OUTPUT:round\xc2\xa0problems?: current total: 0.9999999999999999\n round\xc2\xa0problems?: current total: 2.7755575615628914E-17\n round\xc2\xa0problems?: is total equal to ZERO? NO... thats why you should not use Double for some math!!!I prefer using Integer or Long to represent currency.  BigDecimal junks up the source code too much.You just have to know that all your values are in cents.  Or the lowest value of whatever currency you\'re using.Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn\'t use a double or float in a mathematical calculation is that I would lose too much information.What are the alternatives? There are many (and many more of which I am not aware!).BigDecimal in Java is native to the Java language.\nApfloat is another arbitrary-precision library for Java.The decimal data type in C# is Microsoft\'s .NET alternative for 28 significant figures.SciPy (Scientific Python) can probably also handle financial calculations (I haven\'t tried, but I suspect so).The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.I\'m not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven\'t tried the other solutions I\'ve listed, but they are probably very good as well.For me, I like BigDecimal because of the methods it supports. C#\'s decimal is very nice, but I haven\'t had the chance to work with it as much as I\'d like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you\'re using the divide method.You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.