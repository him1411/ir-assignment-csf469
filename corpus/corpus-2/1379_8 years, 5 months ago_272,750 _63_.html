As far as I can tell, these two pieces of javascript behave the same way:Option A:Option B:Is there any difference between using setTimeout and setInterval?They essentially try to do the same thing, but the setInterval approach will be more accurate than the setTimeout approach, since setTimeout waits 1000ms, runs the function and then sets another timeout. So the wait period is actually a bit more than 1000ms (or a lot more if your function takes a long time to execute).Altough one might think that setInterval will execute exactly every 1000ms, it is important to note that setInterval will also delay, since JavaScript isn\'t a multi-threaded language, which means that - if there are other parts of the script running - the interval will have to wait for that to finish.In this Fiddle, you can clearly see that the timeout will fall behind, while the interval is almost all the time at almost 1 call/second (which the script is trying to do). If you change the speed variable at the top to something small like 20 (meaning it will try to run 50 times per second), the interval will never quite reach an average of 50 iterations per second.The delay is almost always negligible, but if you\'re programming something really precise, you should go for a self-adjusting timer (which essentially is a timeout-based timer that constantly adjusts itself for the delay it\'s created) Is there any difference?Yes. A Timeout executes a certain amount of time after setTimeout() is called; an Interval executes a certain amount of time after the previous interval fired.You will notice the difference if your doStuff() function takes a while to execute. For example, if we represent a call to setTimeout/setInterval with ., a firing of the timeout/interval with * and JavaScript code execution with [-----], the timelines look like:The next complication is if an interval fires whilst JavaScript is already busy doing something (such as handling a previous interval). In this case, the interval is remembered, and happens as soon as the previous handler finishes and returns control to the browser. So for example for a doStuff() process that is sometimes short ([-]) and sometimes long ([-----]):\xe2\x80\xa2 represents an interval firing that couldn\'t execute its code straight away, and was made pending instead.So intervals try to \xe2\x80\x98catch up\xe2\x80\x99 to get back on schedule. But, they don\'t queue one on top of each other: there can only ever be one execution pending per interval. (If they all queued up, the browser would be left with an ever-expanding list of outstanding executions!)x represents an interval firing that couldn\'t execute or be made pending, so instead was discarded.If your doStuff() function habitually takes longer to execute than the interval that is set for it, the browser will eat 100% CPU trying to service it, and may become less responsive.Which do you use and why?Chained-Timeout gives a guaranteed slot of free time to the browser; Interval tries to ensure the function it is running executes as close as possible to its scheduled times, at the expense of browser UI availability.I would consider an interval for one-off animations I wanted to be as smooth as possible, whilst chained timeouts are more polite for ongoing animations that would take place all the time whilst the page is loaded. For less demanding uses (such as a trivial updater firing every 30 seconds or something), you can safely use either.In terms of browser compatibility, setTimeout predates setInterval, but all browsers you will meet today support both. The last straggler for many years was IE Mobile in WinMo <6.5, but hopefully that too is now behind us.setInterval() is a time interval based code execution method that has the native ability to repeatedly run a specified script when the interval is reached. It should not be nested into its callback function by the script author to make it loop, since it loops by default. It will keep firing at the interval unless you call clearInterval().If you want to loop code for animations or on a clock tick, then use setInterval().setTimeout() is a time based code execution method that will execute a script only one time when the interval is reached. It will not repeat again unless you gear it to loop the script by nesting the setTimeout() object inside of the function it calls to run. If geared to loop, it will keep firing at the interval unless you call clearTimeout().If you want something to happen one time after a specified period of time, then use setTimeout(). That is because it only executes one time when the specified interval is reached.The setInterval makes it easier to cancel future execution of your code. If you use setTimeout, you must keep track of the timer id in case you wish to cancel it later on.versusI find the setTimeout method easier to use if you want to cancel the timeout:Also, if something would go wrong in the function it will just stop repeating at the first time error, instead of repeating the error every second.The very difference is in their purposes.It\'s as simple as thatMore elaborate details here http://javascript.info/tutorial/settimeout-setintervalWhen you run some function inside setInterval, which works more time than timeout-> the browser will be stuck.\n\n - E.g., doStuff() takes 1500 sec. to be execute and you do: setInterval(doStuff, 1000);\n1) Browser run doStuff() which takes 1.5 sec. to be executed;\n2) After ~1 second it tries to run doStuff() again. But previous doStuff() is still executed-> so browser adds this run to the queue (to run after first is done).\n3,4,..) The same adding to the queue of execution for next iterations, but doStuff() from previous are still in progress...\n As the result- the browser is stuck.\n\nTo prevent this behavior, the best way is to run setTimeout inside setTimeout to emulate setInterval.\nTo correct timeouts between setTimeout calls, you can use self-correcting alternative to JavaScript\'s setInterval technique.I use setTimeout.Apparently the difference is setTimeout calls the method once, setInterval calls it repeatdly.Here is a good article explaining the difference: Tutorial: JavaScript timers with setTimeout and setIntervalI\'ve made simple test of setInterval(func, milisec), because I was curious what happens when function time consumption is greater than interval duration. setInterval will generally schedule next iteration just after the start of the previous iteration, unless the function is still ongoing. If so, setInterval will wait, till the function ends. As soon as it happens, the function is immediately fired again - there is no waiting for next iteration according to schedule (as it would be under conditions without time exceeded function). There is also no situation with parallel iterations running. I\'ve tested this on Chrome v23. I hope it is deterministic implementation across all modern browsers.Console output:The wait function is just a thread blocking helper - synchronous ajax call which takes exactly 2500 milliseconds of processing at the server side:This article says that you should avoid setInterval if possible, especially since you can replicate its behavior with setTimeout and get some additional benefits along the way.Both setInterval and setTimeout return a timer id that you can use to cancel the execution, that is, before the timeouts are triggered. To cancel you call either clearInterval or clearTimeout like this:Also, the timeouts are automatically cancelled when you leave the page or close the browser window.Well, setTimeout is better in one situation, as I have just learned. I always use setInterval, which i have left to run in the background for more than half an hour. When i switched back to that tab, the slideshow (on which the code was used) was changing very rapidly, instead of every 5 seconds that it should have. It does in fact happen again as i test it more and whether it\'s the browser\'s fault or not isn\'t important, because with setTimeout that situation is completely impossible. The difference is obvious in console:Just adding onto what has already been said but the setTimeout version of the code will also reach the Maximum call stack size which will stop it from functioning. Since there is no base case for the recursive function to stop at so you can\'t have it run forever.You can validate bobince answer by yourself when you run the following javascript or check this JSFiddleYour code will have different execution intevals, and in some projects, such as online games it\'s not acceptable. First, what should you do, to make your code work with same intevals, you should change "myTimeoutFunction" to this:After this change, it will be equal to But, you will still have not stable result, because JS is single-threaded. For now, if JS thread will be busy with something, it will not be able to execute your callback function, and execution will be postponed for 2-3 msec. Is you have 60 executions per second, and each time you have random 1-3 sec delay, it will be absolutely not acceptable (after one minute it will be around 7200 msec delay), and I can advice to use something like this:This code will guarantee stable execution period. Even thread will be busy, and your code will be executed after 1005 mseconds, next time it will have timeout for 995 msec, and result will be stable.To look at it a bit differently: setInterval insures that a code is run at every given interval (i.e. 1000ms, or how much you specify) while setTimeout sets the time that it \'waits until\' it runs the code. And since it takes extra milliseconds to run the code, it adds up to 1000ms and thus, setTimeout runs again at inexact times (over 1000ms).For example, timers/countdowns are not done with setTimeout, they are done with setInterval, to ensure it does not delay and the code runs at the exact given interval.It would probably better to replace the first function by this Options A\'Isn\'t it ? I think the setTimeout version may actually leak memory. You call a function recursively which does not return. So there is a push for a return address on each call, but there is no pop.\nAdditionally, there are scope allocations for each variables defined inside tick function which don\'t get a chance to get freed because the scope is never exited.So for scheduling purposes, I suggest you to use the setInterval approach while the setTimeout approach is better for delayed execution and asynchronous work.I think SetInterval and SetTimeout are different. SetInterval executes the block according to the time set while, SetTimeout executes the block of code once.Try these set of codes after the timeout countdown seconds:and then tryYou can see the differences for yourself.