How can I load a Python module given its full path? Note that the file can be anywhere in the filesystem, as it is a configuration option.For Python 3.5+ use:For Python 3.3 and 3.4 use:(Although this has been deprecated in Python 3.4.)Python 2 use:There are equivalent convenience functions for compiled Python files and DLLs.See also. http://bugs.python.org/issue21436.The advantage of adding a path to sys.path (over using imp) is that it simplifies things when importing more than one module from a single package.  For example:You can use the method from imp module.You can also do something like this and add the directory that the configuration file is sitting in to the Python load path, and then just do a normal import, assuming you know the name of the file in advance, in this case "config".Messy, but it works.Do you mean load or import?You can manipulate the sys.path list specify the path to your module, then import your module. For example, given a module at:You could do:I believe you can use imp.find_module() and imp.load_module() to load the specified module.  You\'ll need to split the module name off of the path, i.e. if you wanted to load /home/mypath/mymodule.py you\'d need to do:...but that should get the job done.It sounds like you don\'t want to specifically import the configuration file (which has a whole lot of side effects and additional complications involved), you just want to run it, and be able to access the resulting namespace. The standard library provides an API specifically for that in the form of runpy.run_path:That interface is available in Python 2.7 and Python 3.2+This should workI\'m not saying that it is better, but for the sake of completeness, I wanted to suggest the exec function, available in both python 2 and 3.\nexec allows you to execute arbitrary code in either the global scope, or in an internal scope, provided as a dictionary.For example, if you have a module stored in "/path/to/module" with the function foo(), you could run it by doing the following:This makes it a bit more explicit that you\'re loading code dynamically, and grants you some additional power, such as the ability to provide custom builtins. And if having access through attributes, instead of keys is important to you, you can design a custom dict class for the globals, that provides such access, e.g.:Here is some code that works in all Python versions, from 2.7-3.5 and probably even others.I tested it. It may be ugly but so far is the only one that works in all versions.Import package modules at runtime (Python recipe) http://code.activestate.com/recipes/223972/You can use the pkgutil module (specifically the walk_packages method) to get a list of the packages in the current directory. From there it\'s trivial to use the importlib machinery to import the modules you want:This area of Python 3.4 seems to be extremely tortuous to understand! However with a bit of hacking using the code from Chris Calloway as a start I managed to get something working. Here\'s the basic function.This appears to use non-deprecated modules from Python 3.4. I don\'t pretend to understand why, but it seems to work from within a program. I found Chris\' solution worked on the command line but not from inside a program.To import a module from a given filename, you can temporarily extend the path, and restore the system path in the finally block reference:I made a package that uses imp for you. I call it import_file and this is how it\'s used:You can get it at:http://pypi.python.org/pypi/import_fileor athttp://code.google.com/p/import-file/In Linux, adding a symbolic link in the directory your python script is located works.ie: ln -s /absolute/path/to/module/module.py /absolute/path/to/script/module.pypython will create /absolute/path/to/script/module.pyc and will update it if you change the contents of /absolute/path/to/module/module.pythen include the following in mypythonscript.pyfrom module import *I have come up with a slightly modified version of @SebastianRittau\'s wonderful answer (for Python > 3.4 I think), which will allow you to load a file with any extension as a module using spec_from_loader instead of spec_from_file_location:The advantage of encoding the path in an explicit SourceFileLoader is that the machinery will not try to figure out the type of the file from the extension. This means that you can load something like a .txt file using this method, but you could not do it with spec_from_file_location without specifying the loader because .txt is not in importlib.machinery.SOURCE_SUFFIXES.The best way, I think, is from the official documentation (29.1. imp \xe2\x80\x94 Access the import internals):It may be obvious but in interactive shell: