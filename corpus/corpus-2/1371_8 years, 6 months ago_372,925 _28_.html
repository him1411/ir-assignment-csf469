I can\'t get to the bottom of this error, because when the debugger is attached, it does not seem to occur. Below is the code.This is a WCF server in a Windows service. The method NotifySubscribers is called by the service whenever there is a data event (at random intervals, but not very often - about 800 times per day).When a Windows Forms client subscribes, the subscriber ID is added to the subscribers dictionary, and when the client unsubscribes, it is deleted from the dictionary. The error happens when (or after) a client unsubscribes. It appears that the next time the NotifySubscribers() method is called, the foreach() loop fails with the error in the subject line. The method writes the error into the application log as shown in the code below. When a debugger is attached and a client unsubscribes, the code executes fine.Do you see a problem with this code? Do I need to make the dictionary thread-safe?What\'s likely happening is that SignalData is indirectly changing the subscribers dictionary under the hood during the loop and leading to that message.  You can verify this by changing To If I\'m right, the problem will dissapearWhen a subscriber unsubscribes you are changing contents of the collection of Subscribers during enumeration.There are several ways to fix this, one being changing the for loop to:A more efficient way, in my opinion, is to have another list that you declare that you put anything that is "to be removed" into.  Then after you finish your main loop (without the .ToList()), you do another loop over the "to be removed" list, removing each entry as it happens.  So in your class you add:Then you change it to:This will not only solve your problem, it will prevent you from having to keep creating a list from your dictionary, which is expensive if there are a lot of subscribers in there.  Assuming the list of subscribers to be removed on any given iteration is lower than the total number in the list, this should be faster.  But of course feel free to profile it to be sure that\'s the case if there\'s any doubt in your specific usage situation.You can also lock your subscribers dictionary to prevent it from being modified whenever its being looped:Note: In general .Net collections do not support being enumerated and modified at the same time. If you try to modifies the collection list while you are in the middle of enumerating it it will raise an exception.So the issue behind this error is, we can not modify the list/dictionary while we are looping through. But if we iterate a dictionary using a temp list of its keys, in parallel we can modify the dictionary object, because now we are not iterating the dictionary(and iterating its key collection).sample: Here is a blog post about this solution.And for a deep dive in stackoverflow: Why this error occurs?Actually the problem seems to me that you are removing elements from the list and expecting to continue to read the list as if nothing had happened.What you really need to do is to start from the end and back to the begining. Even if you remove elements from the list you will be able to continue reading it.I\'ve seen many options for this but to me this one was the best.Then simply loop through the collection.  I had the same issue, and it was solved when I used a "for" loop instead of foreachInvalidOperationException- \nAn InvalidOperationException has occurred. It reports a "collection was modified" in a foreach-loopUse break statement, Once the object is removed.ex: You can copy subscribers dictionary object to a same type of temporary dictionary object and then iterate the temporary dictionary object using foreach loop. So a different way to solve this problem would be instead of removing the elements create a new dictionary and only add the elements you didnt want to remove then replace the original dictionary with the new one. I don\'t think this is too much of an efficiency problem because it does not increase the number of times you iterate over the structure.