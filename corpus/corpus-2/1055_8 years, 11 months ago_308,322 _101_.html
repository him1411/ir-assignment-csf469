This question already has an answer here:I\'ve always handled optional parameters in Javascript like this:Is there a better way to do it?Are there any cases where using || like that is going to fail?Your logic fails if optionalArg is passed, but evaluates as false - try this as an alternativeOr an alternative idiom:Use whichever idiom communicates the intent best to you!I find this to be the simplest, most readable way:Paul Dixon\'s answer (in my humble opinion) is less readable than this, but it comes down to preference.insin\'s answer is much more advanced, but much more useful for big functions!EDIT 11/17/2013 9:33pm: I\'ve created a package for Node.js that makes it easier to "overload" functions (methods) called parametric.In ECMAScript 2015 (aka "ES6") you can declare default argument values in the function declaration:More about them in this article on MDN (despite the article title, they\'re called "arguments," not "parameters," in JavaScript).This is currently only supported by Firefox, but as the standard has been completed, expect support to improve rapidly.If you need to chuck a literal NULL in, then you could have some issues. Apart from that, no, I think you\'re probably on the right track.The other method some people choose is taking an assoc array of variables iterating through the argument list. It looks a bit neater but I imagine it\'s a little (very little) bit more process/memory intensive.Ideally, you would refactor to pass an object and merge it with a default object, so the order in which arguments are passed doesn\'t matter (see the second section of this answer, below).If, however, you just want something quick, reliable, easy to use and not bulky, try this:Here\'s an example for providing defaults for three optional arguments (with two required  arguments)Simple demo. This is similar to roenving\'s answer, but easily extendible for any number of default arguments, easier to update, and using arguments not Function.arguments.The above code, like many ways of doing default arguments, can\'t pass arguments out of sequence, e.g., passing optionalC but leaving optionalB to fall back to its default. A good option for that is to pass objects and merge with a default object. This is also good for maintainability (just take care to keep your code readable, so future collaborators won\'t be left guessing about the possible contents of the objects you pass around).Example using jQuery. If you don\'t use jQuery, you could instead use Underscore\'s _.defaults(object, defaults) or browse these options:Here\'s a simple example of it in action.You can use some different schemes for that, I\'ve always tested for arguments.length:-- doing so, it can\'t possibly fail, but I don\'t know if your way has any chance of failing, just now I can\'t think up a scenario, where it actually would fail ...Edit:\nAnd then Paul provided one failing scenario !-)Similar to Oli\'s answer, I use an argument Object and an Object which defines the default values. With a little bit of sugar......this can be made a bit nicer.What\'s nice about this method?If you\'re using defaults extensively, this seems much more readable:Just declare this function on the global escope.Usage pattern fruit = defaultValue(fruit,\'Apple\');*PS you can rename the defaultValue function to a short name, just don\'t use default it\'s a reserved word in javascript.Loose type checkingEasy to write, but 0, \'\', false, null and undefined will be converted to default value, which might not be expected outcome.Strict type checkingLonger, but covers majority of cases. Only case where it incorrectly assigns default value is when we pass undefined as parameter.Checking arguments variableCatches all cases but is the most clumsy to write.ES6Unfortunately this has very poor browser support at the momentIf you\'re using the Underscore library (you should, it\'s an awesome library):With ES2015/ES6 you can take advantage of Object.assign which can replace $.extend() or _.defaults()You can also use defaults arguments like thisI am used to seeing a few basic variations on handling optional variables. Sometimes, the relaxed versions are useful.The falsy default used with variable a is, for example, used extensively in backbone.js.Landed to this question, searching for default parameters in EcmaScript 2015, thus just mentioning...With ES6 we can do default parameters:Don\'t know why @Paul\'s reply is downvoted but the validaition against null is a good choice. May be more affirmative example will make sense better:In JS a missed parameter is like a declared variable that is not initialized (just var a1;).\nAnd the equality operator converts the undefined to null so this works great with both value \ntypes and objects and this is how CoffeeScript handles optional parameters. Though, there are concerns that for the best semantics is typeof variable === \'undefined\' is slightly better. I\'m not about to defense this since it\'s the matter of underlying API how a function is implemented, it should not interest the API user.Should also add that here\'s the only way to physically make sure any argument were missed, using the in operator which unfortunately won\'t work with the parameter names so have to pass an index of the arguments.The test for undefined is unnecessary and isn\'t as robust as it could be because as user568458 pointed out the solution provided fails if null or false is passed. Users of your API might thing false or null would force the method to avoid that param.The result is:Those last two are potentially bad. Instead try:Which results in:The only scenario where this isn\'t optimal is when you actually have optional params that are meant to be booleans or intentional null.This is what I ended up with:Called like this:Folks -After looking at these and other solutions, I tried a number of them out using a snippet of code originally from W3Schools as a base.  You can find what works in the following.  Each of the items commented out work as well and are that way to allow you to experiment simply by removing individual comments.  To be clear, it is the "eyecolor" parameter that is not being defined.http://jsfiddle.net/mq60hqrf/I tried some options mentioned in here and performance tested them. \nAt this moment the logicalor seems to be the fastest. Although this is subject of change over time(different javascript engine versions)This are my results (Microsoft Edge 20.10240.16384.0)This performance test can be easily replicated on: \nhttp://jsperf.com/optional-parameters-typeof-vs-switch/2This is the code of the test:During a project I noticed I was repeating myself too much with the optional parameters and settings, so I made a class that handles the type checking and assigns a default value which results in neat and readable code. See example and let me know if this works for you.Using this class:Here is my solution. With this  you can leave any parameter you want. The order of the optional parameters is not important and you can add custom validation.arg || \'default\' is a great way and works for 90% of casesIt fails when you need to pass values that might be \'falsy\'For these cases you will need to be a bit more verbose and check for undefinedAlso be careful when you have optional arguments first, you have to be aware of the types of all of your argumentsCorrect me if I\'m wrong, but this seems like the simplest way (for one argument, anyway):Those ones are shorter than the typeof operator version.In all cases where optionalArg is falsy you will end up with defaultValue.All of the above log defaultValue ,because all of 6 are falsy.\nIn case 4, 5, 6 you might not be interested to set optionalArg as defaultValue but it sets since they are falsyI suggest you to use ArgueJS this way:You can also replace undefined by the type of the argument you expect to receive, like this:It seems that the safest way - to deal with all \\ any falsy types of supplied arguments before deciding to use the default - is to check for the existence\\presence of the optional argument in the invoked function. Relying on the arguments object member creation which doesn\'t even get created if the argument is missing, regardless of the fact that it might be declared, we can write your function like this:Utilizing this behavior: \nWe can safely check for any missing values on arguments list arbitrarily and explicitly whenever we need to make sure the function gets a certain value required in its procedure. In the following demo code we will deliberately put a typeless and valueless undefined as a default value to be able to determine whether it might fail on falsy argument values, such as 0 false etc., or if it behaves as expected.Now, checking few falsy argument-values to see if their presence is correctly detected and therefore evaluates to true:Which means -they didn\'t fail the recognition of/as expected argument values.\nHere we have a check with all arguments missing, which according to our algo should acquire their default values even if they\'re falsy.As we can see, the arguments arg1, arg2, arg3 and the undeclared arg4, are returning their exact default values, as ordered. \nBecause we\'ve now made sure that it works, we can rewrite the function which will actually be able to use them as in the first example by using: either if or a ternary condition.On functions that have more than one optional argument, - a loop through, might have saved us some bits. But since argument names don\'t get initialized if their values are not supplied, we cannot access them by names anymore even if we\'ve programmatically written a default value, we can only access them by arguments[index] which useless code readability wise.But aside from this inconvenience, which in certain coding situations might be fully acceptable, there\'s another unaccounted problem for multiple and arbitrary number of argument defaults. Which may and should be considered a bug, as we can no longer skip arguments, as we once might have been able to, without giving a value, in a syntax such as:because it will throw! Which makes it impossible for us to substitute our argument with a specific falsy type of our desired default value.\nWhich is stupid, since the arguments object is an array-like object and is expected to support this syntax and convention as is, natively or by default!Because of this shortsighted decision we can no longer hope to write a function like this:in which case, we would be able to write each default value of a desired type in arguments row and be able to at least access them by args.index.For instance this function call would yield:as defined in our default array of arguments values.\nHowever the following is still possible:But regretfully not:Which would otherwise be logging:but that\'s in a better world!\nHowever - for the original question - the topmost function will do just fine.\ne.g.:p.s.: sorry for not preserving the types of chosen defaults in my argument inputs while writing them. Some code intel tools, in particular the WebStorm IDE and perhaps jshint, give warnings when you call a function with less arguments than declared:What you can do instead is this:Note that the b argument is declared in a comment for clarity.