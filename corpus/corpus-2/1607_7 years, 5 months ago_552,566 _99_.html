Is there a way to declare a constant in Python? In Java we can create constant values in this manner:What is the equivalent of the above Java constant declaration in Python?No there is not. You cannot declare a variable or value as constant in Python. Just don\'t change it.If you are in a class, the equivalent would be:if not, it is justBut you might want to have a look at the code snippet Constants in Python by Alex Martelli.There\'s no const keyword as in other languages, however it is possible to create a Property that has a "getter function" to read the data, but no "setter function" to re-write the data. This essentially protects the identifier from being changed.Here is an alternative implementation using class property:Note that the code is far from easy for a reader wondering about constants. See explanation belowCode Explanation:And in some other more old-fashioned way:(The code is quite tricky, more explanations below)Note that the @apply decorator seems to be deprecated.In Python instead of language enforcing something, people use naming conventions e.g __method for private methods and using _method for protected methods.So in same manner you can simply declare the constant as all caps e.g.If you want that this constant never changes, you can hook into attribute access and do tricks, but a simpler approach is to declare a functionOnly problem is everywhere you will have to do MY_CONSTANT(), but again MY_CONSTANT = "one" is the correct way in python(usually).You can also use namedtuple to create constants:I\'m probably missing a trick here, but this seems to work for me:Creating the instance allows the magic __setattr__ method to kick in and intercept attempts to set the FOO variable. You could throw an exception here if you wanted to. Instantiating the instance over the class name prevents access directly via the class.It\'s a total pain for one value, but you could attach lots to your CONST object. Having an upper class, class name also seems a bit grotty, but I think it\'s quite succinct overall.In addition to the two top answers (just use variables with UPPERCASE names, or use properties to make the values read-only), I want to mention that it\'s possible to use metaclasses in order to implement named constants.  I provide a very simple solution using metaclasses at GitHub which may be helpful if you want the values to be more informative about their type/name:This is slightly more advanced Python, but still very easy to use and handy.  (The module has some more features, including constants being read-only, see its README.)There are similar solutions floating around in various repositories, but to the best of my knowledge they either lack one of the fundamental features that I would expect from constants (like being constant, or being of arbitrary type), or they have esoteric features added that make them less generally applicable.  But YMMV, I would be grateful for feedback. :-)Edit: Added sample code for Python 3Note: this other answer looks like it provides a much more complete implementation similar to the following (with more features).First, make a metaclass:This prevents statics properties from being changed. Then make another class that uses that metaclass:Or, if you\'re using Python 3:This should prevent instance props from being changed. To use it, inherit:Now the props, accessed directly or via an instance, should be constant:Here\'s an example of above in action. Here\'s another example for Python 3.I would make a class that overrides the __setattr__ method of the base object class and wrap my constants with that, note that I\'m using python 2.7:To wrap a string:It\'s pretty simple, but if you want to use your constants the same as you would a non-constant object (without using constObj.value), it will be a bit more intensive. It\'s possible that this could cause problems, so it might be best to keep the .value to show and know that you are doing operations with constants (maybe not the most \'pythonic\' way though).The Pythonic way of declaring "constants" is basically a module level variable:And then write your classes or functions. Since constants are almost always integers, and they are also immutable in Python, you have a very little chance of altering it.Unless, of course, if you explicitly set RED = 2.Here is an implementation of a "Constants" class, which creates instances with read-only (constant) attributes. E.g. can use Nums.PI to get a value that has been initialized as 3.14159, and Nums.PI = 22 raises an exception.Thanks to @MikeGraham \'s FrozenDict, which I used as a starting point. Changed, so instead of Nums[\'ONE\'] the usage syntax is Nums.ONE.And thanks to @Raufio\'s answer, for idea to override __ setattr __.Or for an implementation with more functionality, see @Hans_meine \'s\nnamed_constants at GitHubA tuple technically qualifies as a constant, as a tuple will raise an error if you try to change one of its values. If you want to declare a tuple with one value, then place a comma after its only value, like this:To check this variable\'s value, use something similar to this:  If you attempt to change this value, an error will be raised.Python dictionaries are mutable, so they don\'t seem like a good way to declare constants:You can use a namedtuple as a workaround to effectively create a constant that works the same way as a static final variable in Java (a Java "constant"). As workarounds go, it\'s sort of elegant. (A more elegant approach would be to simply improve the Python language --- what sort of language lets you redefine math.pi? -- but I digress.)(As I write this, I realize another answer to this question mentioned namedtuple, but I\'ll continue here because I\'ll show a syntax that more closely parallels what you\'d expect in Java, as there is no need to create a named type as namedtuple forces you to do.)Following your example, you\'ll remember that in Java we must define the constant inside some class; because you didn\'t mention a class name, let\'s call it Foo. Here\'s the Java class:Here\'s the equivalent Python.The key point I want to add here is that you don\'t need a separate Foo type (an "anonymous named tuple" would be nice, even though that sounds like an oxymoron), so we name our namedtuple _Foo so that hopefully it won\'t escape to importing modules.The second point here is that we immediately create an instance of the nametuple, calling it Foo; there\'s no need to do this in a separate step (unless you want to). Now you can do what you can do in Java:But you can\'t assign to it:Acknowledgement: I thought I invented the namedtuple approach, but then I see that someone else gave a similar (although less compact) answer. Then I also noticed What are "named tuples" in Python?, which points out that sys.version_info is now a namedtuple, so perhaps the Python standard library already came up with this idea much earlier.Note that unfortunately (this still being Python), you can erase the entire Foo assignment altogether:(facepalm)But at least we\'re preventing the Foo.CONST_NAME value from being changed, and that\'s better than nothing. Good luck.Unfortunately the Python has no constants so yet and it is shame. ES6 already added support constants to JavaScript (https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const) since it is a very useful thing in any programming language.\nAs answered in other answers in Python community use the convention - user uppercase variable as constants, but it does not protect against arbitrary errors in code.\nIf you like, you may be found useful a single-file solution as next\n(see docstrings how use it).file constants.pyIf this is not enough, see full testcase for it.Advantages:\n 1. Access to all constants for whole project\n 2. Strict control for values of constantsLacks:\n 1. Not support for custom types and the type \'dict\'Notes:Tested with Python3.4 and Python3.5 (I am use the \'tox\' for it)Testing environment:.Properties are one way to create constants. You can do it by declaring a getter property, but ignoring the setter. For example:You can have a look at an article I\'ve written to find more ways to use Python properties.In my case, I needed immutable bytearrays for an implementation of a crypto library containing many literal numbers I wanted to ensure were constant.This answer works but attempted reassignment of bytearray elements does not raise an error.Constants are immutable, but constant bytearray assignment fails silently:A more powerful, simple, and perhaps even more \'pythonic\' approach involves the use of memoryview objects (buffer objects in <= python-2.6).ConstArray item assignment is a TypeError:I write a util lib for python const:\n kkconst - pypi \nsupport str, int, float, datetime the const field instance will keep its base type behavior.For example:more details usage you can read the pypi url: \n pypi  or  github You can wrap a constant in a numpy array, flag it write only, and always call it by index zero.of course this only protects the contents of the numpy, not the variable "CONSTANT" itself; you can still do:and CONSTANT would change, however that would quickly throw an TypeError the first time CONSTANT[0] is later called in the script.although... I suppose if you at some point changed it to now you wouldn\'t get the TypeError anymore.  hmmmm....https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setflags.htmlWe can create a descriptor object:Extending Raufio\'s answer, add a repr to return the value.then the object behaves a little more like you might expect, you can access it directly rather then \'.value\'well.. even though this is outdated, let me add my 2 cents here :-)Instead of ValueError to break, you can prevent any update happening there. One advantage of this is that you can add constants dynamically in the program but you cannot change once a constant is set. Also you can add any rule or whatsoever before setting a constant(something like key must be a string or a lower case string or upper case string and so on before setting the key)However, I do not see any importance of setting constants in Python. No optimizations can happen like in C and hence it is something that is not required, I guess.You can emulate constant variables with help of the next class. An example of usage:Call the constructor when you want to start a new constant namespace. Note that the class is under protection from unexpected modifying sequence type constants when Martelli\'s const class is not.The source is below.Here\'s a trick if you want constants and don\'t care their values:Just define empty classes.e.g:As you probably already know, Python doesn\'t have constants :(Perhaps the easiest alternative is to define a function for it. E.g.MY_CONSTANT() now has all the functionality of a constant (plus some annoying braces).A python dictionary is unchangeable once declared and can serve as constants.