I\'m trying to create an NSTimer in Swift but I\'m having some trouble.test() is a function in the same class.I get an error in the editor: Could not find an overload for \'init\' that accepts the supplied\n  argumentsWhen I change selector: test() to selector: nil the error disappears.I\'ve tried:But nothing works and I can\'t find a solution in the references.Swift itself doesn\'t use selectors \xe2\x80\x94 several design patterns that in Objective-C make use of selectors work differently in Swift. (For example, use optional chaining on protocol types or is/as tests instead of respondsToSelector:, and use closures wherever you can instead of performSelector: for better type/memory safety.)But there are still a number of important ObjC-based APIs that use selectors, including timers and the target/action pattern. Swift provides the Selector type for working with these. (Swift automatically uses this in place of ObjC\'s SEL type.)You can construct a Selector from a Swift function type using the #selector expression.The great thing about this approach? A function reference is checked by the Swift compiler, so you can use the #selector expression only with class/method pairs that actually exist and are eligible for use as selectors (see "Selector availability" below). You\'re also free to make your function reference only as specific as you need, as per the Swift 2.2+ rules for function-type naming.(This is actually an improvement over ObjC\'s @selector() directive, because the compiler\'s -Wundeclared-selector check verifies only that the named selector exists. The Swift function reference you pass to #selector checks existence, membership in a class, and type signature.)There are a couple of extra caveats for the function references you pass to the #selector expression:Cases where #selector doesn\'t work, and naming: Sometimes you don\'t have a function reference to make a selector with (for example, with methods dynamically registered in the ObjC runtime). In that case, you can construct a Selector from a string: e.g. Selector("dynamicMethod:") \xe2\x80\x94 though you lose the compiler\'s validity checking. When you do that, you need to follow ObjC naming rules, including colons (:) for each parameter.Selector availability: The method referenced by the selector must be exposed to the ObjC runtime. This is already the case if it\'s in a class that (ultimately) inherits from NSObject, but if it\'s in a pure Swift class you\'ll need to preface that method\'s declaration with @objc. Remember that private symbols aren\'t exposed to the runtime, too \xe2\x80\x94 your method needs to have at least internal visibility.Key paths: These are related to but not quite the same as selectors. There\'s a special syntax for these in Swift 3, too: e.g. chris.valueForKeyPath(#keyPath(Person.friends.firstName)). See SE-0062 for details.You can read more about selectors under Interacting with Objective-C APIs in Using Swift with Cocoa and Objective-C.Note: Before Swift 2.2, Selector conformed to StringLiteralConvertible, so you might find old code where bare strings are passed to APIs that take selectors. You\'ll want to run "Convert to Current Swift Syntax" in Xcode to get those using #selector.Here\'s a quick example on how to use the Selector class on Swift:Note that if the method passed as a string doesn\'t work, it will fail at runtime, not compile time, and crash your app. Be carefulAlso, if your (Swift) class does not descend from an Objective-C class, then you must have a colon at the end of the target method name string and you must use the @objc property with your target method e.g.otherwise you will get a "Unrecognised Selector" error at runtime.For future readers, I found that I experienced a problem and was getting an unrecognised selector sent to instance error that was caused by marking the target func as private.The func MUST be publicly visible to be called by an object with a reference to a selector. Just in case somebody else have the same problem I had with NSTimer where none of the other answers fixed the issue, is really important to mention that, if you are using a class that do not inherits from NSObject either directly or deep in the hierarchy(e.g. manually created swift files), none of the other answers will work even when is specified as follows:Without changing anything else other than just making the class inherit from NSObject I stopped getting the "Unrecognized selector" Error and got my logic working as expected.Swift 2.2+ and Swift 3 UpdateUse the new #selector expression, which eliminates the need to use string literals making usage less error-prone. For reference:becomesSee also: Swift Evolution ProposalIf you want to pass a parameter to the function from the NSTimer then here is your solution:Include the colon in the selector text (tester:), and your parameter(s) go in userInfo.Your function should take NSTimer as a parameter.  Then just extract userInfo to get the parameter that passed.Selectors are an internal representation of a method name in Objective-C. In Objective-C "@selector(methodName)" would convert a source-code method into a data type of SEL. Since you can\'t use the @selector syntax in Swift (rickster is on point there), you have to manually specify the method name as a String object directly, or by passing a String object to the Selector type. Here is an example:or Swift 4.0you create the Selector like below.1.add the event to a button like:\nand the function will be like below:\n//Refresh Control MethodSince Swift 3.0 is published, it is even a little bit more subtle to declare a targetAction appropriateWhen using performSelector() /addtarget()/NStimer.scheduledTimerWithInterval() methods your method (matching the selector) should be marked as For Swift 2.2,\nyou need to write \'#selector()\' instead of string and selector name so the possibilities of spelling error and crash due to that will not be there anymore. Below is exampleI found many of these answers to be helpful but it wasn\'t clear how to do this with something that wasn\'t a button. I was adding a gesture recognizer to a UILabel in swift and struggled so here\'s what I found worked for me after reading everything above:Where the "Selector" was declared as:Note that it is public and that I am not using the Selector() syntax but it is possible to do this as well.Using #selector will check your code at compile time to make sure the method you want to call actually exists. Even better, if the method doesn\xe2\x80\x99t exist, you\xe2\x80\x99ll get a compile error: Xcode will refuse to build your app, thus banishing to oblivion another possible source of bugs.you create the Selector like below.\n1.2.Take note that the @selector syntax is gone and replaced with a simple String naming the method to call. There\xe2\x80\x99s one area where we can all agree the verbosity got in the way. Of course, if we declared that there is a target method called flatButtonPressed: we better write one:set the timer:In order to be complete, here\xe2\x80\x99s the flatButtonPressed  It may be useful to note where you setup the control that triggers the action matters.For example, I have found that when setting up a UIBarButtonItem, I had to create the button within viewDidLoad or else I would get an unrecognized selector exception.Change as a simple string naming in the method calling for selector syntaxAfter that, type func test(). Swift 4\n With sample of tap gestureFor swift 3Function Declaration In Same Class