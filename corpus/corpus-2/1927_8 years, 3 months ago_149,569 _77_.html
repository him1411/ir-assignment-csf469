I\'m originally a Java programmer who now works with Objective-C. I\'d like to create an abstract class, but that doesn\'t appear to be possible in Objective-C. Is this possible?If not, how close to an abstract class can I get in Objective-C?Typically, Objective-C class are abstract by convention only\xe2\x80\x94if the author documents a class as abstract, just don\'t use it without subclassing it. There is no compile-time enforcement that prevents instantiation of an abstract class, however. In fact, there is nothing to stop a user from providing implementations of abstract methods via a category (i.e. at runtime). You can force a user to at least override certain methods by raising an exception in those methods implementation in your abstract class:If your method returns a value, it\'s a bit easier to useas then you don\'t need to add a return statement from the method.If the abstract class is really an interface (i.e. has no concrete method implementations), using an Objective-C protocol is the more appropriate option.No, there is no way to create an abstract class in Objective-C.You can mock an abstract class - by making the methods/ selectors call doesNotRecognizeSelector: and therefore raise an exception making the class unusable.For example:You can also do this for init.Just riffing on @Barry Wark\'s answer above (and updating for iOS 4.3) and leaving this for my own reference:then in your methods you can use this\nNotes: Not sure if making a macro look like a C function is a good idea or not, but I\'ll keep it until schooled to the contrary. I think it\'s more correct to use NSInvalidArgumentException (rather than NSInternalInconsistencyException) since that\'s what the runtime system throws in response to doesNotRecognizeSelector being called (see NSObject docs).The solution I came up with is:This way the compiler will give you a warning for any method in the protocol that isn\'t implemented by your child class.It\'s not as succinct as in Java, but you do get the desired compiler warning.From the Omni Group mailing list:Objective-C doesn\'t have the abstract compiler construct like Java at\nthis time.So all you do is define the abstract class as any other normal class\nand implement methods stubs for the abstract methods that either are\nempty or report non-support for selector. For example...I also do the following to prevent the initialization of the abstract\nclass via the default initializer.Instead of trying to create an abstract base class, consider using a protocol (similar to a Java interface). This allows you to define a set of methods, and then accept all objects that conform to the protocol and implement the methods. For example, I can define an Operation protocol, and then have a function like this:Where op can be any object implementing the Operation protocol.If you need your abstract base class to do more than simply define methods, you can create a regular Objective-C class and prevent it from being instantiated. Just override the - (id)init function and make it return nil or assert(false). It\'s not a very clean solution, but since Objective-C is fully dynamic, there\'s really no direct equivalent to an abstract base class.This thread is kind of old, and most of what I want to share is already here.However, my favorite method is not mentioned, and AFAIK there\xe2\x80\x99s no native support in the current Clang, so here I go\xe2\x80\xa6First, and foremost (as others have pointed out already) abstract classes are something very uncommon in Objective-C \xe2\x80\x94 we usually use composition (sometimes through delegation) instead. This is probably the reason why such a feature doesn\xe2\x80\x99t already exist in the language/compiler \xe2\x80\x94 apart from @dynamic properties, which IIRC have been added in ObjC 2.0 accompanying the introduction of CoreData.But given that (after careful assessment of your situation!) you have come to the conclusion that delegation (or composition in general) isn\xe2\x80\x99t well suited to solving your problem, here\xe2\x80\x99s how I do it:I personally prefer the macro version as that allows me to reduce the boilerplate as much as possible.Here it is:As you can see, the macro provides the full implementation of the abstract methods, reducing the necessary amount of boilerplate to an absolute minimum.An even better option would be to lobby the Clang team to providing a compiler attribute for this case, via feature requests. (Better, because this would also enable compile-time diagnostics for those scenarios where you subclass e.g. NSIncrementalStore.)That last point needs some explanation, I guess:Some (most?) people strip assertions in release builds. (I disagree with that habit, but that\xe2\x80\x99s another story\xe2\x80\xa6) Failing to implement a required method \xe2\x80\x94 however \xe2\x80\x94 is bad, terrible, wrong, and basically the end of the universe for your program. Your program cannot work correctly in this regard because it is undefined, and undefined behavior is the worst thing ever. Hence, being able to strip those diagnostics without generating new diagnostics would be completely unacceptable.It\xe2\x80\x99s bad enough that you cannot obtain proper compile-time diagnostics for such programmer errors, and have to resort to at-run-time discovery for these, but if you can plaster over it in release builds, why try having an abstract class in the first place?Using @property and @dynamic could also work. If you declare a dynamic property and don\'t give a matching method implementation, everything will still compile without warnings, and you\'ll get an unrecognized selector error at runtime if you try to access it. This essentially the same thing as calling [self doesNotRecognizeSelector:_cmd], but with far less typing.In Xcode (using clang etc) I like to use __attribute__((unavailable(...))) to tag the abstract classes so you get an error/warning if you try and use it.It provides some protection against accidentally using the method.In the base class @interface tag the "abstract" methods:Taking this one-step further, I create a macro:This lets you do this:Like I said, this is not real compiler protection but it\'s about as good as your going to get in a language that doesn\'t support abstract methods.The answer to the question is scattered around in the comments under the already given answers. So, I am just summarising and simplifying here.If you want to create an abstract class with no implementation use \'Protocols\'. The classes inheriting a protocol are obliged to implement the methods in the protocol.If you want to create an abstract class with partial implementation like "Template Method Pattern" then this is the solution.\nObjective-C - Template methods pattern?Another alternativeJust check the class in the Abstract class and Assert or Exception, whatever you fancy.This removes the necessity to override init(more of a related suggestion)I wanted to have a way of letting the programmer know "do not call from child" and to override completely (in my case still offer some default functionality on behalf of the parent when not extended):The advantage is that the programmer will SEE the "override" in the declaration and will know they should not be calling [super ..].Granted, it is ugly having to define individual return types for this, but it serves as a good enough visual hint and you can easily not use the "override_" part in a subclass definition.Of course a class can still have a default implementation when an extension is optional. But like the other answers say, implement a run-time exception when appropriate, like for abstract (virtual) classes.It would be nice to have built in compiler hints like this one, even hints for when it is best to pre/post call the super\'s implement, instead of having to dig through comments/documentation or... assume.If you are used to the compiler catching abstract instantiation violations in other languages, then the Objective-C behavior is disappointing.As a late binding language it is clear that Objective-C cannot make static decisions on whether a class truly is abstract or not (you might be adding functions at runtime...), but for typical use cases this seems like a shortcoming. I would prefer the compiler flat-out prevented instantiations of abstract classes instead of throwing an error at runtime.Here is a pattern we are using to get this type of static checking using a couple of techniques to hide initializers:Probably this kind of situations should only happen at development time, so this might work:You can use a method proposed by @Yar (with some modification):Here you will get a message like:Or assertion:In this case you will get:Also you can use protocols and other solutions - but this is one of the simplest ones.Cocoa doesn\xe2\x80\x99t provide anything called abstract. We can create a class abstract which gets checked only at runtime, and at compile time this is not checked.I usually just disable the init method in a class that I want to abstract:This will generate an error at compile time whenever you call init on that class. I then use class methods for everything else.Objective-C has no built-in way for declaring abstract classes.Changing a little what @redfood suggested by applying @dotToString\'s comment, you actually have the solution adopted by Instagram\'s IGListKit.Because AbstractClass does not implement Protocol, the only way to have an AbstractClass<Protocol> instance is by subclassing. As AbstractClass alone can\'t be used anywhere in the project, it becomes abstract.Of course, this doesn\'t prevent unadvised developers from adding new methods referring simply to AbstractClass, which would end up allowing an instance of the (not anymore) abstract class.Real world example: IGListKit has a base class IGListSectionController which doesn\'t implement the protocol IGListSectionType, however every method that requires an instance of that class, actually asks for the type IGListSectionController<IGListSectionType>. Therefore there\'s no way to use an object of type IGListSectionController for anything useful in their framework.In fact, Objective-C doesn\'t have abstract classes, but you can use Protocols to achieve the same effect. Here is the sample:A simple example of creating an abstract classCan\'t you just create a delegate?A delegate is like an abstract base class in the sense that you say what functions need to be defined, but you don\'t actually define them.Then whenever you implement your delegate (i.e abstract class) you are warned by the compiler of what optional and mandatory functions you need to define behavior for.This sounds like an abstract base class to me.