This might sound lame, but  I have not been able to find a really good explanation of Aggregate.Good means short, descriptive, comprehensive with a small and clear example.The easiest to understand definition of Aggregate is that it performs an operation on each element of the list taking into account the operations that have gone before. That is to say it performs the action on the first and second element and carries the result forward. Then it operates on the previous result and the third element and carries forward. etc.Example 1. Summing numbersThis adds 1 and 2 to make 3. Then adds 3 (result of previous) and 3 (next element in sequence) to make 6. Then adds 6 and 4 to make 10.Example 2. create a csv from an array of stringsThis works in much the same way. Concatenate a a comma and b to make a,b. Then concatenates a,b  with a comma and c to make a,b,c. and so on.Example 3. Multiplying numbers using a seedFor completeness, there is an overload of Aggregate which takes a seed value. Much like the above examples, this starts with a value of 5 and multiplies it by the first element of the sequence 10 giving a result of 50. This result is carried forward and multiplied by the next number in the sequence 20 to give a result of 1000. This continues through the remaining 2 element of the sequence.Live examples: http://rextester.com/ZXZ64749\nDocs: http://msdn.microsoft.com/en-us/library/bb548651.aspxAddendumExample 2, above, uses string concatenation to create a list of values separated by a comma. This is a simplistic way to explain the use of Aggregate which was the intention of this answer. However, if using this technique to actually create a large amount of comma separated data, it would be more appropriate to use a StringBuilder, and this is entirely compatible with Aggregate using the seeded overload to initiate the StringBuilder.Updated example: http://rextester.com/YZCVXV6464It partly depends on which overload you\'re talking about, but the basic idea is:You may find the Aggregate post in my Edulinq series useful - it includes a more detailed description (including the various overloads) and implementations.One simple example is using Aggregate as an alternative to Count:Or perhaps summing all the lengths of strings in a sequence of strings:Personally I rarely find Aggregate useful - the "tailored" aggregation methods are usually good enough for me.Super short \nAggregate works like fold in Haskell/ML/F#.Slightly longer\n.Max(), .Min(), .Sum(), .Average() all iterates over the elements in a sequence and aggregates them using the respective aggregate function. .Aggregate () is generalized aggregator in that it allows the developer to specify the start state (aka seed) and the aggregate function.I know you asked for a short explaination but I figured as others gave a couple of short answers I figured you would perhaps be interested in a slightly longer oneLong version with code\nOne way to illustrate what does it could be show how you implement Sample Standard Deviation once using foreach and once using .Aggregate. Note: I haven\'t prioritized performance here so I iterate several times over the colleciton unnecessarilyFirst a helper function used to create a sum of quadratic distances:Then Sample Standard Deviation using ForEach:Then once using .Aggregate:Note that these functions are identical except for how sumOfQuadraticDistance is calculated:Versus:So what .Aggregate does is that it encapsulates this aggregator pattern and I expect that the implementation of .Aggregate would look something like this:Using the Standard deviation functions would look something like this:IMHOSo does .Aggregate help readability? In general I love LINQ because I think .Where, .Select, .OrderBy and so on greatly helps readability (if you avoid inlined hierarhical .Selects). Aggregate has to be in Linq for completeness reasons but personally I am not so convinced that .Aggregate adds readability compared to a well written foreach.Aggregate is basically  used to Group or Sum up data.According to MSDN\n           "Aggregate Function Applies an accumulator function over a sequence."Example 1: Add all the numbers in a array.*important: The initial aggregate value by default is the 1 element in the sequence of collection.\ni.e: the total variable initial value will be 1 by default.variable explanationtotal: it will hold the sum up value(aggregated value) returned by the func.nextValue: it is the next value in the array sequence. This value is than added to the aggregated value i.e total.Example 2: Add all items in an array. Also set the initial accumulator value to start adding with from 10.arguments explanation:the first argument is the initial(starting value i.e seed value) which will be used to start addition with the next value in the array.the second argument is a func which is a func that takes 2 int.1.total: this will hold same as before the sum up value(aggregated value) returned by the func after the calculation.2.nextValue: : it is the next value in the array sequence. This value is than added to the aggregated value i.e total. Also debugging this code will give you a better understanding of how aggregate work.Reminder: Func<A,\xe2\x80\x82B,\xe2\x80\x82C> is a function with two inputs of type A and B, that returns a C.Enumerable.Aggregate has three overloads:\nOverload 1:Example:This overload is simple, but it has the following limitations:  Overload 2:Example:This overload is more general:  Overload 3:The third overload is not very useful IMO.\nThe same can be written more succinctly by using overload 2 followed by a function that transforms its result.The illustrations are adapted from this excellent blogpost.Learned a lot from Jamiec\'s answer. If the only need is to generate CSV string, you may try this.Here is a test with 1 million stringsSource code is hereA short and essential definition might be this: Linq Aggregate extension method allows to declare a sort of recursive function applied on the elements of a list, the operands of whom are two: the elements in the order in which they are present into the list, one element at a time, and the result of the previous recursive iteration or nothing if not yet recursion.In this way you can compute the factorial of numbers, or concatenate strings.This is an explanation about using Aggregate on a Fluent API such as Linq Sorting.and lets see we want to implement a sort function that take a set of fields, this is very easy using Aggregate instead of a for-loop, like this:And we can use it like this:Aggregate used to sum columns in a multi dimensional integer arraySelect with index is used within the Aggregate func to sum the matching columns and return a new Array; { 3 + 2 = 5, 1 + 4 = 5, 7 + 16 = 23, 8 + 5 = 13 }.But counting the number of trues in a Boolean array is more difficult since the accumulated type (int) differs from the source type (bool); here a seed is necessary in order to use the second overload.In addition to all the great answers here already, I\'ve also used it to walk an item through a series of transformation steps.If a transformation is implemented as a Func<T,T>, you can add several  transformations to a List<Func<T,T>> and use Aggregate to walk an instance of T through each step.You want to take a string value, and walk it through a series of text transformations that could be built programatically.This will create a chain of transformations: Remove leading and trailing spaces -> remove first character -> remove last character -> convert to upper-case. Steps in this chain can be added, removed, or reordered as needed, to create whatever kind of transformation pipeline is required.The end result of this specific pipeline, is that "    cat   " becomes "A".This can become very powerful once you realize that T can be anything.  This could be used for image transformations, like filters, using BitMap as an example;