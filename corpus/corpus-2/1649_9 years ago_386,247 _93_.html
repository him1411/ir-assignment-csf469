Is there any difference between a binary semaphore and mutex or are they essentially the same?They are NOT the same thing.  They are used for different purposes!\nWhile both types of semaphores have a full/empty state and use the same API, their usage is very different.  Mutual Exclusion Semaphores\nMutual Exclusion semaphores are used to protect shared resources (data structure, file, etc..). A Mutex semaphore is "owned" by the task that takes it.  If Task B attempts to semGive a mutex currently held by Task A, Task B\'s call will return an error and fail.Mutexes always use the following sequence:  Here is a simple example:Binary Semaphore\nBinary Semaphore address a totally different question:  Note that with a binary semaphore, it is OK for B to take the semaphore and A to give it.\nAgain, a binary semaphore is NOT protecting a resource from access. The act of Giving and Taking a semaphore are fundamentally decoupled.\nIt typically makes little sense for the same task to so a give and a take on the same binary semaphore.Mutex can be released only by thread that had acquired it, while you can signal semaphore from any other thread (or process), so semaphores are more suitable for some synchronization problems like producer-consumer.On Windows, binary semaphores are more like event objects than mutexes.The Toilet example is an enjoyable analogy:Mutex:Is a key to a toilet. One person can\n  have the key - occupy the toilet - at\n  the time. When finished, the person\n  gives (frees) the key to the next\n  person in the queue.Officially: "Mutexes are typically\n  used to serialise access to a section\n  of  re-entrant code that cannot be\n  executed concurrently by more than one\n  thread. A mutex object only allows one\n  thread into a controlled section,\n  forcing other threads which attempt to\n  gain access to that section to wait\n  until the first thread has exited from\n  that section." Ref: Symbian Developer\n  Library(A mutex is really a semaphore with\n  value 1.)Semaphore:Is the number of free identical toilet\n  keys. Example, say we have four\n  toilets with identical locks and keys.\n  The semaphore count - the count of\n  keys - is set to 4 at beginning (all\n  four toilets are free), then the count\n  value is decremented as people are\n  coming in. If all toilets are full,\n  ie. there are no free keys left, the\n  semaphore count is 0. Now, when eq.\n  one person leaves the toilet,\n  semaphore is increased to 1 (one free\n  key), and given to the next person in\n  the queue.Officially: "A semaphore restricts the\n  number of simultaneous users of a\n  shared resource up to a maximum\n  number. Threads can request access to\n  the resource (decrementing the\n  semaphore), and can signal that they\n  have finished using the resource\n  (incrementing the semaphore)." Ref:\n  Symbian Developer LibraryNice articles on the topic:From part 2:The mutex is similar to the principles\n  of the binary semaphore with one\n  significant difference: the principle\n  of ownership. Ownership is the simple\n  concept that when a task locks\n  (acquires) a mutex only it can unlock\n  (release) it. If a task tries to\n  unlock a mutex it hasn\xe2\x80\x99t locked (thus\n  doesn\xe2\x80\x99t own) then an error condition\n  is encountered and, most importantly,\n  the mutex is not unlocked. If the\n  mutual exclusion object doesn\'t have\n  ownership then, irrelevant of what it\n  is called, it is not a mutex.Since none of the above answer clears the confusion, here is one which cleared my confusion.Strictly speaking, a mutex is locking mechanism used to\n  synchronize access to a resource. Only one task (can be a thread or\n  process based on OS abstraction) can acquire the mutex. It means there\n  will be ownership associated with mutex, and only the owner can\n  release the lock (mutex).Semaphore is signaling mechanism (\xe2\x80\x9cI am done, you can carry on\xe2\x80\x9d kind of signal). For example, if you are listening songs (assume it as\n  one task) on your mobile and at the same time your friend called you,\n  an interrupt will be triggered upon which an interrupt service routine\n  (ISR) will signal the call processing task to wakeup.Source: http://www.geeksforgeeks.org/mutex-vs-semaphore/Their synchronization semantics are very different:As such one can see a mutex as a token passed from task to tasks and a semaphore as traffic red-light (it signals someone that it can proceed).At a theoretical level, they are no different semantically.  You can implement a mutex using semaphores or vice versa (see here for an example).  In practice, the implementation is different and they offer slightly different services.The practical difference (in terms of the system services surrounding them) is that the implementation of a mutex is aimed at being a more lightweight synchronisation mechanism.  In oracle-speak, mutexes are known as latches and semaphores are known as waits.At the lowest level, they use some sort of atomic test and set mechanism.  This reads the current value of a memory location, computes some sort of conditional and writes out a value at that location in a single instruction that cannot be interrupted.  This means that you can acquire a mutex and test to see if anyone else had it before you.A typical mutex implementation has a process or thread executing the test-and-set instruction and evaluating whether anything else had set the mutex.   A key point here is that there is no interaction with the scheduler, so we have no idea (and don\'t care) who has set the lock.  Then we either give up our time slice and attempt it again when the task is re-scheduled or execute a spin-lock.  A spin lock is an algorithm like:When we have finished executing our protected code (known as a critical section) we just set the mutex value to zero or whatever means \'clear.\'  If multiple tasks are attempting to acquire the mutex they the next task that happens to be scheduled after the mutex is released will get access to the resource.  Typically you would use mutexes to control a synchronised resource where exclusive access is only needed for very short periods of time, normally to make an update to a shared data structure.A semaphore is a synchronised data structure (typically using a mutex) that has a count and some system call wrappers that interact with the scheduler in a bit more depth than the mutex libraries would.  Semaphores are incremented and decremented and used to block tasks until something else is ready.  See Producer/Consumer Problem for a simple example of this.  Semaphores are initialised to some value - a binary semaphore is just a special case where the semaphore is initialised to 1.  Posting to a semaphore has the effect of waking up a waiting process.A basic semaphore algorithm looks like:In the case of a binary semaphore the main practical difference between the two is the nature of the system services surrounding the actual data structure.EDIT: As evan has rightly pointed out, spinlocks will slow down a single processor machine.  You would only use a spinlock on a multi-processor box because on a single processor the process holding the mutex will never reset it while another task is running.  Spinlocks are only useful on multi-processor architectures.Though mutex & semaphores are used as synchronization primitives ,there is a big difference between them.\nIn the case of mutex, only the thread that locked or acquired the mutex can unlock it.\nIn the case of a semaphore, a thread waiting on a semaphore can be signaled by a different thread.\nSome operating system supports using mutex & semaphores between process. Typically usage is creating in shared memory.You obviously use mutex to lock a data in one thread getting accessed by another thread at the same time.  Assume that you have just called lock() and in the process of accessing data.  This means that you don\xe2\x80\x99t expect any other thread (or another instance of the same thread-code) to access the same data locked by the same mutex.  That is, if it is the same thread-code getting executed on a different thread instance, hits the lock, then the lock() should block the control flow there.  This applies to a thread that uses a different thread-code, which is also accessing the same data and which is also locked by the same mutex.  In this case,  you are still in the process of accessing the data and you may take, say, another 15 secs to reach the mutex unlock (so that the other thread that is getting blocked in mutex lock would unblock and would allow the control to access the data). Do you at any cost allow yet another thread to just unlock the same mutex, and in turn, allow the thread that is already waiting (blocking) in the mutex lock to unblock and access the data?  Hope you got what I am saying here?\nAs per, agreed upon universal definition!,  So, if you are very particular about using binary-semaphore instead of mutex, then you should be very careful in \xe2\x80\x9cscoping\xe2\x80\x9d the locks and unlocks. I mean that every control-flow that hits every lock should hit an unlock call, also there shouldn\xe2\x80\x99t be any \xe2\x80\x9cfirst unlock\xe2\x80\x9d, rather it should be always \xe2\x80\x9cfirst lock\xe2\x80\x9d.1.A semaphore can be a Mutex but a Mutex can never be semaphore. This simply means that a binary semaphore ca n be used\nas Mutex, but a Mutex can never exhibit the functionality of semaphore.\n2.  Both semaphores and Mutex (at least the on latest kernel) are non\xc2\xadrecursive in nature.\n3.  No one owns semaphores, whereas Mutex are owned and the owner is held responsible for them. This is an important\ndistinction from a debugging perspective.\n4.  In case the of Mutex, the thread that owns the Mutex is responsible for freeing it. However, in the case of semaphores, this\ncondition is not required. Any other thread can signal to free the semaphore by using the s m p s ( function.e_ot)\n5.  A Mutex, by definition, is used to serialize access to a section of re\xc2\xadentrant code that cannot be executed concurrently by\nmore than one thread. A semaphore, by definition, restricts the number of simultaneous users of a shared resource up to a\nmaximum number\n6.  Another difference that would matter to developers is that semaphores are system\xc2\xadwide and remain in the form of files on\nthe filesystem, unless otherwise cleaned up. Mutex are process\xc2\xadwide and get cleaned up automatically when a process exits.\n7.  The nature of semaphores makes it possible to use them in synchronizing related and unrelated process, as well as between\nthreads. Mutex can be used only in synchronizing between threads and at most between related processes (the pthread\nimplementation of the latest kernel comes with a feature that allows Mutex to be used between related process).\n8.  According to the kernel documentation, Mutex are lighter when compared to semaphores. What this means is that a program\nwith semaphore usage has a higher memory footprint when compared to a program having Mutex.\n9.  From a usage perspective, Mutex has simpler semantics when compared to semaphores.  On Windows, there are two differences between mutexes and binary semaphores:A mutex can only be released by the thread which has ownership, i.e. the thread which previously called the Wait function, (or which took ownership when creating it). A semaphore can be released by any thread.A thread can call a wait function repeatedly on a mutex without blocking. However, if you call a wait function twice on a binary semaphore without releasing the semaphore in between, the thread will block.Mutex are used for " Locking Mechanisms ". one process at a time can use a shared resourcewhereasSemaphores are used for " Signaling Mechanisms " \nlike "I am done , now can continue"Myth:Couple of article says that "binary semaphore and mutex are same" or "Semaphore with value 1 is mutex" but the basic difference is Mutex can be released only by thread that had acquired it, while you can signal semaphore from any other threadKey Points:\xe2\x80\xa2A thread can acquire more than one lock (Mutex).\xe2\x80\xa2A mutex can be locked more than once only if its a recursive mutex, here lock and unlock for mutex should be same\xe2\x80\xa2If a thread which had already locked a mutex, tries to lock the mutex again, it will enter into the waiting list of that mutex, which results in deadlock. \xe2\x80\xa2Binary semaphore and mutex are similar but not same.\xe2\x80\xa2Mutex is costly operation due to protection protocols associated with it.\xe2\x80\xa2Main aim of mutex is achieve atomic access or lock on resourceA Mutex controls access to a single shared resource. It provides operations to acquire() access to that resource and release() it when done.A Semaphore controls access to a shared pool of resources. It provides operations to Wait() until one of the resources in the pool becomes available, and Signal() when it is given back to the pool.When number of resources a Semaphore protects is greater than 1, it is called a Counting Semaphore. When it controls one resource, it is called a Boolean Semaphore. A boolean semaphore is equivalent to a mutex.Thus a Semaphore is a higher level abstraction than Mutex. A Mutex can be implemented using a Semaphore but not the other way around.Modified question is - What\'s the difference between A mutex and a "binary" semaphore in "Linux"?Ans: Following are the differences \xe2\x80\x93\ni) Scope \xe2\x80\x93 The scope of mutex is within a process address space which has created it and is used for synchronization of threads. Whereas semaphore can be used across process space and hence it can be used for interprocess synchronization.ii) Mutex is lightweight and faster than semaphore. Futex is even faster.iii) Mutex can be acquired by same thread successfully multiple times with condition that it should release it same number of times. Other thread trying to acquire will block. Whereas in case of semaphore if same process tries to acquire it again it blocks as it can be acquired only once.http://www.geeksforgeeks.org/archives/9102  discusses in details.Mutex is locking mechanism used to synchronize access to a resource.\nSemaphore is signaling mechanism. Its up to to programmer if he/she wants to use  binary semaphore in place of mutex.Diff between Binary Semaphore and Mutex:\nOWNERSHIP:\nSemaphores can be signalled (posted) even from a non current owner. It means you can simply post from any other thread, though you are not the owner.Semaphore is a public property in process, It can be simply posted by a non owner thread.\nPlease Mark this difference in BOLD letters, it mean a lot. Mutex work on blocking critical region, But Semaphore work on count.Apart from the fact that mutexes have an owner, the two objects may be optimized for different usage. Mutexes are designed to be held only for a short time; violating this can cause poor performance and unfair scheduling. For example, a running thread may be permitted to acquire a mutex, even though another thread is already blocked on it. Semaphores may provide more fairness, or fairness can be forced using several condition variables.In windows the difference is as below.\nMUTEX: process which successfully executes wait has to execute a signal and vice versa. BINARY SEMAPHORES: Different processes can execute wait or signal operation on a semaphore.The concept was clear to me after going over above posts. But there were some lingering questions. So, I wrote this small piece of code. When we try to give a semaphore without taking it, it goes through. But, when you try to give a mutex without taking it, it fails. I tested this on a Windows platform. Enable USE_MUTEX to run the same code using a MUTEX.The differences between binary semaphore and mutex are:Mutex is used exclusively for mutual exclusion. Both mutual exclusion and synchronization can be used by binary.\nA task that took mutex can only give mutex.\nFrom an ISR a mutex can not be given.\nRecursive taking of mutual exclusion semaphores is possible. This means that a task that holds before finally releasing a semaphore, can take the semaphore more than once.\nOptions for making the task which takes as DELETE_SAFE are provided by Mutex, which means the task deletion is not possible when holding the mutex.There is an ambiguity between binary semaphore and mutex. We might have come across that a mutex is binary semaphore. But they are not! The purpose of mutex and semaphore are different. May be, due to similarity in their implementation a mutex would be referred as binary semaphore.Strictly speaking, a mutex is locking mechanism used to synchronize access to a resource. Only one task (can be a thread or process based on OS abstraction) can acquire the mutex. It means there will be ownership associated with mutex, and only the owner can release the lock (mutex).Semaphore is signaling mechanism (\xe2\x80\x9cI am done, you can carry on\xe2\x80\x9d kind of signal). For example, if you are listening songs (assume it as one task) on your mobile and at the same time your friend called you, an interrupt will be triggered upon which an interrupt service routine (ISR) will signal the call processing task to wakeup.While a binary semaphore may be used as a mutex, a mutex is a more specific use-case, in that only the process that locked the mutex is supposed to unlock it. This ownership constraint makes it possible to provide protection against:These constraints are not always present because they degrade the speed. During the development of your code, you can enable these checks  temporarily. e.g. you can enable Error check attribute in your mutex. Error checking mutexes return EDEADLK if you try to lock the same one twice and EPERM if you unlock a mutex that isn\'t yours.Once initialised we can place these checks in our code like this:Mutex is used to protect the sensitive code and data, semaphore is used to synchronization.You also can have practical use with protect the sensitive code, but there might be a risk that release the protection by the other thread by operation V.So The main difference between bi-semaphore and mutex is the ownership.For instance by toilet , Mutex is like that one can enter the toilet and lock the door, no one else can enter until the man get out, bi-semaphore is like that one can  enter the toilet and lock the door, but someone else could enter by asking the administrator to open the door, it\'s ridiculous.Mutex: Suppose we have critical section thread T1 wants to access it then it follows below steps.\nT1:Binary semaphore: It works based on signaling wait and signal.\nwait(s) decrease "s" value by one usually "s" value is initialize with value "0",\nsignal(s) increases "s" value by one. if "s" value is 1 means no one is using critical section, when value is 0 means critical section is in use.\nsuppose thread T2 is using critical section then it follows below steps.\nT2 : Main difference between Mutex and Binary semaphore is in Mutext calling thread lock the critical section then it has to unlock critical section no other thread can unlock it, but in case of Binary semaphore if one thread locks critical section using wait(s) function then value of s become "0" and no one can access it until value of "s" become 1 but suppose some other thread calls signal(s) then value of "s" become 1 and it allows other function to use critical section.\nhence in Binary semaphore thread doesn\'t have ownership.The answer may depend on the target OS.  For example, at least one RTOS implementation I\'m familiar with will allow multiple sequential "get" operations against a single OS mutex, so long as they\'re all from within the same thread context.  The multiple gets must be replaced by an equal number of puts before another thread will be allowed to get the mutex.  This differs from binary semaphores, for which only a single get is allowed at a time, regardless of thread contexts.The idea behind this type of mutex is that you protect an object by only allowing a single context to modify the data at a time.  Even if the thread gets the mutex and then calls a function that further modifies the object (and gets/puts the protector mutex around its own operations), the operations should still be safe because they\'re all happening under a single thread.Of course, when using this feature, you must be certain that all accesses within a single thread really are safe!I\'m not sure how common this approach is, or whether it applies outside of the systems with which I\'m familiar.  For an example of this kind of mutex, see the ThreadX RTOS.Mutexes have ownership,  unlike  semaphores.   Although  any thread,  within  the  scope  of a mutex, can get an unlocked mutex and lock access to the same critical section of  code,only the thread that locked a mutex should unlock it.A mutex is essentially the same thing as a binary semaphore and sometimes uses the same basic implementation. The differences between them are in how they are used. While a binary semaphore may be used as a mutex, a mutex is a more specific use-case, which allows extra guarantees:Mutex & Binary semaphore is both of same usage but in reality, They are different. \nIn Case of mutex, The Thread which have Locked it, Only that can unlock it. If any other thread comes to lock it, It will wait. \nBut in Case of semaphone, Its not the case. Semaphore is not tied up with a partucular thread ID. 