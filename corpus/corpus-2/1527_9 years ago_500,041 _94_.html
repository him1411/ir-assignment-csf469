Is there some rare language construct I haven\'t encountered (like the few I\'ve learned recently, some on Stack Overflow) in C# to get a value representing the current iteration of a foreach loop?For instance, I currently do something like this depending on the circumstances:The foreach is for iterating over collections that implement IEnumerable. It does this by calling GetEnumerator on the collection, which will return an Enumerator.This Enumerator has a method and a property:Current returns the object that Enumerator is currently on, MoveNext updates Current to the next object.Obviously, the concept of an index is foreign to the concept of enumeration, and cannot be done.Because of that, most collections are able to be traversed using an indexer and the for loop construct.I greatly prefer using a for loop in this situation compared to tracking the index with a local variable.Ian Mercer posted a similar solution as this on Phil Haack\'s blog:This gets you the item (item.value) and its index (item.i) by using this overload of Linq\'s Select:the second parameter of the function [inside Select] represents the index of the source element.The new { i, value } is creating a new anonymous object.Could do something like this:I disagree with comments that a for loop is a better choice in most cases. foreach is a useful construct, and not replaceble by a for loop in all circumstances. For example, if you have a DataReader and loop through all records using a foreach it automatically calls the Dispose method and closes the reader (which can then close the connection automatically). This is therefore safer as it prevents connection leaks even if you forget to close the reader. (Sure it is good practise to always close readers but the compiler is not going to catch it if you don\'t - you can\'t guarantee you have closed all readers but you can make it more likely you won\'t leak connections by getting in the habit of using foreach.)There may be other examples of the implicit call of the Dispose method being useful.Literal Answer -- warning, performance may not be as good as just using an int to track the index.  At least it is better than using IndexOf.You just need to use the indexing overload of Select to wrap each item in the collection with an anonymous object that knows the index.  This can be done against anything that implements IEnumerable.Using @FlySwat\'s answer, I came up with this solution:You get the enumerator using GetEnumerator and then you loop using a for loop. However, the trick is to make the loop\'s condition listEnumerator.MoveNext() == true.Since the MoveNext method of an enumerator returns true if there is a next element and it can be accessed, making that the loop condition makes the loop stop when we run out of elements to iterate over.You could wrap the original enumerator with another that does contain the index information.Here is the code for the ForEachHelper class.Finally C#7 has a decent syntax for getting an index inside of a foreach loop (i. e. tuples):A little extension method would be needed:Here\'s a solution I just came up with for this problemOriginal code:Updated codeExtension Method:This would work for collections supporting IList.There\'s nothing wrong with using a counter variable. In fact, whether you use for, foreach while or do, a counter variable must somewhere be declared and incremented.So use this idiom if you\'re not sure if you have a suitably-indexed collection:Else use this one if you know that your indexable collection is O(1) for index access (which it will be for Array and probably for List<T> (the documentation doesn\'t say), but not necessarily for other types (such as LinkedList)):It should never be necessary to \'manually\' operate the IEnumerator by invoking MoveNext() and interrogating Current - foreach is saving you that particular bother ... if you need to skip items, just use a continue in the body of the loop.And just for completeness, depending on what you were doing with your index (the above constructs offer plenty of flexibility), you might use Parallel LINQ:We use AsParallel() above, because it\'s 2014 already, and we want to make good use of those multiple cores to speed things up. Further, for \'sequential\' LINQ, you only get a ForEach() extension method on List<T> and Array ... and it\'s not clear that using it is any better than doing a simple foreach, since you are still running single-threaded for uglier syntax.This is how I do it, which is nice for its simplicity/brevity, but if you\'re doing a lot in the loop body obj.Value, it is going to get old pretty fast.Better to use keyword continue safe construction like thisWhy foreach ?!The simplest way is using for instead of foreach if you are using List .OR if you want use foreach :you can use this to khow index of each Loop :If the collection is a list, you can use List.IndexOf, as in:It\'s only going to work for a List and not any IEnumerable, but in LINQ there\'s this:@Jonathan I didn\'t say it was a great answer, I just said it was just showing it was possible to do what he asked :)@Graphain I wouldn\'t expect it to be fast - I\'m not entirely sure how it works, it could reiterate through the entire list each time to find a matching object, which would be a helluvalot of compares.That said, List might keep an index of each object along with the count.Jonathan seems to have a better idea, if he would elaborate?It would be better to just keep a count of where you\'re up to in the foreach though, simpler, and more adaptable.I built this in LINQPad:You could also just use string.join:C# 7 finally gives us an elegant way to do this:I don\'t believe there is a way to get the value of the current iteration of a foreach loop.  Counting yourself, seems to be the best way.May I ask, why you would want to know?It seems that you would most likley be doing one of three things:1)  Getting the object from the collection, but in this case you already have it.2)  Counting the objects for later post processing...the collections have a Count property that you could make use of.3)  Setting a property on the object based on its order in the loop...although you could easily be setting that when you added the object to the collection.My solution for this problem is an extension method WithIndex(),http://code.google.com/p/ub-dotnet-utilities/source/browse/trunk/Src/Utilities/Extensions/EnumerableExtensions.csUse it likeHow about something like this?  Note that myDelimitedString may be null if myEnumerable is empty.For interest, Phil Haack just wrote an example of this in the context of a Razor Templated Delegate (http://haacked.com/archive/2011/04/14/a-better-razor-foreach-loop.aspx)Effectively he writes an extension method which wraps the iteration in an "IteratedItem" class (see below) allowing access to the index as well as the element during iteration.However, while this would be fine in a non-Razor environment if you are doing a single operation (i.e. one that could be provided as a lambda) it\'s not going to be a solid replacement of the for/foreach syntax in non-Razor contexts.I wasn\'t sure what you were trying to do with the index information based on the question. However, in C#, you can usually adapt the IEnumerable.Select method to get the index out of whatever you want. For instance, I might use something like this for whether a value is odd or even.This would give you a dictionary by name of whether the item was odd (1) or even (0) in the list.I don\'t think this should be quite efficient, but it works:You can write your loop like this:After adding the following struct and extension method.The struct and extension method encapsulate Enumerable.Select functionality.The leading answer states:"Obviously, the concept of an index is foreign to the concept of enumeration, and cannot be done."While this is true of the current C# version, this is not a conceptual limit.The creation of a new C# language feature by MS could solve this, along with support for a new Interface IIndexedEnumerableIf foreach is passed an IEnumerable and can\'t resolve an IIndexedEnumerable, but it is asked with var index, then the C# compiler can wrap the source with an IndexedEnumerable object, which adds in the code for tracking the index.Why:While most people here are not MS, this is a correct answer, and you can lobby MS to add such a feature. You could already build your own iterator with an extension function and use tuples, but MS could sprinkle the syntactic sugar to avoid the extension functionUnless your collection can return the index of the object via some method, the only way is to use a counter like in your example.However, when working with indexes, the only reasonable answer to the problem is to use a for loop. Anything else introduces code complexity, not to mention time and space complexity.I just had this problem, but thinking around the problem in my case gave the best solution, unrelated to the expected solution.It could be quite a common case, basically, I\'m reading from one source list and creating objects based on them in a destination list, however, I have to check whether the source items are valid first and want to return the row of any error.  At first-glance, I want to get the index into the enumerator of the object at the Current property, however, as I am copying these elements, I implicitly know the current index anyway from the current destination.  Obviously it depends on your destination object, but for me it was a List, and most likely it will implement ICollection.i.e.Not always applicable, but often enough to be worth mentioning, I think.Anyway, the point being that sometimes there is a non-obvious solution already in the logic you have...Here is another solution to this problem, with a focus on keeping the syntax as close to a standard foreach as possible. This sort of construct is useful if you are wanting to make your views look nice and clean in MVC. For example instead of writing this the usual way (which is hard to format nicely):You could instead write this:I\'ve written some helper methods to enable this:In a non-web environment you could use a static instead of HttpContext.Current.Items.This is essentially a global variable, and so you cannot have more than one WithIndex loop nested, but that is not a major problem in this use case.This doesn\'t answer your specific question, but it DOES provide you with a solution to your problem: use a for loop to run through the object collection. then you will have the current index you are working on.