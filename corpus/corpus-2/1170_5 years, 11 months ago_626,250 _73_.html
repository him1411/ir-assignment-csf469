I have this table for documents (simplified version here):How do I select one row per id and only the greatest rev?\nWith the above data, the result should contain two rows: [1, 3, ...] and [2, 1, ..]. I\'m using MySQL.Currently I use checks in the while loop to detect and over-write old revs from the resultset. But is this the only method to achieve the result? Isn\'t there a SQL solution?Update\nAs the answers suggest, there is a SQL solution, and here a sqlfiddle demo. Update 2\nI noticed after adding the above sqlfiddle, the rate at which the question is upvoted has surpassed the upvote rate of the answers. That has not been the intention! The fiddle is based on the answers, especially the accepted answer.All you need is a GROUP BY clause with the MAX aggregate function:I just noticed you need the content column as well.This is a very common question in SQL: find the whole data for the row with some max value in a column per some group identifier. I heard that a lot during my career. Actually, it was one the questions I answered in my current job\'s technical interview. It is, actually, so common that StackOverflow community has created a single tag just to deal with questions like that: greatest-n-per-group.Basically, you have two approaches to solve that problem:In this approach, you first find the group-identifier, max-value-in-group (already solved above) in a sub-query. Then you join your table to the sub-query with equality on both group-identifier and max-value-in-group:In this approach, you left join the table with itself. Equality, of course, goes in the group-identifier. Then, 2 smart moves: So you end up with:Both approaches bring the exact same result. If you have two rows with max-value-in-group for group-identifier, both rows will be in the result in both approaches.Both approaches are SQL ANSI compatible, thus, will work with your favorite RDBMS, regardless of its "flavor".Both approaches are also performance friendly, however your mileage may vary (RDBMS, DB Structure, Indexes, etc.). So when you pick one approach over the other, benchmark. And make sure you pick the one which make most of sense to you.My preference is to use as little code as possible...You can do it using IN\ntry this:to my mind it is less complicated... easier to read and maintain.Yet another solution is to use a correlated subquery:Having an index on (id,rev) renders the subquery almost as a simple lookup...Following are comparisons to the solutions in @AdrianCarneiro\'s answer (subquery, leftjoin), based on MySQL measurements with InnoDB table of ~1million records, group size being: 1-3.While for full table scans subquery/leftjoin/correlated timings relate to each other as 6/8/9, when it comes to direct lookups or batch (id in (1,2,3)), subquery is much slower then the others (Due to rerunning the subquery). However I couldnt differentiate between leftjoin and correlated solutions in speed.One final note, as leftjoin creates n*(n+1)/2 joins in groups, its performance can be heavily affected by the size of groups...I can\'t vouch for the performance, but here\'s a trick inspired by the limitations of Microsoft Excel.  It has some good featuresGOOD STUFFAPPROACHIt is a little bit ugly and requires that you know something about the range of valid values of the rev column.  Let us assume that we know the rev column is a number between 0.00 and 999 including decimals but that there will only ever be two digits to the right of the decimal point (e.g. 34.17 would be a valid value).The gist of the thing is that you create a single synthetic column by string concatenating/packing the primary comparison field along with the data you want.  In this way, you can force SQL\'s MAX() aggregate function to return all of the data (because it has been packed into a single column).  Then you have to unpack the data.Here\'s how it looks with the above example, written in SQLThe packing begins by forcing the rev column to be a number of known character length regardless of the value of rev so that for exampleIf you do it right, string comparison of two numbers should yield the same "max" as numeric comparison of the two numbers and it\'s easy to convert back to the original number using the substring function (which is available in one form or another pretty much everywhere).I think this is the easiest solution :I also think it\'s the easiest to break down, understand, and modify to other purposes:Understanding this approach, solving any of these similar problems becomes trivial: get employee with lowest salary (change DESC to ASC), get top-ten earning employees (change LIMIT 1 to LIMIT 10), sort by means of another field (change ORDER BY Employee.Salary to ORDER BY Employee.Commission), etc..I am flabbergasted that no answer offered SQL window function solution:Added in SQL standard ANSI/ISO Standard SQL:2003  and later extended with ANSI/ISO Standard SQL:2008, window (or windowing) functions are available with all major vendors now. There are more types of rank functions available to deal with a tie issue: RANK, DENSE_RANK, PERSENT_RANK.Something like this?Since this is most popular question with regard to this problem, I\'ll re-post another answer to it here as well:It looks like there is simpler way to do this (but only in MySQL):Please credit answer of user Bohemian in this question for providing such a concise and elegant answer to this problem.EDIT: though this solution works for many people it may not be stable in the long run, since MySQL doesn\'t guarantee that GROUP BY statement will return meaningful values for columns not in GROUP BY list. So use this solution at your own riskI like to use a NOT EXIST-based solution for this problem:A third solution I hardly ever see mentioned is MySQL specific and looks like this:Yes it looks awful (converting to string and back etc.) but in my experience it\'s usually faster than the other solutions. Maybe that just for my use cases, but I have used it on tables with millions of records and many unique ids. Maybe it\'s because MySQL is pretty bad at optimizing the other solutions (at least in the 5.0 days when I came up with this solution).One important thing is that GROUP_CONCAT has a maximum length for the string it can build up. You probably want to raise this limit by setting the group_concat_max_len variable. And keep in mind that this will be a limit on scaling if you have a large number of rows.Anyway, the above doesn\'t directly work if your content field is already text. In that case you probably want to use a different separator, like \\0 maybe. You\'ll also run into the group_concat_max_len limit quicker.How about this:I would use this:Subquery SELECT is not too eficient maybe, but in JOIN clause seems to be usable. I\'m not an expert in optimizing queries, but I\'ve tried at MySQL, PostgreSQL, FireBird and it does work very good.You can use this schema in multiple joins and with WHERE clause. It is my working example (solving identical to yours problem with table "firmy"):It is asked on tables having teens thusands of records, and it takes less then 0,01 second on really not too strong machine.I wouldn\'t use IN clause (as it is mentioned somewhere above). IN is given to use with short lists of constans, and not as to be the query filter built on subquery. It is because subquery in IN is performed for every scanned record which can made query taking very loooong time.If you have many fields in select statement and you want latest  value for all of those fields through optimized code:Many, if not all, of the other answers here are find for small datasets.  For scaling, more care is needed.  See here.It discusses multiple faster ways to do groupwise max and top-N per group.This solution makes only one selection from YourTable, therefore it\'s faster. It works only for MySQL and SQLite(for SQLite remove DESC) according to test on sqlfiddle.com. Maybe it can be tweaked to work on other languages which I am not familiar with.NOT mySQL, but for other people finding this question and using SQL, another way to resolve the greatest-n-per-group problem is using Cross Apply in MS SQLHere is a nice way of doing thatUse following code :I like to do this by ranking the records by some column. In this case, rank rev values grouped by id. Those with higher rev will have lower rankings. So highest rev will have ranking of 1.Not sure if introducing variables makes the whole thing slower. But at least I\'m not querying YOURTABLE twice.If anyone is looking for a Linq verson, this seems to work for me:here is another solution hope it will help someone    None of these answers have worked for me.This is what worked for me.SELECT *\nFROM Employee\nwhere Employee.Salary in (select max(salary) from Employee group by Employe_id)\nORDER BY Employee.SalarySorted the rev field in reverse order and then grouped by id which gave the first row of each grouping which is the one with the highest rev value.Tested in http://sqlfiddle.com/ with the following dataThis gave the following result in MySql 5.5 and 5.6 This works for me in sqlite3:With *, you get a duplicate rev column, but that\'s not much of a problem.