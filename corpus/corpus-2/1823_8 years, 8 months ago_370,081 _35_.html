I have a long-running Python server and would like to be able to upgrade a service without restarting the server. What\'s the best way do do this?You can reload a module when it has already been imported by using the reload builtin function in Python 2:In Python 3, reload was moved to the imp module. In 3.4, imp was deprecated in favor of importlib, and reload was added to the latter. When targeting 3 or later, either reference the appropriate module when calling reload or import it.I think that this is what you want. Web servers like Django\'s development server use this so that you can see the effects of your code changes without restarting the server process itself.To quote from the docs:Python modules\xe2\x80\x99 code is recompiled and\n  the module-level code reexecuted,\n  defining a new set of objects which\n  are bound to names in the module\xe2\x80\x99s\n  dictionary. The init function of\n  extension modules is not called a\n  second time. As with all other objects\n  in Python the old objects are only\n  reclaimed after their reference counts\n  drop to zero. The names in the module\n  namespace are updated to point to any\n  new or changed objects. Other\n  references to the old objects (such as\n  names external to the module) are not\n  rebound to refer to the new objects\n  and must be updated in each namespace\n  where they occur if that is desired.As you noted in your question, you\'ll have to reconstruct Foo objects if the Foo class resides in the foo module.In Python 3.0\xe2\x80\x933.3 you would use: imp.reload(module)The BDFL has answered this question.However, imp was deprecated in 3.4, in favour of importlib (thanks @Stefan!).I think, therefore, you\xe2\x80\x99d now use importlib.reload(module), although I\xe2\x80\x99m not sure.It can be especially difficult to delete a module if it is not pure Python.Here is some information from: How do I really delete an imported module?You can use sys.getrefcount() to find out the actual number of\n  references.Numbers greater than 3 indicate that\n  it will be hard to get rid of the\n  module. The homegrown "empty"\n  (containing nothing) module should be\n  garbage collected afteras the third reference is an artifact\n  of the getrefcount() function.reload(module), but only if it\'s completely stand-alone. If anything else has a reference to the module (or any object belonging to the module), then you\'ll get subtle and curious errors caused by the old code hanging around longer than you expected, and things like isinstance not working across different versions of the same code.If you have one-way dependencies, you must also reload all modules that depend on the the reloaded module to get rid of all the references to the old code. And then reload modules that depend on the reloaded modules, recursively.If you have circular dependencies, which is very common for example when you are dealing with reloading a package, you must unload all the modules in the group in one go. You can\'t do this with reload() because it will re-import each module before its dependencies have been refreshed, allowing old references to creep into new modules.The only way to do it in this case is to hack sys.modules, which is kind of unsupported. You\'d have to go through and delete each sys.modules entry you wanted to be reloaded on next import, and also delete entries whose values are None to deal with an implementation issue to do with caching failed relative imports. It\'s not terribly nice but as long as you have a fully self-contained set of dependencies that doesn\'t leave references outside its codebase, it\'s workable.It\'s probably best to restart the server. :-)For Python 2 use built-in function reload():For Python 2 and 3.2\xe2\x80\x933.3 use reload from module imp:But imp is  deprecated since version 3.4 in favor of importlib, so use:The following code allows you Python 2/3 compatibility:The you can use it as reload() in both versions which makes things simpler.The accepted answer doesn\'t handle the from X import Y case. This code handles it and the standard import case as well:In the reloading case, we reassign the top level names to the values stored in the newly reloaded module, which updates them.For those like me who want to unload all modules (when running in the Python interpreter under Emacs):More information is in Reloading Python modules.Enthought Traits has a module that works fairly well for this. https://traits.readthedocs.org/en/4.3.0/_modules/traits/util/refresh.htmlIt will reload any module that has been changed, and update other modules and instanced objects that are using it. It does not work most of the time with __very_private__ methods, and can choke on class inheritance, but it saves me crazy amounts of time from having to restart the host application when writing PyQt guis, or stuff that runs inside programs such as Maya or Nuke. It doesn\'t work maybe 20-30 % of the time, but it\'s still incredibly helpful.Enthought\'s package doesn\'t reload files the moment they change - you have to call it explicitely - but that shouldn\'t be all that hard to implement if you really need itfor me for case of Abaqus it is the way it works.\nImagine your file is Class_VerticesEdges.pyAnother way could be to import the module in a function. This way when the function completes the module gets garbage collected. 