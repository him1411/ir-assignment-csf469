Is there any reason for a class declaration to inherit from object?I just found some code that does this and I can\'t find a good reason why.Yes, this is a \'new style\' object. It was a feature introduced in python2.2.New style objects have a different object model to classic objects, and some things won\'t work properly with old style objects, for instance, super(), @property and descriptors. See this article for a good description of what a new style class is:http://docs.python.org/release/2.2.3/whatsnew/sect-rellinks.htmlSO link for a description of the differences: What is the difference between old style and new style classes in Python?Python 3.x:\nclass MyClass(object): = new-style class\nclass MyClass: = new-style class (implicitly inherits from object)Python 2.x:\nclass MyClass(object): = new-style class\nclass MyClass: = OLD-STYLE CLASSWhen defining base classes in Python 3.x, you\xe2\x80\x99re allowed to drop the object from the definition. However, this can open the door for a seriously hard to track problem\xe2\x80\xa6Python introduced new-style classes back in Python 2.2, and by now old-style classes are really quite old. Discussion of old-style classes is buried in the 2.x docs, and non-existent in the 3.x docs.The problem is, the syntax for old-style classes in Python 2.x is the same as the alternative syntax for new-style classes in Python 3.x. Python 2.x is still very widely used (e.g. GAE, Web2Py), and any code (or coder) unwittingly bringing 3.x-style class definitions into 2.x code is going to end up with some seriously outdated base objects. And because old-style classes aren\xe2\x80\x99t on anyone\xe2\x80\x99s radar, they likely won\xe2\x80\x99t know what hit them.So just spell it out the long way and save some 2.x developer the tears.History from Learn Python the Hard Way:Python\'s original rendition of a class was broken in many serious\n  ways. By the time this fault was recognized it was already too late,\n  and they had to support it. In order to fix the problem, they needed\n  some "new class" style so that the "old classes" would keep working\n  but you can use the new more correct version.They decided that they would use a word "object", lowercased, to be\n  the "class" that you inherit from to make a class. It is confusing,\n  but a class inherits from the class named "object" to make a class but\n  it\'s not an object really its a class, but don\'t forget to inherit\n  from object.Also just to let you know guys what is the difference between new-style classes and old-style classes is that new-style classes always inherit from either object class or from any other class.Another example is:While an old-style base class looks like this:And an old-style child class looks like this:You can see that an Old Style base class doesn\'t inherit from any other class, however, Old Style classes can, of course, inherit from one another. Inheriting from object guarantees that certain functionality is available in every Python class. New style classes were introduced in Python 2.2 Yes, it\'s historical. Without its old-style classes.If you use type() on an old-style object, you just get "instance". On a new-style object you get its classIn Python 3, apart from compatibility between Python 2 and 3, no. In Python 2, yes. In Python 2.x (from 2.2 onward) there\'s two styles of classes depending on the presence or absence of a built-in type as a base-class:"classic" style classes: they have no built-in type as a base class:"new" style classes: they have a built-in type as a base class meaning that, directly or indirectly, they have object as a base class:Without a doubt, when writing a class you\'ll always want to go for new-style classes. The perks of doing so are numerous, to list some of them:One of the downsides of new-style classes is that the class itself is more memory demanding. Unless you\'re creating many class objects, though, I doubt this would be an issue and it\'s a negative sinking in a sea of positives.In Python 3, things are simplified. Only new-style classes exist (referred to plainly as classes) so, the only difference in adding object is requiring you to type in 8 more characters. This:is completely equivalent (apart from their name :-) to this:and to this:all have object in their __bases__.In Python 2: always inherit from object explicitly. Get the perks.In Python 3: only inherit from object if you are writing code that tries to be Python agnostic, that is, it needs to work both in Python 2 and in Python 3. Otherwise don\'t, it really makes no difference.The syntax of the class creation statement:In the absence of any other superclasses that you specifically want to inherit from, the superclass should always be object, which is the root of all classes in Python.object is technically the root of "new-style" classes in Python. But the new-style classes today are as good as being the only style of classes.But, if you don\'t explicitly use the word object when creating classes, then as others mentioned, Python 3.x implicitly inherits from the object superclass. But I guess explicit is always better than implicit (hell)ReferenceThis creates a new-style class.