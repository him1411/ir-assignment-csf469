How do I setup a class that represents an interface?  Is this just an abstract base class?To expand on the answer by bradtgmurray,  you may want to make one exception to the pure virtual method list of your interface by adding a virtual destructor. This allows you to pass pointer ownership to another party without exposing the concrete derived class. The destructor doesn\'t have to do anything, because the interface doesn\'t have any concrete members. It might seem contradictory to define a function as both virtual and inline, but trust me - it isn\'t.You don\'t have to include a body for the virtual destructor - it turns out some compilers have trouble optimizing an empty destructor and you\'re better off using the default. Make a class with pure virtual methods. Use the interface by creating another class that overrides those virtual methods.A pure virtual method is a class method that is defined as virtual and assigned to 0.The whole reason you have a special Interface type-category in addition to abstract base classes in C#/Java is because C#/Java do not support multiple inheritance.  C++ supports multiple inheritance, and so a special type isn\'t needed.  An abstract base class with no non-abstract (pure virtual) methods is functionally equivalent to a C#/Java interface.As far I could test, it is very important to add the virtual destructor. I\'m using objects created with new and destroyed with delete.If you do not add the virtual destructor in the interface, then the destructor of the inherited class is not called.If you run the previous code without virtual ~IBase() {};, you will see that the destructor Tester::~Tester() is never called.There is no concept of "interface" per se in C++.  AFAIK, interfaces were first introduced in Java to work around the lack of multiple inheritance.  This concept has turned out to be quite useful, and the same effect can be achieved in C++ by using an abstract base class.An abstract base class is a class in which at least one member function (method in Java lingo) is a pure virtual function declared using the following syntax:An abstract base class cannot be instantiated, i. e. you cannot declare an object of class A. You can only derive classes from A, but any derived class that does not provide an implementation of foo() will also be abstract.  In order to stop being abstract, a derived class must provide implementations for all pure virtual functions it inherits.Note that an abstract base class can be more than an interface, because it can contain data members and member functions that are not pure virtual. An equivalent of an interface would be an abstract base class without any data with only pure virtual functions.And, as Mark Ransom pointed out, an abstract base class should provide a virtual destructor, just like any base class, for that matter.My answer is basically the same as the others but I think there are two other important things to do:Declare a virtual destructor in your interface or make a protected non-virtual one to avoid undefined behaviours if someone tries to delete an object of type IDemo.Use virtual inheritance to avoid problems whith multiple inheritance. (There is more often multiple inheritance when we use interfaces.) And like other answers:Use the interface by creating another class that overrides those virtual methods.OrAnd   All good answers above.\nOne extra thing you should keep in mind - you can also have a pure virtual destructor.  The only difference is that you still need to implement it.  Confused?  The main reason you\'d want to do this is if you want to provide interface methods, as I have, but make overriding them optional.  To make the class an interface class requires a pure virtual method, but all of your virtual methods have default implementations, so the only method left to make pure virtual is the destructor.Reimplementing a destructor in the derived class is no big deal at all - I always reimplement a destructor, virtual or not, in my derived classes.In C++11 you can easily avoid inheritance altogether:In this case, an Interface has reference semantics, i.e. you have to make sure that the object outlives the interface (it is also possible to make interfaces with value semantics). These type of interfaces have their pros and cons: Finally, inheritance is the root of all evil in complex software design. In Sean Parent\'s Value Semantics and Concepts-based Polymorphism (highly recommended, better versions of this technique are explained there) the following case is studied:Say I have an application in which I deal with my shapes polymorphically using the MyShape interface:In your application, you do the same with different shapes using the YourShape interface:Now say you want to use some of the shapes that I\'ve developed in your application. Conceptually, our shapes have the same interface, but to make my shapes work in your application you would need to extend my shapes as follows:First, modifying my shapes might not be possible at all. Furthermore, multiple inheritance leads the road to spaghetti code (imagine a third project comes in that is using the TheirShape interface... what happens if they also call their draw function my_draw ?).Update: There are a couple of new references about non-inheritance based polymorphism:If you\'re using Microsoft\'s C++ compiler, then you could do the following:I like this approach because it results in a lot smaller interface code and the generated code size can be significantly smaller. The use of novtable removes all reference to the vtable pointer in that class, so you can never instantiate it directly. See the documentation here - novtable.A little addition to what\'s written up there:First, make sure your destructor is also pure virtual Second, you may want to inherit virtually (rather than normally) when you do implement, just for good measures. You can also consider contract classes implemented with the NVI (Non Virtual Interface Pattern). For instance:I\'m still new in C++ development. I started with Visual Studio (VS). Yet, no one seems to mentioned the __interface in VS (.NET). I am not very sure if this is a good way to declare an interface. But it seems to provide an additional enforcement (mentioned in the documents). Such that you don\'t have to explicitly specify the virtual TYPE Method() = 0;, since it will be automatically converted. However, I don\'t use it because I am concern about the cross platform compilation compatibility, since it only available under .NET.If anyone do have anything interesting about it, please share. :-)Thanks.Result:\nRectangle area: 35\nTriangle area: 17We have seen how an abstract class defined an interface in terms of getArea() and two other classes implemented same function but with different algorithm to calculate the area specific to the shape.While it\'s true that virtual is the de-facto standard to define an interface, let\'s not forget about the classic C-like pattern, which comes with a constructor in C++:This has the advantage that you can re-bind events runtime without having to construct your class again (as C++ does not have a syntax for changing polymorphic types, this is a workaround for chameleon classes).Tips: