I\'ve been looking into some of the new features of C++11 and one I\'ve noticed is the double ampersand in declaring variables, like T&& var.For a start, what is this beast called? I wish Google would allow us to search for punctuation like this.What exactly does it mean?At first glance, it appears to be a double reference (like the C-style double pointers T** var), but I\'m having a hard time thinking of a use case for that.It declares an rvalue reference (standards proposal doc).Here\'s an introduction to rvalue references.  Here\'s a fantastic in-depth look at rvalue references by one of Microsoft\'s standard library developers. (But see the Caution in the comments following this answer before reading this article.)The biggest difference between a C++03 reference (now called an lvalue reference in C++11) is that it can bind to an rvalue like a temporary without having to be const.  Thus, this syntax is now legal:rvalue references primarily provide for the following:Move semantics.  A move constructor and move assignment operator can now be defined that takes an rvalue reference instead of the usual const-lvalue reference.  A move functions like a copy, except it is not obliged to keep the source unchanged; in fact, it usually modifies the source such that it no longer owns the moved resources.  This is great for eliminating extraneous copies, especially in standard library implementations.For example, a copy constructor might look like this:If this constructor was passed a temporary, the copy would be unnecessary because we know the temporary will just be destroyed; why not make use of the resources the temporary already allocated?  In C++03, there\'s no way to prevent the copy as we cannot determine we were passed a temporary.  In C++11, we can overload a move constructor:Notice the big difference here: the move constructor actually modifies its argument.  This would effectively "move" the temporary into the object being constructed, thereby eliminating the unnecessary copy.The move constructor would be used for temporaries and for non-const lvalue references that are explicitly converted to rvalue references using the std::move function (it just performs the conversion).  The following code both invoke the move constructor for f1 and f2:Perfect forwarding.  rvalue references allow us to properly forward arguments for templated functions.  Take for example this factory function:If we called factory<foo>(5), the argument will be deduced to be int&, which will not bind to a literal 5, even if foo\'s constructor takes an int.  Well, we could instead use A1 const&, but what if foo takes the constructor argument by non-const reference?  To make a truly generic factory function, we would have to overload factory on A1& and on A1 const&.  That might be fine if factory takes 1 parameter type, but each additional parameter type would multiply the necessary overload set by 2.  That\'s very quickly unmaintainable.rvalue references fix this problem by allowing the standard library to define a std::forward function that can properly forward lvalue/rvalue references.  For more information about how std::forward works, see this excellent answer.This enables us to define the factory function like this:Now the argument\'s rvalue/lvalue-ness is preserved when passed to T\'s constructor.  That means that if factory is called with an rvalue, T\'s constructor is called with an rvalue.  If factory is called with an lvalue, T\'s constructor is called with an lvalue.  The improved factory function works because of one special rule:When the function parameter type is of\n  the form T&& where T is a template\n  parameter, and the function argument\n  is an lvalue of type A, the type A& is\n  used for template argument deduction.Thus, we can use factory like so:Important rvalue reference properties:It denotes an rvalue reference. Rvalue references will only bind to temporary objects, unless explicitly generated otherwise. They are used to make objects much more efficient under certain circumstances, and to provide a facility known as perfect forwarding, which greatly simplifies template code.In C++03, you can\'t distinguish between a copy of a non-mutable lvalue and an rvalue.In C++0x, this is not the case.Consider the implementation behind these constructors. In the first case, the string has to perform a copy to retain value semantics, which involves a new heap allocation. However, in the second case, we know in advance that the object which was passed in to our constructor is immediately due for destruction, and it doesn\'t have to remain untouched. We can effectively just swap the internal pointers and not perform any copying at all in this scenario, which is substantially more efficient. Move semantics benefit any class which has expensive or prohibited copying of internally referenced resources. Consider the case of std::unique_ptr- now that our class can distinguish between temporaries and non-temporaries, we can make the move semantics work correctly so that the unique_ptr cannot be copied but can be moved, which means that std::unique_ptr can be legally stored in Standard containers, sorted, etc, whereas C++03\'s std::auto_ptr cannot.Now we consider the other use of rvalue references- perfect forwarding. Consider the question of binding a reference to a reference.Can\'t recall what C++03 says about this, but in C++0x, the resultant type when dealing with rvalue references is critical. An rvalue reference to a type T, where T is a reference type, becomes a reference of type T.Consider the simplest template function- min and max. In C++03 you have to overload for all four combinations of const and non-const manually. In C++0x it\'s just one overload. Combined with variadic templates, this enables perfect forwarding.I left off the return type deduction, because I can\'t recall how it\'s done offhand, but that min can accept any combination of lvalues, rvalues, const lvalues.The term for T&& when used with type deduction (such as for perfect forwarding) is known colloquially as a universal reference.  This was coined by Scott Meyers in this article.That is because it may be either r-value or l-value.Examples are:Note that the standard itself has no notion of this, it is simply a way to discuss the (odd?) combination of reference collapsing rules, reference type deduction, and the && syntax.More discussion can be found in the answer for: Syntax for universal referencesAn rvalue reference is a type that behaves much like the ordinary reference X&, with several exceptions. The most important one is that when it comes to function overload resolution, lvalues prefer old-style lvalue references, whereas rvalues prefer the new rvalue references:So what is an rvalue? Anything that is not an lvalue. An lvalue being \nan expression that refers to a memory location and allows us to take the address of that memory location via the & operator. It is almost easier to understand first what rvalues accomplish with an example: The constructor and assignment operators have been overloaded with versions that take rvalue references. Rvalue references allow a function to branch at compile time (via overload resolution) on the condition "Am I being called on an lvalue or an rvalue?". This allowed us to create more efficient constructor and assignment operators above that move resources rather copy them. The compiler automatically branches at compile time (depending on the whether it is being invoked for an lvalue or an rvalue) choosing whether the move constructor or move assignment operator should be called.Summing up: rvalue references allow move semantics (and perfect forwarding, discussed in the article link below). One practical easy-to-understand example is the class template std::unique_ptr. Since a unique_ptr maintains exclusive ownership of its underlying raw pointer, unique_ptr\'s can\'t be copied. That would violate their invariant of exclusive ownership. So they do not have copy constructors. But they do have move constructors:static_cast<unique_ptr<int[]>&&>(ptr) is usually done using std::moveAn excellent article explaining all this and more (like how rvalues allow perfect forwarding and what that means) with lots of good examples is Thomas Becker\'s C++ Rvalue References Explained. This post relied heavily on his article. A shorter introduction is A Brief Introduction to Rvalue References by Stroutrup, et. al