Is there a way to find out the call stack at all?You can find the entire stack trace using browser specific code. The good thing is someone already made it; here is the project code on GitHub.But not all the news is good:It is really slow to get the stack trace so be careful (read this for more).You will need to define function names for the stack trace to be legible. Because if you have code like this:Google Chrome will alert ... kls.Hello ( ... but most browsers will expect a function name just after the keyword function and will treat it as an anonymous function. An not even Chrome will be able to use the Klass name if you don\'t give the name kls to the function.And by the way, you can pass to the function printStackTrace the option {guess: true} but I didn\'t find any real improvement by doing that.Not all browsers give you the same information. That is, parameters, code column, etc.By the way, if you only want the name of the caller function (in most browsers, but not IE) you can use:But note that this name will be the one after the function keyword.  I found no way (even on Google Chrome) to get more than that without getting the code of the whole function.And summarizing the rest of the best answers (by Pablo Cabrera, nourdine, and Greg Hewgill). The only cross-browser and really safe thing you can use is:Which will show the code of the caller function. Sadly, that is not enough for me, and that is why I give you tips for the StackTrace and the caller function Name (although they are not cross-browser).To recap (and make it clearer) ...this code: is equivalent to this: Clearly the first bit is more portable, since you can change the name of the function, say from "Hello" to "Ciao", and still get the whole thing to work.In the latter, in case you decide to refactor the name of the invoked function (Hello), you would have to change all its occurrences :( You can get the full stacktrace:Until caller is null.Note: it cause an infinite loop on recursive functions.I know you mentioned "in Javascript", but if the purpose is debugging, I think it\'s easier to just use your browser\'s developer tools. This is how it looks in Chrome:\n\nJust drop the debugger where you want to investigate the stack.You can use Function.Caller to get the calling function. The old method  using argument.caller is considered obsolete.The following code illustrates its use:Notes about obsolete argument.caller:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callerBe aware Function.caller is non-standard: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/callerI usually use (new Error()).stack in Chrome. \nThe nice thing is that this also gives you the line numbers where the caller called the function. The downside is that it limits the length of the stack to 10, which is why I came to this page in the first place.(I\'m using this to collect callstacks in a low-level constructor during execution, to view and debug later, so setting a breakpoint isn\'t of use since it will be hit thousands of times)It\'s safer to use *arguments.callee.caller since arguments.caller is deprecated...Looks like this is quite a solved question but I recently found out that callee is not allowed in \'strict mode\' so for my own use I wrote a class that will get the path from where it is called. It\'s part of a small helper lib and if you want to use the code standalone change the offset used to return the stack trace of the caller (use 1 instead of 2)Try accessing this:If yuo are not going to run it in IE < 11 then console.trace() would suit.If you just want the function name and not the code, and want a browser-independent solution, use the following:Note that the above will return an error if there is no caller function as there is no [1] element in the array. To work around, use the below:I wanted to add my fiddle here for this:http://jsfiddle.net/bladnman/EhUm3/I tested this is chrome, safari and IE (10 and 8). Works fine. There is only 1 function that matters, so if you get scared by the big fiddle, read below.Note:\nThere is a fair amount of my own "boilerplate" in this fiddle. You can remove all of that and use split\'s if you like. It\'s just an ultra-safe" set of functions I\'ve come to rely on.There is also a "JSFiddle" template in there that I use for many fiddles to simply quick fiddling.Just want to let you know that on PhoneGap/Android the name doesnt seem to be working. But arguments.callee.caller.toString() will do the trick.Here, everything but the functionname is stripped from caller.toString(), with RegExp.here is a function to get full stacktrace:Try the following code:Worked for me in Firefox-21 and Chromium-25.As far as I know, we have 2 way for this from given sources like this-arguments.callerFunction.callerThink u have your answer :).I\'m attempting to address both the question and the current bounty with this question.The bounty requires that the caller be obtained in strict mode, and the only way I can see this done is by referring to a function declared outside of strict mode.For example, the following is non-standard but has been tested with current (29/03/2016) versions of Chrome, Edge and Firefox:Why all of the solutions above look like a rocket science. Meanwhile, it should not be more complicated than this snippet. All credits to this guy How do you find out the caller function in JavaScript?If you really need the functionality for some reason and want it to be cross-browser compatible and not worry for strict stuff and be forward compatible then pass a this reference:Another way around this problem is to simply pass the name of the calling function as a parameter. For example:Now, you could call the function like this:My example uses a hard coded check of the function name, but you could easily use a switch statement or some other logic to do what you want there.I think the following code piece may be helpful:Execute the code:The log looks like this:heystewart\'s answer and JiarongWu\'s answer both mentioned that the Error object has access to the stack.Here\'s an example:Different browsers shows the stack in different string formats:\nSafari  : Caller is: main@https://stacksnippets.net/js:14:8\nFirefox : Caller is: main@https://stacksnippets.net/js:14:3\nChrome  : Caller is:     at main (https://stacksnippets.net/js:14:3)\nIE Edge : Caller is:    at main (https://stacksnippets.net/js:14:3)\nIE      : Caller is:    at main (https://stacksnippets.net/js:14:3)\nMost browsers will set the stack with var stack = (new Error()).stack. In Internet Explorer the stack will be undefined - you have to throw a real exception to retrieve the stack.Conclusion: It\'s possible to determine "main" is the caller to "Hello" using the  stack in the Error object. In fact it will work in cases where the callee / caller approach doesn\'t work. It will also show you context, i.e. source file and line number. However effort is required to make the solution cross platform.