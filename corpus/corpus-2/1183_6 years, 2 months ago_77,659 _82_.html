I stumbled upon Stack Overflow question Memory leak with std::string when using std::list<std::string>, and one of the comments says this:Stop using new so much. I can\'t see any reason you used new anywhere\n  you did. You can create objects by value in C++ and it\'s one of the\n  huge advantages to using the language. You do not have to allocate\n  everything on the stack*. Stop thinking like a Java programmer.I\'m not really sure what he means by that. Why should objects be created by value in C++ as often as possible, and what difference does it make internally? Did I misinterpret the answer?* The comment originally said "stack", this has since been corrected by a moderator to the intended "heap".There are two widely-used memory allocation techniques: automatic allocation and dynamic allocation.  Commonly, there is a corresponding region of memory for each: the stack and the heap.The stack always allocates memory in a sequential fashion.  It can do so because it requires you to release the memory in the reverse order (First-In, Last-Out: FILO).  This is the memory allocation technique for local variables in many programming languages.  It is very, very fast because it requires minimal bookkeeping and the next address to allocate is implicit.In C++, this is called automatic storage because the storage is claimed automatically at the end of scope.  As soon as execution of current code block (delimited using {}) is completed, memory for all variables in that block is automatically collected.  This is also the moment where destructors are invoked to clean up resources.The heap allows for a more flexible memory allocation mode.  Bookkeeping is more complex and allocation is slower.  Because there is no implicit release point, you must release the memory manually, using delete or delete[] (free in C).  However, the absence of an implicit release point is the key to the heap\'s flexibility.Even if using the heap is slower and potentially leads to memory leaks or memory fragmentation, there are perfectly good use cases for dynamic allocation, as it\'s less limited.Two key reasons to use dynamic allocation:You don\'t know how much memory you need at compile time.  For instance, when reading a text file into a string, you usually don\'t know what size the file has, so you can\'t decide how much memory to allocate until you run the program.You want to allocate memory which will persist after leaving the current block.  For instance, you may want to write a function string readfile(string path) that returns the contents of a file.  In this case, even if the stack could hold the entire file contents, you could not return from a function and keep the allocated memory block.In C++ there\'s a neat construct called a destructor.  This mechanism allows you to manage resources by aligning the lifetime of the resource with the lifetime of a variable. This technique is called RAII and is the distinguishing point of C++. It "wraps" resources into objects.  std::string is a perfect example.  This snippet:actually allocates a variable amount of memory.  The std::string object allocates memory using the heap and releases it in its destructor.  In this case, you did not need to manually manage any resources and still got the benefits of dynamic memory allocation.In particular, it implies that in this snippet:there is unneeded dynamic memory allocation.  The program requires more typing (!) and introduces the risk of forgetting to deallocate the memory.  It does this with no apparent benefit.Basically, the last paragraph sums it up.  Using automatic storage as often as possible makes your programs:In the referenced question, there are additional concerns.  In particular, the following class:Is actually a lot more risky to use than the following one:The reason is that std::string properly defines a copy constructor.  Consider the following program:Using the original version, this program will likely crash, as it uses delete on the same string twice.  Using the modified version, each Line instance will own its own string instance, each with its own memory and both will be released at the end of the program.Extensive use of RAII is considered a best practice in C++ because of all the reasons above.  However, there is an additional benefit which is not immediately obvious.  Basically, it\'s better than the sum of its parts.  The whole mechanism composes.  It scales.If you use the Line class as a building block:Thenallocates four std::string instances, four Line instances, one Table instance and all the string\'s contents and everything is freed automagically.In C++, it takes but a single instruction to allocate space -- on the stack -- for every local scope object in a given function, and it\'s impossible to leak any of that memory. That comment intended (or should have intended) to say something like "use the stack and not the heap".It\'s complicated.First, C++ is not garbage collected. Therefore, for every new, there must be a corresponding delete. If you fail to put this delete in, then you have a memory leak. Now, for a simple case like this:This is simple. But what happens if "Do stuff" throws an exception? Oops: memory leak. What happens if "Do stuff" issues return early? Oops: memory leak.And this is for the simplest case. If you happen to return that string to someone, now they have to delete it. And if they pass it as an argument, does the person receiving it need to delete it? When should they delete it?Or, you can just do this:No delete. The object was created on the "stack", and it will be destroyed once it goes out of scope. You can even return the object, thus transfering its contents to the calling function. You can pass the object to functions (typically as a reference or const-reference: void SomeFunc(std::string &iCanModifyThis, const std::string &iCantModifyThis). And so forth.All without new and delete. There\'s no question of who owns the memory or who\'s responsible for deleting it. If you do:It is understood that otherString has a copy of the data of someString. It isn\'t a pointer; it is a separate object. They may happen to have the same contents, but you can change one without affecting the other:See the idea?Objects created by new must be eventually deleted lest they leak. The destructor won\'t be called, memory won\'t be freed, the whole bit. Since C++ has no garbage collection, it\'s a problem.Objects created by value (i. e. on stack) automatically die when they go out of scope. The destructor call is inserted by the compiler, and the memory is auto-freed upon function return.Smart pointers like auto_ptr, shared_ptr solve the dangling reference problem, but they require coding discipline and have other issues (copyability, reference loops, etc.).Also, in heavily multithreaded scenarios, new is a point of contention between threads; there can be a performance impact for overusing new. Stack object creation is by definition thread-local, since each thread has its own stack.The downside of value objects is that they die once the host function returns - you cannot pass a reference to those back to the caller, only by copying or returning by value.To a great extent, that\'s someone elevating their own weaknesses to a general rule.  There\'s nothing wrong per se with creating objects using the new operator.  What there is some argument for is that you have to do so with some discipline: if you create an object you need to make sure it\'s going to be destroyed.The easiest way of doing that is to create the object in automatic storage, so C++ knows to destroy it when it goes out of scope:Now, observe that when you fall off that block after the end-brace, foo is out of scope.  C++ will call its dtor automatically for you.  Unlike Java, you don\'t need to wait for the GC to find it.  Had you writtenyou would want to match it explicitly withor even better, allocate your File * as a "smart pointer".  If you aren\'t careful about that it can lead to leaks.The answer itself makes the mistaken assumption that if you don\'t use new you don\'t allocate on the heap; in fact, in C++ you don\'t know that.  At most, you know that a small amout of memory, say one pointer, is certainly allocated on the stack.  However, consider if the implementation of File is something likethen FileImpl will still be allocated on the stack.And yes, you\'d better be sure to havein the class as well; without it, you\'ll leak memory from the heap even if you didn\'t apparently allocate on the heap at all.I see that a few important reasons for doing as few new\'s as possible are missed:Calling new may or may not cause the OS to allocate a new physical page to your process this can be quite slow if you do it often. Or it may already have a suitable memory location ready, we don\'t know. If your program needs to have consistent and predictable execution time (like in a real-time system or game/physics simulation) you need to avoid new in your time critical loops.Yes you heard me, your OS needs to make sure your page tables are consistent and as such calling new will cause your thread to acquire an implicit mutex lock. If you are consistently calling new from many threads you are actually serialising your threads (I\'ve done this with 32 CPUs, each hitting on new to get a few hundred bytes each, ouch! that was a royal p.i.t.a. to debug)The rest such as slow, fragmentation, error prone, etc have already been mentioned by other answers.When you use new, objects are allocated to the heap. It is generally used when you anticipate expansion. When you declare an object such as,it is placed on the stack.You will always have to call destroy on the object that you placed on the heap with new. This opens the potential for memory leaks. Objects placed on the stack are not prone to memory leaking!new() shouldn\'t be used as little as possible. It should be used as carefully as possible. And it should be used as often as necessary as dictated by pragmatism.Allocation of objects on the stack, relying on their implicit destruction, is a simple model. If the required scope of an object fits that model then there\'s no need to use new(), with the associated delete() and checking of NULL pointers.\nIn the case where you have lots of short-lived objects allocation on the stack should reduce the problems of heap fragmentation.However, if the lifetime of your object needs to extend beyond the current scope then new() is the right answer. Just make sure that you pay attention to when and how you call delete() and the possibilities of NULL pointers, using deleted objects and all of the other gotchas that come with the use of pointers.Consider a "careful" user who remembers to wrap objects in smart pointers:This code is dangerous because there is no guarantee that either shared_ptr is constructed before either T1 or T2. Hence, if one of new T1() or new T2() fails after the other succeeds, then the first object will be leaked because no shared_ptr exists to destroy and deallocate it.SolutIon: use make_shared.I think the poster meant to say You do not have to allocate everything on theheap rather than the the stack.Basically objects are allocated on the stack (if the object size allows, of course) because of the cheap cost of stack-allocation, rather than heap-based allocation which involves quite some work by the allocator, and adds verbosity because then you have to manage data allocated on the heap.I tend to disagree with the idea of using new "too much". Though the original poster\'s use of new with system classes is a bit ridiculous. (int *i; i = new int[9999];? really? int i[9999]; is much clearer.) I think that is what was getting the commenter\'s goat.When you\'re working with system objects, it\'s very rare that you\'d need more than one reference to the exact same object. As long as the value is the same, that\'s all that matters. And system objects don\'t typically take up much space in memory. (one byte per character, in a string). And if they do, the libraries should be designed to take that memory management into account (if they\'re written well). In these cases, (all but one or two of the news in his code), new is practically pointless and only serves to introduce confusions and potential for bugs.When you\'re working with your own classes/objects, however (e.g. the original poster\'s Line class), then you have to begin thinking about the issues like memory footprint, persistence of data, etc. yourself. At this point, allowing multiple references to the same value is invaluable - it allows for constructs like linked lists, dictionaries, and graphs, where multiple variables need to not only have the same value, but reference the exact same object in memory. However, the Line class doesn\'t have any of those requirements. So the original poster\'s code actually has absolutely no needs for new.One notable reason to avoid overusing the heap is for performance -- specifically involving the performance of the default memory management mechanism used by C++. While allocation can be quite quick in the trivial case, doing a lot of new and delete on objects of non-uniform size without strict order leads not only to memory fragmentation, but it also complicates the allocation algorithm and can absolutely destroy performance in certain cases.That\'s the problem that memory pools where created to solve, allowing to to mitigate the inherent disadvantages of traditional heap implementations, while still allowing you to use the heap as necessary.Better still, though, to avoid the problem altogether. If you can put it on the stack, then do so.Two reasons:The core reason is that objects on heap are always difficult to use and manage than simple values. Writing code that are easy to read and maintain is always the first priority of any serious programmer.Another scenario is the library we are using provides value semantics and make dynamic allocation unnecessary. Std::string is a good example.For object oriented code however, using a pointer - which means use new to create it beforehand - is a must. In order to simplify the complexity of resource management, we have dozens of tools to make it as simple as possible, such as smart pointers. The object based paradigm or generic paradigm assumes value semantics and requires less or no new, just as  the posters elsewhere stated.Traditional design patterns, especially those mentioned in GoF book, use new a lot, as they are typical OO code.new is the new goto.Recall why goto is so reviled: while it is a powerful, low-level tool for flow control, people often used it in unnecessarily complicated ways that made code difficult to follow. Furthermore, the most useful and easiest to read patterns were encoded in structured programming statements (e.g. for or while); the ultimate effect is that the code where goto is the appropriate way to is rather rare, if you are tempted to write goto, you\'re probably doing things badly (unless you really know what you\'re doing).new is similar — it is often used to make things unnecessarily complicated ahd harder to read, and the most useful usage patterns can be encoded have been encoded into various classes. Furthermore, if you need to use any new usage patterns for which there aren\'t already standard classes, you can write your own classes that encode them!I would even argue that new is worse than goto, due to the need to pair new and delete statements.Like goto, if you ever think you need to use new, you are probably doing things badly — especially if you are doing so outside of the implementation of a class whose purpose in life is to encapsulate whatever dynamic allocations you need to do.new allocates objects on the heap.  Otherwise, objects are allocated on the stack.  Look up the difference between the two.