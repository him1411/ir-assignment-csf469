I\'m trying to work out an appropriate singleton model for usage in Swift. So far, I\'ve been able to get a non-thread safe model working as:Wrapping the singleton instance in the Static struct should allow a single instance that doesn\'t collide with singleton instances without complex naming schemings, and it should make things fairly private. Obviously though, this model isn\'t thread safe, so I tried to add dispatch_once to the whole thing:But I get a compiler error on the dispatch_once line:Cannot convert the expression\'s type \'Void\' to type \'()\'I\'ve tried several different variants of the syntax, but they all seem to have the same results:What is the proper usage of dispatch_once using Swift? I initially thought the problem was with the block due to the () in the error message, but the more I look at it, the more I think it may be a matter of getting the dispatch_once_t correctly defined.tl;dr: Use the class constant approach if you are using Swift 1.2 or above and the nested struct approach if you need to support earlier versions.From my experience with Swift there are three approaches to implement the Singleton pattern that support lazy initialization and thread safety.This approach supports lazy initialization because Swift lazily initializes class constants (and variables), and is thread safe by the definition of let. This is now officially recommended way to instantiate a singleton.Class constants were introduced in Swift 1.2. If you need to support an earlier version of Swift, use the nested struct approach below or a global constant.Here we are using the static constant of a nested struct as a class constant. This is a workaround for the lack of static class constants in Swift 1.1 and earlier, and still works as a workaround for the lack of static constants and variables in functions.The traditional Objective-C approach ported to Swift. I\'m fairly certain there\'s no advantage over the nested struct approach but I\'m putting it here anyway as I find the differences in syntax interesting.See this GitHub project for unit tests.Since Apple has now clarified that static struct variables are initialized both lazy and wrapped in dispatch_once (see the note at the end of the post), I think my final solution is going to be:This takes advantage of the automatic lazy, thread-safe initialization of static struct elements, safely hides the actual implementation from the consumer, keeps everything compactly compartmentalized for legibility, and eliminates a visible global variable.Apple has clarified that lazy initializer are thread-safe, so there\'s no need for dispatch_once or similar protectionsThe lazy initializer for a global variable (also for static members of structs and enums) is run the first time that global is accessed, and is launched as dispatch_once to make sure that the initialization is atomic. This enables a cool way to use dispatch_once in your code: just declare a global variable with an initializer and mark it private.From hereFor Swift 1.2 and beyond:With a proof of correctness (all credit goes here), there is little to no reason now to use any of the previous methods for singletons.Update: This is now the official way to define singletons as described in the official docs!As for concerns on using static vs class. static should be the one to use even when class variables become available. Singletons are not meant to be subclassed since that would result in multiple instances of the base singleton. Using static enforces this in a beautiful, Swifty way.For Swift 1.0 and 1.1:With the recent changes in Swift, mostly new access control methods, I am now leaning towards the cleaner way of using a global variable for singletons.As mentioned in the Swift blog article here:The lazy initializer for a global variable (also for static members of\n  structs and enums) is run the first time that global is accessed, and\n  is launched as dispatch_once to make sure that the initialization is\n  atomic. This enables a cool way to use dispatch_once in your code:\n  just declare a global variable with an initializer and mark it\n  private.This way of creating a singleton is thread safe, fast, lazy, and also bridged to ObjC for free.Swift 1.2 or later  now supports static variables/constants in classes. So you can just use a static constant:There is a better way to do it.  You can declare a global variable in your class above the class decleration like soThis just calls your default init or whichever init and global variables are dispatch_once by default in Swift. Then in whichever class you want to get a reference, you just do this:So basically you can get rid of the entire block of shared instance code.Swift singletons are exposed in the Cocoa frameworks as class functions, e.g. NSFileManager.defaultManager(), NSNotificationCenter.defaultCenter(), so I feel it makes more sense as a class function to mirror this behaviour, rather than a class variable as some other solutions use, e.g.Retrieve the singleton via MyClass.sharedInstance().Swift 4+Per the Apple documentation, it has been repeated many times that the easiest way to do this in Swift is with a static type property:However, if you\'re looking for a way to perform additional setup beyond a simple constructor call, the secret is to use an immediately invoked closure:This is guaranteed to be thread-safe and lazily initialized only once.Looking at Apple\'s sample code I came across this pattern. I\'m not sure how Swift deals with statics, but this would be thread safe in C#. I include both the property and method for Objective-C interop.If you are planning on using your Swift singleton class in Objective-C, this setup will have the compiler generate appropriate Objective-C-like header(s):Then in Objective-C class you can call your singleton the way you did it in pre-Swift days:This is just my simple implementation.First solutionLater in your code:Second solutionAnd later in your code you will be able to keep braces for less confusion:Use:How to use:In brief,You may want to read Files and InitializationThe lazy initializer for a global variable (also for static members of\n  structs and enums) is run the first time that global is accessed, and\n  is launched as dispatch_once to make sure that the initialization is\n  atomic.Then call it;I would suggest an Enum, like you would use in Java, e.g.:Just for reference, here is an example Singleton implementation of Jack Wu/hpique\'s Nested Struct implementation. The implementation also shows how archiving could work, as well as some accompanying functions. I couldn\'t find this complete of an example, so hopefully this helps somebody!And if you didn\'t recognize some of those functions, here is a little living Swift utility file I\'ve been using:I prefer this implementation:My way of implementation in Swift...ConfigurationManager.swiftAccess the globalDic from any screen of the application by the below.Read:Write:From Apple Docs (Swift 3.0.1),You can simply use a static type property, which is guaranteed to be\n  lazily initialized only once, even when accessed across multiple\n  threads simultaneously:If you need to perform additional setup beyond initialization, you can\n  assign the result of the invocation of a closure to the global\n  constant:After seeing David\'s implementation, it seems like there\'s no need to have a singleton class function instanceMethod since let is doing pretty much the same thing as a sharedInstance class method. All you need to do is declare it as a global constant and that would be it. The best approach in Swift above 1.2 is a one-line singleton, as - To know more detail about this approach you can visit this link.I just came across with this, but I required my singleton to allow inheritance, and none of these solutions actually allowed it.So I came up with this:The issue with this first dirty approach is that I cannot guarantee that subclasses would implement the dispatch_once_t and make sure that sharedInstanceVar is only modified once per class... I will try to refine this further, but it would be interesting to see if anyone has strong feelings against this (besides the fact that it is verbose and requires to manually update it).This is my implementation. It also prevents the programmer from creating a new instance: