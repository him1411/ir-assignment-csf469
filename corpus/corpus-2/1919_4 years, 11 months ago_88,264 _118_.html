A friend of mine and I are currently discussing what is a closure in JS and what isn\'t. We just want to make sure we really understand it correctly.Let\'s take this example. We have a counting loop and want to print the counter variable on the console delayed. Therefore we use setTimeout and closures to capture the value of the counter variable to make sure that it will not print N times the value N.The wrong solution without closures or anything near to closures would be:which will of course print 10 times the value of i after the loop, namely 10.So his attempt was:printing 0 to 9 as expected.I told him that he isn\'t using a closure to capture i, but he insists that he is. I proved that he doesn\'t use closures by putting the for loop body within another setTimeout (passing his anonymous function to setTimeout), printing 10 times 10 again. The same applies if I store his function in a var and execute it after the loop, also printing 10 times 10. So my argument is that he doesn\'t really capture the value of i, making his version not a closure.My attempt was:So I capture i (named i2 within the closure), but now I return another function and pass this around. In my case, the function passed to setTimeout really captures i.Now who is using closures and who isn\'t?Note that both solutions print 0 to 9 on the console delayed, so they solve the original problem, but we want to understand which of those two solutions uses closures to accomplish this.Editor\'s Note: All functions in JavaScript are closures as explained in this post. However we are only interested in identifying a subset of these functions which are interesting from a theoretical point of view. Henceforth any reference to the word closure will refer to this subset of functions unless otherwise stated.A simple explanation for closures:Now let\'s use this to figure out who uses closures and who doesn\'t (for the sake of explanation I have named the functions):Case 1: Your Friend\'s ProgramIn the above program there are two functions: f and g. Let\'s see if they are closures:For f:Thus the function f is not a closure.For g:Thus the function g is a closure for the free variable i2 (which is an upvalue for g) when it\'s referenced from within setTimeout.Bad for you: Your friend is using a closure. The inner function is a closure.Case 2: Your ProgramIn the above program there are two functions: f and g. Let\'s see if they are closures:For f:Thus the function f is not a closure.For g:Thus the function g is a closure for the free variable i2 (which is an upvalue for g) when it\'s referenced from within setTimeout.Good for you: You are using a closure. The inner function is a closure.So both you and your friend are using closures. Stop arguing. I hope I cleared the concept of closures and how to identify them for the both of you.Edit: A simple explanation as to why are all functions closures (credits @Peter):First let\'s consider the following program (it\'s the control):Next let\'s consider the following program (it\'s the alternative):What do we infer from this?According to the closure definition:A "closure" is an expression (typically a function) that can have free variables together with an environment that binds those variables (that "closes" the expression).You are using closure if you define a function which use a variable which is defined outside of the function. (we call the variable a free variable).\nThey all use closure(even in the 1st example).In a nutshell Javascript Closures allow a function to access a variable that is declared in a lexical-parent function.Let\'s see a more detailed explanation.\nTo understand closures it is important to understand how JavaScript scopes variables.ScopesIn JavaScript scopes are defined with functions.\nEvery function defines a new scope.Consider the following example;calling f prints Let\'s now consider the case we have a function g defined within another function f.We will call f the lexical parent of g.\nAs explained before we now have 2 scopes; the scope f and the scope g.But one scope is "within" the other scope, so is the scope of the child function part of the scope of the parent function? What happens with the variables declared in the scope of the parent function; will I be able to access them from the scope of the child function?\nThat\'s exactly where closures step in.ClosuresIn JavaScript the function g can not only access any variables declared in scope g but also access any variables declared in the scope of the parent function f.Consider following;calling f printsLet\'s look at the line console.log(foo);. At this point we are in scope g and we try to access the variable foo that is declared in scope f. But as stated before we can access any variable declared in a lexical parent function which is the case here; g is the lexical parent of f. Therefore hello is printed.\nLet\'s now look at the line console.log(bar);. At this point we are in scope f and we try to access the variable bar that is declared in scope g. bar is not declared in the current scope and the function g is not the parent of f, therefore bar is undefinedActually we can also access the variables declared in the scope of a lexical "grand parent" function. Therefore if there would be a function h defined within the function gthen h would be able to access all the variables declared in the scope of function h, g, and f. This is done with closures. In JavaScript closures allows us to access any variable declared in the lexical parent function, in the lexical grand parent function, in the lexical grand-grand parent function, etc. \nThis can be seen as a scope chain;  scope of current function -> scope of lexical parent function -> scope of lexical grand parent function -> ...  until the last parent function that has no lexical parent.The window objectActually the chain doesn\'t stop at the last parent function. There is one more special scope; the global scope. Every variable not declared in a function is considered to be declared in the global scope. The global scope has two specialities;Therefore there are exactly two ways of declaring a variable foo in the global scope; either by not declaring it in a function or by setting the property foo of the window object.Both attempts uses closuresNow that you have read a more detailed explanation it may now be apparent that both solutions uses closures.\nBut to be sure, let\'s make a proof.Let\'s create a new Programming Language; JavaScript-No-Closure.\nAs the name suggests, JavaScript-No-Closure is identical to JavaScript except it doesn\'t support Closures.In other words;Alright, let\'s see what happens with the first solution with JavaScript-No-Closure;therefore this will print undefined 10 times in JavaScript-No-Closure.Hence the first solution uses closure.Let\'s look at the second solution;therefore this will print undefined 10 times in JavaScript-No-Closure.Both solutions uses closures.Edit: It is assumed that these 3 code snippets are not defined in the global scope. Otherwise the variables foo and i would be bind to the window object and therefore accessible through the window object in both JavaScript and JavaScript-No-Closure.I\'ve never been happy with the way anybody explains this.The key to understanding closures is to understand what JS would be like without closures.Without closures, this would throw an errorOnce outerFunc has returned in an imaginary closure-disabled version of JavaScript, the reference to outerVar would be garbage collected and gone leaving nothing there for the inner func to reference.Closures are essentially the special rules that kick in and make it possible for those vars to exist when an inner function references an outer function\'s variables. With closures the vars referenced are maintained even after the outer function is done or \'closed\' if that helps you remember the point.Even with closures, the life cycle of local vars in a function with no inner funcs that reference its locals works the same as it would in a closure-less version. When the function is finished, the locals get garbage collected.Once you have a reference in an inner func to an outer var, however it\'s like a doorjamb gets put in the way of garbage collection for those referenced vars.A perhaps more accurate way to look at closures, is that the inner function basically uses the inner scope as its own scope foudnation.But the context referenced is in fact, persistent, not like a snapshot. Repeatedly firing a returned inner function that keeps incrementing and logging an outer function\'s local var will keep alerting higher values.You are both using closures.I \'m going with the Wikipedia definition here:In computer science, a closure (also lexical closure or function\n  closure) is a function or reference to a function together with a\n  referencing environment\xe2\x80\x94a table storing a reference to each of the\n  non-local variables (also called free variables) of that function.\n  A closure\xe2\x80\x94unlike a plain function pointer\xe2\x80\x94allows a function to access\n  those non-local variables even when invoked outside of its immediate\n  lexical scope.Your friend\'s attempt clearly uses the variable i, which is non-local, by taking its value and making a copy to store into the local i2.Your own attempt passes i (which at the call site is in scope) to an anonymous function as an argument. This is not a closure so far, but then that function returns another function that references the same i2. Since inside the inner anonymous function i2 is not a local, this creates a closure.You and your friend both use closures:A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time that the closure was created.MDN: https://developer.mozilla.org/en-US/docs/JavaScript/Guide/ClosuresIn your friend\'s code function function(){ console.log(i2); } defined inside closure of anonymous function function(){ var i2 = i; ... and can read/write local variable i2.In your code function function(){ console.log(i2); } defined inside closure of function function(i2){ return ... and can read/write local valuable i2 (declared in this case as a parameter).In both cases function function(){ console.log(i2); } then passed into setTimeout.Another equivalent (but with less memory utilization) is:ClosureA closure is not an function, and not an expression. It must be seen as a kind of \'snapshot\' from the used variables outside the functionscope and used inside the function. Grammatically, one should say: \'take the closure of the variables\'.Again, in other words: A closure is a copy of the relevant context of variables on which the function depends on.Once more (na\xc3\xaff): A closure is having access to variables who are not being passed as parameter.Bear in mind that these functional concepts strongly depends upon the programming language / environment you use. In JavaScript, the closure depends on lexical scoping (which is true in most c-languages). So, returning a function is mostly returning a anonymous / unnamed function. When the function access variables, not passed as parameter, and within its (lexical) scope, a closure has been taken.So, concerning your examples:All are using closures. Don\'t confuse the point of execution with closures. If the \'snapshot\' of the closures is taken at the wrong moment, the values may be unexpected but certainly a closure is taken!Let\'s look at both ways:Declares and immediately executes an anonymous function that runs setTimeout() within its own context. The current value of i is preserved by making a copy into i2 first; it works because of the immediate execution.Declares an execution context for the inner function whereby the current value of i is preserved into i2; this approach also uses immediate execution to preserve the value.ImportantIt should be mentioned that the run semantics are NOT the same between both approaches; your inner function gets passed to setTimeout() whereas his inner function calls setTimeout() itself.Wrapping both codes inside another setTimeout() doesn\'t prove that only the second approach uses closures, there\'s just not the same thing to begin with.ConclusionBoth methods use closures, so it comes down to personal taste; the second approach is easier to "move" around or generalize.I wrote this a while ago to remind myself of what a closure is and how it works in JS. A closure is a function that, when called, uses the scope in which it was declared, not the scope in which it was called. In javaScript, all functions behave like this. Variable values in a scope persist as long as there is a function that still points to them. The exception  to the rule is \'this\', which refers to the object that the function is inside when it is called.After inspecting closely, looks like both of you are using closure.In your friends case, i is accessed inside anonymous function 1 and i2 is accessed in anonymous function 2 where the console.log is present.In your case you are accessing i2 inside anonymous function where console.log is present. Add a debugger; statement before console.log and in chrome developer tools under "Scope variables" it will tell under what scope the variable is.Consider the following.\nThis creates and recreates a function f that closes on i, but different ones!:\nwhile the following closes on "a" function "itself"\n( themselves! the snippet after this uses a single referent f )\nor to be more explicit:NB. the last  definition of f is function(){ console.log(9) } before 0 is printed.Caveat! The closure concept can be a coercive distraction from the essence of elementary programming:x-refs.:\nHow do JavaScript closures work?\nJavascript Closures Explanation\nDoes a (JS) Closure Require a Function Inside a Function\nHow to understand closures in Javascript?\nJavascript local and global variable confusion 