I was implementing an algorithm in Swift and noticed that the performance was very poor. After digging deeper I realised that one of the bottlenecks was something as simple as sorting arrays. The relevant part is here:In C++, a similar operation takes 0.06 s on my computer.In Python it takes 0.6 s (no tricks, just y = sorted(x) for a list of integers).In Swift it takes 6 s if I compile it with the following command:And it takes as much as 88 s if I compile it with the following command:Timings in Xcode with "Release" vs. "Debug" builds are similar.What is wrong here? I could understand some performance loss in comparison with C++, but not a 10-fold slowdown in comparison with pure Python.Edit: mweathers noticed that changing -O3 to -Ofast makes this code run almost as fast as the C++ version! However, -Ofast changes the semantics of the language a lot \xe2\x80\x94 in my testing, it disabled the checks for integer overflows and array indexing overflows. For example, with -Ofast the following Swift code runs silently without crashing (and prints out some garbage):So -Ofast is not what we want; the whole point of Swift is that we have the safety nets in place. Of course the safety nets have some impact on the performance, but they should not make the programs 100 times slower. Remember that Java already checks for array bounds, and in typical cases the slowdown is by a factor much less than 2. And in Clang and GCC we have got -ftrapv for checking (signed) integer overflows, and it is not that slow, either.Hence the question: how can we get a reasonable performance in Swift without losing the safety nets?Edit 2: I did some more benchmarking, with very simple loops along the lines of(Here the xor operation is there just so that I can more easily find the relevant loop in the assembly code. I tried to pick an operation that is easy to spot but also "harmless" in the sense that it should not require any checks related to integer overflows.)Again, there was a huge difference in the performance between -O3 and -Ofast. So I had a look at the assembly code:With -Ofast I get pretty much what I would expect. The relevant part is a loop with 5 machine language instructions.With -O3 I get something that was beyond my wildest imagination. The inner loop spans 88 lines of assembly code. I did not try to understand all of it, but the most suspicious parts are 13 invocations of "callq _swift_retain" and another 13 invocations of "callq _swift_release". That is, 26 subroutine calls in the inner loop!Edit 3: In comments, Ferruccio asked for benchmarks that are fair in the sense that they do not rely on built-in functions (e.g. sort). I think the following program is a fairly good example:There is no arithmetic, so we do not need to worry about integer overflows. The only thing that we do is just lots of array references. And the results are here\xe2\x80\x94Swift -O3 loses by factor almost 500 in comparison with -Ofast:(If you are concerned that the compiler might optimise out the pointless loops entirely, you can change it to e.g. x[i] ^= x[j], and add a print statement that outputs x[0]. This does not change anything; the timings will be very similar.)And yes, here the Python implementation was a stupid pure Python implementation with a list of ints and nested for loops. It should be much slower than unoptimised Swift. Something seems to be seriously broken with Swift and array indexing.Edit 4: These issues (as well as some other performance issues) seems to have been fixed in Xcode 6 beta 5.For sorting, I now have the following timings:For nested loops:It seems that there is no reason anymore to use the unsafe -Ofast (a.k.a. -Ounchecked); plain -O produces equally good code.tl;dr Swift is now as fast as C by this benchmark using the default release optimisation level [-O].Here is an in-place quicksort in Swift:And the same in C:Both work:Both are called in the same program as written.This converts the absolute times to seconds:Here is a summary of the compiler\'s optimazation levels:Time in seconds with [-Onone] for n=10_000:Here is Swift\'s builtin sort() for n=10_000:Here is [-O] for n=10_000:As you can see, Swift\'s performance improved by a factor of 20.As per mweathers\' answer, setting [-Ofast] makes the real difference, resulting in these times for n=10_000:And for n=1_000_000:For comparison, this is with [-Onone] for n=1_000_000:So Swift with no optimizations was almost 1000x slower than C in this benchmark, at this stage in its development.  On the other hand with both compilers set to [-Ofast] Swift actually performed at least as well if not slightly better than C.It has been pointed out that [-Ofast] changes the semantics of the language, making it potentially unsafe. This is what Apple states in the Xcode 5.0 release notes:A new optimization level -Ofast, available in LLVM, enables aggressive optimizations. -Ofast relaxes some conservative restrictions, mostly for floating-point operations, that are safe for most code. It can yield significant high-performance wins from the compiler.They all but advocate it. Whether that\'s wise or not I couldn\'t say, but from what I can tell it seems reasonable enough to use [-Ofast] in a release if you\'re not doing high-precision floating point arithmetic and you\'re confident no integer or array overflows are possible in your program. If you do need high performance and overflow checks / precise arithmetic then choose another language for now.BETA 3 UPDATE:n=10_000 with [-O]:Swift in general is a bit faster and it looks like Swift\'s built-in sort has changed quite significantly.FINAL UPDATE:[-Onone]:[-O]:[-Ounchecked]:TL;DR: Yes, the only Swift language implementation is slow, right now. If you need fast, numeric (and other types of code, presumably) code, just go with another one. In the future, you should re-evaluate your choice. It might be good enough for most application code that is written at a higher level, though.From what I\'m seeing in SIL and LLVM IR, it seems like they need a bunch of optimizations for removing retains and releases, which might be implemented in Clang (for Objective-C), but they haven\'t ported them yet. That\'s the theory I\'m going with (for now\xe2\x80\xa6 I still need to confirm that Clang does something about it), since a profiler run on the last test-case of this question yields this \xe2\x80\x9cpretty\xe2\x80\x9d result:\nAs was said by many others, -Ofast is totally unsafe and changes language semantics. For me, it\'s at the \xe2\x80\x9cIf you\'re going to use that, just use another language\xe2\x80\x9d stage. I\'ll re-evaluate that choice later, if it changes.-O3 gets us a bunch of swift_retain and swift_release calls that, honestly, don\'t look like they should be there for this example. The optimizer should have elided (most of) them AFAICT, since it knows most of the information about the array, and knows that it has (at least) a strong reference to it.It shouldn\'t emit more retains when it\'s not even calling functions which might release the objects. I don\'t think an array constructor can return an array which is smaller than what was asked for, which means that a lot of checks that were emitted are useless. It also knows that the integer will never be above 10k, so the overflow checks can be optimized (not because of -Ofast weirdness, but because of the semantics of the language (nothing else is changing that var nor can access it, and adding up to 10k is safe for the type Int).The compiler might not be able to unbox the array or the array elements, though, since they\'re getting passed to sort(), which is an external function and has to get the arguments it\'s expecting. This will make us have to use the Int values indirectly, which would make it go a bit slower. This could change if the sort() generic function (not in the multi-method way) was available to the compiler and got inlined.This is a very new (publicly) language, and it is going through what I assume are lots of changes, since there are people (heavily) involved with the Swift language asking for feedback and they all say the language isn\'t finished and will change.Code used:P.S: I\'m not an expert on Objective-C nor all the facilities from Cocoa, Objective-C, or the Swift runtimes. I might also be assuming some things that I didn\'t write.I decided to take a look at this for fun, and here are the timings that I get:Results:Swift 1.1Swift 1.2Swift 2.0It seems to be the same performance if I compile with -Ounchecked.Swift 3.0There seems to have been a performance regression from Swift 2.0 to Swift 3.0, and I\'m also seeing a difference between -O and -Ounchecked for the first time.Results:Apple Clang 6.0Apple Clang 6.1.0Apple Clang 7.0.0Apple Clang 8.0.0As of the time of this writing, Swift\'s sort is fast, but not yet as fast as C++\'s sort, with the above compilers & libraries. Since Swift is still young, it\'s conceivable that this gap will be closed in the future, and the gap has been significantly narrowed in Swift 1.2 and 2.0 with an apparent performance regression in Swift 3.0.From The Swift Programming Language:The Sort Function Swift\xe2\x80\x99s standard library provides a function called\n  sort, which sorts an  array of values of a known type, based on the\n  output of a sorting closure  that you provide. Once it completes the\n  sorting process, the sort function returns a new array of the same\n  type and size as the old one, with its elements in the correct sorted\n  order.The sort function has two declarations.The default declaration which allows you to specify a comparison closure:And a second declaration that only take a single parameter (the array) and is "hardcoded to use the less-than comparator."I tested a modified version of your code in a playground with the closure added on so I could monitor the function a little more closely, and I found that with n set to 1000, the closure was being called about 11,000 times.It is not an efficient function, an I would recommend using a better sorting function implementation.EDIT:I took a look at the Quicksort wikipedia page and wrote a Swift implementation for it. Here is the full program I used (in a playground)Using this with n=1000, I found thatIt seems that the built-in sort method is (or is close to) quick sort, and is really slow...As of Xcode 7 you can turn on Fast, Whole Module Optimization. This should increase your performance immediately.Swift Array performance revisited: I wrote my own benchmark comparing Swift with C/Objective-C. My benchmark calculates prime numbers. It uses the array of previous prime numbers to look for prime factors in each new candidate, so it is quite fast. However, it does TONS of array reading, and less writing to arrays.I originally did this benchmark against Swift 1.2. I decided to update the project and run it against Swift 2.0. The project lets you select between using normal swift arrays and using Swift unsafe memory buffers using array semantics.For C/Objective-C, you can either opt to use NSArrays, or C malloc\'ed arrays.The test results seem to be pretty similar with fastest, smallest code optimization ([-0s]) or fastest, aggressive ([-0fast]) optimization.Swift 2.0 performance is still horrible with code optimization turned off, whereas C/Objective-C performance is only moderately slower.The bottom line is that C malloc\'d array-based calculations are the fastest, by a modest marginSwift with unsafe buffers takes around 1.19X - 1.20X longer than C malloc\'d arrays when using fastest, smallest code optimization. the difference seems slightly less with fast, aggressive optimization (Swift takes more like 1.18x to 1.16x longer than C.If you use regular Swift arrays, the difference with C is slightly greater. (Swift takes ~1.22 to 1.23 longer.) Regular Swift arrays are DRAMATICALLY faster than they were in Swift 1.2/Xcode 6. Their performance is so close to Swift unsafe buffer based arrays that using unsafe memory buffers does not really seem worth the trouble any more, which is big. BTW, Objective-C NSArray performance stinks. If you\'re going to use the native container objects in both languages, Swift is DRAMATICALLY faster.You can check out my project on github at SwiftPerformanceBenchmarkIt has a simple UI that makes collecting stats pretty easy.It\'s interesting that sorting seems to be slightly faster in Swift than in C now, but that this prime number algorithm is still faster in Swift.The main issue that is mentioned by others but not called out enough is that -O3 does nothing at all in Swift (and never has) so when compiled with that it is effectively non-optimised (-Onone).Option names have changed over time so some other answers have obsolete flags for the build options. Correct current options (Swift 2.2) are:Whole module optimisation has a slower compile but can optimise across files within the module i.e. within each framework and within the actual application code but not between them. You should use this for anything performance critical)You can also disable safety checks for even more speed but with all assertions and preconditions not just disabled but optimised on the basis that they are correct. If you ever hit an assertion this means that you are into undefined behaviour. Use with extreme caution and only if you determine that the speed boost is worthwhile for you (by testing). If you do find it valuable for some code I recommend separating that code into a separate framework and only disabling the safety checks for that module.This is my Blog about Quick Sort\nhttps://github.com/ahmad-atef/Algorithms-DataStructures/wiki/Quick-SortYou can take a look about Lomuto\'s partitioning algorithm in Partitioning the list. Written in Swift