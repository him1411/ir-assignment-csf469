I want to convert a std::string to lowercase. I am aware of the function tolower(), however in the past I have had issues with this function and it is hardly ideal anyway as use with a string would require iterating over each character.Is there an alternative which works 100% of the time?From http://notfaq.wordpress.com/2007/08/04/cc-convert-string-to-upperlower-case/:You\'re really not going to get away with not iterating through each character.  There\'s no way to know whether the character is lowercase or uppercase otherwise.If you really hate tolower(), here\'s a non-portable alternative that I don\'t recommend you use:Be aware that ::tolower() can only do a per-single-byte-character substitution, which is ill-fitting for many scripts, especially if using a multi-byte-encoding like UTF-8.There is a Boost string algorithm for this:tl;drUse the ICU library.First you have to answer a question: What is the encoding of your std::string? Is it ISO-8859-1? Or perhaps ISO-8859-8? Or Windows Codepage 1252? Does whatever you\'re using to convert upper-to-lowercase know that? (Or does it fail miserably for characters over 0x7f?)If you are using UTF-8 (the only sane choice among the 8-bit encodings) with std::string as container, you are already deceiving yourself into believing that you are still in control of things, because you are storing a multibyte character sequence in a container that is not aware of the multibyte concept. Even something as simple as .substr() is a ticking timebomb. (Because splitting a multibyte sequence will result in an invalid (sub-) string.)And as soon as you try something like std::toupper( \'\xc3\x9f\' ), in any encoding, you are in deep trouble. (Because it\'s simply not possible to do this "right" with the standard library, which can only deliver one result character, not the "SS" needed here.) [1] Another example would be std::tolower( \'I\' ), which should yield different results depending on the locale. In Germany, \'i\' would be correct; in Turkey, \'\xc4\xb1\' (LATIN SMALL LETTER DOTLESS I) is the expected result.Then there is the point that the standard library is depending on which locales are supported on the machine your software is running on... and what do you do if it isn\'t?So what you are really looking for is a string class that is capable of dealing with all this correctly, and that is not std::string.(C++11 note: std::u16string and std::u32string are better, but still not perfect.)While Boost looks nice, API wise, Boost.Locale is basically a wrapper around ICU. If Boost is compiled with ICU support... if it isn\'t, Boost.Locale is limited to the locale support compiled for the standard library.And believe me, getting Boost to compile with ICU can be a real pain sometimes. (There are no pre-compiled binaries for Windows, so you\'d have to supply them together with your application, and that opens a whole new can of worms...)So personally I would recommend getting full Unicode support straight from the horse\'s mouth and using the ICU library directly:Compile (with G++ in this example):This gives:[1] In 2017, the Council for German Orthography ruled that "\xe1\xba\x9e" U+1E9E LATIN CAPITAL LETTER SHARP S could be used officially, as an option beside the traditional "SS" conversion to avoid ambiguity e.g. in passports (where names are capitalized). My beautiful go-to example, made obsolete by committee decision... If the string contains UTF-8 characters outside of the ASCII range, then boost::algorithm::to_lower will not convert those. Better use boost::locale::to_lower when UTF-8 is involved. See http://www.boost.org/doc/libs/1_51_0/libs/locale/doc/html/conversions.htmlUsing range-based for loop of C++11 a simpler code would be :This is a follow-up to Stefan Mai\'s response: if you\'d like to place the result of the conversion in another string, you need to pre-allocate its storage space prior to calling std::transform. Since STL stores transformed characters at the destination iterator (incrementing it at each iteration of the loop), the destination string will not be automatically resized, and you risk memory stomping.As far as I see Boost libraries are really bad performance-wise. I have tested their unordered_map to STL and it was average 3 times slower (best case 2, worst was 10 times). Also this algorithm looks too low.The difference is so big that I am sure whatever addition you will need to do to tolower to make it equal to boost "for your needs" will be way faster than boost.I have done these tests on an Amazon EC2, therefore performance varied during the test but you still get the idea.-O2 made it like this:Source:I guess I should to the tests on a dedicated machine but I will be using this EC2 so I do not really need to test it on my machine.std::ctype::tolower() from the standard C++ Localization library will correctly do this for you. Here is an example extracted from the tolower reference pageThere is a way to convert upper case to lower WITHOUT doing if tests, and it\'s pretty straight-forward. The isupper() function/macro\'s use of clocale.h should take care of problems relating to your location, but if not, you can always tweak the UtoL[] to your heart\'s content. Given that C\'s characters are really just 8-bit ints (ignoring the wide character sets for the moment) you can create a 256 byte array holding an alternative set of characters, and in the conversion function use the chars in your string as subscripts into the conversion array. Instead of a 1-for-1 mapping though, give the upper-case array members the BYTE int values for the lower-case characters. You may find islower() and isupper() useful here. The code looks like this...This approach will, at the same time, allow you to remap any other characters you wish to change. This approach has one huge advantage when running on modern processors, there is no need to do branch prediction as there are no if tests comprising branching. This saves the CPU\'s branch prediction logic for other loops, and tends to prevent pipeline stalls. Some here may recognize this approach as the same one used to convert EBCDIC to ASCII.An alternative to Boost is POCO (pocoproject.org).POCO provides two variants:Both versions are demonstrated below:Simplest way to convert string into loweercase without bothering about std namespace is as follows 1:string with/without spaces2:string without spacesHere\'s a macro technique if you want something simple:However, note that @AndreasSpindler\'s comment on this answer still is an important consideration, however, if you\'re working on something that isn\'t just ASCII characters.Another approach using range based for loop with reference variableOn microsoft platforms you can use the strlwr family of functions: http://msdn.microsoft.com/en-us/library/hkxwh33z.aspxFor more information: http://www.cplusplus.com/reference/locale/tolower/Use fplus::to_lower_case().(fplus: https://github.com/Dobiasd/FunctionalPlus.Search \'to_lower_case\' in http://www.editgym.com/fplus-api-search/)I do something like this...I tried std::transform, all i get is abominable stl criptic compilation error that only druids from 200 years ago can understand  (cannot convert from to flibidi flabidi flu)this works fine and can be easily tweaked