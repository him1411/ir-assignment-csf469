Using C# and WPF under .NET (rather than Windows Forms or console), what is the correct way to create an application that can only be run as a single instance?I know it has something to do with some mythical thing called a mutex, rarely can I find someone that bothers to stop and explain what one of these are.The code needs to also inform the already-running instance that the user tried to start a second one, and maybe also pass any command-line arguments if any existed.Here is a very good article regarding the Mutex solution.  The approach described by the article is advantageous for two reasons.First, it does not require a dependency on the Microsoft.VisualBasic assembly.  If my project already had a dependency on that assembly, I would probably advocate using the approach shown in the accepted answer.  But as it is, I do not use the Microsoft.VisualBasic assembly, and I\'d rather not add an unnecessary dependency to my project.Second, the article shows how to bring the existing instance of the application to the foreground when the user tries to start another instance.  That\'s a very nice touch that the other Mutex solutions described here do not address.As of 8/1/2014, the article I linked to above is still active, but the blog hasn\'t been updated in a while.  That makes me worry that eventually it might disappear, and with it, the advocated solution.  I\'m reproducing the content of the article here for posterity.  The words belong solely to the blog owner at Sanity Free Coding.Today I wanted to refactor some code that prohibited my application\n  from running multiple instances of itself.Previously I had use System.Diagnostics.Process to search for an\n  instance of my myapp.exe in the process list. While this works, it\n  brings on a lot of overhead, and I wanted something cleaner.Knowing that I could use a mutex for this (but never having done it\n  before) I set out to cut down my code and simplify my life.In the class of my application main I created a static named Mutex:Having a named mutex allows us to stack synchronization across\n  multiple threads and processes which is just the magic I\'m looking\n  for.Mutex.WaitOne has an overload that specifies an amount of time for us\n  to wait. Since we\'re not actually wanting to synchronizing our code\n  (more just check if it is currently in use) we use the overload with\n  two parameters: Mutex.WaitOne(Timespan timeout, bool exitContext).\n  Wait one returns true if it is able to enter, and false if it wasn\'t.\n  In this case, we don\'t want to wait at all; If our mutex is being\n  used, skip it, and move on, so we pass in TimeSpan.Zero (wait 0\n  milliseconds), and set the exitContext to true so we can exit the\n  synchronization context before we try to aquire a lock on it. Using\n  this, we wrap our Application.Run code inside something like this:So, if our app is running, WaitOne will return false, and we\'ll get a\n  message box.Instead of showing a message box, I opted to utilize a little Win32 to\n  notify my running instance that someone forgot that it was already\n  running (by bringing itself to the top of all the other windows). To\n  achieve this I used PostMessage to broadcast a custom message to every\n  window (the custom message was registered with RegisterWindowMessage\n  by my running application, which means only my application knows what\n  it is) then my second instance exits. The running application instance\n  would receive that notification and process it. In order to do that, I\n  overrode WndProc in my main form and listened for my custom\n  notification. When I received that notification I set the form\'s\n  TopMost property to true to bring it up on top.Here is what I ended up with:You could use the Mutex class, but you will soon find out that you will need to implement the code to pass the arguments and such yourself.  Well, I learned a trick when programming in WinForms when I read Chris Sell\'s book.  This trick uses logic that is already available to us in the framework.  I don\'t know about you, but when I learn about stuff I can reuse in the framework, that is usually the route I take instead of reinventing the wheel.  Unless of course it doesn\'t do everything I want.When I got into WPF, I came up with a way to use that same code, but in a WPF application.  This solution should meet your needs based off your question.First, we need to create our application class.  In this class we are going override the OnStartup event and create a method called Activate, which will be used later.Second, we will need to create a class that can manage our instances.  Before we go through that, we are actually going to reuse some code that is in the Microsoft.VisualBasic assembly.  Since, I am using C# in this example, I had to make a reference to the assembly.  If you are using VB.NET, you don\'t have to do anything.  The class we are going to use is WindowsFormsApplicationBase and inherit our instance manager off of it and then leverage properties and events to handle the single instancing.Basically, we are using the VB bits to detect single instance\'s and process accordingly.  OnStartup will be fired when the first instance loads.  OnStartupNextInstance is fired when the application is re-run again.  As you can see, I can get to what was passed on the command line through the event arguments.  I set the value to an instance field.  You could parse the command line here, or you could pass it to your application through the constructor and the call to the Activate method.Third, it\'s time to create our EntryPoint.  Instead of newing up the application like you would normally do, we are going to take advantage of our SingleInstanceManager.Well, I hope you are able to follow everything and be able use this implementation and make it your own.From here.A common use for a cross-process Mutex is to ensure that only instance of a program can run at a time. Here\'s how it\'s done:A good feature of Mutex is that if the application terminates without ReleaseMutex first being called, the CLR will release the Mutex automatically.MSDN actually has a sample application for both C# and VB to do exactly this: http://msdn.microsoft.com/en-us/library/ms771662(v=VS.90).aspxThe most common and reliable technique\n  for developing single-instance\n  detection is to use the Microsoft .NET\n  Framework remoting infrastructure\n  (System.Remoting). The Microsoft .NET\n  Framework (version 2.0) includes a\n  type, WindowsFormsApplicationBase,\n  which encapsulates the required\n  remoting functionality. To incorporate\n  this type into a WPF application, a\n  type needs to derive from it, and be\n  used as a shim between the application\n  static entry point method, Main, and\n  the WPF application\'s Application\n  type. The shim detects when an\n  application is first launched, and\n  when subsequent launches are\n  attempted, and yields control the WPF\n  Application type to determine how to\n  process the launches.The framework already has support for this - its just that some idiot named the DLL Microsoft.VisualBasic and it didn\'t get put into Microsoft.ApplicationUtils or something like that. Get over it - or open up Reflector.Tip: If you use this approach exactly as is, and you already have an App.xaml with resources etc. you\'ll want to take a look at this too.This code should go to the main method. Look at here for more information about the main method in WPF.Method 2Note : Above methods assumes your process/application has a unique name. Because it uses process name to find if any existing processors. So, if your application has a very common name (ie: Notepad), above approach won\'t work. A new one that uses Mutex and IPC stuff, and also passes any command line arguments to the running instance, is WPF Single Instance Application.Well, I have a disposable Class for this that works easily for most use cases:Use it like this:Here it is:Here is an example that allows you to have a single instance of an application. When any new instances load, they pass their arguments to the main instance that is running.Just some thoughts:\nThere are cases when requiring that only one instance of an application is not "lame" as some would have you believe. Database apps, etc. are an order of magnitude more difficult if one allows multiple instances of the app for a single user to access a database (you know, all that updating all the records that are open in multiple instances of the app on the users machine, etc.). \nFirst, for the "name collision thing, don\'t use a human readable name - use a GUID instead or, even better a GUID + the human readable name. Chances of name collision just dropped off the radar and the Mutex doesn\'t care. As someone pointed out, a DOS attack would suck, but if the malicious person has gone to the trouble of getting the mutex name and incorporating it into their app, you are pretty much a target anyway and will have to do MUCH more to protect yourself than just fiddle a mutex name.\nAlso, if one uses the variant of:\nnew Mutex(true, "some GUID plus Name", out AIsFirstInstance), you already have your indicator as to whether or not the Mutex is the first instance.So many answers to such a seemingly simple question.  Just to shake things up a little bit here is my solution to this problem.Creating a Mutex can be troublesome because the JIT-er only sees you using it for a small portion of your code and wants to mark it as ready for garbage collection.  It pretty much wants to out-smart you thinking you are not going to be using that Mutex for that long.  In reality you want to hang onto this Mutex for as long as your application is running.  The best way to tell the garbage collector to leave you Mutex alone is to tell it to keep it alive though out the different generations of garage collection.  Example:I lifted the idea from this page: http://www.ai.uga.edu/~mc/SingleInstance.htmlThe code C# .NET Single Instance Application that is the reference for the marked answer is a great start.However, I found it doesn\'t handle very well the cases when the instance that already exist has a modal dialog open, whether that dialog is a managed one (like another Form such as an about box), or an unmanaged one (like the OpenFileDialog even when using the standard .NET class). With the original code, the main form is activated, but the modal one stays unactive, which looks strange, plus the user must click on it to keep using the app.So, I have create a SingleInstance utility class to handle all this quite automatically for Winforms and WPF applications.Winforms:1) modify the Program class like this:2) modify the main window class like this:WPF:1) modify the App page like this (and make sure you set its build action to page to be able to redefine the Main method):2) modify the main window class like this:And here is the utility class:It looks like there is a really good way to handle this:WPF Single Instance ApplicationThis provides a class you can add that manages all the mutex and messaging cruff to simplify the your implementation to the point where it\'s simply trivial.The following code is my WCF named pipes solution to register a single-instance application. It\'s nice because it also raises an event when another instance attempts to start, and receives the command line of the other instance.It\'s geared toward WPF because it uses the System.Windows.StartupEventHandler class, but this could be easily modified.This code requires a reference to PresentationFramework, and System.ServiceModel.Usage:Here is what I use. It combined process enumeration to perform switching and mutex to safeguard from "active clickers":I found the simpler solution, similar to Dale Ragan\'s, but slightly modified. It does practically everything you need and based on the standard Microsoft WindowsFormsApplicationBase class.Firstly, you create SingleInstanceController class, which you can use in all other single-instance applications, which use Windows Forms:Then you can use it in your program as follows:Both the program and the SingleInstanceController_NET solution should reference Microsoft.VisualBasic . If you just want to reactivate the running application as a normal window when the user tries to restart the running program, the second parameter in the SingleInstanceController can be null. In the given example, the window is maximized.You should never use a named mutex to implement a single-instance application (or at least not for production code). Malicious code can easily DoS (Denial of Service) your ass...Look at the folllowing code. It is a great and simple solution to prevent multiple instances of a WPF application.Not using Mutex though, simple answer:Put it inside the Program.Main().\nExample:You can add MessageBox.Show to the if-statement and put "Application already running".\nThis might be helpful to someone.Update 2017-01-25. After trying few things, I decided to go with VisualBasic.dll it is easier and works better (at least for me). I let my previous answer just as reference...Just as reference, this is how I did without passing arguments (which I can\'t find any reason to do so... I mean a single app with arguments that as to be passed out from one instance to another one).\nIf file association is required, then an app should (per users standard expectation) be instanciated for each doc. If you have to pass args to existing app, I  think I would used vb dll.Not passing args (just single instance app), I prefer not registering a new Window message and not override the message loop as defined in Matt Davis Solution. Although it\'s not a big deal to add a VisualBasic dll, but I prefer not add a new reference just to do single instance app. Also, I do prefer instanciate a new class with Main instead of calling Shutdown from App.Startup override to ensure to exit as soon as possible.In hope that anybody will like it... or will inspire a little bit :-) Project startup class should be set as \'SingleInstanceApp\'.WindowHelper:Use mutex solution:Here\'s a lightweight solution I use which allows the application to bring an already existing window to the foreground without resorting to custom windows messages or blindly searching process names.Edit: You can also store and initialize mutex and createdNew statically, but you\'ll need to explicitly dispose/release the mutex once you\'re done with it. Personally, I prefer keeping the mutex local as it will be automatically disposed of even if the application closes without ever reaching the end of Main.You can also use the CodeFluent Runtime which is free set of tools. It provides a SingleInstance class to implement a single instance application.Simply using a StreamWriter, how about this?andI added a sendMessage Method to the NativeMethods Class.Apparently the postmessage method dosent work, if the application is not show in the taskbar, however using the sendmessage method solves this.Usually whenever we execute an .exe, every time it creates a separate windows process with its own address space, resources and so on.  But we do not want this criteria as this would prevent us from creating single process. Single instance applications can be created using the Mutex in C# which is discussed in this articleMoreover if we want to bring the application on top we can do it using Normally, this is the code I use for single-instance Windows Forms applications:Where native components are:Here is a solution:Here\'s the same thing implemented via Event.This is how I ended up taking care of this issue.  Note that debug code is still in there for testing.  This code is within the OnStartup in the App.xaml.cs file.  (WPF)  This may have issues that I have not caught yet.  If I run into any I\'ll update my answer.      Here is my 2 cents