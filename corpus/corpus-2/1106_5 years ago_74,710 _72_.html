I can\'t find it now, but I swear there used to be a T-shirt for sale featuring the immortal words:What part ofdo you not understand?In my case, the answer would be... all of it!In particular, I often see notation like this in Haskell papers, but I have no clue what any of it means. I have no idea what branch of mathematics it\'s supposed to be.I recognise the letters of the Greek alphabet of course, and symbols such as "\xe2\x88\x89" (which usually means that something is not an element of a set).On the other hand, I\'ve never seen "\xe2\x8a\xa2" before (Wikipedia claims it might mean "partition"). I\'m also unfamiliar with the use of the vinculum here. (Usually it denotes a fraction, but that does not appear to be the case here.)I imagine SO is not a good place to be explaining the entire Milner Hindley algorithm. But if somebody could at least tell me where to start looking to comprehend what this sea of symbols means, that would be helpful. (I\'m sure I can\'t be the only person who\'s wondering...)This syntax, while it may look complicated, is actually fairly simple. The basic idea comes from logic: the whole expression is an implication with the top half being the assumptions and the bottom half being the result. That is, if you know that the top expressions are true, you can conclude that the bottom expressions are true as well.Another thing to keep in mind is that some letters have traditional meanings; particularly, \xce\x93 represents the "context" you\'re in\xe2\x80\x94that is, what the types of other things you\'ve seen are. So something like \xce\x93 \xe2\x8a\xa2 ... means "the expression ... when you know the types of every expression in \xce\x93.The \xe2\x8a\xa2 symbol essentially means that you can prove something. So \xce\x93 \xe2\x8a\xa2 ... is a statement saying "I can prove ... in a context \xce\x93. These statements are also called type judgements. Another thing to keep in mind: in math, just like ML and Scala, x : \xcf\x83 means that x has type \xcf\x83. You can read it just like Haskell\'s x :: \xcf\x83.So, knowing this, the first expression becomes easy to understand: if we know that x : \xcf\x83 \xe2\x88\x88 \xce\x93 (that is, x has some type \xcf\x83 in some context \xce\x93), then we know that \xce\x93 \xe2\x8a\xa2 x : \xcf\x83 (that is, in \xce\x93, x has type \xcf\x83). So really, this isn\'t telling you anything super-interesting; it just tells you how to use your context.The other rules are also simple. For example, take [App]. This rule has two conditions: e\xe2\x82\x80 is a function from some type \xcf\x84 to some type \xcf\x84\' and e\xe2\x82\x81 is a value of type \xcf\x84. Now you know what type you will get by applying e\xe2\x82\x80 to e\xe2\x82\x81! Hopefully this isn\'t a surprise :).The next rule has some more new syntax. Particularly, \xce\x93, x : \xcf\x84 just means the context made up of \xce\x93 and the judgement x : \xcf\x84. So, if we know that the variable x has a type of \xcf\x84 and the expression e has a type \xcf\x84\', we also know the type of a function that takes x and returns e. This just tells us what to do if we\'ve figured out what type a function takes and what type it returns, so it shouldn\'t be surprising either.The next one just tells you how to handle let statements. If you know that some expression e\xe2\x82\x81 has a type \xcf\x84 as long as x has a type \xcf\x83, then a let expression which locally binds x to a value of type \xcf\x83 will make e\xe2\x82\x81 have a type \xcf\x84. Really, this just tells you that a let statement essentially lets you expand the context with a new binding\xe2\x80\x94which is exactly what let does!The [Inst] rule deals with sub-typing. It says that if you have a value of type \xcf\x83\' and it is a sub-type of \xcf\x83 (\xe2\x8a\x91 represents a partial ordering relation) then that expression is also of type \xcf\x83.The final rule deals with generalizing types. A quick aside: a free variable is a variable that is not introduced by a let-statement or lambda inside some expression; this expression now depends on the value of the free variable from its context.The rule is saying that if there is some variable \xce\xb1 which is not "free" in anything in your context, then it is safe to say that any expression whose type you know e : \xcf\x83 will have that type for any value of \xce\xb1.So, now that you understand the symbols, what do you do with these rules? Well, you can use these rules to figure out the type of various values. To do this, look at your expression (say f x y) and find a rule that has a conclusion (the bottom part) that matches your statement. Let\'s call the thing you\'re trying to find your "goal". In this case, you would look at the rule that ends in e\xe2\x82\x80 e\xe2\x82\x81. When you\'ve found this, you now have to find rules proving everything above the line of this rule. These things generally correspond to the types of sub-expressions, so you\'re essentially recursing on parts of the expression. You just do this until you finish your proof tree, which gives you a proof of the type of your expression. So all these rules do is specify exactly\xe2\x80\x94and in the usual mathematically pedantic detail :P\xe2\x80\x94how to figure out the types of expressions.Now, this should sound familiar if you\'ve ever used Prolog\xe2\x80\x94you\'re essentially computing the proof tree like a human Prolog interpreter. There is a reason Prolog is called "logic programming"! This is also important as the first way I was introduced to the H-M inference algorithm was by implementing it in Prolog. This is actually surprisingly simple and makes what\'s going on clear. You should certainly try it.Note: I probably made some mistakes in this explanation and would love it if somebody would point them out. I\'ll actually be covering this in class in a couple of weeks, so I\'ll be more confident then :P.if somebody could at least tell me where to start looking to comprehend what this sea of symbols meansSee "Practical Foundations of Programming Languages.", chapters 2 and 3, on the style of logic through judgements and derivations. The entire book is now available on Amazon.Inductive definitions are an indispensable tool in the study of programming languages. In this chapter we will develop the basic framework of inductive definitions, and give some examples of their use. An inductive definition consists of a set of rules for deriving judgments, or assertions, of a variety of forms. Judgments are statements about one or more syntactic objects of a specified sort. The rules specify necessary and sufficient conditions for the validity of a judgment, and hence fully determine its meaning.We start with the notion of a judgment, or assertion about a syntactic object. We shall make use of many forms of judgment, including examples such as these:A judgment states that one or more syntactic objects have a property or stand in some relation to one another. The property or relation itself is called a judgment form, and the judgment that an object or objects have that property or stand in that relation is said to be an instance of that judgment form. A judgment form is also called a predicate, and the objects constituting an instance are its subjects. We write a J for the judgment asserting that J holds of a. When it is not important to stress the subject of the judgment, (text cuts off here)The notation comes from natural deduction.\xe2\x8a\xa2 symbol is called turnstile. The 6 rules are very easy.Var rule is rather trivial rule - it says that if type for identifier is already present in your type environment, then to infer the type you just take it from the environment as is.App rule says that if you have two identifiers e0 and e1 and can infer their types, then you can infer the type of application e0 e1. The rule reads like this if you know that e0 :: t0 -> t1 and e1 :: t0 (the same t0!), then application is well-typed and the type is t1.Abs and Let are rules to infer types for lambda-abstraction and let-in.Inst rule says that you can substitute a type with less general one.I imagine SO is not a good place to be explaining the entire Milner Hindley algorithm.If you are looking for a good explanation of the algorithm, the best that I\'ve found so far is in chapter 30 of Shriram Krishnamurthi\'s Programming Languages: Application and Interpretation (CC licensed!).  Here\'s one good reason why it\'s a good explanation: examples!There are two ways to think of e : \xcf\x83. One is "the expression e has type \xcf\x83", another is "the ordered pair of the expression e and the type \xcf\x83".View \xce\x93 as the knowledge about the types of expressions, implemented as a set of pairs of expression and type, e : \xcf\x83.The turnstile \xe2\x8a\xa2 means that from the knowledge on the left, we can deduce what\'s on the right.The first rule [Var] can thus be read:\nIf our knowledge \xce\x93 contains the pair e : \xcf\x83, then we can deduce from \xce\x93 that e has type \xcf\x83.The second rule [App] can be read:\nIf we from \xce\x93 can deduce that e_0 has the type \xcf\x84 \xe2\x86\x92 \xcf\x84\', and we from \xce\x93 can deduce that e_1 has the type \xcf\x84, then we from \xce\x93 can deduce that e_0 e_1 has the type \xcf\x84\'.It\'s common to write \xce\x93, e : \xcf\x83 instead of \xce\x93 \xe2\x88\xaa {e : \xcf\x83}.The third rule [Abs] can thus be read:\nIf we from \xce\x93 extended with x : \xcf\x84 can deduce that e has type \xcf\x84\', then we from \xce\x93 can deduce that \xce\xbbx.e has the type \xcf\x84 \xe2\x86\x92 \xcf\x84\'.The fourth rule [Let] is left as an exercise. :-)The fifth rule [Inst] can be read:\nIf we from \xce\x93 can deduce that e has type \xcf\x83\', and \xcf\x83\' is a subtype of \xcf\x83, then we from \xce\x93 can deduce that e has type \xcf\x83.The sixth and last rule [Gen] can be read:\nIf we from \xce\x93 can deduce that e has type \xcf\x83, and \xce\xb1 is not a free type variable in any of the types in \xce\x93, then we from \xce\x93 can deduce that e has type \xe2\x88\x80\xce\xb1 \xcf\x83.Hindley-Milner is a set of rules in the form of sequent calculus that says you can deduce the (most general) type of a program from the construction of the program without explicit type declarations.First, let\'s explain the symbolsEverything above the line is the premise, everything below is the conclusion (Per Martin-L\xc3\xb6f)What follows here are English interpretations of the logic statements, followed by an explanation. Given \xf0\x9d\x91\xa5 is a type of \xf0\x9d\x9c\x8e (sigma), an element of \xf0\x9d\x9a\xaa (Gamma),\n  conclude \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\xa5 is a \xf0\x9d\x9c\x8e.This is basically a tautology - an identifier name is a variable or a function.Given \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92\xe2\x82\x80 is a functional type and \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92\xe2\x82\x81 is a \xf0\x9d\x9c\x8f\n  conclude \xf0\x9d\x9a\xaa asserts applying function \xf0\x9d\x91\x92\xe2\x82\x80 to \xf0\x9d\x91\x92\xe2\x82\x81 is a type \xf0\x9d\x9c\x8f\'This means that if we know that a function returns a type, and we apply it to an argument, the result will be an instance of the type we know it returns.Given \xf0\x9d\x9a\xaa and \xf0\x9d\x91\xa5 of type \xf0\x9d\x9c\x8f asserts \xf0\x9d\x91\x92 is a type, \xf0\x9d\x9c\x8f\'\n  conclude \xf0\x9d\x9a\xaa asserts an anonymous function, \xf0\x9d\x9c\x86 of \xf0\x9d\x91\xa5 returning expression, \xf0\x9d\x91\x92 is of type \xf0\x9d\x9c\x8f\xe2\x86\x92\xf0\x9d\x9c\x8f\'.This means that if we know \xf0\x9d\x91\xa5 is of type \xf0\x9d\x9c\x8f and thus an expression \xf0\x9d\x91\x92 is of type \xf0\x9d\x9c\x8f\', then a function of \xf0\x9d\x91\xa5 returning expression \xf0\x9d\x91\x92 is of type \xf0\x9d\x9c\x8f\xe2\x86\x92\xf0\x9d\x9c\x8f\'.Given \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92\xe2\x82\x80, of type \xf0\x9d\x9c\x8e, and \xf0\x9d\x9a\xaa and \xf0\x9d\x91\xa5, of type \xf0\x9d\x9c\x8e, asserts \xf0\x9d\x91\x92\xe2\x82\x81 of type \xf0\x9d\x9c\x8f\n  conclude \xf0\x9d\x9a\xaa asserts let \xf0\x9d\x91\xa5=\xf0\x9d\x91\x92\xe2\x82\x80 in \xf0\x9d\x91\x92\xe2\x82\x81 of type \xf0\x9d\x9c\x8fThis means if we have an expression \xf0\x9d\x91\x92\xe2\x82\x80 that is a \xf0\x9d\x9c\x8e (being a variable or a function), and some name, \xf0\x9d\x91\xa5, also a \xf0\x9d\x9c\x8e, and an expression \xf0\x9d\x91\x92\xe2\x82\x81 of type \xf0\x9d\x9c\x8f, then we can substitute \xf0\x9d\x91\x92\xe2\x82\x80 for \xf0\x9d\x91\xa5 wherever it appears inside of \xf0\x9d\x91\x92\xe2\x82\x81.Given \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92 of type \xf0\x9d\x9c\x8e\' and \xf0\x9d\x9c\x8e\' is a subtype of \xf0\x9d\x9c\x8e\n  conclude \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92 is of type \xf0\x9d\x9c\x8eThis is saying that if an instance is of a type that is a subtype of another type, it is also an instance of that super-type.This allows us to use type instantiation in the more general sense that an expression can return a more specific type.Given \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92 is a \xf0\x9d\x9c\x8e and \xf0\x9d\x9b\xbc is not an element of the free variables of \xf0\x9d\x9a\xaa,\n  conclude \xf0\x9d\x9a\xaa asserts \xf0\x9d\x91\x92, type for all argument expressions \xf0\x9d\x9b\xbc returning a \xf0\x9d\x9c\x8e expressionThis means we can generalize a program to accept all types for arguments not already bound in the containing scope (variables that are not non-local). These bound variables are substitutable.These rules combined allow us to prove the most general type of an asserted program, without requiring type annotations, allowing for various types to be accepted correctly as input (parametric polymorphism). 