How do I find the application\'s path in a console application?In Windows Forms, I can use Application.StartupPath to find the current path, but this doesn\'t seem to be available in a console application.System.Reflection.Assembly.GetExecutingAssembly().Location1Combine that with System.IO.Path.GetDirectoryName if all you want is the directory.1As per Mr.Mindor\'s comment:\n  System.Reflection.Assembly.GetExecutingAssembly().Location returns where the executing assembly is currently located, which may or may not be where the assembly is located when not executing. In the case of shadow copying assemblies, you will get a path in a temp directory. System.Reflection.Assembly.GetExecutingAssembly().CodeBase will return the \'permanent\' path of the assembly.You can use the following code to get the current application directory.You have two options for finding the directory of the application, which you chose will depend on your purpose.Probably a bit late but this is worth a mention:Or more correctly to get just the directory path:Edit:Quite a few people have pointed out that GetCommandLineArgs is not guaranteed to return the program name. See The first word on the command line is the program name only by convention. The article does state that "Although extremely few Windows programs use this quirk (I am not aware of any myself)". So it is possible to \'spoof\' GetCommandLineArgs, but we are talking about a console application. Console apps are usually quick and dirty. So this fits in with my KISS philosophy.For anyone interested in asp.net web apps. Here are my results of 3 different methodsresultthe app is physically running from "C:\\inetpub\\SBSPortal_staging", so the first solution is definitely not appropriate for web apps.The answer above was 90% of what I needed, but returned a Uri instead of a regular path for me.As explained in the MSDN forums post, How to convert URI path to normal filepath?, I used the following:You may be looking to do this:you can use this one instead.For Console Applications, you can try this:Output (on my local machine):c:\\users\\xxxxxxx\\documents\\visual studio 2012\\Projects\\ImageHandler\\GetDir\\bin\\DebugOr you can try (there\'s an additional backslash in the end):Output:c:\\users\\xxxxxxx\\documents\\visual studio 2012\\Projects\\ImageHandler\\GetDir\\bin\\Debug\\I use this if the exe is supposed to be called by double clicking it I have used when I want to find a path relative to an applications folder. This works for both ASP.Net and winform applications. It also does not require any reference to System.Web assemblies.You can simply add to your project references System.Windows.Forms and then use the System.Windows.Forms.Application.StartupPath  as usual .So, not need for more complicated methods or using the reflection.I have used this code and get the solution.I mean, why not a p/invoke method?You would use it just like the Application.StartupPath:Assembly.GetEntryAssembly().Location or Assembly.GetExecutingAssembly().LocationUse in combination with System.IO.Path.GetDirectoryName() to get only the directory.The paths from GetEntryAssembly() and GetExecutingAssembly() can be different, even though for most cases the directory will be the same.With GetEntryAssembly() you have to be aware that this can return null if the entry module is unmanaged (ie C++ or VB6 executable). In those cases it is possible to use GetModuleFileName from the Win32 API:Will resolve the issue to refer the 3rd party reference files with installation packages.in VB.networks for me (Application Type: Class Library). Not sure about C#...\nReturns the path w/o Filename as stringBR,\nDanielHere is a reliable solution that works with 32bit and 64bit applications.Add these references:using System.Diagnostics;using System.Management;Add this method to your project:Now use it like so:Notice that if you know the id of the process, then this method will return the corresponding ExecutePath.Extra, for those interested:...will give you an array of all the currently running processes, and......will give you the current process, along with their information e.g. Id, etc. and also limited control e.g. Kill, etc.*None of these methods work in special cases like using a symbolic link to the exe, they will return the location of the link not the actual exe.So can use QueryFullProcessImageName to get around that:You can create a folder name as Resources within the project using Solution Explorer,then you can paste a file within the Resources.