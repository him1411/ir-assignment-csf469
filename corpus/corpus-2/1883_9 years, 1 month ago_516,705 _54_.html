Does anyone know of an easy way to escape HTML from strings in jQuery?  I need to be able to pass an arbitrary string and have it properly escaped for display in an HTML page (preventing JavaScript/HTML injection attacks).  I\'m sure it\'s possible to extend jQuery to do this, but I don\'t know enough about the framework at the moment to accomplish this.Since you\'re using jQuery, you can just set the element\'s text property:There is also the solution from mustache.jsSource: http://debuggable.com/posts/encode-html-entities-with-jquery:480f4dd6-13cc-4ce9-8071-4710cbdd56cbIf you\'re escaping for HTML, there are only three that I can think of that would be really necessary:Depending on your use case, you might also need to do things like " to &quot;.  If the list got big enough, I\'d just use an array:encodeURIComponent() will only escape it for URLs, not for HTML.I wrote a tiny little function which does this. It only escapes ", &, < and > (but usually that\'s all you need anyway). It is slightly more elegant then the earlier proposed solutions in that it only uses one .replace() to do all the conversion. (EDIT 2: Reduced code complexity making the function even smaller and neater, if you\'re curious about the original code see end of this answer.)This is plain Javascript, no jQuery used.Edit in response to mklement\'s comment.The above function can easily be expanded to include any character. To specify more characters to escape, simply insert them both in the character class in the regular expression (i.e. inside the /[...]/g) and as an entry in the chr object. (EDIT 2: Shortened this function too, in the same way.)Note the above use of &#39; for apostrophe (the symbolic entity &apos; might have been used instead \xe2\x80\x93 it is defined in XML, but was originally not included in the HTML spec and might therefore not be supported by all browsers. See: Wikipedia article on HTML character encodings). I also recall reading somewhere that using decimal entities is more widely supported than using hexadecimal, but I can\'t seem to find the source for that now though. (And there cannot be many browsers out there which does not support the hexadecimal entities.)Note: Adding / and \' to the list of escaped characters isn\'t all that useful, since they do not have any special meaning in HTML and do not need to be escaped.EDIT 2: The original function used a variable (chr) to store the object needed for the .replace() callback. This variable also needed an extra anonymous function to scope it, making the function (needlessly) a little bit bigger and more complex.I haven\'t tested which of the two versions are faster. If you do, feel free to add info and links about it here.Easy enough to use underscore:Underscore is a utility library that provides a lot of features that native js doesn\'t provide. There\'s also lodash which is the same API as underscore but was rewritten to be more performant.Here is a clean, clear JavaScript function. It will escape text such as "a few < many" into "a few &lt; many".Try Underscore.string lib, it works with jQuery.output:After last tests I can recommend fastest and completely cross browser compatible native java script (DOM) solution:If you repeat it many times you can do it with once prepared variables:Look at my final performance comparison (stack question).I realize how late I am to this party, but I have a very easy solution that does not require jQuery.Edit: This does not escape quotes. The only case where quotes would need to be escaped is if the content is going to be pasted inline to an attribute within an HTML string. It is hard for me to imagine a case where doing this would be good design.Edit 2: If performance is crucial, the highest performance solution (by about 50%) is still a series of regex replaces. Modern browsers will detect that the regular expressions contain no operators, just a string, and collapse all of them into a single operation.I\'ve enhanced the mustache.js example adding the escapeHTML() method to the string object.That way it is quite easy to use "Some <text>, more Text&Text".escapeHTML()escape() and unescape() are intended to encode / decode strings for URLs, not HTML.Actually, I use the following snippet to do the trick that doesn\'t require any framework:If you have underscore.js, use _.escape (more efficient than the jQuery method posted above):If your\'re going the regex route, there\'s an error in tghw\'s example above.This is a nice safe example...No global variables, some memory optimization.\nUsage: result is: You can easily do it with vanilla js.Simply add a text node the document. \nIt will be escaped by the browser.2 simple methods that require NO JQUERY...You can encode all characters in your string like this:Or just target the main characters to worry about &, line breaks, <, >, " and \' like:works like a charmThis answer provides the jQuery and normal JS methods, but this is shortest without using the DOM:Escaped string: It%27s%20%3E%2020%25%20less%20complicated%20this%20way.If the escaped spaces bother you, try:Escaped string: It%27s %3E 20%25 less complicated this way.Unfortunately, the escape() function was deprecated in JavaScript version 1.5. encodeURI() or encodeURIComponent() are alternatives, but they ignore \', so the last line of code would turn into this:All major browsers still support the short code, and given the number of old websites, i doubt that will change soon.If you are saving this information in a database, its wrong to escape HTML using a client-side script, this should be done in the server. Otherwise its easy to bypass your XSS protection.To make my point clear, here is a exemple using one of the answers:Lets say you are using the function escapeHtml to escape the Html from a comment in your blog and then posting it to your server.The user could:If the user paste this snippet in the console it would bypass the XSS validation:All solutions are useless if you dont prevent re-escape, e.g. most solutions would keep escaping & to &amp;.