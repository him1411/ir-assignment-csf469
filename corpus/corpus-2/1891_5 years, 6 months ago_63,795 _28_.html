In the following program you can see that for each value slightly less that .5 is rounded down, except for 0.5.printsI am using Java 6 update 31.SummaryIn Java 6 (and presumably earlier), round(x) is implemented as floor(x+0.5).1   This is a specification bug, for precisely this one pathological case.2  Java 7 no longer mandates this broken implementation.3The problem0.5+0.49999999999999994 is exactly 1 in double precision:This is because 0.49999999999999994 has a smaller exponent than 0.5, so when they\'re added, its mantissa is shifted, and the ULP gets bigger.The solutionSince Java 7, OpenJDK (for example) implements it thus:4\n1. http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html#round%28double%29\n\n2. http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6430675 (credits to @SimonNickerson for finding this)\n\n3. http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html#round%28double%29\n\n4. http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/lang/Math.java#Math.round%28double%29\nThis appears to be a known bug (Java bug 6430675: Math.round has surprising behavior for 0x1.fffffffffffffp-2) which has been fixed in Java 7.source code in JDK 6source code in JDK 7When the value is 0.49999999999999994d, in JDK 6, it will call floor and hence returns 1 but in JDK 7, the if condition is checking whether the number is greatest double value less than 0.5 or not. As in this case the number is not the greatest double value less than 0.5, so else block returns 0.You can try 0.49999999999999999d, which will return 1 but not 0, because this is the greatest double value less than 0.5.I\'ve got the same on jdk 1.6 32bit, but on java 7 64bit I\'ve go 0 for 0.49999999999999994 rounded is 0 and the last line is not printed. It seems to be VM issue, however, using floating points, you should expect the results to differ a bit on various environments (CPU, 32- or 64-bit mode)And, when using round or inverting matrixes or etc., this bits can make a huge difference.x64 output:The answer hereafter is an excerpt of an oracle bug report at http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6430675. Visit the link for the full explanation.The methods {Math, StrictMath.round are operationally defined asfor double arguments.  While this definition usually works as expected, it gives the surprising result of 1, rather than 0, for 0x1.fffffffffffffp-2 (0.49999999999999994).The value 0.49999999999999994 is the greatest floating-point value less than 0.5.  As a hexadecimal floating-point literal its value is 0x1.fffffffffffffp-2, which is equal to (2 - 2^52) * 2^-2. == (0.5 - 2^54).  Therefore, the exact value of the sumis 1 - 2^54.  This is halfway between the two adjacent floating-point numbers (1 - 2^53) and 1.  In the IEEE 754 arithmetic round to nearest even rounding mode used by Java, when a floating-point results is inexact, the closer of the two representable floating-point values which bracket the exact result must be returned; if both values are equally close, the one which its last bit zero is returned.  In this case the correct return value from the add is 1, not the greatest value less than 1.While the method is operating as defined, the behavior on this input is very surprising; the specification coudl be ameneded to something more like "Round to the closest long, rounding ties up," which would allow the behavior on this input to be changed.