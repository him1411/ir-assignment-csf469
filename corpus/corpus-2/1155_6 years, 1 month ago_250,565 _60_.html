I used to use CShell (csh), which lets you make an alias that takes a parameter. The notation was something likeIn Bash, this does not seem to work. Given that Bash has a multitude of useful features, I would assume that this one has been implemented but I am wondering how.Bash alias does not directly accept parameters. You will have to create a function and alias that.alias does not accept parameters but a function can be called just like an alias. For example:By the way, Bash functions defined in your .bashrc and other files are available as commands within your shell. So for instance you can call the earlier function like this Refining the answer above, you can get 1-line syntax like you can for aliases, which is more convenient for ad-hoc definitions in a shell or .bashrc files:Don\'t forget the semi-colon before the closing right-bracket. Similarly, for the actual question:Or:The question is simply asked wrong.  You don\'t make an alias that takes parameters because alias just adds a second name for something that already exists.  The functionality the OP wants is the function command to create a new function.  You do not need to alias the function as the function already has a name.I think you want something like this :That\'s it!  You can use parameters $1, $2, $3, etc, or just stuff them all with $@Its far easier and more readable  to use a function than an alias to put arguments in the middle of a command. If you read on, you\'ll learn things that you don\'t need to know about shell argument processing. Knowledge is dangerous. Just get the outcome you want, before the dark side forever controls your destiny.bash aliases do accept arguments, but only at the end:Putting arguments into the middle of command via alias is indeed possible but it gets ugly.If you like circumventing limitations and doing what others say is impossible, here\'s the recipe. Just don\'t blame me if your hair gets frazzled and your face ends up covered in soot mad-scientist-style.The workaround is to pass the arguments that alias accepts only at the end to a wrapper that will insert them in the middle and then execute your command.If you\'re really against using a function per se, you can use:You can replace $@ with $1 if you only want the first argument.Explanation 1This creates a temporary function f, which is passed the arguments (note that f is called at the very end). The unset -f removes the function definition as the alias is executed so it doesn\'t hang around afterwards.You can also use a subshell:Explanation 2The alias builds a command like:Comments: The placeholder _ is required, but it could be anything. It gets set to sh\'s $0, and is required so that the first of the user-given arguments don\'t get consumed. Demonstration:The single-quotes inside single-quotes are required. Here\'s an example of it not working with double quotes:Here the values of the interactive shell\'s $0 and $@ are replaced into the double quoted before it is passed to sh. Here\'s proof:The single quotes ensure that these variables are not interpreted by interactive shell, and are passed literally to sh -c.You could use double-quotes and \\$@, but best practice is to quote your arguments (as they may contain spaces), and \\"\\$@\\" looks even uglier, but may help you win an obfuscation contest where frazzled hair is a prerequisite for entry.An alternative solution is to use marker, a tool I\'ve created recently that allows you to "bookmark" command templates and easily place cursor at command place-holders:  I found that most of time, I\'m using shell functions so I don\'t have to write frequently used commands again and again in the command-line. The issue of using functions for this use case, is adding new terms to my command vocabulary and having to remember what functions parameters refer to in the real-command. Marker goal is to eliminate that mental burden.Here\'s are three examples of functions I have in my ~/.bashrc, that are essentially aliases that accept a parameter:...References:NB: In case the idea isn\'t obvious, it is a bad idea to use aliases for anything but aliases, the first one being the \'function in an alias\' and the second one being the \'hard to read redirect/source\'. Also, there are flaws (which i thought would be obvious, but just in case you are confused: I do not mean them to actually be used... anywhere!)................................................................................................................................................I\'ve answered this before, and it has always been like this in the past:which is fine and good, unless you are avoiding the use of functions all together. in which case you can take advantage of bash\'s vast ability to redirect text:They are both about the same length give or take a few characters. The real kicker is the time difference, the top being the \'function method\' and the bottom being the \'redirect-source\' method. To prove this theory, the timing speaks for itself:This is the bottom part of about 200 results, done at random intervals. It seems that function creation/destruction takes more time than redirection. Hopefully this will help future visitors to this question (didn\'t want to keep it to myself).If you\'re looking for a generic way to apply all params to a function, not just one or two or some other hardcoded amount, you can do that this way:So in the example above, i pass all parameters from when i run runjar to the alias.For example, if i did runjar hi there it would end up actually running java -jar myjar.jar hi there. If i did runjar one two three it would  run java -jar myjar.jar one two three.I like this $@ - based solution because it works with any number of params. For taking parameters, you should use functions!However $@ get interpreted when creating the alias instead of during the execution of the alias and escaping the $ doesn\xe2\x80\x99t work either. How do I solve this problem?You need to use shell function instead of an alias to get rid of this problem. You can define foo as follows:ORFinally, call your foo() using the following syntax:Make sure you add your foo() to ~/.bash_profile or ~/.zshrc file.In your case, this will workFunctions are indeed almost always the answer as already amply contributed and confirmed by this quote from the man page: "For almost every purpose, aliases are superseded by shell functions."For completeness and because this can be useful (marginally more lightweight syntax) it could be noted that when the parameter(s) follow the alias, they can still be used (although this wouldn\'t address the OP\'s requirement).  This is probably easiest to demonstrate with an example:allows me to type smth like ssh_disc myhost, which gets expanded as expected as: ssh -O stop myhost This can be useful for commands which take complex arguments (my memory isn\'t what it use t be anymore...)