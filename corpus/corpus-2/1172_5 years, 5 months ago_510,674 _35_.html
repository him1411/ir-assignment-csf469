I\'ve seen so many different standards for the JSON date format:Which one is the right one? Or best? Is there any sort of standard on this?JSON itself does not specify how dates should be represented, but JavaScript does.You should use the format emitted by Date\'s toJSON method:2012-04-23T18:25:43.511ZHere\'s why:It\'s human readable but also succinctIt sorts correctlyIt includes fractional seconds, which can help re-establish chronologyIt conforms to ISO 8601ISO 8601 has been well-established internationally for more than a decadeISO 8601 is endorsed by W3C, RFC3339, and XKCDThat being said, every date library ever written can understand "milliseconds since 1970". So for easy portability, ThiefMaster is right.JSON does not know anything about dates. What .NET does is a non-standard hack/extension.I would use a format that can be easily converted to a Date object in JavaScript, i.e. one that can be passed to new Date(...). The easiest and probably most portable format is the timestamp containing milliseconds since 1970.There is no right format; The JSON specification does not specify a format for exchanging dates which is why there are so many different ways to do it.The best format is arguably a date represented in 8601 format; it is a well known and widely used format and can be handled across many different languages, making it very well suited for interoperability. If you have control over the generated json, for example, you provide data to other systems in json format, choosing 8601 as the date interchange format is a good choice.If you do not have control over the generated json, for example, you are the consumer of json from several different existing systems, the best way of handling this is to have a date parsing utility function to handle the different formats expected.From RFC 7493 (The I-JSON Message Format ):I-JSON stands for either Internet JSON or Interoperable JSON, depending on who you ask.Protocols often contain data items that are designed to contain\n  timestamps or time durations.  It is RECOMMENDED that all such data\n  items be expressed as string values in ISO 8601 format, as specified\n  in RFC 3339, with the additional restrictions that uppercase rather\n  than lowercase letters be used, that the timezone be included not\n  defaulted, and that optional trailing seconds be included even when\n  their value is "00".  It is also RECOMMENDED that all data items\n  containing time durations conform to the "duration" production in\n  Appendix A of RFC 3339, with the same additional restrictions.Just for reference I\'ve seen this format used:It works with JSONP which is supported by the $.getJSON() function. Not sure I would go so far as to recommend this approach... just throwing it out there as a possibility because people are doing it this way.FWIW: Never use seconds since epoch in a communication protocol, nor milliseconds since epoch, because these are fraught with danger thanks to the randomized implementation of leap seconds (you have no idea whether sender and receiver both properly implement UTC leap seconds).Kind of a pet hate, but many people believe that UTC is just the new name for GMT -- wrong! If your system does not implement leap seconds then you are using GMT (often called UTC despite being incorrect). If you do fully implement leap seconds you really are using UTC. Future leap seconds cannot be known; they get published by the IERS as necessary and require constant updates. If you are running a system that attempts to implement leap seconds but contains and out-of-date reference table (more common than you might think) then you have neither GMT, nor UTC, you have a wonky system pretending to be UTC.These date counters are only compatible when expressed in a broken down format (y, m, d, etc). They are NEVER compatible in an epoch format. Keep that in mind.There is only one correct answer to this and most systems get it wrong.  Number of milliseconds since epoch, aka a 64 bit integer.  Time Zone is a UI concern and has no business in the app layer or db layer.  Why does your db care what time zone something is, when you know it\'s going to store it as a 64 bit integer then do the transformation calculations.Strip out the extraneous bits and just treat dates as numbers up to the UI.  You can use simple arithmetic operators to do queries and logic.In Sharepoint 2013, getting data in JSON there is no format to convert date into date only format, because in that date should be in ISO formatThis may be helpful for  youit is work for me with parse Server{\n    "ContractID": "203-17-DC0101-00003-10011",\n    "Supplier":"Sample Co., Ltd",\n    "Value":12345.80,\n    "Curency":"USD",\n    "StartDate": {\n                "__type": "Date",\n                "iso": "2017-08-22T06:11:00.000Z"\n            }\n}I think that really depends on the use case. In many cases it might be more beneficial to use a proper object model (instead of rendering the date to a string), like so:Admittedly this is more verbose than RFC 3339 but:I don\'t think that correct sorting (as noted by funroll for RFC 3339) is a feature that\'s really needed when serializing a date to JSON. Also that\'s only true for date-times having the same time zone offset.