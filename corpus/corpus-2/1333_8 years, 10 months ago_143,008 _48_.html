What\'s the difference?   From Understanding Weak References, by Ethan Nicholas:Weak referencesA weak reference, simply put, is a\n  reference that isn\'t strong enough to\n  force an object to remain in memory.\n  Weak references allow you to leverage\n  the garbage collector\'s ability to\n  determine reachability for you, so you\n  don\'t have to do it yourself. You\n  create a weak reference like this:and then\n  elsewhere in the code you can use\n  weakWidget.get() to get the actual\n  Widget object. Of course the weak\n  reference isn\'t strong enough to\n  prevent garbage collection, so you may\n  find (if there are no strong\n  references to the widget) that\n  weakWidget.get() suddenly starts\n  returning null....Soft referencesA soft reference is exactly like a\n  weak reference, except that it is less\n  eager to throw away the object to\n  which it refers. An object which is\n  only weakly reachable (the strongest\n  references to it are WeakReferences)\n  will be discarded at the next garbage\n  collection cycle, but an object which\n  is softly reachable will generally\n  stick around for a while.SoftReferences aren\'t required to\n  behave any differently than\n  WeakReferences, but in practice softly\n  reachable objects are generally\n  retained as long as memory is in\n  plentiful supply. This makes them an\n  excellent foundation for a cache, such\n  as the image cache described above,\n  since you can let the garbage\n  collector worry about both how\n  reachable the objects are (a strongly\n  reachable object will never be removed\n  from the cache) and how badly it needs\n  the memory they are consuming.And Peter Kessler added in a comment:The Sun JRE does treat SoftReferences differently from WeakReferences. We attempt to hold on to object referenced by a SoftReference if there isn\'t pressure on the available memory. One detail: the policy for the "-client" and "-server" JRE\'s are different: the -client JRE tries to keep your footprint small by preferring to clear SoftReferences rather than expand the heap, whereas the -server JRE tries to keep your performance high by preferring to expand the heap (if possible) rather than clear SoftReferences. One size does not fit all.Weak references are collected eagerly. If GC finds that an object is\nweakly reachable (reachable only through weak references), it\'ll clear the\nweak references to that object immediately. As such, they\'re good for\nkeeping a reference to an object for which your program also keeps\n(strongly referenced) "associated information" somewere, like cached\nreflection information about a class, or a wrapper for an object, etc.\nAnything that makes no sense to keep after the object it is associated\nwith is GC-ed. When the weak reference gets cleared, it gets enqueued in a\nreference queue that your code polls somewhere, and it discards the\nassociated objects as well. That is, you keep extra information about an\nobject, but that information is not needed once the object it refers to\ngoes away. Actually, in certain situations you can even subclass\nWeakReference and keep the associated extra information about the object\nin the fields of the WeakReference subclass. Another typical use of\nWeakReference is in conjunction with Maps for keeping canonical instances.SoftReferences on the other hand are good for caching external, recreatable resources\nas the GC typically delays clearing them. It is guaranteed though that all\nSoftReferences will get cleared before OutOfMemoryError is thrown, so they\ntheoretically can\'t cause an OOME[*].Typical use case example is keeping a parsed form of a contents from a\nfile. You\'d implement a system where you\'d load a file, parse it, and keep\na SoftReference to the root object of the parsed representation. Next time\nyou need the file, you\'ll try to retrieve it through the SoftReference. If\nyou can retrieve it, you spared yourself another load/parse, and if the GC\ncleared it in the meantime, you reload it. That way, you utilize free\nmemory for performance optimization, but don\'t risk an OOME.Now for the [*]. Keeping a SoftReference can\'t cause an OOME in itself. If\non the other hand you mistakenly use SoftReference for a task a WeakReference is meant\nto be used (namely, you keep information associated with an Object somehow\nstrongly referenced, and discard it when the Reference object gets\ncleared), you can run into OOME as your code that polls the ReferenceQueue\nand discards the associated objects might happen to not run in a timely\nfashion.So, the decision depends on usage\n- if you\'re caching information that is expensive to construct, but\nnonetheless reconstructible from other data, use soft references\n- if you\'re keeping a reference to a canonical instance of some data, or\nyou want to have a reference to an object without "owning" it (thus\npreventing it from being GC\'d), use a weak reference.In Java;  order from strongest to weakest, there are: Strong, Soft, Weak and Phantom  A Strong reference is a normal reference that protects the referred object from collection by GC. i.e. Never garbage collects. A Soft reference is eligible for collection by garbage collector, but probably won\'t be collected until its memory is needed. i.e. garbage collects before OutOfMemoryError.    A Weak reference is a reference that does not protect a referenced object from collection by GC. i.e. garbage collects when no Strong or Soft refs.  A Phantom reference is a reference to an object is phantomly referenced after it has been finalized, but before its allocated memory has been reclaimed.Source Analogy: Assume a JVM is a kingdom, Object is a king of the kingdom, and GC is an attacker of the kingdom who tries to kill the king(object).Weak Reference\nhttp://docs.oracle.com/javase/1.5.0/docs/api/java/lang/ref/WeakReference.htmlPrinciple: weak reference is related to garbage collection. Normally, object having one or more reference will not be eligible for garbage collection.\nThe above principle is not applicable when it is weak reference. If an object has only weak reference with other objects, then its ready for garbage collection.Let\'s look at the below example: We have an Map with Objects where Key is reference a object. Now, during the execution of the program we have made emp  = null. The Map holding the key makes no sense here as it is null. In the above situation, the object is not garbage collected. WeakHashMapWeakHashMap is one where the entries (key-to-value mappings) will be removed when it is no longer possible to retrieve them from the Map.Let me show the above example same with WeakHashMapOutput: Took 20 calls to System.gc() to result in aMap size of : 0. WeakHashMap has only weak references to the keys, not strong references like other Map classes. There are situations which you have to take care when the value or key is strongly referenced though you have used WeakHashMap. This can avoided by wrapping the object in a WeakReference.Soft References.Soft Reference is slightly stronger that weak reference. Soft reference allows for garbage collection, but begs the garbage collector to clear it only if there is no other option. The garbage collector does not aggressively collect softly reachable objects the way it does with weakly reachable ones -- instead it only collects softly reachable objects if it really "needs" the memory. Soft references are a way of saying to the garbage collector, "As long as memory isn\'t too tight, I\'d like to keep this object around. But if memory gets really tight, go ahead and collect it and I\'ll deal with that." The garbage collector is required to clear all soft references before it can throw OutOfMemoryError.The only real difference between a soft reference and a weak reference is that the garbage collector uses algorithms to decide whether or not to reclaim a softly reachable object, but always reclaims a weakly reachable object.SoftReference is designed for caches. When it is found that a WeakReference references an otherwise unreachable object, then it will get cleared immediately. SoftReference may be left as is. Typically there is some algorithm relating to the amount of free memory and the time last used to determine whether it should be cleared. The current Sun algorithm is to clear the reference if it has not been used in as many seconds as there are megabytes of memory free on the Java heap (configurable, server HotSpot checks against maximum possible heap as set by -Xmx). SoftReferences will be cleared before OutOfMemoryError is thrown, unless otherwise reachable.The six types of object reachability states in Java -For more details: https://www.artima.com/insidejvm/ed2/gc16.html \xc2\xab collapse One should be aware that a weakly referenced object will only get collected when it has ONLY weak reference(s). If it has so much as one strong reference, it does not get collected no matter how many weak references it has.Per the doc, loose WeakReferences must be cleared by a running GC.Per the doc, loose SoftReferences must be cleared before OOM is thrown.That\'s the only real difference. Everything else is not part of the contract. (I\'ll assume the latest docs are contractual.)SoftReferences are useful. Memory-sensitive caches use SoftReferences, not WeakReferences.\nAs for incorrect use of WeakReference, the list is endless:a lousy hack to implement priority-2 softreference such that you don\'t have to write one, yet it doesn\'t work as expected because the cache would be cleared on every GC run, even when there is spare memory. See  https://stackoverflow.com/a/3243242/632951 for phails. (Besides, what if you need more than 2 levels of cache priority? You\'d still gotta need a real library for it.)a lousy hack to associate data with an object of an existing class, yet it creates a memory leak (OutOfMemoryError) when your GC decides to take a break after your weakreferences are created. Besides, it\'s beyond ugly: A better approach is to use tuples. a lousy hack to associate data with an object of an existing class, where the class  has the nerve to make itself non-subclassable, and is used in an existing function code which you need to call. In such a case, the proper solution is to either edit the class and make it subclassable, or edit the function and make it take an interface instead of a class, or use an alternative function.