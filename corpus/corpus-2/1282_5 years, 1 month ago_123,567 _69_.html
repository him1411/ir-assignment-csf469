How would you divide a number by 3 without using *, /, +, -, %,  operators?The number may be signed or unsigned.This is a simple function which performs the desired operation. But it requires the + operator, so all you have left to do is to add the values with bit-operators:As Jim commented this works because:So sum += a, n = a + b, and iterate When a == 0 (n < 4), sum += floor(n / 3); i.e. 1, if n == 3, else 0Idiotic conditions call for an idiotic solution:If also the decimal part is needed, just declare result as double and add to it the result of fmod(number,divisor).Explanation of how it worksIf you write 30 bytes then read back the file in units of 3, you get 10 "units".  30 / 3 = 10You can use (platform dependent) inline assembly, e.g., for x86: (also works for negative numbers)Use itoa to convert to a base 3 string. Drop the last trit and convert back to base 10.(note: see Edit 2 below for a better version!)This is not as tricky as it sounds, because you said "without using the [..] + [..] operators". See below, if you want to forbid using the + character all together.then just say div_by(100,3) to divide 100 by 3.We use the first argument of the add function because we cannot denote the type of pointers without using the * character, except in function parameter lists, where the syntax type[] is identical to type* const.FWIW, you can easily implement a multiplication function using a similar trick to use the 0x55555556 trick proposed by AndreyT:It is easily possible on the Setun computer.To divide an integer by 3, shift right by 1 place.I\'m not sure whether it\'s strictly possible to implement a conforming C compiler on such a platform though. We might have to stretch the rules a bit, like interpreting "at least 8 bits" as "capable of holding at least integers from -128 to +127".Here\'s my solution: First, note that Now, the rest is simple!Now all we have to do is add together these bit shifted values of a! Oops! We can\'t add though, so instead, we\'ll have to write an add function using bit-wise operators! If you\'re familiar with bit-wise operators, my solution should look fairly simple... but just in-case you aren\'t, I\'ll walk through an example at the end.Another thing to note is that first I shift left by 30! This is to make sure that the fractions don\'t get rounded off.It\'s simply carry addition that you learned as a child!This implementation failed because we can not add all terms of the equation:Suppose the reslut of div_by_3(a) = x, then x <= floor(f(a, i)) < a / 3. When a = 3k, we get wrong answer.Since it\'s from Oracle, how about a lookup table of pre calculated answers. :-D To divide a 32-bit number by 3 one can multiply it by 0x55555556 and then take the upper 32 bits of the 64 bit result.Now all that\'s left to do is to implement multiplication using bit operations and shifts...Yet another solution. This should handle all ints (including negative ints) except the min value of an int, which would need to be handled as a hard coded exception. This basically does division by subtraction but only using bit operators (shifts, xor, & and complement). For faster speed, it subtracts 3 * (decreasing powers of 2). In c#, it executes around 444 of these DivideBy3 calls per millisecond (2.2 seconds for 1,000,000 divides), so not horrendously slow, but no where near as fast as a simple x/3. By comparison, Coodey\'s nice solution is about 5 times faster than this one.This is c# because that\'s what I had handy, but differences from c should be minor.It\'s really quite easy.(I have of course omitted some of the program for the sake of brevity.) If the programmer gets tired of typing this all out, I\'m sure that he or she could write a separate program to generate it for him. I happen to be aware of a certain operator, /, that would simplify his job immensely.Using counters is a basic solution:It is also easy to perform a modulus function, check the comments.This one is the classical division algorithm in base 2:Would it be cheating to use the / operator "behind the scenes" by using eval and string concatenation?For example, in Javacript, you can doWrite the program in Pascal and use the DIV operator.Since the question is tagged c, you can probably write a function in Pascal and call it from your C program; the method for doing so is system-specific.But here\'s an example that works on my Ubuntu system with the Free Pascal fp-compiler package installed.  (I\'m doing this out of sheer misplaced stubbornness; I make no claim that this is useful.)divide_by_3.pas :main.c :To build:Sample execution:Using BC Math in PHP:MySQL (it\'s an interview from Oracle)Pascal:x86-64 assembly language:First that I\'ve come up with.EDIT: Sorry, I didn\'t notice the tag C. But you can use the idea about string formatting, I guess...Didn\'t cross-check if this answer is already published. If the program need to be extended to floating numbers, the numbers can be multiplied by 10*number of precision needed and then the following code can be again applied.  This should work for any divisor, not only three. Currently only for unsigned, but extending it to signed should not be that difficult.The following script generates a C program that solves the problem without using the operators * / + - %:Using Hacker\'s Delight Magic number calculator Where fma is a standard library function defined in math.h header.How about this approach (c#)?Solution using fma() library function, works for any positive number:See my another answer.Use cblas, included as part of OS X\'s Accelerate framework. I think the right answer is:Why would I not use a basic operator to do a basic operation?first:then figure out how to solve x/(1 - y):with y = 1/4:although it uses +, but somebody already implements add by bitwise opOkay I think we all agree that this isn\'t a real world problem. So just for fun, here\'s how to do it with Ada and multithreading: