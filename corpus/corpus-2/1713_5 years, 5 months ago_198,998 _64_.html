Problem: Fragment onResume() in ViewPager is fired before the fragment becomes actually visible.For example, I have 2 fragments with ViewPager and FragmentPagerAdapter. The second fragment is only available for authorized users and I need to ask the user to log in when the fragment becomes visible (using an alert dialog).BUT the ViewPager creates the second fragment when the first is visible in order to cache the second fragment and makes it visible when the user starts swiping.So the onResume() event is fired in the second fragment long before it becomes visible. That\'s why I\'m trying to find an event which fires when the second fragment becomes visible to show a dialog at the appropriate moment.How can this be done?UPDATE: Android Support Library (rev 11) finally fixed the user visible hint issue, now if you use support library for fragments, then you can safely use getUserVisibleHint() or override setUserVisibleHint() to capture the changes as described by gorn\'s answer.UPDATE 1 Here is one small problem with getUserVisibleHint(). This value is by default true.So there might be a problem when you try to use it before setUserVisibleHint() was invoked. As a workaround you might set value in onCreate method like this.The outdated answer:In most use cases, ViewPager only show one page at a time, but the pre-cached fragments are also put to "visible" state (actually invisible) if you are using FragmentStatePagerAdapter in Android Support Library pre-r11.I override :To capture the focus state of fragment, which I think is the most suitable state of the "visibility" you mean, since only one fragment in ViewPager can actually place its menu items together with parent activity\'s items.How to determine when Fragment becomes visible in ViewPagerYou can do the following by overriding setUserVisibleHint in your Fragment:This seems to restore the normal onResume() behavior that you would expect.  It plays well with pressing the home key to leave the app and then re-entering the app.  onResume() is not called twice in a row.Here is another way using onPageChangeListener:setUserVisibleHint() gets called sometimes before onCreateView() and sometimes after which causes trouble. To overcome this you need to check isResumed() as well inside setUserVisibleHint() method. But in this case i realized setUserVisibleHint() gets called only if Fragment is resumed and visible, NOT when Created.So if you want to update something when Fragment is visible, put your update function both in onCreate() and setUserVisibleHint():UPDATE: Still i realized myUIUpdate() gets called twice sometimes, the reason is, if you have 3 tabs and this code is on 2nd tab, when you first open 1st tab, the 2nd tab is also created even it is not visible and myUIUpdate() is called. Then when you swipe to 2nd tab, myUIUpdate() from if (visible && isResumed()) is called and as a result,myUIUpdate() may get called twice in a second. The other problem is !visible in setUserVisibleHint gets called both 1) when you go out of fragment screen and 2) before it is created, when you switch to fragment screen first time.Solution: Explanation: fragmentResume,fragmentVisible: Makes sure myUIUpdate() in onCreateView() is called only when fragment is created and visible, not on resume. It also solves problem when you are at 1st tab, 2nd tab is created even if it is not visible. This solves that and checks if fragment screen is visible when onCreate.fragmentOnCreated: Makes sure fragment is not visible, and not called when you create fragment first time. So now this if clause only gets called when you swipe out of fragment.Update\nYou can put all this code in BaseFragment code like this and override method.Override setPrimaryItem() in the FragmentPagerAdapter subclass. I use this method, and it works well.Override Fragment.onHiddenChanged() for that.public\xc2\xa0void\xc2\xa0onHiddenChanged(boolean\xc2\xa0hidden)Called when the hidden state (as returned by isHidden()) of the fragment has changed. Fragments start out not hidden; this will be called whenever the fragment changes state from that.Parameters \n  hidden - boolean: True if the fragment is now hidden, false if it is not visible. I figured out that onCreateOptionsMenu and onPrepareOptionsMenu methods called only in the case of the fragment really visible. I could not found any method which behaves like these, also I tried OnPageChangeListener but it did not work for the situations, for example, I need a variable initialized in onCreate method.So these two methods can be used for this problem as a workaround, specifically for little and short jobs.I think, this is the better solution but not the best. I will use this but wait for better solution at the same time.Regards.Another solution posted here overriding setPrimaryItem in the pageradapter by kris larson almost worked for me. But this method is called multiple times for each setup. Also I got NPE from views, etc. in the fragment as this is not ready the first few times this method is called. With the following changes this worked for me:Add following Code inside fragmentNote that setUserVisibleHint(false) is not called on activity / fragment stop.  You\'ll still need to check start/stop to properly register/unregister any listeners/etc.Also, you\'ll get setUserVisibleHint(false) if your fragment starts in a non-visible state; you don\'t want to unregister there since you\'ve never registered before in that case.I encountered this problem when I was trying to get a timer to fire when the fragment in the viewpager was on-screen for the user to see. The timer always started just before the fragment was seen by the user.\nThis is because the onResume() method in the fragment is called before we can see the fragment.My solution was to do a check in the onResume() method. I wanted to call a certain method \'foo()\' when fragment 8 was the view pagers current fragment. Hope this helps. I\'ve seen this problem pop up a lot. This seems to be the simplest solution I\'ve seen. A lot of others are not compatible with lower APIs etc.I had the same issue. ViewPager executes other fragment life cycle events and I could not change that behavior. I wrote a simple pager using fragments and available animations.\nSimplePager\n You need loadData() inside both setUserVisibleHint and onCreateView because setUserVisibleHint can call before onCreateView so if we just always loadData() inside setUserVisibleHint, we can get NullPointerExceptionFor example, my viewpager have 3 tabs (Tab1, Tab2, Tab3).\nAt first time I go to this viewpager, the function will call in order likeAt this case, loadData() get called inside onCreateView of Tab1 (we will not get any NullPointerException)Then I go to Tab2, the the function will call in order likeAt this case loadData() get called inside setUserVisibleHint of Tab2 like we expectedWe have a special case with MVP where the fragment needs to notify the presenter that the view has become visible, and the presenter is injected by Dagger in fragment.onAttach().setUserVisibleHint() is not enough, we\'ve detected 3 different cases that needed to be addressed (onAttach() is mentioned so that you know when the presenter is available):Fragment has just been created. The system makes the following calls:Fragment already created and home button is pressed. When restoring the app to foreground, this is called:Orientation change:We only want the visibility hint to get to the presenter once, so this is how we do it:I encountered the same problem while working with FragmentStatePagerAdapters and 3 tabs. I had to show a Dilaog whenever the 1st tab was clicked and hide it on clicking other tabs.Overriding setUserVisibleHint() alone didn\'t help to find the current visible fragment.When clicking from 3rd tab -----> 1st tab.\nIt triggered twice for 2nd fragment and for 1st fragment.\nI combined it with isResumed() method.In the Fragment use the GestureDetector.OnGestureListenerand and when that fires you will know that "this" Fragment is visibleIn the Fragment use the GestureDetectorI handle the visible state at here: Check fragment is currently visible or not in android?. \nI split the Fragment\'s switch type into three ways, and if nested use, handle the sub Fragment\'s visible state in it\'s parent Fragment. It work for me.I overrode the Count method of the associated FragmentStatePagerAdapter and have it return the total count minus the number of pages to hide:So, if there are 3 fragments initially added to the ViewPager, and only the first 2 should be shown until some condition is met, override the page count by setting TrimmedPages to 1 and it should only show the first two pages.This works good for pages on the end, but wont really help for ones on the beginning or middle (though there are plenty of ways of doing this).