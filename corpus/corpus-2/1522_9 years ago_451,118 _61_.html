Is there a way to get the path for the assembly in which the current code resides?  I do not want the path of the calling assembly, just the one containing the code. Basically my unit test needs to read some xml test files which are located relative to the  dll.  I want the path to always resolve correctly regardless of whether the testing dll is run from TestDriven.NET, the MbUnit GUI or something else.Edit: People seem to be misunderstanding what I\'m asking.My test library is located in say C:\\projects\\myapplication\\daotests\\bin\\Debug\\daotests.dlland I would like to get this path:C:\\projects\\myapplication\\daotests\\bin\\Debug\\The three suggestions so far fail me when I run from the MbUnit Gui:Environment.CurrentDirectory\ngives c:\\Program Files\\MbUnitSystem.Reflection.Assembly.GetAssembly(typeof(DaoTests)).Location\ngives C:\\Documents and\nSettings\\george\\Local\nSettings\\Temp\\ ....\\DaoTests.dllSystem.Reflection.Assembly.GetExecutingAssembly().Location\ngives the same as the previous.I\'ve defined the following property as we use this often in unit testing. The Assembly.Location property sometimes gives you some funny results when using NUnit (where assemblies run from a temporary folder), so I prefer to use CodeBase which gives you the path in URI format, then UriBuild.UnescapeDataString removes the File:// at the beginning, and GetDirectoryName changes it to the normal windows format.Does this help?It\'s as simple as this:Same as John\'s answer, but a slightly less verbose extension method.Now you can do:or if you prefer:The only solution that worked for me when using CodeBase and UNC Network shares was:It also works with normal URIs too.This should work, unless the assembly is shadow copied:What about this:I suspect that the real issue here is that your test runner is copying your assembly to a different location.  There\'s no way at runtime to tell where the assembly was copied from, but you can probably flip a switch to tell the test runner to run the assembly from where it is and not to copy it to a shadow directory.Such a switch is likely to be different for each test runner, of course.Have you considered embedding your XML data as resources inside your test assembly?works with MbUnit GUI.Here is a VB.NET port of John Sibly\'s code. Visual Basic is not case sensitive, so a couple of his variable names were colliding with type names.I\'ve been using Assembly.CodeBase instead of Location:It\'s been working, but I\'m no longer sure it is 100% correct. The page at http://blogs.msdn.com/suzcook/archive/2003/06/26/assembly-codebase-vs-assembly-location.aspx says:"The CodeBase is a URL to the place where the file was found, while the Location is the path where it was actually loaded. For example, if the assembly was downloaded from the internet, its CodeBase may start with "http://", but its Location may start with "C:\\". If the file was shadow-copied, the Location would be the path to the copy of the file in the shadow copy dir.\nIt\xe2\x80\x99s also good to know that the CodeBase is not guaranteed to be set for assemblies in the GAC. Location will always be set for assemblies loaded from disk, however."You may want to use CodeBase instead of Location.The current directory where you exist.If you copy the .xml file out with build you should find it.orAs far as I can tell, most of the other answers have a few problems.The correct way to do this for a disk-based (as opposed to web-based), non-GACed assembly is to use the currently executing assembly\'s CodeBase property.This returns a URL (file://). Instead of messing around with string manipulation or UnescapeDataString, this can be converted with minimal fuss by leveraging the LocalPath property of Uri. In all these years, nobody has actually mentioned this one. A trick I learned from the awesome ApprovalTests project. The trick is that you use the debugging information in the assembly to find the original directory.This will not work in RELEASE mode, nor with optimizations enabled, nor on a machine different from the one it was compiled on.But this will get you paths that are relative to the location of the source code file you call it fromYou can get the bin path by\n    AppDomain.CurrentDomain.RelativeSearchPathThis is what I came up with. In between web projects, unit tests (nunit and resharper test runner); I found this worked for me.I have been looking for code to detect what configuration the build is in, Debug/Release/CustomName. Alas, the #if DEBUG. So if someone can improve that!Feel free to edit and improve.Getting app folder. Useful for web roots, unittests to get the folder of test files.Getting bin folder: Useful for executing assemblies using reflection. If files are copied there due to build properties. This should work:I am using this to deploy DLL file libraries along with some configuration file (this is to use log4net from within the DLL file).I find my solution adequate for the retrieval of the location.I got the same behaviour in the NUnit in the past. By default NUnit copies your assembly into the temp directory. You can change this behaviour in the NUnit settings:Maybe TestDriven.NET and MbUnit GUI have the same settings.How about this ...  Then just hack off what you do not needAll of the proposed answers work when the developer can change the code to include the required snippet, but if you wanted to do this without changing any code you could use Process Explorer. It will list all executing dlls on the system, you may need to determine the process id of your running application, but that is usually not too difficult. I\'ve written a full description of how do this for a dll inside II - http://nodogmablog.bryanhogan.net/2016/09/locating-and-checking-an-executing-dll-on-a-running-web-server/I use this to get the path to the Bin Directory:You get this result:"c:\\users\\ricooley\\documents\\visual studio\n  2010\\Projects\\Windows_Test_Project\\Windows_Test_Project\\bin"Web application?