I\'ve recently run into a rather nasty bug, wherein the code was loading a <select> dynamically via JavaScript.  This dynamically loaded <select> had a pre-selected value.  In IE6, we already had code to fix the selected <option>, because sometimes the <select>\'s selectedIndex value would be out of sync with the selected <option>\'s index attribute, as below:However, this code wasn\'t working.  Even though the field\'s selectedIndex was being set correctly, the wrong index would end up being selected.  However, if I stuck an alert() statement in at the right time, the correct option would be selected.  Thinking this might be some sort of timing issue, I tried something random that I\'d seen in code before:And this worked!I\'ve got a solution for my problem, but I\'m uneasy that I don\'t know exactly why this fixes my problem.  Does anyone have an official explanation?  What browser issue am I avoiding by calling my function "later" using setTimeout()?This works because you\'re doing co-operative multi-tasking. A browser has to do a number of things pretty much all at once, and just one of those is execute JavaScript. But one of the things JavaScript is very often used for is to ask the browser to build a display element. This is often assumed to be done synchronously (particularly as JavaScript is not executed in parallel) but there is no guarantee this is the case and JavaScript does not have a well-defined mechanism for waiting. The solution is to "pause" the JavaScript execution to let the rendering threads catch up. And this is the effect that setTimeout() with a timeout of 0 does. It is like a thread/process yield in C. Although it seems to say "run this immediately" it actually gives the browser a chance to finish doing some non-JavaScript things that have been waiting to finish before attending to this new piece of JavaScript.(In actuality, setTimeout() re-queues the new JavaScript at the end of the execution queue. See the comments for links to a longer explanation.)IE6 just happens to be more prone to this error, but I have seen it occur on older versions of Mozilla and in Firefox.Preface:IMPORTANT NOTE: While it\'s most upvoted and accepted, the accepted answer by @staticsan actually is NOT CORRECT! - see David Mulder\'s comment for explanation why.Some of the other answers are correct but don\'t actually illustrate what the problem being solved is, so I created this answer to present that detailed illustration.As such, I am posting a detailed walk-through of what the browser does and how using setTimeout() helps. It looks longish but is actually very simple and straightforward - I just made it very detailed. UPDATE: I have made a JSFiddle to live-demonstrate the explanation below: http://jsfiddle.net/C2YBE/31/ . Many thanks to @ThangChung for helping to kickstart it.UPDATE2: Just in case JSFiddle web site dies, or deletes the code, I added the code to this answer at the very end.DETAILS:Imagine a web app with a "do something" button and a result div.The onClick handler for "do something" button calls a function "LongCalc()", which does 2 things:Makes a very long calculation (say takes 3 min)Prints the results of calculation into the result div.Now, your users start testing this, click "do something" button, and the page sits there doing seemingly nothing for 3 minutes, they get restless, click the button again, wait 1 min, nothing happens, click button again... The problem is obvious - you want a "Status" DIV, which shows what\'s going on. Let\'s see how that works.So you add a "Status" DIV (initially empty), and modify the onclick handler (function LongCalc()) to do 4 things:Populate the status "Calculating... may take ~3 minutes" into status DIVMakes a very long calculation (say takes 3 min)Prints the results of calculation into the result div.Populate the status "Calculation done" into status DIVAnd, you happily give the app to users to re-test.They come back to you looking very angry. And explain that when they clicked the button, the Status DIV never got updated with "Calculating..." status!!!You scratch your head, ask around on StackOverflow (or read docs or google), and realize the problem:The browser places all its "TODO" tasks (both UI tasks and JavaScript commands) resulting from events into a single queue. And unfortunately, re-drawing the "Status" DIV with the new "Calculating..." value is a separate TODO which goes to the end of the queue!Here\'s a breakdown of the events during your user\'s test, contents of the queue after each event:So, the underlying problem is that the re-draw event for "Status" DIV is placed on the queue at the end, AFTER the "execute line 2" event which takes 3 minutes, so the actual re-draw doesn\'t happen until AFTER the calculation is done.To the rescue comes the setTimeout(). How does it help? Because by calling long-executing code via setTimeout, you actually create 2 events: setTimeout execution itself, and (due to 0 timeout), separate queue entry for the code being executed.So, to fix your problem, you modify your onClick handler to be TWO statements (in a new function or just a block within onClick):Populate the status "Calculating... may take ~3 minutes" into status DIVExecute setTimeout() with 0 timeout and a call to LongCalc() function. LongCalc() function is almost the same as last time but obviously doesn\'t have "Calculating..." status DIV update as first step; and instead starts the calculation right away.So, what does the event sequence and the queue look like now?Hooray! The Status DIV just got updated to "Calculating..." before the calculation started!!!Below is the sample code from the JSFiddle illustrating these examples: http://jsfiddle.net/C2YBE/31/ :HTML code:JavaScript code: (Executed on onDomReady and may require jQuery 1.9)Take a look at John Resig\'s article about How JavaScript Timers Work. When you set a timeout, it actually queues the asynchronous code until the engine executes the current call stack.Most browsers have a process called main thread, that is responsible for execute some JavaScript tasks, UI updates e.g.: painting, redraw or reflow, etc.Some JavaScript execution and UI update tasks are queued to the browser message queue, then are dispatched to the browser main thread to be executed.When UI updates are generated while the main thread is busy, the tasks are added into the message queue.setTimeout(fn, 0); add this fn to the end of the queue to be executed.\nIt schedules a task to be added on the message queue after a given amount of time.setTimeout() buys you some time until the DOM elements are loaded, even if is set to 0.Check this out: setTimeoutThere are conflicting upvoted answers here, and without proof there is no way to know whom to believe. Here is proof that @DVK is correct and @SalvadorDali is wrong. The latter claims:"And here is why: it is not possible to have setTimeout with a time\n  delay of 0 milliseconds. The Minimum value is determined by the\n  browser and it is not 0 milliseconds. Historically browsers sets this\n  minimum to 10 milliseconds, but the HTML5 specs and modern browsers\n  have it set at 4 milliseconds."The 4ms minimum timeout is irrelevant to what is happening. What really happens is that setTimeout pushes the callback function to the end of the execution queue. If after setTimeout(callback, 0) you have blocking code which takes several seconds to run, the callback will not be executed for several seconds, until the blocking code has finished. Try this code:Output is:One reason to do that is to defer the execution of code to a separate, subsequent event loop. When responding to a browser event of some kind (mouse click, for example), sometimes it\'s necessary to perform operations only after the current event is processed. The setTimeout() facility is the simplest way to do it.edit now that it\'s 2015 I should note that there\'s also requestAnimationFrame(), which isn\'t exactly the same but it\'s sufficiently close to setTimeout(fn, 0) that it\'s worth mentioning.This is an old questions with old answers. I wanted to add a new look at this problem and to answer why is this happens and not why is this useful.So you have two functions:and then call them in the following order f1(); f2(); just to see that the second one executed first. And here is why: it is not possible to have setTimeout with a time delay of 0 milliseconds. The Minimum value is determined by the browser and it is not 0 milliseconds. Historically browsers sets this minimum to 10 milliseconds, but the HTML5 specs and modern browsers have it set at 4 milliseconds. If nesting level is greater than 5, and timeout is less than 4, then\n  increase timeout to 4.Also from mozilla:To implement a 0 ms timeout in a modern browser, you can use\n  window.postMessage() as described here.P.S. information is taken after reading the following article.Since it is being passed a duration of 0, I suppose it is in order to remove the code passed to the setTimeout from the flow of execution. So if it\'s a function that could take a while, it won\'t prevent the subsequent code from executing.The other thing this does is push the function invocation to the bottom of the stack, preventing a stack overflow if you are recursively calling a function. This has the effect of a while loop but lets the JavaScript engine fire other asynchronous timers.The answers about execution loops and rendering the DOM before some other code completes are correct. Zero second timeouts in JavaScript help make the code pseudo-multithreaded, even though it is not.I want to add that the BEST value for a cross browser / cross platform zero-second timeout in JavaScript is actually about 20 milliseconds instead of 0 (zero), because many mobile browsers can\'t register timeouts smaller than 20 milliseconds due to clock limitations on AMD chips.Also, long-running processes that do not involve DOM manipulation should be sent to Web Workers now, as they provide true multithreaded execution of JavaScript.By calling setTimeout you give the page time to react to the whatever the user is doing. This is particularly helpful for functions run during page load. Some other cases where setTimeout is useful:You want to break a long-running loop or calculation into smaller components so that the browser doesn\'t appear to \'freeze\' or say "Script on page is busy".You want to disable a form submit button when clicked, but if you disable the button in the onClick handler the form will not be submitted. setTimeout with a time of zero does the trick, allowing the event to end, the form to begin submitting, then your button can be disabled.setTimout on 0 is also very useful in the pattern of setting up a deferred promise, which you want to return right away: