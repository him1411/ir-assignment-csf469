What does RESTful Authentication mean and how does it work?  I can\'t find a good overview on Google.  My only understanding is that you pass the session key (remeberal) in the URL, but this could be horribly wrong.How to handle authentication in a RESTful Client-Server architecture is a matter of debate.Commonly, it can be achieved, in the SOA over HTTP world via:You\'ll have to adapt, or even better mix those techniques, to match your software architecture at best.Each authentication scheme has its own PROs and CONs, depending on the purpose of your security policy and software architecture.HTTP basic auth over HTTPSThis first solution, based on the standard HTTPS protocol, is used by most web services.It\'s easy to implement, available by default on all browsers, but has some known draw-backs, like the awful authentication window displayed on the Browser, which will persist (there is no LogOut-like feature here), some server-side additional CPU consumption, and the fact that the user-name and password are transmitted (over HTTPS) into the Server (it should be more secure to let the password stay only on the client side, during keyboard entry, and be stored as secure hash on the Server).We may use Digest Authentication, but it requires also HTTPS, since it is vulnerable to MiM or Replay attacks, and is specific to HTTP.Session via CookiesTo be honest, a session managed on the Server is not truly Stateless.One possibility could be to maintain all data within the cookie content. And, by design, the cookie is handled on the Server side (Client in fact does even not try to interpret this cookie data: it just hands it back to the server on each successive request). But this cookie data is application state data, so the client should manage it, not the server, in a pure Stateless world.The cookie technique itself is HTTP-linked, so it\'s not truly RESTful, which should be protocol-independent, IMHO. It is vulnerable to MiM or Replay attacks.Granted via Token (OAuth2)An alternative is to put a token within the HTTP headers, so that the request is authenticated. This is what OAuth 2.0 does, for instance. See the RFC 6749:In short, this is very similar to a cookie, and suffers to the same issues: not stateless, relying on HTTP transmission details, and subject to a lot of security weaknesses - including MiM and Replay - so is to be used only over HTTPS.Query AuthenticationQuery Authentication consists in signing each RESTful request via some additional parameters on the URI. See this reference article. It was defined as such in this article:All REST queries must be authenticated by signing the query parameters\n  sorted in lower-case, alphabetical order using the private credential\n  as the signing token. Signing should occur before URL encoding the\n  query string.This technique is perhaps the more compatible with a Stateless architecture, and can also be implemented with a light session management (using in-memory sessions instead of DB persistence).For instance, here is a generic URI sample from the link above:should be transmitted as such:The string being signed is /object?apikey=Qwerty2010&timestamp=1261496500 and the signature is the SHA256 hash of that string using the private component of the API key.Server-side data caching can be always available. For instance, in our framework, we cache the responses at the SQL level, not at the URI level. So adding this extra parameter doesn\'t break the cache mechanism.See this article for some details about RESTful authentication in our client-server ORM/SOA/MVC framework, based on JSON and REST. Since we allow communication not only over HTTP/1.1, but also named pipes or GDI messages (locally), we tried to implement a truly RESTful authentication pattern, and not rely on HTTP specificity (like header or cookies).In practice, the upcoming MAC Tokens Authentication for OAuth 2.0 may be a huge improvement in respect to the "Granted by Token" current scheme. But this is still a work in progress, and is tied to HTTP transmission.ConclusionIt\'s worth concluding that REST is not only HTTP-based, even if, in practice, it\'s mostly implemented over HTTP. REST can use other communication layers. So a RESTful authentication is not just a synonym of HTTP authentication, whatever Google answers. It should even not use the HTTP mechanism at all, but shall be abstracted from the communication layer.I really doubt whether the people enthusiastically shouting "HTTP Authentication" ever tried making a browser-based application (instead of a machine-to-machine web service) with REST (no offense intended - I just don\'t think they ever faced the complications).Problems I found with using HTTP Authentication on RESTful services that produce HTML pages to be viewed in a browser are:A very insightful article that tackles these point by point is here, but this results to a lot of browser-specific javascript hackery, workarounds to workarounds, et cetera. As such, it is also not forward-compatible so will require constant maintenance as new browsers are released. I do not consider that clean and clear design, plus I feel it is a lot of extra work and headache just so that I can enthusiastically show my REST-badge to my friends.I believe cookies are the solution. But wait, cookies are evil, aren\'t they? No they\'re not, the way cookies are used often is evil. A cookie itself is just a piece of client-side information, just like the HTTP authentication info that the browser would keep track of while you browse. And this piece of client-side information is sent to the server at every request, again just like the HTTP Authentication info would be. Conceptually, the only difference is that the content of this piece of client-side state can be determined by the server as part of its response.By making sessions a RESTful resource with just the following rules:The only difference to HTTP Authentication, now, is that the authentication key is generated by the server and sent to the client who keeps sending it back, instead of the client computing it from the entered credentials.converter42 adds that when using https (which we should), it is important that the cookie will have its secure flag set, so that authentication info is never sent over a non-secure connection. Great point, hadn\'t seen it myself.I feel that this is a sufficient solution that works fine, but I must admit that I\'m not enough of a security expert to identify potential holes in this scheme - all I know is that hundreds of non-RESTful web applications use essentially the same login protocol ($_SESSION inphp, HttpSession in Java EE, etc). The cookie header contents is simply used to address a server-side resource, just like an accept-language might be used to access translation resources, etcetera. I feel that it is the same, but maybe others don\'t? What do you think, guys?Enough already is said on this topic by good folks here. But here is my 2 cents. There are 2 modes of interaction:The machine being the common denominator, expressed as the REST APIs, and the actors/clients being either the humans or the machines.Now, in a truly RESTful architecture, the concept of statelessness implies that all relevant application states (meaning the client side states) must be supplied with each and every request. By relevant, it is meant that whatever is required by the REST API to process the request and serve an appropriate response. When we consider this in the context of human-to-machine applications, "browser based" as Skrebbel points out above, this means that the (web) application running in the browser will need to send its state and relevant information with each request it makes to the back end REST APIs. Consider this: You have a data/information platform exposed as set of REST APIs. Perhaps you have a self-service BI platform that handles all the data cubes. But you want your (human) customers to access this via (1) web app, (2) mobile app, and (3) some 3rd party application. In the end, even chain of MTMs lead upto HTM - right. So human users remain at the apex of information chain.In the first 2 cases, you have a case for human-to-machine interaction, the information being actually consumed by a human user. In the last case, you have a machine program consuming the REST APIs. The concept of authentication applies across the board. How will you design this so that your REST APIs are accessed in a uniform, secured manner? The way I see this, there are 2 ways:Way-1:Way-2:Clearly, in Way-2, the REST APIs will need a way to recognize and trust the token as valid. The Login API performed the auth verification, and therefore that "valet key" needs to be trusted by other REST APIs in your catalog.This of course means that the auth key/token will need to be stored and shared among the REST APIs. This shared, trusted token repository can be local/federated whatever, allowing REST APIs from other organizations to trust each other. But I digress. The point is, a "state" (about the client\'s authenticated status) needs to be maintained and shared so that all REST APIs can create a circle of trust. If we do not do this, which is the Way-1, we must accept that an act of authentication must be performed for any/all requests coming in. Performing authentication is a resource intensive process. Imagine executing SQL queries, for every incoming request, against your user store to check for uid/pwd match. Or, to encrypt and perform hash  matches (the AWS style). And architecturally, every REST API will need to perform this, I suspect, using a common back end login service. Because, if you dont, then you litter the auth code everywhere. A big mess. So more the layers, more latency.Now, take Way-1 and apply to HTM. Does your (human) user really care if you have to send uid/pwd/hash or whatever with every request? No, as long as you don\'t bother her by throwing the auth/login page every second. Good luck having customers if you do. So, what you will do is to store the login information somewhere on the client side, in browser, right at the beginning, and send it with every requests made. For the (human) user, she has already logged in, and a "session" is available. But in reality, she is authenticated on every request. Same with Way-2. Your (human) user will never notice. So no harm done.What if we apply Way-1 to MTM? In this case, since its a machine, we can bore the hell out of this guy by asking it submit authentication information with every request. Nobody cares! Performing Way-2 on MTM will not evoke any special reaction; its a damn machine. It could care less!So really, the question is what suits your need. Statelessness has a price to pay. Pay the price and move on. If you want to be a purist, then pay the price for that too, and move on. In the end, philosophies do not matter. What really matter is information discovery, presentation, and the consumption experience. If people love your APIs, you did your job.Here is a truly and completely RESTful authentication solution:When a client authenticates:3.1. issue a token which contains the following:3.2. Encrypt the token with the private key.3.3. Send the encrypted token back to the user.When the user accesses any API they must also pass in their auth token.This is stateless/RESTful authentication.Note, that if a password hash were included the user would also send the unencrypted password along with the authentication token.  The server could verify that the password matched the password that was used to create the authentication token by comparing hashes.  A secure connection using something like HTTPS would be necessary.  Javascript on the client side could handle getting the user\'s password and storing it client side, either in memory or in a cookie, possibly encrypted with the server\'s public key.To be honest with you I\'ve seen great answers here but something that bothers me a bit is when someone will take the whole Stateless concept to a extreme where it becomes dogmatic. It reminds me of those old Smalltalk fans that only wanted to embrace pure OO and if something is not an object, then you\'re doing it wrong. Give me a break.The RESTful approach is supposed to make your life easier and reduce the overhead and cost of sessions, try to follow it as it is a wise thing to do, but the minute you follow a discipline (any discipline/guideline) to the extreme where it no longer provides the benefit it was intended for, then you\'re doing it wrong. Some of the best languages today have both, functional programming and object orientation. If the easiest way for you to solve your problem is to store the authentication key in a cookie and send it on HTTP header, then do it, just don\'t abuse it. Remember that sessions are bad when they become heavy and big, if all your session consists of is a short string containing a key, then what\'s the big deal?I am open to accept corrections in comments but I just don\'t see the point (so far) in making our lives miserable to simply avoid keeping a big dictionary of hashes in our server.First and foremost, a RESTful web service is STATELESS (or in other words, SESSIONLESS).  Therefore, a RESTful service does not have and should not have a concept of session or cookies involved.  The way to do authentication or authorization in the RESTful service is by using the HTTP Authorization header as defined in the RFC 2616 HTTP specifications.  Every single request should contain the HTTP Authorization header, and the request should be sent over an HTTPs (SSL) connection.  This is the correct way to do authentication and to verify the authorization of requests in a HTTP RESTful web services.  I have implemented a RESTful web service for the Cisco PRIME Performance Manager application at Cisco Systems.  And as part of that web service, I have implemented authentication/authorization as well.Rubens Gomes.It\'s certainly not about "session keys" as it is generally used to refer to sessionless authentication which is performed within all of the constraints of REST.  Each request is self-describing, carrying enough information to authorize the request on its own without any server-side application state.The easiest way to approach this is by starting with HTTP\'s built-in authentication mechanisms in RFC 2617.The \'very insightful\' article mentioned by @skrebel ( http://www.berenddeboer.net/rest/authentication.html )\ndiscusses a convoluted but really broken method of authentication.You may try to visit the page (which is supposed to be viewable only to authenticated user) http://www.berenddeboer.net/rest/site/authenticated.html without any login credentials.(Sorry I can\'t comment on the answer.)I would say REST and authentication simply do not mix. REST means stateless but \'authenticated\' is a state. You cannot have them both at the same layer. If you are a RESTful advocate and frown upon states, then you have to go with HTTPS (i.e. leave the security issue to another layer).I think restful authentication involves the passing of an authentication token as a parameter in the request. Examples are the use of apikeys by api\'s. I don\'t believe the use of cookies or http auth qualifies.That\'s the way to do that: Using OAuth 2.0 for Login.You may use other authentication methods other then Google\'s as long as it supports OAuth.I think the following approach can be used for REST service authentication:With this approach we are doing the expensive operation of loading the cache with user specific access right details every 30 minutes. So if an access is revoked or new access is granted, it takes 30 minutes to reflect or a logout followed by a loginTo answer this question from my understanding...An authentication system that uses REST so that you do not need to actually track or manage the users in your system. This is done by using the HTTP methods POST, GET, PUT, DELETE. We take these 4 methods and think of them in terms of database interaction as CREATE, READ, UPDATE, DELETE (but on the web we use POST and GET because that is what anchor tags support currently). So treating POST and GET as our CREATE/READ/UPDATE/DELETE (CRUD) then we can design routes in our web application that will be able to deduce what action of CRUD we are achieving. For example, in a Ruby on Rails application we can build our web app such that if a user who is logged in visits http://store.com/account/logout then the GET of that page can viewed as the user attempting to logout. In our rails controller we would build an action in that logs the user out and sends them back to the home page.A GET on the login page would yield a form. a POST on the login page would be viewed as a login attempt and take the POST data and use it to login. To me, it is a practice of using HTTP methods mapped to their database meaning and then building an authentication system with that in mind you do not need to pass around any session id\'s or track sessions.I\'m still learning -- if you find anything I have said to be wrong please correct me, and if you learn more post it back here. Thanks.Using a Public key infrastruction in which the registration of a key involves proper binding ensures that the public key is bound to the individual to which it is assigned in a way that ensures non-repudiationSee http://en.wikipedia.org/wiki/Public_key_infrastructure . If you follow the proper PKI standards, the person or agent who improperly uses the stolen key can be identified and locked out. If the agent is required to use a certificate, the binding gets pretty tight. A clever and quick-moving thief can escape, but they leave more crumbs.