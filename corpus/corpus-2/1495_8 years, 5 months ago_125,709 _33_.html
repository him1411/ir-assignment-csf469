I have the following function:How I call it:If I step that loop with the debugger during runtime I get different values (which is what I want).\nHowever, if I put a breakpoint two lines below that code, all members of the "mac" array have equal value.Why does that happen?Every time you do new Random() it is initialized using the clock. This means that in a tight loop you get the same value lots of times. You should keep a single Random instance and keep using Next on the same instance.Edit (see comments): why do we need a lock here?Basically, Next is going to change the internal state of the Random instance. If we do that at the same time from multiple threads, you could argue "we\'ve just made the outcome even more random", but what we are actually doing is potentially breaking the internal implementation, and we could also start getting the same numbers from different threads, which might be a problem - and might not. The guarantee of what happens internally is the bigger issue, though; since Random does not make any guarantees of thread-safety. Thus there are two valid approaches:Either can be fine; but mutexing a single instance from multiple callers at the same time is just asking for trouble.The lock achieves the first (and simpler) of these approaches; however, another approach might be: this is then per-thread, so you don\'t need to synchronize. For ease of re-use throughout your application a static class may help.You can use then use static random instance with code such asMark\'s solution can be quite expensive since it needs to synchronize everytime.We can get around the need for synchronization by using the thread-specific storage pattern:Measure the two implementations and you should see a significant difference.My answer from here:Just reiterating the right solution:So you can call:all throughout. If you strictly need a true stateless static method to generate random numbers, you can rely on a Guid.It\'s going to be a wee bit slower, but can be much more random than Random.Next, at least from my experience.But not:The unnecessary object creation is going to make it slower especially under a loop.And never:Not only it\'s slower (inside a loop), its randomness is... well not really good according to me..I would rather use the following class to generate random numbers:1) As Marc Gravell said, try to use ONE random-generator. It\'s always cool to add this to the constructor: System.Environment.TickCount.2) One tip. Let\'s say you want to create 100 objects and suppose each of them should have its-own random-generator (handy if you calculate LOADS of random numbers in a very short period of time). If you would do this in a loop (generation of 100 objects), you could do this like that (to assure fully-randomness):Cheers.There are a lot of solutions, here one: if you want only number erase the letters and the method receives a random and the result length.If you want to use a function that creates an instance of Random each time you can use this:   This will generate random numbers. Tweak it as needed.(== Try Me ==) 