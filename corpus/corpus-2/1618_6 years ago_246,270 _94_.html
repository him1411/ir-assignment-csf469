I\'m learning Spring 3 and I don\'t seem to grasp the functionality behind <context:annotation-config> and <context:component-scan>.From what I\'ve read they seem to handle different annotations (@Required, @Autowired etc vs @Component, @Repository, @Service etc) but also from what I\'ve read they register the same bean post processor classes.To confuse me even more, there is an annotation-config attribute on <context:component-scan>.Can someone shed some light on these tags? What\'s similar, what\'s different, is one superseded by the other, they complete each other, do I need one of them, both?<context:annotation-config> is used to activate annotations in beans already registered in the application context (no matter if they were defined with XML or by package scanning).<context:component-scan> can also do what <context:annotation-config> does but <context:component-scan> also scans packages to find and register beans within the application context.I\'ll use some examples to show the differences/similarities. Lets start with a basic setup of three beans of type A, B and C, with B and C being injected into A.With the following XML configuration :Loading the context produces the following output:OK, this is the expected output. But this is "old style" Spring. Now we have annotations so lets use those to simplify the XML.First, lets autowire the bbb and ccc properties on bean A like so:This allows me to remove the following rows from the XML:My XML is now simplified to this:When I load the context I get the following output:OK, this is wrong! What happened? Why aren\'t my properties autowired?Well, annotations are a nice feature but by themselves they do nothing whatsoever. They just annotate stuff. You need a processing tool to find the annotations and do something with them. <context:annotation-config> to the rescue. This activates the actions for the annotations that it finds on the beans defined in the same application context where itself is defined.If I change my XML to this:when I load the application context I get the proper result:OK, this is nice, but I\'ve removed two rows from the XML and added one. That\'s not a very big difference. The idea with annotations is that it\'s supposed to remove the XML.So let\'s remove the XML definitions and replace them all with annotations:While in the XML we only keep this:We load the context and the result is... Nothing. No beans are created, no beans are autowired. Nothing!That\'s because, as I said in the first paragraph, the <context:annotation-config /> only works on beans registered within the application context. Because I removed the XML configuration for the three beans there is no bean created and <context:annotation-config /> has no "targets" to work on.But that won\'t be a problem for <context:component-scan> which can scan a package for "targets" to work on. Let\'s change the content of the XML config into the following entry:When I load the context I get the following output:Hmmmm... something is missing. Why? If you look closelly at the classes, class A has package com.yyy but I\'ve specified in the <context:component-scan> to use package com.xxx so this completely missed my A class and only picked up B and C which are on the com.xxx package.To fix this, I add this other package also:and now we get the expected result:And that\'s it! Now you don\'t have XML definitions anymore, you have annotations.As a final example, keeping the annotated classes A, B and C and adding the following to the XML, what will we get after loading the context?We still get the correct result:Even if the bean for class A isn\'t obtained by scanning, the processing tools are still applied by <context:component-scan> on all beans registered\nin the application context, even for A which was manually registered in the XML.But what if we have the following XML, will we get duplicated beans because we\'ve specified both <context:annotation-config /> and <context:component-scan>?No, no duplications, We again get the expected result:That\'s because both tags register the same processing tools (<context:annotation-config /> can be omitted if <context:component-scan> is specified) but Spring takes care of running them only once.Even if you register the processing tools yourself multiple times, Spring will still make sure they do their magic only once; this XML:will still generate the following result:OK, that about raps it up. I hope this information along with the responses from @Tomasz Nurkiewicz and @Sean Patrick Floyd are all you need to understand how \n<context:annotation-config> and <context:component-scan> work.I found this nice summary of which annotations are picked up by which declarations. By studying it you will find that <context:component-scan/> recognizes a superset of annotations recognized by <context:annotation-config/>, namely:As you can see <context:component-scan/> logically extends <context:annotation-config/> with CLASSPATH component scanning and Java @Configuration features.Spring allows you to do two things:1. Autowiring\nUsually in applicationContext.xml you define beans and other beans are wired using\nconstructor or setter methods. You can wire beans using XML or annotations.\nIn case you use annotations, you need to activate annotations and you have to add\n<context:annotation-config /> in applicationContext.xml. This will simplify the\nstructure of the  tag from applicationContext.xml, because you will not have to manually wire beans (constructor or setter). You can use @Autowire annotation and the beans will be wired by type.A step forward for escaping the manual XML configuration is  2. Autodiscovery\nAutodiscovery is simplifying the XML one step further, in the sense that you don\'t even need too add the <bean> tag in applicationContext.xml. You just mark the specific beans with one of the following annotation and Spring will automatically wire the marked beans and their dependencies into the Spring container. The annotations are as follow:  @Controller, @Service, @Component, @Repository. By using <context:component-scan> and pointing the base package, Spring will auto-discover and wire the components into Spring container.As a conclusion:<context:annotation-config> activates many different annotations in beans, whether they are defined in XML or through component scanning.<context:component-scan> is for defining beans without using XMLFor further information, read:The difference between the two is really simple!.Enables you to use annotations that are restricted to wiring up properties and constructors only of beans!.Where asEnables everything that <context:annotation-config /> can do, with addition of using stereotypes eg.. @Component, @Service , @Repository. So you can wire entire beans and not just restricted to constructors or properties!.    The <context:annotation-config> tag tells Spring to scan the codebase for automatically resolving dependency requirements of the classes containing @Autowired annotation.Spring 2.5 also adds support for JSR-250 annotations such as @Resource, @PostConstruct, and @PreDestroy.Use of these annotations also requires that certain BeanPostProcessors be registered within the Spring container. As always, these can be registered as individual bean definitions, but they can also be implicitly registered by including <context:annotation-config> tag in spring configuration.Taken from Spring documentation of Annotation Based ConfigurationSpring provides the capability of automatically detecting \'stereotyped\' classes and registering corresponding BeanDefinitions with the ApplicationContext.According to javadoc of org.springframework.stereotype:Stereotypes are Annotations denoting the roles of types or methods in the overall architecture (at a conceptual, rather than implementation, level). \nExample: @Controller @Service @Repository etc.\nThese are intended for use by tools and aspects (making an ideal target for pointcuts).To autodetect such \'stereotype\' classes, <context:component-scan> tag is required.The <context:component-scan> tag also tells Spring to scan the code for injectable beans under the package (and all its subpackages) specified.tl;dr\n<context:annotation-config>: Scanning and activating annotations for already registered beans in spring config xml.<context:component-scan>: Bean registration + <context:annotation-config>@Autowired and @Required are targets property level so bean should register in spring IOC before use these annotations. To enable these annotations either have to register respective beans or include <context:annotation-config />. i.e. <context:annotation-config /> works with registered beans only.@Required enables  RequiredAnnotationBeanPostProcessor  processing tool\n  @Autowired enables  AutowiredAnnotationBeanPostProcessor processing toolNote: Annotation itself nothing to do, we need a Processing Tool, which is a class underneath, responsible for the core process.@Repository, @Service and @Controller  are @Component, and they targets class level.<context:component-scan> it scans the package and find and register the beans, and it includes the work done by <context:annotation-config />.Only resolves the @Autowired and @Qualifer annotations, thats all, it about the Dependency Injection, There are other annotations that do the same job, I think how @Inject, but all about to resolve DI through annotations.Be aware, even when you have declared the <context:annotation-config> element, you must declare your class how a Bean anyway, remember we have three available optionsNow withIt does two things:Therefore if you declare <context:component-scan>, is not necessary anymore declare <context:annotation-config> too.Thats all A common scenario was for example declare only a bean through XML and resolve the DI through annotations, for exampleWe have only declared the beans, nothing about <constructor-arg> and <property>, the DI is configured in their own classes through @Autowired. It means the Services use @Autowired for their Repositories components and the Repositories use @Autowired for the JdbcTemplate, DataSource etc..componentstry with <context:component-scan base-package="..." annotation-config="false"/> , in your configuration @Service, @Repository, @Component works fine, but @Autowired,@Resource and @Inject doesn\'t work.This means AutowiredAnnotationBeanPostProcessor will not be enabled and Spring container will not process the Autowiring annotations.The other important point to note is that context:component-scan implicitly calls the context:annotation-config to activate the annotations on beans. Well if you don\'t want context:component-scan to implicitly activate annotations for you, you can go on setting the annotation-config element of the context:component-scan to false.To summarize:A <context:component-scan/> custom tag registers the same set of bean definitions as is done by , apart from its primary responsibility of scanning the java packages and registering bean definitions from the classpath.If for some reason this registration of default bean definitions are to be avoided, the way to do that is to specify an additional "annotation-config" attribute in component-scan, this way:Reference:\nhttp://www.java-allandsundry.com/2012/12/contextcomponent-scan-contextannotation.html<context:component-scan base-package="package name" />:This is used to tell the container that there are bean classes in my package scan those bean classes. In order to scan  bean classes by container on top of the bean we have to write one of the stereo type annotation like following.@Component, @Service, @Repository, @Controller<context:annotation-config />:If we don\'t want to write bean tag explicitly in XML then how the container knows if there is a auto wiring in the bean. This is possible by using @Autowired annotation. we have to inform to the container that there is auto wiring in my bean by context:annotation-config.context:annotation-config:This tells Spring that I am gona use Annoatted beans as spring bean adn those would be wired through @Autowired annotation, instead of declaring in spring config xml file.context:component-scan base-package="com.test..." : \nThis tells Spring container, where to start searching those annotated beans. Here spring will sear all sub packages of the 