What does class << self do in Ruby?First, the class << foo syntax opens up foo\'s singleton class (eigenclass). This allows you to specialise the behaviour of methods called on that specific object.Now, to answer the question: class << self opens up self\'s singleton class, so that methods can be redefined for the current self object (which inside a class or module body is the class or module itself). Usually, this is used to define class/module ("static") methods:This can also be written as a shorthand:Or even shorter:When inside a function definition, self refers to the object the function is being called with. In this case, class << self opens the singleton class for that object; one use of that is to implement a poor man\'s state machine:So, in the example above, each instance of StateMachineExample has process_hook aliased to process_state_1, but note how in the latter, it can redefine process_hook (for self only, not affecting other StateMachineExample instances) to process_state_2. So, each time a caller calls the process method (which calls the redefinable process_hook), the behaviour changes depending on what state it\'s in.I found a super simple explanation about class << self , Eigenclass and different type of methods in this blog.In Ruby, there are three types of methods that can be applied to a class:Instance methods and class methods are almost similar to their homonymous in other programming languages.Another way of accessing an Eigenclass(which includes singleton methods) is with the following syntax (class <<):now you can define a singleton method for self which is the class Foo itself in this context:[it makes self == thing.singleton_class in the context of its block].  hi object inherits its #methods from its #singleton_class.instance_methods and then from its #class.instance_methods.\nHere we gave hi\'s singleton class instance method :a. It could have been done with class << hi instead.\nhi\'s #singleton_class has all instance methods hi\'s #class has, and possibly some more (:a here).[instance methods of thing\'s #class and #singleton_class can be applied directly to thing. when ruby sees thing.a, it first looks for :a method definition in thing.singleton_class.instance_methods and then in thing.class.instance_methods]By the way - they call object\'s singleton class == metaclass == eigenclass.  Usually, instance methods are global methods. That means they are available in all instances of the class on which they were defined. In contrast, a singleton method is implemented on a single object.Ruby stores methods in classes and all methods must be associated with a class. The object on which a singleton method is defined is not a class (it is an instance of a class). If only classes can store methods, how can an object store a singleton method? When a singleton method is created, Ruby automatically creates an anonymous class to store that method. These anonymous classes are called metaclasses, also known as singleton classes or eigenclasses. The singleton method is associated with the metaclass which, in turn, is associated with the object on which the singleton method was defined.If multiple singleton methods are defined within a single object, they are all stored in the same metaclass.In the above example, class << z1 changes the current self to point to the metaclass of the z1 object; then, it defines the say_hello method within the metaclass.Classes are also objects (instances of the built-in class called Class). Class methods are nothing more than singleton methods associated with a class object. All objects may have metaclasses. That means classes can also have metaclasses. In the above example, class << self modifies self so it points to the metaclass of the Zabuton class. When a method is defined without an explicit receiver (the class/object on which the method will be defined), it is implicitly defined within the current scope, that is, the current value of self. Hence, the stuff method is defined within the metaclass of the Zabuton class. The above example is just another way to define a class method. IMHO, it\'s better to use the def self.my_new_clas_method syntax to define class methods, as it makes the code easier to understand. The above example was included so we understand what\'s happening when we come across the class << self syntax.Additional info can be found at this post about Ruby Classes.\xd0\x90 singleton method is a method that is defined only for a single object. Example:Singleton\'s methods of SomeClasstestSingleton\'s methods of test_objtest_2test_3In fact if you write any C extensions for your Ruby projects there is really only one way to define a Module method.I know this self business just opens up all kinds of other questions so you could do better by searching each part.Objects first.Can I make a method for foo?SureWhat do I do with it?Just another object.You get all the Object methods plus your new one.Just the foo Object.Try to see what happens if you make foo from other Objects like Class and Module. The examples from all the answers are nice to play with but you have to work with different ideas or concepts to really understand what is going on with the way the code is written. So now you have lots of terms to go look at.Singleton,\nClass,\nModule,\nself,\nObject,\nand Eigenclass was brought up but Ruby doesn\'t name Object Models that way. It\'s more like Metaclass.\nRichard or __why shows you the idea here.\nhttp://viewsourcecode.org/why/hacking/seeingMetaclassesClearly.html\nAnd if the blows you away then try looking up Ruby Object Model in search.\nTwo videos that I know of on YouTube are Dave Thomas and Peter Cooper. They try to explain that concept too. It took Dave a long time to get it so don\'t worry.\nI\'m still working on it too. Why else would I be here?\nThanks for your question.\nAlso take a look at the standard library. It has a Singleton Module just as an FYI.This is pretty good.\nhttps://www.youtube.com/watch?v=i4uiyWA8eFk