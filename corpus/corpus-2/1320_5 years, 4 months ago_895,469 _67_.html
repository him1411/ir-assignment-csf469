Apparently, I have completely misunderstood its semantics. I thought of something like this:Well, I am wrong. It does not work like this at all. So, I have read Cross-origin resource sharing and attempted to read Cross-Origin Resource Sharing in w3c recommendationOne thing is sure - I still do not understand how am I supposed to use this header. I have full control of both site A and site B. How do I enable the javascript code downloaded from the site A to access resources on the site B using this header?P.S.I do not want to utilize JSONP.Access-Control-Allow-Origin is a CORS (Cross-Origin Resource Sharing) header.When Site A tries to fetch content from Site B,  Site B can send an Access-Control-Allow-Origin response header to tell the browser that the content of this page is accessible to certain origins. (An origin is a domain, plus a scheme and port number.)  By default, Site B\'s pages are not accessible to any other origin; using the Access-Control-Allow-Origin header opens a door for cross-origin access by specific requesting origins.For each resource/page that Site B wants to make accessible to Site A, Site B should serve its pages with the response header:Modern browsers will not block cross-domain requests outright.  If Site A requests a page from Site B, the browser will actually fetch the requested page on the network level and check if the response headers list Site A as a permitted requester domain.  If Site B has not indicated that Site A is allowed to access this page, the browser will trigger the XMLHttpRequest\'s error event and  deny the response data to the requesting JavaScript code.What happens on the network level can be slightly more complex than explained above. If the request is a "non-simple" request, the browser first sends a data-less "preflight" OPTIONS request, to verify that the server will accept the request. A request is non-simple when either (or both):If the server responds to the OPTIONS preflight with appropriate response headers (Access-Control-Allow-Headers for non-simple headers, Access-Control-Allow-Methods for non-simple verbs) that match the non-simple verb and/or non-simple headers, then the browser sends the actual request.Supposing that Site A wants to send a PUT request for /somePage, with a non-simple Content-Type value of application/json, the browser would first send a preflight request:Note that Access-Control-Request-Method and Access-Control-Request-Headers are added by the browser automatically; you do not need to add them. This OPTIONS preflight gets the successful response headers:When sending the actual request (after preflight is done), the behavior is identical to how a simple request is handled. In other words, a non-simple request whose preflight is successful is treated the same as a simple request (i.e., the server must still send Access-Control-Allow-Origin again for the actual response).The browsers sends the actual request:And the server sends back an Access-Control-Allow-Origin, just as it would for a simple request:See Understanding XMLHttpRequest over CORS for a little more information about non-simple requests.Cross-Origin Request Sharing - CORS (A.K.A. Cross-Domain AJAX request) is an issue that most web developers might encounter, according to Same-Origin-Policy, browsers restrict client JavaScript in a security sandbox, usually JS cannot directly communicate with a remote server from a different domain. In the past developers created many tricky ways to achieve Cross-Domain resource request, most commonly using ways are:Those tricky ways have more or less some issues, for example JSONP might result in security hole if developers simply "eval" it, and #3 above, although it works, both domains should build strict contract between each other, it neither flexible nor elegant IMHO:)W3C had introduced Cross-Origin Resource Sharing (CORS) as a standard solution to provide a safe, flexible and a recommended standard way to solve this issue. The MechanismFrom a high level we can simply deem CORS is a contract between client AJAX call from domain A and a page hosted on domain B, a typical Cross-Origin request/response would be:DomainA AJAX request headersDomainB response headersThe blue parts I marked above were the kernal facts, "Origin" request header "indicates where the cross-origin request or preflight request originates from", the "Access-Control-Allow-Origin" response header indicates this page allows remote request from DomainA (if the value is * indicate allows remote requests from any domain).As I mentioned above, W3 recommended browser to implement a "preflight request" before submiting the actually Cross-Origin HTTP request, in a nutshell it is an HTTP OPTIONS request:If foo.aspx supports OPTIONS HTTP verb, it might return response like below:Only if the response contains "Access-Control-Allow-Origin" AND its value is "*" or contain the domain who submitted the CORS request, by satisfying this mandtory condition browser will submit the actual Cross-Domain request, and cache the result in "Preflight-Result-Cache".I blogged about CORS three years ago: AJAX Cross-Origin HTTP requestQuestion is a bit too old to answer, but I am posting this for any future reference to this question.According to this Mozilla Developer Network article,A resource makes a cross-origin HTTP request when it requests a resource from a different domain, or port than the one which the first resource itself serves.An HTML page served from http://domain-a.com makes an <img> src request for http://domain-b.com/image.jpg.\nMany pages on the web today load resources like CSS stylesheets, images and scripts from separate domains (thus it should be cool).For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts.\nFor example, XMLHttpRequest and Fetch follow the same-origin policy.\nSo, a web application using XMLHttpRequest or Fetch could only make HTTP requests to its own domain.To improve web applications, developers asked browser vendors to allow cross-domain requests.The Cross-Origin Resource Sharing (CORS) mechanism gives web servers cross-domain access controls, which enable secure cross-domain data transfers.\nModern browsers use CORS in an API container - such as XMLHttpRequest or Fetch - to mitigate risks of cross-origin HTTP requests.Wikipedia:The CORS standard describes new HTTP headers which provide browsers and servers a way to request remote URLs only when they have permission.Although some validation and authorization can be performed by the server, it is generally the browser\'s responsibility to support these headers and honor the restrictions they impose.The browser sends the OPTIONS request with an Origin HTTP header. The value of this header is the domain that served the parent page. When a page from http://www.example.com attempts to access a user\'s data in service.example.com, the following request header would be sent to service.example.com:Origin: http://www.example.comThe server at service.example.com may respond with:An Access-Control-Allow-Origin (ACAO) header in its response indicating which origin sites are allowed.\nFor example:  Access-Control-Allow-Origin: http://www.example.comAn error page if the server does not allow the cross-origin requestAn Access-Control-Allow-Origin (ACAO) header with a wildcard that allows all domains:Access-Control-Allow-Origin: *1. A client downloads javascript code MyCode.js from http://siteA - the origin.The code that does the downloading - your html script tag or xhr from javascript or whatever - came from, let\'s say, http://siteZ.  And, when the browser requests MyCode.js, it sends an Origin: header saying "Origin: http://siteZ", because it can see that you\'re requesting to siteA and siteZ != siteA.  (You cannot stop or interfere with this.)2. The response header of MyCode.js contains Access-Control-Allow-Origin: http://siteB, which I thought meant that MyCode.js was allowed to make cross-origin references to the site B.no.  It means, Only siteB is allowed to do this request.  So your request for MyCode.js from siteZ gets an error instead, and the browser typically gives you nothing.  But if you make your server return A-C-A-O: siteZ instead, you\'ll get MyCode.js .  Or if it sends \'*\', that\'ll work, that\'ll let everybody in.  Or if the server always sends the string from the Origin: header... but... for security, if you\'re afraid of hackers, your server should only allow origins on a shortlist, that are allowed to make those requests.Then, MyCode.js comes from siteA.  When it makes requests to siteB, they are all cross-origin, the browser sends Origin: siteA, and siteB has to take the siteA, recognize it\'s on the short list of allowed requesters, and send back A-C-A-O: siteA.  Only then will the browser let your script get the result of those requests.For cross origin sharing, set header: \'Access-Control-Allow-Origin\':\'*\';Php: header(\'Access-Control-Allow-Origin\':\'*\');Node: app.use(\'Access-Control-Allow-Origin\':\'*\');This will allow to share content for different domain.If you want just to test a cross domain application in which the browser blocks your request, then you can just open your browser in unsafe mode and test your application without changing your code and without making your code unsafe.\nFrom MAC OS you can do this from the terminal line:If you are using PHP, try to add the following code at the beaning of the php file:if you are using localhost, try this:if you are using external domains such as server, try this:i work with express 4 and node 7.4 and angular,I had the same problem me help this: \na) server side: in file app.js i give headers to all response like:this must have before all router.\nI saw a lot of added this headers:but i dont need that,\nb) client side: in send ajax you need add: "withCredentials: true," like:good luck.