How to find that a number is float or integer?check for a remainder when dividing by 1:If you don\'t know that the argument is a number you need two tests:Try these functions to test whether a value is a number primitive value that has no fractional part and is within the size limits of what can be represented as an exact integer.Why not something like this:There is a method called Number.isInteger() which is currently implemented only in latest Firefox and is still a part of EcmaScript 6 proposal. However MDN provides a polyfill for the other browsers, which matches the one specified in ECMA harmony:You can use a simple regular expression:Or you can use the below functions too, according your needs. They are developed by the PHPJS Project.is_int() => Check if variable type is integer and if its content is integeris_float() => Check if variable type is float and if its content is floatctype_digit() => Check if variable type is string and if its content has only decimal digitsUpdate 1Now it checks negative numbers too, thanks for @ChrisBartley comment!Here are efficient functions that check if the value is a number or can be safely converted to a number:And for integers (would return false if the value is a float):The efficiency here is that parseInt (or parseNumber) are avoided when the value already is a number. Both parsing functions always convert to string first and then attempt to parse that string, which would be a waste if the value already is a number.Thank you to the other posts here for providing further ideas for optimization!works for all cases.As others mentioned, you only have doubles in JS. So how do you define a number being an integer? Just check if the rounded number is equal to itself:Here\'s what I use for integers:Short, nice :) Works all the time. This is what David Flanagan suggests if I\'m not mistaken.Haven\'t had a case where this didn\'t do the job.Any Float number with a zero decimal part (e.g. 1.0, 12.00, 0.0) are implicitly cast to Integer, so it is not possible to check if they are Float or not.It\'s simple as:Try this in console:This confuses a lot of people.  Whenever something is .0, it\'s not a float anymore.  It\'s an integer.  Or you can just call it "a numeric thing" for there is no strict distinction like back then in C.  Good old times.So basically, all you can do is check for integer accepting the fact that 1.000 is an integer.Interesting side noteThere was a comment about huge numbers.  Huge numbers mean NO problem for this approach; whenever parseInt is unable to handle the number (for it\'s too big) it will return something else than the actual value so the test will return FALSE.  This is a good thing because if you consider something a "number" you normally expect JS to be able to calculate with it - so yes, numbers are limited and parseInt will take this into consideration, to put it this way.Try this:In my browser (IE8) this returns "a is ok; b fails" which is exactly because of the huge number in b.  The limit may vary but I guess 20 digits "ought to be enough for anybody", to quote a classical :)I wrote function which accepts strings (if somebody will need)example ouptuts:It really depends on what you want to achieve. If you want to "emulate" strongly typed languages then I suggest you not trying. As others mentioned all numbers have the same representation (the same type).Using something like Claudiu provided:isInteger( 1.0 ) -> truewhich looks fine for common sense, but in something like C you would get falseTHIS IS FINAL CODE FOR CHECK BOTH INT AND FLOATOR For integers I use thisIt really doesn\'t have to be so complicated. The numeric value of an integer\'s parseFloat() and parseInt() equivalents will be the same. Thus you can do like so:ThenThis will also allow for string checks and thus is not strict. If want a strong type solution (aka, wont work with strings):In java script all the numbers are internally 64 bit floating point, same as double in java.\nThere are no diffrent types in javascript, all are represented by type number. Hence you wil l not be able make a instanceof check. However u can use the above solutions given to find out if it is a fractional number. designers of java script felt with a single type they can avoid numerous type cast errors.This maybe isn\'t as performant as the % answer, which prevents you from having to convert to a string first, but I haven\'t seen anyone post it yet, so here\'s another option that should work fine:Here\'s my code.  It checks to make sure it\'s not an empty string (which will otherwise pass) and then converts it to numeric format.  Now, depending on whether you want \'1.1\' to be equal to 1.1, this may or may not be what you\'re looking for.  I like this little function, which will return true for both positive and negative integers:This works because 1 or "1" becomes "1.0", which isNaN() returns false on (which we then negate and return), but 1.0 or "1.0" becomes "1.0.0", while "string" becomes "string.0", neither of which are numbers, so isNaN() returns false (and, again, gets negated).If you only want positive integers, there\'s this variant:or, for negative integers:isPositiveInt() works by moving the concatenated numeric string ahead of the value to be tested. For example, isPositiveInt(1) results in isNaN() evaluating "01", which evaluates false. Meanwhile, isPositiveInt(-1) results in isNaN() evaluating "0-1", which evaluates true. We negate the return value and that gives us what we want. isNegativeInt() works similarly, but without negating the return value of isNaN().Edit:My original implementation would also return true on arrays and empty strings. This implementation doe not have that defect. It also has the benefit of returning early if val is not a string or number, or if it\'s an empty string, making it faster in these cases. You can further modify it by replacing the first two clauses withif you only want to match literal numbers (and not strings)Edit:I can\'t post comments yet, so I\'m adding this to my answer. The benchmark posted by @Asok is very informative; however, the fastest function does not fit the requirements, as it also returns TRUE for floats, arrays, booleans, and empty strings.I created the following test suite to test each of the functions, adding my answer to the list, as well (function 8, which parses strings, and function 9, which does not):I also reran the benchmark with function #8 added to the list. I won\'t post the result, as they\'re a bit embarrassing (e.g. that function is NOT fast)...The (abridged -- I removed successful tests, since the output is quite long) results are as follows:I\'ve left in failures so you can see where each function is failing, and the (string) \'#\' tests so you can see how each function handles integer and float values in strings, as some may want these parsed as numbers and some may not.Out of the 10 functions tested, the ones that actually fit OP\'s requirements are [1,3,5,6,8,9]Condtion for floating validation :Condtion for Integer validation :Hope this might be helpful.You can add typeof a === \'number\' if you want to exclude strings.YourJS provides the following two functions which work for all numbers including returning false for -Infinity and Infinity:Due to the fact that typeOf() is a YourJS internal function, if you wanted to use these definitions you can download the version for just these functions here:  http://yourjs.com/snippets/build/34Some times Number objects don\'t allow you to use direct the mod operator (%), if you are facing that case you can use this solution.Based on all that I have seen here, I\'ve created my own set of functions to test for what I need:However, shime\'s solution is shorter and with less checks, so it might be a better one.For those curious, using Benchmark.js I tested the most up-voted answers (and the one posted today) on this post, here are my results: