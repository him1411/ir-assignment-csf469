I have a shell script with this code:But the conditional code always executes, because hg st always prints at least one newline character.orI could use sed or AWK, but I\'d like to think there is a more elegant solution to this problem.Let\'s define a variable containing leading, trailing, and intermediate whitespace:How to remove all whitespace (denoted by [:space:] in tr):How to remove leading whitespace only:How to remove trailing whitespace only:How to remove both leading and trailing spaces--chain the seds:Alternatively, if your bash supports it, you can replace echo -e "${FOO}" | sed ... with sed ... <<<${FOO}, like so (for trailing whitespace):A simple answer is:Xargs will do the trimming for you. It\'s one command/program, no parameters, returns the trimmed string, easy as that!Note: this doesn\'t remove the internal spaces so "foo bar" stays the same. It does NOT become "foobar".There is a solution which only uses Bash built-ins called wildcards:Here\'s the same wrapped in a function:You pass the string to be trimmed in quoted form. e.g.: A nice thing about this solution is that it will work with any POSIX-compliant shell.Bash has a feature called parameter expansion, which, among other things, allows string replacement based on so-called patterns (patterns resemble regular expressions, but there are fundamental differences and limitations).\n[flussence\'s original line: Bash has regular expressions, but they\'re well-hidden:]The following demonstrates how to remove all white space (even from the interior) from a variable value. You can trim simply with echo:From Bash Guide section on globbing To use an extglob in a parameter expansion  Here\'s the same functionality wrapped in a function (NOTE: Need to quote input string passed to function):Usage:You can delete newlines with tr:With Bash\'s extended pattern matching features enabled (shopt -s extglob), you can use this:{trimmed##*( )}to remove an arbitrary amount of leading spaces.I\'ve always done it with sedIf there is a more elegant solution, I hope somebody posts it.In order to remove all the spaces from the beginning and the end of a string (including end of line characters):This will remove duplicate spaces also:Produces: \'this string has a lot of spaces\'Sorry everyone, there was a problem elsewhere in my script and I thought that var had a trailing newline in it, but that actually was not the case. Command substitution strips trailing newlines automatically, as mentioned here: http://tldp.org/LDP/abs/html/commandsub.html.There are a lot of answers, but I still believe my just-written script is worth being mentioned because:The script:Usage:Output:I\'ve seen scripts just use variable assignment to do the job:Whitespace is automatically coalesced and trimmed.  One has to be careful of shell metacharacters (potential injection risk).I would also recommend always double-quoting variable substitutions in shell conditionals:since something like a -o or other content in the variable could amend your test arguments.You can use old-school tr. For example, this returns the number of modified files in a git repository, whitespaces stripped.This worked for me:To put that on fewer lines for the same result:Here\'s a trim() function that trims and normalizes whitespaceAnd another variant that uses regular expressions.This does not have the problem with unwanted globbing, also, interior white-space is unmodified (assuming that $IFS is set to the default, which is \' \\t\\n\').It reads up to the first newline (and doesn\'t include it) or the end of string, whichever comes first, and strips away any mix of leading and trailing space and \\t characters. If you want to preserve multiple lines (and also strip leading and trailing newlines), use read -r -d \'\' var << eof instead; note, however, that if your input happens to contain \\neof, it will be cut off just before. (Other forms of white space, namely \\r, \\f, and \\v, are not stripped, even if you add them to $IFS.)Use AWK:Assignments ignore leading and trailing whitespace and as such can be used to trim:I would simply use sed:a) Example of usage on single-line stringOutput:b) Example of usage on multi-line stringOutput:c) Final note:\nIf you don\'t like to use a function, for single-line string you can simply use a "easier to remember" command like:Example:Output:Using the above on multi-line strings will work as well, but please note that it will cut any trailing/leading internal multiple space as well, as GuruM noticed in the commentsOutput:So if you do mind to keep those spaces, please use the function at the beginning of my answer!d) EXPLANATION of the sed syntax "find and replace" on multi-line strings used inside the function trim:OROROR ORBuilding upon moskit\'s expr soulution...ORTo remove spaces and tabs from left to first word, enter:cyberciti.biz/tips/delete-leading-spaces-from-front-of-each-word.htmlThis will remove all the whitespaces from your String, / replaces the first occurrence and // all occurrences of whitespaces in the string. I.e. all white spaces get replaced by \xe2\x80\x93 nothing This trims multiple spaces of the front and endwhatever=${whatever%% *}whatever=${whatever#* }This is the simplest method I\'ve seen.  It only uses Bash, it\'s only a few lines, the regexp is simple, and it matches all forms of whitespace:Here is a sample script to test it with:I created the following functions. I am not sure how portable printf is, but the beauty of this solution is you can specify exactly what is "white space" by adding more character codes.