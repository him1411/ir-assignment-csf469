Does anyone know what the difference is between these two methods:slice() works like substring() with a few different behaviors.What they have in common:Distinctions of substring():Distinctions of slice():Source: Rudimentary Art of Programming & Development: Javascript: substr() v.s. substring()Note: if you\'re in a hurry, and/or looking for short answer scroll to the bottom of the answer, and read the last two lines.if Not in a hurry read the whole thing.let me start by stating the facts:Syntax:\nstring.slice(start,end)\nstring.substr(start,length)\nstring.substring(start,end)\nNote #1: slice()==substring()What it does?\nThe slice() method extracts parts of a string and returns the extracted parts in a new string.\nThe substr() method extracts parts of a string, beginning at the character at the specified position, and returns the specified number of characters.\nThe substring() method extracts parts of a string and returns the extracted parts in a new string.\nNote #2:slice()==substring()Changes the Original String?\nslice() Doesn\'t\nsubstr() Doesn\'t\nsubstring() Doesn\'t\nNote #3:slice()==substring()Using Negative Numbers as an Argument:\nslice() selects characters starting from the end of the string\nsubstr()selects characters starting from the end of the string\nsubstring() Doesn\'t Perform\nNote #3:slice()==substr()==substr()if the First Argument is Greater than the Second:\nslice() Doesn\'t Perform\nsubstr() since the Second Argument is NOT a position, but length value, it will perform as usual, with no problems\nsubstring() will swap the two arguments, and perform as usualthe First Argument:\nslice() Required, indicates: Starting Index\nsubstr() Required, indicates: Starting Index\nsubstring() Required, indicates: Starting Index\nNote #4:slice()==substr()==substring()the Second Argument:\nslice() Optional, The position (up to, but not including) where to end the extraction\nsubstr() Optional, The number of characters to extract\nsubstring() Optional, The position (up to, but not including) where to end the extraction\nNote #5:slice()==substring()What if the Second Argument is Omitted?\nslice() selects all characters from the start-position to the end of the string\nsubstr() selects all characters from the start-position to the end of the string\nsubstring() selects all characters from the start-position to the end of the string\nNote #6:slice()==substr()==substring()so, you can say that there\'s a difference between slice() and substr(), while substring() is basically a copy of slice().in Summary:\nif you know the index(the position) on which you\'ll stop (but NOT include), Use slice()\nif you know the length of characters to be extracted use substr().Ben Nadel has written a good article about this, he points out the difference in the parameters to these functions:He also points out that if the parameters to slice are negative, they reference the string from the end. Substring and substr doesn\xc2\xb4t. Here is his article about this http://www.bennadel.com/blog/2159-using-slice-substring-and-substr-in-javascript.htmThe one answer is fine, but requires a little reading into.  Especially with the new terminology "stop".My Go -- organized by differences to make it useful in addition to the first answer by Daniel above:1) negative indexes.  Substring requires positive indexes, and will set a negative index to 0.  Slice\'s nagative index means the position from the end of the string.2) Swaping of indexes.  Substring will reorder the indexes to make the first index less than or equal to the second index.General comment -- I find it weird that the second index is the position after the last character of the slice or substring.  I would expect "1234".slice(2,2) to return "3".  This makes Andy\'s confusion above justified -- I would expect "1234".slice(2, -1) to return "34".  Yes, this means I\'m new to Javascript.  This means also this behavior:My 2c.The difference between substring and slice - is how they work with negative and overlooking lines abroad arguments:substring (start, end)Negative arguments are interpreted as zero. Too large values \xe2\x80\x8b\xe2\x80\x8bare truncated to the length of the string:\n\xc2\xa0\n    alert ( "testme" .substring (-2)); // "testme", -2 becomes 0Furthermore, if start > end, the arguments are interchanged, i.e. plot line returns between the start and end:sliceNegative values \xe2\x80\x8b\xe2\x80\x8bare measured from the end of the line:It is much more convenient than the strange logic substring.A negative value of the first parameter to substr supported in all browsers except IE8-.If the choice of one of these three methods, for use in most situations - it will be slice: negative arguments and it maintains and operates most obvious.The only difference between slice and substring method is of argumentsBoth take two arguments e.g. start/from and end/to.You cannot pass a negative value as first argument for substring method but for slice method to traverse it from end.Slice method argument details:REF: \nhttp://www.thesstech.com/javascript/string_slice_methodArgumentsstart_index\nIndex from where slice should begin. If value is provided in negative it means start from last. e.g. -1 for last character.\nend_index\nIndex after end of slice. If not provided slice will be taken from start_index to end of string. In case of negative value index will be measured from end of string.Substring method argument details:REF: http://www.thesstech.com/javascript/string_substring_methodArgumentsfrom\nIt should be a non negative integer to specify index from where sub-string should start.\nto\nAn optional non negative integer to provide index before which sub-string should be finished.DifferencesString.prototype.slice -Treatment of negative indicesStarting index greater than ending index" If [the starting index] is greater than or equal to the [treatment of the ending index] of the [string slice], slice() returns an empty string. "-- MDN\n  String.prototype.substring -Treatment of negative indicesStarting index greater than ending index" If [the starting index] is greater than [the ending index], then the effect of substring() is as if the two arguments were swapped; for example, str.substring(1, 0) == str.substring(0, 1). "-- MDNSimilaritiesEverything else is the same, I think, including:*The above is also true for the substr() method, except substr() does not have an ending index argument (see notes under String.prototype.substr).\nNotesString.prototype.substringWhere string.substring(startIndex, endIndex), Argument swapping limitation - if endIndex is not a number when it is passed as an argument, it becomes 0 internally for the substring() method (it does the same for slice(), too); however, it will not swap its value with startIndex (one thinks that it might have been reasonable for it to do so, but I digress). Therefore, if endIndex = NaN, then string.substring(startIndex, endIndex) === "" is true (as it is for slice() as well) regardless of the starting index provided.A thought with regards to argument swapping - if endIndex is undefined it becomes string.length; if startIndex is greater than the string\'s length, you might reason that it swaps its value with endIndex, but since this results in an empty string either way (since both values are beyond the indices of the string), it would be a moot point to do so. Instead, it\'s likely there is just an internal check to see if startIndex > string.length is true in the first place, which then returns an empty string if it is.String.prototype.substr\n[slightly beyond the scope of the question]For slice(start, stop), if stop is negative, stop will be set to: string.length \xe2\x80\x93 Math.abs(stop), rather (string.length \xe2\x80\x93 1) \xe2\x80\x93 Math.abs(stop).