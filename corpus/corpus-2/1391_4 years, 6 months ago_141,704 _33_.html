In Java: What is the difference between:?I have already checked the Javadoc multiple times and yet this never explains it well.\nI also ran a test and that didn\'t reflect any real meaning behind the way these methods are called.So please, instead of blaming me for asking this question and directing me to javadoc, try to give some efforts to explain the real meaning behind them. Thanks for your support.If you\'re unsure about something, try writing a test first.I did this:Prints:There\'s an empty line in the last block where getSimpleName returns an empty string.The upshot looking at this is:Adding arrays:Adds to Nick Holt\'s answer:Adding local classes, lambdas and the toString() method to complete the previous two answers. Further, I add arrays of lambdas and arrays of anonymous classes (which do not make any sense in practice though):This is the full output:So, here are the rules. First, lets start with primitive types and void:Now the rules for the getName() method:Now, the toString() method:The getCanonicalName() method:The getSimpleName() method:this is best document I found describing getName(), getSimpleName(), getCanonicalName()https://javahowtodoit.wordpress.com/2014/09/09/java-lang-class-what-is-the-difference-between-class-getname-class-getcanonicalname-and-class-getsimplename/I\'ve been confused by the wide range of different naming schemes as well, and was just about to ask and answer my own question on this when I found this question here. I think my findings fit it well enough, and complement what\'s already here. My focus is looking for documentation on the various terms, and adding some more related terms that might crop up in other places.Consider the following example:The simple name of D is D. That\'s just the part you wrote when declaring the class. Anonymous classes have no simple name. Class.getSimpleName() returns this name or the empty string. It is possible for the simple name to contain a $ if you write it like this, since $ is a valid part of an identifier.According to the JLS section 6.7, both a.b.C.D and a.b.C.D.D.D would be fully qualified names, but only a.b.C.D would be the canonical name of D. So every canonical name is a fully qualified name, but the converes is not always true. Class.getCanonicalName() will return the canonical name or null.Class.getName() is documented to return the binary name, as specified in JLS section 13.1. In this case it returns a.b.C$D for D and [La.b.C$D; for D[].This answer demonstrates that it is possible for two classes loaded by the same class loader to have the same canonical name but distinct binary names. Neither name is sufficient to reliably deduce the other: if you have the canonical name, you don\'t know which parts of the name are packages and which are containing classes. If you have the binary name, you don\'t know which $ were introduced as separators and which were part of some simple name.Anonymous classes and local classes have no fully qualified names but still have a binary name. The same holds for classes nested inside such classes. Every class has a binary name.Running javap -v -private on a/b/C.class shows that the bytecode refers to the type of d as La/b/C$D; and that of the array ds as [La/b/C$D;. These are called descriptors, and they are specified in JVMS section 4.3.The class name a/b/C$D used in both of these descriptors is what you get by replacing . by / in the binary name. The JVM spec apparently calls this the internal form of the binary name. JVMS section 4.2.1 describes it, and states that the difference from the binary name were for historical reasons.The file name of a class in one of the typical filename-based class loaders is what you get if you interpret the / in the internal form of the binary name as a directory separator, and append the file name extension .class to it. It\'s resolved relative to the class path used by the class loader in question.It is interesting to note that getCanonicalName() and getSimpleName() can raise InternalError when the class name is malformed. This happens for some non-Java JVM languages, e.g., Scala.Consider the following (Scala 2.11 on Java 8):This can be a problem for mixed language environments or environments that dynamically load bytecode, e.g., app servers and other platform software.