How can I find the memory used on my Android application, programmatically?I hope there is a way to do it. Plus, how do I get the free memory of the phone too?Note that memory usage on modern operating systems like Linux is an extremely complicated and difficult to understand area.  In fact the chances of you actually correctly interpreting whatever numbers you get is extremely low.  (Pretty much every time I look at memory usage numbers with other engineers, there is always a long discussion about what they actually mean that only results in a vague conclusion.)Note: we now have much more extensive documentation on Managing Your App\'s Memory that covers much of the material here and is more up-to-date with the state of Android.First thing is to probably read the last part of this article which has some discussion of how memory is managed on Android:Service API changes starting with Android 2.0Now ActivityManager.getMemoryInfo() is our highest-level API for looking at overall memory usage.  This is mostly there to help an application gauge how close the system is coming to having no more memory for background processes, thus needing to start killing needed processes like services.  For pure Java applications, this should be of little use, since the Java heap limit is there in part to avoid one app from being able to stress the system to this point.Going lower-level, you can use the Debug API to get raw kernel-level information about memory usage: android.os.Debug.MemoryInfoNote starting with 2.0 there is also an API, ActivityManager.getProcessMemoryInfo, to get this information about another process: ActivityManager.getProcessMemoryInfo(int[])This returns a low-level MemoryInfo structure with all of this data:But as to what the difference is between Pss, PrivateDirty, and SharedDirty...  well now the fun begins.A lot of memory in Android (and Linux systems in general) is actually shared across multiple processes.  So how much memory a processes uses is really not clear.  Add on top of that paging out to disk (let alone swap which we don\'t use on Android) and it is even less clear.Thus if you were to take all of the physical RAM actually mapped in to each process, and add up all of the processes, you would probably end up with a number much greater than the actual total RAM.The Pss number is a metric the kernel computes that takes into account memory sharing -- basically each page of RAM in a process is scaled by a ratio of the number of other processes also using that page.  This way you can (in theory) add up the pss across all processes to see the total RAM they are using, and compare pss between processes to get a rough idea of their relative weight.The other interesting metric here is PrivateDirty, which is basically the amount of RAM inside the process that can not be paged to disk (it is not backed by the same data on disk), and is not shared with any other processes.  Another way to look at this is the RAM that will become available to the system when that process goes away (and probably quickly subsumed into caches and other uses of it).That is pretty much the SDK APIs for this.  However there is more you can do as a developer with your device.Using adb, there is a lot of information you can get about the memory use of a running system.  A common one is the command adb shell dumpsys meminfo which will spit out a bunch of information about the memory use of each Java process, containing the above info as well as a variety of other things.  You can also tack on the name or pid of a single process to see, for example adb shell dumpsys meminfo system give me the system process:The top section is the main one, where size is the total size in address space of a particular heap, allocated is the kb of actual allocations that heap thinks it has, free is the remaining kb free the heap has for additional allocations, and pss and priv dirty are the same as discussed before specific to pages associated with each of the heaps.If you just want to look at memory usage across all processes, you can use the command adb shell procrank.  Output of this on the same system looks like:Here the Vss and Rss columns are basically noise (these are the straight-forward address space and RAM usage of a process, where if you add up the RAM usage across processes you get an ridiculously large number).Pss is as we\'ve seen before, and Uss is Priv Dirty.Interesting thing to note here: Pss and Uss are slightly (or more than slightly) different than what we saw in meminfo.  Why is that?  Well procrank uses a different kernel mechanism to collect its data than meminfo does, and they give slightly different results.  Why is that?  Honestly I haven\'t a clue.  I believe procrank may be the more accurate one...  but really, this just leave the point: "take any memory info you get with a grain of salt; often a very large grain."Finally there is the command adb shell cat /proc/meminfo that gives a summary of the overall memory usage of the system.  There is a lot of data here, only the first few numbers worth discussing (and the remaining ones understood by few people, and my questions of those few people about them often resulting in conflicting explanations):MemTotal is the total amount of memory available to the kernel and user space (often less than the actual physical RAM of the device, since some of that RAM is needed for the radio, DMA buffers, etc).MemFree is the amount of RAM that is not being used at all.  The number you see here is very high; typically on an Android system this would be only a few MB, since we try to use available memory to keep processes runningCached is the RAM being used for filesystem caches and other such things.  Typical systems will need to have 20MB or so for this to avoid getting into bad paging states; the Android out of memory killer is tuned for a particular system to make sure that background processes are killed before the cached RAM is consumed too much by them to result in such paging.Yes, you can get memory info programmatically and decide whether to do memory intensive work.Get VM Heap Size by calling:Get Allocated VM Memory by calling:Get VM Heap Size Limit by calling:Get Native Allocated Memory by calling:I made an app to figure out the OutOfMemoryError behavior and monitor memory usage.https://play.google.com/store/apps/details?id=net.coocood.oomresearchYou can get the source code at\nhttps://github.com/coocood/oom-researchThis is a work in progress, but this is what I don\'t understand:Why isn\'t the PID mapped to the result in activityManager.getProcessMemoryInfo()?  Clearly you want to make the resulting data meaningful, so why has Google made it so difficult to correlate the results?  The current system doesn\'t even work well if I want to process the entire memory usage since the returned result is an array of android.os.Debug.MemoryInfo objects, but none of those objects actually tell you what pids they are associated with.  If you simply pass in an array of all pids, you will have no way to understand the results.  As I understand it\'s use, it makes it meaningless to pass in more than one pid at a time, and then if that\'s the case, why make it so that activityManager.getProcessMemoryInfo() only takes an int array?Hackbod\'s is one of the best answers on StackÂ Overflow. It throws light on a very obscure subject. It helped me a lot.Another really helpful resource is this must-see video: Google I/O 2011: Memory management for Android AppsUPDATE:Process Stats, a service to discover how your app manages memory explained at the blog post Process Stats: Understanding How Your App Uses RAM by Dianne Hackborn: 1) I guess not, at least not from Java.\n2)Android Studio 0.8.10+ has introduced an incredibly useful tool called Memory Monitor.What it\'s good for:Figure 1. Forcing a GC (Garbage Collection) event on Android Memory MonitorYou can have plenty good information on your app\'s RAM real-time consumption by using it. We found out that all the standard ways of getting the total memory of the current process have some issues.Finally, we ended up using the following code:It returns VmRSS metric. You can find more details about it here: one, two and three.P.S. I noticed that the theme still has a lack of an actual and simple code snippet of how to estimate the private memory usage of the process if the performance isn\'t a critical requirement: