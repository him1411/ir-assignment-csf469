How do I make a function wait until all jQuery Ajax requests are done inside another function?In short, I need to wait for all Ajax requests to be done before I execute the next. But how?jQuery now defines a \'when\' function for this purpose.http://api.jquery.com/jQuery.when/It accepts any number of Deferred objects as arguments, and executes a function when all of them resolve.That means, if you want to initiate (for example) four ajax requests, then perform an action when they are done, you could do something like this:In my opinion, it makes for a clean and clear syntax, and avoids involving any global variables such as ajaxStart and ajaxStop, which could have unwanted side effects as your page develops.If you don\'t know in advance how many ajax arguments you need to wait for (i.e. you want to use a variable number of arguments), it can still be done but is just a little bit trickier. See Pass in an array of Deferreds to $.when() (and maybe jQuery .when troubleshooting with variable number of arguments).If you need deeper control over the failure modes of the ajax scripts etc., you can save the object returned by .when() - it\'s a jQuery Promise object encompassing all of the original ajax queries. You can call .then() or .fail() on it to add detailed success/failure handlers.If you want to wait until all ajax requests are finished in your document, no matter how many of them exists, just use $.ajaxStop event this way:In this case there is no need to guess how many requests can be in an application that might finish in the future. In some cases ajax requests can be part of a function\'s inner logic, which can be quite complicated (e.g. calling other functions), and in that case you might not wait until said function is done with its entire logic rather than only waiting for the ajax part to complete.$.ajaxStop here can also be bound to any html node that you think might be modified by ajax.Again the purpose of this handler is to know when there is no active ajax not to clear or reset something.I found a good answer by gnarf my self which is exactly what I was looking for :)jQuery ajaxQueue Then you can add a ajax request to the queue like this:NOTE: The above answers use functionality that didn\'t exist at the time that this answer was written.  I recommend using jQuery.when() instead of these approaches, but I\'m leaving the answer for historical purposes.-You could probably get by with a simple counting semaphore, although how you implement it would be dependent on your code.  A simple example would be something like...If you wanted this to operate like {async: false} but you didn\'t want to lock the browser, you could accomplish the same thing with a jQuery queue.Use the ajaxStop event.For example, let\'s say you have a loading ... message while fetching 100 ajax requests and you want to hide that message once loaded.From the jQuery doc:Do note that it will wait for all ajax requests being done on that page.jQuery allows you to specify if you want the ajax request to be asynchronous or not.  You can simply make the ajax requests synchronous and then the rest of the code won\'t execute until they return.For example:javascript is event-based, so you should never wait, rather set hooks/callbacksYou can probably just use the success/complete methods of jquery.ajaxOr you could use .ajaxComplete :though youy should post a pseudocode of how your(s) ajax request(s) is(are) called to be more   precise...A little workaround is something like this:Hope can be useful...On the basis of @BBonifield answer, I wrote a utility function so that semaphore logic is not spread in all the ajax calls.untilAjax is the utility function which invokes a callback function when all the ajaxCalls are completed.ajaxObjs is a array of ajax setting objects [http://api.jquery.com/jQuery.ajax/].fn is callback function Example: doSomething function uses untilAjax.  I highly recommend using $.when() if you\'re starting from scratch. Even though this question has over million answers, I still didn\'t find anything useful for my case. Let\'s say you have to deal with an existing codebase, already making some ajax calls and don\'t want to introduce the complexity of promises and/or redo the whole thing.We can easily take advantage of jQuery .data, .on and .trigger functions which have been a part of jQuery since forever.CodepenThe good stuff about my solution is:it\'s obvious what the callback exactly depends onthe function triggerNowOrOnLoaded doesn\'t care if the data has been already loaded or we\'re still waiting for itit\'s super easy to plug it into an existing codeIf you need something simple; once and done callbackI have met this problem and created a generic plugin jquery_counter to solve it:\nhttps://bitbucket.org/stxnext/jquery_counter/I found simple way, it using shift() Also you could use async.js.I think its better than $.when because you can merge all kinds of asynchronous call that does not support promises out of the box like timeouts, SqlLite calls etc. and not just ajax requests.My solution is as follows Worked quite nicely. I\'ve tried a lot of different ways of doing this, but I found this to be the simplest and most reusable. Hope it helpsLook at my solution:1.Insert this function (and variable) into your javascript file:2.Buil an array with your requests, like this:3.Create callback function:4.Call the runFunctionQueue function with parameters:Solution given by Alex works fine. Same concept but using it a little different way (when number of calls is not known in advance)http://garbageoverflow.blogspot.com/2014/02/wait-for-n-or-multiple-or-unknown.htmlThe most elegant solution I\'ve found that works best with a handful of asynchronous operations, in the absence of a library like jQuery or a facility similar to jQuery\'s .when(), is to have each Promise\'s fulfillment handler attach a fulfillment handler to one of the other Promises involved, like so (assuming promise1, promise2, and promise3 are Promise instances of unknown state):This works because the fulfilled/rejected callbacks will fire immediately if they are attached after a Promise has been fulfilled or rejected. Therefore, even if promise3 is fulfilled first, its fulfillment callback will not execute until it has been attached, which does not happen until promise1 and promise2 have been fulfilled. The drawback to this approach is that the nested function expressions can be a bit confusing. With a bit of refactoring, we can eliminate the need for nested functions;With this idiom we can construct unlimited conjunctions of Promises without reducing readability to a dreadful extent. And, with this idiom, we have the basis for a (simple, incomplete) when() function of our own:Try this way. make a loop inside java script function to wait until the ajax call finished.