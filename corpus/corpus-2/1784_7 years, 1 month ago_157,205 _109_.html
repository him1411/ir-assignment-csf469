I\'ve read various articles about mocking vs stubbing in testing, including Martin Fowler\'s Mocks Aren\'t Stubs, but still don\'t understand the difference.StubI believe the biggest distinction is that a stub you have already written with predetermined behavior. So you would have a class that implements the dependency (abstract class or interface most likely) you are faking for testing purposes and the methods would just be stubbed out with set responses. They would not do anything fancy and you would have already written the stubbed code for it outside of your test.MockA mock is something that as part of your test you have to setup with your expectations. A mock is not setup in a predetermined way so you have code that does it in your test. Mocks in a way are determined at runtime since the code that sets the expectations has to run before they do anything.DifferenceTests written with mocks usually follow an initialize -> set expectations -> exercise -> verify pattern to testing. While the pre-written stub would follow an initialize -> exercise -> verify. SimilarityThe purpose of both is to eliminate testing all the dependencies of a class or function so your tests are more focused and simpler in what they are trying to prove.There are several definitions of objects, that are not real. The general term is test double. This term encompasses: dummy, fake, stub, mock.According to Martin Fowler\'s article:Mocks vs Stubs = Behavioral testing vs State testingAccording to the principle of Test only one thing per test, there may be several stubs in one test, but generally there is only one mock.Test lifecycle with stubs:Test lifecycle with mocks:Both mocks and stubs testing give an answer for the question: What is the result?Testing with mocks are also interested in: How the result has been achieved?Stub is simple fake object. It just makes sure test runs smoothly.\nMock is smarter stub. You verify Your test passes through it.In the codeschool.com course, Rails Testing for Zombies, they give this definition of the terms:StubFor replacing a method with code that returns a specified result.MockA stub with an assertion that the method gets called.So as Sean Copenhaver described in his answer, the difference is that mocks set expectations (i.e. make assertions, about whether or how they get called).Here\'s a description of each one followed by with real world sample.Dummy - just bogus values to satisfy the API. Example: If you\'re testing a method of a class which requires many mandatory parameters in a constructor which have no effect on your test, then you may create dummy objects for the purpose of creating new instances of a class.Fake - create a test implementation of a class which may have a dependency on some external infrastructure. (It\'s good practice that your unit test does NOT actually interact with external infrastructure.)Example: Create fake implementation for accessing a database, replace it with in-memory collection.Stub - override methods to return hard-coded values, also referred to as state-based.Example: Your test class depends on a method Calculate() taking 5 minutes to complete. Rather than wait for 5 minutes you can replace its real implementation with stub that returns hard-coded values; taking only a small fraction of the time.Mock - very similar to Stub but interaction-based rather than state-based. This means you don\'t expect from Mock to return some value, but to assume that specific order of method calls are made.Example: You\'re testing a user registration class. After calling Save, it should call SendConfirmationEmail.Stubs and Mocks are actually sub types of Mock, both swap real implementation with test implementation, but for different, specific reasons.Stubs don\'t fail your tests, mock can.I think the simplest and clearer answer about this question is given from Roy Osherove in his book The art of Unit Testing (page 85)The easiest way to tell we\xe2\x80\x99re dealing with a stub is to notice  that the stub can never fail the test. The asserts the test uses are always against \n  the class under test.On the other hand, the test will use a mock object to verify whether the \n  test failed or not. [...]Again, the mock object is the object we use to see if the test failed or not.That means if you are making assertions against the fake it means you are using the fake as a mock,  if you are using the fake only to run the test without assertion over it you are using the fake as a stub.I think the most important difference between them is their intentions.Let me try to explain it in WHY stub vs. WHY mockSuppose I\'m writing test code for my mac twitter client\'s public timeline controllerHere is test sample codeBy writing mock, you discover the objects collaboration relationship by verifying the expectation are met, while stub only simulate the object\'s behavior.I suggest to read this article if you\'re trying to know more about mocks: http://jmock.org/oopsla2004.pdfA Mock is just testing behaviour, making sure certain methods are called.\nA Stub is a testable version (per say) of a particular object.What do you mean an Apple way?If you compare it to debugging:Stub is like making sure a method returns the correct valueMock is like actually stepping into the method and making sure everything inside is correct before returning the correct value.To be very clear and practical:Stub: A class or object that implements the methods of the class/object to be faked and returns always what you want.Example in JavaScript:Mock: The same of stub, but it adds some logic that "verifies" when a method is called so you can be sure some implementation is calling that method. As @mLevan says imagine as an example that you\'re testing a user registration class. After calling Save, it should call SendConfirmationEmail.A very stupid code Example:A fake is a generic term that can be used to describe either a stub\nor a mock object (handwritten or otherwise), because they both look like the\nreal object. Whether a fake is a stub or a mock depends on how it\xe2\x80\x99s used in\nthe current test. If it\xe2\x80\x99s used to check an interaction (asserted against), it\xe2\x80\x99s a\nmock object. Otherwise, it\xe2\x80\x99s a stub.\nFakes makes sure test runs smoothly. It means that reader of your future test will understand what will be the behavior of the fake object, without needing to read its source code (without needing to depend on external resource).\n\nWhat does test run smoothly mean?\nForexample in below code:You want to test mailService.SendEMail() method, to do that you need to simulate an Exception in you test method, so you just need to create a Fake Stub errorService class to simulate that result, then your test code will be able to test mailService.SendEMail() method. As you see you need to simulate a result which is from an another External Dependency ErrorService class. I like the explanantion put out by Roy Osherove [video link].Every class or object created is a Fake. It is a Mock if you verify\n  calls against it. Otherwise its a stub.Reading all the explanations above, let me try to condense:This slide explain the main differences very good.*From CSE 403 Lecture 16 , University of Washington (slide created by "Marty Stepp")Right from the paper Mock Roles, not Objects, by the developers of jMock :Stubs are dummy implementations of production code that return canned\n  results. Mock Objects act as stubs, but also include assertions to\n  instrument the interactions of the target object with its neighbours.So, the main differences are:To sum up, while also trying to disperse the confusion from Fowler\'s article title: mocks are stubs, but they are not only stubs.Stub helps us to run test. How? It gives values which helps to run test. These values are itself not real and we created these values just to run the test. For example we create a HashMap to give us values which are similar to values in database table. So instead of directly interacting with database we interact with Hashmap.Mock is an fake object which runs the test. where we put assert.See below example of mocks vs stubs using C# and Moq framework. Moq doesn\'t have a special keyword for Stub but you can use Mock object to create stubs too. I have used python examples in my answer to illustrate the differences.Stub - Stubbing is a software development technique used to implement methods of classes early in the development life-cycle. They are used commonly as placeholders for implementation of a known interface, where the interface is finalized or known but the implementation is not yet known or finalized. You begin with stubs, which simply means that you only write the definition of a function down and leave the actual code for later. The advantage is that you won\'t forget methods and you can continue to think about your design while seeing it in code.  You can also have your stub return a static response so that the response can be used by other parts of your code immediately. Stub objects provide a valid response, but it\'s static no matter what input you pass in, you\'ll always get the same response:Mock objects are used in mock test cases they validate that certain methods are called on those objects. Mock objects are simulated objects that mimic the behaviour of real objects in controlled ways. You typically creates a mock object to test the behaviour of some other object. Mocks let us simulate resources that are either unavailable or too unwieldy for unit testing.mymodule.py:test.py:This is a very basic example that just runs rm and asserts the parameter it was called with. You can use mock with objects not just functions as shown here, and you can also return a value so a mock object can be used to replace a stub for testing.More on unittest.mock, note in python 2.x mock is not included in unittest but is a downloadable module that can be downloaded via pip (pip install mock).I have also read "The Art of Unit Testing" by Roy Osherove and I think it would be great if a similar book was written using Python and Python examples. If anyone knows of such a book please do share. Cheers :)A stub is a fake object built for test purposes. A mock is a stub that records whether expected calls effectively occurred.I came across this interesting article by UncleBob The Little Mocker. It explains all the terminology in a very easy to understand manner, so its useful for beginners. Martin Fowlers article is a hard read especially for beginners like me.A stub is an empty function which is used to avoid unhandled exceptions during tests:A mock is an artificial function which is used to avoid OS, environment or hardware dependencies during tests:In terms of assertions and state:ReferencesA Stub is an object that implements an interface of a component, but instead of returning what the component would return when called, the stub can be configured to return a value that suits the test. Using stubs a unit test can test if a unit can handle various return values from its collaborator. Using a stub instead of a real collaborator in a unit test could be expressed like this:unit test --> stubunit test --> unit --> stubunit test asserts on results and state of unitFirst the unit test creates the stub and configures its return values. Then the unit test creates the unit and sets the stub on it. Now the unit test calls the unit which in turn calls the stub. Finally the unit test makes assertions about the results of the method calls on the unit.A Mock is like a stub, only it also has methods that make it possible determine what methods where called on the Mock. Using a mock it is thus possible to both test if the unit can handle various return values correctly, and also if the unit uses the collaborator correctly. For instance, you cannot see by the value returned from a dao object whether the data was read from the database using a Statement or a PreparedStatement. Nor can you see if the connection.close() method was called before returning the value. This is possible with mocks. In other words, mocks makes it possible to test a units complete interaction with a collaborator. Not just the collaborator methods that return values used by the unit. Using a mock in a unit test could be expressed like this:unit test --> mockunit test --> unit --> mockunit test asserts on result and state of unitunit test asserts on the methods called on mockMore Detail >> Herefollowing is my understanding...if you create test objects locally and feed your local service with that, you are using mock object. \nthis will give a test for the method you implemented in your local service.\nit is used to verify behaviorswhen you get the test data from the real service provider, though from a test version of interface and get a test version of the object, you are working with stubs\nthe stub can have logic to accept certain input and give corresponding output to help you perform state verification...Stubs are used on methods with an expected return value which you setup in your test.\nMocks are used on void methods which are verified in the Assert that they are called.Mock - A mock intercepts a call to a method or function (or a group of methods and functions like in the case of a mocked class). It is not an alternative to that method or function. In that interception, the mock can do whatever it wants, such as record the input and output, decide to short circuit the call, change the returned value, etc.Stub - A stub is a valid full working implementation of a method or function (or group of methods and functions like in the case of a stubbed class) that has an identical interface/signature to the method, function or group of methods and functions it is stubbing for. The stubbed implementation will generally only do things that are acceptable within the context of a unit test, that means it won\'t do IO for example, while mimicking the behavior of the thing it is stubbing.Stub and Mock testing point of view:Stub is dummy implementation done by user in static way mean i.e in Stub writing the implementation code. So it can not handle service definition and dynamic condition, Normally this is done in JUnit framework without using mocking framework.  Mock is also dummy implementation but its implementation done dynamic way by using Mocking frameworks like Mockito. So we can handle condition and service definition as dynamic way i.e. mocks can be created dynamically from code at runtime. So using mock we can implement Stubs dynamically.