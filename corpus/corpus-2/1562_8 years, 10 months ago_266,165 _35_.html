What is the best way to randomize the order of a generic list in C#? I\'ve got a finite set of 75 numbers in a list I would like to assign a random order to, in order to draw them for a lottery type application.Shuffle any (I)List with an extension method based on the Fisher-Yates shuffle:Usage:The code above uses the much criticised System.Random method to select swap candidates. It\'s fast but not as random as it should be. If you need a better quality of randomness in your shuffles use the random number generator in System.Security.Cryptography like so:A simple comparison is available at: http://thegrenade.blogspot.com/2010/02/when-random-is-too-consistent.htmlEdit: Since writing this answer a couple years back, many people have commented or written to me, to point out the big silly flaw in my comparison. They are of course right. There\'s nothing wrong with System.Random if it\'s used in the way it was intended. In my first example above, I instantiate the rng variable inside of the Shuffle method, which is asking for trouble if the method is going to be called repeatedly. Below is a fixed, full example based on a really useful comment received today from @weston here on SO.Program.cs:If we only need to shuffle items in a completely random order (just to mix the items in a list), I prefer this simple yet effective code that orders items by guid...I\'m bit surprised by all the clunky versions of this simple algorithm here. Fisher-Yates (or Knuth shuffle) is bit tricky but very compact. If you go to Wikipedia, you would see a version of this algorithm that has for-loop in reverse and lot of people don\'t really seem to understand why is it in reverse. The key reason is that this version of algorithm assumes that the random number generator Random(n) at your disposal has following two properties:However .Net random number generator does not satisfy #2 property. The Random.Next(n) instead returns number from 0 to n-1 inclusive. If you try to use for-loop in reverse then you would need to call Random.Next(n+1) which adds one additional operation.However, .Net random number generator has another nice function Random.Next(a,b) which returns a to b-1 inclusive. This actually perfectly fits nicely with implementation of this algorithm that has normal for-loop. So without further ado, here\'s the correct, efficient and compact implementation:Extension method for IEnumerable:EDIT\nThe RemoveAt is a weakness in my previous version. This solution overcomes that.Note the optional Random generator, if the base framework implementation of Random is not thread-safe or cryptographically strong enough for your needs, you can inject your implementation into the operation.A suitable implementation for a thread-safe cryptographically strong Random implementation can be found in this answer.Here\'s an idea, extend IList in a (hopefully) efficient way.You can achieve that be using this simple extension methodand you can use it by doing the followingI usually use:If you have a fixed number (75), you could create an array with 75 elements, then enumerate your list, moving the elements to randomized positions in the array.  You can generate the mapping of list number to array index using the Fisher-Yates shuffle.This is my preferred method of a shuffle when it\'s desirable to not modify the original. It\'s a variant of the Fisher\xe2\x80\x93Yates "inside-out" algorithm that works on any enumerable sequence (the length of source does not need to be known from start).This algorithm can also be implemented by allocating a range from 0 to length - 1 and randomly exhausting the indices by swapping the randomly chosen index with the last index until all indices have been chosen exactly once. This above code accomplishes the exact same thing but without the additional allocation. Which is pretty neat.With regards to the Random class it\'s a general purpose number generator (and If I was running a lottery I\'d consider using something different). It also relies on a time based seed value by default. A small alleviation of the problem is to seed the Random class with the RNGCryptoServiceProvider or you could use the RNGCryptoServiceProvider in a method similar to this (see below) to generate uniformly chosen random double floating point values but running a lottery pretty much requires understanding randomness and the nature of the randomness source.The point of generating a random double (between 0 and 1 exclusively) is to use to scale to an integer solution. If you need to pick something from a list based on a random double x that\'s always going to be 0 <= x && x < 1 is straight forward.Enjoy!If you don\'t mind using two Lists, then this is probably the easiest way to do it, but probably not the most efficient or unpredictable one: Here\'s an efficient Shuffler that returns a byte array of shuffled values. It never shuffles more than is needed. It can be restarted from where it previously left off. My actual implementation (not shown) is a MEF component that allows a user specified replacement shuffler.`Here\'s a thread-safe way to do this:Old post for sure, but I just use a GUID.  A GUID is always unique, and since it is regenerated every time the result changes each time.  A simple modification of the accepted answer that returns a new list instead of working in-place, and accepts the more general IEnumerable<T> as many other Linq methods do.A very simple approach to this kind of problem is to use a number of random element swap in the list.In pseudo-code this would look like this: