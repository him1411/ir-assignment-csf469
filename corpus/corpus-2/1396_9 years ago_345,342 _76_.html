When writing multi-threaded applications, one of the most common problems experienced are race conditions.  My questions to the community are:What is a race condition? How do you detect them? How do you handle them? Finally, how do you prevent them from occurring?A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don\'t know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data. Problems often occur when one thread does a "check-then-act" (e.g. "check" if the value is X, then "act" to do something that depends on the value being X) and another thread does something to the value in between the "check" and the "act". E.g:The point being, y could be 10, or it could be anything, depending on whether another thread changed x in between the check and act. You have no real way of knowing.In order to prevent race conditions from occurring, you would typically put a lock around the shared data to ensure only one thread can access the data at a time. This would mean something like this:A "race condition" exists when multithreaded (or otherwise parallel) code that would access a shared resource could do so in such a way as to cause unexpected results.Take this example:If you had 5 threads executing this code at once, the value of x WOULD NOT end up being 50,000,000.  It would in fact vary with each run.This is because, in order for each thread to increment the value of x, they have to do the following: (simplified, obviously)Any thread can be at any step in this process at any time, and they can step on each other when a shared resource is involved.  The state of x can be changed by another thread during the time between x is being read and when it is written back.Let\'s say a thread retrieves the value of x, but hasn\'t stored it yet.  Another thread can also retrieve the same value of x (because no thread has changed it yet) and then they would both be storing the same value (x+1) back in x!Example:Race conditions can be avoided by employing some sort of locking mechanism before the code that accesses the shared resource:Here, the answer comes out as 50,000,000 every time.For more on locking, search for: mutex, semaphore, critical section, shared resource.What is a Race Condition?You are planning to go to a movie at 5 pm. You inquire about the availability of the tickets at 4 pm. The representative says that they are available. You relax and reach the ticket window 5 minutes before the show. I\'m sure you can guess what happens: it\'s a full house. The problem here was in the duration between the check and the action. You inquired at 4 and acted at 5. In the meantime, someone else grabbed the tickets. That\'s a race condition - specifically a "check-then-act" scenario of race conditions.How do you detect them?Religious code review, multi-threaded unit tests. There is no shortcut. There are few Eclipse plugin emerging on this, but nothing stable yet.How do you handle and prevent them?The best thing would be to create side-effect free and stateless functions, use immutables as much as possible. But that is not always possible. So using java.util.concurrent.atomic, concurrent data structures, proper synchronization, and actor based concurrency will help.The best resource for concurrency is JCIP. You can also get some more details on above explanation here.There is an important technical difference between race conditions and data races. Most answers seem to make the assumption that these terms are equivalent, but they are not. A data race occurs when 2 instructions access the same memory location, at least one of these accesses is a write and there is no happens before ordering among these accesses. Now what constitutes a happens before ordering is subject to a lot of debate, but in general ulock-lock pairs on the same lock variable and wait-signal pairs on the same condition variable induce a happens-before order. A race condition is a semantic error. It is a flaw that occurs in the timing or the ordering of events that leads to erroneous program behavior. Many race conditions can be (and in fact are) caused by data races, but this is not necessary. As a matter of fact, data races and race conditions are neither the necessary, nor the sufficient condition for one another. This blog post also explains the difference very well, with a simple bank transaction example. Here is another simple example that explains the difference.Now that we nailed down the terminology, let us try to answer the original question.Given that race conditions are semantic bugs, there is no general way of detecting them. This is because there is no way of having an automated oracle that can distinguish correct vs. incorrect program behavior in the general case. Race detection is an undecidable problem.On the other hand, data races have a precise definition that does not necessarily relate to correctness, and therefore one can detect them. There are many flavors of data race detectors (static/dynamic data race detection, lockset-based data race detection, happens-before based data race detection, hybrid data race detection). A state of the art dynamic data race detector is ThreadSanitizer which works very well in practice.Handling data races in general requires some programming discipline to induce happens-before edges between accesses to shared data (either during development, or once they are detected using the above mentioned tools). this can be done through locks, condition variables, semaphores, etc. However, one can also employ different programming paradigms like message passing (instead of shared memory) that avoid data races by construction.A sort-of-canonical definition is "when two threads access the same location in memory at the same time, and at least one of the accesses is a write." In the situation the "reader" thread may get the old value or the new value, depending on which thread "wins the race." This is not always a bug—in fact, some really hairy low-level algorithms do this on purpose—but it should generally be avoided. @Steve Gury give\'s a good example of when it might be a problem.A race condition is a kind of bug, that happens only with certain temporal conditions.Example:\nImagine you have two threads, A and B.In Thread A:In Thread B:If thread A is preempted just after having check that object.a is not null, B will do a = 0, and when thread A will gain the processor, it will do a "divide by zero". This bug only happen when thread A is preempted just after the if statement, it\'s very rare, but it can happen.Race conditions occur in multi-threaded applications or multi-process systems.  A race condition, at its most basic, is anything that makes the assumption that two things not in the same thread or process will happen in a particular order, without taking steps to ensure that they do.  This happens commonly when two threads are passing messages by setting and checking member variables of a class both can access.  There\'s almost always a race condition when one thread calls sleep to give another thread time to finish a task (unless that sleep is in a loop, with some checking mechanism).Tools for preventing race conditions are dependent on the language and OS, but some comon ones are mutexes, critical sections, and signals.  Mutexes are good when you want to make sure you\'re the only one doing something.  Signals are good when you want to make sure someone else has finished doing something.  Minimizing shared resources can also help prevent unexpected behaviorsDetecting race conditions can be difficult, but there are a couple signs.  Code which relies heavily on sleeps is prone to race conditions, so first check for calls to sleep in the affected code.  Adding particularly long sleeps can also be used for debugging to try and force a particular order of events.  This can be useful for reproducing the behavior, seeing if you can make it disappear by changing the timing of things, and for testing solutions put in place.  The sleeps should be removed after debugging.The signature sign that one has a race condition though, is if there\'s an issue that only occurs intermittently on some machines.  Common bugs would be crashes and deadlocks.  With logging, you should be able to find the affected area and work back from there.Microsoft actually have published a really detailed article on this matter of race conditions and deadlocks. The most summarized abstract from it would be the title paragraph:A race condition occurs when two threads access a shared variable at\n  the same time. The first thread reads the variable, and the second\n  thread reads the same value from the variable. Then the first thread\n  and second thread perform their operations on the value, and they race\n  to see which thread can write the value last to the shared variable.\n  The value of the thread that writes its value last is preserved,\n  because the thread is writing over the value that the previous thread\n  wrote.A race condition is a situation on concurrent programming where two concurrent threads or processes and the resulting final state depends on who gets the resource first.A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but because of the nature of the device or system, the operations must be done in the proper sequence in order to be done correctly.In computer memory or storage, a race condition may occur if commands to read and write a large amount of data are received at almost the same instant, and the machine attempts to overwrite some or all of the old data while that old data is still being read. The result may be one or more of the following: a computer crash, an "illegal operation," notification and shutdown of the program, errors reading the old data, or errors writing the new data.Here is the classical Bank Account Balance example which will help newbies to understand Threads in Java easily w.r.t. race conditions:Race condition is not only related with software but also related with hardware too. Actually the term initially was coined by the hardware industry.According to wikipedia:The term originates with the idea of two signals racing each other to\n  influence the output first.Race condition in a logic circuit:Software industry took this term without modification, which makes it a little bit difficult to understand. You need to do some replacement to map it to the software world:So race condition in software industry means "two threads"/"two processes" racing each other to "influence some shared state", and the final result of the shared state will depend on some subtle timing difference, which could be caused by some specific thread/process launching order, thread/process scheduling, etc.Ok thats 4 questions. one by one answer is as under....What is a race condition?It occurs when the output and/or result of the process is critically dependent on the sequence or timing of other events i.e. e.g. 2 signals are racing to change the output first.How do you detect them? It leads to error which is difficult to localize.How do you handle them? Use SemaphoresAnd finally,How do you prevent them from occurring?One way to avoid race condition is using locking mechanism for resources. but locking resources can lead to deadlocks. which has to be dealt with.Try this basic example for better understanding of race condition:You don\'t always want to discard a race condition. If you have a flag which can be read and written by multiple threads, and this flag is set to \'done\' by one thread so that other thread stop processing when flag is set to \'done\', you don\'t want that "race condition" to be eliminated. In fact, this one can be referred to as a benign race condition. However, using a tool for detection of race condition, it will be spotted as a harmful race condition.More details on race condition here, http://msdn.microsoft.com/en-us/magazine/cc546569.aspx. Consider an operation which has to display the count as soon as the count gets incremented. ie., as soon as CounterThread increments the value DisplayThread needs to display the recently updated value.Output  Here CounterThread gets the lock frequently and updates the value before DisplayThread displays it. Here exists a Race condition. Race Condition can be solved by using SynchronzationYou can prevent race condition, if you use "Atomic" classes. The reason is just the thread don\'t separate operation get and set, example is below:As a result, you will have 7 in link "ai". \nAlthough you did two actions, but the both operation confirm the same thread and no one other thread will interfere to this, that means no race conditions!   