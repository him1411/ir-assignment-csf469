This command lists directories in the current path: ls -d */What exactly does the pattern */ do?And how can we give the absolute path in the above command (e.g. ls -d /home/alice/Documents) for listing only directories in that path?*/ is a pattern that matches all of the subdirectories in the current directory (* would match all files and subdirectories; the / restricts it to directories). Similarly, to list all subdirectories under /home/alice/Documents, use ls -d /home/alice/Documents/*/Example: echo */, echo */*/\nHere is what I got: Example: ls -d */\nHere is exactly what I got: Example: ls -l | grep "^d"\nHere is what I got:Example: for i in $(ls -d */); do echo ${i%%/}; done\nHere is what I got:If you like to have \'/\' as ending character, the command will be: for i in $(ls -d */); do echo ${i}; doneI use:This creates a single column with no trailing slash - useful in scripts.My two cents.For all folders without subfolders:For all folders with subfolders:An unquoted asterisk * will be interpreted as a pattern (glob) by the shell.The shell will use it in pathname expansion. It will then generate a list of filenames that match the pattern. A simple asterisk will match all filenames in the PWD (present working directory).A more complex pattern as */ will match all filenames that end in /. Thus, all directories. That is why the command:will be expanded (by the shell) to echo all directories in the PWD.To test this: Create a directory (mkdir) named like test-dir, and cd into it:Create some directories:The command echo ./*/ will remain reliable even with odd named files:But the spaces in filenames make reading a bit confusing.If instead of echo, we use ls, the shell is still what is expanding the list of filenames. The shell is the reason to get a list of directories in the PWD. The -d option to ls makes it list the present directory entry instead of the contents of each directory (as presented by default).However, this command is (somewhat) less reliable. It will fail with the odd named files listed above. It will choke with several names. You need to erase one by one till you find the ones with problems.The GNU ls will accept the "end of options" (--) key.To list each directory in its own line (in one column, similar to ls -1), use:And, even better, we could remove the trailing /:An attempt like this:Will fail on:Finally, using the argument list inside a function will not affect the arguments list of the present running shell. Simply:presents this list:This options are safe with several types of odd filenames.The tree command is also pretty useful here.  By default it will show all files and directories to a complete depth, with some ascii characters showing the directory tree.But if we wanted to get just the directories, without the ascii tree, and with the full path from the current directory, you could do:The arguments being:And if you then want the absolute path, you could start by specifying the full path to the current directory:And to limit the number of subdirectories, you can set the max level of subdirectories with -L level, eg:More arguments can be seen with man treeIf hidden directory is not needed to be listed, I offer:And if hidden directories is needed to be listed, use:ORI just add this to my .bashrc file (you could also just type it on the command line if you only need/want it for one session)then lsd will produce the desired result.to show folder lists without /Here is what I am using ls -d1 /Directory/Path/*;In case you\'re wondering why output from \'ls -d */\' gives you two trailing slashes, like:it\'s probably because somewhere your shell or session config files alias the ls command to a version of ls that includes the -F flag. That flag appends a character to each output name (that\'s not a plain file) indicating the kind of thing it is.  So one slash is the from matching the pattern \'*/\', and the other slash is the appended type indicator.To get rid of this issue, you could of course define a different alias for ls. However, to temporarily not invoke the alias, you can prepend the command with backslash:\\ls -d */One-liner to list directories only from "here".With file count.*/ is a filename matching pattern that matches directories in the current directory.To list directories only, I like this function:Put it in your .bashrc.Usage examples:NOTE: it will break if you use the -i option. Here is a fix for that:FYI, if you want to print all the files in multi-line, you can do a ls -1 which will print each file in a separate line. \nfile1\nfile2\nfile3for dir in $(ls); test -d $i && echo $i ; doneI partially solved with :Well , this reduce to me , the mayor part :)Adding on to make it full circle, to retrieve the path of every folder, use a combination of Albert\'s answer as well as Gordans that should be pretty usefull.Output:Many answers here don\'t actually use ls (or only use it in the trivial sense of ls -d, while using wildcards for the actual subdirectory matching. A true ls solution is useful, since it allows the use of ls options for sorting order, etc.One solution using ls has been given, but it does something different from the other solutions in that it excludes symlinks to directories:(possibly piping through sed or awk to isolate the file names)In the (probably more common) case that symlinks to directories should be included, we can use the -p option of ls:or, getting rid of the trailing slashes:We can add options to ls as needed (if a long listing is used, the -l is no longer required).note: if we want trailing slashes, but don\'t want them highlighted by grep, we can hackishly remove the highlighting by making the actual matched portion of the line empty: