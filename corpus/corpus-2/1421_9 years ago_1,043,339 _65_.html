How do I determine the size of my array in C? That is, the number of elements the array can hold?Executive summary:To determine the size of your array in bytes, you can use the sizeof\noperator:On my computer, ints are 4 bytes long, so n is 68.To determine the number of elements in the array, we can divide\nthe total size of the array by the size of the array element.\nYou could do this with the type, like this:and get the proper answer (68 / 4 = 17), but if the type of\na changed you would have a nasty bug if you forgot to change\nthe sizeof(int) as well.So the preferred divisor is sizeof(a[0]), the size of the\nzeroeth element of the array.Another advantage is that you can now easily parameterize\nthe array name in a macro and get:The sizeof way is the right way iff you are dealing with arrays not received as parameters. An array sent as a parameter to a function is treated as a pointer, so sizeof will return the pointer\'s size, instead of the array\'s.Thus, inside functions this method does not work. Instead, always pass an additional parameter size_t size indicating the number of elements in the array.Test:Output (in a 64-bit Linux OS):Output (in a 32-bit windows OS):It is worth noting that sizeof doesn\'t help when dealing with an array value that has decayed to a pointer: even though it points to the start of an array, to the compiler it is the same as a pointer to a single element of that array. A pointer does not "remember" anything else about the array that was used to initialize it.The sizeof "trick" is the best way I know, with one small but (to me, this being a major pet peeve) important change in the use of parenthesis.As the Wikipedia entry makes clear, C\'s sizeof is not a function; it\'s an operator. Thus, it does not require parenthesis around its argument, unless the argument is a type name. This is easy to remember, since it makes the argument look like a cast expression, which also uses parenthesis.So: If you have the following:You can find the number of elements with code like this:That, to me, reads a lot easier than the alternative with parenthesis. I also favor use of the asterisk in the right-hand part of the division, since it\'s more concise than indexing.Of course, this is all compile-time too, so there\'s no need to worry about the division affecting the performance of the program. So use this form wherever you can.It is always best to use sizeof on an actual object when you have one, rather than on a type, since then you don\'t need to worry about making an error and stating the wrong type.For instance, say you have a function that outputs some data as a stream of bytes, for instance across a network. Let\'s call the function send(), and make it take as arguments a pointer to the object to send, and the number of bytes in the object. So, the prototype becomes:And then you need to send an integer, so you code it up like this:Now, you\'ve introduced a subtle way of shooting yourself in the foot, by specifying the type of foo in two places. If one changes but the other doesn\'t, the code breaks. Thus, always do it like this:Now you\'re protected. Sure, you duplicate the name of the variable, but that has a high probability of breaking in a way the compiler can detect, if you change it.Check out this link for explanationIf you know the data type of the array, you can use something like:Or if you don\'t know the data type of array, you can use something like:Note: This thing only works if the array is not defined at run time (like malloc) and the array is not passed in a function. In both cases, arr (array name) is a pointer.For multidimensional arrays it is a tad more complicated. Oftenly people define explicit macro constants, i.e. But these constants can be evaluated at compile-time too with sizeof:Note that this code works in C and C++. For arrays with more than two dimensions useetc., ad infinitum.The macro ARRAYELEMENTCOUNT(x) that everyone is making use of evaluates incorrectly. This, realistically, is just a sensitive matter, because you can\'t have expressions that result in an \'array\' type.Actually evaluates as:WhereasIt correctly evaluates to:This really doesn\'t have a lot to do with the size of arrays explicitly. I\'ve just noticed a lot of errors from not truly observing how the C preprocessor works. You always wrap the macro parameter, not an expression in might be involved in.This is correct; my example was a bad one. But that\'s actually exactly what should happen. As I previously mentioned p + 1 will end up as a pointer type and invalidate the entire macro (just like if you attempted to use the macro in a function with a pointer parameter).At the end of the day, in this particular instance, the fault doesn\'t really matter (so I\'m just wasting everyone\'s time; huzzah!), because you don\'t have expressions with a type of \'array\'. But really the point about preprocessor evaluation subtles I think is an important one.Size of an array in C:"you\'ve introduced a subtle way of shooting yourself in the foot"C \'native\' arrays do not store their size. It is therefore recommended to save the length of the array in a separate variable/const, and pass it whenever you pass the array, that is:You SHOULD always avoid native arrays (unless you can\'t, in which case, mind your foot). If you are writing C++, use the STL\'s \'vector\' container. "Compared to arrays, they provide almost the same performance", and they are far more useful!See:\nhttp://www.cplusplus.com/reference/stl/vector/You can use sizeof operator but it will not work for functions because it will take the reference of pointer\nyou can do the following to find the length of an arrayRefernce of the above code \nC program to find the number of elements in an array@ Magnus: The standard defines sizeof as yielding the number of bytes in the object and that sizeof (char) is always one. The number of bits in a byte is implementation specific.Edit: ANSI C++ standard section 5.3.3 Sizeof:The sizeof operator yields the number of bytes in the object representation  of its operand. [...] sizeof (char), sizeof (signed char) and sizeof (unsigned char) are 1; the result of sizeof applied to any other fundamental type is implementation-defined.Section 1.6 The C++ memory model:The fundamental storage unit in the C++ memory model is the  byte. A byte is at least large enough to contain any member of the basic execution character set and is composed of a contiguous sequence of bits, the  number of which is implementation-defined.@Skizz: I am pretty sure I am right, although the best "source" I can give you at the moment is Wikipedia, from the article on sizeof:Wikipedia is wrong, Skizz is right. sizeof(char) is 1, by definition.I mean, just read the Wikipedia entry really closely to see that it\'s wrong. "multiples of char".  sizeof(char) can never be anything other than "1". If it were, say, 2, it would mean that sizeof(char) was twice the size of char!If you really want to do this to pass around your array I suggest implementing a structure to store a pointer to the type you want an array of and an integer representing the size of the array. Then you can pass that around to your functions. Just assign the array variable value (pointer to first element) to that pointer. Then you can go Array.arr[i] to get the i-th element and use Array.size to get the number of elements in the array.I included some code for you. It\'s not very useful but you could extend it with more features. To be honest though, if these are the things you want you should stop using C and use another language with these features built in.The best way is you save this information, for example, in a structure:Implement all necessary functions such as create, destroy, check equality, and everything else you need. It is easier to pass as a parameter.You can use the & operator. Here is the source code:Here is the sample outputUse:Output:Reason: calculates the number of elements held in the array rather than the number of free spaces allocated to it.