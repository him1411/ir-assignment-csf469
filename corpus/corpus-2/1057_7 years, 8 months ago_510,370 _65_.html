Is there a way to get the current \'Context\' instance by using a static method? I\'m looking for that way because I hate saving the \'Context\' instance each time it changes.Do this:In the Android Manifest file, declare the following.Then write the class:Now everywhere call MyApplication.getAppContext() to get your application context statically.No, I don\'t think there is.  Unfortunately, you\'re stuck calling getApplicationContext() from Activity or one of the other subclasses of Context.  Also, this question is somewhat related.The majority of apps that want a convenient method to get the application context create their own class which extends android.app.Application.GUIDEYou can accomplish this by first creating a class in your project like the following:Then, in your AndroidManifest you should specify the name of your class in the AndroidManifest.xml\xe2\x80\x99s  tag:You can then retrieve the application context in any static method using the following:WARNINGBefore adding something like the above to your project you should consider what the documentation says:There is normally no need to subclass Application. In most situation,\n  static singletons can provide the same functionality in a more modular\n  way. If your singleton needs a global context (for example to register\n  broadcast receivers), the function to retrieve it can be given a\n  Context which internally uses Context.getApplicationContext() when\n  first constructing the singleton.REFLECTIONThere is also another way to get the application context using reflection. Reflection is often looked down upon in Android and I personally think this should not be used in production. To retrieve the application context we must invoke a method on a hidden class (ActivityThread) which has been available since API 1:There is one more hidden class (AppGlobals) which provides a way to get the application context in a static way. It gets the context using ActivityThread so there really is no difference between the following method and the one posted above:Happy coding!Here is an undocumented way to get an Application (which is a Context) from anywhere in the UI thread. It relies on the hidden static method ActivityThread.currentApplication(). It should work at least on Android 4.x.Note that it is possible for this method to return null, e.g. when you call the method outside of the UI thread, or the application is not bound to the thread.It is still better to use @RohitGhatol\'s solution if you can change the Application code.It depends on what you are using the context for. I can think of at least one disadvantage to that method:If you are trying to create an AlertDialog with AlertDialog.Builder, the Application context won\'t work. I believe you need the context for the current Activity...Assuming we\'re talking about getting the Application Context, I implemented it as suggested by @Rohit Ghatol extending Application. What happened then, it\'s that there\'s no guarantee that the context retrieved in such a way will always be non-null. At the time you need it, it\'s usually because you want to initialize an helper, or get a resource, that you cannot delay in time; handling the null case will not help you.\nSo I understood I was basically fighting against the Android architecture, as stated in the docsNote: There is normally no need to subclass Application. In most situations, static singletons can provide the same functionality in a more modular way. If your singleton needs a global context (for example to register broadcast receivers), include Context.getApplicationContext() as a Context argument when invoking your singleton\'s getInstance() method.and explained by Dianne HackbornThe only reason Application exists as something you can derive from is because during the pre-1.0 development one of our application developers was continually bugging me about needing to have a top-level application object they can derive from so they could have a more "normal" to them application model, and I eventually gave in.\n  I will forever regret giving in on that one. :)She is also suggesting the solution to this problem:If what you want is some global state that can be shared across different parts of your app, use a singleton. [...] And this leads more naturally to how you should be managing these things -- initializing them on demand.so what I did was getting rid of extending Application, and pass the context directly to the singleton helper\'s getInstance(), while saving a reference to the application context in the private constructor:the caller will then pass a local context to the helper:So, to answer this question properly: there are ways to access the Application Context statically, but they all should be discouraged, and you should prefer passing a local context to the singleton\'s getInstance().For anyone interested, you can read a more detailed version at fwd blogIf you\'re open to using RoboGuice, you can have the context injected into any class you want.  Here\'s a small sample of how to do it with RoboGuice 2.0 (beta 4 at time of this writing)I\'ve used this at some point:This is a valid context I used at getting system services and worked.But, I used it only in framework/base modifications and did not try it in Android applications.A warning that you must know: When registering for broadcast receivers with this context, it will not work and you will get:java.lang.SecurityException: Given caller package android is not running in process ProcessRecordI think you need a body for the getAppContext() method:You can use the following:MainActivity.java:Any other class:I use a variation of the Singleton design pattern to help me with this.I then call ApplicationContextSingleton.setContext( this ); in my activity.onCreate() and ApplicationContextSingleton.setContext( null ); in onDestroy();I just released a jQuery-inspired framework for Android called Vapor API that aims to make app development simpler.The central $ facade class maintains a WeakReference (link to awesome Java blog post about this by Ethan Nicholas) to the current Activity context which you can retrieve by calling:A WeakReference maintains a reference without preventing the garbage collection reclaiming the original object, so you shouldn\'t have a problem with memory leaks.The downside of course is that you run the risk that $.act() could return null. I have not come across this scenario yet though, so it\'s perhaps just a minimal risk, worth mentioning.You can also set the context manually if you are not using VaporActivity as your Activity class:Also, much of the Vapor API framework uses this stored context inherently which might mean you needn\'t store it yourself at all if you decide to use the framework. Check out the site for more information and samples.I hope that helps :)If you for some reason want Application context in any class, not just those extending application/activity, maybe for some factory or helper classes. You can add the following singleton to your app.then initialize it in your application class\'s onCreate withuse it anywhere by callingI don\'t recommend this approach to anything but application context however. As it can cause memory leaks.According to this source you can obtain your own Context by extending ContextWrapperJavaDoc for ContextWrapper Proxying implementation of Context that simply delegates all of its calls to another Context. Can be subclassed to modify behavior without changing the original Context. So i modified the accepted answer because its causing a memory leak, this is what i came up with...What i actually did is, assign a context to an object and return the object as a context(casting it to context). Hope it help.this will be inside AndroidManifest.xml fileand this is MyApplication.java file