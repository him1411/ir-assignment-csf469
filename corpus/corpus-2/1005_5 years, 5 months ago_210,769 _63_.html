Ryan Davis\xe2\x80\x99s Ruby QuickRef says (without explanation):Don\xe2\x80\x99t rescue Exception. EVER. or I will stab you.Why not? What\xe2\x80\x99s the right thing to do?Exception is the root of Ruby\'s exception hierarchy, so when you rescue Exception you rescue from everything, including subclasses such as SyntaxError, LoadError, and Interrupt.Rescuing Interrupt prevents the user from using CTRLC to exit the program.Rescuing SignalException prevents the program from responding correctly to signals. It will be unkillable except by kill -9.Rescuing SyntaxError means that evals that fail will do so silently.All of these can be shown by running this program, and trying to CTRLC or kill it:Rescuing from Exception isn\'t even the default. Doingdoes not rescue from Exception, it rescues from StandardError. You should generally specify something more specific than the default StandardError, but rescuing from Exception broadens the scope rather than narrowing it, and can have catastrophic results and make bug-hunting extremely difficult.If you have a situation where you do want to rescue from StandardError and you need a variable with the exception, you can use this form:which is equivalent to:One of the few common cases where it\xe2\x80\x99s sane to rescue from Exception is for logging/reporting purposes, in which case you should immediately re-raise the exception:The real rule is: Don\'t throw away exceptions.  The objectivity of the author of your quote is questionable, as evidenced by the fact that it ends withor I will stab youOf course, be aware that signals (by default) throw exceptions, and normally long-running processes are terminated through a signal, so catching Exception and not terminating on signal exceptions will make your program very hard to stop.  So don\'t do this:No, really, don\'t do it.  Don\'t even run that to see if it works.However, say you have a threaded server and you want all exceptions to not:Then this is perfectly acceptable in your connection handling thread:The above works out to a variation of Ruby\'s default exception handler, with the advantage that it doesn\'t also kill your program.  Rails does this in its request handler.Signal exceptions are raised in the main thread.  Background threads won\'t get them, so there is no point in trying to catch them there.This is particularly useful in a production environment, where you do not want your program to simply stop whenever something goes wrong. Then you can take the stack dumps in your logs and add to your code to deal with specific exception further down the call chain and in a more graceful manner.Note also that there is another Ruby idiom which has much the same effect:In this line, if do_something raises an exception, it is caught by Ruby, thrown away, and a is assigned "something else".Generally, don\'t do that, except in special cases where you know you don\'t need to worry.  One example:The debugger function is a rather nice way to set a breakpoint in your code, but if running outside a debugger, and Rails, it raises an exception.  Now theoretically you shouldn\'t be leaving debug code lying around in your program (pff! nobody does that!)  but you might want to keep it there for a while for some reason, but not continually run your debugger.Note:If you\'ve run someone else\'s program that catches signal exceptions and ignores them, (say the code above) then:If you are working with someone else\'s program which is, for whatever reason, peppered with these ignore-exception blocks, then putting this at the top of the mainline is one possible cop-out:This causes the program to respond to the normal termination signals by immediately terminating, bypassing exception handlers,  with no cleanup.  So it could cause data loss or similar.  Be careful!If you need to do this:you can actually do this:In the second case, critical cleanup will be called every time, whether or not an exception is thrown.Because this captures all exceptions. It\'s unlikely that your program can recover from any of them. You should handle only exceptions that you know how to recover from. If you don\'t anticipate a certain kind of exception, don\'t handle it, crash loudly (write details to the log), then diagnose logs and fix code.Swallowing exceptions is bad, don\'t do this.Let\'s say you are in a car (running Ruby). You recently installed a new steering wheel with the over-the-air upgrade system (which uses eval), but you didn\'t know one of the programmers messed up on syntax.You are on a bridge, and realize you are going a bit towards the railing, so you turn left.oops! That\'s probably Not Good\xe2\x84\xa2, luckily, Ruby raises a SyntaxError.The car should stop immediately - right?Nope.beep beepWarning: Caught SyntaxError Exception.Info: Logged Error - Continuing Process.You notice something is wrong, and you slam on the emergency breaks (^C: Interrupt)beep beepWarning: Caught Interrupt Exception.Info: Logged Error - Continuing Process.Yeah - that didn\'t help much. You\'re pretty close to the rail, so you put the car in park (killing: SignalException).beep beepWarning: Caught SignalException Exception.Info: Logged Error - Continuing Process.At the last second, you pull out the keys (kill -9), and the car stops, you slam forward into the steering wheel (the airbag can\'t inflate because you didn\'t gracefully stop the program - you terminated it), and the computer in the back of your car slams into the seat in front of it. A half-full can of Coke spills over the papers. The groceries in the back are crushed, and most are covered in egg yolk and milk. The car needs serious repair and cleaning. (Data Loss) Hopefully you have insurance (Backups). Oh yeah - because the airbag didn\'t inflate, you\'re probably hurt (getting fired, etc).But wait! There\'s more reasons why you might want to use rescue Exception => e!Let\'s say you\'re that car, and you want to make sure the airbag inflates if the car is going more than 5mph before stopping.Here\'s the exception to the rule: You can catch Exception only if you re-raise the exception. So, a better rule is to never swallow Exception, and always re-raise the error.But adding rescue is both easy to forget in a language like Ruby, and putting a rescue statement right before re-raising an issue feels a little non-DRY. And you do not want to forget the raise statement. And if you do, good luck trying to find that error.Thankfully, Ruby is awesome, you can just use the ensure keyword, which makes sure the code runs. The ensure keyword will run the code no matter what - if an exception is thrown, if one isn\'t, the only exception being if the world ends (or other unlikely events).Boom! And that code should run anyways. The only reason you should use rescue Exception => e is if you need access to the exception, or if you only want code to run on an exception. And remember to re-raise the error. Every time. Or you will have 3 people stabbing you (including your boss).Don\'t rescue Exception => e (and not re-raise the exception) - or you might drive off a bridge.That\'s a specific case of the rule that you shouldn\'t catch any exception you don\'t know how to handle. If you don\'t know how to handle it, it\'s always better to let some other part of the system catch and handle it.This will also hide bugs from you, for example if you mistyped a method name: