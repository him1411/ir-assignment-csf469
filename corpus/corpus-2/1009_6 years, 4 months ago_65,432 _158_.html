I have RSI problems and have tried 30 different computer keyboards which all caused me pain. Playing piano does not cause me pain. I have played piano for around 20 years without any pain issues. I would like to know if there is a way to capture MIDI from a MIDI keyboard and output keyboard strokes. I know nothing at all about MIDI but I would like some guidance on how to convert this signal into a keystroke.A good library in .NET with full midi support (BASS), go to http://www.un4seen.com.And for the other part, translating keyboard midi notes to keys and more, I would go for AutoItX, the ActiveX/COM and DLL interface to autoIt. Info and download, go to http://www.autoitscript.com/site/autoit/No need to write keyboard driver.I haven\'t done any MIDI programming in years, but your fundamental idea is very sound (no pun).MIDI is a stream of "events" (or "messages"), two of the most fundamental being "note on" and "note off" which carry with them the note number (0 = C five octaves below middle C, through 127 = G five octaves above the G above middle C, in semi-tones). These events carry a "velocity" number on keyboards that are velocity sensitive ("touch sensitive"), with a force of (you guessed it) between 0 and 127.Between velocity, chording, and the pedals, I\'d think you could come up with quite a good "typing" interface for the piano keyboard. Chording in particular could be a very powerful technique — as I mentioned in the comments, it\'s why rank-and-file stenographers can use a stenotype machine to keep up with people talking for hours in a row, when even top-flight typists wouldn\'t be able to for any length of time via normal typewriter-style keyboards. As with machine stenography, you\'d need a "dictionary" of the meanings of chords and sequences of chords. (Can you tell I used to work in the software side of machine stenography?)To do this, the fundamental pieces are:To be most broadly-compatible with software, you\'d have to write this as a keyboard device driver. This is a plug-in to the operating system that serves as a source for keyboard events, talking to the underlying hardware (in your case, the piano keyboard). For Windows and Linux, you\'re probably going to want to use C for that.However, since you\'re just generating keystrokes (not trying to intercept them, which I was trying to do years ago), you may be able to use whatever features the operating system has for sending artificial keystrokes. Windows has an interface for doing that (probably several, the one I\'m thinking of is SendInput but I know there\'s some "journal" interface that does something similar), and I\'m sure other operating systems do as well. That may well be sufficient for your purposes — it\'s where I\'d start, because the device driver route is going to be awkward and you\'d probably have to use a different language for it than Java. (I\'m a big fan of Java, but the interfaces that operating systems use to talk to device drivers tend to be more easily consumed via C and similar.)Update: More about the "dictionary" of chords to keystrokes:Basically, the dictionary is a trie (thanks, @Adam) that we search with longest-prefix matching. Details:In machine stenography, the stenographer writes by pressing multiple keys on the stenotype machine at the same time, then releasing them all. They call this a "stroke" of the keyboard; it\'s like playing a chord on the piano. Strokes frequently (but not always) correspond to a syllable of spoken language. Like syllables, sometimes one stroke (chord) has meaning all on its own, other times it only has meaning combined with following strokes. (Think "good" vs. "good" followed by "bye"). Although they\'ll be heavily influenced by the school at which they studied, each stenographer will have their own "dictionary" of what strokes they use to mean what, a dictionary they will continuously hone over the course of their working lives. The dictionary will have entries where the stenographic part ("steno", for short) is one stroke long, or multiple strokes long. Frequently, there will be several entries with the same starting stroke which are differentiated by their length and by the subsequent strokes. For instance (and I won\'t use real steno here, just placeholders), there may be these entries:(Those letters aren\'t meant to be musical notes, just abstract markers.)Note that A starts multiple entries, and also note that how you translate a C stroke depends on whether you\'ve previously seen an A, a B, or you\'re starting fresh.Also note that (although not shown in the very small sample above), there may be multiple ways to "play" the same word or phrase, rather than just one. Stenographers do that to make it easier to flow from a preceding word to the next depending on hand position. There\'s an obvious analogy to music there, and you could use that to make your typing flow more akin to playing music, in order to both prevent this from negatively affecting your piano playing and to maximize the likelihood of this actually helping with the RSI.When translating steno into standard text, again we use a "longest-prefix match" search: The translation algorithm starts with the first stroke ever written, and looks for entries starting with that stroke. If there is only one entry, and it\'s one stroke long, then we can reliably say "that\'s the entry to use", output the corresponding text, and then start fresh with the next stroke. But more likely, that stroke starts multiple entries of varying lengths. So we look at the next stroke and see if there are entries that start with those two strokes in order; and so on until we get a match.So with the dictionary above, suppose we saw this sequence:Here\'s how we\'d translate it:Aspects of the above to note:Consider doing something in hardware that emulates a usb (or ps/2?) keyboard.  You will no longer be dependent on a specific OS, or specific OS API.  A hardware solution will stand the test of time.  Don\'t be stuck using an old API in Windows 7 when everyone else is running Windows 11!  Arduino is pretty easy to learn.There is a ton of info and help out there for Arduino.  It is a hardware hacking platform built for newbies.  It will only get bigger now that Google is pushing Arduino.EDIT:  Virtual USB Keyboard software  and hardwareIt sounds to me like you\'re looking less for advice on how to build this yourself and more asking what resources are already out there to accomplish what you want. Depending on your OS, there are many ways to accomplish this without having to write your own program from scratch:MIDI StrokeFree. For Mac OS X 10.3 and up. This one specifically comes with "the ability to use any MIDI keyboard as a full blown computer keyboard replacement."Bome\'s MIDI TranslatorFree/Postcardware (it\'s a bit odd). For Windows 2000 and up, and Mac OS X. It initially appears to be more geared towards AutoHotkey-type usage, but on further looking I think it could do what you want nicely.Max and aka.keyboardFree. For Mac OS X. Not exactly a "ready out of the box" solution, but if you are comfortable with basic device configuration, it shouldn\'t be too bad.You can access the hardware with source code samples in .NET in MIDI DotNet.A complete working sample as sourcecode to create MIDI notes data stream is in VB 5/6-Tipp 0521: MIDI-T\xc3\xb6ne erzeugen (Visual Basic 6.0, somewhere is .NET version too)A way to simulate keyboard strokes is in VB 5/6-Tipp 0155: Tastaturereignisse simulieren (Visual Basic 6.0, somewhere is .NET version too)And recognize keystrokes is describedin Tipp-Upload: VB.NET 0266: Globaler KeyHook. Then, just use a good working matrix for a piano player\nOn piano and when you\'re a good player, you can have 10 fingers on the keyboard and if the matrix is usable you can be much more quickly that any computer keyboard user I think. :-)In that case, if I understand your question right, it should not be a big thing.I studied piano performance in college and then got into interaction design, programming, and using Vim, so I have actually spent a lot of time prototyping things like this. You can get this working pretty quick in Linux by using the graphical programming language for multimedia artists, "Pure Data," along with the x11key external by Alex Andre. On Mac, you can use MidiStroke. I believe a method on Windows involved the MidiOx and AutoHotKey tools. At another time I had a version going using the Java plugin for Max/MSP. I believe Patrice Colet made a windows external for Pure Data that worked as well, but I can\'t seem to locate it anymore. Also, there\'s an external for MaxMSP that can do this on Windows. Finally, the non-free but awesome Osculator can do what you want - see the features page.When I got it working, I never stuck with it, because I couldn\'t stop tooling with the layout. It was cool just having my monitor on my electric keyboard, though! Good luck.You stated that you "know nothing at all about MIDI". MIDI technology is fairly straight-forward once you grasp it, but it can be confusing at the outset. One of the resources that has been tremendously helpful for me in understanding the foundations for MIDI (which are certainly necessary if you want to program MIDI interactions), is a book called MIDI for the Technophobe. It\'s an easy book to read and is very helpful.  In my experience developing interactive multimedia, there are two very similar programs I have encountered that facilitate connecting and mapping signals/inputs from any device.These are Max for a Mac environment and Pure Data for a PC environment. Both have a plethora of online documentation and YouTube tutorials. The video Max/MSP Tutorial 1 - using your computer keyboard as midikeyboard (ableton style) demonstrates a program built in Max that maps a computer keyboard to a MIDI keyboard\'s inputs (which is basically the exact opposite of what you are trying to do). You could get your intended results by using the same pattern, but reversing the signals/mappings.AutoHotKey is a free open source utility for Windows that allows you to remap keys and buttons on your devices to macros. It natively supports QWERTY keyboards, joysticks and mouse macros.   However, I was able to find an implementation supporting the specific mapping you are looking for. These two threads explain the process:MIDI IN support in AutoHotkey , the discussion of the use case. The author was looking for a program that could detect MIDI IN input and translate that to keypresses.MIDI input library , the solution to the author\'s problem and the posted code/patch to AutoHotKey which actually implements your intended result.Basically, it looks like AutoHotKey, along with this user\'s custom patch, will provide exactly what you need to create a mapping from a MIDI keyboard to a QWERTY keyboard\'s input signal.  All you would have to do is install, configure and define your mappings.Some of the other answers have given you much more extensive information on MIDI and MIDI programming, in general, but as your post states that doesn\'t seem to be quite what you are looking for. I would like to help you more if possible, but it would be easier if you could be more specific about the type of information you are looking for.  For instance, are you more interested in how to convert a MIDI keyboard\'s input signals to a QWERTY keyboard\'s signals, or is your primary interest finding an out of the box solution to your specific problem? What are you looking for that has not yet been addressed?You could hack your own USB keyboard pretty quickly using a Teenys micro controller.In fact, they have example code for how to make a USB keyboard.You could approach this two ways:Get an old piano and wire up switches directly to the teensyAdd the additional logic to connect to the MIDI port and necessary decoding.Actually, I worked on this a while ago, trying to capture Rock Band drum inputs into my computer (making a little Java homemade drum emulator) Anyway, I asked a question on here about that, Time delay problem (there is polling code in there, along with what I was attempting to do.). And if I can find my program I can give you the code, it uses a third-party API (JInput).Good luck either way.Try Bome\'s MIDI translator.It works cross platform, can convert any MIDI input to a keystoke easily, quick to setup and configure, plus it\'s free for personal use.There is a tutorial, Quick Tip: MIDI Translation \xe2\x80\x93 MIDI to Keystrokes, of how to easily set it up:Basically, there are infinite possibilities of what you can do, including chording and modifier keys. I use it for my live audio rig to control my DAW using my piano and have never had an issue.In Java, you can use JMF (Java Media framework) to convert MIDI signals.\nBasic of keyboard design is easy to use, that is, the user interface; and place frequently used charcter/symbol handy.The sample code and API in Java Sound Resources: Examples: Digital Signal Processing (DSP) help to understand how to process the signal.Some more references:Casey has the best answer. I\'ve added a comment to it and upvoted it. This kind of software belongs in either a device driver or an embedded system. Device drivers are much more complex and they are not portable to other OSes. For reference see the issues with Winmodems on Linux.By putting your code in an embedded system, you make it portable to any MIDI device with a USB port, and any computer that accepts USB keyboards.There is a program called GlovePIE. You can program it in a simple scripting language, and I believe it supports MIDI. I\'m not sure if this fits under the "Java" category, but still, it is a great program. I\'ve used it to control robots using PS3 controllers. It\'s very powerful.Many keyboards have a serial port (RS-232) connector to send MIDI signals to the computer. I use a program called Girder to convert serial port communication into keyboard strokes.Girder has a "mapping" feature that lets you map each key, one by one, to the corresponding keystroke.This might be the simple solution you\'re looking for!It\'s clear from all the discussion on your part. You don\'t want to re-invent any wheels, from a technical standpoint. But once you have a connection made (what this question is asking) and up and working, you still have most of the work ahead of you: You have to train your brain. You also have to invent the cleverest, most efficient way to do that - a design issue totally out of the rhealm of computer techies. You or any of us would fall short. Fortunately, the problem has been solved and honed though centuries of maturing...Learn stenography!Yes, this will set you back some jack. But what are hundreds of hours of your own time worth, with at the end, a less favorable result? Besides, the stenography Wikipedia article says, \'it looks more like a piano keyboard\'.Unless, of course, you want to have a sideshow effect going. I would have to admit, I never thought of this possibility, it it would be really entertaining to see somebody bust out a text from a piano keyboard! You could start with a USB keyboard with touchpad (or a pointing stick would be more ergonomic?), use Plover to translate it (I\'m sure it can be configured to let the non-letter keys retain their functionality as they are critical for programming), or, follow the thread Re: Plover keyboard to roll your own USB stenography keyboard, or, buy a stenotype.Good luck!Take a look at MAME arcade gaming. They have built hardware devices to allow input from any number of different items. The iPac, for example, converts signals from input devices into USB that the computer can then use to emulate keys. You could use any combination of input devices arranged any way that seems comfortable with no crazy programming logic required--because the software to interpret input is already done and well tested.I\'ve seen flight simulator cockpit inputs, custom kiosks, and voting systems built in this method.....and the price is right! Not really program related, but I can offer some advice on how to manage RSI.There are timers that pace your work troughout the day introducing frequent micro-breaks. If you\'ve researched RSI, I\'m sure you\'ve heard about micro-breaks. They\'re crucial to managing and preventing reoccurrences. A free program is WorkraveGive QWERTY the boot and try Dvorak. Here is a programmer Dvorak keyboard layout. Dvorak has the most often used characters on the home row whereas QWERTY does not. So using Dvorak will reduce the strain caused by not having to \'reach\' for letters.Grab that \'natural\' keyboard out of the closet if you\'re not already using it. Type very lightly. The bare minimum to register a keystroke will do.Try limiting coffee to one or two cups per day. Excessive caffeine will make you not feel tired and make it easy to forget you have RSI. Excessive alcohol disrupts the sleep needed to allow your body to heal itself. A good night\'s rest is crucial for taming RSI.Stretch using active isolated stetching. A good routine is described in Wrist, Hand & Finger Stretching Routine - Active Isolated Stretching.Learn how to be ambidextrous with the mouse. Make sure the mouse is designed to be used by both hands and has buttons that are easy to click. Use a pen tablet as your main input device. Wacom makes some decent inexpensive tablets.Good luck!To solve this you will need a few things:A way to capture MIDI data from your keyboard. Depending upon the interface: MIDI interface (classic) or USB MIDI interface (modern) the most likely interface is to a computer as it provides the most options. USB host microcontrollers are not as simple as just using a computer.A scheme to convert MIDI data into keystrokes. Like one user pointed out, chords are the way to go as the number of keys will not be dependent upon the number of piano keys.A way to inject a key into the operating system. This will require a low-level driver to be accurate. I have played around with applications that inject keyboard and mouse data into applications in Windows 7, and it can be flaky and depend upon whether an application is currently in focus. This is hardest part of the interface. What may work is to create a HID USB keyboard microcontroller that also has a serial interface.The serial interface would create a virtual serial port. The software that reads the MIDI data and produces the keystrokes could send a serial message to the virtual serial port. The microcontroller would send a keystroke so it would look like a standard keyboard input. This would allow interfacing both MIDI ports and USB MIDI keyboards.Hmmm, with this type of interface you could also simulate a mouse and use some piano keys setup for the mouse axis and buttons. The pressure could be used to determine mouse pointer velocity. So you could eliminate the mouse as well. Another benefit of this approach is any type of input device you connect could talk to the virtual serial port to produce keyboard and mouse events. So if you wanted to add other hardware such as drum pedals or a joystick it would be a matter of adjusting the program that talks to the serial interface.Another take on the above is like some posted above to use an Arduino, but also include USB Host Shield from Sparkfun to handle USB based music keyboards. This allows the Arduino to be programmed as a keyboard or keyboard mouse combo in the boot loader chip and allows the device to act a USB host for the USB based music keyboard. Then you are covered for both types. Although, I still think the virtual serial port method is more flexible and would be easier to program in the long run. The Arduino device will be harder to change than a desktop program or service.There is another possibility:\nChorded one handed keyboards already exist. I have seen videos on them, but you would have to determine if those hurt your hands or not.Your pain symptoms could very well be psychosomatic.  I once thought I had RSI in my wrist for many months after a long night of playing computer games. Physical therapy did not help. After I read an article written by a doctor explaining that RSI, carpal tunnel, back pain and IBS can often be psychosomatic, especially in people who are under stress, the pain practically disappeared (it helped to visualize my wrist relaxing and blood flowing to it, since the article said that autonomic blood vessel constriction is the immediate cause of the pain). I was in fact suffering from a lot of stress at the time. It should be fairly easy using something like the .NET DirectSound interface to hook into an MIDI device. You will need to identify your target MIDI device and then get the code to listen in on the incoming messages (there are articles about doing this via Google).Since you are using the MIDI in as a keyboard there are basically only two MIDI messages that you need to detect, namely note on and note off. The MIDI message is three data bytes specifying the command, the note and the velocity. The note off is just the note number (sometimes \'bad\' MIDI stacks send a note on with zero velocity which you also have to expect).Once you have the messages translating them the keyboard output should be fairly simple from .NET.There is plenty of advice in the other answers about the technicalities; I just wanted to give you an idea of the actual MIDI messages.  Good luck!You\'ll get better and happier results (regardless what operating system and/or DAW program you like to use) by playing any external MIDI keyboard as a controller through your sound card. Then route that into your GB software (or whatever) and tone generate the many sounds they have supplied you that way in real-time. If your sound card does not support MIDI I/O\'s (ins / outs /thrus), that\'s not a problem. You can consider researching and investing in an external MIDI table top converter. Many are equipped to further convert MIDI outs to USB 2.0 (by- passing an existing sound card altogether).For example: it\'s pretty tough getting "human like" grace note results via a Z and X change key option using a computer keyboard and pencil tool. When, instead, your own fingers can just play that with a MIDI keyboard from its own physical octave register ranges\xe2\x80\x94immediately!I realize budgetary constraints may be involved. But, some of these seemingly cheap "Casio" type 5 octave keyboards sold at Radio Shack for under $100.00 U.S. Dollars (*or less) is all you would need (plus, some of their on-board sound patches and sequencer modules sound and handle amazingly well for other things too). RadioShack MIDI keyboard options.As for external MIDI converters for existing sound cards, I\'ve run some Google searches for you as follows with Mac platforms specifically in mind: A lot of this external MIDI conversion information may be cumbersome to you at first, so I\'ve broken down things more as "user friendly" for your considerations & budget:There\'s nothing wrong with facilitating virtual keyboards as VST\'s when using DAW. They have their place.But, you sound like an accomplished keyboardist. So, why not consider the external MIDI conversion / keyboard options I just mentioned for yourself? Good luck and I hope this gave you some ideas that can and will work for you! If you don\'t want to do any programming yourself but just want the problem solved you can just buy a USB-MIDI-keyboard where you can re-assign any key to send a QWERTY keyboard output signal instead of a MIDI-output, for example M-Audio Axiom ProThis method will work with any OS and any computer that supports standard USB-keyboards since the MIDI-keyboard will identify itself as a standard QWERTY keyboard.You can use a simple AutoIt script to both read MIDI events, see MIDI Input. You\'ll also need MIDI UDF and simulate key presses.Reading MIDI events should be easy, but different MIDI controllers (instruments) have different features. Try to find out what your MIDI piano can do first, then see how you can best map those features to simulated QWERTY-keyboard presses.If you want, you could have something on screen or in the tray to help you see what you are doing (that is, for Shift, Ctrl and Alt simulation).You might take a look at chorded keyboards. They have the advantage that you don\'t need to write a driver for them before you can use them, and some are similar to the layout of a piano keyboard.If you know coding in Java, you could use this way: First, implement a javax.sound.midi.Receiver with a send(..) method that is mapping the \'Note on\' events to keystrokes like you want. You would need to get the MidiMessage\'s content with its getMessage method and intepret it in your fashion. The meaning of the message bytes can be found in MIDI Messages.After receiving a \'note on\' or \'note off\' for a certain keyboard key, you may map that to a key you like by assigning it a constant of the KeyEvent class, something like C#4 -> KeyEvent.VK_A and so on. This key code can then be used by java.awt.Robot\'s keyPress and keyRelease methods to actually send the keystroke to the OS and thus to other applications.I know exactly how you feel. Doing crazy keyboard coding commands all-day makes my hands hurt. A piano won\'t do the job (your better off getting a Dorvak keyboard). The best solution would be mental telepathy or at this moment in time voice control. I find Arthro-Aid Direct cream is good and Wild Blend works OK as well.The other thing I\'ve noticed is that the mouse is also majorly to blame, most are un-ergonomic and clicking so much cause RSI and CTS. To overcome this I occasionally use auto mouse clickers, for example Auto Mouse Clicker.I know of patents with mouse\'s as grips that you squeeze, I\'m keen to buy. PS: Get your income protection insurance before you see a doctor about your hands!And don\'t program on weekends:)I agree with Brian O\'Dell\'s answer - if this were my project, I\'d do it in hardware. It has the advantage of being platform and hardware independent - your box replaces the need for a MIDI-USB interface and a PC API.mbed is a fast-prototyping platform that is very easy to learn, and has multiple advantages over Arduino IMHO (online compiler, 512 KB flash, 96 MHz, C++ language). It has a USB keyboard interface and a USB Midi interface pre-written for you. The community is very friendly and willing to help, and there are a lot of existing projects using both MIDI and USB hid emulation - search Youtube for "mbed MIDI" or similar. If you use Linux have a take at Footware.It should be exactly what you\'re looking for - if you adjust the MIDI pitches to a keymapping of your liking...I never thought this could be useful for anyone but me ;o)To type faster maybe it\'s an idea to \'play\' the consonants on the left hand and the vowels on the right (or vice versa). You don\'t need a key for every consonant, because you could combine them like:You can leave two close keys out (like c# + d, this doesn\'t play easily).\nYou can even leave the black keys out.For vowels it is easy: A  E  I  O  U  Yc  d  e  f  g  aHowever, also think about using multiple keystrokes: like c# = aa, d# = ee, etc.You can do the same trick with the consonants (having combination of keys for st, sp, etc.)You can play consonants and vowels at the same time, bind them together alternately or with priority (consonants, then vowels, etc.)You probably will have to learn to type again, but I\'m sure you can do a lot quicker than a normal typing person can.Use another octave for digits and special characters, use a switch for shift, use an easy to play a combination of keys for space (like two c-s with both left and right hand, make sure it doesn\'t mean (a) character(s)).Also think about using a pedal which can have values of 0-127. You could use it as shift or space too ... or backspace/enter.I hope this give some new ideas and good luck with your project.The answers to your question are already on this page, but I\'d like to make some additional inputs.First, I\'m not convinced typing on a piano keyboard instead will stop the pains. In this regard, I\'ll suggest you look into something like Nuance Dragon - Naturally Speaking for your typing.Secondly, if you insist on going ahead with this, you\'ll probably need to go with Nasebnbaar\'s (though I don\'t agree it\'ll be any faster) and Brian\'s suggestion. This is probably something you should contact an engineer to do properly, but if you must do it yourself, you\'d be better off asking for directions on Electrical Engineering - Stack Echange.Thirdly, if you simply want to understand how MIDI files work, how to read them programmatically, and how to simulate a keyboard stroke, then good luck ;)Lastly, I\'d like to get a copy as well if you eventually decide to go with the second option :)