What is the best way(s) to fake function overloading in Javascript? I know it is not possible to overload functions in Javascript as in other languages. \nIf I needed a function with two uses foo(x) and foo(x,y,z) which is the best / preferred way:The best way to do function overloading with parameters is not to check the argument length or  the types; checking the types will just make your code slow and you have the fun of Arrays, nulls, Objects, etc.What most developers do is tack on an object as the last argument to their methods.  This object can hold anything. Then you can handle it anyway you want in your method. [Switch, if-else, etc.]I often do this:C#:JavaScript Equivalent:This particular example is actually more elegant in javascript than C#.  Parameters which are not specified are \'undefined\' in javascript, which evaluates to false in an if statement. However, the function definition does not convey the information that p2 and p3 are optional.  If you need a lot of overloading, jQuery has decided to use an object as the parameter, for example, jQuery.ajax(options).  I agree with them that this is the most powerful and clearly documentable approach to overloading, but I rarely need more than one or two quick optional parameters.EDIT: changed IF test per Ian\'s suggestionThere is no real function overloading in JavaScript since it allows to pass any number of parameters of any type. You have to check inside the function how many arguments have been passed and what type they are.There are two ways you could approach this better: Pass a dictionary (associative array) if you want to leave a lot of flexibility Take an object as the argument and use prototype based inheritance to add flexibility.The correct answer is THERE IS NO OVERLOADING IN JAVASCRIPT.Checking / Switching inside the function is not OVERLOADING.The concept of overloading:\nIn some programming languages, function overloading or method overloading is the ability to create multiple methods of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.For example, doTask() and doTask(object O) are overloaded methods. To call the latter, an object must be passed as a parameter, whereas the former does not require a parameter, and is called with an empty parameter field. A common error would be to assign a default value to the object in the second method, which would result in an ambiguous call error, as the compiler wouldn\'t know which of the two methods to use.https://en.wikipedia.org/wiki/Function_overloadingAll suggested implementations are great, but truth to be told, there is no native implementation for JavaScript.Here is a benchmark test on function overloading - http://goo.gl/UyYAD (code shown in this post). It shows that function overloading (taking types into account) can be around 13 times slower in Google Chrome\'s V8 as of 16.0(beta).As well as passing an object (i.e. {x: 0, y: 0}), one can also take the C approach when appropriate, naming the methods accordingly. For example, Vector.AddVector(vector), Vector.AddIntegers(x, y, z, ...) and Vector.AddArray(integerArray). You can look at C libraries, such as OpenGL for naming inspiration. Edit: I\'ve added a benchmark for passing an object and testing for the object using both \'param\' in arg and arg.hasOwnProperty(\'param\'), and function overloading is much faster than passing an object and checking for properties (in this benchmark at least).From a design perspective, function overloading is only valid or logical if the overloaded parameters correspond to the same action. So it stands to reason that there ought to be an underlying method that is only concerned with specific details, otherwise that may indicate inappropriate design choices. So one could also resolve the use of function overloading by converting data to a respective object. Of course one must consider the scope of the problem as there\'s no need in making elaborate designs if your intention is just to print a name, but for the design of frameworks and libraries such thought is justified.My example comes from a Rectangle implementation - hence the mention of Dimension and Point. Perhaps Rectangle could add a GetRectangle() method to the Dimension and Point prototype, and then the function overloading issue is sorted. And what about primitives? Well, we have argument length, which is now a valid test since objects have a GetRectangle() method.The best way really depends on the function and the arguments. Each of your options is a good idea in different situations. I generally try these in the following order until one of them works:Using optional arguments like y = y || \'default\'. This is convenient if you can do it, but it may not always work practically, e.g. when 0/null/undefined would be a valid argument.Using number of arguments. Similar to the last option but may work when #1 doesn\'t work.Checking types of arguments. This can work in some cases where the number of arguments is the same. If you can\'t reliably determine the types, you may need to use different names.Using different names in the first place. You may need to do this if the other options won\'t work, aren\'t practical, or for consistency with other related functions.If I needed a function with two uses foo(x) and foo(x,y,z) which is the best / preferred way?The issue is that JavaScript does NOT natively support method overloading. So, if it sees/parses two or more functions with a same names it\xe2\x80\x99ll just consider the last defined function and overwrite the previous ones.One of the way I think is suitable for most of the case is follows - Lets say you have method Instead of overloading method which is not possible in javascript you can define a new method and then modify the 1st function as follows -If you have many such overloaded method consider using switch than just if-else statements.(more details)I\'m not sure about best practice, but here is how I do it:I just tried this, maybe it suits your needs.\nDepending on the number of the arguments, you can access a different function. You initialize it the first time you call it.\nAnd the function map is hidden in the closure.Test it. Since JavaScript doesn\'t have function overload options object can be used instead.  If there are one or two required arguments, it\'s better to keep them separate from the options object.  Here is an example on how to use options object and populated values to default value in case if value was not passed in options object.here is an example on how to use options objectThere is no way to function overloading in javascript.\nSo, I recommend like the following by typeof() method instead of\nmultiple function to fake overloading.Good luck!check this out. It is very cool.\nhttp://ejohn.org/blog/javascript-method-overloading/\nTrick Javascript to allow you to do calls like this:As this post already contains a lot of different solutions i thought i post another one.this can be used as shown below:This solution is not perfect but i only want to demonstrate how it could be done.You can user the \'addMethod\' from John Resig. With this method you can "overload" methods based on arguments count.I have also created an alternative to this method that uses caching to hold the variations of the function. The differencies are described hereThis is an old question but one that I think needs another entry (although I doubt anyone will read it). The use of Immediately Invoked Function Expressions (IIFE) can be used in conjunction with closures and inline functions to allow for function overloading. Consider the following (contrived) example:In short, the use of the IIFE creates a local scope, allowing us to define the private variable old to store a reference to the initial definition of the function foo. This function then returns an inline function newFoo that logs the contents of both two arguments if it is passed exactly two arguments a and b or calls the old function if arguments.length !== 2. This pattern can be repeated any number of times to endow one variable with several different functional defitions.Forward to another function which name is built from the 3rd & 4th points : JavaScript is untyped language, and I only think that makes sense to overload a method/function with regards to the number of params. Hence, I would recommend to check if the parameter has been defined:As of July 2017, the following has been the common technique. Note that we can also perform type checking within the function.Another way to approach this is by using the special variable: arguments, this is an implementation:so you can modify this code to:The first option really deserves attention cause it\'s the thing I\'ve come up in quite complex code setup. So, my answer isWith a little but essential hint, names should look different for computer, but not for you. Name overloaded functions like: func, func1, func2.We made over.js to solve this problem is a very elegant way.  You can do:So I really liked this way of doing things that I found in secrets of the javascript ninjayou then use addMethod to add overloaded functions to any object.  The main confusion in this code for me was the use of fn.length == arguments.length -- this works because fn.length is the number of expected parameters, while arguments.length is the number of parameters that are actually called with the function. The reason the anonymous function has no argument is because you can pass in any number of arguments in javascript and the language is forgiving. I liked this because you can use it everywhere - just create this function and simply use the method in whatever code base you want. It also avoids having a ridiculously large if/switch statement, which becomes hard to read if you start writing complex code (the accepted answer will result in this).In terms of cons, I guess the code is initially a little obscure...but I\'m not sure of others? I would like to share a useful example of overloaded-like approach.Usage: \n  Clear(); // Clears all the documentClear(myDiv); // Clears panel referenced by myDivI like @AntouanK\'s approach. I often find myself offering a function with different numbers o parameters and different types. Sometimes they don\'t follow a order. I use to map looking the types of parameters:INTRODUCTIONSo far reading through so many answers would give anyone a headache. Anyone trying to know the concept would need to know the following prerequisites. Function overloading Definition, Function Length property, Function argument propertyFunction overloading in its simplest form means that a function performs different tasks on the basis of number of arguments that are being passed to it. Notably the TASK1, TASK2 and TASK3 are highlighted below and are being performed on the basis of the number of arguments being passed to the same function fooYo. NOTE\n- JS does not provide inbuilt ability of function overloading. AlternativeJohn E Resig (creator of JS) has pointed out an alternative which uses the above prerequisites to achieve the ability to implement function overloading. The code below uses a straightforward but naive approach by using if-else or switch statement.Another technique is much more clean and dynamic. The highlight of this technique is the addMethod generic function. we define a function addMethod which is used to add different functions to an object with the same name but different functionalities.below the addMethod function accepts three params object name object, function name name and the function that we want to be invoked fn. I am working on a library that provides class like code capabilities to Javascript, currently it supports constructors, inheritance, methods overload by number of params and by types of params, mixins, statics properties and singleton.See an example of method overloading using that library:Any feedback, bug fixes, docs and tests improves are welcome!https://github.com/eutsiv/eutsiv.js 