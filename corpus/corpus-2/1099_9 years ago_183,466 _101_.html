I\'ve always wondered this - why can\'t you declare variables after a case label in a switch statement?  In C++ you can declare variables pretty much anywhere (and declaring them close to first use is obviously a good thing) but the following still won\'t work:The above gives me the following error (MSC):initialization of \'newVal\' is skipped by \'case\' labelThis seems to be a limitation in other languages too.  Why is this such a problem?Case statements are only labels. This means the compiler will interpret this as a jump directly to the label. In C++, the problem here is one of scope. Your curly brackets define the scope as everything inside the switch statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that case statement and define your variable within it. This question is tagged as [C] and [C++] at the same time. The original code is indeed invalid in both C and C++, but for completely different unrelated reasons. I believe this important detail was missed (or obfuscated) by the existing answers.In C++ this code is invalid because the case ANOTHER_VAL: label jumps into the scope of variable newVal bypassing its initialization. Jumps that bypass initialization of local objects are illegal in C++. This side of the issue is correctly addressed by most answers.However, in C language bypassing variable initialization is not an error. Jumping into the scope of a variable over it initialization is legal in C. It simply means that the variable is left uninitialized. The original code does not compile in C for a completely different reason. Label case VAL: in the original code is attached to the declaration of variable newVal. In C language declarations are not statements. They cannot be labeled. And this is what causes the error when this code is interpreted as C code.Adding an extra {} block fixes both C++ and C problems, even though these problems happen to be very different. On the C++ side it restricts the scope of newVal, making sure that case ANOTHER_VAL: no longer jumps into that scope, which eliminates the C++ issue. On the C side that extra {} introduces a compound statement, thus making the case VAL: label to apply to a statement, which eliminates the C issue.In C case the problem can be easily solved without the {}. Just add an empty statement after the case VAL: label and the code will become validNote that even though it is now valid from C point of view, it remains invalid from C++ point of view.Symmetrically, in C++ case the the problem can be easily solved without the {}. Just remove the initializer from variable declaration and the code will become validNote that even though it is now valid from C++ point of view, it remains invalid from C point of view.Ok.  Just to clarify this strictly has nothing to do with the declaration.  It relates only to "jumping over the initialization" (ISO C++ \'03 6.7/3)A lot of the posts here have mentioned that jumping over the declaration may result in the variable "not being declared".  This is not true.  An POD object can be declared without an initializer but it will have an indeterminate value.   For example:Where the object is a non-POD or aggregate the compiler implicitly adds an initializer, and so it is not possible to jump over such a declaration:This limitation is not limited to the switch statement.  It is also an error to use \'goto\' to jump over an initialization:A bit of trivia is that this is a difference between C++ and C.  In C, it is not an error to jump over the initialization.As others have mentioned, the solution is to add a nested block so that the lifetime of the variable is limited to the individual case label.The whole switch statement is in the same scope. To get around it, do this:Note the brackets.After reading all answers and some more research I get a few things.In C, according to the specification,\xc2\xa76.8.1 Labeled Statements:In C there isn\'t any clause that allows for a "labeled declaration". It\'s just not part of the language.SoThis will not compile, see http://codepad.org/YiyLQTYw. GCC is giving an error:Eventhis is also not compiling, see http://codepad.org/BXnRD3bu. Here I am also getting the same error.In C++, according to the specification,labeled-declaration is allowed but labeled -initialization is not allowed.See http://codepad.org/ZmQ0IyDG.Solution to such condition is twoEither use new scope using {}Or use dummy statement with labelDeclare the variable before switch() and initialize it with different values in case statement if it fulfills your requirementSome more things with switch statementNever write any statements in the switch which are not part of any label, because they will never executed:See http://codepad.org/PA1quYX3.You can\'t do this, because case labels are actually just entry points into the containing block.This is most clearly illustrated by Duff\'s device. Here\'s some code from Wikipedia:Notice how the case labels totally ignore the block boundaries. Yes, this is evil. But this is why your code example doesn\'t work. Jumping to a case label is the same as using goto, so you aren\'t allowed to jump over a local variable with a constructor.As several other posters have indicated, you need to put in a block of your own:Most of the replies so far are wrong in one respect: you can declare variables after the case statement, but you can\'t initialize them:As previously mentioned, a nice way around this is to use braces to create a scope for your case.My favorite evil switch trick is to use an if(0) to skip over an unwanted case label.But very evil.Try this:You can declare variables within a switch statement if you start a new block:The reason is to do with allocating (and reclaiming) space on the stack for storage of the local variable(s).Consider:In the absence of break statements, sometimes newVal gets declared twice, and you don\'t know whether it does until runtime. My guess is that the limitation is because of this kind of confusion. What would the scope of newVal be? Convention would dictate that it would be the whole of the switch block (between the braces).I\'m no C++ programmer, but in C:Works fine. Declaring a variable inside a switch block is fine. Declaring after a case guard is not.The entire section of the switch is a single declaration context.  You can\'t declare a variable in a case statement like that.  Try this instead:If your code says "int newVal=42" then you would reasonably expect that newVal is never uninitialised. But if you goto over this statement (which is what you\'re doing) then that\'s exactly what happens - newVal is in-scope but has not been assigned.If that is what you really meant to happen then the language requires to make it explicit by saying "int newVal; newVal = 42;". Otherwise you can limit the scope of newVal to the single case, which is more likely what you wanted.It may clarify things if you consider the same example but with "const int newVal = 42;"So far the answers have been for C++.For C++, you can\'t jump over an initialization. You can in C. However, in C, a declaration is not a statement, and case labels have to be followed by statements.So, valid (but ugly) C, invalid C++Conversly, in C++, a declaration is a statement, so the following is valid C++, invalid CInteresting that this is fine:... but this isn\'t:I get that a fix is simple enough, but I\'m not understanding yet why the first example doesn\'t bother the compiler. As was mentioned earlier (2 years earlier hehe), declaration is not what causes the error, even despite the logic. Initialisation is the problem. If the variable is initialised and declared on the different lines, it compiles.I wrote this answer orginally for this question. However when I finished it I found that answer has been closed. So I posted it here, maybe someone who likes references to standard will find it helpful.Original Code in question:There are actually 2 questions:1. Why can I declare a variable after case label?It\'s because in C++ label has to be in form:N3337 6.1/1labeled-statement:......And in C++ declaration statement is also considered as statement (as opposed to C):N3337 6/1:statement:...declaration-statement...2. Why can I jump over variable declaration and then use it?Because:\nN3337 6.7/3It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A\n  program that jumps\n  (The transfer from the condition of a switch statement to a case label is considered a jump in this respect.)from a point where a variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed unless the variable has scalar type, class type with a trivial default\n  constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the\n  preceding types and is declared without an initializer (8.5).Since k is of scalar type, and is not initialized at point of declaration jumping over it\'s declaration is possible. This is semantically equivalent:However that wouldn\'t be possible, if x was initialized at point of declaration:I just wanted to emphasize slim\'s point. A switch construct creates a whole, first-class-citizen scope. So it is posible to declare (and initialize) a variable in a switch statement before the first case label, without an additional bracket pair:New variables can be decalared only at block scope. You need to write something like this:Of course, newVal only has scope within the braces...Cheers, RalphA switch block isn\'t the same as a succession of if/else if blocks. I\'m surprised no other answer explains it clearly.Consider this switch statement :It may be surprising, but the compiler will not see it as a simple if/else if. It will produce the following code :The case statements are converted into labels and then called with goto. The brackets create a new scope and it is easy to see now why you can\'t declare two variables with the same name within a switch block.It may look weird, but it is necessary to support fallthrough (that is, not using break to let execution continue to the next case). newVal exists in the entire scope of the switch but is only initialised if the VAL limb is hit. If you create a block around the code in VAL it should be OK.C++ Standard has:\nIt is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps from a point where a local variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed unless the variable has POD type (3.9) and is declared without an initializer (8.5).The code to illustrate this rule:The code to show the initializer effect:I believe the issue at hand is that is the statement was skipped, and you tried to use the var elsewhere, it wouldn\'t be declared.It appears that anonymous objects can be declared or created in a switch case statement for the reason that they cannot be referenced and as such cannot fall through to the next case. Consider this example compiles on GCC 4.5.3 and Visual Studio 2008 (might be a compliance issue tho\' so experts please weigh in)