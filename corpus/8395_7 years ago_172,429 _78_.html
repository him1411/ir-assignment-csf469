The error message :"The model backing the \'AddressBook\' context has changed since the database was created.  Either manually delete/update the database, or call Database.SetInitializer with an IDatabaseInitializer instance.  For example, the RecreateDatabaseIfModelChanges strategy will automatically delete and recreate the database, and optionally seed it with new data."I am trying to use the code-first feature and following is what I wrote:The context class:and the connection string:So, the database name is "AddressBook" and the error happens when I trying to add the contact object to the context. Am I missing anything here?Now it\'s:in your YourDbContext.cs file.Here\'s some information from Scott Gu\'s Blog posted by Jeff on what\'s actually taking place:For those who are seeing this exception:"The model backing the \'Production\' context has changed since the\n  database was created. Either manually delete/update the database, or\n  call Database.SetInitializer with an IDatabaseInitializer instance."Here is what is going on and what to do about it:When a model is first created, we run a DatabaseInitializer to do\n  things like create the database if it\'s not there or add seed data.\n  The default DatabaseInitializer tries to compare the database schema\n  needed to use the model with a hash of the schema stored in an\n  EdmMetadata table that is created with a database (when Code First is\n  the one creating the database). Existing databases won\xe2\x80\x99t have the\n  EdmMetadata table and so won\xe2\x80\x99t have the hash\xe2\x80\xa6and the implementation\n  today will throw if that table is missing. We\'ll work on changing this\n  behavior before we ship the fial version since it is the default.\n  Until then, existing databases do not generally need any database\n  initializer so it can be turned off for your context type by calling:JeffFor Entity Framework 5.0.0.0 - 6.1.3 You DO indeed want to do the following:Yes, Matt Frear is correct. UPDATE -EDIT:   Caveat is that I agree with others in that instead of adding this code to global.asax added to your DbContext classAs others mentioned this also is good for handling the unit testing.Currently I am using this with Entity Framework 6.1.3  /.net 4.6.1This fix no longer works after CTP5.You have to do Database.SetInitializer<YourContext>(null);Just found out the answer and thought of updating here. Just need to do the following.Or you can put this line in your Global.asax.cs file under Application_Start():Make sure to change ProjectName.Path.Context to your namespace and context. If using code first this will delete and create a new database whenever any changes are made to the schema.Just run the followng sql command in SQL Server Management Studio:I spent many days to solve this issue, analyzed many different posts and tried many options and finally fixed. \nThis 2 projects in my solution using EF code first migrations:I got this error when requested WebApi...My environment:Here I collected all the remarks you should pay attention and all conditions/requirements which must be met, to avoid mentioned exception :Name of connection string e.g. MyConnectionString in config file of startup project (Web.config/App.config):should be equal to parameter passed in constructor of your DbContext:And the main, which fixed my issue: It is weird, but in my WebApi/bin folder DataModel.exe was old, not refreshed since last build. Since migrations was embedded in my assembly DataModel.exe then my WebApi updated database using old mirgations. I was confused why after updating database in WebApi it not corresponds to latest migration script from DataModel. Following code automatically creates(if not exists) or updates to latest migration local database in my WebApi/App_Data folder. I tried clean and rebuild solution but it did not help, than I completely removed\nbin and obj folders from WebApi, deleted database files from WebApi/App_Data, built, restarted WebApi, made request to it, it created correct database - lazy initialization (using lines above), which corresponds to latest migration and exception didn\'t appear more.\nSo, this may fix your problem:For me, with the upgrade to 4.3.1, I just truncate the EdmMetaData table or just delete it outright.For VB.NET developers:Add the following line to the Glabal.asax.vb file, at the end of method Application_Start()Change ApplicationDbContext to your specific Db context.I had this issue and it turned out that one project was pointing to SQLExpress but the one with the problem was pointing to LocalDb. (in their respective web.config). Silly oversight but worth noting here in case anyone else is troubleshooting this issue. I had the same issue - re-adding the migration and updating the database didn\'t work and none of the answers above seemed right. Then inspiration hit me - I\'m using multiple tiers (one web, one data, and one business). The data layer has the context and all the models. The web layer never threw this exception - it was the business layer (which I set as console application for testing and debugging). Turns out the business layer wasn\'t using the right connection string to get the db and make the context. So I added the connection string to the app config of the business layer (and the data layer) and viola it works. Putting this here for others who may encounter the same issue.I use the Database.CompatibleWithModel method (available in EF5) to test if the model and DB match before I use it. I call this method just after creating the context...It means that there were some changes on the context which have not been executed.\nPlease run Add-Migration first to generate the changes that we have done (the changes that we might not aware)\nAnd then run Update-DatabaseI had the same problem when we used one database for two applications. Setting disableDatabaseInitialization="true" in context type section works for me.See more details https://msdn.microsoft.com/en-us/data/jj556606.aspxAfter some research on this topic, I found that the error is occured basically if you have an instance of db created previously on your local sql server express. So whenever you have updates on db and try to update the db/run some code on db without running Update Database command using Package Manager Console; first of all, you have to delete previous db on our local sql express manually. Also, this solution works unless you have AutomaticMigrationsEnabled = false;in your Configuration. If you work with a version control system (git,svn,etc.) and some other developers update db objects in production phase then this error rises whenever you update your code base and run the application. As stated above, there are some solutions for this on code base. However, this is the most practical one for some cases.I am reading the Pro ASP.NET MVC 4 book as well, and ran into the same problem you were having.  For me, I started having the problem after making the changes prescribed in the \'Adding Model Validation\' section of the book.  The way I resolved the problem is by moving my database from the localdb to the full-blown SQL Server 2012 server.  (BTW, I know that I am lucky I could switch to the full-blown version, so don\'t hate me. ;-)))  There must be something with the communication to the db that is causing the problem.Modify Global.asax.cs, including the Application_Start event with:This error can indicate an issue with your connection string and whether your connection string name matches the Database context declaration.I had this error because I had named the local database wrongly (silly mistake) and the name of the connection string in web.config of "DefaultConnection" did not match the MyDbContext i.e. Try using  Database SetInitializer which belongs to using System.Data.Entity;In Global.asax This will create new database everytime your model is changed.But your database would be empty.In order to fill it with dummy data you can use Seeding. Which you can implement as  :Seeding ::It\'s weird, but all answers here were useless for me. \nFor me worked initializer MigrateDatabaseToLatestVersionHere\'s my solution (I know, it can be much simplier, but it\'s how I use it):MyDbInitializerForTesting just inherits from DropCreateDatabaseAlways so in some specific case (testing), whole database is rebuilded. Otherwise it\'s migrated to latest version.My source: https://msdn.microsoft.com/en-us/data/jj591621.aspx#specificGood suggestion, however, nt so accurate in all cases. I figure one out.\nPlease you need to make sure you run  "enable-migrations" using PM windows in Visual Studio, and Migration folder would be added to you project.Make sure the two c# class files added to the folder on will contain all your models and their respective properties.If you have all that build the solution, and publis for deployment.The logic is that the existing metadata cannot be overwritten because your application has no metadata to replace the current. As a result you are getting this error "The model backing the  context has changed since the database was created"Just in case someone has the same scenario as mine.I have database first EF and at the same time using the asp.net identityso I have two connectionStrings in my webconfig, and there is no problem with that. It happened that I created/run the scripts to generate manually the asp.net identity tables which I should not. so DROP first all the asp.net identity tables created by you manually/from scripts.None of these solutions would work for us (other than disabling the schema checking altogether). In the end we had a miss-match in our version of Newtonsoft.jsonOur AppConfig did not get updated correctly:The solution was to correct the assembly version to the one we were actually deployingCheck this following steps 2.\n    \n  Here I want to share another method that prevent the error of model backing when context changed is:1) Open your DbContext File2) Add namespace using Microsoft.AspNet.Identity.EntityFramework;3) \npublic MyDbContext() : base("name=MyDbContext")\n        {\n            Database.SetInitializer(new        DropCreateDatabaseAlways());\n        }