Just as make clean deletes all the files that a makefile has produced, I would like to do the same with CMake. All too often I find myself manually going through directories removing files like cmake_install.cmake and CMakeCache.txt, and the CMakeFiles folders.Is there a command like cmake clean to remove all these files automatically? Ideally this should follow the recursive structure defined within the current directory\'s CMakeLists.txt file.There is no cmake clean.I usually build the project in a single folder like "build". So if I want to make clean, I can just rm -rf build.The "build" folder in the same directory as the root "CMakeLists.txt" is usually a good choice. To build your project, you simply give cmake the location of the CMakeLists.txt as an argument. For example: cd <location-of-cmakelists>/build && cmake ... (From @ComicSansMS)I googled it for like half an hour and the only useful thing I came up with was invoking the find utility:Also, be sure to invoke make clean (or whatever cmake generator you\'re using) before that.:)CMake official FAQ states:Some build trees created with GNU autotools have a "make distclean"\n  target that cleans the build and also removes Makefiles and other\n  parts of the generated build system. CMake does not generate a "make\n  distclean" target because CMakeLists.txt files can run scripts and\n  arbitrary commands; CMake has no way of tracking exactly which files\n  are generated as part of running CMake. Providing a distclean target\n  would give users the false impression that it would work as expected.\n  (CMake does generate a "make clean" target to remove files generated\n  by the compiler and linker.) A "make distclean" target is only\n  necessary if the user performs an in-source build. CMake supports\n  in-source builds, but we strongly encourage users to adopt the notion\n  of an out-of-source build. Using a build tree that is separate from\n  the source tree will prevent CMake from generating any files in the\n  source tree. Because CMake does not change the source tree, there is\n  no need for a distclean target. One can start a fresh build by\n  deleting the build tree or creating a separate build tree.You can use something like:I usually create a "make clean-all" command adding to the previous example a call to "make clean":Don\'t try to add the "clean" target as a dependence:Because "clean" isn\'t a real target in CMake and this doesn\'t work.\nMoreover, you should not use this "clean-cmake-files" as dependence of anything:Because, if you do that, all cmake files will be erase before clean-all is complete, and make will throw you an error searching "CMakeFiles/clean-all.dir/build.make". In consequence, you can not use the clean-all command before "anything" in any context:This doesn\'t work either.In these days of git everywhere, you may forget CMake and use git clean -d -f -x, that will remove all files not under source control.Simply issuing rm CMakeCache.txt works for me too.I agree that the out-of-source build is the best answer.  But for the times when you just must do an in-source build, I have written a Python script available here, which:A solution that I found recently is to combine the out-of-source build concept with a Makefile wrapper.In my top-level CMakeLists.txt file, I include the following to prevent in-source builds:Then, I create a top-level Makefile, and include the following:The default target all is called by typing make, and invokes the target ./build/Makefile.The first thing the target ./build/Makefile does is to create the build directory using $(MKDIR), which is a variable for mkdir -p. The directory build is where we will perform our out-of-source build. We provide the argument -p to ensure that mkdir does not scream at us for trying to create a directory that may already exist.The second thing the target ./build/Makefile does is to change directories to the build directory and invoke cmake.Back to the all target, we invoke $(MAKE) -C build, where $(MAKE) is a Makefile variable automatically generated for make. make -C changes the directory before doing anything. Therefore, using $(MAKE) -C build is equivalent to doing cd build; make.To summarize, calling this Makefile wrapper with make all or make is equivalent to doing:The target distclean invokes cmake .., then make -C build clean, and finally, removes all contents from the build directory. I believe this is exactly what you requested in your question.The last piece of the Makefile evaluates if the user-provided target is or is not distclean. If not, it will change directories to build before invoking it. This is very powerful because the user can type, for example, make clean, and the Makefile will transform that into an equivalent of cd build; make clean.In conclusion, this Makefile wrapper, in combination with a mandatory out-of-source build CMake configuration, make it so that the user never has to interact with the command cmake. This solution also provides an elegant method to remove all CMake output files from the build directory.P.S. In the Makefile, we use the prefix @ to suppress the output from a shell command, and the prefix @- to ignore errors from a shell command. When using rm as part of the distclean target, the command will return an error if the files do not exist (they may have been deleted already using the command line with rm -rf build, or they were never generated in the first place). This return error will force our Makefile to exit. We use the prefix @- to prevent that. It is acceptable if a file was removed already; we want our Makefile to keep going and remove the rest.Another thing to note: This Makefile may not work if you use a variable number of CMake variables to build your project, for example, cmake .. -DSOMEBUILDSUSETHIS:STRING="foo" -DSOMEOTHERBUILDSUSETHISTOO:STRING="bar". This Makefile assumes you invoke CMake in a consistent way, either by typing cmake .. or by providing cmake a consistent number of arguments (that you can include in your Makefile).Finally, credit where credit is due. This Makefile wrapper was adapted from the Makefile provided by the C++ Application Project Template.If you run this:It will regenerate the cmake files. Which is necessary if you add a new file to source folder that is selected by *.cc, for example.While this isn\'t a "clean" per se, it does "clean" up the cmake files by regenerating the caches.Hope that helps.I used the response from zsxwing above successfully to solve the following problem:I have source that I build on multiple hosts (on a Raspberry PI Linux board, on a VMware Linux virtual machine, etc.)I have a bash script that creates tmp directories based on the hostname of the machine like this:Hope this helps somebody ...In many cases make rebuild_cache is useful. It triggers a complete configure run and this will rebuilt all targets which rely on changed variables.I use this shell script for such purpose:If you are using Windows then use Cygwin for this script.I have this in my shell rc file (.bashrc, .zshrc):You are supposed to use it only for out-of-source builds. Let\'s say you have a directory named build/ for this purpose. Then you just have to run t-cmake-clean from within it.Create a temporary build directory. eg build_cmake. hence all you build files will be inside this folder. then in your main cmake file add the below command.hence while compiling doand to clean do