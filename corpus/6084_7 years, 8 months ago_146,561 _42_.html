I\'ve got a R script for which I\'d like to be able to supply several command-line parameters (rather than hardcode parameter values in the code itself).  The script runs on Windows.I can\'t find info on how to read parameters supplied on the command-line into my R script.  I\'d be surprised if it can\'t be done, so maybe I\'m just not using the best keywords in my Google search...Any pointers or recommendations?Dirk\'s answer here is everything you need. Here\'s a minimal reproducible example.I made two files: exmpl.bat and exmpl.R.exmpl.bat:Alternatively, using Rterm.exe:exmpl.R:Save both files in the same directory and start exmpl.bat. In the result you\'ll get:You could also add an environment variable %R_Script%:and use it in your batch scripts as %R_Script% <filename.r> <arguments>Differences between RScript and Rterm:A few points:Command-line parameters are\naccessible via commandArgs(), so\nsee help(commandArgs) for an\noverview.You can use Rscript.exe on all platforms, including Windows. It will support commandArgs(). littler could be ported to Windows but lives right now only on OS X and Linux.There are two add-on packages on CRAN -- getopt and optparse -- which were both written for command-line parsing.Edit in Nov 2015:  New alternatives have appeared and I wholeheartedly recommend doctopt.Add this to the top of your script: Then you can refer to the arguments passed as args[1], args[2] etc.Then run If your args are strings with spaces in them, enclose within double quotes.Try library(getopt) ... if you want things to be nicer. For example:you need littler (pronounced \'little r\')Dirk will be by in about 15 minutes to elaborate ;)In bash, you can construct a command line like the following:You can see that the variable $z is substituted by bash shell with "10" and this value is picked up by commandArgs and fed into args[2], and the range command x=1:10 executed by R successfully, etc etc.Since optparse has been mentioned a couple of times in the answers, and it provides a comprehensive kit for command line processing, here\'s a short simplified example of how you can use it, assuming the input file exists:script.R:Given an arbitrary file blah.txt with 23 lines.On the command line:Rscript script.R -h outputsRscript script.R -n blah.txt outputs [1] "69"Rscript script.R -n -f 5 blah.txt outputs [1] "115"FYI:   there is a function args(), which retrieves the arguments of R functions, not to be confused with a vector of arguments named argsIf you need to specify options with flags, (like -h, --help, --number=42, etc) you can use the R package optparse (inspired from Python):\nhttp://cran.r-project.org/web/packages/optparse/vignettes/optparse.pdf.At least this how I understand your question, because I found this post when looking for an equivalent of the bash getopt, or perl Getopt, or python argparse and optparse.I just put together a nice data structure and chain of processing to generate this switching behaviour, no libraries needed. I\'m sure it will have been implemented numerous times over, and came across this thread looking for examples - thought I\'d chip in.I didn\'t even particularly need flags (the only flag here is a debug mode, creating a variable which I check for as a condition of starting a downstream function if (!exists(debug.mode)) {...} else {print(variables)}). The flag checking lapply statements below produce the same as:where args is the variable read in from command line arguments (a character vector, equivalent to c(\'--debug\',\'--help\') when you supply these on for instance)It\'s reusable for any other flag and you avoid all the repetition, and no libraries so no dependencies:Note that in flag.details here the commands are stored as strings, then evaluated with eval(parse(text = \'...\')). Optparse is obviously desirable for any serious script, but minimal-functionality code is good too sometimes.Sample output: