I have a dictionary of values read from two fields in a database: a string field and a numeric field. The string field is unique, so that is the key of the dictionary.I can sort on the keys, but how can I sort based on the values?Note: I have read Stack Overflow question How do I sort a list of dictionaries by values of the dictionary in Python? and probably could change my code to have a list of dictionaries, but since I do not really need a list of dictionaries I wanted to know if there is a simpler solution.It is not possible to sort a dict, only to get a representation of a dict that is sorted. Dicts are inherently orderless, but other types, such as lists and tuples, are not. So you need a sorted representation, which will be a list\xe2\x80\x94probably a list of tuples.For instance,sorted_x will be a list of tuples sorted by the second element in each tuple. dict(sorted_x) == x.And for those wishing to sort on keys instead of values:Well, it is actually possible to do a "sort by dictionary values". Recently I had to do that in a Code Golf (Stack Overflow question Code golf: Word frequency chart). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency. If you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as:then you can get a list of the words, ordered by frequency of use with sorted(d, key=d.get) - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key . I am writing this detailed explanation to illustrate what people often mean by "I can easily sort a dictionary by key, but how do I sort by value" - and I think the OP was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above.You could use:sorted(d.items(), key=lambda x: x[1])This will sort the dictionary by the values of each entry within the dictionary from smallest to largest.Dicts can\'t be sorted, but you can build a sorted list from them.A sorted list of dict values:A list of (key, value) pairs, sorted by value:In recent Python 2.7, we have the new OrderedDict type, which remembers the order in which the items were added.To make a new ordered dictionary from the original, sorting by the values:The OrderedDict behaves like a normal dict:It can often be very handy to use namedtuple. For example, you have a dictionary of \'name\' as keys and \'score\' as values and you want to sort on \'score\':sorting with lowest score first:sorting with highest score first:Now you can get the name and score of, let\'s say the second-best player (index=1) very Pythonically like this:UPDATE: 5 DECEMBER 2015 using Python 3.5Whilst I found the accepted answer useful, I was also surprised that it hasn\'t been updated to reference OrderedDict from the standard library collections module as a viable, modern alternative - designed to solve exactly this type of problem.The official OrderedDict documentation offers a very similar example too, but using a lambda for the sort function:Pretty much the same as Hank Gay\'s answer;In Python 2.7, simply do:copy-paste from : http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipesEnjoy ;-)Given dictionarySortingResult You can use a lambda function to sort things up by value and store them processed inside a variable, in this case sred with e the original dictionary.Hope that helps!I had the same problem, I solved it like this:(people who answer: "It is not possible to sort a dict" did not read the question!!\nIn fact "I can sort on the keys, but how can I sort based on the values?" clearly means that he wants a list of the keys sorted according to the value of their values.)Please notice that the order is not well defined (keys with the same value will be in an arbitrary order in the output list)Good news, so the OP\'s original use case of mapping pairs retrieved from a database with unique string ids as keys and numeric values as values into a builtin python v3.6+ dict, should now respect the insert order.If say the resulting 2 column table expression from a database query like:would be stored in two python tuples k_seq and v_seq (aligned by numerical index and with the same length of course), then:Allow to output later as:yielding in this case (for the new python 3.6+ builtin dict!):in the same ordering per value of v.Where in the python 3.5 install on my machine it currently yields:As proposed in 2012 by Raymond Hettinger (cf. Mail on python-dev with subject "More compact dictionaries with faster iteration") and now (in 2016) announced in a mail by Victor Stinner to python-dev with subject "Python 3.6 dict becomes compact and gets a private version; and keywords become ordered" due to the fix/implementation of issue 27350 "Compact and ordered dict" in Python 3.6 we will now be able, to use a built-in dict to maintain insert order! !Updated: Hopefully this will lead to a thin layer OrderedDict implementation as a first step. As @JimFasarakis-Hilliard indicated, some see  use cases for the OrderedDict type also in the future.\nI think the Python community at large will carefully inspect, if this will stand the test of time, and what the next steps will be.Time to rethink our coding habits to not miss the possibilities opened by stable ordering of:The first because it eases dispatch in the implementation of functions and methods in some cases.The second as it encourages to more easily use dict\'s as intermediate storage in processing pipelines.Raymond Hettinger kindly provided documentation explaining "The Tech Behind Python 3.6 Dictionaries" - from his San Francisco Python Meetup Group presentation 2016-DEC-08.And maybe quite some stackoverflow high decorated question and answer pages will receive variants of this info and many high quality answers will require a per version update too.As @ajcr rightfully notes: "The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon." (from the whatsnew36) not nit picking, but the citation was cut a bit pessimistic ;-). It continues as " (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5)."So as in some human languages (e.g. German), usage shapes the language, and the will now has been declared ... in whatsnew36If values are numeric you may also use Counter from collectionsYou can use the collections.Counter. Note, this will work for both numeric and non-numeric values.This is the code:Here are the results:OriginalRoflRank You can create an "inverted index", alsoNow your inverse has the values; each value has a list of applicable keys.Technically, dictionaries aren\'t sequences, and therefore can\'t be sorted. You can do something likeassuming performance isn\'t a huge deal.UPDATE: Thanks to the commenters for pointing out that I made this way too complicated in the beginning.Why not try this approach. Let us define a dictionary called mydict with the following data:If one wanted to sort the dictionary by keys, one could do something like:This should return the following output:On the other hand, if one wanted to sort a dictionary by value (as is asked in the question), one could do the following:The result of this command (sorting the dictionary by value) should return the following:You can use a skip dict which is a dictionary that\'s permanently sorted by value.If you use keys(), values() or items() then you\'ll iterate in sorted order by value.It\'s implemented using the skip list datastructure.This returns the list of key-value pairs in the dictionary, sorted by value from highest to lowest:For the dictionary sorted by key, use the following:The return is a list of tuples because dictionaries themselves can\'t be sorted.This can be both printed or sent into further computation.Use ValueSortedDict from dicts:You can also use custom function that can be passed to key.One more way to do is to use labmda functionIterate through a dict and sort it by its values in descending order:If your values are integers, and you use Python 2.7 or newer, you can use collections.Counter instead of dict. The most_common method will give you all items, sorted by the value.This works in 3.1.x:I came up with this one, For Python 3.x: x.items() replacing iteritems().Or try with collections.OrderedDict!You can use the sorted function of Pythonsorted(iterable[, cmp[, key[, reverse]]])Thus you can use:sorted(dictionary.items(),key = lambda x :x[1])Visit this link for more information on sorted function: https://docs.python.org/2/library/functions.html#sortedHere is a solution using zip on d.values() and d.keys().  A few lines down this link (on Dictionary view objects) is:This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()).So we can do the following:For the sake of completeness, I am posting a solution using heapq. Note, this method will work for both numeric and non-numeric values