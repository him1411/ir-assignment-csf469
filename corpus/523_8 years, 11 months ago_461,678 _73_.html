I\'ve been attempting to learn C in my spare time, and other languages (C#, Java, etc.) have the same concept (and often the same operators) ... What I\'m wondering is, at a core level, what does bit-shifting (<<, >>, >>>) do, what problems can it help solve, and what gotchas lurk around the bend? In other words, an absolute beginner\'s guide to bit shifting in all its goodness.The bit shifting operators do exactly what their name implies.  They shift bits.  Here\'s a brief (or not-so-brief) introduction to the different shift operators.All of these operators can be applied to integer values (int, long, possibly short and byte or char).  In some languages, applying the shift operators to any datatype smaller than int automatically resizes the operand to be an int.Note that <<< is not an operator, because it would be redundant.  Also note that C and C++ do not distinguish between the right shift operators.  They provide only the >> operator, and the right-shifting behavior is implementation defined for signed types.Integers are stored, in memory, as a series of bits.  For example, the number 6 stored as a 32-bit int would be:Shifting this bit pattern to the left one position (6 << 1) would result in the number 12:As you can see, the digits have shifted to the left by one position, and the last digit on the right is filled with a zero.  You might also note that shifting left is equivalent to multiplication by powers of 2.  So 6 << 1 is equivalent to 6 * 2, and 6 << 3 is equivalent to 6 * 8.  A good optimizing compiler will replace multiplications with shifts when possible.Please note that these are not circular shifts.  Shifting this value to the left by one position (3,758,096,384 << 1):results in 3,221,225,472:The digit that gets shifted "off the end" is lost.  It does not wrap around.A logical right shift is the converse to the left shift.  Rather than moving bits to the left, they simply move to the right.  For example, shifting the number 12:to the right by one position (12 >>> 1) will get back our original 6:So we see that shifting to the right is equivalent to division by powers of 2.However, a shift cannot reclaim "lost" bits.  For example, if we shift this pattern:to the left 4 positions (939,524,102 << 4), we get 2,147,483,744:and then shifting back ((939,524,102 << 4) >>> 4) we get 134,217,734:We cannot get back our original value once we have lost bits.The arithmetic right shift is exactly like the logical right shift, except instead of padding with zero, it pads with the most significant bit.  This is because the most significant bit is the sign bit, or the bit that distinguishes positive and negative numbers.  By padding with the most significant bit, the arithmetic right shift is sign-preserving.For example, if we interpret this bit pattern as a negative number:we have the number -2,147,483,552.  Shifting this to the right 4 positions with the arithmetic shift (-2,147,483,552 >> 4) would give us:or the number -134,217,722.So we see that we have preserved the sign of our negative numbers by using the arithmetic right shift, rather than the logical right shift.  And once again, we see that we are performing division by powers of 2.Let\'s say we have a single byte:Applying a single left bitshift gets us:The leftmost zero was shifted out of the byte, and a new zero was appended to the right end of the byte.The bits don\'t rollover; they are discarded. That means if you left shift 1101100 and then right shift it, you won\'t get the same result back.Shifting left by N is equivalent to multiplying by 2N.Shifting right by N is (if you are using ones\' complement) is the equivalent of dividing by 2N and rounding to zero.Bitshifting can be used for insanely fast multiplication and division, provided you are working with a power of 2. Almost all low-level graphics routines use bitshifting.For example, way back in the olden days, we used mode 13h (320x200 256 colors) for games. In Mode 13h, the video memory was laid out sequentially per pixel. That meant to calculate the location for a pixel, you would use the following math:Now, back in that day and age, speed was critical, so we would use bitshifts to do this operation.However, 320 is not a power of two, so to get around this we have to find out what is a power of two that added together makes 320:Now we can convert that into left shifts:For a final result of:Now we get the same offset as before, except instead of an expensive multiplication operation, we use the two bitshifts...in x86 it would be something like this (note, it\'s been forever since I\'ve done assembly (editor\'s note: corrected a couple mistakes and added a 32-bit example)):Total: 28 cycles on whatever ancient CPU had these timings.Vrs12 cycles on the same ancient CPU.Yes, we would work this hard to shave off 16 CPU cycles.In 32 or 64-bit mode, both versions get a lot shorter and faster.  Modern out-of-order execution CPUs like Intel Skylake (see http://agner.org/optimize/) have very fast hardware multiply (low latency and high throughput), so the gain is much smaller.  AMD Bulldozer-family is a bit slower, especially for 64-bit multiply.  On Intel CPUs, and AMD Ryzen, two shifts are slightly lower latency but more instructions than a multiply (which may lead to lower throughput):vs.Compilers will do this for you: See how gcc, clang, and MSVC all use shift+lea when optimizing return 320*row + col;.The most interesting thing to note here is that x86 has a shift-and-add instruction (LEA) that can do small left shifts and add at the same time, with the performance as and add instruction.  ARM is even more powerful: one operand of any instruction can be left or right shifted for free.  So scaling by a compile-time-constant that\'s known to be a power-of-2 can be even more efficient than a multiply.OK, back in the modern days... something more useful now would be to use bitshifting to store two 8-bit values in a 16-bit integer. For example, in C#:In C++, compilers should do this for you if you used a struct with two 8-bit members, but in practice don\'t always.Bitwise operations, including bit shift, are fundamental to low-level hardware or embedded programming. If you read a specification for a device or even some binary file formats, you will see bytes, words, and dwords, broken up into non-byte aligned bitfields, which contain various values of interest. Accessing these bit-fields for reading/writing is the most common usage.A simple real example in graphics programming is that a 16-bit pixel is represented as follows:To get at the green value you would do this:ExplanationIn order to obtain the value of green ONLY, which starts at offset 5 and ends at 10 (i.e. 6-bits long), you need to use a (bit) mask, which when applied against the entire 16-bit pixel, will yield only the bits we are interested in.The appropriate mask is 0x7E0 which in binary is 0000011111100000 (which is 2016 in decimal).To apply a mask, you use the AND operator (&).After applying the mask, you\'ll end up with a 16-bit number which is really just a 11-bit number since its MSB is in the 11th bit. Green is actually only 6-bits long, so we need to scale it down using a right shift (11 - 6 = 5), hence the use of 5 as offset (#define GREEN_OFFSET  5).Also common is using bit shifts for fast multiplication and division by powers of 2:Bit shifting is often used in low level graphics programming. For example a given pixel color value encoded in a 32-bit word.For better understanding, the same binary value labeled with what sections represents what color part.Let\'s say for example we want to get the green value of this pixels color. We can easily get that value by masking and shifting.Our mask:The logical & operator ensures that only the values where the mask is 1 are kept. The last thing we now have to do, is to get the correct integer value by shifting all those bits to the right by 16 places (logical right shift).Et voil\xc3\xa1, we have the integer representing the amount of green in the pixels color:This is often used for encoding or decoding image formats like jpg,png,....One gotcha is that the following is implementation dependent (according to the ANSI standard): x can now be 127 (01111111) or still -1 (11111111).In practice, it\'s usually the latter.Note that in the Java implementation, the number of bits to shift is mod\'d by the size of the source.For example:equals 2.  You might expect shifting the bits to the right 65 times would zero everything out, but it\'s actually the equivalent of:This is true for <<, >>, and >>>.  I have not tried it out in other languages.I am writing tips and tricks only, may find useful in tests/exams. Be aware of that only 32 bit version of PHP is available on the Windows platform.Then if you for instance shift << or >> more than by 31 bits, results are unexpectable. Usually the original number instead of zeros will be returned, and it can be a really tricky bug.Of course if you use 64 bit version of PHP (unix), you should avoid shifting by more than 63 bits. However, for instance, MySQL uses the 64-bit BIGINT, so there should not be any compatibility problems.