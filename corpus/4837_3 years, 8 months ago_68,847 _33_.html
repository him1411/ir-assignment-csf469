I saw a React dev talk at http://www.youtube.com/watch?v=x7cQ3mrcKaY and the speaker mentioned that dirty-checking of the model can be slow. But isn\'t calculating the diff between virtual DOMs actually even less performant since the virtual DOM, in most of the cases, should be bigger than model?I really like the potential power of the Virtual DOM (especially server-side rendering) but I would like to know all the pros and cons.I\'m the primary author of a virtual-dom module, so I might be able to answer your questions. There are in fact 2 problems that need to be solved hereIn React, each of your components have a state. This state is like an observable you might find in knockout or other MVVM style libraries. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because you must poll the data at a regular interval and check all of the values in the data structure recursively. By comparison, setting a value on the state will signal to a listener that some state has changed, so React can simply listen for change events on the state and queue up re-rendering.The virtual DOM is used for efficient re-rendering of the DOM. This isn\'t really related to dirty checking your data. You could re-render using a virtual DOM with or without dirty checking. You\'re right in that there is some overhead in computing the diff between two virtual trees, but the virtual DOM diff is about understanding what needs updating in the DOM and not whether or not your data has changed. In fact, the diff algorithm is a dirty checker itself but it is used to see if the DOM is dirty instead.We aim to re-render the virtual tree only when the state changes. So using an observable to check if the state has changed is an efficient way to prevent unnecessary re-renders, which would cause lots of unnecessary tree diffs. If nothing has changed, we do nothing.A virtual DOM is nice because it lets us write our code as if we were re-rendering the entire scene. Behind the scenes we want to compute a patch operation that updates the DOM to look how we expect. So while the virtual DOM diff/patch algorithm is probably not the optimal solution, it gives us a very nice way to express our applications. We just declare exactly what we want and React/virtual-dom will work out how to make your scene look like this. We don\'t have to do manual DOM manipulation or get confused about previous DOM state. We don\'t have to re-render the entire scene either, which could be much less efficient than patching it.I recently read a detailed article about React\'s diff algorithm here: http://calendar.perfplanet.com/2013/diff/. From what I understand, what makes React fast is:Compared to dirty-check, the key differences IMO are:Model dirty-checking: React component is explicitly set as dirty whenever setState is called, so there\'s no comparison (of the data) needed here. For dirty-checking, the comparison (of the models) always happen each digest loop.DOM updating: DOM operations are very expensive because modifying the DOM will also apply and calculate CSS styles, layouts. The saved time from unnecessary DOM modification can be longer than the time spent diffing the virtual DOM. The second point is even more important for non-trivial models such as one with huge amount of fields or large list. One field change of complex model will result in only the operations needed for DOM elements involving that field, instead of the whole view/template.I really like the potential power of the Virtual DOM (especially\n  server-side rendering) but I would like to know all the pros and cons.-- OPReact is not the only DOM manipulation library. I encourage you to understand the alternatives by reading this article from Auth0 that includes detailed explanation and benchmarks. I\'ll highlight here their pros and cons, as you asked:Here\'s a comment by React team member Sebastian Markb\xc3\xa5ge which sheds some light:React does the diffing on the output (which is a known serializable format, DOM attributes). This means that the source data can be of any format. It can be immutable data structures and state inside of closures.The Angular model doesn\'t preserve referential transparency and therefore is inherently mutable. You mutate the existing model to track changes. What if your data source is immutable data or a new data structure every time (such as a JSON response)?Dirty checking and Object.observe does not work on closure scope state.These two things are very limiting to functional patterns obviously.Additionally, when your model complexity grows, it becomes increasingly expensive to do dirty tracking. However, if you only do diffing on the visual tree, like React, then it doesn\'t grow as much since the amount of data you\'re able to show on the screen at any given point is limited by UIs. Pete\'s link above covers more of the pref benefits.https://news.ycombinator.com/item?id=6937668Virtual Dom is not invented by react. It is part of HTML dom.\nIt is lightweight and detached from the browser-specific implementation details.We can think virtual DOM as React\xe2\x80\x99s local and simplified copy of the HTML DOM. It allows React to do its computations within this abstract world and skip the \xe2\x80\x9creal\xe2\x80\x9d DOM operations, often slow and browser-specific. Actually there is no big differenc between DOM and VIRTUAL DOM.Below are the points why Virtual Dom is used:When you do:Following thing happens:Recalculating the CSS and changed layouts uses complex algorithm and they effect the performance, as well as updating the DOM properties ie. values. It follows a algorithm.Now, suppose if you update DOM 10 times directly, then all the above steps will run one by one and updating DOM algorithms will take time to updates DOM values.This, is why Real DOM is slower than virtual DOM.