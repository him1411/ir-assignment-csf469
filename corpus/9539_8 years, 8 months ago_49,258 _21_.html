I have a feeling that there must be client-server synchronization patterns out there. But i totally failed to google up one.Situation is quite simple - server is the central node, that multiple clients connect to and manipulate same data. Data can be split in atoms, in case of conflict, whatever is on server, has priority (to avoid getting user into conflict solving). Partial synchronization is preferred due to potentially large amounts of data.Are there any patterns / good practices for such situation, or if you don\'t know of any - what would be your approach?Below is how i now think to solve it:\nParallel to data, a modification journal will be held, having all transactions timestamped. \nWhen client connects, it receives all changes since last check, in consolidated form (server goes through lists and removes additions that are followed by deletions, merges updates for each atom, etc.).\nEt voila, we are up to date.Alternative would be keeping modification date for each record, and instead of performing data deletes, just mark them as deleted.Any thoughts?You should look at how distributed change management works.  Look at SVN, CVS and other repositories that manage deltas work.You have several use cases.Synchronize changes.  Your change-log (or delta history) approach looks good for this.  Clients send their deltas to the server; server consolidates and distributes the deltas to the clients.  This is the typical case.  Databases call this "transaction replication".Client has lost synchronization.  Either through a backup/restore or because of a bug.  In this case, the client needs to get the current state from the server without going through the deltas.  This is a copy from master to detail, deltas and performance be damned.  It\'s a one-time thing; the client is broken; don\'t try to optimize this, just implement a reliable copy.Client is suspicious.  In this case, you need to compare client against server to determine if the client is up-to-date and needs any deltas.You should follow the database (and SVN) design pattern of sequentially numbering every change.  That way a client can make a trivial request ("What revision should I have?") before attempting to synchronize.  And even then, the query ("All deltas since 2149") is delightfully simple for the client and server to process.What you really need is Operational Transform (OT).  This can even cater for the conflicts in many cases.This is still an active area of research, but there are implementations of various OT algorithms around.  I\'ve been involved in such research for a number of years now, so let me know if this route interests you and I\'ll be happy to put you on to relevant resources.The question is not crystal clear, but I\'d look into optimistic locking if I were you.\nIt can be implemented with a sequence number that the server returns for each record. When a client tries to save the record back, it will include the sequence number it received from the server. If the sequence number matches what\'s in the database at the time when the update is received, the update is allowed and the sequence number is incremented. If the sequence numbers don\'t match, the update is disallowed.As part of the team, I did quite a lot of projects which involved data syncing, so I should be competent to answer this question.Data syncing is quite a broad concept and there are way too much to discuss. It covers a range of different approaches with their upsides and downsides. Here is one of the possible classifications based on two perspectives: Synchronous / Asynchronous, Client/Server / Peer-to-Peer. Syncing implementation is severely dependent on these factors, data model complexity, amount of data transferred and stored, and other requirements. So in each particular case the choice should be in favor of the simplest implementation meeting the app requirements.Based on a review of existing off-the-shelf solutions, we can delineate several major classes of syncing, different in granularity of objects subject to synchronization:So, we grabbed our knowledge into this article which I think might be very useful to everyone interested in the topic => Data Syncing in Core Data Based iOS apps (http://blog.denivip.ru/index.php/2014/04/data-syncing-in-core-data-based-ios-apps/?lang=en)  For delta (change) sync, you can use pubsub pattern to publish changes back to all subscribed clients, services like pusher can do this.For database mirror, some web frameworks use a local mini database to sync server side database to local in browser database, partial synchronization is supported. Check meteror.