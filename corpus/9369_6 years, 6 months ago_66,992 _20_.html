It\'s widely mentioned that Redis is "Blazing Fast" and mongoDB is fast too. But, I\'m having trouble finding actual numbers comparing the results of the two. Given similar configurations, features and operations (and maybe showing how the factor changes with different configurations and operations), etc, is Redis 10x faster?, 2x faster?, 5x faster?I\'m ONLY speaking of performance. I understand that mongoDB is a different tool and has a richer feature set.  This is not the "Is mongoDB better than Redis" debate. I\'m asking, by what margin does Redis outperform mongoDB?At this point, even cheap benchmarks are better than no benchmarks.Rough results from the following benchmark: 2x write, 3x read.Here\'s a simple benchmark in python you can adapt to your purposes, I was looking at how well each would perform simply setting/retrieving values:Results for with mongodb 1.8.1 and redis 2.2.5 and latest pymongo/redis-py:Take the results with a grain of salt of course! If you are programming in another language, using other clients/different implementations, etc your results will vary wildy. Not to mention your usage will be completely different! Your best bet is to benchmark them yourself, in precisely the manner you are intending to use them. As a corollary you\'ll probably figure out the best way to make use of each. Always benchmark for yourself!Please check this post about Redis and MongoDB insertion performance analysis:Up to 5000 entries mongodb $push is faster even when compared to Redis RPUSH, then it becames incredibly slow, probably the mongodb array type has linear insertion time and so it becomes slower and slower. mongodb might gain a bit of performances by exposing a constant time insertion list type, but even with the linear time array type (which can guarantee constant time look-up) it has its applications for small sets of data.Good and simple benchmarkI tried to recalculate the results again using the current versions of redis(2.6.16) and mongo(2.4.8) and here\'s the resultAlso this blog post compares both of them but using node.js. It shows the effect of increasing number of entries in the database along with time.Numbers are going to be hard to find as the two are not quite in the same space.  The general answer is that Redis 10 - 30% faster when the data set fits within working memory of a single machine.  Once that amount of data is exceeded, Redis fails.  Mongo will slow down at an amount which depends on the type of load.  For an insert only type of load one user recently reported a slowdown of 6 to 7 orders of magnitude (10,000 to 100,000 times) but that report also admitted that there were configuration issues, and that this was a very atypical working load.  Normal read heavy loads anecdotally slow by about 10X when some of the data must be read from disk.  Conclusion:  Redis will be faster but not by a whole lot.Here is an excellent article about session performance in the Tornado framework about 1 year old.  It has a comparison between a few different implementations, of which Redis and MongoDB are included.  The graph in the article states that Redis is behind MongoDB by about 10% in this specific use case.Redis comes with a built in benchmark that will analyze the performance of the machine you are on.  There is a ton of raw data from it at the Benchmark wiki for Redis. But you might have to look around a bit for Mongo. Like here, here, and some random polish numbers (but it gives you a starting point for running some MongoDB benchmarks yourself).I believe the best solution to this problem is to perform the tests yourself in the types of situations you expect.In my case, what has been a determining factor in performance comparison, is the MongoDb WriteConcern that is used. Most mongo drivers nowadays will set the default WriteConcern to ACKNOWLEDGED which means \'written to RAM\' (Mongo2.6.3-WriteConcern), in that regards, it was very comparable to redis for most write operations. But the reality is depending on your application needs and production environment setup, you may want to change this concern to WriteConcern.JOURNALED (written to oplog) or WriteConcern.FSYNCED (written to disk) or even written to replica sets (back-ups) if it is needed. Then you may start seeing some performance decrease. Other important factors also include, how optimized your data access patterns are, index miss % (see mongostat) and indexes in general.