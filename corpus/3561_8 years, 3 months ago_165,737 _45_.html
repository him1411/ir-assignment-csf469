Is there a performance or code maintenance issue with using assert as part of the standard code instead of using it just for debugging purposes?Isbetter or worse than Also, is there any way to set a business rule like if x < 0 raise error that is always checked without the try/except/finally so, if at anytime throughout the code x is less than 0 an error is raised, like if you set assert x < 0 at the start of a function, anywhere within the function where x becomes less then 0 an exception is raised?To be able to automatically throw an error when x become less than zero throughout the function. You can use class descriptors. Here is an example:Asserts should be used to test conditions that should never happen.  The purpose is to crash early in the case of a corrupt program state.Exceptions should be used for errors that can conceivably happen, and you should almost always create your own Exception classes.For example, if you\'re writing a function to read from a configuration file into a dict, improper formatting in the file should raise a ConfigurationSyntaxError, while you can assert that you\'re not about to return None.In your example, if x is a value set via a user interface or from an external source, an exception is best.If x is only set by your own code in the same program, go with an assertion."assert" statements are removed when the compilation is optimized.  So, yes, there are both performance and functional differences.The current code generator emits no code for an assert statement when optimization is requested at compile time. - Python 2.6.4 DocsIf you use assert to implement application functionality, then optimize the deployment to production, you will be plagued by "but-it-works-in-dev" defects.See PYTHONOPTIMIZE and -O -OOAssume you work on 200,000 lines of code with four colleagues Alice, Bernd, Carl, and Daphne.\nThey call your code, you call their code.Then assert has four roles:Inform Alice, Bernd, Carl, and Daphne what your code expects.\nAssume you have a method that processes a list of tuples and the program logic can break if those tuples are not immutable:This is more trustworthy than equivalent information in the documentation\nand much easier to maintain.Inform the computer what your code expects.\nassert enforces proper behavior from the callers of your code.\nIf your code calls Alices\'s and Bernd\'s code calls yours,\nthen without the assert, if the program crashes in Alices code,\nBernd might assume it was Alice\'s fault,\nAlice investigates and might assume it was your fault,\nyou investigate and tell Bernd it was in fact his.\nLots of work lost.\nWith asserts, whoever gets a call wrong, they will quickly be able to see it was\ntheir fault, not yours. Alice, Bernd, and you all benefit.\nSaves immense amounts of time.Inform the readers of your code (including yourself) what your code has achieved at some point.\nAssume you have a list of entries and each of them can be clean (which is good)\nor it can be smorsh, trale, gullup, or twinkled (which are all not acceptable).\nIf it\'s smorsh it must be unsmorshed; if it\'s trale it must be baludoed;\nif it\'s gullup it must be trotted (and then possibly paced, too);\nif it\'s twinkled it must be twinkled again except on Thursdays.\nYou get the idea: It\'s complicated stuff.\nBut the end result is (or ought to be) that all entries are clean.\nThe Right Thing(TM) to do is to summarize the effect of your\ncleaning loop asThis statements saves a headache for everybody trying to understand\nwhat exactly it is that the wonderful loop is achieving.\nAnd the most frequent of these people will likely be yourself.Inform the computer what your code has achieved at some point.\nShould you ever forget to pace an entry needing it after trotting,\nthe assert will save your day and avoid that your code\nbreaks dear Daphne\'s much later.In my mind, assert\'s two purposes of documentation (1 and 3) and \nsafeguard (2 and 4) are equally valuable.\nInforming the people may even be more valuable than informing the computer\nbecause it can prevent the very mistakes the assert aims to catch (in case 1)\nand plenty of subsequent mistakes in any case.In addition to the other answers, asserts themselves throw exceptions, but only AssertionErrors. From a utilitarian standpoint, assertions aren\'t suitable for when you need fine grain control over which exceptions you catch.The only thing that\'s really wrong with this approach is that it\'s hard to make a very descriptive exception using assert statements.  If you\'re looking for the simpler syntax, remember you can also do something like this:Another problem is that using assert for normal condition-checking is that it makes it difficult to disable the debugging asserts using the -O flag.As has been said previously, assertions should be used when your code SHOULD NOT ever reach a point, meaning there is a bug there. Probably the most useful reason I can see to use an assertion is an invariant/pre/postcondition. These are something that must be true at the start or end of each iteration of a loop or a function.For example, a recursive function (2 seperate functions so 1 handles bad input and the other handles bad code, cause it\'s hard to distinguish with recursion). This would make it obvious if I forgot to write the if statement, what had gone wrong.These loop invariants often can be represented with an assertion.As for "Is there a performance issue?":Please remember to "make it work first before you make it work fast".\nVery few percent of any program are usually relevant for its speed.\nYou can always kick out or simplify an assert if it ever proves to\nbe a performance problem -- and most of them never will.Be pragmatic:\nAssume you have a method that processes a non-empty list of tuples and the program logic will break if those tuples are not immutable. You should write:This is probably fine if your lists tend to be ten entries long, but\nit can become a problem if they have a million entries.\nBut rather than discarding this valuable check entirely you could \nsimply downgrade it towhich is cheap but will likely catch 97% of the actual program errors anyway.In IDE\'s such as PTVS, PyCharm, Wing assert isinstance() statements can be used to enable code completion for some unclear objects.There\'s a framework called JBoss Drools for java that does runtime monitoring to assert business rules, which answers the second part of your question. However, I am unsure if there is such a framework for python. An Assert is to check -\n1. the valid condition, \n2. the valid statement, \n3. true logic;\nof  source code. Instead of failing the whole project it gives an alarm that something is not appropriate in your source file.In example 1, since variable \'str\' is not nul. So no any assert or exception get raised.Example 1:In example 2, var \'str\' is nul. So we are saving the user from going ahead of faulty program by assert statement. Example 2:The moment we don\'t want debug and realized the assertion issue in the source code. Disable the optimization flagpython -O assertStatement.py\nnothing will get print The English language word assert here is used in the sense of swear, affirm, avow. It doesn\'t mean "check" or "should be". It means that you as a coder are making a sworn statement here:If the code is correct, barring Single-event upsets, hardware failures and such, no assert will ever fail. That is why the behaviour of the program to an end user must not be affected. Especially, an assert cannot fail even under exceptional programmatic conditions. It just doesn\'t ever happen. If it happens, the programmer should be zapped for 