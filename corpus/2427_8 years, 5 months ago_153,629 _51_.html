I want to have a unique constraint on a column which I am going to populate with GUIDs. However, my data contains null values for this columns. How do I create the constraint that allows multiple null values?Here\'s an example scenario. Consider this schema:Then see this code for what I\'m trying to achieve:The final statement fails with a message:Violation of UNIQUE KEY constraint \'UQ_People_LibraryCardId\'. Cannot insert duplicate key in object \'dbo.People\'.How can I change my schema and/or uniqueness constraint so that it allows multiple NULL values, while still checking for uniqueness on actual data?You can create a unique index that accept multiple NULLs with a WHERE clause. See the answer below.You cannot create a UNIQUE constraint and allow NULLs. You need set a default value of NEWID(). Update the existing values to NEWID() where NULL before creating the UNIQUE constraint.What you\'re looking for is indeed part of the ANSI standards SQL:92, SQL:1999 and SQL:2003, ie a UNIQUE constraint must disallow duplicate non-NULL values but accept multiple NULL values. In the Microsoft world of SQL Server however, a single NULL is allowed but multiple NULLs are not... In SQL Server 2008, you can define a unique filtered index based on a predicate that excludes NULLs:In earlier versions, you can resort to VIEWS with a NOT NULL predicate to enforce the constraint.Materialized View Not RequiredFor SQL 2005 and earlier, you can do it without a view. I just added a unique constraint like you\'re asking for to one of my tables. Given that I want uniqueness in column SamAccountName, but I want to allow multiple NULLs, I used a materialized column rather than a materialized view:You simply have to put something in the computed column that will be guaranteed unique across the whole table when the actual desired unique column is NULL. In this case, PartyID is an identity column and being numeric will never match any SamAccountName, so it worked for me. You can try your own method--be sure you understand the domain of your data so that there is no possibility of intersection with real data. That could be as simple as prepending a differentiator character like this:Even if PartyID became non-numeric someday and could coincide with a SamAccountName, now it won\'t matter.This DOES take space in the table, which may not be the best for you, though. In SQL Server 2008 and up, definitely use the filtered solution!Note that you can also add the keyword PERSISTED to the end of the column definition if you don\'t want an index but wish to use some disk space for precalculation of the expression in order to save CPU later.ControversyPlease note that some database professionals will see this as a case of "surrogate NULLs", which definitely have problems (mostly due to issues around trying to determine when something is a real value or a surrogate value for missing data; there can also be issues with the number of non-NULL surrogate values multiplying like crazy).However, I believe this case is different. The computed column I\'m adding will never be used to determine anything. It has no meaning of itself, and encodes no information that isn\'t already found separately in other, properly defined columns. It should never be selected or used.So, my story is that this is not a surrogate NULL, and I\'m sticking to it! Since we don\'t actually want the non-NULL value for any purpose other than to trick the UNIQUE index to ignore NULLs, our use case has none of the problems that arise with normal surrogate NULL creation.All that said, I have no problem with using an indexed view instead--but it brings some issues with it such as the requirement of using SCHEMABINDING. Have fun adding a new column to your base table (you\'ll at minimum have to drop the index, and then drop the view or alter the view to not be schema bound). See the full (long) list of requirements for creating an indexed view in SQL Server (2005) (also later versions), (2000).UpdateIf your column is numeric, there may be a challenge of ensuring that the unique constraint using Coalesce does not result in collisions. In that case, there are some options. One might be to use a negative number, to put the "surrogate NULLs" only in the negative range, and the "real values" only in the positive range. Alternately, the following pattern may be used. In table Issue (where IssueID is the PRIMARY KEY), there may or may not be a TicketID, but if there is one, it must be unique.If IssueID 1 has ticket 123, the UNIQUE constraint will be on values (123, NULL). If IssueID 2 has no ticket, it will be on (NULL, 2). Some thought will show that this constraint cannot be duplicated for any row in the table, and still allows multiple NULLs.For people who are using Microsoft SQL Server Manager and want to create a Unique but Nullable index you can create your unique index as you normally would then in your Index Properties for your new index, select "Filter" from the left hand panel, then enter your filter (which is your where clause).  It should read something like this:This works with MSSQL 2012When I applied the unique index below: every non null update and insert failed with the error below:UPDATE failed because the following SET options have incorrect settings: \'ARITHABORT\'.I found this on MSDNSET ARITHABORT must be ON when you are creating or changing indexes on computed columns or indexed views. If SET ARITHABORT is OFF, CREATE, UPDATE, INSERT, and DELETE statements on tables with indexes on computed columns or indexed views will fail.So to get this to work correctly I did thisRight click [Database]-->Properties-->Options-->Other\n  Options-->Misscellaneous-->Arithmetic Abort Enabled -->trueI believe it is possible to set this option in code using but i have not tested thisCreate a view that selects only non-NULL columns and create the UNIQUE INDEX on the view:Note that you\'ll need to perform INSERT\'s and UPDATE\'s on the view instead of table.You may do it with an INSTEAD OF trigger:It is possible to create a unique constraint on a Clustered Indexed View   You can create the View like this:and the unique constraint like this:Maybe consider an "INSTEAD OF" trigger and do the check yourself? With a non-clustered (non-unique) index on the column to enable the lookup.As stated before, SQL Server doesn\'t implement the ANSI standard when it comes to UNIQUE CONSTRAINT. There is a ticket on Microsoft Connect for this since 2007. As suggested there and here the best options as of today are to use a filtered index as stated in another answer or a computed column, e.g.:It can be done in the designer as well Right click on the Index > Properties to get this windowYou can\'t do this with a UNIQUE constraint, but you can do this in a trigger.this code if u make a register form with textBox and use insert and ur textBox is empty and u click on submit button .