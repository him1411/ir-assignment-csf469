I\'ve been looking for a simple Java algorithm to generate a pseudo-random alpha-numeric string.  In my situation it would be used as a unique session/key identifier that would "likely" be unique over 500K+ generation (my needs don\'t really require anything much more sophisticated).  Ideally, I would be able to specify a length depending on my uniqueness needs. For example, a generated string of length 12 might look something like "AEYGF7K0DM1X".  To generate a random string, concatenate characters drawn randomly from the set of acceptable symbols until the string reaches the desired length.Here\'s some fairly simple and very flexible code for generating random identifiers. Read the information that follows for important application notes.Create an insecure generator for 8-character identifiers:Create a secure generator for session identifiers:Create a generator with easy-to-read codes for printing. The strings are longer than full alphanumeric strings to compensate for using fewer symbols:Generating session identifiers that are likely to be unique is not good enough, or you could just use a simple counter. Attackers hijack sessions when predictable identifiers are used.There is tension between length and security. Shorter identifiers are easier to guess, because there are fewer possibilities. But longer identifiers consume more storage and bandwidth. A larger set of symbols helps, but might cause encoding problems if identifiers are included in URLs or re-entered by hand.The underlying source of randomness, or entropy, for session identifiers should come from a random number generator designed for cryptography. However, initializing these generators can sometimes be computationally expensive or slow, so effort should be made to re-use them when possible.Not every application requires security. Random assignment can be an efficient way for multiple entities to generate identifiers in a shared space without any coordination or partitioning. Coordination can be slow, especially in a clustered or distributed environment, and splitting up a space causes problems when entities end up with shares that are too small or too big.Identifiers generated without taking measures to make them unpredictable should be protected by other means if an attacker might be able to view and manipulate them, as happens in most web applications. There should be a separate authorization system that protects objects whose identifier can be guessed by an attacker without access permission.Care must be also be taken to use identifiers that are long enough to make collisions unlikely given the anticipated total number of identifiers. This is referred to as "the birthday paradox." The probability of a collision, p, is approximately n2/(2qx), where n is the number of identifiers actually generated, q is the number of distinct symbols in the alphabet, and x is the length of the identifiers. This should be a very small number, like 2‑50 or less.Working this out shows that the chance of collision among 500k 15-character identifiers is about 2‑52, which is probably less likely than undetected errors from cosmic rays, etc.According to their specification, UUIDs are not designed to be unpredictable, and should not be used as session identifiers.UUIDs in their standard format take a lot of space: 36 characters for only 122 bits of entropy. (Not all bits of a "random" UUID are selected randomly.) A randomly chosen alphanumeric string packs more entropy in just 21 characters.UUIDs are not flexible; they have a standardized structure and layout. This is their chief virtue as well as their main weakness. When collaborating with an outside party, the standardization offered by UUIDs may be helpful. For purely internal use, they can be inefficient.Java supplies a way of doing this directly. If you don\'t want the dashes, they are easy to strip out. Just use uuid.replace("-", "")Output:If you\'re happy to use Apache classes, you could use org.apache.commons.lang.RandomStringUtils (commons-lang).In one line:http://mynotes.wordpress.com/2009/07/23/java-generating-random-string/You can use Apache library for this: RandomStringUtilsusing Dollar should be simple as:it outputs something like that:Here it is in Java:Here\'s a sample run:Surprising no-one here has suggested it but: Easy. Benefit of this is UUIDs are nice and long and guaranteed to be almost impossible to collide.Wikipedia has a good explanation of it: " ...only after generating 1 billion UUIDs every second for the next 100 years, the probability of creating just one duplicate would be about 50%."http://en.wikipedia.org/wiki/Universally_unique_identifier#Random_UUID_probability_of_duplicatesThe first 4 bits are the version type and 2 for the variant so you get 122 bits of random. So if you want to you can truncate from the end to reduce the size of the UUID. It\'s not recommended but you still have loads of randomness, enough for your 500k records easy.A short and easy solution, but uses only lowercase and numerics:The size is about 12 digits to base 36 and can\'t be improved further, that way. Of course you can append multiple instances.An alternative in Java 8 is:This is easily achievable without any external libraries.First you need a cryptographic PRNG. Java has SecureRandom for that typically uses the best entropy source on the machine (e.g. /dev/random) . Read more here.Note: SecureRandom is the slowest, but most secure way in Java of generating random bytes. I do however recommend NOT considering performance here since it usually has no real impact on your application unless you have to generate millions of tokens per second - in this case your entropy cache will probably run out.Next you have to decide "how unique" your token needs to be. The whole and only point of considering entropy is to make sure that the system can resist brute force attacks: the space of possible values must be so large that any attacker could only try a negligible proportion of the values in non-ludicrous time1. Unique identifiers such as random UUID have 122bit of entropy (ie. 2^122 = 5.3x10^36) - the chance of collision is "*(...) for there to be a one in a billion chance of duplication, 103 trillion version 4 UUIDs must be generated2". We will choose 128 bit since it fits exactly into 16 bytes and is seen as highly sufficient for being unique for basically every, but the most extreme, use cases and you don\'t have to think about duplicates. Here is a simple comparison table of entropy including simple analysis of the birthday problem.For simple requirements 8 or 12 byte length might suffice, but with 16 bytes you are on the "safe side".And that\'s basically it. Last thing is to think about encoding so it can be represented as a printable text (read, a String).Typical encodings include:Base64 every character encodes 6bit creating a 33% overhead. Unfortunatly there is no standard implementation in the JDK (there is in Android). But numerous libraries exist that add this. The downside is, that Base64 is not safe for eg. urls and as filename in most file systems requiring additional encoding (e.g. url encoding). Example encoding 16 bytes with padding: XfJhfv3C0P6ag7y9VQxSbw==Base32 every character encodes 5bit creating a 40% overhead. This will use A-Z and 2-7 making it reasonably space efficient while being case-insensitive alpha-numeric. Like with Base64 there is no standard implementation in JDK. Example encoding 16 bytes without padding: WUPIL5DQTZGMF4D3NX5L7LNFOYBase16 (hex) every character encodes 4bit requiring 2 characters per byte (ie. 16 byte create a string of length 32). Therefore hex is less space efficient than Base32 but is safe to use in most cases (url) since it only uses 0-9 and A to F. Example encoding 16 bytes: 4fa3dd0f57cb3bf331441ed285b27735. See a SO discussion about converting to hex here.Additional encodings like Base85 and the exotic Base122 exist with better/worse space efficiency. You can create your own encoding (which basically most answers in this thread do) but I would advise against it, if you don\'t have very specific requirements. See more encoding schemes in the Wikipedia article.Don\'tSo what this does is just add\'s the password into the string and ... yeah works good check it out... very simple. I wrote itUsing UUIDs is insecure, because parts of the UUID arn\'t random at all. The procedure of @erickson is very neat, but does not create strings of the same length. The following snippet should be sufficient:Why choosing length*5. Let\'s assume the simple case of a random string of length 1, so one random character. To get a random character containing all digits 0-9 and characters a-z, we would need a random number between 0 and 35 to get one of each character. BigInteger provides a constructor to generate a random number, uniformly distributed over the range 0 to (2^numBits - 1). Unfortunately 35 is no number which can be received by 2^numBits - 1. So we have two options: Either go with 2^5-1=31 or 2^6-1=63. If we would choose 2^6 we would get a lot of "unnecesarry" / "longer" numbers. Therefore 2^5 is the better option, even if we loose 4 characters (w-z). To now generate a string of a certain length, we can simply use a 2^(length*numBits)-1 number. The last problem, if we want a string with a certain length, random could generate a small number, so the length is not met, so we have to pad the string to it\'s required length prepending zeros.I found this solution that generates a random hex encoded string.  The provided unit test seems to hold up to my primary use case.  Although, it is slightly more complex than some of the other answers provided.using apache library it can be done in one linehere is doc http://commons.apache.org/lang/api-2.3/org/apache/commons/lang/RandomStringUtils.htmlYou can use following code , if your password mandatory contains numbers alphabetic special characters:Here is the one line code by AbacusUtilRandom doesn\'t mean it must be unique. to get unique strings, using:You mention "simple", but just in case anyone else is looking for something that meets more stringent security requirements, you might want to take a look at jpwgen.  jpwgen is modeled after pwgen in Unix, and is very configurable.Here it is a Scala solution:Maybe this is helpfulChange String characters as per as your requirements.String is immutable. Here StringBuilder.append is more efficient than string concatenation.Best Random String Generator MethodLots of use of StringBuilder above.  I guess it\'s easy, but requires a function call per char, growing an array, etc...\nIf using the stringbuilder, a suggestion is to specify the required capacity of the string ie.,Here\'s a version that doesn\'t use a StringBuilder or String appending, and no dictionary.You can create a character array which includes all the letters and numbers, then you can randomly select from this char array and create your own string password.