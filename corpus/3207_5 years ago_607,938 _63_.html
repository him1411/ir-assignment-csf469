I have the following indexed DataFrame with named columns and rows not- continuous numbers:I would like to add a new column, \'e\', to the existing data frame and do not want to change anything in the data frame (i.e., the new column always has the same length as the DataFrame). I tried different versions of join, append, merge, but I did not get the result I wanted, only errors at most. How can I add column e to the above example? Use the original df1 indexes to create the series:Edit 2015\nSome reported to get the SettingWithCopyWarning with this code.\nHowever, the code still runs perfect with the current pandas version 0.16.1.The SettingWithCopyWarning aims to inform of a possibly invalid assignment on a copy of the Dataframe. It doesn\'t necessarily say you did it wrong (it can trigger false positives) but from 0.13.0 it let you know there are more adequate methods for the same purpose. Then, if you get the warning, just follow its advise: Try using .loc[row_index,col_indexer] = value insteadIn fact, this is currently the more efficient method as described in pandas docsEdit 2017As indicated in the comments and by @Alexander, currently the best method to add the values of a Series as a new column of a DataFrame could be using assign:This is the simple way of adding a new column: df[\'e\'] = eI would like to add a new column, \'e\', to the existing data frame and do not change anything in the data frame. (The series always got the same length as a dataframe.) I assume that the index values in e match those in df1.The easiest way to initiate a new column named e, and assign it the values from your series e:assign (Pandas 0.16.0+)As of Pandas 0.16.0, you can also use assign, which assigns new columns to a DataFrame and returns a new object (a copy) with all the original columns in addition to the new ones.As per this example (which also includes the source code of the assign function), you can also include more than one column:In context with your example: The description of this new feature when it was first introduced can be found here.Doing this directly via NumPy will be the most efficient:Note my original (very old) suggestion was to use map (which is much slower):It seems that in recent Pandas versions the way to go is to use df.assign:df1 = df1.assign(e=np.random.randn(sLength))It doesn\'t produce SettingWithCopyWarning.I got the dreaded SettingWithCopyWarning, and it wasn\'t fixed by using the iloc syntax. My DataFrame was created by read_sql from an ODBC source. Using a suggestion by lowtech above, the following worked for me:This worked fine to insert the column at the end. I don\'t know if it is the most efficient, but I don\'t like warning messages. I think there is a better solution, but I can\'t find it, and I think it depends on some aspect of the index.\nNote. That this only works once and will give an error message if trying to overwrite and existing column.\nNote As above and from 0.16.0 assign is the best solution. See documentation http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.assign.html#pandas.DataFrame.assign \nWorks well for data flow type where you don\'t overwrite your intermediate values.A pandas dataframe is implemented as an ordered dict of columns.This means that the __getitem__ [] can not only be used to get a certain column, but __setitem__ [] = can be used to assign a new column.For example, this dataframe can have a column added to it by simply using the [] accessorNote that this works even if the index of the dataframe is off.However, if you have a pd.Series and try to assign it to a dataframe where the indexes are off, you will run in to trouble. See example:This is because a pd.Series by default has an index enumerated from 0 to n. And the pandas [] = method tries to be "smart"When you use the [] = method pandas is quietly performing an outer join or outer merge using the index of the left hand dataframe and the index of the right hand series. df[\'column\'] = seriesThis quickly causes cognitive dissonance, since the []= method is trying to do a lot of different things depending on the input, and the outcome cannot be predicted unless you just know how pandas works. I would therefore advice against the []= in code bases, but when exploring data in a notebook, it is fine.If you have a pd.Series and want it assigned from top to bottom, or if you are coding productive code and you are not sure of the index order, it is worth it to safeguard for this kind of issue.You could downcast the pd.Series to a np.ndarray or a list, this will do the trick.orBut this is not very explicit.Some coder may come along and say "Hey, this looks redundant, I\'ll just optimize this away".Setting the index of the pd.Series to be the index of the df is explicit.Or more realistically, you probably have a pd.Series already available.Can now be assignedSince the index dissonance is the problem, if you feel that the index of the dataframe should not dictate things, you can simply drop the index, this should be faster, but it is not very clean, since your function now probably does two things.While df.assign make it more explicit what you are doing, it actually has all the same problems as the above []=Just watch out with df.assign that your column is not called self. It will cause errors. This makes df.assign smelly, since there are these kind of artifacts in the function.You may say, "Well, I\'ll just not use self then". But who knows how this function changes in the future to support new arguments. Maybe your column name will be an argument in a new update of pandas, causing problems with upgrading.Let me just add that, just like for hum3, .loc didn\'t solve the SettingWithCopyWarning and I had to resort to df.insert(). In my case false positive was generated by "fake" chain indexing  dict[\'a\'][\'e\'], where \'e\' is the new column, and dict[\'a\'] is a DataFrame coming from dictionary.Also note that if you know what you are doing, you can switch of the warning using\npd.options.mode.chained_assignment = None\nand than use one of the other solutions given here.If you get the SettingWithCopyWarning, an easy fix is to copy the DataFrame you are trying to add a column to.Before assigning a new column, if you have indexed data, you need to sort the index. At least in my case I had to:One thing to note, though, is that if you dothis will effectively be a left join on the df1.index. So if you want to have an outer join effect, my probably imperfect solution is to create a dataframe with index values covering the universe of your data, and then use the code above. For example,The following is what I did... But I\'m pretty new to pandas and really Python in general, so no promises.Foolproof:Example:To add a new column, \'e\', to the existing data frame I was looking for a general way of adding a column of numpy.nans to a dataframe without getting the dumb SettingWithCopyWarning.From the following:I came up with this:For the sake of completeness - yet another solution using DataFrame.eval() method:Data:Solution:If the data frame and Series object have the same index, pandas.concat also works here:In case they don\'t have the same index: