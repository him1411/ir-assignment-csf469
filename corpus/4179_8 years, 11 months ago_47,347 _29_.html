Resharper likes to point out multiple functions per asp.net page that could be made static. Does it help me if I do make them static? Should I make them static and move them to a utility class?Static methods versus Instance methods\n\n10.2.5 Static and instance members of the C# Language Specification explains the difference. Generally, static methods can provide a very small performance enhancement over instance methods, but only in somewhat extreme situations (see this answer for some more details on that).Rule CA1822 in FxCop or Code Analysis states:"After [marking members as static], the compiler will emit non-virtual call sites to these members which will prevent a check at\n  runtime for each call that ensures the current object pointer is\n  non-null. This can result in a measurable performance gain for\n  performance-sensitive code. In some cases, the failure to access the\n  current object instance represents a correctness issue."Utility Class\nYou shouldn\'t move them to a utility class unless it makes sense in your design. If the static method relates to a particular type, like a ToRadians(double degrees) method relates to a class representing angles, it makes sense for that method to exist as a static member of that type (note, this is a convoluted example for the purposes of demonstration).Performance, namespace pollution etc are all secondary in my view. Ask yourself what is logical. Is the method logically operating on an instance of the type, or is it related to the type itself? If it\'s the latter, make it a static method. Only move it into a utility class if it\'s related to a type which isn\'t under your control.Sometimes there are methods which logically act on an instance but don\'t happen to use any of the instance\'s state yet. For instance, if you were building a file system and you\'d got the concept of a directory, but you hadn\'t implemented it yet, you could write a property returning the kind of the file system object, and it would always be just "file" - but it\'s logically related to the instance, and so should be an instance method. This is also important if you want to make the method virtual - your particular implementation may need no state, but derived classes might. (For instance, asking a collection whether or not it\'s read-only - you may not have implemented a read-only form of that collection yet, but it\'s clearly a property of the collection itself, not the type.)Marking a method as static within a class makes it obvious that it doesn\'t use any instance members which can be helpful to know when skimming through the code. You don\'t necessarily have to move it to another class unless it\'s meant to be shared by another class that\'s just as closely associated, concept-wise.I\'m sure this isn\'t happening in your case, but one "bad smell" I\'ve seen in some code I\'ve had to suffer through maintaining used a heck of a lot of static methods.Unfortunately, they were static methods that assumed a particular application state. (why sure, we\'ll only have one user per application! Why not have the User class keep track of that in static variables?) They were glorified ways of accessing global variables. They also had static constructors (!), which are almost always a bad idea. (I know there are a couple of reasonable exceptions).However, static methods are quite useful when they factor out domain-logic that doesn\'t actually depend on the state of an instance of the object. They can make your code a lot more readable.Just be sure you\'re putting them in the right place. Are the static methods intrusively manipulating the internal state of other objects? Can a good case be made that their behavior belongs to one of those classes instead? If you\'re not separating concerns properly, you may be in for headaches later.Just to add to @Jason True\'s answer, it is important to realise that just putting \'static\' on a method doesn\'t guarantee that the method will be \'pure\'. It will be stateless with regard to the class in which it is declared, but it may well access other \'static\' objects which have state (application configuration etc.), this may not always be a bad thing, but one of the reasons that I personally tend to prefer static methods when I can is that if they are pure, you can test and reason about them in isolation, without having to worry about the surrounding state.For complex logic within a class, I have found private static methods useful in creating isolated logic, in which the instance inputs are clearly defined in the method signature and no instance side-effects can occur.  All outputs must be via return value or out/ref parameters. Breaking down complex logic into side-effect-free code blocks can improve the code\'s readability and the development team\'s confidence in it.On the other hand it can lead to a class polluted by a proliferation of utility methods. As usual, logical naming, documentation, and consistent application of team coding conventions can alleviate this.This is interesting read:http://thecuttingledge.com/?p=57ReSharper isn\xe2\x80\x99t actually suggesting you make your method static. \nYou should ask yourself why that method is in that class as opposed to, say, one of the classes that shows up in its signature...but here is what resharper documentaion says:\nhttp://confluence.jetbrains.net/display/ReSharper/Member+can+be+made+staticReSharper does not check the logic. It only checks whether the method uses instance members.\nIf the method is private and only called by (maybe just one) instance methods this is a sign to let it an instance method.You should do what is most readable and intuitive in a given scenario.The performance argument is not a good one except in the most extreme situations as the only thing that is actually happening is that one extra parameter (this) is getting pushed onto the stack for instance methods.It helps to control namespace pollution.If the functions are shared across many pages, you could also put them in a base page class, and then have all asp.net pages using that functionality inherit from it (and the functions could still be static as well).Making a method static means you can call the method from outside the class without first creating an instance of that class. This is helpful when working with third-party vendor objects or add-ons. Imagine if you had to first create a Console object "con" before calling con.Writeline();Just my tuppence: Adding all of the shared static methods to a utility class allows you to add to your using statements, which makes the code faster to type and easier to read. For example, I have a large number of what would be called "global variables" in some code I inherited. Rather than make global variables in a class that was an instance class, I set them all as static properties of a global class. It does the job, if messily, and I can just reference the properties by name because I have the static namespace already referenced.I have no idea if this is good practice or not. I have so much to learn about C# 4/5 and so much legacy code to refactor that I am just trying to let the Roselyn tips guide me.Joey