What techniques can be used to speed up C++ compilation times?This question came up in some comments to Stack Overflow question C++ programming style, and I\'m interested to hear what ideas there are.I\'ve seen a related question, Why does C++ compilation take so long?, but that doesn\'t provide many solutions.Vote here have Visual Studio support sharing precompiled headers between projectsTake a look at the Pimpl idiom here, and here, also known as an opaque pointer or handle classes. Not only does it speed up compilation, it also increases exception safety when combined with a non-throwing swap function. The Pimpl idiom lets you reduce the dependencies between headers and reduces the amount of recompilation that needs to be done.Wherever possible, use forward declarations. If the compiler only needs to know that SomeIdentifier is a struct or a pointer or whatever, don\'t include the entire definition, forcing the compiler to do more work than it needs to. This can have a cascading effect, making this way slower than they need to be.The I/O streams are particularly known for slowing down builds. If you need them in a header file, try #including <iosfwd> instead of <iostream> and #include the <iostream> header in the implementation file only.  The <iosfwd> header holds forward declarations only. Unfortunately the other standard headers don\'t have a respective declarations header.Prefer pass-by-reference to pass-by-value in function signatures. This will eliminate the need to #include the respective type definitions in the header file and you will only need to forward-declare the type. Of course, prefer const references to non-const references to avoid obscure bugs, but this is an issue for another question.Use guard conditions to keep header files from being included more than once in a single translation unit.By using both the pragma and the ifndef, you get the portability of the plain macro solution, as well as the compilation speed optimization that some compilers can do in the presence of the pragma once directive.The more modular and less interdependent your code design is in general, the less often you will have to recompile everything. You can also end up reducing the amount of work the compiler has to do on any individual block at the same time, by virtue of the fact that it has less to keep track of.These are used to compile a common section of included headers once for many translation units. The compiler compiles it once, and saves its internal state. That state can then be loaded quickly to get a head start in compiling another file with that same set of headers.Be careful that you only include rarely changed stuff in the precompiled headers, or you could end up doing full rebuilds more often than necessary. This is a good place for STL headers and other library include files.ccache is another utility that takes advantage of caching techniques to speed things up.Many compilers / IDEs support using multiple cores/CPUs to do compilation simultaneously. In GNU Make (usually used with GCC), use the -j [N] option. In Visual Studio, there\'s an option under preferences to allow it to build multiple projects in parallel. You can also use the /MP option for file-level paralellism, instead of just project-level paralellism.Other parallel utilities:The more the compiler tries to optimize, the harder it has to work.Moving your less frequently modified code into libraries can reduce compile time. By using shared libraries (.so or .dll), you can reduce linking time as well.More RAM, faster hard drives (including SSDs), and more CPUs/cores will all make a difference in compilation speed.I\'d recommend these articles from "Games from Within, Indie Game Design And Programming":Granted, they are pretty old - you\'ll have to re-test everything with the latest versions (or versions available to you), to get realistic results. Either way, it is a good source for ideas.I work on the STAPL project which is a heavily-templated C++ library. Once in a while, we have to revisit all the techniques to reduce compilation time. In here, I have summarized the techniques we use. Some of these techniques are already listed above:Although there is no proven correlation between the symbol lengths and compilation time, we have observed that smaller average symbol sizes can improve compilation time on all compilers. So your first goals it to find the largest symbols in your code.You can use the nm command to list the symbols based on their sizes:In this command the --radix=d lets you see the sizes in decimal numbers (default is hex). Now by looking at the largest symbol, identify if you can break the corresponding class and try to redesign it by factoring the non-templated parts in a base class, or by splitting the class into multiple classes.You can run the regular nm command and pipe it to your favorite script (AWK, Python, etc.) to sort the symbols based on their length. Based on our experience, this method identifies the largest trouble making candidates better than method 1."Templight is a Clang-based tool to profile the time and memory consumption of template instantiations and to perform interactive debugging sessions to gain introspection into the template instantiation process".You can install Templight by checking out LLVM and Clang (instructions) and applying the Templight patch on it. The default setting for LLVM and Clang is on debug and assertions, and these can impact your compilation time significantly. It does seem like Templight needs both, so you have to use the default settings. The process of installing LLVM and Clang should take about an hour or so.After applying the patch you can use templight++ located in the build folder you specified upon installation to compile your code.Make sure that templight++ is in your PATH. Now to compile add the following switches to your CXXFLAGS in your Makefile or to your command line options:OrAfter compilation is done, you will have a .trace.memory.pbf and .trace.pbf generated in the same folder. To visualize these traces, you can use the Templight Tools that can convert these to other formats. Follow these instructions to install templight-convert. We usually use the callgrind output. You can also use the GraphViz output if your project is small:The callgrind file generated can be opened using kcachegrind in which you can trace the most time/memory consuming instantiation.Although there are no exact solution for reducing the number of template instantiations, there are a few guidelines that can help:For example, if you have a class,and both of T and U can have 10 different options, you have increased the possible template instantiations of this class to 100. One way to resolve this is to abstract the common part of the code to a different class. The other method is to use inheritance inversion (reversing the class hierarchy), but make sure that your design goals are not compromised before using this technique.Using this technique, you can compile the common section once and link it with your other TUs (translation units) later on.If you know all the possible instantiations of a class you can use this technique to compile all cases in a different translation unit.For example, in:We know that this class can have three possible instantiations:Put the above in a translation unit and use the extern keyword in your header file, below the class definition:This technique can save you time if you are compiling different tests with a common set of instantiations.NOTE : MPICH2 ignores the explicit instantiation at this point and always compiles the instantiated classes in all compilation units.The whole idea behind unity builds is to include all the .cc files that you use in one file and compile that file only once. Using this method, you can avoid reinstantiating common sections of different files and if your project includes a lot of common files, you probably would save on disk accesses as well.As an example, let\'s assume you have three files foo1.cc, foo2.cc, foo3.cc and they all include tuple from STL. You can create a foo-all.cc that looks like:You compile this file only once and potentially reduce the common instantiations among the three files. It is hard to generally predict if the improvement can be significant or not. But one evident fact is that you would lose parallelism in your builds (you can no longer compile the three files at the same time).Further, if any of these files happen to take a lot of memory, you might actually run out of memory before the compilation is over. On some compilers, such as GCC, this might ICE (Internal Compiler Error) your compiler for lack of memory. So don\'t use this technique unless you know all the pros and cons.Precompiled headers (PCHs) can save you a lot of time in compilation by compiling your header files to an intermediate representation recognizable by a compiler. To generate precompiled header files, you only need to compile your header file with your regular compilation command. For example, on GCC:This will generate a YOUR_HEADER.hpp.gch file (.gch is the extension for PCH files in GCC) in the same folder. This means that if you include YOUR_HEADER.hpp in some other file, the compiler will use your YOUR_HEADER.hpp.gch instead of YOUR_HEADER.hpp in the same folder before.There are two issues with this technique:For example:Unnamed namespaces (a.k.a. anonymous namespaces) can reduce the generated binary sizes significantly. Unnamed namespaces use internal linkage, meaning that the symbols generated in those namespaces will not be visible to other TU (translation or compilation units). Compilers usually generate unique names for unnamed namespaces. This means that if you have a file foo.hpp:And you happen to include this file in two TUs (two .cc files and compile them separately). The two foo template instances will not be the same. This violates the One Definition Rule (ODR). For the same reason, using unnamed namespaces is discouraged in the header files. Feel free to use them in your .cc files to avoid symbols showing up in your binary files. In some cases, changing all the internal details for a .cc file showed a 10% reduction in the generated binary sizes.In newer compilers you can select your symbols to be either visible or invisible in the Dynamic Shared Objects  (DSOs). Ideally, changing the visibility can improve compiler performance, link time optimizations (LTOs), and generated binary sizes. If you look at the STL header files in GCC you can see that it is widely used. To enable visibility choices, you need to change your code per function, per class, per variable and more importantly per compiler.With the help of visibility you can hide the symbols that you consider them private from the generated shared objects. On GCC you can control the visibility of symbols by passing default or hidden to the -visibility option of your compiler. This is in some sense similar to the unnamed namespace but in a more elaborate and intrusive way.If you would like to specify the visibilities per case, you have to add the following attributes to your functions, variables, and classes:The default visibility in GCC is default (public), meaning that if you compile the above as a shared library (-shared) method, foo2 and class foo3 will not be visible in other TUs (foo1 and foo4 will be visible). If you compile with -visibility=hidden then only foo1 will be visible. Even foo4 would be hidden.You can read more about visibility on GCC wiki.There\'s an entire book on this topic, which is titled Large-Scale C++ Software Design (written by John Lakos).The book pre-dates templates, so to the contents of that book add "using templates, too, can make the compiler slower".One technique which worked quite well for me in the past: don\'t compile multiple C++ source files independently, but rather generate one C++ file which includes all the other files, like this:Of course this means you have to recompile all of the included source code in case any of the sources changes, so the dependency tree gets worse. However, compiling multiple source files as one translation unit is faster (at least in my experiments with MSVC and GCC) and generates smaller binaries. I also suspect that the compiler is given more potential for optimizations (since it can see more code at once).This technique breaks in various cases; for instance, the compiler will bail out in case two or more source files declare a global function with the same name. I couldn\'t find this technique described in any of the other answers though, that\'s why I\'m mentioning it here.For what it\'s worth, the KDE Project used this exact same technique since 1999 to build optimized binaries (possibly for a release). The switch to the build configure script was called --enable-final. Out of archaeological interest I dug up the posting which announced this feature: http://lists.kde.org/?l=kde-devel&m=92722836009368&w=2I will just link to my other answer: How do YOU reduce compile time, and linking time for Visual C++ projects (native C++)?. Another point I want to add, but which causes often problems is to use precompiled headers. But please, only use them for parts which hardly ever change (like GUI toolkit headers). Otherwise, they will cost you more time than they save you in the end.Another option is, when you work with GNU make, to turn on -j<N> option:I usually have it at 3 since I\'ve got a dual core here. It will then run compilers in parallel for different translation units, provided there are no dependencies between them. Linking cannot be done in parallel, since there is only one linker process linking together all object files.But the linker itself can be threaded, and this is what the GNU gold ELF linker does. It\'s optimized threaded C++ code which is said to link ELF object files a magnitude faster than the old ld (and was actually included into binutils).Here are some:Once you have applied all the code tricks above (forward declarations, reducing header inclusion to the minimum in public headers, pushing most details inside the implementation file with Pimpl...) and nothing else can be gained language-wise, consider your build system. If you use Linux, consider using distcc (distributed compiler) and ccache (cache compiler).The first one, distcc, executes the preprocessor step locally and then sends the output to the first available compiler in the network. It requires the same compiler and library versions in all the configured nodes in the network.The latter, ccache, is a compiler cache. It again executes the preprocessor and then check with an internal database (held in a local directory) if that preprocessor file has already been compiled with the same compiler parameters. If it does, it just pops up the binary and output from the first run of the compiler.Both can be used at the same time, so that if ccache does not have a local copy it can send it trough the net to another node with distcc, or else it can just inject the solution without further processing.When I came out of college, the first real production-worthy C++ code I saw had these arcane #ifndef ... #endif directives in between them where the headers were defined. I asked the guy who was writing the code about these overarching things in a very naive fashion and was introduced to world of large-scale programming.Coming back to the point, using directives to prevent duplicate header definitions was the first thing I learned when it came to reducing compiling times.More RAM.Someone talked about RAM drives in another answer. I did this with a 80286 and Turbo C++ (shows age) and the results were phenomenal. As was the loss of data when the machine crashed.Useat the top of header files, so if they\'re included more than once in a translation unit, the text of the header will only get included and parsed once.You could use Unity Builds.\xe2\x80\x8b\xe2\x80\x8bUpgrade your computerThen you have all your other typical suggestionsJust for completeness: a build might be slow because the build system is being stupid as well as because the compiler is taking a long time to do its work. Read Recursive Make Considered Harmful (PDF) for a discussion of this topic in Unix environments.Use forward declarations where you can. If a class declaration only uses a pointer or reference to a type, you can just forward declare it and include the header for the type in the implementation file.For example:Fewer includes means far less work for the preprocessor if you do it enough.Where are you spending your time?  Are you CPU bound?  Memory bound?  Disk bound?  Can you use more cores?  More RAM?  Do you need RAID?   Do you simply want to improve the efficiency of your current system?.Under gcc/g++, have you looked at ccache?  It can be helpful if you are doing make_clean_;_make a lot.Dynamic linking (.so) can be much much faster than static linking (.a).  Especially when you have a slow network drive.  This is since you have all of the code in the .a file which needs to be processed and written out.  In addition, a much larger executable file needs to be written out to the disk.I had an idea about using a RAM drive. It turned out that for my projects it doesn\'t make that much of a difference after all. But then they are pretty small still. Try it! I\'d be interested in hearing how much it helped.Networks shares will drastically slow down your build, as the seek latency is high. For something like Boost, it made a huge difference for me, even though our network share drive is pretty fast.   Time to compile a toy Boost program went from about 1 minute to 1 second when I switched from a network share to a local SSD.If you have a multicore processor, both Visual Studio (2005 and later) as well as GCC support multi-processor compiles. It is something to enable if you have the hardware, for sure.Not about the compilation time, but about the build time:Use ccache if you have to rebuild the same files when you are working\non your buildfilesUse ninja-build instead of make. I am currently compiling a project\nwith ~100 source files and everything is cached by ccache. make needs\n5 minutes, ninja less than 1.You can generate your ninja files from cmake with -GNinja.Although not a "technique", I couldn\'t figure out how Win32 projects with many source files compiled faster than my "Hello World" empty project.  Thus, I hope this helps someone like it did me.In Visual Studio, one option to increase compile times is Incremental Linking (/INCREMENTAL).  It\'s incompatible with Link-time Code Generation (/LTCG) so remember to disable incremental linking when doing release builds.Faster hard disks.Compilers write many (and possibly huge) files to disk. Work with SSD instead of typical hard disk and compilation times are much lower.On Linux (and maybe some other *NIXes), you can really speed the compilation by NOT STARING at the output and changing to another TTY.Here is the experiment: printf slows down my program