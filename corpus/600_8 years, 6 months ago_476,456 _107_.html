What is the simplest way to update a Label from another thread?I have a Form on thread1, and from that I\'m starting another thread (thread2). While thread2 is processing some files I would like to update a Label on the Form with the current status of thread2\'s work.How can I do that?For .NET 2.0, here\'s a nice bit of code I wrote that does exactly what you want, and works for any property on a Control:Call it like this:If you\'re using .NET 3.0 or above, you could rewrite the above method as an extension method of the Control class, which would then simplify the call to:UPDATE 05/10/2010:For .NET 3.0 you should use this code:which uses LINQ and lambda expressions to allow much cleaner, simpler and safer syntax:Not only is the property name now checked at compile time, the property\'s type is as well, so it\'s impossible to (for example) assign a string value to a boolean property, and hence cause a runtime exception.Unfortunately this doesn\'t stop anyone from doing stupid things such as passing in another Control\'s property and value, so the following will happily compile:Hence I added the runtime checks to ensure that the passed-in property does actually belong to the Control that the method\'s being called on. Not perfect, but still a lot better than the .NET 2.0 version.If anyone has any further suggestions on how to improve this code for compile-time safety, please comment!The simplest way is an anonymous method passed into Label.Invoke:Notice that Invoke blocks execution until it completes--this is synchronous code. The question doesn\'t ask about asynchronous code, but there is lots of content on Stack Overflow about writing asynchronous code when you want to learn about it.Since .NET 4.5 and C# 5.0 you should use Task-based Asynchronous Pattern (TAP) along with async-await keywords in all areas (including the GUI):TAP is the recommended asynchronous design pattern for new developmentinstead of Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP) (the latter includes the BackgroundWorker Class).Then, the recommended solution for new development is:Asynchronous implementation of an event handler (Yes, that\'s all):Implementation of the second thread that notifies the UI thread:Notice the following: For a more verbose examples see: The Future of C#: Good things come to those who \'await\' by Joseph Albahari.See also about UI Threading Model concept.The below snippet is an example of how to handle exceptions and toggle button\'s Enabled property to prevent multiple clicks during background execution.Variation of Marc Gravell\'s simplest solution for .NET 4:Or use Action delegate instead:See here for a comparison of the two: MethodInvoker vs Action for Control.BeginInvokeFire and forget extension method for .NET 3.5+This can be called using the following line of code:This is the classic way you should do this:Your worker thread has an event. Your UI thread starts off another thread to do the work and hooks up that worker event so you can display the state of the worker thread.Then in the UI you need to cross threads to change the actual control... like a label or a progress bar.The simple solution is to use Control.Invoke.Threading code is often buggy and always hard to test. You don\'t need to write threading code to update the user interface from a background task. Just use the BackgroundWorker class to run the task and its ReportProgress method to update the user interface. Usually, you just report a percentage complete, but there\'s another overload that includes a state object. Here\'s an example that just reports a string object:That\'s fine if you always want to update the same field. If you\'ve got more complicated updates to make, you could define a class to represent the UI state and pass it to the ReportProgress method.One final thing, be sure to set the WorkerReportsProgress flag, or the ReportProgress method will be completely ignored.You\'ll have to make sure that the update happens on the correct thread; the UI thread.In order to do this, you\'ll have to Invoke the event-handler instead of calling it directly.You can do this by raising your event like this:(The code is typed here out of my head, so I haven\'t checked for correct syntax, etc., but it should get you going.)Note that the code above will not work on WPF projects, since WPF controls do not implement the ISynchronizeInvoke interface.In order to make sure that the code above works with Windows Forms and WPF, and all other platforms, you can have a look at the AsyncOperation, AsyncOperationManager and SynchronizationContext classes.In order to easily raise events this way, I\'ve created an extension method, which allows me to simplify raising an event by just calling:Of course, you can also make use of the BackGroundWorker class, which will abstract this matter for you.The vast majority of answers use Control.Invoke which is a race condition waiting to happen. For example, consider the accepted answer:If the user closes the form just before this.Invoke is called (remember, this is the Form object), an ObjectDisposedException will be likely fired.The solution is to use SynchronizationContext, specifically SynchronizationContext.Current as hamilton.danielb suggests (other answers rely on specific SynchronizationContext implementations which is completely unnecessary). I would slightly modify his code to use SynchronizationContext.Post rather than SynchronizationContext.Send though (as there\'s typically no need for the worker thread to wait):Note that on .NET 4.0 and up you should really be using tasks for async operations. See n-san\'s answer for the equivalent task-based approach (using TaskScheduler.FromCurrentSynchronizationContext). Finally, on .NET 4.5 and up you can also use Progress<T> (which basically captures SynchronizationContext.Current upon its creation) as demonstrated by Ryszard D\xc5\xbcegan\'s for cases where the long-running operation needs to run UI code while still working.You\'ll need to Invoke the method on the GUI thread. You can do that by calling Control.Invoke.For example:None of the Invoke stuff in the previous answers is necessary.You need to look at WindowsFormsSynchronizationContext:Because of the triviality of the scenario I would actually have the UI thread poll for the status. I think you will find that it can be quite elegant.The approach avoids the marshaling operation required when using the ISynchronizeInvoke.Invoke and ISynchronizeInvoke.BeginInvoke methods. There is nothing wrong with using the marshaling technique, but there are a couple of caveats you need to be aware of.The strategy I propose in this answer reverses the communication roles of the threads. Instead of the worker thread pushing the data the UI thread polls for it. This a common pattern used in many scenarios. Since all you are wanting to do is display progress information from the worker thread then I think you will find that this solution is a great alternative to the marshaling solution. It has the following advantages.For many purposes it\'s as simple as this:"serviceGUI()" is a GUI level method within the form (this) that can change as many controls as you want. Call "updateGUI()" from the other thread. Parameters can be added to pass values, or (probably faster) use class scope variables with locks on them as required if there is any possibility of a clash between threads accessing them that could cause instability.  Use BeginInvoke instead of Invoke if the non-GUI thread is time critical (keeping Brian Gideon\'s warning in mind). This in my C# 3.0 variation of Ian Kemp\'s solution:You call it like this:Otherwise, the original is a very nice solution.Note that BeginInvoke() is preferred over Invoke() because it\'s less likely to cause deadlocks (however, this is not an issue here when just assigning text to a label): When using Invoke() you are waiting for the method to return. Now, it may be that you do something in the invoked code that will need to wait for the thread, which may not be immediately obvious if it\'s buried in some functions that you are calling, which itself may happen indirectly via event handlers. So you would be waiting for the thread, the thread would be waiting for you and you are deadlocked. This actually caused some of our released software to hang. It was easy enough to fix by replacing Invoke() with BeginInvoke(). Unless you have a need for synchronous operation, which may be the case if you need a return value, use BeginInvoke().Salvete! Having searched for this question, I found the answers by FrankG and Oregon Ghost to be the easiest most useful to me. Now, I code in Visual Basic and ran this snippet through a convertor; so I\'m not sure quite how it turns out.I have a dialog form called form_Diagnostics, which has a richtext box, called updateDiagWindow, which I am using as a sort of logging display.  I needed to be able to update its text from all threads. The extra lines allow the window to automatically scroll to the newest lines.And so, I can now update the display with one line, from anywhere in the entire program in the manner which you think it would work without any threading:Main Code (put this inside of your form\'s class code):This one is similar to the solution above using .NET Framework 3.0, but it solved the issue of compile-time safety support.To use:The compiler will fail if the user passes the wrong data type.When I encountered the same issue I sought help from Google, but rather than give me a simple solution it confused me more by giving examples of MethodInvoker and blah blah blah. So I decided to solve it on my own. Here is my solution:Make a delegate like this:You can call this function in a new thread like thisDon\'t be confused with Thread(() => .....). I use an anonymous function or lambda expression when I work on a thread. To reduce the lines of code you can use the ThreadStart(..) method too which I am not supposed to explain here.Simply use something like this:You may use the already-existing delegate Action:You must use invoke and delegateMy version is to insert one line of recursive "mantra":For no arguments:For a function that has arguments:THAT is IT.Some argumentation: Usually it is bad for code readability to put {} after an if () statement in one line. But in this case it is routine all-the-same "mantra". It doesn\'t break code readability if this method is consistent over the project. And it saves your code from littering (one line of code instead of five).As you see if(InvokeRequired) {something long} you just know "this function is safe to call from another thread".Create a class variable:Set it in the constructor that creates your UI:When you want to update the label:Try to refresh the label using thisThe easiest way I think:For example, access a control other than in the current thread:There the lblThreshold is a Label and Speed_Threshold is a global variable.I just read the answers and this appears to be a very hot topic. I\'m currently using .NET 3.5 SP1 and Windows Forms.The well-known formula greatly described in the previous answers that makes use of the InvokeRequired property covers most of the cases, but not the entire pool.What if the Handle has not been created yet?The InvokeRequired property, as described here (Control.InvokeRequired Property reference to MSDN) returns true if the call was made from a thread that is not the GUI thread, false either if the call was made from the GUI thread, or if the Handle was not created yet.You can come across an exception if you want to have a modal form shown and updated by another thread. Because you want that form shown modally, you could do the following:And the delegate can update a Label on the GUI:This can cause an InvalidOperationException if the operations before the label\'s update "take less time" (read it and interpret it as a simplification) than the time it takes for the GUI thread to create the Form\'s Handle. This happens within the ShowDialog() method.You should also check for the Handle like this:You can handle the operation to perform if the Handle has not been created yet: You can just ignore the GUI update (like shown in the code above) or you can wait (more risky).\nThis should answer the question.Optional stuff:\nPersonally I came up coding the following:I feed my forms that get updated by another thread with an instance of this ThreadSafeGuiCommand, and I define methods that update the GUI (in my Form) like this:In this way I\'m quite sure that I will have my GUI updated whatever thread will make the call, optionally waiting for a well-defined amount of time (the timeout).I wanted to add a warning because I noticed that some of the simple solutions omit the InvokeRequired check.  I noticed that if your code executes before the window handle of the control has been created (e.g. before the form is shown), Invoke throws an exception.  So I recommend always checking on InvokeRequired before calling Invoke or BeginInvoke.Even if the operation is time-consuming (thread.sleep in my example) - This code will NOT lock your UI:  