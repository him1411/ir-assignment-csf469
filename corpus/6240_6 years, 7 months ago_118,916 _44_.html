I am using Entity Framework and occasionally i will get this error. Even though i am not doing any manual connection management. this error happens intermittently.code that triggers the error (shortened for ease of reading):using Dispose pattern in order to open new connection every time.still problematic why wouldn\'t EF reuse a connection if it is already open. It is not about closing connection. EF manages connection correctly. My understanding of this problem is that there are multiple data retrieval commands executed on single connection (or single command with multiple selects) while next DataReader is executed before first one has completed the reading. The only way to avoid the exception is to allow multiple nested DataReaders = turn on MultipleActiveResultSets. Another scenario when this always happens is when you iterate through result of the query (IQueryable) and you will trigger lazy loading for loaded entity inside the iteration.Alternatively to using MARS (MultipleActiveResultSets) you can write your code so you dont open multiple result sets.What you can do is to retrieve the data to memory, that way you will not have the reader open.\nIt is often caused by iterating through a resultset while trying to open another result set.Sample Code:Lets say you are doing a lookup in your database containing these:We can do a simple solution to this by adding .ToList() like this:This forces entityframework to load the list into memory, thus when we iterate though it in the foreach loop it is no longer using the data reader to open the list, it is instead in memory.I realize that this might not be desired if you want to lazyload some properties for example. \nThis is mostly an example that hopefully explains how/why you might get this problem, so you can make decisions accordinglyThere\'s another way to overcome this problem.  Whether it\'s a better way depends on your situation.The problem results from lazy loading, so one way to avoid it is not to have lazy loading, through the use of Include:If you use the appropriate Includes, you can avoid enabling MARS.  But if you miss one, you\'ll get the error, so enabling MARS is probably the easiest way to fix it.You get this error, when the collection you are trying to iterate is kind of lazy loading (IQueriable). Converting the IQueriable collection into other enumerable collection will solve this problem.\nexample Note: .ToList() creates a new set every-time and it can cause the performance issue if you are dealing with large data.I solved the problem easily (pragmatic) by adding the option to the constructor. Thus, i use that only when needed. try in your connection string to set  "MultipleActiveResultSets=true"\nthis allow multitasking on database .\n" Server=yourserver ;AttachDbFilename=database;User Id=sa;Password=blah ;MultipleActiveResultSets=true;App=EntityFramework"\nthats works for me ... whether your connection in app.config or you set it programmatically ...\nhope this helpful I had originally decided to use a static field in my API class to reference an instance of MyDataContext object (Where MyDataContext is an EF5 Context object), but that is what seemed to create the problem.  I added code something like the following to every one of my API methods and that fixed the problem. As other people have stated, the EF Data Context objects are NOT thread safe. So placing them in the static object will eventually cause the "data reader" error under the right conditions. My original assumption was that creating only one instance of the object would be more efficient, and afford better memory management.  From what I have gathered researching this issue, that is not the case.  In fact, it seems to be more efficient to treat each call to your API as an isolated, thread safe event. Ensuring that all resources are properly released, as the object goes out of scope.This makes sense especially if you take your API to the next natural progression which would be to expose it as a WebService or REST API.DisclosureI noticed that this error happens when I send an IQueriable to the view and use it in a double foreach, where the inner foreach also needs to use the connection. Simple example (ViewBag.parents can be IQueriable or DbSet):The simple solution is to use .ToList() on the collection before using it. Also note that MARS does not work with MySQL.A good middle-ground between enabling MARS and retrieving the entire result set into memory is to retrieve only IDs in an initial query, and then loop through the IDs materializing each entity as you go.For example (using the "Blog and Posts" sample entities as in this answer):Doing this means that you only pull a few thousand integers into memory, as opposed to thousands of entire object graphs, which should minimize memory usage while enabling you to work item-by-item without enabling MARS.Another nice benefit of this, as seen in the sample, is that you can save changes as you loop through each item, instead of having to wait until the end of the loop (or some other such workaround), as would be needed even with MARS enabled (see here and here).I found that I had the same error, and it occurred when I was using a Func<TEntity, bool> instead of a Expression<Func<TEntity, bool>> for your predicate.Once I changed out all Func\'s to Expression\'s the exception stopped being thrown.I believe that EntityFramwork does some clever things with Expression\'s which it simply does not do with Func\'sIf we try to group part of our conditions into a Func<> or extension method we will get this error, suppose we have a code like this:This will throw the exception if we try to use it in a Where(), what we should do instead is to build a Predicate like this:Further more can be read at : http://www.albahari.com/nutshell/predicatebuilder.aspxThis problem can be solved simply by converting the data to a listI solved this problem using the following section of code before the second query:you can change the time of sleep in milisecondsP.D. Useful when using threads