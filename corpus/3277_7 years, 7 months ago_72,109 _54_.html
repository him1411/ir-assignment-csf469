When I specify an ancestor commit object in Git, I\'m confused between HEAD^ and HEAD~.Both have a "numbered" version like HEAD^3 and HEAD~2.They seem very similar or the same to me, but are there any differences between the tilde and the caret?HEAD^ means the first parent of the tip of the current branch.Remember that git commits can have more than one parent. HEAD^ is short for HEAD^1, and you can also address HEAD^2 and so on as appropriate.You can get to parents of any commit, not just HEAD. You can also move back through generations: for example, master~2 means the grandparent of the tip of the master branch, favoring the first parent in cases of ambiguity. These specifiers can be chained arbitrarily\n, e.g., topic~3^2.For the full details, see "Specifying Revisions" in the git rev-parse documentation.To have a visual representation of the idea let\'s quote part of documentation:Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.The difference between HEAD^ and HEAD~ is well described by the illustration (by Jon Loeliger) found on http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html. This documentation can be a bit obscure to beginners so I\'ve reproduced that illustration below:Both ~ and ^ on their own refer to the parent of the commit (~~ and ^^ both refer to the grandparent commit, etc.) But they differ in meaning when they are used with numbers:~2 means up two levels in the hierarchy, via the first parent if a commit has more than one parent^2 means the second parent where a commit has more than one parent (i.e. because it\'s a merge)These can be combined, so HEAD~2^3 means HEAD\'s grandparent commit\'s third parent commit.My two cents... (Ok, I have to type a few more characters due to stackoverflow policy.)The ^<n> format allows you to select the nth parent of the commit (relevant in merges).  The ~<n> format allows you to select the nth ancestor commit, always following the first parent.  See git-rev-parse\'s documentation for some examples.It is worth noting that git also has a syntax for tracking "from-where-you-came"/"want-to-go-back-now" - for example, HEAD@{1} will reference the place from where you jumped to new commit location.Basically HEAD@{} variables capture the history of HEAD movement, and you can decide to use a particular head by looking into reflogs of git using the command git reflog.Example:An example could be that I did local-commits a->b->c->d and then I went back discarding 2 commits to check my code - git reset HEAD~2 - and then after that I want to move my HEAD back to d - git reset HEAD@{1}.Here\'s a very good explanation taken verbatim from http://www.paulboxley.com/blog/2011/06/git-caret-and-tilde :ref~ is shorthand for ref~1 and means the commit\'s first parent. ref~2 means the commit\'s first parent\'s first parent. ref~3 means the commit\'s first parent\'s first parent\'s first parent. And so on.ref^ is shorthand for ref^1 and means the commit\'s first parent. But where the two differ is that ref^2 means the commit\'s second parent (remember, commits can have two parents when they are a merge).The ^ and ~ operators can be combined.HEAD^^^ is the same as HEAD~3, selecting the third commit before HEADHEAD^2 specifies the second head in a merge commitHEAD~ specifies the first parent on a "branch"HEAD^ allows you to select a specific parent of the commitAn Example:If you want to follow a side branch, you have to specify something likeSimplistically:You can specify one or more branch when merging. Then commit has two or more parents and then ^ is useful to indicates parents.Suppose you are on branch A and you have two more branches: B and C.On each branch three last commits are respectively:If now on branch A you execute the command:then you are combing three branches together (here your merge commit has three parents)and~ indicates the n\'th ancestor in the first branch, so^ indicates the n\'th parent, soThe next use of ~ or ^ next to each other, is in the context of the commit designated by previous characters.Notice 1:        and generally:Notice 2:        and generally:Simply put, for the first level of parentage (ancestry, inheritance, lineage, etc.) HEAD^ and HEAD~ both point to the same commit, which is (located) one parent above the HEAD (commit). Furthermore, HEAD^ = HEAD^1 = HEAD~ = HEAD~1. But HEAD^^ != HEAD^2 != HEAD~2.  Yet HEAD^^ = HEAD~2.  Read on.Beyond the first level of parentage, things get trickier, especially if the working branch/master branch has had merges (from other branches).  There is also the matter of syntax with the caret, HEAD^^ = HEAD~2 (they\'re equivalent) BUT HEAD^^ != HEAD^2 (they\'re two different things entirely). Each/the caret refers to the HEAD\'s first parent, which is why carets stringed together are equivalent to tilde expressions, because they refer to the first parent\'s (first parent\'s) first parents, etc., etc. based strictly on the number on connected carets or on the number following the tilde (either way, they both mean the same thing), i.e. stay with the first parent and go up x generations.HEAD~2 (or HEAD^^) refers to the commit that is two levels of ancestry up/above the current commit (the HEAD) in the hierarchy, meaning the HEAD\'s grandparent commit. HEAD^2, on the other hand, refers NOT to the first parent\'s second parent\'s commit, but simply to the second parent\'s commit. That is because the caret means the parent of the commit, and the number following signifies which/what parent commit is referred to (the first parent, in the case when the caret is not followed by a number [because it is shorthand for the number being 1, meaning the first parent]). Unlike the caret, the number that follows afterwards does not imply another level of hierarchy upwards, but rather it implies how many levels sideways, into the hierarchy, one needs to go find the correct parent (commit). Unlike the number in a tilde expression, it is only one parent up in the hierarchy, regardless of the number (immediately) proceeding the caret. Instead of upward, the caret\'s trailing number counts sideways for parents across the hierarchy [at a level of parents upwards that is equivalent to the number of consecutive carets].So HEAD^3 is equal to the third parent of the HEAD commit (NOT the great-grandparent, which is what HEAD^^^ AND HEAD~3 would be...).