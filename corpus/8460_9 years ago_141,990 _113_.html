I\'d like to be able to introspect a C++ class for its name, contents (i.e. members and their types) etc. I\'m talking native C++ here, not managed C++, which has reflection. I realise C++ supplies some limited information using RTTI. Which additional libraries (or other techniques) could supply this information?What you need to do is have the preprocessor generate reflection data about the fields. This data can be stored as nested classes. First, to make it easier and cleaner to write it in the preprocessor we will use typed expression. A typed expression is just an expression that puts the type in parenthesis. So instead of writing int x you will write (int) x. Here are some handy macros to help with typed expressions:Next, we define a REFLECTABLE macro to generate the data about each field(plus the field itself). This macro will be called like this:So using Boost.PP we iterate over each argument and generate the data like this:What this does is generate a constant fields_n that is number of reflectable fields in the class. Then it specializes the field_data for each field. It also friends the reflector class, this is so it can access the fields even when they are private:Now to iterate over the fields we use the visitor pattern. We create an MPL range from 0 to the number of fields, and access the field data at that index. Then it passes the field data on to the user-provided visitor:Now for the moment of truth we put it all together. Here is how we can define a Person class that is reflectable:Here is a generalized print_fields function using the reflection data to iterate over the fields:An example of using the print_fields with the reflectable Person class:Which outputs:And voila, we have just implemented reflection in C++, in under 100 lines of code. There are two kinds of reflection swimming around.If you are rather looking for ways to accomplish 1), like looking how many methods a class has, or like getting the string representation of a class id, then i\'m afraid there is no Standard C++ way of doing this. You have to use eitherC++ is made with speed in mind. If you want high-level inspection, like C# or Java has, then I\'m afraid i have to tell you there is no way without some effort.And I would love a pony, but ponies aren\'t free. :-phttp://en.wikibooks.org/wiki/C%2B%2B_Programming/RTTI is what you\'re going to get. Reflection like you\'re thinking about -- fully descriptive metadata available at runtime -- just doesn\'t exist for C++ by default.The information does exist - but not in the format you need, and only if you export your classes. This works in Windows, I don\'t know about other platforms. Using the storage-class specifiers as in, for example:This makes the compiler build the class definition data into the DLL/Exe. But it\'s not in a format that you can readily use for reflection.At my company we built a library that interprets this metadata, and allows you to reflect a class without inserting extra macros etc. into the class itself. It allows functions to be called as follows:This effectively does:The Invoke(this_pointer,...) function has variable arguments. Obviously by calling a function in this way you\'re circumventing things like const-safety and so on, so these aspects are implemented as runtime checks.I\'m sure the syntax could be improved, and it only works on Win32 and Win64 so far. We\'ve found it really useful for having automatic GUI interfaces to classes, creating properties in C++, streaming to and from XML and so on, and there\'s no need to derive from a specific base class. If there\'s enough demand maybe we could knock it into shape for release.RTTI doesn\'t exist for C++.This is simply wrong. Actually, the very term \xe2\x80\x9cRTTI\xe2\x80\x9d was coined by the C++ standard. On the other hand, RTTI doesn\'t go very far in implementing reflection.You need to look at what you are trying to do, and if RTTI will satisfy your requirements.  I\'ve implemented my own pseudo-reflection for some very specific purposes.  For example, I once wanted to be able to flexibly configure what a simulation would output.  It required adding some boilerplate code to the classes that would be output:The first call adds this object to the filtering system, which calls the BuildMap() method to figure out what methods are available.  Then, in the config file, you can do something like this:Through some template magic involving boost, this gets translated into a series of method calls at run-time (when the config file is read), so it\'s fairly efficient.  I wouldn\'t recommend doing this unless you really need to, but, when you do, you can do some really cool stuff.What are you trying to do with reflection?\n\nYou can use the Boost type traits and typeof libraries as a limited form of compile-time reflection. That is, you can inspect and modify the basic properties of a type passed to a template.I would recommend using Qt.There is an open-source licence as well as a commercial licence.I did something like what you\'re after once, and while it\'s possible to get some level of reflection and access to higher-level features, the maintenance headache might not be worth it.  My system was used to keep the UI classes completely separated from the business logic through delegation akin to Objective-C\'s concept of message passing and forwarding.  The way to do it is to create some base class that is capable of mapping symbols (I used a string pool but you could do it with enums if you prefer speed and compile-time error handling over total flexibility) to function pointers (actually not pure function pointers, but something similar to what Boost has with Boost.Function--which I didn\'t have access to at the time).  You can do the same thing for your member variables as long as you have some common base class capable of representing any value.  The entire system was an unabashed ripoff of Key-Value Coding and Delegation, with a few side effects that were perhaps worth the sheer amount of time necessary to get every class that used the system to match all of its methods and members up with legal calls:  1)  Any class could call any method on any other class without having to include headers or write fake base classes so the interface could be predefined for the compiler; and 2)  The getters and setters of the member variables were easy to make thread-safe because changing or accessing their values was always done through 2 methods in the base class of all objects.It also led to the possibility of doing some really weird things that otherwise aren\'t easy in C++.  For example I could create an Array object that contained arbitrary items of any type, including itself, and create new arrays dynamically by passing a message to all array items and collecting the return values (similar to map in Lisp).  Another was the implementation of key-value observing, whereby I was able to set up the UI to respond immediately to changes in the members of backend classes instead of constantly polling the data or unnecessarily redrawing the display.Maybe more interesting to you is the fact that you can also dump all methods and members defined for a class, and in string form no less.Downsides to the system that might discourage you from bothering:  adding all of the messages and key-values is extremely tedious; it\'s slower than without any reflection; you\'ll grow to hate seeing boost::static_pointer_cast and boost::dynamic_pointer_cast all over your codebase with a violent passion; the limitations of the strongly-typed system are still there, you\'re really just hiding them a bit so it isn\'t as obvious.  Typos in your strings are also not a fun or easy to discover surprise.As to how to implement something like this:  just use shared and weak pointers to some common base (mine was very imaginatively called "Object") and derive for all the types you want to use.  I\'d recommend installing Boost.Function instead of doing it the way I did, which was with some custom crap and a ton of ugly macros to wrap the function pointer calls.  Since everything is mapped, inspecting objects is just a matter of iterating through all of the keys.  Since my classes were essentially as close to a direct ripoff of Cocoa as possible using only C++, if you want something like that then I\'d suggest using the Cocoa documentation as a blueprint.The two reflection-like solutions I know of from my C++ days are:1) Use RTTI, which will provide a bootstrap for you to build your reflection-like behaviour, if you are able to get all your classes to derive from an \'object\' base class. That class could provide some methods like GetMethod, GetBaseClass etc. As for how those methods work you will need to manually add some macros to decorate your types, which behind the scenes create metadata in the type to provide answers to GetMethods etc.2) Another option, if you have access to the compiler objects is to use the DIA SDK. If I remember correctly this lets you open pdbs, which should contain metadata for your C++ types. It might be enough to do what you need. This page shows how you can get all base types of a class for example.Both these solution are a bit ugly though! There is nothing like a bit of C++ to make you appreciate the luxuries of C#.Good Luck.CAMP is an MIT licensed library (formerly LGPL) that adds reflection to the C++ language. It doesn\'t require a specific preprocessing step in the compilation, but the binding has to be made manually.The current Tegesoft library uses Boost, but there is also a fork using C++11 that no longer requires Boost.There is another new library for reflection in C++, called RTTR (Run Time Type Reflection, see also github).The interface is similar to reflection in C# and it works without any RTTI.EDIT: Updated broken link as of February, the 7th, 2017.I think noone mentioned this:At CERN they use a full reflection system for C++:CERN Reflex. It seems to work very well.This question is a bit old now (don\'t know why I keep hitting old questions today) but I was thinking about BOOST_FUSION_ADAPT_STRUCT which introduces compile-time reflection.It is up to you to map this to run-time reflection of course, and it won\'t be too easy, but it is possible in this direction, while it would not be in the reverse :)I really think a macro to encapsulate the BOOST_FUSION_ADAPT_STRUCT one could generate the necessary methods to get the runtime behavior.I think you might find interesting the article "Using Templates for Reflection in C++" by Dominic Filion. It is in section 1.4 of Game Programming Gems 5. Unfortunately I dont have my copy with me, but look for it because I think it explains what you are asking for.Reflection is essentially about what the compiler decided to leave as footprints in the code that the runtime code can query.  C++ is famous for not paying for what you don\'t use; because most people don\'t use/want reflection, the C++ compiler avoids the cost by not recording anything.So, C++ doesn\'t provide reflection, and it isn\'t easy to "simulate" it yourself as general rule as other answers have noted.Under "other techniques", if you don\'t have a language with reflection, get a tool that can extract the information you want at compile time.Our DMS Software Reengineering Toolkit is generalized compiler technology parameterized by explicit langauge definitions. It has langauge definitions for C, C++, Java, COBOL, PHP, ...For C, C++, Java and COBOL versions, it provides complete access to parse trees, and symbol table information.  That symbol table information includes the kind of data you are likely to want from "reflection".  If you goal is to enumerate some set of fields or methods and do something with them, DMS can be used to transform the code according to what you find in the symbol tables in arbitrary ways.You can find another library here: http://www.garret.ru/cppreflection/docs/reflect.html\nIt supports 2 ways: getting type information from debug information and let programmer to provide this information.I also interested in reflection for my project and found this library, i have not tried it yet, but tried other tools from this guy and i like how they work :-)Check out Classdesc http://classdesc.sf.net. It provides reflection in the form of class "descriptors", works with any standard C++ compiler (yes it is known to work with Visual Studio as well as GCC), and does not require source code annotation (although some pragmas exist to handle tricky situations). It has been in development for more than a decade, and used in a number of industrial scale projects.Ponder is a C++ reflection library, in answer to this question. I considered the options and decided to make my own since I couldn\'t find one that ticked all my boxes. Although there are great answers to this question, I don\'t want to use tonnes of macros, or rely on Boost. Boost is a great library, but there are lots of small bespoke C++0x projects out that are simpler and have faster compile times. There are also advantages to being able to decorate a class externally, like wrapping a C++ library that doesn\'t (yet?) support C++11. It is fork of CAMP, using C++11, that no longer requires Boost.Reflection is not supported by C++ out of the box. This is sad because it makes defensive testing a pain.There are several approaches to doing reflection:The first link looks the most promising (uses mod\'s to clang), the second discusses a number of techniques, the third is a different approach using gcc:http://www.donw.org/rfl/https://bitbucket.org/dwilliamson/clreflecthttps://root.cern.ch/how/how-use-reflexThere is now a working group for C++ reflection. See the news for C++14 @ CERN:Edit 13/08/17:\nSince the  original post there have been a number of potential advancements on the reflection. The following provides more detail and a discussion on the various techniques and status:However it does not look promising on a standardised reflections approach in C++ in the near future unless there is a lot more interest from the community in support for reflection in C++.The following details the current status based on feedback from the last C++ standards meeting:When I wanted reflection in C++ I read this article and improved upon what I saw there.  Sorry, no can has.  I don\'t own the result...but you can certainly get what I had and go from there.I am currently researching, when I feel like it, methods to use inherit_linearly to make the definition of reflectable types much easier.  I\'ve gotten fairly far in it actually but I still have a ways to go.  The changes in C++0x are very likely to be a lot of help in this area.It looks like C++ still does not have this feature.\nAnd C++11 postponed reflection too ((Search some macros or make own. Qt also can help with reflection (if it can be used).Try to look at this project http://www.garret.ru/cppreflection/docs/reflect.html\nis added reflections to C++. It added meta data to the classes that you can then use.even though reflection is not supported out-of-the-box in c++, it is not too hard to implement.\nI\'ve encountered this great article:\nhttp://replicaisland.blogspot.co.il/2010/11/building-reflective-object-system-in-c.htmlthe article explains in great detail how you can implement a pretty simple and rudimentary reflection system. granted its not the most wholesome solution, and there are rough edges left to be sorted out but for my needs it was sufficient.the bottom line - reflection can pay off if done correctly, and it is completely feasible in c++.I would like to advertise the existence of the automatic introspection/reflection toolkit "IDK". It uses a meta-compiler like Qt\'s and adds meta information directly into object files. It is claimed to be easy to use. No external dependencies. It even allows you to automatically reflect std::string and then use it in scripts. Please look at IDKReflection in C++ is very useful, in cases there you need to run some method for each member(For example: serialization, hashing, compare). I came with generic solution, with very simple syntax:Where ENUMERATE_MEMBERS is a macro, which is described later(UPDATE):Assume we have defined serialization function for int and std::string like this:And we have generic function near the "secret macro" ;)Now you can writeSo having ENUMERATE_MEMBERS macro in struct definition, you can build serialization, compare, hashing, and other stuffs without touching original type, the only requirement is to implement "EnumerateWith" method for each type, which is not enumerable, per enumerator(like BinaryWriter). Usually you will have to implement 10-20 "simple" types to support any type in your project.This macro should have zero-overhead to struct creation/destruction in run-time, and the code of T.EnumerateWith() should be generated on-demand, which can be achieved by making it template-inline function, so the only overhead in all the story is to add ENUMERATE_MEMBERS(m1,m2,m3...) to each struct, while implementing specific method per member type is a must in any solution, so I do not assume it as overhead.UPDATE: \nThere is very simple implementation of ENUMERATE_MEMBERS macro(however it could be a little be extended to support inheritance from enumerable struct)And you do not need any 3rd party library for these 15 lines of code ;)Root Reflex project has support for this. See https://root.cern.ch/how/how-use-reflexUpdated 24.2.2017Previously I have analyzed support for using #define\'s and like it\'s recommended in some of web articles - I\'ve hit across defines in visual C++ were not working \nidentically compared to define\'s used in gcc (for example, on internet this is quite often referred as "MSVC walkaround"). Besides not be able to easily understand what is happening behind define / macro expansion machinery - it\'s rather difficult to debug each macro expansion. There are couple of ways to walk around complexities of define expansion, one approach is to turn on "/P" compiler flag (pre-process to file only) - after that you can compare how your define\'s opened up. (Previously I have also used also actively stringfy operator (#))I have collected all useful defines from multiple forums, resorted them, and commented out what is happening behind machinery, you can find whole header file in here now:https://sourceforge.net/p/testcppreflect/code/HEAD/tree/MacroHelpers.hI thought it was rather trivial to use these macros to enable C++ reflection, but it requires bit more magic to do the reflection.I\'ve recollected a working sample code, and put it as sourceforge project, can be downloaded here:https://sourceforge.net/p/testcppreflect/code/HEAD/tree/Demo code looks like this:REFLECTABLE define uses class name + field name with offsetof - to identify at which place in memory particular field is located. I have tried to pick up .NET terminology for as far as possible, but C++ and C# are different, so it\'s not 1 to 1. Whole C++ reflection model resides in TypeInfo and FieldInfo classes for timebeing, it\'s possible to expand support also to method, but I\'ve decided to keep things simple for now.I have used pugi xml parser to fetch demo code into xml and restore it back from xml.So output produced by demo code looks like this:It\'s also possible to enable any 3-rd party class / structure support via TypeTraits class, and partial template specification - to define your own TypeTraitsT class, in similar manner to CString or int - see example code in https://sourceforge.net/p/testcppreflect/code/HEAD/tree/TypeTraits.h#l65I guess only downside of my own implementation is use of __if_exists - which might be Microsoft compiler specific extension. If someone knows how to walk around it, let me know.lack of built in reflection in C++ is the single reason why modern C++ is not used for web development (and lacks ORM and other frameworks)You can try\nhttp://www.extreme.indiana.edu/reflcpp/A simple way is to use the dynamic_cast<>() operator which, when assigned to an wrong type, returns NULL, so you can upcast to a base concrete class in an easy way, checking the value of the pointer, if it is not NULL, the cast was done, and you got the type of the object.But this is just a simple solution, and it only provides the type of the objects, you cannot ask what methods it has, like in Java. If you need an advanced solution, there are some frameworks to choose from.