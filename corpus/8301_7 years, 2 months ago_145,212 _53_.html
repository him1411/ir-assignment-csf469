Let\'s say I have the following local repository with a commit tree like this:master is my this is the latest stable release code, develop is my this is the \'next\' release code, and feature is a new feature being prepared for develop.What I want to be able to do on my remote repo using hooks, is for pushes to feature to be refused unless commit f is a direct descendant of develop HEAD. i.e. the commit tree looks like this because feature has been git rebase on d.So is it possible to:From there I would check what HEAD of parent branch is, and see if f predecessor matches the parent branch HEAD, to determine if the feature needs to be rebased.Assuming that the remote repository has a copy of the develop branch (your initial description describes it in a local repository, but it sounds like it also exists in the remote), you should be able to achieve what I think you want, but the approach is a bit different from what you have envisioned.Git\xe2\x80\x99s history is based on a DAG of commits. Branches (and \xe2\x80\x9crefs\xe2\x80\x9d in general) are just transient labels that point to specific commits in the continually growing commit DAG. As such, the relationship between branches can vary over time, but the relationship between commits does not.It looks like baz is based on (an old version of) bar? But what if we delete bar?Now it looks like baz is based on foo. But the ancestry of baz did not change, we just removed a label (and the resulting dangling commit). And what if we add a new label at 4?Now it looks like baz is based on quux. Still, the ancestry did not change, only the labels changed.If, however, we were asking \xe2\x80\x9cis commit 6 a descendent of commit 3?\xe2\x80\x9d (assuming 3 and 6 are full SHA-1 commit names), then the answer would be \xe2\x80\x9cyes\xe2\x80\x9d, whether the bar and quux labels are present or not.So, you could ask questions like \xe2\x80\x9cis the pushed commit a descendent of the current tip of the develop branch?\xe2\x80\x9d, but you can not reliably ask \xe2\x80\x9cwhat is the parent branch of the pushed commit?\xe2\x80\x9d.A mostly reliable question that seems to get close to what you want is:For all the pushed commit\xe2\x80\x99s ancestors (excluding the current tip of develop and its ancestors), that have the current tip of develop as a parent:Which could be implemented as:This will cover some of what you want restricted, but maybe not everything.For reference, here is an extended example history:The above code could be used to reject Hand S while accepting H\', J, K, or N, but it would also accept L and P (they involve merges, but they do not merge the tip of develop).To also reject L and P, you can change the question and askFor all the pushed commit\xe2\x80\x99s ancestors (excluding the current tip of develop and its ancestors):Another way to phrase the question is "What is the nearest commit that resides on a branch other than the current branch, and which branch is that?"You can find it with a little bit of command line magicRunning the above code onWill give you develop if you run it from H and master if you run it from I.The code is available as a gistI have a solution to your overall problem (determine if feature is descended from the tip of develop), but it doesn\'t work using the method you outlined.You can use git branch --contains to list all the branches descended from the tip of develop, then use grep to make sure feature is among them.If it is among them, it will print "  feature" to standard output and have a return code of 0.     Otherwise, it will print nothing and have a return code of 1.You can also try:This working fine for me.Courtesy answers from: @droidbot and @JistanidiotRemember that, as described in "Git: Finding what branch a commit came from", you cannot  easily pinpoint the branch where that commit has been made (branches can be renamed, moved, deleted...), even though git branch --contains <commit> is a start.If the two commits id match, you are good to go (that would mean the feature branch has its origin at the HEAD of develop).Since none of the answers above worked on our repository, I want to share my own way, using latest merges in git log:Put it in a script named git-last-merges, which also accepts a branch name as argument (instead of current branch) as well as other git log argumentsFrom the output, we can manually detect the parent branch(es) based on own branching conventions and number of merges from each branch.EDIT:\nIf you use git rebase on child branches often (and merges are fast-forwarded often so there aren\'t too many merge commits), this answer won\'t work well, so I wrote a script to count ahead commits (normal and merge), and behind commits (there shouldn\'t be any behind merge in parent branch) on all branches comparing to the current branch. Just run this script and let me know if works for you or notJoeChrysler\'s command-line magic can be simplified.  Here\'s the logic as written:We can accomplish the same thing as all five of those individual command filters in a relatively simple awk command:That breaks down like this:split the line into fields at ], ^, ~, and [ characters.Find lines that contain an asterisk...but not the current branch nameWhen you find such a line, print its second field (that is, the part between the first and second occurrences of our field separator characters). For simple branch names, that will be just what\'s between the brackets; for refs with relative jumps, it will be just the name without the modifier. So our set of field separators handles the intent of both sed commands.Then exit immediately.  This means it only ever processes the first matching line, so we don\'t need to pipe the output through head -n 1.@Mark Reed: You should add that the commit line should not only contain an asterisk, but begin with an asterisk! Otherwise commit messages that contain an asterisk are also included in the matched lines. So it should be:git show-branch -a | awk -F\'[]^~[]\' \'/^\\*/ && !/\'"$current_branch"\'/ {print $2;exit}\'or the long version:Cross-platform implementation with AntAchieves the same ends as Mark Reed\'s answer, but uses a much safer approach that doesn\'t misbehave in a number of scenarios:Here is a PowerShell implementation of Mark Reed\'s solution:Anyone wanting to do this these days - Atlassian\'s SourceTree application shows you a great visual representation of how your branches relate to one another, i.e. Where they began and where they currently sit in the commit order (e.g. HEAD or 4 commits behind, etc.).why not just use sourceTree:it shows a graphical tree...