I have been reading a lot of Javascript lately and I have been noticing that the whole file is wrapped like the following in the .js files to be imported.What is the reason for doing this rather than a simple set of constructor functions?It\'s usually to namespace (see later) and control the visibility of member functions and/or variables. Think of it like an object definition. jQuery plugins are usually written like this.In Javascript, you can nest functions. So, the following is legal:Now you can call outerFunction(), but the visiblity of innerFunction() is limited to the scope of outerFunction(), meaning it is private to outerFunction(). It basically follows the same principle as variables in Javascript:Correspondingly:In the above scenario, you can call globalFunction() from anywhere, but you cannot call localFunction1 or localFunction2.What you\'re doing when you write (function() { ... code ... })(), is you\'re making the code inside a function literal (meaning the whole "object" is actually a function). After that, you\'re self-invoking the function (the final ()). So the major advantage of this as I mentioned before, is that you can have private methods/functions and properties:The neat thing is that you can also define things inside and expose it to the outside world so (an example of namespacing so you can basically create your own library/plugin):Now you can call myPlugin.public_function1(), but you cannot access private_function()! So pretty similar to a class definition. To understand this better, I recommend the following links for some further reading:EDITI forgot to mention. In that final (), you can pass anything you want inside. For example, when you create jQuery plugins, you pass in jQuery or $ like so: So what you\'re doing here is defining a function that takes in one parameter (called jQ, a local variable, and known only to that function). Then you\'re self-invoking the function and passing in a parameter (also called jQuery, but this one is from the outside world and a reference to the actual jQuery itself).  There is no pressing need to do this, but there are some advantages:In its simplest form, this technique aims to wrap code inside a function scope.It helps decreases chances of:It does not detect when the document is ready - it is not some kind of document.onload nor window.onloadIt is commonly known as an Immediately Invoked Function Expression (IIFE) or Self Executing Anonymous Function.In the example above, any variable defined in the function (i.e. declared using var) will be "private" and accessible within the function scope ONLY (as Vivin Paliath puts it). In other words, these variables are not visible/reachable outside the function. See live demo.Javascript has function scoping. "Parameters and variables defined in a function are not visible outside of the function, and that a variable defined anywhere within a function is visible everywhere within the function." (from "Javascript: The Good Parts").In the end, the code posted before could also be done as follows:See live demo.One day, someone probably thought "there must be a way to avoid naming \'myMainFunction\', since all we want is to execute it immediately."If you go back to the basics, you find out that:Similarly, function expressions evaluate to a value. And one consequence (I assume?) is that they can be immediately invoked:So our more complex example becomes:See live demo.The next step is the thought "why have var myMainFunction = if we don\'t even use it!?".The answer is simple: try removing this, such as below:See live demo.It won\'t work because "function declarations are not invokable".The trick is that by removing var myMainFunction = we transformed the function expression into a function declaration. See the links in "Resources" for more details on this.The next question is "why can\'t I keep it as a function expression with something other than var myMainFunction =?The answer is "you can", and there are actually many ways you could do this: adding a +, a !, a -, or maybe wrapping in a pair of parenthesis (as it\'s now done by convention), and more I believe.  As example:ororSo once the relevant modification is added to what was once our "Alternative Code", we return to the exact same code as the one used in the "Code Explained" exampleRead more about Expressions vs Statements:One thing one might wonder is "what happens when you do NOT define the variable \'properly\' inside the function -- i.e. do a simple assignment instead?"See live demo.Basically, if a variable that was not declared in its current scope is assigned a value, then "a look up the scope chain occurs until it finds the variable or hits the global scope (at which point it will create it)".When in a browser environment (vs a server environment like nodejs) the global scope is defined by the window object. Hence we can do window.myOtherFunction().My "Good practices" tip on this topic is to always use var when defining anything: whether it\'s a number, object or function, & even when in the global scope. This makes the code much simpler.Note:Read more about Javascript Scopes:Once you get this IIFE concept, it leads to the module pattern, which is commonly done by leveraging this IIFE pattern. Have fun :)Javascript in a browser only really has a couple of effective scopes: function scope and global scope.If a variable isn\'t in function scope, it\'s in global scope. And global variables are generally bad, so this is a construct to keep a library\'s variables to itself.That\'s called a closure. It basically seals the code inside the function so that other libraries don\'t interfere with it. It\'s similar to creating a namespace in compiled languages.Example. Suppose I write:Now other libraries cannot access the variable x I created to use in my library.You can use function closures as data in larger expressions as well, as in this method of determining browser support for some of the html5 objects.In addition to keeping the variables local, one very handy use is when writing a library using a global variable, you can give it a shorter variable name to use within the library. It\'s often used in writing jQuery plugins, since jQuery allows you to disable the $ variable pointing to jQuery, using jQuery.noConflict(). In case it is disabled, your code can still use $ and not break if you just do:We should also use \'use strict\' in the scope function to make sure that the code should be executed in "strict mode". Sample code shown belowIn ES6, you can use a plain curly-brace block to keep your code out of the global namespace (var strongly discouraged!):Tested in Chrome, Safari, iOS Safari, Firefox. I have no idea if this pattern has a name, whether it\'s good practice, or why I could initially find no reference to it at all (until the above article).