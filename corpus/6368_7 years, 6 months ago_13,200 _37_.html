Here is the example with comments:So, what do you think about this?The bug is in the following two lines of System.ValueType: (I stepped into the reference source)(Both methods are [MethodImpl(MethodImplOptions.InternalCall)])When all of the fields are 8 bytes wide, CanCompareBits mistakenly returns true, resulting in a bitwise comparison of two different, but semantically identical, values.When at least one field is not 8 bytes wide, CanCompareBits returns false, and the code proceeds to use reflection to loop over the fields and call Equals for each value, which correctly treats -0.0 as equal to 0.0.Here is the source for CanCompareBits from SSCLI:I found the answer at http://blogs.msdn.com/xiangfan/archive/2008/09/01/magic-behind-valuetype-equals.aspx.The core piece is the source comment on CanCompareBits, which ValueType.Equals uses to determine whether to use memcmp-style comparison:The comment of CanCompareBits says\n  "Return true if the valuetype does not\n  contain pointer and is tightly\n  packed". And FastEqualsCheck use\n  "memcmp" to speed up the comparison.The author goes on to state exactly the problem described by the OP:Imagine you have a structure which\n  only contains a float. What will occur\n  if one contains +0.0, and the other\n  contains -0.0? They should be the\n  same, but the underlying binary\n  representation are different. If you\n  nest other structure which override\n  the Equals method, that optimization\n  will also fail.Vilx\'s conjecture is correct. What "CanCompareBits" does is checks to see whether the value type in question is "tightly packed" in memory. A tightly packed struct is compared by simply comparing the binary bits that make up the structure; a loosely packed structure is compared by calling Equals on all the members.This explains SLaks\' observation that it repros with structs that are all doubles; such structs are always tightly packed.Unfortunately as we\'ve seen here, that introduces a semantic difference because bitwise comparison of doubles and Equals comparison of doubles gives different results.Half an answer:Reflector tells us that ValueType.Equals() does something like this:Unfortunately both CanCompareBits() and FastEquals() (both static methods) are extern ([MethodImpl(MethodImplOptions.InternalCall)]) and have no source available.Back to guessing why one case can be compared by bits, and the other cannot (alignment issues maybe?)It does give true for me, with Mono\'s gmcs 2.4.2.3.Simpler test case:EDIT: The bug also happens with floats, but only happens if the fields in the struct add up to a multiple of 8 bytes.It must be related to a bit by bit comparison, since 0.0 should differ from -0.0 only by the signal bit.\xe2\x80\xa6what do you think about this?Always override Equals and GetHashCode on value types. It will be fast and correct.If you make D2 like thisit\'s true.if you make it like this It\'s still false.it seems like it\'s false if the struct only holds doubles.It must be zero related, since changing the lined.d = -0.0to:d.d = 0.0results in the comparison being true...Just an update for this 10 years old bug: it has been fixed (Disclaimer: I\'m the author of this PR) in .NET Core which would be probably released in .NET Core 2.1.0.The blog post explained the bug and how I fixed it.