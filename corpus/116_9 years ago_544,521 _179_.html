There have been several questions already posted with specific questions about dependency injection, such as when to use it and what frameworks are there for it. However,What is dependency injection and when/why should or shouldn\'t it be used?Basically, instead of having your objects creating a dependency or asking a factory object to make one for them, you pass the needed dependencies in to the object externally, and you make it somebody else\'s problem. This "someone" is either an object further up the dependency graph, or a dependency injector (framework) that builds the dependency graph. A dependency as I\'m using it here is any other object the current object needs to hold a reference to.One of the major advantages of dependency injection is that it can make testing lots easier. Suppose you have an object which in its constructor does something like:This can be troublesome when all you want to do is run some unit tests on SomeClass, especially if myObject is something that does complex disk or network access. So now you\'re looking at mocking myObject but also somehow intercepting the factory call. Hard. Instead, pass the object in as an argument to the constructor. Now you\'ve moved the problem elsewhere, but testing can become lots easier. Just make a dummy myObject and pass that in. The constructor would now look a bit like:This is one style of dependency injection - via the constructor. Several mechanisms are possible. When not using dependency injection (such as in classes that do too much work in their constructors etc.), it tends to become much harder to isolate components in unit testing. Back in 2013 when I wrote this answer, this was a major theme on the Google Testing Blog. This remains the biggest advantage to me, as you may not always need the extra flexibility in your run-time design (for instance, for service locator or similar patterns), but you do often need to be able to isolate your classes during testing.The best definition I\'ve found so far is one by James Shore: "Dependency Injection" is a 25-dollar\n  term for a 5-cent concept. [...]\n  Dependency injection means giving an\n  object its instance variables. [...].There is an article by Martin Fowler that may prove useful, too.Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It\'s a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.Dependencies can be injected into objects by many means (such as constructor injection or setter injection). One can even use specialized dependency injection frameworks (e.g. Spring) to do that, but they certainly aren\'t required. You don\'t need those frameworks to have dependency injection. Instantiating and passing objects (dependencies) explicitly is just as good an injection as injection by framework.I found this funny example in terms of loose coupling:Any application is composed of many objects that collaborate with each other to perform some useful stuff. Traditionally each object is responsible for obtaining its own references to the dependent objects (dependencies) it collaborate with. This leads to highly coupled classes and hard-to-test code.For example, consider a Car object.A Car depends on wheels, engine, fuel, battery, etc. to run. Traditionally we define the brand of such dependent objects along with the definition of the Car object.Without Dependency Injection (DI):Here, the Car object is responsible for creating the dependent objects.What if we want to change the type of its dependent object - say Wheel - after the initial NepaliRubberWheel() punctures?\nWe need to recreate the Car object with its new dependency say ChineseRubberWheel(), but only the Car manufacturer can do that.Then what does the Dependency Injection do us for...?When using dependency injection, objects are given their dependencies at run time rather than compile time (car manufacturing time).\nSo that we can now change the Wheel whenever we want. Here, the dependency (wheel) can be injected into Car at run time.After using dependency injection:Here, we are injecting the dependencies (Wheel and Battery) at runtime. Hence the term : Dependency Injection. Source: Understanding dependency injectionDependency Injection is a practice where objects are designed in a manner where they receive instances of the objects from other pieces of code, instead of constructing them internally.  This means that any object implementing the interface which is required by the object can be substituted in without changing the code, which simplifies testing, and improves decoupling.For example, consider these clases:In this example, the implementation of PersonService::addManager and PersonService::removeManager would need an instance of the GroupMembershipService in order to do its work.  Without Dependency Injection, the traditional way of doing this would be to instantiate a new GroupMembershipService in the constructor of PersonService and use that instance attribute in both functions.  However, if the constructor of GroupMembershipService has multiple things it requires, or worse yet, there are some initialization "setters" that need to be called on the GroupMembershipService, the code grows rather quickly, and the PersonService now depends not only on the GroupMembershipService but also everything else that GroupMembershipService depends on.  Furthermore, the linkage to GroupMembershipService is hardcoded into the PersonService which means that you can\'t "dummy up" a GroupMembershipService for testing purposes, or to use a strategy pattern in different parts of your application.   With Dependency Injection, instead of instantiating the GroupMembershipService within your PersonService, you\'d either pass it in to the PersonService constructor, or else add a Property (getter and setter) to set a local instance of it.  This means that your PersonService no longer has to worry about how to create a GroupMembershipService, it just accepts the ones it\'s given, and works with them.  This also means that anything which is a subclass of GroupMembershipService, or implements the GroupMembershipService interface can be "injected" into the PersonService, and the PersonService doesn\'t need to know about the change.The accepted answer is a good one - but I would like to add to this that DI is very much like the classic avoiding of hardcoded constants in the code.  When you use some constant like a database name you\'d quickly move it from the inside of the code to some config file and pass a variable containing that value to the place where it is needed.  The reason to do that is that these constants usually change more frequently than the rest of the code.  For example if you\'d like to test the code in a test database.  DI is analogous to this in the world of Object Oriented programming.  The values there instead of constant literals are whole objects - but the reason to move the code creating them out from the class code is similar - the objects change more frequently then the code that uses them.  One important case where such a change is needed is tests.Let\'s imagine that you want to go fishing:Without dependency injection, you need to take care of everything yourself. You need to find a boat, to buy a fishing rod, to look for bait, etc. It\'s possible, of course, but it puts a lot of responsibility on you. In software terms, it means that you have to perform a lookup for all these things.With dependency injection, someone else takes care of all the preparation and makes the required equipment available to you. You will receive ("be injected") the boat, the fishing rod and the bait - all ready to use.This is the most simple explanation about Dependency Injection and Dependency Injection Container I have ever seen:Dependency Injection and dependency Injection Containers are different things:You don\'t need a container to do dependency injection. However a container can help you.Doesn\'t "dependency injection" just mean using parameterized constructors and public setters?James Shore\'s article shows the following examples for comparison.Constructor without dependency injection:Constructor with dependency injection:What is Dependency Injection (DI)?As others have said, Dependency Injection(DI) removes the responsibility of direct creation, and management of the lifespan, of other object instances upon which our class of interest (consumer class) is dependent (in the UML sense). These instances are instead passed to our consumer class, typically as constructor parameters or via property setters (the management of the dependency object instancing and passing to the consumer class is usually performed by an Inversion of Control (IoC) container, but that\'s another topic).DI, DIP and SOLIDSpecifically, in the paradigm of Robert C Martin\'s SOLID principles of Object Oriented Design, DI is one of the possible implementations of the Dependency Inversion Principle (DIP). The DIP is the D of the SOLID mantra  - other DIP implementations include the Service Locator, and Plugin patterns.The objective of the DIP is to decouple tight, concrete dependencies between classes, and instead, to loosen the coupling by means of an abstraction, which can be achieved via an interface, abstract class or pure virtual class, depending on the language and approach used.Without the DIP, our code (I\'ve called this \'consuming class\') is directly coupled to a concrete dependency and is also often burdened with the responsibility of knowing how to obtain, and manage, an instance of this dependency, i.e. conceptually:Whereas after application of the DIP, the requirement is loosened, and the concern of obtaining and managing the lifespan of the Foo dependency has been removed:Why use DIP (and DI)?Decoupling dependencies between classes in this way allows for easy substitution of these dependency classes with other implementations which also fulfil the prerequisites of the abstraction (e.g. the dependency can be switched with another implementation of the same interface). Moreover, as others have mentioned, possibly the most common reason to decouple classes via the DIP is to allow a consuming class to be tested in isolation, as these same dependencies can now be stubbed and/or mocked.One consequence of DI is that the lifespan management of dependency object instances is no longer controlled by a consuming class, as the dependency object is now passed into the consuming class (via constructor or setter injection).This can be viewed in different ways:When to use DI?ExampleHere\'s a simple C# implementation. Given the below Consuming class:Although seemingly innocuous, it has two static dependencies on two other classes, System.DateTime and System.Console, which not only limit the logging output options (logging to console will be worthless if no one is watching), but worse, it is difficult to automatically test given the dependency on a non-deterministic system clock.We can however apply DIP to this class, by abstracting out the the concern of timestamping as a dependency, and coupling MyLogger only to a simple interface:We can also loosen the dependency on Console to an abstraction, such as a TextWriter. Dependency Injection is typically implemented as either constructor injection (passing an abstraction to a dependency as a parameter to the constructor of a consuming class) or Setter Injection (passing the dependency via a setXyz() setter or a .Net Property with {set;} defined). Constructor Injection is preferred, as this guarantees the class will be in a correct state after construction, and allows the internal dependency fields to be marked as readonly (C#) or final (Java). So using constructor injection on the above example, this leaves us with:(A concrete Clock needs to be provided, which of course could revert to DateTime.Now, and the two dependencies need to be provided by an IoC container via constructor injection)An automated Unit Test can be built, which definitively proves that our logger is working correctly, as we now have control over the dependencies - the time, and we can spy on the written output:Next StepsDependency injection is invariably associated with an Inversion of Control container(IoC), to inject (provide) the concrete dependency instances, and to manage lifespan instances. During the configuration / bootstrapping process, IoC containers allow the following to be defined:Typically, once IoC containers have been configured / bootstrapped, they operate seamlessly in the background allowing the coder to focus on the code at hand rather than worrying about dependencies.The key to DI-friendly code is to avoid static coupling of classes, and not to use new() for the creation of DependenciesAs per above example, decoupling of dependencies does require some design effort, and for the developer, there is a paradigm shift needed to break the habit of newing dependencies directly, and instead trusting the container to manage dependencies. But the benefits are many, especially in the ability to thoroughly test your class of interest.Note : The creation / mapping / projection (via new ..()) of POCO / POJO / Serialization DTOs / Entity Graphs / Anonymous JSON projections et al - i.e. "Data only" classes or records - used or returned from methods are not regarded as Dependencies (in the UML sense) and not subject to DI. Using new to project these is just fine.To make Dependency Injection concept simple to understand. Let\'s take an example of switch button to toggle(on/off) a bulb.Switch needs to know beforehand which bulb I am connected to (hard-coded dependency). So,Switch -> PermanentBulb //switch is directly connected to permanent bulb, testing not possible easilySwitch only knows I need to turn on/off whichever Bulb is passed to me. So,Switch -> Bulb1 OR Bulb2 OR NightBulb (injected dependency)Modifying James Example for Switch and Bulb:The whole point of Dependency Injection (DI) is to keep application source code clean and stable:Practically, every design pattern separates concerns to make future changes affect minimum files.The specific domain of DI is delegation of dependency configuration and initialization.If you occasionally work outside of Java, recall how source is often used in many scripting languages (Shell, Tcl, etc., or even import in Python misused for this purpose).Consider simple dependent.sh script:The script is dependent: it won\'t execute successfully on its own (archive_files is not defined).You define archive_files in archive_files_zip.sh implementation script (using zip in this case):Instead of source-ing implementation script directly in the dependent one, you use an injector.sh "container" which wraps both "components":The archive_files dependency has just been injected into dependent script.You could have injected dependency which implements archive_files using tar or xz.If dependent.sh script used dependencies directly, the approach would be called dependency lookup (which is opposite to dependency injection):Now the problem is that dependent "component" has to perform initialization itself.The "component"\'s source code is neither clean nor stable because every changes in initialization of dependencies requires new release for "components"\'s source code file as well.DI is not as largely emphasized and popularized as in Java frameworks.But it\'s a generic approach to split concerns of:Using configuration only with dependency lookup does not help as number of configuration parameters may change per dependency (e.g. new authentication type) as well as number of supported types of dependencies (e.g. new database type).Dependency Injection(DI) means to decouple the objects which are dependent on each other. Say object A is dependent on Object B so the idea is to decouple these object from each other. We don\xe2\x80\x99t need to hard code the object using new keyword rather sharing dependencies to objects at runtime in spite of compile time.\nIf we talk about We don\xe2\x80\x99t need to hard code the object using new keyword rather define the bean dependency in the configuration file. The spring container will be responsible for hooking up all.IOC is a general concept and it can be expressed in many different ways and Dependency Injection is one concrete example of IOC.Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on other class.Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.NOTE:\nIt is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the if we use annotation based than @Required annotation on a setter can be used to make setters as a required dependencies.The best analogy I can think of is the surgeon and his assistant(s) in an operation theater, where the surgeon is the main person and his assistant who provides the various surgical components when he needs it so that the surgeon can concentrate on the one thing he does best (surgery). Without the assistant the surgeon has to get the components himself every time he needs one.DI for short, is a technique to remove a common additional responsibility (burden) on components to fetch the dependent components, by providing them to it.DI brings you closer to the Single Responsibility (SR) principle, like the surgeon who can concentrate on surgery.When to use DI : I would recommend using DI in almost all production projects ( small/big), particularly in ever changing business environments :)Why : Because you want your code to be easily testable, mockable etc so that you can quickly test your changes and push it to the market. Besides why would you not when you there are lots of awesome free tools/frameworks to support you in your journey to a codebase where you have more control.It means that objects should only have as many dependencies as is needed to do their job and the dependencies should be few. Furthermore, an object\xe2\x80\x99s dependencies should be on interfaces and not on \xe2\x80\x9cconcrete\xe2\x80\x9d objects, when possible. (A concrete object is any object created with the keyword new.) Loose coupling promotes greater reusability, easier maintainability, and allows you to easily provide \xe2\x80\x9cmock\xe2\x80\x9d objects in place of expensive services.The \xe2\x80\x9cDependency Injection\xe2\x80\x9d (DI) is also known as \xe2\x80\x9cInversion of Control\xe2\x80\x9d (IoC), can be used as a technique for encouraging this loose coupling.There are two primary approaches to implementing DI:It\xe2\x80\x99s the technique of passing objects dependencies to its constructor.Note that the constructor accepts an interface and not concrete object. Also, note that an exception is thrown if the orderDao parameter is null. This emphasizes the importance of receiving a valid dependency. Constructor Injection is, in my opinion, the preferred mechanism for giving an object its dependencies. It is clear to the developer while invoking the object which dependencies need to be given to the \xe2\x80\x9cPerson\xe2\x80\x9d object for proper execution.But consider the following example\xe2\x80\xa6 Suppose you have a class with ten methods that have no dependencies, but you\xe2\x80\x99re adding a new method that does have a dependency on IDAO. You could change the constructor to use Constructor Injection, but this may force you to changes to all constructor calls all over the place. Alternatively, you could just add a new constructor that takes the dependency, but then how does a developer easily know when to use one constructor over the other. Finally, if the dependency is very expensive to create, why should it be created and passed to the constructor when it may only be used rarely? \xe2\x80\x9cSetter Injection\xe2\x80\x9d is another DI technique that can be used in situations such as this.Setter Injection does not force dependencies to be passed to the constructor. Instead, the dependencies are set onto public properties exposed by the object in need. As implied previously, the primary motivators for doing this include:Here is the example of how the above code would look like:I think since everyone has written for DI, let me ask a few questions..This is based on the answer @Adam N posted.Why does PersonService no longer have to worry about GroupMembershipService? You just mentioned GroupMembership has multiple things(objects/properties) it depends on. If GMService was required in PService, you\'d have it as a property. You can mock that out regardless of whether you injected it or not. The only time I\'d like it to be injected is if GMService had more specific child classes, which you wouldn\'t know until runtime. Then you\'d want to inject the subclass. Or if you wanted to use that as either singleton or prototype. To be honest, the configuration file has everything hardcoded as far as what subclass for a type (interface) it is going to inject during compile time.  EDIT A nice comment by Jose Maria Arranz on DIDI increases cohesion by removing any need to determine the direction of dependency and write any glue code.False. The direction of dependencies is in XML form or as annotations, your dependencies are written as XML code and annotations. XML and annotations ARE source code.DI reduces coupling by making all of your components modular (i.e. replacable) and have well-defined interfaces to each other.False. You do not need a DI framework to build a modular code based on interfaces.About replaceable: with a very simple .properties archive and Class.forName you can define wich classes can change. If ANY class of your code can be changed, Java is not for you, use an scripting language.  By the way: annotations cannot be changed without recompiling.In my opinion there is one only reason for DI frameworks: boiler plate reduction. With a well done factory system you can do the same, more controlled and more predictable as your preferred DI framework, DI frameworks promise code reduction (XML and annotations are source code too). The problem is this boiler plate reduction is just real in very very simple cases (one instance-per class and similar), sometimes in the real world picking the appropriated service object is not as easy as mapping a class to a singleton object.Let\'s try simple example with Car and Engine classes, any car need an engine to go anywhere, at least for now. So below how code will look without dependency injection.And to instantiate the Car class we will use next code:The issue with this code that we tightly coupled to GasEngine and if we decide to change it to ElectricityEngine then we will need to rewrite Car class. And the bigger the application the more issues and headache we will have to add and use new type of engine. In other words with this approach is that our high level Car class is dependent on the lower level GasEngine class which violate Dependency Inversion Principle(DIP) from SOLID. DIP suggests that we should depend on abstractions, not concrete classes. So to satisfy this we introduce IEngine interface and rewrite code like below:Now our Car class is dependent on only the IEngine interface, not a specific implementation of engine. \nNow, the only trick is how do we create an instance of the Car and give it an actual concrete Engine class like GasEngine or ElectricityEngine. That\'s where Dependency Injection comes in. Here we basically inject(pass) our dependency(Engine instance) to Car constructor. So now our classes have loose coupling between objects and their dependencies, and we can easily add new types of engines without changing the Car class.The main benefit of the Dependency Injection that classes are more loosely coupled, because they do not have hard-coded dependencies. This follows the Dependency Inversion Principle, which was mentioned above. Instead of referencing specific implementations, classes request abstractions (usually interfaces) which are provided to them when the class is constructed.So in the end Dependency injection is just a technique for\n  achieving loose coupling between objects and their dependencies.\n  Rather than directly instantiating dependencies that class needs in\n  order to perform its actions, dependencies are provided to the class\n  (most often) via constructor injection.Also when we have many dependencies it is very good practice to use Inversion of Control(IoC) containers which we can tell which interfaces should be mapped to which concrete implementations for all our dependencies and we can have it resolve those dependencies for us when it constructs our object. For example, we could specify in the mapping for the IoC container that the IEngine dependency should be mapped to the GasEngine class and when we ask the IoC container for an instance of our Car class, it will automatically construct our Car class with a GasEngine dependency passed in. UPDATE: Watched course about EF Core from Julie Lerman recently and also liked her short definition about DI.Dependency injection is a pattern to allow your application to inject\n  objects on the fly to classes that need them, without forcing those\n  classes to be responsible for those objects. It allows your code to be\n  more loosely coupled, and Entity Framework Core plugs in to this same\n  system of services.Dependency Injection means a way (actually any-way) for one part of code (e.g a class) to have access to dependencies (other parts of code, e.g other classes, it depends upon) in a modular way without them being hardcoded (so they can change or be overriden freely, or even be loaded at another time, as needed)(and ps , yes it has become an overly-hyped 25$ name for a rather simple, concept), my .25 centsI know there are already many answers, but I found this very helpful: http://tutorials.jenkov.com/dependency-injection/index.html No Dependency:Dependency:Notice how the DataSourceImpl instantiation is moved into a constructor. The constructor takes four parameters which are the four values needed by the DataSourceImpl. Though the MyDao class still depends on these four values, it no longer satisfies these dependencies itself. They are provided by whatever class creating a MyDao instance.The popular answers are unhelpful, because they define dependency injection in a way that isn\'t useful. Let\'s agree that by "dependency" we mean some pre-existing other object that our object X needs. But we don\'t say we\'re doing "dependency injection" when we sayWe just call that passing parameters into the constructor. We\'ve been doing that regularly ever since constructors were invented."Dependency injection" is considered a type of "inversion of control", which means that some logic is taken out of the caller. That isn\'t the case when the caller passes in parameters, so if that were DI, DI would not imply inversion of control.DI means there is an intermediate level between the caller and the constructor which manages dependencies. A Makefile is a simple example of dependency injection. The "caller" is the person typing "make bar" on the command line, and the "constructor" is the compiler. The Makefile specifies that bar depends on foo, and it does abefore doing aThe person typing "make bar" doesn\'t need to know that bar depends on foo. The dependency was injected between "make bar" and gcc.The main purpose of the intermediate level is not just to pass in the dependencies to the constructor, but to list all the dependencies in just one place, and to hide them from the coder (not to make the coder provide them).Usually the intermediate level provides factories for the constructed objects, which must provide a role that each requested object type must satisfy. That\'s because by having an intermediate level that hides the details of construction, you\'ve already incurred the abstraction penalty imposed by factories, so you might as well use factories.Dependency injection is one possible solution to what could generally be termed the "Dependency Obfuscation" requirement. Dependency Obfuscation is a method of taking the \'obvious\' nature out of the process of providing a dependency to a class that requires it and therefore obfuscating, in some way, the provision of said dependency to said class. This is not necessarily a bad thing. In fact, by obfuscating the manner by which a dependency is provided to a class then something outside the class is responsible for creating the dependency which means, in various scenarios, a different implementation of the dependency can be supplied to the class without making any changes to the class. This is great for switching between production and testing modes (eg., using a \'mock\' service dependency).Unfortunately the bad part is that some people have assumed you need a specialized framework to do dependency obfuscation and that you are somehow a \'lesser\' programmer if you choose not to use a particular framework to do it. Another, extremely disturbing myth, believed by many, is that dependency injection is the only way of achieving dependency obfuscation. This is demonstrably and historically and obviously 100% wrong but you will have trouble convincing some people that there are alternatives to dependency injection for your dependency obfuscation requirements.Programmers have understood the dependency obfuscation requirement for years and many alternative solutions have evolved both before and after dependency injection was conceived. There are Factory patterns but there are also many options using ThreadLocal where no injection to a particular instance is needed - the dependency is effectively injected into the thread which has the benefit of making the object available (via convenience static getter methods) to any class that requires it without having to add annotations to the classes that require it and set up intricate XML \'glue\' to make it happen. When your dependencies are required for persistence (JPA/JDO or whatever) it allows you to achieve \'tranaparent persistence\' much easier and with domain model and business model classes made up purely of POJOs (i.e. no framework specific/locked in annotations).From the Book, \'Well-Grounded Java Developer: Vital techniques of Java 7 and polyglot programmingDI is a particular form of IoC, whereby the process of finding your dependencies is\n  outside the direct control of your currently executing code.Dependency Injection (DI) is one from Design Patterns, which uses the basic feature of OOP - the relationship in one object with another object. While inheritance inherits one object to do more complex and specific another object, relationship or association simply creates a pointer to another object from one object using attribute. The power of DI is in combination with other features of OOP as are interfaces and hiding code.\nSuppose, we have a customer (subscriber) in the library, which can borrow only one book for simplicity.Interface of book:Next we can have many kind of books; one of type is fiction:Now subscriber can have association to the book:All the three classes can be hidden for it\'s own implementation. Now we can use this code for DI:There are many different ways how to use dependency injection. It is possible to combine it with Singleton, etc., but still in basic it is only association realized by creating attribute of object type inside another object.\nThe usefulness is only and only in feature, that code, which we should write again and again is always prepared and done for us forward. This is why DI so closely binded with Inversion of Control (IoC) which means, that our program passes control another running module, which does injections of beans to our code. (Each object, which can be injected can be signed or considered as a Bean.) For example in Spring it is done by creating and initialization ApplicationContext container, which does this work for us. We simply in our code create the Context and invoke initialization the beans. In that moment injection has been done automatically.from Book Apress.Spring.Persistence.with.Hibernate.Oct.2010The purpose of dependency injection is to decouple the work of\n  resolving external software components from your application business\n  logic.Without dependency injection, the details of how a component\n  accesses required services can get muddled in with the component\xe2\x80\x99s\n  code. This not only increases the potential for errors, adds code\n  bloat, and magnifies maintenance complexities; it couples components\n  together more closely, making it difficult to modify dependencies when\n  refactoring or testing.In simple words dependency injection (DI) is the way to remove dependencies or tight coupling between different object. Dependency Injection gives a cohesive behavior to each object. DI is the implementation of IOC principal of Spring which says "Don\'t call us we will call you". Using dependency injection programmer doesn\'t need to create object using the new keyword. Objects are once loaded in Spring container and then we reuse them whenever we need them by fetching those objects from Spring container using getBean(String beanName) method.Dependency injection is the heart of the concept related with Spring Framework.While creating the framework of any project spring may perform a vital role,and here dependency injection come in pitcher.Actually,Suppose in java you created two different classes as class A and class B, and whatever the function are available in class B you want to use in class A, So at that time dependency injection can be used.\nwhere you can crate object of one class in other,in the same way you can inject an entire class in another class to make it accessible.\nby this way dependency can be overcome.DEPENDENCY INJECTION IS SIMPLY GLUING TWO CLASSES AND AT THE SAME TIME KEEPING THEM SEPARATE.Dependency Injection (DI) is part of Dependency Inversion Principle (DIP) practice, which is also called Inversion of Control (IoC). Basically you need to do DIP because you want to make your code more modular and unit testable, instead of just one monolithic system. So you start identifying parts of the code that can be separated from the class and abstracted away. Now the implementation of the abstraction need to be injected from outside of the class. Normally this can be done via constructor. So you create a constructor that accepts the abstraction as a parameter, and this is called dependency injection (via constructor). For more explanation about DIP, DI, and IoC container you can read HereDependency Injection is a type of implementation of the "Inversion of Control" principle on which is based Frameworks building.Frameworks as stated in "Design Pattern" of GoF are classes that implement the main control flow logic raising the developer to do that, in this way Frameworks realize the inversion of control principle.A way to implement as a technique, and not as class hierarchy, this IoC principle it is just Dependency Injection.DI consists mainly into delegate the mapping of classes instances and type reference to that instances, to an external "entity": an object, static class, component, framework, etc... Classes instances are the "dependencies", the external binding of the calling component with the class instance through the reference it is the "injection".Obviously you can implement this technique in many way as you want from OOP point of view, see for example constructor injection, setter injection, interface injection.Delegating a third party to carry out the task of match a ref to an object it is very useful when you want to completely separate a component that needs some services from the same services implementation. In this way, when designing components, you can focus exclusively on their architecture and their specific logic, trusting on interfaces for collaborating with other objects without worry about any type of implementation changes of objects/services used, also if the same object you are using will be totally replaced (obviously respecting the interface).Any nontrivial application is made up of two or more classes that collaborate with each other to perform some business logic. Traditionally, each object is responsible for obtaining its own references to the objects it collaborates with (its dependencies). When applying DI, the objects are given their dependencies at creation time by some external entity that coordinates each object in the system. In other words, dependencies are injected into objects.For further details please see enter link description hereHere is a great example explanation of dependency injections: Guice docs