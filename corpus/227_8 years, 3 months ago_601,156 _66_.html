How do I write a switch statement in Ruby?Ruby uses the case expression instead.The comparison is done by comparing the object in the when-clause with the object in the case-clause using the === operator. That is, it does 1..5 === a and String === a, not a === 1..5. This allows for the sophisticated semantics you see above, where you can use ranges and classes and all sorts of things rather than just testing for equality.You can check more of the same from Ruby case SO Documentationcase...when behaves a bit unexpectedly when handling classes. This is due to the fact that it uses the === operator.That operator works as expected with literals, but not with classes:This means that if you want to do a case ... when over an object\'s class, this will not work:Will print "It is not a string".Fortunately, this is easily solved. The === operator has been defined so that it returns true if you use it with a class and supply an instance of that class as the second operand:In short, the code above can be fixed by removing the .class:I hit this problem today while looking for an answer, and this was the first appearing page, so I figured it would be useful to others in my same situation.It is done by case in Ruby. Also see this article on Wikipedia.Quoted:Another example:On around page 123 (I am using Kindle) of The Ruby Programming Lanugage (1st Edition, O\'Reilly), it says the then keyword following the when clauses can be replaced with a newline or semicolon (just like in the if then else syntax). (Ruby 1.8 also allows a colon in place of then... But this syntax is no longer allowed in Ruby 1.9.)To add more examples to Chuck\'s answer:With parameter:Without parameter:Please, be aware of the issue that kikito warns.In Ruby 2.0, you can also use lambdas in case statements, as follows:You can also create your own comparators easily using a Struct with a custom ===(Example taken from "Can procs be used with case statements in Ruby 2.0?".)Or, with a complete class:(Example taken from "How A Ruby Case Statement Works And What You Can Do With It".)Many programming languages, especially those derived from C, have support for the so-called Switch Fallthrough. I was searching for the best way to do the same in Ruby and thought it might be useful to others:In C-like languages fallthrough typically looks like this:In Ruby, the same can be achieved in the following way:This is not strictly equivalent, because it\'s not possible to let \'a\' execute a block of code before falling through to \'b\' or \'c\', but for the most part I find it similar enough to be useful in the same way.You can use regular expressions, such as finding a type of string:Ruby\'s case will use the equality operand === for this (thanks @JimDeville). Additional information is available at "Ruby Operators". This also can be done using @mmdemirbas example (without parameter), only this approach is cleaner for these types of cases.If you are eager to know how to use an OR condition in a Ruby switch case:So, in a case statement, a , is the equivalent of || in an if statement.Many other things you can do with a Ruby case statementIt\'s called case and it works like you would expect, plus lots more fun stuff courtesy of === which implements the tests.Now for some fun:And it turns out you can also replace an arbitrary if/else chain (that is, even if the tests don\'t involve a common variable) with case by leaving out the initial case parameter and just writing expressions where the first match is what you want.Since switch case always returns a single object, we can directly print its result:Multi-value when and no-value case:And a regular expression solution here:Depending on your case, you could prefer to use a hash of methods.If there is a long list of when\'s and each of them has a concrete value to compare with (not an interval), it will be more effective to declare a hash of methods and then to call the relevant method from the hash like that.Ruby uses the case for writing switch statements.As per the Ruby Docs:Case statements consist of an optional condition, which is in the\n  position of an argument to case, and zero or more when clauses.\n  The first when clause to match the condition (or to evaluate to\n  Boolean truth, if the condition is null) \xe2\x80\x9cwins\xe2\x80\x9d, and its code stanza\n  is executed. The value of the case statement is the value of the\n  successful when clause, or nil if there is no such clause.A case statement can end with an else clause. Each when a\n  statement can have multiple candidate values, separated by commas.Example:Shorter version:And as this blog by Honeybadger describes Ruby Case;Can be used with Ranges:Can be used with Regex:Can be used with Procs and Lambdas:Also, can be used with your own match classes:You can write case expressions in two different ways in ruby.Lots of great answers but I thought I would add one factoid.. If you are attempting to compare objects (Classes) make sure you have a space ship method (not a joke) or understand how they are being comparedHere is a good discussion on the topic\nhttp://www.skorks.com/2009/09/ruby-equality-and-object-comparison/You can do like this in more natural way,As stated in many of the above answers, the === operator is used under the hood on case/when statements. Here is a few extra information about that operator.Many of Ruby\'s built-in classes, such as String, Range, and Regexp, provide their own implementations of the === operator, also known as case-equality, triple equals or threequals. Because it\'s implemented differently in each class, it will behave differently depending on the type of object it was called on. Generally, it returns true if the object on the right "belongs to" or "is a member of" the object on the left. For instance, it can be used to test if an object is an instance of a class (or one of its subclasses).The same result can be achieved with other methods which are probably best suited for the job, such as is_a? and instance_of?.When the === operator is called on a range object, it returns true if the value on the right falls within the range on the left.Remember that the === operator invokes the === method of the left-hand object. So (1..4) === 3 is equivalent to (1..4).=== 3. In other words, the class of the left-hand operand will define which implementation of the === method will be called, so the operand positions are not interchangeable. Returns true if the string on the right matches the regular expression on the left.\n    /zen/ === "practice zazen today"  # Output: => true\n    # is similar to\n    "practice zazen today"=~ /zen/The only relevant difference between the two examples above is that, when there is a match, === returns true and =~ returns an integer, which is a truthy value in Ruby. We will get back to this soon.I\'ve started to use:It helps compact code in some cases.