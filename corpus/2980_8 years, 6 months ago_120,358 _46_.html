This question already has an answer here:With git rebase --interactive <commit> you can squash any number of commits together into a single one.That\'s all great unless you want to squash commits into the initial commit. That seems impossible to do.Are there any ways to achieve it?In a related question, I managed to come up with a different approach to the need of squashing against the first commit, which is, well, to make it the second one.If you\'re interested: git: how to insert a commit as the first, shifting all the others?Update July 2012 (git 1.7.12+)You now can rebase all commits up to root, and select the second commit Y to be squashed with the first X.This command can now be used to rewrite all the history leading from "$tip" down to the root commit.See commit df5df20c1308f936ea542c86df1e9c6974168472 on GitHub from Chris Webb (arachsys).Original answer (February 2009)I believe you will find different recipes for that in the SO question "How do I combine the first two commits of a git repository?"Charles Bailey provided there the most detailed answer, reminding us that a commit is a full tree (not just diffs from a previous states).\nAnd here the old commit (the "initial commit") and the new commit (result of the squashing) will have no common ancestor.\nThat mean you can not "commit --amend" the initial commit into new one, and then rebase onto the new initial commit the history of the previous initial commit (lots of conflicts)(That last sentence is no longer true with git rebase -i --root <aBranch>)Rather (with A the original "initial commit", and B a subsequent commit needed to be squashed into the initial one):Go back to the last commit that we want to form the initial commit (detach HEAD):Reset the branch pointer to the initial commit, but leaving the index and working tree intact:Amend the initial tree using the tree from \'B\':Temporarily tag this new initial commit (or you could remember the new commit sha1 manually):Go back to the original branch (assume master for this example):Replay all the commits after B onto the new initial commit:Remove the temporary tag:That way, the "rebase --onto" does not introduce conflicts during the merge, since it rebases history made after the last commit (B) to be squashed into the initial one (which was A) to tmp (representing the squashed new initial commit): trivial fast-forward merges only.  That works for "A-B", but also "A-...-...-...-B" (any number of commits can be squashed into the initial one this way)I\'ve reworked VonC\'s script to do everything automatically and not ask me for anything. You give it two commit SHA1s and it will squash everything between them into one commit named "squashed history":For what it\'s worth, I avoid this problem by always creating a "no-op" first commit, in which the only thing in the repository is an empty .gitignore:https://github.com/DarwinAwardWinner/git-custom-commands/blob/master/bin/git-myinitThat way, there\'s never any reason to mess with the first commit.This will squash second commit into the first one:A-B-C-... -> AB-C-...Commit message for AB will be taken from B (although I\'d prefer from A).Has the same effect as Uwe Kleine-K\xc3\xb6nig\'s answer, but works for non-initial A as well.If you simply want to squash all commits into a single, initial commit, just reset the repository and amend the first commit:Git reset will leave the working tree intact, so everything is still there. So just add the files using git add commands, and amend the first commit with these changes. Compared to rebase -i you\'ll lose the ability to merge the git comments though.Squashing the first and second commit would result in the first commit being rewritten. If you have more than one branch that is based off the first commit, you\'d cut off that branch.Consider the following example:Squashing a and b into a new commit "ab" would result in two distinct trees which in most cases is not desirable since git-merge and git-rebase will no longer work across the two branches.If you really want this, it can be done. Have a look at git-filter-branch for a powerful (and dangerous) tool for history rewriting.You can use git filter-branch for that.  e.g.This results in AB-C throwing away the commit log of A.You could use rebase interactive to modify the last two commits before they\'ve been pushed to a remoteThere is an easier way to do this.  Let\'s assume you\'re on the master branchCreate a new orphaned branch which will remove all commit history:Add your initial commit message:Get rid of the old unmerged master branch:Rename your current branch new_branch to master: