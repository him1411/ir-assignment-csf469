I know that Java enums are compiled to classes with private constructors and a bunch of public static members. When comparing two members of a given enum, I\'ve always used .equals(), e.g.However, I just came across come code that uses the equals operator == instead:Which operator is the one I should be using?Both are technically correct. If you look at the source code for .equals(), it simply defers to ==.I use ==, however, as that will be null safe.Yes: enums have tight instance controls that allows you to use == to compare instances. Here\'s the guarantee provided by the language specification:An enum type has no instances other than those defined by its enum constants. It is a compile-time error to attempt to explicitly instantiate an enum type. The final clone method in Enum ensures that enum constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization. Reflective instantiation of enum types is prohibited. Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants.Because there is only one instance of each enum constant, it is permissible to use the == operator in place of the equals method when comparing two object references if it is known that at least one of them refers to an enum constant. (The equals method in Enum is a final method that merely invokes super.equals on its argument and returns the result, thus performing an identity comparison.)This guarantee is strong enough that Josh Bloch recommends, that if you insist on using the singleton pattern, the best way to implement it is to use a single-element enum (see: Effective Java 2nd Edition, Item 3: Enforce the singleton property with a private constructor or an enum type; also Thread safety in Singleton)As a reminder, it needs to be said that generally, == is NOT a viable alternative to equals. When it is, however (such as with enum), there are two important differences to consider:Bloch specifically mentions that immutable classes that have proper control over their instances can guarantee to their clients that == is usable. enum is specifically mentioned to exemplify.Item 1: Consider static factory methods instead of constructors[...] it allows an immutable class to make the guarantee that no two equal instances exist: a.equals(b) if and only if a==b. If a class makes this guarantee, then its clients can use the == operator instead of the equals(Object) method, which may result in improved performance. Enum types provide this guarantee.To summarize, the arguments for using == on enum are:Using == to compare two enum values works because there is only one object for each enum constant.On a side note, there is actually no need to use == to write null safe code if you write your equals() like this:This is a best practice known as Compare Constants From The Left that you definitely should follow.As others have said, both == and .equals() work in most cases. The compile time certainty that you\'re not comparing completely different types of Objects that others have pointed out is valid and beneficial, however the particular kind of bug of comparing objects of two different compile time types would also be found by FindBugs (and probably by Eclipse/IntelliJ compile time inspections), so the Java compiler finding it doesn\'t add that much extra safety.However:I actually think that the Java language should have defined == on Objects to call .equals() on the left hand value, and introduce a separate operator for object identity, but that\'s not how Java was defined.In summary, I still think the arguments are in favor of using .equals() for enum types. Here is a crude timing test to compare the two:Comment out the IFs one at a time. Here are the two compares from above in disassembled byte-code:The first (equals) performs a virtual call and tests the return boolean from the stack. The second (==) compares the object addresses directly from the stack. In the first case there is more activity.I ran this test several times with both IFs one at a time. The "==" is ever so slightly faster.In case of enum both are correct and right!!I prefer to use == instead of equals:Other reason, in addition to the others already discussed here, is you could introduce a bug without realizing it. Suppose you have this enums which is exactly the same but in separated pacakges (it\'s not common, but it could happen):First enum:Second enum:Then suppose you use the equals like next in item.category which is first.pckg.Category but you import the second enum (second.pckg.Category) instead the first without realizing it:So you will get allways false due is a different enum although you expect true because item.getCategory() is JAZZ. And it could be be a bit difficult to see.So, if you instead use the operator == you will have a compilation error:operator == cannot be applied to "second.pckg.Category", "first.pckg.Category"Using anything other than == to compare enum constants is nonsense. It\'s like comparing class objects with equals \xe2\x80\x93 don\'t do it!However, there was a nasty bug (BugId 6277781) in Sun JDK 6u10 and earlier that might be interesting for historical reasons. This bug prevented proper use of == on deserialized enums, although this is arguably somewhat of a corner case.Enums are classes that return one instance (like singletons) for each enumeration constant declared by public static final field (immutable) so that == operator could be used to check their equality rather than using equals() methodI want to complement polygenelubricants answer:I personally prefer equals(). But it lake the type compatibility check. Which I think is an important limitation.To have type compatibility check at compilation time, declare and use a custom function in your enum.With this, you got all the advantage of both solution: NPE protection, easy to read code and type compatibility check at compilation time.I also recommend to add an UNDEFINED value for enum.In short, both have pros and cons.On one hand, it has advantages to use ==, as described in the other answers.On the other hand, if you for any reason replace the enums with a different approach (normal class instances), having used == bites you. (BTDT.)I would like to explicitly highlight this specific difference between the == operator and equals() method:The equals() method is meant to check whether the contents of the object(s) the reference variable(s) involved refer(s) to are the same.The == operator checks whether the reference variable(s) involved refer(s) to the same object.It\'s up to the implementing class to provide this differentiation as needed by the application. Otherwise the default behavior will be as provided by the Object class (in Java) where as explained in http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html#equals(java.lang.Object):The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). 