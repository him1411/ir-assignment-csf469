I would like to inject a Mockito mock object into a Spring (3+) bean for the purposes of unit testing with JUnit. My bean dependencies are currently injected by using the @Autowired annotation on private member fields.I have considered using ReflectionTestUtils.setField but the bean instance that I wish to inject is actually a proxy and hence does not declare the private member fields of the target class. I do not wish to create a public setter to the dependency as I will then be modifying my interface purely for the purposes of testing.I have followed some advice given by the Spring community but the mock does not get created and the auto-wiring fails:The error I currently encounter is as follows:If I set the constructor-arg value to something invalid no error occurs when starting the application context.The best way is:Update\nIn the context file this mock must be listed before any autowired field depending on it is declared.This will inject any mocked objects in the test class, so in this case it will inject mockedObject in testObject. This was mentioned above but here is the code.I have a very simple solution using Spring Java Config and Mockito:Given:You can have the class that is being tested loaded via autowiring, mock the dependency with Mockito, and then use Spring\'s ReflectionTestUtils to inject the mock into the class being tested.Please note that before Spring 4.3.1, this method won\'t work with services behind a proxy (annotated with @Transactional, or Cacheable, for example). This has been fixed by SPR-14050.For earlier versions, a solution is to unwrap the proxy, as described there: https://stackoverflow.com/a/17548683/5138796 (which is what ReflectionTestUtils.setField does by default now)If you\'re using Spring Boot 1.4, it has an awesome way of doing this. Just use new brand @SpringBootTest on your class and @MockBean on the field  and Spring Boot will create a mock of this type and it will inject it into the context (instead of injecting the original one):On the other hand, if you\'re not using Spring Boot or are you using a previous version, you\'ll have to do a bit more work:    Create a @Configuration bean that injects your mocks into Spring context:Using @Primary annotation you\'re telling spring that this bean has priority if no qualifier are specified.Make sure you annotate the class with @Profile("useMocks") in order to control which classes will use the mock and which ones will use the real bean.Finally, in your test, activate userMocks profile:If you don\'t want to use the mock but the real bean, just don\'t activate useMocks profile:Since 1.8.3 Mockito has @InjectMocks - this is incredibly useful. My JUnit tests are @RunWith the MockitoJUnitRunner and I build @Mock objects that satisfy all the dependencies for the class being tested, which are all injected when the private member is annotated with @InjectMocks.I @RunWith the SpringJUnit4Runner for integration tests only now.I will note that it does not seem to be able to inject List in the same manner as Spring. It looks only for a Mock object that satisfies the List, and will not inject a list of Mock objects. The workaround for me was to use a @Spy against a manually instantiated list, and manually .add the mock object(s) to that list for unit testing. Maybe that was intentional, because it certainly forced me to pay close attention to what was being mocked together.Update: There are now better, cleaner solutions to this problem. Please consider the other answers first.I eventually found an answer to this by ronen on his blog. The problem I was having is due to the method Mockito.mock(Class c) declaring a return type of Object. Consequently Spring is unable to infer the bean type from the factory method return type.Ronen\'s solution is to create a FactoryBean implementation that returns mocks. The FactoryBean interface allows Spring to query the type of objects created by the factory bean.My mocked bean definition now looks like:As of Spring 3.2, this is no longer an issue.  Spring now supports Autowiring of the results of generic factory methods.  See the section entitled "Generic Factory Methods" in this blog post: http://spring.io/blog/2012/11/07/spring-framework-3-2-rc1-new-testing-features/.The key point is: In Spring 3.2, generic return types for factory methods are now\n  properly inferred, and autowiring by type for mocks should work as\n  expected. As a result, custom work-arounds such as a\n  MockitoFactoryBean, EasyMockFactoryBean, or Springockito are likely no\n  longer necessary.Which means this should work out of the box:Below code works with autowiring - it is not the shortest version but useful when it should work only with standard spring/mockito jars.If you\'re using spring >= 3.0, try using Springs @Configuration annotation to define part of the application contextIf you don\'t want to use the @ImportResource, it can be done the other way around too:For more information, have a look at http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-javaI can do the following using Mockito:Perhaps not the perfect solution, but I tend not to use spring to do DI for unit tests. the dependencies for a single bean (the class under test) usually aren\'t overly complex so I just do the injection directly in the test code.Posting a few examples based on the above approachesWith Spring:Without Spring:Update - new answer here: https://stackoverflow.com/a/19454282/411229.  This answer only applies to those on Spring versions before 3.2.I\'ve looked for a while for a more definitive solution to this.  This blog post seems to cover all my needs and doesn\'t rely on ordering of bean declarations.  All credit to Mattias Severson.  http://www.jayway.com/2011/11/30/spring-integration-tests-part-i-creating-mock-objects/Basically, implement a FactoryBeanNext update your spring config with the following:Looking at Springockito pace of development and number of open issues, I would be little bit worried to introduce it into my test suite stack nowadays. Fact that last release was done before Spring 4 release brings up questions like "Is it possible to easily integrate it with Spring 4?". I don\'t know, because I didn\'t try it. I prefer pure Spring approach if I need to mock Spring bean in integration test.There is an option to fake Spring bean with just plain Spring features. You need to use @Primary, @Profile and @ActiveProfiles annotations for it. I wrote a blog post on the topic.I found a similar answer as teabot to create a MockFactory that provides the mocks. I used the following example to create the mock factory (since the link to narkisr are dead):\nhttp://hg.randompage.org/java/src/407e78aa08a0/projects/bookmarking/backend/spring/src/test/java/org/randompage/bookmarking/backend/testUtils/MocksFactory.javaThis also helps to prevent that Spring wants to resolve the injections from the mocked bean.this ^ works perfectly well if declared first/early in the XML file. Mockito 1.9.0/Spring 3.0.5I use a combination of the approach used in answer by Markus T and a simple helper implementation of ImportBeanDefinitionRegistrar that looks for a custom annotation (@MockedBeans) in which one can specify which classes are to be mocked. I believe that this approach results in a concise unit test with some of the boilerplate code related to mocking removed.Here\'s how a sample unit test looks with that approach:To make this happen you need to define two simple helper classes - custom annotation (@MockedBeans) and a custom \nImportBeanDefinitionRegistrar implementation. @MockedBeans annotation definition needs to be annotated with @Import(CustomImportBeanDefinitionRegistrar.class) and the ImportBeanDefinitionRgistrar needs to add mocked beans definitions to the configuration in it\'s registerBeanDefinitions method.If you like the approach you can find sample implementations on my blogpost. I developed a solution based on the proposal of Kresimir Nesek. I added a new annotation @EnableMockedBean in order to make the code a bit cleaner and modular.I have written a post explaining it.I would suggest to migrate your project to Spring Boot 1.4. After that you can use new annotation @MockBean to fake your com.package.DaoToday I found out that a spring context where I declared a  before the Mockito  beans, was failing to load. \nAfter moving the  AFTER the mocks, the app context was loaded successfully. \nTake care :)For the record, all my tests correctly work by just making the fixture lazy-initialized, e.g.:I suppose the rationale is the one Mattias explains here (at the bottom of the post), that a workaround is changing the order the beans are declared - lazy initialization is "sort of" having the fixture declared at the end.If you use Controller Injection, make sure your local variables are NOT "final"