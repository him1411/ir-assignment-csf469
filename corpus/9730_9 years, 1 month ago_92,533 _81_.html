I took a look at the "Beginner\'s Guide to LINQ" post here on StackOverflow (Beginners Guide to LINQ), but had a follow-up question:We\'re about to ramp up a new project where nearly all of our database op\'s will be fairly simple data retrievals (there\'s another segment of the project which already writes the data). Most of our other projects up to this point make use of stored procedures for such things. However, I\'d like to leverage LINQ-to-SQL if it makes more sense.So, the question is this: For simple data retrievals, which approach is better, LINQ-to-SQL or stored procs? Any specific pro\'s or con\'s?Thanks.Some advantages of LINQ over sprocs:Some disadvantages of LINQ vs sprocs:Security and manageability are something that people argue about too.I used to be a big sproc guy, but I\'m starting to lean towards LINQ as a better alternative in general.  If there are some areas where sprocs are clearly better, then I\'ll probably still write a sproc but access it using LINQ. :)I am generally a proponent of putting everything in stored procedures, for all of the reasons DBAs have been harping on for years.  In the case of Linq, it is true that there will be no performance difference with simple CRUD queries.But keep a few things in mind when making this decision: using any ORM couples you tightly to your data model.  A DBA has no freedom to make changes to the data model without forcing you to change your compiled code.  With stored procedures, you can hide these sorts of changes to an extent, since the parameter list and results set(s) returned from a procedure represent its contract, and the innards can be changed around, just so long as that contract is still met.And also, if Linq is used for more complex queries, tuning the database becomes a much more difficult task.  When a stored procedure is running slow, the DBA can totally focus on the code in isolation, and has lots of options, just so that contract is still satisfied when he/she is done.I have seen many, many cases where serious problems in an application were addressed by changes to the schema and code in stored procedures without any change to deployed, compiled code.Perhaps a hybird approach would be nice with Linq?  Linq can, of course, be used to call stored procedures.Linq to Sql.Sql server will cache the query plans, so there\'s no performance gain for sprocs.Your linq statements, on the other hand, will be logically part of and tested with your application.  Sprocs are always a bit separated and are harder to maintain and test.If I was working on a new application from scratch right now I would just use Linq, no sprocs.For basic data retrieval I would be going for Linq without hesitation.Since moving to Linq I\'ve found the following advantages:LINQ will bloat the procedure cacheIf an application is using LINQ to SQL and the queries involve the use of strings that can be highly variable in length, the SQL Server procedure cache will become bloated with one version of the query for every possible string length. For example, consider the following very simple queries created against the Person.AddressTypes table in the AdventureWorks2008 database:If both of these queries are run, we will see two entries in the SQL Server procedure cache: One bound with an NVARCHAR(7), and the other with an NVARCHAR(11). Now imagine if there were hundreds or thousands of different input strings, all with different lengths. The procedure cache would become unnecessarily filled with all sorts of different plans for the exact same query. More here: https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=363290I think the pro LINQ argument seems to be coming from people who don\'t have a history with database development (in general).Especially if using a product like VS DB Pro or Team Suite, many of the arguments made here do not apply, for instance:Harder to maintain and Test:\nVS provides full syntax checking, style checking, referential and constraint checking and more. It also provide full unit testing capabilities and refactoring tools.LINQ makes true unit testing impossible as (in my mind) it fails the ACID test.Debugging is easier in LINQ:\nWhy? VS allows full step-in from managed code and regular debugging of SPs.Compiled into a single DLL rather than deployment scripts:\nOnce again, VS comes to the rescue where it can build and deploy full databases or make data-safe incremental changes.Don\'t have to learn TSQL with LINQ:\nNo you don\'t, but you have to learn LINQ - where\'s the benefit?I really don\'t see this as being a benefit. Being able to change something in isolation might sound good in theory, but just because the changes fulfil a contract doesn\'t mean it\'s returning the correct results. To be able to determine what the correct results are you need context and you get that context from the calling code.Um, loosely coupled apps are the ultimate goal of all good programmers as they really do increase flexibility. Being able to change things in isolation is fantastic, and it is your unit tests that will ensure it is still returning appropriate results.Before you all get upset, I think LINQ has its place and has a grand future. But for complex, data-intensive applications I do not think it is ready to take the place of stored procedures. This was a view I had echoed by an MVP at TechEd this year (they will remain nameless).EDIT: The LINQ to SQL Stored Procedure side of things is something I still need to read more on - depending on what I find I may alter my above diatribe ;)LINQ is new and has its place. LINQ is not invented to replace stored procedure. Here I will focus on some performance myths & CONS, just for "LINQ to SQL", of course I might be totally wrong ;-)(1)People say LINQ statment can "cache" in SQL server, so it doesn\'t lose performance. Partially true. "LINQ to SQL" actually is the runtime translating LINQ syntax to TSQL statment. So from the performance perspective,a hard coded ADO.NET SQL statement has no difference than LINQ. (2)Given an example, a customer service UI has a "account transfer" function. this function itself might update 10 DB tables and return some messages in one shot. With LINQ, you have to build a set of statements and send them as one batch to SQL server. the performance of this translated LINQ->TSQL batch can hardly match stored procedure. Reason? because you can tweak the smallest unit of the statement in Stored procedue by using the built-in SQL profiler and execution plan tool, you can not do this in LINQ.The point is, when talking single DB table and small set of data CRUD, LINQ is as fast as SP. But for much more complicated logic, stored procedure is more performance tweakable.(3)"LINQ to SQL" easily makes newbies to introduce performance hogs. Any senior TSQL guy can tell you when not to use CURSOR (Basically you should not use CURSOR in TSQL in most cases). With LINQ and the charming "foreach" loop with query, It\'s so easy for a newbie to write such code:You can see this easy decent code is so attractive. But under the hood, .NET runtime just translate this to an update batch. If there are only 500 lines, this is 500 line TSQL batch; If there are million lines, this is a hit. Of course, experienced user won\'t use this way to do this job, but the point is, it\'s so easy to fall in this way.The best code is no code, and with stored procedures you have to write at least some code in the database and code in the application to call it , whereas with LINQ to SQL or LINQ to Entities, you don\'t have to write any additional code beyond any other LINQ query aside from instantiating a context object. LINQ definitely has its place in application-specific databases and in small businesses.But in a large enterprise, where central databases serve as a hub of common data for many applications, we need abstraction. We need to centrally manage security and show access histories. We need to be able to do impact analysis: if I make a small change to the data model to serve a new business need, what queries need to be changed and what applications need to be re-tested? Views and Stored Procedures give me that. If LINQ can do all that, and make our programmers more productive, I\'ll welcome it -- does anyone have experience using it in this kind of environment?A DBA has no freedom to make changes\n  to the data model without forcing you\n  to change your compiled code. With\n  stored procedures, you can hide these\n  sorts of changes to an extent, since\n  the parameter list and results set(s)\n  returned from a procedure represent\n  its contract, and the innards can be\n  changed around, just so long as that\n  contract is still met.I really don\'t see this as being a benefit. Being able to change something in isolation might sound good in theory, but just because the changes fulfil a contract doesn\'t mean it\'s returning the correct results. To be able to determine what the correct results are you need context and you get that context from the calling code.IMHO, RAD = LINQ, RUP = Stored Procs.  I worked for a large Fortune 500 company for many years, at many levels including management, and frankly, I would never hire RUP developers to do RAD development.  They are so siloed that they very limited knowledge of what to do at other levels of the process.  With a siloed environment, it makes sense to give DBAs control over the data through very specific entry points, because others frankly don\'t know the best ways to accomplish data management.But large enterprises move painfully slow in the development arena, and this is extremely costly. There are times when you need to move faster to save both time and money, and LINQ provides that and more in spades.Sometimes I think that DBAs are biased against LINQ because they feel it threatens their job security.  But that\'s the nature of the beast, ladies and gentlemen.I think you need to go with procs for anything real.A) Writing all your logic in linq means your database is less useful because only your application can consume it.B) I\'m not convinced that object modelling is better than relational modelling anyway.C) Testing and developing a stored procedure in SQL is a hell of a lot faster than a compile edit cycle in any Visual Studio environment.  You just edit, F5 and hit select and you are off to the races.D) It\'s easier to manage and deploy stored procedures than assemblies.. you just put the file on the server, and press F5...E) Linq to sql still writes crappy code at times when you don\'t expect it.Honestly, I think the ultimate thing would be for MS to augment t-sql so that it can do a join projection impliclitly the way linq does.  t-sql should know if you wanted to do order.lineitems.part, for example.LINQ doesn\'t prohibit the use of stored procedures. I\'ve used mixed mode with LINQ-SQL and LINQ-storedproc. Personally, I\'m glad I don\'t have to write the stored procs....pwet-tu.Also there is the issue of possible 2.0 rollback. Trust me it has happened to me a couple times so I am sure it has happened to others.I also agree that abstraction is best. Along with the fact the the original purpose of any ORM is to make RDBMS match up nicely to the OO concepts. However if everything worked fine before LINQ by having to deviate a bit from OO concepts then screw \'em. Concepts and reality don\'t always fit well together. There is no room for militant zealots in IT.I\'m assuming you mean Linq To SqlFor any CRUD command it\'s easy to profile the performance of a stored procedure vs. any technology. In this case any difference between the two will be negligible. Try profiling for a 5 (simple types) field object over 100,000 select queries to find out if there\'s a real difference.On the other hand the real deal-breaker will be the question on whether you feel comfortable putting your business logic on your database or not, which is an argument against stored procedures.According to gurus, I define LINQ as motorcycle and SP as car.\nIf you want to go for a short trip and only have small passengers(in this case 2), go gracefully with LINQ.\nBut if you want to go for a journey and have large band, i think you should choose SP.As a conclusion, choosing between motorcycle or car is depend on your route (business), length (time), and passengers (data).Hope it helps, I may be wrong. :DAll these answers leaning towards LINQ are mainly talking about EASE of DEVELOPMENT which is more or less connected to poor quality of coding or laziness in coding. I am like that only. Some advantages or Linq, I read here as , easy to test, easy to debug etc, but these are no where connected to Final output or end user. This is always going cause the trouble the end user on performance. Whats the point loading many things in memory and then applying filters on in using LINQ? Again TypeSafety, is caution that "we are careful to avoid wrong typecasting" which again poor quality we are trying to improve by using linq. Even in that case, if anything in database changes, e.g. size of String column, then linq needs to be re-compiled and would not be typesafe without that .. I tried.Although, we found is good, sweet, interesting etc while working with LINQ, it has shear disadvantage of making developer lazy :) and it is proved 1000 times that it is bad (may be worst) on performance compared to Stored Procs.Stop being lazy. I am trying hard. :)Stored Procs vs Code (Previous discussion)For simple CRUD operations with a single data access point, I would say go for LINQ if you feel comfortable with the syntax. For more complicated logic I think sprocs are more efficiant performance-wise if you are good at T-SQL and its more advanced operations. You also have the help from Tuning Advisor, SQL Server Profiler, debugging your queries from SSMS etc. Stored procedure makes testing easier and you can change the query without touching the application code. Also with linq, getting a data does not mean its the right data. And testing the correctness of the data means running the application but with stored procedure it\'s easy to test without touching the application.The outcome can be summarized as LinqToSql for small sites, and prototypes. It really saves time for Prototyping.Sps : Universal. I can fine tune my queries and always check ActualExecutionPlan / EstimatedExecutionPlan.http://www.totaldotnet.com/Article/ShowArticle121_StoreProcBasic.aspxBoth LINQ and SQL have their places. Both have their disadvantages and advantages.Sometimes for complex data retrieval you might need stored procs. And sometimes you may want other people to use your stored proc in Sql Server Management Studio.Linq to Entities is great for fast CRUD development.Sure you can build an app using only one or the other. Or you can mix it up. It all comes down to your requirements. But SQL stored procs will no go away any time soon.