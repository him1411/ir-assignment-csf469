How do I check whether the remote repository has changed and I need to pull?Now I use this simple script:But it is rather heavy.Is there a better way? The ideal solution would check all the remote branches, and return names of the changed branches and the number of new commits in each one.First use git remote update, to bring your remote refs up to date. Then you can do one of several things, such as:git status -uno will tell you whether the branch you are tracking is ahead, behind or has diverged. If it says nothing, the local and remote are the same.git show-branch *master will show you the commits in all of the branches whose names end in \'master\' (eg master and origin/master).If you use -v with git remote update (git remote -v update) you can see which branches got updated, so you don\'t really need any further commands.However, it looks like you want to do this in a script or program and end up with a true/false value. If so, there are ways to check the relationship between your current HEAD commit and the head of the branch you\'re tracking, although since there are four possible outcomes you can\'t reduce it to a yes/no answer. However, if you\'re prepared to do a pull --rebase then you can treat "local is behind" and "local has diverged" as "need to pull", and the other two as "don\'t need to pull".You can get the commit id of any ref using git rev-parse <ref>, so you can do this for master and origin/master and compare them. If they\'re equal, the branches are the same. If they\'re unequal, you want to know which is ahead of the other. Using git merge-base master origin/master will tell you the common ancestor of both branches, and if they haven\'t diverged this will be the same as one or the other. If you get three different ids, the branches have diverged.To do this properly, eg in a script, you need to be able to refer to the current branch, and the remote branch it\'s tracking. The bash prompt-setting function in /etc/bash_completion.d has some useful code for getting branch names. However, you probably don\'t actually need to get the names. Git has some neat shorthands for referring to branches and commits (as documented in git rev-parse --help). In particular, you can use @ for the current branch (assuming you\'re not in a detached-head state) and @{u} for its upstream branch (eg origin/master). So git merge-base @ @{u} will return the (hash of) the commit at which the current branch and its upstream diverge and git rev-parse @ and git rev-parse @{u} will give you the hashes of the two tips. This can be summarized in the following script:Note: older versions of git didn\'t allow @ on its own, so you may have to use @{0} instead.The line UPSTREAM=${1:-\'@{u}\'} allows you optionally to pass an upstream branch explicitly, in case you want to check against a different remote branch than the one configured for the current branch. This would typically be of the form remotename/branchname. If no parameter is given, the value defaults to @{u}.The script assumes that you\'ve done a git fetch or git remote update first, to bring the tracking branches up to date. I didn\'t build this into the script because it\'s more flexible to be able to do the fetching and the comparing as separate operations, for example if you want to compare without fetching because you already fetched recently.Compare the two branches:For example:(I\'m assuming origin/master is your remote tracking branch)If any commits are listed in the output above, then you have incoming changes -- you need to merge.  If no commits are listed by git log then there is nothing to merge.Note that this will work even if you are on a feature branch -- that does not have a tracking remote, since if explicitly refers to origin/master instead of implicitly using the upstream branch remembered by Git.If this is for a script, you can use:(Note: the benefit of this vs. previous answers is that you don\'t need a separate command to get the current branch name. "HEAD" and "@{u}" (the current branch\'s upstream) take care of it. See "git rev-parse --help" for more details.)The commandwill list the current head on the remote -- you can compare it to a previous value or see if you have the SHA in your local repo.Here\'s a Bash one-liner that compares the current branch\'s HEAD commit hash against its remote upstream branch, no heavy git fetch or git pull --dry-run operations required:Here\'s how this somewhat dense line is broken down:I suggest you go see the script https://github.com/badele/gitcheck, i have coded this script for check in one pass all your git repositories, and it show who has not commited and who has not pushed/pulled.Here a sample result I think the best way to do this would be:Assuming that you have the this refspec registered. You should if you have cloned the repository, otherwise (i.e., if the repo was created de novo locally, and pushed to the remote), you need to add the refspec explicitly.I based this solution on the comments of @jberger.I would do the way suggested by brool. The following one-line script takes the SHA1 of your last commited version and compares it to the one of the remote origin, and pull changes only if they differ.\nAnd it\'s even more light-weight of the solutions based on git pull or git fetch.There are many very feature rich and ingenious answers already. To provide some contrast, I could make do with a very simple line.If you run this script, it will test if the current branch need a git pull:It\'s very convenient to put it as a Git hook pre-commit to avoidwhen you commit before pulling.To use this code as a hook, simply copy/paste the script inandRun git fetch (remote) to update your remote refs, it\'s show you what\'s new. Then, when you checkout your local branch, it will show you whether it\'s behind upstream.will list everything referenced in any remote that isn\'t in your repo.  To catch remote ref changes to things you already had (e.g. resets to previous commits) takes a little more:Here\'s my version of a bash script that checks all repos in a predefined folder:https://gist.github.com/henryiii/5841984It can differentiate between common situations, like pull needed and push needed, and it is multithreaded, so the fetch happens all at once. It has several commands, like pull and status.Put a symlink (or the script) in a folder in your path, then it works as git all status (etc). It only supports origin/master, but it can be edited or combined with another method.I use a version of script based on Stephen Haberman\'s answer:Assuming this script is called git-fetch-and-rebase, it can be invoked with an optional argument directory name of the local git repository to perform operation on. If the script is called with no arguments, it assumes the current directory to be part of the git repository.Examples:It is available here as well.After reading many answers and multiple posts, and spending half a day trying various permutations, this is what I have come up with. If you are on Windows, you may run this script in Windows using gitbash provided by Git for Windows (installation or portable).This script requires arguments The script will If there is a change as printed by the script, then you may proceed to fetch or pull. The script may not be efficient, but it gets the job done for me. Update - 2015-10-30 : stderr to dev null to prevent printing url with password to console. Maybe this, if you want to add task as crontab:Below script works perfectlyYou can also find a Phing script who does that now.I needed a solution to update my production environments automatically and we\'re very happy thanks to this script that I\'m sharing.The script is written in XML and needs Phing.