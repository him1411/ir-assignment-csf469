What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?I think about the best I can do is give you a bunch of examples to study.\nJavascript programmers are practically ranked by how well they understand scope.\nIt can at times be quite counter-intuitive.A globally-scoped variableLocal scopeIntermediate: No such thing as block scope in JavaScript (ES5; ES6 introduces let)a.b.Intermediate: Object propertiesAdvanced: ClosureAdvanced: Prototype-based scope resolutionGlobal+Local: An extra complex CaseThis will print out undefined and 10 rather than 5 and 10 since JavaScript always moves variable declarations (not initializations) to the top of the scope, making the code equivalent to:Catch clause-scoped variableThis will print out 5, 6, 5. Inside the catch clause e shadows global and local variables. But this special scope is only for the caught variable. If you write var f; inside the catch clause, then it\'s exactly the same as if you had defined it before or after the try-catch block.Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It\'s always the position in the source that defines the scope.An element in the scope chain is basically a Map with a pointer to its parent scope.When resolving a variable, javascript starts at the innermost scope and searches outwards.Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.(I\'m sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across this page about what exactly this means at any time. Hopefully this more introductory link is enough to get you started though.)Traditionally, JavaScript really only has two types of scope : I will not elaborate on this, since there are already many other answers explaining the difference.The most recent JavaScript specs now also allow a third scope :Traditionally, you create your variables like this :Block scope variables are created like this :To understand the difference between functional scope and block scope, consider the following code :Here, we can see that our variable j is only known in the first for loop, but not before and after. Yet, our variable i is known in the entire function from the moment it is defined onward.Whether or not it is safe to use today, depends on your environment :If you\'re writing server-side JavaScript code (Node.js), you can safely use the let statement.If you\'re writing client-side JavaScript code and use a transpiler (like Traceur), you can safely use the let statement, however your code is likely to be anything but optimal with respect to performance.If you\'re writing client-side JavaScript code and don\'t use a transpiler, you need to consider browser support.Today, Feb 23 2016, these are some browsers that either don\'t support let or have only partial support :For an up-to-date overview of which browsers support the let statement at the time of your reading this answer, see this Can I Use page.Here\'s an example:You\'ll want to investigate closures, and how to use them to make private members.The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.Here is a good article on the subject.In "Javascript 1.7" (Mozilla\'s extension to Javascript) one can also declare block-scope variables with let statement:The idea of scoping in JavaScript when originally designed by Brendan Eich came from the HyperCard scripting language HyperTalk. In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as Execution ContextsECMA. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be window or a constructor function.These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution. So that is the technical explanation. In practice, it is important to remember that in JavaScriptApplying this to one of the previous examples (5. "Closure") on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six\'s immediately invoked function.i) The outer context. It has a variable environment of a = 1\n ii) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack\n iii) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.1) There is a global scope, a function scope, and the with and catch scopes. There is no \'block\' level scope in general for variable\'s -- the with and the catch statements add names to their blocks.2) Scopes are nested by functions all the way to the global scope.3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.EDIT: ECMAAScript 6 (Harmony) is spec\'ed to support let, and I know chrome allows a \'harmony\' flag, so perhaps it does support it..Let would be a support for block level scoping, but you have to use the keyword to make it happen.EDIT: Based on Benjamin\'s pointing out of the with and catch statements in the comments, I\'ve edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that is a block scope. These variables are aliased to the properties of the objects passed into them.EDIT: Clarifying example:test1 is scoped to the with block, but is aliased to a.test1.  \'Var test1\' creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is. Yikes!  Be careful using \'with\' -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.Try the feature at:See a demo at:View the code at:Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.JavaScript have only two type of scope : Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.Scope chain -->  Now when a variable a required it first searches for nearest variable scope and if variable is not there than it move\'s to next object of variable scope chain.which is in this case is window level.run the code. hope this will give an idea about scoping Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference errorCheck this article for in-depth understanding of scope Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it\'s compiling and executing the code.So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:Quoting from his ebook:The building represents our program\xe2\x80\x99s nested scope ruleset. The first\n  floor of the building represents your currently executing scope,\n  wherever you are. The top level of the building is the global scope.\n  You resolve LHS and RHS references by looking on your current floor,\n  and if you don\xe2\x80\x99t find it, taking the elevator to the next floor,\n  looking there, then the next, and so on. Once you get to the top floor\n  (the global scope), you either find what you\xe2\x80\x99re looking for, or you\n  don\xe2\x80\x99t. But you have to stop regardless.One thing of note that is worth mentioning, "Scope look-up stops once it finds the first match".This idea of "scope levels" explains why "this" can be changed with a newly created scope, if it\'s being looked up in a nested function.\nHere is a link that goes into all these details, Everything you wanted to know about javascript scope There are only function scopes in JS. Not block scopes!\nYou can see what is hoisting too.There are ALMOST only two types of JavaScript scopes:So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:Using functions instead:In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.That\'s almost all you need to know in terms of JavaScript scoping, except:So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:So this code:is equivalent to:This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.Every chunk of JavaScript code (global code or functions) has a scope chain associated with it. This scope\nchain is a list or chain of objects that defines the variables that are \xe2\x80\x9cin scope\xe2\x80\x9d for that\ncode. When JavaScript needs to look up the value of a variable x (a process called\nvariable resolution), it starts by looking at the first object in the chain. If that object has\na property named x , the value of that property is used. If the first object does not have\na property named x , JavaScript continues the search with the next object in the chain.\nIf the second object does not have a property named x , the search moves on to the next\nobject, and so on. If x is not a property of any of the objects in the scope chain, then\nx is not in scope for that code, and a ReferenceError occurs.\nIn top-level JavaScript code (i.e., code not contained within any function definitions),\nthe scope chain consists of a single object, the global object. In a non-nested function,\nthe scope chain consists of two objects. The first is the object that defines the function\xe2\x80\x99s\nparameters and local variables, and the second is the global object. In a nested function,\nthe scope chain has three or more objects. It is important to understand how this chain\nof objects is created. When a function is DEFINED, it stores the scope chain then in effect.\nWhen that function is INVOKED, it creates a new object to store its local variables, and\nadds that new object to the stored scope chain to create a new, longer, chain that\nrepresents the scope for that function invocation. This becomes more interesting for\nnested functions because each time the outer function is called, the inner function is\ndefined again. Since the scope chain differs on each invocation of the outer function,\nthe inner function will be subtly different each time it is defined\xe2\x80\x94the code of the inner\nfunction will be identical on each invocation of the outer function, but the scope chain\nassociated with that code will be different.\nThis notion of a scope chain is crucial for understanding closures .Try this curious example. In the example below if a were a numeric initialized at 0, you\'d see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword \'var\', either within a function or outside, and block scope is indicated with the keyword \'let\'.For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/letThere are two types of scopes in JavaScript. Global scope: variable which is announced in global scope can be used anywhere in the program very smoothly. For example: Functional scope or Local scope: variable declared in this scope can be used in its own function only. For example:Global: variable declared outside of a functionLocal: variable declared inside a function, and can only be called in that scope