Can you share your thoughts how would you implement data versioning in MongoDB. (I\'ve asked similar question regarding Cassandra. If you have any thoughts which db is better for that please share)Suppose that I need to version records in an simple address book. (Address book records are stored as flat json objects). I expect that the history:I\'m considering the following approaches:Create a new object collection to store history of records or changes to the records. It would store one object per version with a reference to the address book entry. Such records would looks as follows:This approach can be modified to store an array of versions per document. But this seems to be slower approach without any advantages.Store versions as serialized (JSON) object attached to address book entries. I\'m not sure how to attach such objects to MongoDB documents. Perhaps as an array of strings.\n(Modelled after Simple Document Versioning with CouchDB)The first big question when diving in to this is "how do you want to store changesets"?My personal approach would be to store diffs. Because the display of these diffs is really a special action, I would put the diffs in a different "history" collection.I would use the different collection to save memory space. You generally don\'t want a full history for a simple query. So by keeping the history out of the object you can also keep it out of the commonly accessed memory when that data is queried.To make my life easy, I would make a history document contain a dictionary of time-stamped diffs. Something like this:To make my life really easy, I would make this part of my DataObjects (EntityWrapper, whatever) that I use to access my data. Generally these objects have some form of history, so that you can easily override the save() method to make this change at the same time.UPDATE: 2015-10It looks like there is now a spec for handling JSON diffs. This seems like a more robust way to store the diffs / changes.There is a versioning scheme called "Vermongo" which addresses some aspects which haven\'t been dealt with in the other replies.One of these issues is concurrent updates, another one is deleting documents.Vermongo stores complete document copies in a shadow collection. For some use cases this might cause too much overhead, but I think it also simplifies many things.https://github.com/thiloplanz/v7files/wiki/VermongoIf you\'re looking for a ready-to-roll solution -Mongoid has built in simple versioninghttp://mongoid.org/en/mongoid/docs/extras.html#versioningmongoid-history is a Ruby plugin that provides a significantly more complicated solution with auditing, undo and redohttps://github.com/aq1018/mongoid-historyHere\'s another solution using a single document for the current version and all old versions:data contains all versions. The data array is ordered, new versions will only get $pushed to the end of the array. data.vid is the version id, which is an incrementing number.Get the most recent version:Get a specific version by vid:Return only specified fields:Insert new version: (and prevent concurrent insert/update)2 is the vid of the current most recent version and 3 is the new version getting inserted. Because you need the most recent version\'s vid, it\'s easy to do get the next version\'s vid: nextVID = oldVID + 1.The $and condition will ensure, that 2 is the latest vid.This way there\'s no need for a unique index, but the application logic has to take care of incrementing the vid on insert.Remove a specific version:That\'s it!(remember the 16MB per document limit)I worked through this solution that accommodates a published, draft and historical versions of the data:I explain the model further here: http://software.danielwatrous.com/representing-revision-data-in-mongodb/For those that may implement something like this in Java, here\'s an example:http://software.danielwatrous.com/using-java-to-work-with-versioned-data/Including all the code that you can fork, if you likehttps://github.com/dwatrous/mongodb-revision-objectsIf you are using mongoose, I have found the following plugin to be a useful implementation of the JSON Patch formatmongoose-patch-historyAnother option is to use mongoose-history plugin.