From my understanding one of the main things that async and await do is to make code easy to write and read - but is using them equal to spawning background threads to perform long duration logic?I\'m currently trying out the most basic example. I\'ve added some comments inline. Can you clarify it for me?When using async and await the compiler generates a state machine in the background.Here\'s an example on which I hope I can explain some of the high-level details that are going on: OK, so what happens here:Task<int> longRunningTask = LongRunningOperationAsync(); starts executing LongRunningOperationIndependent work is done on let\'s assume the Main Thread (Thread ID = 1) then await longRunningTask is reached. Now, if the longRunningTask hasn\'t finished and it is still running, MyMethodAsync() will return to its calling method, thus the main thread doesn\'t get blocked. When the longRunningTask is done then a thread from the ThreadPool (can be any thread) will return to MyMethodAsync() in its previous context and continue execution (in this case printing the result to the console). A second case would be that the longRunningTask has already finished its execution and the result is available. When reaching the await longRunningTask we already have the result so the code will continue executing on the very same thread. (in this case printing result to console). Of course this is not the case for the above example, where there\'s a Task.Delay(1000) involved. Further to the other answers, have a look at await (C# Reference)and more specifically at the example included, it explains your situation a bitThe following Windows Forms example illustrates the use of await in an\n  async method, WaitAsynchronouslyAsync. Contrast the behavior of that\n  method with the behavior of WaitSynchronously. Without an await\n  operator applied to a task, WaitSynchronously runs synchronously\n  despite the use of the async modifier in its definition and a call to\n  Thread.Sleep in its body.From my understanding one of the main things that async and await do is to make code easy to write and read.They\'re to make asynchronous code easy to write and read, yes.Is it the same thing as spawning background threads to perform long duration logic?Not at all.//i don\'t uderstand why this method must be marked as "async\'.The async keyword enables the await keyword. So any method using await must be marked async.// this line is reached after the 5 seconds sleep from DoSomethingAsync() method. Shouldn\'t it be reached immediately? No, because async methods are not run on another thread by default.//is this executed on a background thread?No.You may find my async/await intro helpful. The official MSDN docs are also unusually good (particularly the TAP section), and the async team put out an excellent FAQ.Showing the above explanations in action in a simple console program -And the output is:Thus,Thus, not thread is blocked. I think you\'ve picked a bad example with System.Threading.Thread.SleepPoint of an async Task is to let it execute in background without locking the main thread, such as doing a DownloadFileAsyncSystem.Threading.Thread.Sleep isn\'t something that is "being done", it just sleeps, and therefore your next line is reached after 5 seconds ...Read this article, I think it is a great explanation of async and await concept: http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspxI\'ve struggled to find simple examples of what async/await actually does. Once I finally started to understand, I created this simple little example which I think provides a very good general idea of what\'s going on when using async/await.Note: Task.Delay(1000) simply blocks for 1 secondOUTPUT:Here is a quick console program to make it clear to those who follow. The "TaskToDo" method is your long running method that you want to make async. Making it run Async is done by the TestAsync method. The test loops method just runs through the "TaskToDo" tasks and runs them Async. You can see that in the results because they don\'t complete in the same order from run to run - they are reporting to the console UI thread when they complete. Simplistic, but I think the simplistic examples bring out the core of the pattern better than more involved examples:This answer aims to provide some info specific to ASP.NET.By utilizing async/await in MVC controller, it is possible to increase thread pool utilization and achieve a much better throughput, as explained in the below article,http://www.asp.net/mvc/tutorials/mvc-4/using-asynchronous-methods-in-aspnet-mvc-4In web applications that sees a large number of concurrent requests at\n  start-up or has a bursty load (where concurrency increases suddenly),\n  making these web service calls asynchronous will increase the\n  responsiveness of your application. An asynchronous request takes the\n  same amount of time to process as a synchronous request. For example,\n  if a request makes a web service call that requires two seconds to\n  complete, the request takes two seconds whether it is performed\n  synchronously or asynchronously. However, during an asynchronous call,\n  a thread is not blocked  from responding to other requests while it\n  waits for the first request to complete. Therefore, asynchronous\n  requests prevent request queuing and thread pool growth when there are\n  many concurrent requests that invoke long-running operations.To be honest I still think the best explanation is the one about future and promises on the Wikipedia: http://en.wikipedia.org/wiki/Futures_and_promisesThe basic idea is that you have a separate pool of threads that execute tasks asynchronously. When using it. The object does however make the promise that it will execute the operation at some time and give you the result when you request it. This means that it will block when you request the result and hasn\'t finished, but execute in the thread pool otherwise.From there you can optimize things: some operations can be implemented async and you can optimize things like file IO and network communication by batching together subsequent requests and/or reordering them. I\'m not sure if this is already in the task framework of Microsoft - but if it isn\'t that would be one of the first things I would add.You can actually implement the future pattern sort-of with yields in C# 4.0. If you want to know how it works exactly, I can recommend this link that does a decent job: http://code.google.com/p/fracture/source/browse/trunk/Squared/TaskLib/ . However, if you start toying with it yourself, you will notice that you really need language support if you want to do all the cool things -- which is exactly what Microsoft did.All the answers here use Task.Delay() or some other built in async function. But here is my example that use none of those async functions:is using them equal to spawning background threads to perform long\n  duration logic?This article MDSN:Asynchronous Programming with async and await (C#) explains it explicitly:The async and await keywords don\'t cause additional threads to be\n  created. Async methods don\'t require multithreading because an async\n  method doesn\'t run on its own thread. The method runs on the current\n  synchronization context and uses time on the thread only when the\n  method is active.The way I understand it is also, there should be a third term added to the mix: Task.Async is just a qualifier you put on your method to say it\'s an asynchronous method.Task is the return of the async function. It executes asynchronously.You await a Task. When code execution reaches this line, control jumps out back to caller of your surrounding original function.If instead, you assign the return of an async function (ie Task) to a variable, when code execution reaches this line, it just continues past that line in the surrounding function while the Task executes asynchronously.In the following code, the HttpClient method GetByteArrayAsync returns a Task, getContentsTask. The task is a promise to produce the actual byte array when the task is complete. The await operator is applied to getContentsTask to suspend execution in SumPageSizesAsync until getContentsTask is complete. In the meantime, control is returned to the caller of SumPageSizesAsync. When getContentsTask is finished, the await expression evaluates to a byte array.