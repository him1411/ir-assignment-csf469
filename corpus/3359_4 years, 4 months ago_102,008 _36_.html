What\'s the difference between git merge and git rebase?Suppose originally there were 3 commits, A,B,C:Then developer Dan created commit D, and developer Ed created commit E:Obviously, this conflict should be resolved somehow. For this, there are 2 ways:MERGE:Both commits D and E are still here, but we create merge commit M that inherits changes from both D and E. However, this creates diamond shape, which many people find very confusing.REBASE:We create commit R, which actual file content is identical to that of merge commit M above. But, we get rid of commit E, like it never existed (denoted by dots - vanishing line). Because of this obliteration, E should be local to developer Ed and should have never been pushed to any other repository. Advantage of rebase is that diamond shape is avoided, and history stays nice straight line - most developers love that!I really love this excerpt from 10 Things I hate about git (it gives a short explanation for rebase in its second example):The man pages are one almighty \xe2\x80\x9cf*** you\xe2\x80\x9d1. They describe the commands from the perspective of a computer scientist, not a user. Case in point:Here\xe2\x80\x99s a description for humans:Update, another example: (thanks cgd)Translation: And then we havewhich is a good description.1. uncensored in the originalPersonally I don\'t find the standard diagramming technique very helpful - the arrows always seem to point the wrong way for me. (They generally point towards the "parent" of each commit, which ends up being backwards in time, which is weird).To explain it in words:For reasons I don\'t understand, GUI tools for Git have never made much of an effort to present merge histories more cleanly, abstracting out the individual merges. So if you want a "clean history", you need to use rebase.I seem to recall having read blog posts from programmers who only use rebase and others that never use rebase.I\'ll try explaining this with a just-words example. Let\'s say other people on your project are working on the user interface, and you\'re writing documentation. Without rebase, your history might look something like:That is, merges and UI commits in the middle of your documentation commits.If you rebased your code onto master instead of merging it, it would look like this:All of your commits are at the top (newest), followed by the rest of the master branch.(Disclaimer: I\'m the author of the "10 things I hate about Git" post referred to in another answer)While the accepted and most upvoted answer is great, I additionally find it useful trying to explain the difference only by words:mergerebasesummary: When possible, rebase is almost always better. Making re-integration into the main branch easier.Because? \xe2\x9e\x9d your feature work can be presented as one big \xe2\x80\x98patch file\xe2\x80\x99 (aka diff) in respect to the main branch, not having to \xe2\x80\x98explain\xe2\x80\x99 multiple parents: At least two, coming from one merge, but likely many more, if there were several merges. Unlike merges, multiple rebases do not add up. (another big plus)Git rebase is closer to a merge. The difference in rebase is:So that means that all your local commits are moved to the end, after all the remote commits. If you have a merge conflict, you have to solve it too.