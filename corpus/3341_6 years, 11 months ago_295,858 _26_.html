I\'m new to Git, and now I\'m in this situation:How do I update all other branches with master branch code?You have two options:The first is a merge, but this creates an extra commit for the merge. Checkout each branch:Then merge:Then push:Alternatively, you can do a rebase:You have basically two options:You merge. That is actually quite simple, and a perfectly local operation:This leaves the history exactly as it happened: You forked from master, you made changes to all branches, and finally you incorporated the changes from master into all three branches.git can handle this situation really well, it is designed for merges happening in all directions, at the same time. You can trust it be able to get all threads together correctly. It simply does not care whether branch b1 merges master, or master merges b1, the merge commit looks all the same to git. The only difference is, which branch ends up pointing to this merge commit.You rebase. People with an SVN, or similar background find this more intuitive. The commands are analogue to the merge case:People like this approach because it retains a linear history in all branches. However, this linear history is a lie, and you should be aware that it is. Consider this commit graph:The merge results in the true history:The rebase, however, gives you this history:The point is, that the commits E\', F\', and G\' never truly existed, and have likely never been tested. They may not even compile. It is actually quite easy to create nonsensical commits via a rebase, especially when the changes in master are important to the development in b1.The consequence of this may be, that you can\'t distinguish which of the three commits E, F, and G actually introduced a regression, diminishing the value of git bisect.I am not saying that you shouldn\'t use git rebase. It has its uses. But whenever you do use it, you need to be aware of the fact that you are lying about history. And you should at least compile test the new commits.git rebase master is the proper way to do this. Merging would mean a commit would be created for the merge, while rebasing would not.If you\'ve been working on a branch on-and-off, or lots has happened in other branches while you\'ve been working on something, it\'s best to rebase your branch onto master. This keeps the history tidy and makes things a lot easier to follow. Notes:There\'s a chapter on rebasing at http://git-scm.com/book/ch3-6.html, and loads of other resources out there on the web.You can merge, or you can apply individual commits across branches by using git cherry-pick.@cmaster made the best elaborated answer. In brief: You should not rewrite branch history instead keep them in actual state for future references. While merging to master, it creates one extra commit but that is cheap. Commits does not cost.