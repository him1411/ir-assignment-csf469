In C#/VB.NET/.NET, which loop runs faster, for or foreach?Ever since I read that a for loop works faster than a foreach loop a long time ago I assumed it stood true for all collections, generic collections, all arrays, etc.I scoured Google and found a few articles, but most of them are inconclusive (read comments on the articles) and open ended.What would be ideal is to have each scenario listed and the best solution for the same.For example (just an example of how it should be):A few references found on the web for the same:    [Edit]Apart from the readability aspect of it, I am really interested in facts and figures. There are applications where the last mile of performance optimization squeezed do matter. Patrick Smacchia blogged about this last month, with the following conclusions:foreach loops demonstrate more specific intent than for loops.Using a foreach loop demonstrates to anyone using your code that you are planning to do something to each member of a collection irrespective of its place in the collection. It also shows you aren\'t modifying the original collection (and throws an exception if you try to).The other advantage of foreach is that it works on any IEnumerable, where as for only makes sense for IList, where each element actually has an index.However, if you need to use the index of an element, then of course you should be allowed to use a for loop. But if you don\'t need to use an index, having one is just cluttering your code.There are no significant performance implications as far as I\'m aware. At some stage in the future it might be easier to adapt code using foreach to run on multiple cores, but that\'s not something to worry about right now.First, a counter-claim to Dmitry\'s answer. For arrays, the C# compiler emits largely the same code for foreach as it would for an equivalent for loop. That explains why for this benchmark, the results are basically the same:Results:Next, validation that Greg\'s point about the collection type being important - change the array to a List<double> in the above, and you get radically different results. Not only is it significantly slower in general, but foreach becomes significantly slower than accessing by index. Having said that, I would still almost always prefer foreach to a for loop where it makes the code simpler - because readability is almost always important, whereas micro-optimisation rarely is.Any time there\'s arguments over performance, you just need to write a small test so that you can use quantitative results to support your case.Use the StopWatch class and repeat something a few million times, for accuracy. (This might be hard without a for loop):Fingers crossed the results of this show that the difference is negligible, and you might as well just do whatever results in the most maintainable codeIt will always be close. For an array, sometimes for is slightly quicker, but foreach is more expressive, and offers LINQ, etc. In general, stick with foreach.Additionally, foreach may be optimised in some scenarios. For example, a linked list might be terrible by indexer, but it might be quick by foreach. Actually, the standard LinkedList<T> doesn\'t even offer an indexer for this reason.My guess is that it will probably not be significant in 99% of the cases, so why would you choose the faster instead of the most appropriate (as in easiest to understand/maintain)?There is unlikely to be a huge performance difference between the two. As always, when faced with a "which is faster?" question, you should always think "I can measure this."Write two loops that do the same thing in the body of the loop, execute and time them both, and see what the difference in speed is. Do this with both an almost-empty body, and a loop body similar to what you\'ll actually be doing. Also try it with the collection type that you\'re using, because different types of collections can have different performance characteristics.There are very good reasons to prefer foreach loops over for loops. If you can use a foreach loop, your boss is right that you should.However, not every iteration is simply going through a list in order one by one. If he is forbidding for, yes that is wrong.If I were you, what I would do is turn all of your natural for loops into recursion. That\'d teach him, and it\'s also a good mental exercise for you.Jeffrey Richter on TechEd 2005:"I have come to learn over the years the C# compiler is basically a liar to me." .. "It lies about many things." .. "Like when you do a foreach loop..." .. "...that is one little line of code that you write, but what the C# compiler spits out in order to do that it\'s phenomenal. It puts out a try/finally block in there, inside the finally block it casts your variable to an IDisposable interface, and if the cast suceeds it calls the Dispose method on it, inside the loop it calls the Current property and the MoveNext method repeatedly inside the loop, objects are being created underneath the covers. A lot of people use foreach because it\'s very easy coding, very easy to do.." .. "foreach is not very good in terms of performance, if you iterated over a collection instead by using square bracket notation, just doing index, that\'s just much faster, and it doesn\'t create any objects on the heap..."On-Demand Webcast:\nhttp://msevents.microsoft.com/CUI/WebCastEventDetails.aspx?EventID=1032292286&EventCategory=3&culture=en-US&CountryCode=USIn cases where you work with a collection of objects, foreach is better, but if you increment a number, a for loop is better.Note that in the last case, you could do something like:But it certainly doesn\'t perform better, it actually has worse performance compared to a for.This is ridiculous. There\'s no compelling reason to ban the for-loop, performance-wise or other.See Jon Skeet\'s blog for a performance benchmark and other arguments.This should save you:Use:For greater win, you may take three delegates as parameters.The differences in speed in a for- and a foreach-loop are tiny when you\'re looping through common structures like arrays, lists, etc, and doing a LINQ query over the collection is almost always slightly slower, although it\'s nicer to write! As the other posters said, go for expressiveness rather than a millisecond of extra performance.What hasn\'t been said so far is that when a foreach loop is compiled, it is optimised by the compiler based on the collection it is iterating over. That means that when you\'re not sure which loop to use, you should use the foreach loop - it will generate the best loop for you when it gets compiled. It\'s more readable too.Another key advantage with the foreach loop is that if your collection implementation changes (from an int array to a List<int> for example) then your foreach loop won\'t require any code changes:The above is the same no matter what type your collection is, whereas in your for loop, the following will not build if you changed myCollection from an array to a List:"Are there any arguments I could use to help me convince him the for loop is acceptable to use?"No, if your boss is micromanaging to the level of telling you what programming language constructs to use, there\'s really nothing you can say.  Sorry.It probably depends on the type of collection you are enumerating and the implementation of its indexer. In general though, using foreach is likely to be a better approach. Also, it\'ll work with any IEnumerable - not just things with indexers.Every language construct has an appropriate time and place for usage.  There is a reason the C# language has a four separate iteration statements - each is there for a specific purpose, and has an appropriate use.I recommend sitting down with your boss and trying to rationally explain why a for loop has a purpose.  There are times when a for iteration block more clearly describes an algorithm than a foreach iteration.  When this is true, it is appropriate to use them.I\'d also point out to your boss - Performance is not, and should not be an issue in any practical way - it\'s more a matter of expression the algorithm in a succinct, meaningful, maintainable manner.  Micro-optimizations like this miss the point of performance optimization completely, since any real performance benefit will come from algorithmic redesign and refactoring, not loop restructuring.If, after a rational discussion, there is still this authoritarian view, it is up to you as to how to proceed.  Personally, I would not be happy working in an environment where rational thought is discouraged, and would consider moving to another position under a different employer.  However, I strongly recommend discussion prior to getting upset - there may just be a simple misunderstanding in place.It is what you do inside the loop that affects perfomance, not the actual looping construct (assuming your case is non-trivial).Whether for is faster than foreach is really besides the point. I seriously doubt that choosing one over the other will make a significant impact on your performance. The best way to optimize your application is through profiling of the actual code. That will pinpoint the methods that account for the most work/time. Optimize those first. If performance is still not acceptable, repeat the procedure. As a general rule I would recommend to stay away from micro optimizations as they will rarely yield any significant gains. Only exception is when optimizing identified hot paths (i.e. if your profiling identifies a few highly used methods, it may make sense to optimize these extensively). This has the same two answers as most "which is faster" questions:1) If you don\'t measure, you don\'t know.2) (Because...) It depends.It depends on how expensive the "MoveNext()" method is, relative to how expensive the "this[int index]" method is, for the type (or types) of IEnumerable that you will be iterating over.The "foreach" keyword is shorthand for a series of operations - it calls GetEnumerator() once on the IEnumerable, it calls MoveNext() once per iteration, it does some type checking, and so on. The thing most likely to impact performance measurements is the cost of MoveNext() since that gets invoked O(N) times. Maybe it\'s cheap, but maybe it\'s not.The "for" keyword looks more predictable, but inside most "for" loops you\'ll find something like "collection[index]". This looks like a simple array indexing operation, but it\'s actually a method call, whose cost depends entirely on the nature of the collection that you\'re iterating over. Probably it\'s cheap, but maybe it\'s not.If the collection\'s underlying structure is essentially a linked list, MoveNext is dirt-cheap, but the indexer might have O(N) cost, making the true cost of a "for" loop O(N*N).The two will run almost exactly the same way.  Write some code to use both, then show him the IL.  It should show comparable computations, meaning no difference in performance.I found the foreach loop which iterating through a List faster. See my test results below. In the code below I iterate an array of size 100, 10000 and 100000 separately using for and foreach loop to measure the time.After @jgauffin suggestion I used @johnskeet code and found that the for loop with array is faster than following,See my test results and code below,for has more simple logic to implement so it\'s faster than foreach.Unless you\'re in a specific speed optimization process, I would say use whichever method produces the easiest to read and maintain code.  If an iterator is already setup, like with one of the collection classes, then the foreach is a good easy option.  And if it\'s an integer range you\'re iterating, then for is probably cleaner.Jeffrey Richter talked the performance difference between for and foreach on  a recent podcast: http://pixel8.infragistics.com/shows/everything.aspx#Episode:9317In most cases there\'s really no difference.Typically you always have to use foreach when you don\'t have an explicit numerical index, and you always have to use for when you don\'t actually have an iterable collection (e.g. iterating over a two-dimensional array grid in an upper triangle).  There are some cases where you have a choice.One could argue that for loops can be a little more difficult to maintain if magic numbers start to appear in the code.  You should be right to be annoyed at not being able to use a for loop and have to build a collection or use a lambda to build a subcollection instead just because for loops have been banned.Really screw with his head and go for an IQueryable .foreach closure instead:myList.ForEach(c => Console.WriteLine(c.ToString());LOLI wouldn\'t expect anyone to find a "huge" performance difference between the two.I guess the answer depends on the whether the collection you are trying to access has a faster indexer access implementation or a faster IEnumerator access implementation. Since IEnumerator often uses the indexer and just holds a copy of the current index position, I would expect enumerator access to be at least as slow or slower than direct index access, but not by much.Of course this answer doesn\'t account for any optimizations the compiler may implement.Keep in mind that the for-loop and foreach-loop are not always equivalent. List enumerators will throw an exception if the list changes, but you won\'t always get that warning with a normal for loop. You might even get a different exception if the list changes at just the wrong time.It seems a bit strange to totally forbid the use of something like a for loop.There\'s an interesting article here that covers a lot of the performance differences between the two loops.I would say personally I find foreach a bit more readable over for loops but you should use the best for the job at hand and not have to write extra long code to include a foreach loop if a for loop is more appropriate.I did test it a while ago, with the result that a for loop is much faster than a foreach loop. The cause is simple, the foreach loop first needs to instantiate an IEnumerator for the collection.