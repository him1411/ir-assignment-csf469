What is the worst real-world macros/pre-processor abuse you\'ve ever come across (please no contrived IOCCC answers *haha*)?Please add a short snippet or story if it is really entertaining. The goal is to teach something instead of always telling people "never use macros".p.s.: I\'ve used macros before... but usually I get rid of them eventually when I have a "real" solution (even if the real solution is inlined so it becomes similar to a macro).Bonus: Give an example where the macro was really was better than a not-macro solution.Related question: When are C++ macros beneficial? From memory, it looked something like this:Yes that\'s right, no closing braces in any of the functions.  Syntax highlighting was a mess, so he used vi to edit (not vim, it has syntax coloring!)He was a Russian programmer who had mostly worked in assembly language.  He was fanatical about saving as many bytes as possible because he had previously worked on systems with very limited memory.  "It was for satellite.  Only very few byte, so we use each byte over for many things."  (bit fiddling, reusing machine instruction bytes for their numeric values)  When I tried to find out what kinds of satellites, I was only able to get "Orbiting satellite.  For making to orbit."He had two other quirks: A convex mirror mounted above his monitor "For knowing who is watching", and an occasional sudden exit from his chair to do a quick ten pushups.  He explained this last one as "Compiler found error in code. This is punishment".  My worst:I spent two days of my life tracking down some multi-threaded COM ref-counting issue because some idiot put this in a header file.  I won\'t mention the company I worked for at the time.  The moral of this story?  If you don\'t understand something, read the documentation and learn about it.  Don\'t just make it go away.Challenge: Can anyone do it with fewer defines and structs? ;-)It was joke played on someone, it wasn\'t found amusing by those affectedThe hideous:Seriously, if you want to code in Pascal, buy a Pascal compiler, don\'t destroy the beautiful C language.An \'architect\', very humble guy, you know the type, had the following:because he liked to type fast. The brain-surgeon used to like to shout at people who were smarter than him (which was pretty much everyone), and threaten to use his black-belt on them. Real-world?  MSVC has macros in minmax.h, called max and min, which cause a compiler error every time I intend to use the standard std::numeric_limits<T>::max() function.A mix between Pascal syntax and french keywords:Raymond Chen has a really good rant against using flow control macros. His best example is straight from the original Bourne shell source code:I would like to submit for the contest a gem called chaos-pp, which implements a functional language by means of the preprocessor macros.One of the examples is calculating the 500th fibonacci number entirely by the preprocessor:The original code before preprocessor looks as this:preprocessing the file we get the following result (after a rather long wait):Directly from Qt:Really nice to interact with other libs as boost::signals... Just an example, there are many others in Qt that create funny looking code like:And that is C++... but suddenly:Is not valid C++ any more.Windows.h has a lot of functions that abused macros.MrValdez is annoyed by the GetObject macro found in Windows.hThe GetObject macro changes the GetObject() function into GetObjectA() or GetObjectW() (depending if the build is compiled in non-unicode and unicode, respectively)MrValdez hates having to do before the GetObject function lineThe alternative is to change the function name to something else like GetGameObject()jdkoftinoff in the comments have nailed it: The problem is that all windows API functions are macros.Adam Rosenfield mentioned that that the issues can be fixed by defining NOGDI, WIN32_LEAN_AND_MEAN, NOMINMAX, etc before including windows.h to remove the issues.this is just so evil. It\'s random, which means it fires in different places all the time, it changes return statement, which usually have some code on it that could fail all by itself, it changes innocent looking keyword that you won\'t ever get suspicious over and it uses exception from std space so you won\'t try to search through your sources to find it\'s source. Just brilliant. A coworker and I found these two gems in some of our code for object streaming.  These macros were instantiated in EVERY SINGLE class file that did streaming.  Not only is this hideous code spewed all over our code base, when we approached the original author about it, he wrote a 7 page article on our internal wiki defending this as the only possible way to accomplish what he was attempting to do here. Needless to say, it has since been refactored out and is no longer used in our code base.Don\'t be thrown off by the highlighted keywords.  This is ALL a macroUpdate (December 17, 2009):More good news regarding this hideous macro author.  As of August, the employee responsible for this monstrosity was sacked.I did the following myself, and I think I learned something from it.In 1992 or so I wrote a small Lisp interpreter. It wasn\'t implemented in normal\nC, but in an interpreted C-like language. This C-like language used the standard C pre-processor, though.The Lisp interpreter of course contained the functions car, which is\nused in Lisp to return the first element in a list, and cdr, which\nreturns the rest of the list. They were implemented like this:(Data were stored in arrays, since there were no structs. CONS_OFFSET is the constant 1000.)car and cdr are used frequently in Lisp, and are short, and since function calls weren\'t\nvery fast in the implementation language, I optimized my code by implementing those two Lisp functions as macros:CHECK_CONS checks that its argument actually is a list, and since that one is also used frequently in the interpreter, and is short, I wrote that one too as a macro:IS_CONS and LISP_ERROR were also used frequently, so I made them into macros too:Seems reasonable?But then, why did the entire system crash on this line:I worked a long time to find the problem, until I finally checked what\nthat short line was expanded to by the pre-processor. It was expanded to a 31370-character line, which I have here split into lines (502 of them) for clarity:I once had to port a C application from unix to windows, the specific nature of which shall remain unnamed to protect the guilty.  The guy who wrote it was a professor unaccustomed to writing production code, and had clearly come to C from some other language.  It also happens that English wasn\'t his first language, though the country he came from the majority of people speak it quite well.His application made heavy use of the preprocessor to twist the C language into a format he could better understand.  But the macros he used the most were defined in a header file named \'Thing.h\' (seriously), which included the following:...which he then used to write monstrosities like the following:The entire project (~60,000 LOC) was written in a similar style -- marco hell, weird names, Olde-English jargon, etc.  Fortunately we were able to throw the code out since I found an OSS library which performed the same algorithm dozens of times faster.(I\'ve copied and edited this answer which I originally made on this question).The worst I\'ve ever encountered was in a product containing a suite of executables where the designated technical leader hadn\'t figured out libraries.Instead, he had sets of files that were shared in several Visual Source Safe folders.\nHe then realised they needed to behave slightly differently for each application. There\'s a number of refactoring steps you could apply here.Instead, he used #ifdefsThe use of the LINE preprocessor to generate unique ID for messages passed over the network:This is an example where the macro really was better than a non-macro solution:In a non-macro solution classes, functions and variables have to be built to keep track of what ID the message is. The developer may or may not make the message ID tracking complicated whereas this is easier to read and debug.In addition, its easier to add new messages just by adding the message into the source.The disadvantage of this situation is that the file has to be included in all code that uses messages. Compile time would increase whenever a message is edited.One fairly bad example:This allows a C structure that contains a member variable called class to be handled by a C++ compiler.  There are two headers with this construct in it; one of them also contains \'#undef class\' at the end and the other doesn\'t.In one year of the International Obfuscated C Coding Contest, there was an entry where the entire program was:PWith the proviso that you could define P in the makefile to be whatever program you wanted.As I recall, it won in one of the categories, and the next year a rule had popped up disallowing that style of entry.(Edit: six months later or something... I\'m sure the "No IOCCC" thing wasn\'t in the main question when I wrote this...)I was bored one day and was playing around with blocks in Objective-C...allowing "interesting" things like:(some function and class definitions not shown for sake of brevity)The worst one I saw was the non-use :-)Someone wrote a strcpy (I think that was it... over 10 years ago now) function inside of a method (because they didn\'t want the overhead of calling strcpy... sigh).They clued in that it wouldn\'t work for Japanese characters so they added an "if" at the start to do ASCII or Unicode.  At that point the code was about a screen long... likely killing cache coherency and erasing his supposed savings for the inlining of the code.The code was identical save for the types (so should have used a macro).Of course the strcpy that they wrote was much much much slower than the hand tuned assembler one that was in the standard library...Of course if they had just done it all as a macro it could have been replaced with a call to strcpy...Of course I quit the company (not directly because of that...) The obligatoryandWho knew?The person who did this explained himself some years later - most (if not all) C library functions return 0 as an indication that everything went well. So, he wanted to be able to write code like:Needless to say, nobody in our team (tester or developer) ever dared to glance at his code again.I maintain code that has gotos in macros. So a function will have a label at the end but no visible goto in the function code. To make matters worse the macro is at the end of other statements usually off the screen unless you scroll horizontally.By a classmate who failed to understand the rules about magic numbers:\n#define TWO_HUNDRED_AND_EIGHTY_THREE_POINT_ONE 283.1 ASA - http://www.ingber.com/#ASAYou really have to download it to appreciate it. The entire work flow is determined by macros. It is completely unreadable. As an example - etc., etc.And that is just setting up the options. the entire program is like that.