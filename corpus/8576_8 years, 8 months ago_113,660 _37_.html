Is there a way in Java\'s for-each loopto find out how often the loop has already been processed?Aside from using the old and well-known for(int i=0; i < boundary; i++) - loop, is the constructthe only way to have such a counter available in a for-each loop?No, but you can provide your own counter.The reason for this is that the for-each loop internally does not have a counter; it is based on the Iterable interface, i.e. it uses an Iterator to loop through the "collection" - which may not be a collection at all, and may in fact be something not at all based on indexes (such as a linked list).There is another way.Given that you write your own Index class and a static method that returns an Iterable over instances of this class you can Where the implementation of With.index is something likeThe easiest solution is to just run your own counter thus:The reason for this is because there\'s no actual guarantee that items in a collection (which that variant of for iterates over) even have an index, or even have a defined order (some collections may change the order when you add or remove elements).See for example, the following code:When you run that, you can see something like:indicating that, rightly so, order is not considered a salient feature of a set.There are other ways to do it without a manual counter but it\'s a fair bit of work for dubious benefit.I\'m afraid this isn\'t possible with foreach. But I can suggest you a simple old-styled for-loops:Notice that, the List interface gives you access to it.nextIndex().(edit)To your changed example:Using lambdas and functional interfaces in Java 8 makes creating new loop abstractions possible. I can loop over a collection with the index and the collection size:Which outputs:Which I implemented as:The possibilities are endless. For example, I create an abstraction that uses a special function just for the first element:Which prints a comma separated list correctly:Which I implemented as:Libraries will begin to pop up to do these sorts of things, or you can roll your own.One of the changes Sun is considering for Java7 is to provide access to the inner Iterator in foreach loops. the syntax will be something like this (if this is accepted):This is syntactic sugar, but apparently a lot of requests were made for this feature. But until it is approved, you\'ll have to count the iterations yourself, or use a regular for loop with an Iterator.Java 8 introduced the Iterable#forEach() / Map#forEach() method, which is more efficient for many Collection / Map implementations compared to the "classical" for-each loop. However, also in this case an index is not provided. The trick here is to use AtomicInteger outside the lambda expression. Note: variables used within the lambda expression must be effectively final, that is why we cannot use an ordinary int.If you need a counter in an for-each loop you have to count yourself. There is no built in counter as far as I know.There is a "variant" to pax\' answer...  ;-)There are many ways but the method is one of the wayI found that using a simple for loop with an incrementing index was the most efficient, reliable solution, as posted here: https://stackoverflow.com/a/3431543/2430549For situations where I only need the index occasionally, like in a catch clause, I will sometimes use indexOf.I\'m a little surprised no-one suggested the following (I admit it\'s a lazy approach...);\nIf stringArray is a List of some sort, you could use something like stringArray.indexOf(S) to return a value for the current count.Note: this assumes that the elements of the List are unique, or that it doesn\'t matter if they are non-unique (because in that case it will return the index of the first copy found).There are situations in which that would be sufficient...