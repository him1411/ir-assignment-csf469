There have been some discussions here about JPA entities and which hashCode()/equals() implementation should be used for JPA entity classes.  Most (if not all) of them depend on Hibernate, but I\'d like to discuss them JPA-implementation-neutrally (I am using EclipseLink, by the way).All possible implementations are having their own advantages and disadvantages regarding:As far I can see, there are three options: My questions are:\nUPDATE 1:By "hashCode()/equals() are broken", I mean that successive hashCode() invocations may return differing values, which is (when correctly implemented) not broken in the sense of the Object API documentation, but which causes problems when trying to retrieve a changed entity from a Map,  Set or other hash-based Collection.  Consequently, JPA implementations (at least EclipseLink) will not work correctly in some cases.UPDATE 2:Thank you for your answers -- most of them have remarkable quality.\nUnfortunately, I am still unsure which approach will be the best for a real-life application, or how to determine the best approach for my application.  So, I\'ll keep the question open and hope for some more discussions and/or opinions.Read this very nice article on the subject: Don\'t Let Hibernate Steal Your Identity.The conclusion of the article goes like this:Object identity is deceptively hard to implement correctly when\n  objects are persisted to a database. However, the problems stem\n  entirely from allowing objects to exist without an id before they are\n  saved. We can solve these problems by taking the responsibility of\n  assigning object IDs away from object-relational mapping frameworks\n  such as Hibernate. Instead, object IDs can be assigned as soon as the\n  object is instantiated. This makes object identity simple and\n  error-free, and reduces the amount of code needed in the domain model.I always override equals/hashcode and implement it based on the business id. Seems the most reasonable solution for me. See the following link.To sum all this stuff up, here is a listing of what will work or won\'t work with the different ways to handle equals/hashCode: EDIT:To explain why this works for me:We usually have two IDs in our entities: Take a look: EDIT: to clarify my point regarding calls to setUuid() method. Here\'s a typical scenario:When I run my tests and see the log output I fix the problem:Alternatively, one can provide a separate constructor:So my example would look like this:I use a default constructor and a setter, but you may find two-constructors approach more suitable for you.If you want to use equals()/hashCode() for your Sets, in the sense that the same entity can only be in there once, then there is only one option: Option 2. That\'s because a primary key for an entity by definition never changes (if somebody indeed updates it, it\'s not the same entity anymore)You should take that literally: Since your equals()/hashCode() are based on the primary key, you must not use these methods, until the primary key is set. So you shouldn\'t put entities in the set, until they\'re assigned a primary key. (Yes, UUIDs and similar concepts may help to assign primary keys early.)Now, it\'s theoretically also possible to achieve that with Option 3, even though so-called "business-keys" have the nasty drawback that they can change: "All you\'ll have to do is delete the already inserted entities from the set(s), and re-insert them." That is true - but it also means, that in a distributed system, you\'ll have to make sure, that this is done absolutely everywhere the data has been inserted to (and you\'ll have to make sure, that the update is performed, before other things occur). You\'ll need a sophisticated update mechanism, especially if some remote systems aren\'t currently reachable...Option 1 can only be used, if all the objects in your sets are from the same Hibernate session. The Hibernate documentation makes this very clear in chapter 13.1.3. Considering object identity:Within a Session the application can safely use == to compare objects.However, an application that uses == outside of a Session might produce unexpected results. This might occur even in some unexpected places. For example, if you put two detached instances into the same Set, both might have the same database identity (i.e., they represent the same row). JVM identity, however, is by definition not guaranteed for instances in a detached state. The developer has to override the equals() and hashCode() methods in persistent classes and implement their own notion of object equality.It continues to argue in favor of Option 3:There is one caveat: never use the database identifier to implement equality. Use a business key that is a combination of unique, usually immutable, attributes. The database identifier will change if a transient object is made persistent. If the transient instance (usually together with detached instances) is held in a Set, changing the hashcode breaks the contract of the Set.This is true, if you Otherwise, you\'re free to choose Option 2.Then it mentions the need for a relative stability:Attributes for business keys do not have to be as stable as database primary keys; you only have to guarantee stability as long as the objects are in the same Set.This is correct. The practical problem I see with this is: If you can\'t guarantee absolute stability, how will you be able to guarantee stability "as long as the objects are in the same Set". I can imagine some special cases (like using sets only for a conversation and then throwing it away), but I would question the general practicability of this.Short version:I personally already used all of these three stategies in different projects. An I must say that option 1 is in my opinion the most practicable in a real life app. A made the experience breaking hashCode()/equals() conformity leads to many crazy bugs as you will every time end up in situations where result of equality changes after an entity has been added to a collection.But there are further options (also with their pros and cons):a) hashCode/equals based on a set of immutable, not null, constructor assigned, fields(+) all three criterias are guaranteed(-) field values must be available to create a new instance(-) complicate handling if you must change one of thenb) hashCode/equals based on primary key that is assigned by application (in constructor) instead of JPA(+) all three criterias are guaranteed(-) you cannot take advantage of simple reliable ID generation stategies like DB sequences(-) complicated if new entities are created in a distributed environment (client/server) or app server clusterc) hashCode/equals based on a UUID assigned by constructor of entity(+) all three criterias are guaranteed(-) overhead of UUID generation(-) may be a little risk that twice the same UUID is used, depending on algorythm used (may be detected by an unique index on DB)Although using a business key (option 3) is the most commonly recommended approach (Hibernate community wiki, "Java Persistence with Hibernate" p. 398), and this is what we mostly use, there\'s a Hibernate bug which breaks this for eager-fetched sets: HHH-3799.  In this case, Hibernate can add an entity to a set before its fields are initialized.  I\'m not sure why this bug hasn\'t gotten more attention, as it really makes the recommended business-key approach problematic.I think the heart of the matter is that equals and hashCode should be based on immutable state (reference Odersky et al.), and a Hibernate entity with Hibernate-managed primary key has no such immutable state.  The primary key is modified by Hibernate when a transient object becomes persistent.  The business key is also modified by Hibernate, when it hydrates an object in the process of being initialized.That leaves only option 1, inheriting the java.lang.Object implementations based on object identity, or using an application-managed primary key as suggested by James Brundege in "Don\'t Let Hibernate Steal Your Identity" (already referenced by Stijn Geukens\'s answer) and by Lance Arlaus in "Object Generation: A Better Approach to Hibernate Integration".The biggest problem with option 1 is that detached instances can\'t be compared with persistent instances using .equals().  But that\'s OK; the contract of equals and hashCode leaves it up to the developer to decide what equality means for each class.  So just let equals and hashCode inherit from Object.  If you need to compare a detached instance to a persistent instance, you can create a new method explicitly for that purpose, perhaps boolean sameEntity or boolean dbEquivalent or boolean businessEquals.You can use the entity identifier as suggested in this post. The only catch is that you need to use a hashCode implementation that always returns the same value, like this:I agree with Andrew\'s answer. We do the same thing in our application but instead of storing UUIDs as VARCHAR/CHAR, we split it into two long values. See UUID.getLeastSignificantBits() and UUID.getMostSignificantBits().One more thing to consider, is that calls to UUID.randomUUID() are pretty slow, so you might want to look into lazily generating the UUID only when needed, such as during persistence or calls to equals()/hashCode()As other people way smarter than me has pointed out already, there\'s a numerous amount of strategies out there. It seems to be the case though that the majority of applied design patterns try to hack their way to success. They limit constructor access if not hinder constructor invocations completely with specialized constructors and factory methods. Indeed it is always pleasant with a clear cut API. But if the sole reason is to make the equals- and hashcode overrides be compatible with the application, then I wonder if those strategies are in compliance with KISS (Keep It Simple Stupid).For me, I like to override equals and hashcode by way of examining the id. In these methods, I require the id to not be null and document this behavior well. Thus it will become the developers contract to persist a new entity before storing him somewhere else. An application that does not honor this contract would fail within the minute (hopefully).Word of caution though: If your entities are stored in different tables and your provider use an auto-generation strategy for the primary key, then you\'ll get duplicated primary keys across entity types. In such case, also compare run time types with a call to Object#getClass() which of course will make it impossible that two different types are considered equal. That suits me just fine for the most part.There are obviously already very informative answers here but I will tell you what we do.We do nothing (ie do not override).If we do need equals/hashcode to work for collections we use UUIDs.\nYou just create the UUID in the constructor. We use http://wiki.fasterxml.com/JugHome for UUID. UUID is a little more expensive CPU wise but is cheap compared to serialization and db access.Business keys approach doesn\'t suit for us. We use DB generated ID, temporary transient tempId and override equal()/hashcode() to solve the dilemma. All entities are descendants of Entity. Pros:Cons:Look at our code:I have always used option 1 in the past because I was aware of these discussions and thought it was better to do nothing until I knew the right thing to do. Those systems are all still running successfully.However, next time I may try option 2 - using the database generated Id.Hashcode and equals will throw IllegalStateException if the id is not set.This will prevent subtle errors involving unsaved entities from appearing unexpectedly.What do people think of this approach?This is a common problem in every IT system that uses Java and JPA. The pain point extends beyond implementing equals() and hashCode(), it affects how an organization refer to an entity and how its clients refer to the same entity. I\'ve seen enough pain of not having a business key to the point that I wrote my own blog to express my view.In short: use a short, human readable, sequential ID with meaningful prefixes as business key that\'s generated without any dependency on any storage other than RAM. Twitter\'s Snowflake is a very good example.If UUID is the answer for many people, why don\'t we just use factory methods from business layer to create the entities and assign primary key at creation time?for example:this way we would get a default primary key for the entity from the persistence provider, and our hashCode() and equals() functions could rely on that.We could also declare the Car\'s constructors protected and then use reflection in our business method to access them. This way developers would not be intent on instantiate Car with new, but through factory method.How\'bout that?I tried to answer this question myself and was never totally happy with found solutions until i read this post and especially DREW one. I liked the way he lazy created UUID and optimally stored it.But I wanted to add even more flexibility, ie lazy create UUID ONLY when hashCode()/equals() is accessed before first persistence of the entity with each solution\'s advantages : I would really apreciate feedback on my mixed-solution belowIn practice it seems, that Option 2 (Primary key) is most frequently used.\nNatural and IMMUTABLE business key is seldom thing, creating and supporting synthetic keys are too heavy to solve situations, which are probably never happened.\nHave a look at spring-data-jpa AbstractPersistable implementation (the only thing: for Hibernate  implementation use Hibernate.getClass).Just aware of manipulating new objects in HashSet/HashMap.\nIn opposite, the Option 1 (remain Object implementation) is broken just after merge, that is very common situation. If you have no business key and have a REAL needs to manipulate new entity in hash structure, override hashCode to constant, as below Vlad Mihalcea was advised.Below is a simple (and tested) solution for Scala. Note that this solution does not fit into any of the 3 categories\ngiven in the question.  All my Entities are subclasses of the UUIDEntity so I follow the\ndon\'t-repeat-yourself (DRY) principle.If needed the UUID generation can be made more precise (by using more\npseudo-random numbers).Scala Code: