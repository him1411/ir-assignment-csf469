If I pass the same key multiple times to HashMap\xe2\x80\x99s put method, what happens to the original value? And what if even the value repeats? I didn\xe2\x80\x99t find any documentation on this.Case 1: Overwritten values for a keyWe get surely not one.Case 2: Duplicate valueWe get one.But what happens to the other values? I was teaching basics to a student and I was asked this. Is the Map like a bucket where the last value is referenced (but in memory)?By definition, the put command replaces the previous value associated with the given key in the map (conceptually like an array indexing operation for primitive types).The map simply drops its reference to the value.  If nothing else holds a reference to the object, that object becomes eligible for garbage collection.  Additionally, Java returns any previous value associated with the given key (or null if none present), so you can determine what was there and maintain a reference if necessary.More information here: HashMap DocYou may find your answer in the javadoc of Map#put(K, V) (which actually returns something):Associates the specified value with the specified key in this map\n  (optional operation). If the map\n  previously contained a mapping for\n  this key, the old value is replaced by\n  the specified value. (A map m is said\n  to contain a mapping for a key k if\n  and only if m.containsKey(k) would\n  return true.)Parameters:\n          key - key with which the specified value is to be associated.\n          value - value to be associated with the specified key. Returns:\n          previous value associated with specified key, or null if there was no\n  mapping for key. (A null return can also indicate that the map previously associated null with the specified key, if the implementation supports null values.)So if you don\'t assign the returned value when calling mymap.put("1", "a string"), it just becomes unreferenced and thus eligible for garbage collection.The prior value for the key is dropped and replaced with the new one.If you\'d like to keep all the values a key is given, you might consider implementing something like this:it\'s Key/Value feature and you could not to have duplicate key for several values because when you want to get the actual value which one of values is belong to entered keyin your example when you want to get value of "1" which one is it ?!that\'s reasons to have unique key for every value but you could to have a trick by java standard lib :and you could to use it in this way:and result of prints are :Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.To your question whether the map was like a bucket: no.It\'s like a list with name=value pairs whereas name doesn\'t need to be a String (it can, though).To get an element, you pass your key to the get()-method which gives you the assigned object in return.And a Hashmap means that if you\'re trying to retrieve your object using the get-method, it won\'t compare the real object to the one you provided, because it would need to iterate through its list and compare() the key you provided with the current element.This would be inefficient. Instead, no matter what your object consists of, it calculates a so called hashcode from both objects and compares those. It\'s easier to compare two ints instead of two entire (possibly deeply complex) objects. You can imagine the hashcode like a summary having a predefined length (int), therefore it\'s not unique and has collisions. You find the rules for the hashcode in the documentation to which I\'ve inserted the link.If you want to know more about this, you might wanna take a look at articles on javapractices.com and technofundo.comregardsI always used:if I wanted to apply multiple things to one identifying key. you could always do something like this and create yourself a maze!BTW, if you want some semantics such as only put if this key is not exist. you can use concurrentHashMap with putIfAbsent() function.\nCheck this out:https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html#put(K,%20V)concurrentHashMap  is thread safe with high performance since it uses "lock striping" mechanism to improve the throughput. Yes, this means all the 1 keys with value are overwriten with the last added value and here you add "surely not one" so it will display only "surely not one".Even if you are trying to display with a loop, it will also only display one key and value which have same key.Means hash map wont allow duplicates, if you have properly overridden equals and hashCode() methods. HashSet also uses HashMap internally, see the source doc