I\'m trying to write a Java routine to evaluate simple math expressions from String values like:I want to avoid a lot of if-then-else statements.\nHow can I do this?With JDK1.6, you can use the built-in Javascript engine.I\'ve written this eval method for arithmetic expressions to answer this question. It does addition, subtraction, multiplication, division, exponentiation (using the ^ symbol), and a few basic functions like sqrt. It supports grouping using (...), and it gets the operator precedence and associativity rules correct.Example:Output: 7.5 (which is correct)The parser is a recursive descent parser, so internally uses separate parse methods for each level of operator precedence in its grammar. I kept it short so it\'s easy to modify, but here are some ideas you might want to expand it with:Variables:The bit of the parser that reads the names for functions can easily be changed to handle custom variables too, by looking up names in a variable table passed to the eval method, such as a Map<String,Double> variables.Separate compilation and evaluation:What if, having added support for variables, you wanted to evaluate the same expression millions of times with changed variables, without parsing it every time? It\'s possible. First define an interface to use to evaluate the precompiled expression:Now change all the methods that return doubles, so instead they return an instance of that interface. Java 8\'s lambda syntax works great for this. Example of one of the changed methods:That builds a recursive tree of Expression objects representing the compiled expression (an abstract syntax tree). Then you can compile it once and evaluate it repeatedly with different values:Different datatypes:Instead of double, you could change the evaluator to use something more powerful like BigDecimal, or a class that implements complex numbers, or rational numbers (fractions). You could even use Object, allowing some mix of datatypes in expressions, just like a real programming language. :)All code in this answer released to the public domain. Have fun!The correct way to solve this is with a lexer and a parser. You can write simple versions of these yourself, or those pages also have links to Java lexers and parsers.Creating a recursive descent parser is a really good learning exercise.HERE is another open source library on GitHub named EvalEx.Unlike the JavaScript engine this library is focused in evaluating mathematical expressions only. Moreover, the library is extensible and supports use of boolean operators as well as parentheses.You can also try the BeanShell interpreter:This article points to 3 different approaches, one which is JEXL from Apache and allows for scripts that include references to java objects.You can evaluate expressions easily if your Java application already accesses a database, without using any other JARs.Some databases require you to use a dummy table (eg, Oracle\'s "dual" table) and others will allow you to evaluate expressions without "selecting" from any table.For example, in Sql Server or Sqliteand in OracleThe advantage of using a DB is that you can evaluate many expressions at the same time. Also most DB\'s will allow you to use highly complex expressions and   will also have a number of extra functions that can be called as necessary.  However performance may suffer if many single expressions need to be evaluated individually, particularly when the DB is located on a network server.The following addresses the performance problem to some extent, by using a Sqlite in-memory database.    Here\'s a full working example in JavaOf course you could extend the above code to handle multiple calculations at the same time.To my university project I was looking for a parser / evaluator supporting both basic formulas and more complicated equations (especially iterated operators). I found very nice open source library for JAVA and .NET called mXparser. I will give a few examples to make some feeling on the syntax, for further instructions please visit project website (especially tutorial section).http://mathparser.org/http://mathparser.org/mxparser-tutorial/http://mathparser.org/api/And few examples1 - Simple furmula2 - User defined arguments and constants3 - User defined functions4 - IterationBest regardsIt seems like JEP should do the jobAnother way is to use Spring Expression Language or SpEL which does a whole lot more along with evaluating mathematical expressions therefore maybe slightly overkill. You do not have to be using Spring framework to use this expression library as it is stand-alone. Copying examples from SpEL\'s documentation: Read more concise SpEL examples here and the complete docs hereThis is another interesting alternative \nhttps://github.com/Shy-Ta/expression-evaluator-demoThe usage is very simple and gets the job done, for example:I think what ever way you do this it\'s going to involve a lot of conditional statements. But for single operations like in your examples you could limit it to 4 if statements with something like It gets a whole lot more complicated when you want to deal with multiple operations like "4+5*6".If you are trying to build a calculator then I\'d surgest passing each section of the calculation separatly (each number or operator) rather than as a single string.if we are going to implement it then we can can use the below algorithm :--While there are still tokens to be read in,1.1 Get the next token.\n1.2 If the token is:1.2.1 A number: push it onto the value stack.1.2.2 A variable: get its value, and push onto the value stack.1.2.3 A left parenthesis: push it onto the operator stack.1.2.4 A right parenthesis:1.2.5 An operator (call it thisOp):While the operator stack is not empty,\n1 Pop the operator from the operator stack.\n2 Pop the value stack twice, getting two operands.\n3 Apply the operator to the operands, in the correct order.\n4 Push the result onto the value stack.At this point the operator stack should be empty, and the value\nstack should have only one value in it, which is the final result.You might have a look at the Symja framework:Take note that definitively more complex expressions can be evaluated:This is actually complementing the answer given by @Boann. It has a slight bug which causes "-2 ^ 2" to give an erroneous result of -4.0. The problem for that is the point at which the exponentiation is evaluated in his. Just move the exponentiation to the block of parseTerm(), and you\'ll be all fine. Have a look at the below, which is @Boann\'s answer slightly modified. Modification is in the comments.How about something like this:and do the similar thing for every other mathematical operator accordingly .. It is possible to convert any expression string in infix notation to a postfix notation using Djikstra\'s shunting-yard algorithm. The result of the algorithm can then serve as input to the postfix algorithm with returns the result of the expression.I wrote an article about it here, with an implementation in javaIt\'s too late to answer but I came across same situation to evaluate expression in java, it might help someoneMVEL does runtime evaluation of expressions, we can write a java code in String to get it evaluated in this.Yet another option: https://github.com/stefanhaustein/expressionparserI have implemented this to have a simple but flexible option to permit both:The TreeBuilder linked above is part of a CAS demo package that does symbolic derivation. There is also a BASIC interpreter example and I have started to build a TypeScript interpreter using it.I have written my own method for similar problem. Its a recursive method.The method requires that your formulae/expression should have exactly one space between adjacent numbers/operands. In case your expression does not meet this requirement then you can easily format the expression first using string operations and then only use this method to calculate further. Following is an example of how to format the expression before passing it to evaluate method.And following is the implementation of this method.Try the following sample code using JDK1.6\'s Javascript engine with code injection handling.A Java class that can evaluate mathematical expressions: