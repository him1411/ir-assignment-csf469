I have seen two general practices to instantiate a new Fragment in an application:andThe second option makes use of a static method newInstance() and generally contains the following method.At first, I thought the main benefit was the fact that I could overload the newInstance() method to give flexibility when creating new instances of a Fragment - but I could also do this by creating an overloaded constructor for the Fragment.Did I miss something?What are the benefits of one approach over the other? Or is it just good practice?If Android decides to recreate your Fragment later, it\'s going to call the no-argument constructor of your fragment. So overloading the constructor is not a solution.With that being said, the way to pass stuff to your Fragment so that they are available after a Fragment is recreated by Android is to pass a bundle to the setArguments method.So, for example, if we wanted to pass an integer to the fragment we would use something like:And later in the Fragment onCreate() you can access that integer by using:This Bundle will be available even if the Fragment is somehow recreated by Android.Also note: setArguments can only be called before the Fragment is attached to the Activity.This approach is also documented in the android developer reference: https://developer.android.com/reference/android/app/Fragment.htmlThe only benefit in using the newInstance() that I see are the following:You will have a single place where all the arguments used by the fragment could be bundled up and you don\'t have to write the code below everytime you instantiate a fragment.Its a good way to tell other classes what arguments it expects to work faithfully(though you should be able to handle cases if no arguments are bundled in the fragment instance).So, my take is that using a static newInstance() to instantiate a fragment is a good practice.There is also another way:While @yydl gives a compelling reason on why the newInstance method is better:If Android decides to recreate your Fragment later, it\'s going to call\n  the no-argument constructor of your fragment. So overloading the\n  constructor is not a solution.it\'s still quite possible to use a constructor. To see why this is, first we need to see why the above workaround is used by Android.Before a fragment can be used, an instance is needed. Android calls YourFragment() (the no arguments constructor) to construct an instance of the fragment. Here any overloaded constructor that you write will be ignored, as Android can\'t know which one to use. In the lifetime of an Activity the fragment gets created as above and destroyed multiple times by Android. This means that if you put data in the fragment object itself, it will be lost once the fragment is destroyed.To workaround, android asks that you store data using a Bundle (calling setArguments()), which can then be accessed from YourFragment. Argument bundles are protected by Android, and hence are guaranteed to be persistent.One way to set this bundle is by using a static newInstance method:However, a constructor:can do exactly the same thing as the newInstance method.Naturally, this would fail, and is one of the reasons Android wants you to use the newInstance method:As further explaination, here\'s Android\'s Fragment Class:Note that Android asks that the arguments be set only at construction, and guarantees that these will be retained.EDIT: As pointed out in the comments by @JHH, if you are providing a custom constructor that requires some arguments, then Java won\'t provide your fragment with a no arg default constructor. So this would require you to define a no arg constructor, which is code that you could avoid with the newInstance factory method.EDIT: Android doesn\'t allow using an overloaded constructor for fragments anymore. You must use the newInstance method.I disagree with yydi answer saying:If Android decides to recreate your Fragment later, it\'s going to call\n  the no-argument constructor of your fragment. So overloading the\n  constructor is not a solution.I think it is a solution and a good one, this is exactly the reason it been developed by Java core language. Its true that Android system can destroy and recreate your Fragment. So you can do this:It will allow you to pull someInt from getArguments() latter on, even if the Fragment been recreated by the system. This is more elegant solution than static constructor.For my opinion static constructors are useless and should not be used. Also they will limit you if in the future you would like to extend this Fragment and add more functionality to the constructor. With static constructor you can\'t do this.Update:Android added inspection that flag all non-default constructors with an error.\nI recommend to disable it, for the reasons mentioned above.Since the questions about best practice, I would add, that very often good idea to use hybrid approach for creating fragment when working with some REST web servicesWe can\'t pass complex objects, for example some User model, for case of displaying user fragmentBut what we can do, is to check in onCreate that user!=null and if not - then bring him from data layer, otherwise - use existing.This way we gain both ability to recreate by userId in case of fragment recreation by Android and snappiness for user actions, as well as ability to create fragments by holding to object itself or only it\'s idSomething likes this:Best practice to instance fragments with arguments in android is to have static factory method in your fragment.You should avoid setting your fields with the instance of a fragment. Because whenever android system recreate your fragment, if it feels that the system needs more memory, than it will recreate your fragment by using constructor with no arguments.You can find more info about best practice to instantiate fragments with arguments here.setArguments() is useless. It only brings a mess.Best way to instantiate the fragment is use default Fragment.instantiate method or create factory method to instantiate the the fragment\n\nCaution: always create one empty constructor in fragment other while restoring fragment memory will throw run-time exception.I believe I have a much simpeler solution for this.