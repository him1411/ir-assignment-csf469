What\'s the fastest way to count the number of keys/properties of an object?  It it possible to do this without iterating over the object?  i.e. without doing(Firefox did provide a magic __count__ property, but this was removed somewhere around version 4.)To do this in any ES5-compatible environment, such as Node, Chrome, IE 9+, FF 4+, or Safari 5+:You could use this code:then you can do this in older browsers as well:If you are using Underscore.js you can use _.size (thanks @douwe):\n_.size(obj)Alternatively you can also use _.keys which might be clearer for some:\n_.keys(obj).length I highly recommend Underscore, its a tight library for doing lots of basic things. Whenever possible they match ECMA5 and defer to the native implementation.Otherwise I support @Avi\'s answer. I edited it to add a link to the MDC doc which includes the keys() method you can add to non-ECMA5 browsers.The standard Object implementation ( ES5.1 Object Internal Properties and Methods\n) does not require an Object to track its number of keys/properties, so there should be no standard way to determine the size of an Object without explicitly or implicitly iterating over its keys.So here are the most commonly used alternatives:Object.keys(obj).length; Works by internally iterating over the keys to compute a temporary array and returns its length.Many library-based examples elsewhere in this topic are usefull idioms in the context of their library. From a performance viewpoint, however, there is nothing to gain compared to a perfect no-library code since all those library methods actually encapsulate either a for-loop or ES5 Object.keys (native or shimmed). The slowest part of such a for-loop is generally the .hasOwnProperty() call, because of the function call overhead. So when I just want the number of entries of a JSON object, I just skip the .hasOwnProperty() call if I know that no code did nor will extend  Object.prototype. Otherwise, your code could be very slightly optimized by making k local (var k) and by using prefix-decrement operator (++count) instead of postfix.Another idea relies on caching the hasOwnProperty method:Whether this is faster or not on a given environment is a question of benchmarking. Very limited performance gain can be expected anyway.If you are actually running into a performance problem I would suggest wrapping the calls that add/remove properties to/from the object with a function that also increments/decrements an appropriately named (size?) property.You only need to calculate the initial number of properties once and move on from there. If there isn\'t an actual performance problem, don\'t bother. Just wrap that bit of code in a function getNumberOfProperties(object) and be done with it.I\'m not aware of any way to do this, however to keep the iterations to a minimum, you could try checking for the existance of __count__ and if it doesn\'t exist (ie not Firefox) then you could iterate over the object and define it for later use eg:This way any browser supporting __count__ would use that, and iterations would only be carried out for those which don\'t. If the count changes and you can\'t do this, you could always make it a function:This way anytime you reference myobj.__count__ the function will fire and recalculate.As stated by Avi Flax https://stackoverflow.com/a/4889658/1047014will do the trick for all enumerable properties on your object but to also include the non-enumerable properties you can instead use the Object.getOwnPropertyNames. Here\'s the difference:As stated here this has the same browser support as Object.keysHowever, in most cases, you might not want to include the nonenumerables in these type of operations, but it\'s always good to know the difference ;)To iterate on Avi Flax answer Object.keys(obj).length is correct for an object that doesnt have functions tied to itexample:versussteps to avoid this:do not put functions in an object that you want to count the number of keys inuse a seperate object or make a new object specifically for functions (if you want to count how many functions there are in the file using Object.keys(obj).length)also yes i used the _ or underscore module from nodejs in my example documentation can be found here http://underscorejs.org/ as well as its source on github and various other infoAnd finally a lodash implementation https://lodash.com/docs#size_.size(obj)For those who have Underscore.js included in their project you can do:or functional style:How I\'ve solved this problem is to build my own implementation of a basic list which keeps a record of how many items are stored in the object. Its very simple. Something like this:From: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/definePropertyObject.defineProperty(obj, prop, descriptor)You can either add it to all your objects:Or a single object:Example:Added that way, it won\'t be displayed in for..in loops:Output:Note: it does not work in < IE9 browsers.For those that have Ext JS 4 in their project you can do:The advantage of this is that it\'ll work on all Ext compatible browsers (IE6-IE8 included), however, I believe the running time is no better than O(n) though, as with other suggested solutions.I don\'t think this is possible (at least not without using some internals). And I don\'t think you would gain much by optimizing this.If jQuery above does not work, then tryGoogle Closure has a nice function for this... goog.object.getCount(obj)look at goog.Object Documentation