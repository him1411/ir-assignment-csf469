Consider the following code:What is the difference between the three types of casting (okay, the 3rd one is not a casting, but you get the intent). Which one should be preferred?Throws InvalidCastException if o is not a string. Otherwise, assigns o to s, even if o is null.Assigns null to s if o is not a string or if o is null. For this reason, you cannot use it with value types (the operator could never return null in that case). Otherwise, assigns o to s.Causes a NullReferenceException if o is null. Assigns whatever o.ToString() returns to s, no matter what type o is.Use 1 for most conversions - it\'s simple and straightforward. I tend to almost never use 2 since if something is not the right type, I usually expect an exception to occur. I have only seen a need for this return-null type of functionality with badly designed libraries which use error codes (e.g. return null = error, instead of using exceptions).3 is not a cast and is just a method invocation. Use it for when you need the string representation of a non-string object.It really depends on whether you know if o is a string and what you want to do with it. If your comment means that o really really is a string, I\'d prefer the straight (string)o cast - it\'s unlikely to fail.The biggest advantage of using the straight cast is that when it fails, you get an InvalidCastException, which tells you pretty much what went wrong.With the as operator, if o isn\'t a string, s is set to null, which is handy if you\'re unsure and want to test s:However, if you don\'t perform that test, you\'ll use s later and have a NullReferenceException thrown. These tend to be more common and a lot harder to track down once they happens out in the wild, as nearly every line dereferences a variable and may throw one. On the other hand, if you\'re trying to cast to a value type (any primitive, or structs such as DateTime), you have to use the straight cast - the as won\'t work.In the special case of converting to a string, every object has a ToString, so your third method may be okay if o isn\'t null and you think the ToString method might do what you want.If you already know what type it can cast to, use a C-style cast:Note that only with a C-style cast can you perform explicit type coercion.If you don\'t know whether it\'s the desired type and you\'re going to use it if it is, use as keyword:Note that as will not call any type conversion operators. It will only be non-null if the object is not null and natively of the specified type.Use ToString() to get a human-readable string representation of any object, even if it can\'t cast to string.The as keyword is good in asp.net when you use the FindControl method.This means you can operate on the typed variable rather then having to then cast it from object like you would with a direct cast:It\'s not a huge thing, but it saves lines of code and variable assignment, plus it\'s more readable\'as\' is based on \'is\', which is a keyword that checks at runtime if the object is polimorphycally compatible (basically if a cast can be made) and returns null if the check fails.These two are equivalent:Using \'as\':Using \'is\':On the contrary, the c-style cast is made also at runtime, but throws an exception if the cast cannot be made.Just to add an important fact:The \'as\' keyword only works with reference types. You cannot do:In those cases you have to use casting.2 is useful for casting to a derived type.Suppose a is an Animal:will get a fed with a minimum of casts. "(string)o" will result in an InvalidCastException as there\'s no direct cast."o as string" will result in s being a null reference, rather than an exception being thrown."o.ToString()" isn\'t a cast of any sort per-se, it\'s a method that\'s implemented by object, and thus in one way or another, by every class in .net that "does something" with the instance of the class it\'s called on and returns a string.Don\'t forget that for converting to string, there\'s also Convert.ToString(someType instanceOfThatType) where someType is one of a set of types, essentially the frameworks base types.According to experiments run on this page: http://www.dotnetguru2.org/sebastienros/index.php/2006/02/24/cast_vs_as(this page is having some "illegal referrer" errors show up sometimes, so just refresh if it does)Conclusion is, the "as" operator is normally faster than a cast. Sometimes by many times faster, sometimes just barely faster. I peronsonally thing "as" is also more readable. So, since it is both faster and "safer" (wont throw exception), and possibly easier to read, I recommend using "as" all the time. All given answers are good, if i might add something:\nTo directly use string\'s methods and properties (e.g. ToLower) you can\'t write:you can only write:but you could write instead:The as option is more readable (at least to my opinion).Is prefered, as it avoids the performance penalty of double casting.It seems the two of them are conceptually different.Direct CastingTypes don\'t have to be strictly related. It comes in all types of flavors. It feels like the object is going to be converted into something else.AS operator Types have a direct relationship. As in: It feels like the you are going to handle the object in a different way.Samples and ILWhen trying to get the string representation of anything (of any type) that could potentially be null, I prefer the below line of code. It\'s compact, it invokes ToString(), and it correctly handles nulls. If o is null, s will contain String.Empty.Since nobody mentioned it, the closest to instanceOf to Java by keyword is this:Use direct cast string s = (string) o; if in the logical context of your app string is the only valid type. With this approach, you will get InvalidCastException and implement the principle of Fail-fast. Your logic will be protected from passing the invalid type further or get NullReferenceException if used as operator.If the logic expects several different types cast string s = o as string; and check it on null or use is operator.New cool feature have appeared in C# 7.0 to simplify cast and check is a Pattern matching: