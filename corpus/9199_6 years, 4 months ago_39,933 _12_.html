What is the difference between Task.WaitAll() and TaskEx.WhenAll() from the Async CTP ?\nCan you provide some sample code to illustrate the different use cases ?Task.WaitAll blocks the current thread until everything has completed.TaskEx.WhenAll returns a task which represents the action of waiting until everything has completed.That means that from an async method, you can use:... which means your method will continue when everything\'s completed, but you won\'t tie up a thread to just hang around until that time.While JonSkeet\'s answer explains the difference in a typically excellent way for me the biggest practical difference is exception handling.  Task.WaitAll throws an AggregateException when any of the tasks throws and you can examine all thrown exceptions. The await in await Task.WhenAll unwraps the AggregateException and \'returns\' only the first exception.When the program below executes with await Task.WhenAll(taskArray) the output is as follows.When the program below is executed with Task.WaitAll(taskArray) the output is as follows.The program:As an example of the difference -- if you have a task the does something with the UI thread (e.g. a task that represents an animation in a Storyboard) if you Task.WaitAll() then the UI thread is blocked and the UI is never updated.  if you use await Task.WhenAll() then the UI thread is not blocked, and the UI will be updated.Taking from @mayu answer, here is a way of getting the AggregateException when using Task.WhenAll.