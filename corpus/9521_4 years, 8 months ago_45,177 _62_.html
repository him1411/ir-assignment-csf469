I\'ve been hereand plenty of URLs that I did not copy, some on SO, some on other sites, back when I thought\nI\'d have the solution quickly.The forever-recurring question is this: With Windows 7, 32-bit Python 2.7.3, how do I solve this "Attempted relative import in non-package" message?  I built an exact replica of the package on pep-0328:I did make functions named spam and eggs in their appropriate modules.  Naturally, it didn\'t work.  The answer is apparently in the 4th URL I listed, but it\'s all alumni to me. There was this response on one of the URLs I visited:Relative imports use a module\'s name attribute to determine that module\'s position in the package hierarchy. If the module\'s name does not contain any package information (e.g. it is set to \'main\') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.The above response looks promising, but it\'s all hieroglyphs to me.  So my question, how do I make Python not return to me "Attempted relative import in non-package"? has an answer that involves -m, supposedly.Can somebody please tell me why Python gives that error message, what it Means by non-package!, why and how do you define a \'package\', and the precise answer put in terms easy enough for a kindergartener to understand. Edit: The imports were done from the console.Script vs. ModuleHere\'s an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  Just knowing what directory a file is in does not determine what package Python thinks it is in.  That depends, additionally, on how you load the file into Python (by running or by importing).There are two ways to load a Python file: as the top-level script, or as a \nmodule.  A file is loaded as the top-level script if you execute it directly, for instance by typing python myfile.py on the command line.  It is loaded as a module if you do python -m myfile, or if it is loaded when an import statement is encounted inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.NamingWhen a file is loaded, it is given a name (which is stored in its __name__ attribute).  If it was loaded as the top-level script, its name is __main__.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.So for instance in your example:if you imported moduleX (note: imported, not directly executed), its name would be package.subpackage1.moduleX.  If you imported moduleA, its name would be package.moduleA.  However, if you directly run moduleX from the command line, its name will instead be __main__, and if you directly run moduleA from the command line, its name will be __main__.  When a module is run as the top-level script, it loses its normal name and its name is instead __main__.Accessing a module NOT through its containing packageThere is an additional wrinkle: the module\'s name depends on whether it was imported "directly" from the directory it is in, or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory package/subpackage1 and then do import moduleX, the name of moduleX will just be moduleX, and not package.subpackage1.moduleX.  This is because Python adds the current directory to its search path on startup; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module\'s name.A special case is if you run the interpreter interactively (e.g., just type python and start entering Python code on the fly).  In this case the name of that interactive session is __main__.Now here is the crucial thing for your error message: if a module\'s name has no dots, it is not considered to be part of a package.  It doesn\'t matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.Now look at the quote you included in your question:Relative imports use a module\'s name attribute to determine that module\'s position in the package hierarchy. If the module\'s name does not contain any package information (e.g. it is set to \'main\') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.Relative imports...Relative imports use the module\'s name to determine where it is in a package.  When you use a relative import like from .. import foo, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module\'s name is package.subpackage1.moduleX, then ..moduleA would mean package.moduleA.  For a from .. import to work, the module\'s name must have at least as many dots as there are in the import statement.... are only relative in a packageHowever, if your module\'s name is __main__, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use from .. import statements inside it.  If you try to do so, you will get the "relative-import in non-package" error.Scripts can\'t import relativeWhat you probably did is you tried to run moduleX or the like from the command line.  When you did this, its name was set to __main__, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory "too early" without realizing it is part of a package.Also remember that when you run the interactive interpreter, the "name" of that interactive session is always __main__.  Thus you cannot do relative imports directly from an interactive session.  Relative imports are only for use within module files.Two solutions:If you really do want to run moduleX directly, but you still want it to be considered part of a package, you can do python -m package.subpackage.moduleX.  The -m tells Python to load it a s a module, not as the top-level script.Or perhaps you don\'t actually want to run moduleX, you just want to run some other script, say myfile.py, that uses functions inside moduleX.  If that is the case, put myfile.py somewhere else --- not inside the package directory -- and run it.  If inside myfile.py you do things like from package.moduleA import spam, it will work fine.NotesFor either of these solutions, the package directory (package in your example) must be accessible from the Python module search path (sys.path).  If it is not, you will not be able to use anything in the package reliably at all.since Python 2.6, the module\'s "name" for package-resolution purposes is determined not just by its __name__ attributes but also by the __package__ attribute.  That\'s why I\'m avoiding using the explicit symbol __name__ to refer to the module\'s "name".  Since Python 2.6 a module\'s "name" is effectively __package__ + \'.\' + __name__, or just __name__ if __package__ is None.)Here is one solution that I would not recommend, but might be useful in some situations where modules were simply not generated:__name__ changes depending on whether the code in question is run in the global namespace or as part of an imported module.If the code is not running in the global space, __name__ will be the name of the module. If it is running in global namespace -- for example, if you type it into a console, or run the module as a script using python.exe yourscriptnamehere.py then __name__ becomes "__main__".  You\'ll see a lot of python code with  if __name__ == \'__main__\' is used to test whether the code is being run from the global namespace \xe2\x80\x93 that allows you to have a module that doubles as a script. Did you try to do these imports from the console? Here\'s a general recipe, modified to fit as an example, that I am using right now for dealing with Python libraries written as packages, that contain interdependent files, where I want to be able to test parts of them piecemeal.  Let\'s call this lib.foo and say that it needs access to lib.fileA for functions f1 and f2, and lib.fileB for class Class3.I have included a few print calls to help illustrate how this works.  In practice you would want to remove them (and maybe also the from __future__ import print_function line).This particular example is too simple to show when we really need to insert an entry into sys.path.  (See Lars\' answer for a case where we do need it, when we have two or more levels of package directories, and then we use os.path.dirname(os.path.dirname(__file__))\xe2\x80\x94but it doesn\'t really hurt here either.)  It\'s also safe enough to do this without the if _i in sys.path test.  However, if each imported file inserts the same path\xe2\x80\x94for instance, if both fileA and fileB want to import utilities from the package\xe2\x80\x94this clutters up sys.path with the same path many times, so it\'s nice to have the if _i not in sys.path in the boilerplate.The idea here is this (and note that these all function the same across python2.7 and python 3.x):If run as import lib or from lib import foo as a regular package import from ordinary code, __package is lib and __name__ is lib.foo.  We take the first code path, importing from .fileA, etc.If run as python lib/foo.py, __package__ will be None and __name__ will be __main__.We take the second code path.  The lib directory will already be in sys.path so there is no need to add it.  We import from fileA, etc.If run within the lib directory as python foo.py, the behavior is the same as for case 2.If run within the lib directory as python -m foo, the behavior is similar to cases 2 and 3.  However, the path to the lib directory is not in sys.path, so we add it before importing.  The same applies if we run Python and then import foo.(Since . is in sys.path, we don\'t really need to add the absolute version of the path here.  This is where a deeper package nesting structure, where we want to do from ..otherlib.fileC import ..., makes a difference.  If you\'re not doing this, you can omit all the sys.path manipulation entirely.)There is still a quirk.  If you run this whole thing from outside:or:the behavior depends on the contents of lib/__init__.py.  If that exists and is empty, all is well:But if lib/__init__.py itself imports routine so that it can export routine.name directly as lib.name, you get:That is, the module gets imported twice, once via the package and then again as __main__ so that it runs your main code.  Python 3.6 and later warn about this:The warning is new, but the warned-about behavior is not.  It is part of what some call the double import trap.  (For additional details see issue 27487.)  Nick Coghlan says:This next trap exists in all current versions of Python, including 3.3, and can be summed up in the following general guideline: "Never add a package directory, or any directory inside a package, directly to the Python path".Note that while we violate that rule here, we do it only when the file being loaded is not being loaded as part of a package, and our modification is specifically designed to allow us to access other files in that package.  (And, as I noted, we probably shouldn\'t do this at all for single level packages.)  If we wanted to be extra-clean, we might rewrite this as, e.g.:That is, we modify sys.path long enough to achieve our imports, then put it back the way it was (deleting one copy of _i if and only if we added one copy of _i).I had a similar problem where I didn\'t want to change the Python module search \npath and needed to load a module relatively from a script (in spite of "scripts can\'t import relative with all" as BrenBarn explained nicely above).So I used the following hack. Unfortunately, it relies on the imp module that \nbecame deprecated since version 3.4 to be dropped in favour of importlib.\n(Is this possible with importlib, too? I don\'t know.) Still, the hack works for now.Example for accessing members of moduleX in subpackage1 from a script residing in the subpackage2 folder:A cleaner approach seems to be to modify the sys.path used for loading modules as mentioned by Federico.