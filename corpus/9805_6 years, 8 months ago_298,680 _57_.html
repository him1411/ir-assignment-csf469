I\'m writing a REST web app (NetBeans 6.9, JAX-RS, TopLink Essentials) and trying to return JSON and HTTP status code. I have code ready and working that returns JSON when the HTTP GET method is called from the client. Essentially:But I also want to return an HTTP status code (500, 200, 204, etc.) along with the JSON data.I tried to use HttpServletResponse:But this made the browser think it\'s a "real" 500 so the output web page was a regular HTTP 500 error page.I want to return an HTTP status code so that my client-side JavaScript can handle some logic depending on it (to e.g. display the error code and message on an HTML page). Is this possible or should HTTP status codes not be used for such thing?Here\'s an example:Take a look at the Response class.  Note that you should always specify a content type, especially if you are passing multiple content types, but if every message will be represented as JSON, you can just annotate the method with @Produces("application/json")There are several use cases for setting HTTP status codes in a REST web service, and at least one was not sufficiently documented in the existing answers (i.e. when you are using auto-magical JSON/XML serialization using JAXB, and you want to return an object to be serialized, but also a status code different than the default 200).So let me try and enumerate the different use cases and the solutions for each one:The most common use case when you want to return a status code different than 200 OK is when an error occurs.For example:In that case, I think that the cleanest way to handle the problem is to throw an exception. This exception will be handled by an ExceptionMapper, that will translate the exception into a response with the appropriate error code.You can use the default ExceptionMapper that comes pre-configured with Jersey (and I guess it\'s the same with other implementations) and throw any of the existing sub-classes of javax.ws.rs.WebApplicationException. These are pre-defined exception types that are pre-mapped to different error codes, for example:Etc. You can find the list here: APIAlternatively, you can define your own custom exceptions and ExceptionMapper classes, and add these mappers to Jersey by the mean of the @Provider annotation (source of this example):Provider :Note: you can also write ExceptionMappers for existing exception types that you use.Another way to set a status code is to use a Response builder to build a response with the intended code.In that case, your method\'s return type must be javax.ws.rs.core.Response. This is described in various other responses such as hisdrewness\' accepted answer and looks like this :Another case when you want to set the return status is when the operation was successful, but you want to return a success code different than 200, along with the content that you return in the body.A frequent use case is when you create a new entity (POST request) and want to return info about this new entity or maybe the entity itself, together with a 201 Created status code.One approach is to use the response object just like described above and set the body of the request yourself. However, by doing this you loose the ability to use the automatic serialization to XML or JSON provided by JAXB.This is the original method returning an entity object that will be serialized to JSON by JAXB:This will return a JSON representation of the newly created user, but the return status will be 200, not 201.Now the problem is if I want to use the Response builder to set the return code, I have to return a Response object in my method. How do I still return the User object to be serialized?One approach to solve this is to obtain a servlet request object and set the response code manually ourselves, like demonstrated in Garett Wilson\'s answer :The method still returns an entity object and the status code will be 201.Note that to make it work, I had to flush the response. This is an unpleasant resurgence of low-level Servlet API code in our nice JAX_RS resource, and much worse, it causes the headers to be unmodifiable after this because they were already sent on the wire.The best solution, in that case, is to use the Response object and set the entity to be serialized on this response object. It would be nice to make the Response object generic to indicate the type of the payload entity in that case, but is not the currently the case.In that case, we use the created method of the Response builder class in order to set the status code to 201. We pass the entity object (user) to the response via the entity() method.The result is that the HTTP code is 401 as we wanted, and the body of the response is the exact same JSON as we had before when we just returned the User object. It also adds a location header.The Response class has a number of builder method for different statuses (stati ?) such as :Response.accepted()\nResponse.ok()\nResponse.noContent()\nResponse.notAcceptable()NB: the hateoas object is a helper class that I developed to help generate resources URIs. You will need to come up with your own mechanism here ;)That\'s about it.I hope this lengthy response helps somebody :)The answer by hisdrewness will work, but it modifies the whole approach to letting a provider such as Jackson+JAXB automatically convert your returned object to some output format such as JSON. Inspired by an Apache CFX post (which uses a CFX-specific class) I\'ve found one way to set the response code that should work in any JAX-RS implementation: inject an HttpServletResponse context and manually set the response code. For example, here is how to set the response code to CREATED when appropriate.Improvement: After finding another related answer, I learned that one can inject the HttpServletResponse as a member variable, even for singleton service class (at least in RESTEasy)!! This is a much better approach than polluting the API with implementation details. It would look like this:If you like to keep your resource layer clean of Response objects, then I recommend you use @NameBinding and binding to implementations of ContainerResponseFilter.Here\'s the meat of the annotation:Here\'s the meat of the filter:And then the implementation on your resource simply becomes:JAX-RS has support for standard/custom HTTP codes.  See ResponseBuilder and ResponseStatus, for example:http://jackson.codehaus.org/javadoc/jax-rs/1.0/javax/ws/rs/core/Response.ResponseBuilder.html#status%28javax.ws.rs.core.Response.Status%29Keep in mind that JSON information is more about the data associated with the resource/application.  The HTTP codes are more about the status of the CRUD operation being requested.  (at least that is how it\'s supposed to be in REST-ful systems)If your WS-RS needs raise an error why not just use the WebApplicationException?In case you want to change the status code because of an exception, with JAX-RS 2.0 you can implement an ExceptionMapper like this. This handles this kind of exception for the whole app.Please look at the example here, it best illustrates the problem and how it is solved in the latest (2.3.1) version of Jersey. https://jersey.java.net/documentation/latest/representations.html#d0e3586It basically involves defining a custom Exception and keeping the return type as the entity. When there is an error, the exception is thrown, otherwise, you return the POJO.I found it very useful to build also a json message with repeated code, like this:I\'m not using JAX-RS, but I\'ve got a similar scenario where I use:Also, notice that by default Jersey will override the response body in case of an http code 400 or more.In order to get your specified entity as the response body, try to add the following init-param to your Jersey  in your web.xml configuration file :I\'m using jersey 2.0 with message body readers and writers.  I had my method return type as a specific entity which was also used in the implementation of the message body writer and i was returning the same pojo, a SkuListDTO.\n    @GET\n    @Consumes({"application/xml", "application/json"})\n    @Produces({"application/xml", "application/json"})\n    @Path("/skuResync")all i changed was this,  I left the writer implementation alone and it still worked.