How can I check if a Python object is a string (either regular or Unicode)?Use isinstance(obj, basestring) for an object-to-test obj.Docs.To check if an object o is a string type of a subclass of a string type:because both str and unicode are subclasses of basestring.To check if the type of o is exactly str:To check if o is an instance of str or any subclass of str:The above also work for Unicode strings if you replace str with unicode.However, you may not need to do explicit type checking at all.  "Duck typing" may fit your needs.  See http://docs.python.org/glossary.html#term-duck-typing.See also What\xe2\x80\x99s the canonical way to check for type in python?In Python 3.x basestring is not available anymore, as str is the sole string type (with the semantics of Python 2.x\'s unicode).So the check in Python 3.x is just:This follows the fix of the official 2to3 conversion tool: converting basestring to str.If you want to check with no regard for Python version (2.x vs 3.x), use six (PyPI) and it\'s string_types attribute:Within six (a very light-weight single-file module), it\'s simply doing this:In order to check if your variable is something you could go like:The output of isistance will give you a boolean True or False value so you can adjust accordingly.\nYou can check the expected acronym of your value by initially using:\n    type(s)\nThis will return you type \'str\' so you can use it in the isistance function.I found this ans more pythonic:since type objects are singleton, is can be used to do the compareI might deal with this in the duck-typing style, like others mention.  How do I know a string is really a string? well, obviously by converting it to a string!If the arg is already a string or unicode type, real_word will hold its value unmodified.  If the object passed implements a __unicode__ method, that is used to get its unicode representation.  If the object passed cannot be used as a string, the unicode builtin raises an exception.If one wants to stay away from explicit type-checking (and there are good reasons to stay away from it), probably the safest part of the string protocol to check is:It won\'t iterate through an iterable or iterator, it won\'t call a list-of-strings a string and it correctly detects a stringlike as a string.Of course there are drawbacks. For example, str(maybe_string) may be a heavy calculation. As so often, the answer is it depends.will be True if your object is indeed a string-type. \'str\' is reserved word.my apologies,\nthe correct answer is using \'basestring\' instead of \'str\' in order of it to include unicode strings as well - as been noted above by one of the other responders.You can test it by concatenating with an empty string:Edit:Correcting my answer after comments pointing out that this fails with listsThis evening I ran into a situation in which I thought I was going to have to check against the str type, but it turned out I did not. My approach to solving the problem will probably work in many situations, so I offer it below in case others reading this question are interested (Python 3 only). Some tests: For a nice duck-typing approach for string-likes that has the bonus of working with both Python 2.x and 3.x:wisefish was close with the duck-typing before he switched to the isinstance approach, except that += has a different meaning for lists than + does.from \nEDX - online course\nMITx: 6.00.1x Introduction to Computer Science and Programming Using Python