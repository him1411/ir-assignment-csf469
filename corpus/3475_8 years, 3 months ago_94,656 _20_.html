Programming in Android, most of the text values are expected in CharSequence.Why is that? What is the benefit, and what are the main impacts of using CharSequence over String?What are the main differences, and what issues are expected, while using them, and converting from one to another?Strings are CharSequences, so you can just use Strings and not worry. Android is merely trying to be helpful by allowing you to also specify other CharSequence objects, like StringBuffers.I believe it is best to use CharSequence. The reason is that String implements CharSequence, therefore you can pass a String into a CharSequence, HOWEVER you cannot pass a CharSequence into a String, as CharSequence doesn\'t not implement String. ALSO, in Android the EditText.getText() method returns an Editable, which also implements CharSequence and can be passed easily into one, while not easily into a String. CharSequence handles all!This class diagram may help you see the big picture of string types in Java 7/8. I\'m not sure if all of these are present in Android, but the overall context may still prove useful to you.Also, note the comments made on the accepted Answer. The CharSequence interface was retrofitted onto existing class structures, so there are some important subtleties (equals() & hashCode()). Notice the various versions of Java (1, 2, 4 & 5) tagged on the classes/interfaces\xe2\x80\x94quite a bit of churn over the years. Ideally CharSequence would have been in place from the beginning, but such is life.In general using an interface allows you to vary the implementation with minimal collateral damage. Although java.lang.String are super popular it may be possible that in certain contexts one may want to use another implementation. By building the API around CharSequences rather than Strings the code gives one the opportunity to do that.This is almost certainly performance reasons. For example, imagine a parser that goes through a 500k ByteBuffer containing strings.There are 3 approaches to returning the string content:Build a String[] at parse time, one character at a time. This will take a noticeable amount of time. We can use == instead of .equals to compare cached references.Build an int[] with offsets at parse time, then dynamically build String when a get() happens. Each String will be a new object, so no caching returned values and using ==Build a CharSequence[] at parse time. Since no new data is stored (other than offsets into the byte buffer), the parsing is much lower that #1. At get time, we don\'t need to build a String, so get performance is equal to #1 (much better than #2), as we\'re only returning a reference to an existing object.In addition to the processing gains you get using CharSequence, you also reduce the memory footprint by not duplicating data. For example, if you have a buffer containing 3 paragraphs of text, and want to return either all 3 or a single paragraph, you need 4 Strings to represent this. Using CharSequence you only need 1 buffer with the data, and 4 instances of a CharSequence implementation that tracks the start and length.An issue that DO arise in practical Android code is that comparing them with CharSequence.equals is valid but does not necessarily work as intended.Comparison should be made byCharSequence is an interface and String implements it. You can instantiate a String but you could not do that for CharSequence since it is an interface. You can find other implementations in CharSequence in the official Java website. CharSequence is a readable sequence of char values which implements String. it has 4 methods    Please refer documentation CharSequence documentation