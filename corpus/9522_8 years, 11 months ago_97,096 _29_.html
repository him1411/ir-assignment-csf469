If I am passing an object to a method, why should I use the ref keyword? Isn\'t this the default behaviour anyway?For example:The output is "Bar" which means that the object was passed as a reference.Pass a ref if you want to change what the object is:After calling DoSomething, t does not refer to the original new TestRef, but refers to a completely different object.This may be useful too if you want to change the value of an immutable object, e.g. a string. You cannot change the value of a string once it has been created. But by using a ref, you could create a function that changes the string for another one that has a different value.Edit: As other people have mentioned. It is not a good idea to use ref unless it is needed. Using ref gives the method freedom to change the argument for something else, callers of the method will need to be coded to ensure they handle this possibility.Also, when the parameter type is an object, then object variables always act as references to the object. This means that when the ref keyword is used you\'ve got a reference to a reference. This allows you to do things as described in the example given above. But, when the parameter type is a primitive value (e.g. int), then if this parameter is assigned to within the method, the value of the argument that was passed in will be changed after the method returns:You need to distinguish between "passing a reference by value", and "passing a parameter/argument by reference".I\'ve written a reasonably long article on the subject to avoid having to write carefully each time this comes up on newsgroups :)In .NET when you pass any parameter to a method, a copy is created. In value types means that any modification you make to the value is at the method scope, and is lost when you exit the method.When passing a Reference Type, a copy is also made, but it is a copy of a reference, i.e. now you have TWO references in memory to the same object. So, if you use the reference to modify the object, it gets modified. But if you modify the reference itself - we must remember it is a copy - then any changes are also lost upon exiting the method.As people have said before, an assignment is a modification of the reference, thus is lost:The methods above does not modifies the original object.A little modification of your exampleSince TestRef is a class (which are reference objects), you can change the contents inside t without passing it as a ref. However, if you pass t as a ref, TestRef can change what the original t refers to. i.e. make it point to a different object.With ref you can write:And t will be changed after the method has completed.Think of variables (e.g. foo) of reference types (e.g. List<T>) as holding object identifiers of the form "Object #24601".  Suppose the statement foo = new List<int> {1,5,7,9}; causes foo to hold "Object #24601" (a list with four items).  Then calling foo.Length will ask Object #24601 for its length, and it will respond 4, so foo.Length will equal 4.If foo is passed to a method without using ref, that method might make changes to Object #24601.  As a consequence of such changes, foo.Length might no longer equal 4.  The method itself, however, will be unable to change foo, which will continue to hold "Object #24601".Passing foo as a ref parameter will allow the called method to make changes not just to Object #24601, but also to foo itself.  The method might create a new Object #8675309 and store a reference to that in foo.  If it does so, foo would no longer hold "Object #24601", but instead "Object #8675309".In practice, reference-type variables don\'t hold strings of the form "Object #8675309"; they don\'t even hold anything that can meaningfully converted into a number.  Even though each reference-type variable will hold some bit pattern, there is no fixed relationship between the bit patterns stored in such variables and the objects they identify.  There is no way code could extract information from an object or a reference to it, and later determine whether another reference identified the same object, unless the code either held or knew of a reference that identified the original object.By using the ref keyword with reference types you are effectively passing a reference to the reference. In many ways it\'s the same as using the out keyword but with the minor difference that there\'s no guarantee that the method will actually assign anything to the ref\'ed parameter. This is like passing a pointer to a pointer in C.  In .NET this will allow you to change what the original T refers to, personally though I think if you are doing that in .NET you have probably got a design issue!If you\'re passing a value, however, things are different. You can force a value to be passed by reference. This allows you to pass an integer to a method, for example, and have the method modify the integer on your behalf.Ref denotes whether the function can get its hands on the object itself, or only on its value.Passing by reference is not bound to a language; it\'s a parameter binding strategy next to pass-by-value, pass by name, pass by need etc...A sidenote: the class name TestRef is a hideously bad choice in this context ;).ref mimics (or behaves as) a global area just for two scopes: