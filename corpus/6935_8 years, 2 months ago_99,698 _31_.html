I have this multi-line string (quotes included):How would I assign it to a variable using a heredoc in Bash?I need to preserve newlines.I don\'t want to escape the characters in the string, that would be annoying...You can avoid a useless use of cat and handle mismatched quotes better with this:If you don\'t quote the variable when you echo it, newlines are lost. Quoting it preserves them:If you want to use indentation for readability in the source code, use a dash after the less-thans. The indentation must be done using only tabs (no spaces).If, instead, you want to preserve the tabs in the contents of the resulting variable, you need to remove tab from IFS. The terminal marker for the here doc (EOF) must not be indented.Tabs can be inserted at the command line by pressing Ctrl-V Tab. If you are using an editor, depending on which one, that may also work or you may have to turn off the feature that automatically converts tabs to spaces.Use $() to assign the output of cat to your variable like this:Making sure to delimit END_HEREDOC with single-quotes.Thanks to @ephemient for the answer.this is variation of Dennis method, looks more elegant in the scripts.function definition:usage:enjoydoesn\'t work because you are redirecting stdin to something that doesn\'t care about it, namely the assignmentworks, but there\'s a back-tic in there that may stop you from using this. Also, you should really avoid using backticks, it\'s better to use the command substitution notation $(..).Adding comment here as an answer since I don\'t have enough rep points to comment on your question text.There is still no solution that preserves newlines.This is not true - you\'re probably just being misled by the behaviour of echo:echo $VAR # strips newlinesecho "$VAR" # preserves newlinesAn array is a variable, so in that case mapfile will workThen you can print like thisBranching off Neil\'s answer, you often don\'t need a var at all, you can use a function in much the same way as a variable and it\'s much easier to read than the inline or read-based solutions.I found myself having to read a string with NULL in it, so here is a solution that will read anything you throw at it.  Although if you actually are dealing with NULL, you will need to deal with that at the hex level.$ cat > read.dd.shProof:HEREDOC example (with ^J, ^M, ^I):Thanks to dimo414\'s answer, this shows how his great solution works, and shows that you can have quotes and variables in the text easily as well: