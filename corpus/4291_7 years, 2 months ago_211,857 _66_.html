I\'d like to return a string from a Bash function.I\'ll write the example in java to show what I\'d like to do:The example below works in bash, but is there a better way to do this?There is no better way I know of. Bash knows only status codes (integers) and strings written to the stdout.You could have the function take a variable as the first arg and modify the variable with the string you want to return.Prints "foo bar rab oof".Edit: added quoting in the appropriate place to allow whitespace in string to address @Luca Borrione\'s comment.Edit: As a demonstration, see the following program. This is a general-purpose solution: it even allows you to receive a string into a local variable.This prints:Edit: demonstrating that the original variable\'s value is available in the function, as was incorrectly criticized by @Xichen Li in a comment.This gives output:All answers above ignore what has been stated in the man page of bash.Example codeAnd outputAlso under pdksh and ksh this script does the same!Like bstpierre above, I use and recommend the use of explicitly naming output variables:\nNote the use of quoting the $. This will avoid interpreting content in $result as shell special characters. I have found that this is an order of magnitude faster than the result=$(some_func "arg1") idiom of capturing an echo. The speed difference seems even more notable using bash on MSYS where stdout capturing from function calls is almost catastrophic.It\'s ok to send in a local variables since locals are dynamically scoped in bash:Bash, since version 4.3, feb 2014(?), has explicit support for reference variables or name references (namerefs), beyond "eval", with the same beneficial performance and indirection effect, and which may be clearer in your scripts and also harder to "forget to \'eval\' and have to fix this error":and also:PARAMETERSA variable can be assigned the nameref attribute using the -n option to the\n     declare or local builtin commands (see the descriptions of declare and local\n     below) to create a nameref, or a reference to another variable.  This allows\n     variables to be manipulated indirectly.  Whenever the nameref variable is\xe2\x8b\x85\n     referenced or assigned to, the operation is actually performed on the variable\n     specified by the nameref variable\'s value.  A nameref is commonly used within\n     shell functions to refer to a variable whose name is passed as an argument to\xe2\x8b\x85\n     the function.  For instance, if a variable name is passed to a shell function\n     as its first argument, runninginside the function creates a nameref variable ref whose value is the variable\n     name passed as the first argument.  References and assignments to ref are\n     treated as references and assignments to the variable whose name was passed as\xe2\x8b\x85\n     $1.  If the control variable in a for loop has the nameref attribute, the list\n     of words can be a list of shell variables, and a name reference will be\xe2\x8b\x85\n     established for each word in the list, in turn, when the loop is executed.\n     Array variables cannot be given the -n attribute.  However, nameref variables\n     can reference array variables and subscripted array variables.  Namerefs can be\xe2\x8b\x85\n     unset using the -n option to the unset builtin.  Otherwise, if unset is executed\n     with the name of a nameref variable as an argument, the variable referenced by\xe2\x8b\x85\n     the nameref variable will be unset.For example (EDIT 2: (thank you Ron) namespaced (prefixed) the function-internal variable name, to minimize external variable clashes, which should finally answer properly, the issue raised in the comments by Karsten):and testing this example:Note that the bash "declare" builtin, when used in a function, makes the declared variable "local" by default, and "-n" can also be used with "local".I prefer to distinguish "important declare" variables from "boring local" variables, so using "declare" and "local" in this way acts as documentation.EDIT 1 - (Response to comment below by Karsten) - I cannot add comments below any more, but Karsten\'s comment got me thinking, so I did the following test which WORKS FINE, AFAICT - Karsten if you read this, please provide an exact set of test steps from the command line, showing the problem you assume exists, because these following steps work just fine:(I ran this just now, after pasting the above function into a bash term - as you can see, the result works just fine.)You could also capture the function output:Looks weird, but is better than using global variables IMHO. Passing parameters works as usual, just put them inside the braces or backticks.As previously mentioned, the "correct" way to return a string from a function is with command substitution.  In the event that the function also needs to output to console (as @Mani mentions above), create a temporary fd in the beginning of the function and redirect to console.  Close the temporary fd before returning your string.executing script with no params produces...hope this helps people-AndyYou could use a global variable:This givesThe most straightforward and robust solution is to use command substitution, as other people wrote:The downside is performance as this requires a separate process.The other technique suggested in this topic, namely passing the name of a variable to assign to as an argument, has side effects, and I wouldn\'t recommend it in its basic form. The problem is that you will probably need some variables in the function to calculate the return value, and it may happen that the name of the variable intended to store the return value will interfere with one of them:You might, of course, not declare internal variables of the function as local, but you really should always do it as otherwise you may, on the other hand, accidentally overwrite an unrelated variable from the parent scope if there is one with the same name.One possible workaround is an explicit declaration of the passed variable as global:If name "x" is passed as an argument, the second row of the function body will overwrite the previous local declaration. But the names themselves might still interfere, so if you intend to use the value previously stored in the passed variable prior to write the return value there, be aware that you must copy it into another local variable at the very beginning; otherwise the result will be unpredictable!\nBesides, this will only work in the most recent version of BASH, namely 4.2. More portable code might utilize explicit conditional constructs with the same effect:Perhaps the most elegant solution is just to reserve one global name for function return values and\nuse it consistently in every function you write.To illustrate my comment on Andy\'s answer, with additional file descriptor manipulation to avoid use of /dev/tty:Still nasty, though.The way you have it is the only way to do this without breaking scope. Bash doesn\'t have a concept of return types, just exit codes and file descriptors (stdin/out/err, etc)Addressing Vicky Ronnen\'s head up, considering the following code:\nwill giveMaybe the normal scenario is to use the syntax used in the test_inside_a_func function, thus you can use both methods in the majority of cases, although capturing the output is the safer method always working in any situation, mimicking the returning value from a function that you can find in other languages, as Vicky Ronnen correctly pointed out.The options have been all enumerated, I think. Choosing one may come down to a matter of the best style for your particular application, and in that vein, I want to offer one particular style I\'ve found useful. In bash, variables and functions are not in the same namespace. So, treating the variable of the same name as the value of the function is a convention that I find minimizes name clashes and enhances readability, if I apply it rigorously. An example from real life:And, an example of using such functions:As you can see, the return status is there for you to use when you need it, or ignore if you don\'t. The "returned" variable can likewise be used or ignored, but of course only after the function is invoked.Of course, this is only a convention. You are free to fail to set the associated value before returning (hence my convention of always nulling it at the start of the function) or to trample its value by calling the function again (possibly indirectly).  Still, it\'s a convention I find very useful if I find myself making heavy use of bash functions.As opposed to the sentiment that this is a sign one should e.g. "move to perl", my philosophy is that conventions are always important for managing the complexity of any language whatsoever.You can echo a string, but catch it by piping (|) the function to something else.You can do it with expr, though ShellCheck reports this usage as deprecated.In my programs, by convention, this is what the pre-existing $REPLY variable is for, which read uses for that exact purpose.This echoesBut to avoid conflicts, any other global variable will do.If that isn\xe2\x80\x99t enough, I recommend Markarian451\xe2\x80\x99s solution.They key problem of any \'named output variable\' scheme where the caller can pass in the variable name (whether using eval or declare -n) is inadvertent aliasing, i.e. name clashes: From an encapsulation point of view, it\'s awful to not be able to add or rename a local variable in a function without checking ALL the function\'s callers first to make sure they\'re not wanting to pass that same name as the output parameter. (Or in the other direction, I don\'t want to have to read the source of the function I\'m calling just to make sure the output parameter I intend to use is not a local in that function.)The only way around that is to use a single dedicated output variable like REPLY (as suggested by Evi1M4chine) or a convention like the one suggested by Ron Burk.However, it\'s possible to have functions use a fixed output variable internally, and then add some sugar over the top to hide this fact from the caller, as I\'ve done with the call function in the following example. Consider this a proof of concept, but the key points areThe reason this works is because the call function itself has no locals and uses no variables other than REPLY, avoiding any potential for name clashes. At the point where the caller-defined output variable name is assigned, we\'re effectively in the caller\'s scope (technically in the identical scope of the call function), rather than in the scope of the function being called.Output: