I normally have several problems with how cron executes scripts as they normally don\'t have my environment setup. Is there a way to invoke bash(?) in the same way cron does so I could test scripts before installing them?Add this to your cron:After it runs, do this:This assumes that your cron runs /bin/sh, which is the default regardless of the user\'s default shell.Cron provides only this environment by default :If you need more you can source a script where you define your environment before the scheduling table in the crontab.Couple of approaches:Export cron env and source it:Addto your crontab, let it run once, turn it back off, then runAnd you are now inside a sh session which has cron\'s environmentBring your environment to cronYou could skip above exercise and just do a . ~/.profile in front of your cron job, e.g. Use screenAbove two solutions still fail in that they provide an environment connected to a running X session, with access to dbus etc. For example, on Ubuntu, nmcli (Network Manager) will work in above two approaches, but still fail in cron.Add above line to cron, let it run once, turn it back off. Connect to your screen session (screen -r). If you are checking the screen session has been created (with ps) be aware that they are sometimes in capitals (e.g. ps | grep SCREEN)Now even nmcli and similar will fail.You can run:This will run your_command with empty environment.Depending on the shell of the accountorFrom http://matthew.mceachen.us/blog/howto-simulate-the-cron-environment-1018.htmlCreate a cron job that runs env and redirects stdout to a file.\nUse the file alongside "env -" to create the same environment as a cron job.Answering six years later: the environment mismatch problem is one of the problems solved by systemd "timers" as a cron replacement.  Whether you run the systemd "service" from the CLI or via cron, it receives exactly the same environment, avoiding the environment mismatch problem.The most common issue to cause cron jobs to fail when they pass manually is the restrictive default $PATH set by cron, which is this on Ubuntu 16.04:By contrast, the default $PATH set by systemd on Ubuntu 16.04 is:So there\'s already a better chance that a systemd timer is going to find a binary without further hassle.The downside with systemd timers, is there\'s a slightly more time to set them up. You first create a "service" file to define what you want to run and a "timer" file to define the schedule to run it on and finally "enable" the timer to activate it. Don\'t forget that since cron\'s parent is init, it runs programs without a controlling terminal. You can simulate that with a tool like this:http://libslack.org/daemon/By default, cron executes its jobs using whatever your system\'s idea of sh is. This could be the actual Bourne shell or dash, ash, ksh or bash (or another one) symlinked to sh (and as a result running in POSIX mode).The best thing to do is make sure your scripts have what they need and to assume nothing is provided for them. Therefore, you should use full directory specifications and set environment variables such as $PATH yourself.Another simple way I\'ve found (but may be error prone, I\'m still testing) is to source your user\'s profile files before your command.Editing a /etc/cron.d/ script:Would turn into:Dirty, but it got the job done for me. Is there a way to simulate a login? Just a command you could run? bash --login didn\'t work. It sounds like that would be the better way to go though.EDIT: This seems to be a solid solution: http://www.epicserve.com/blog/2012/feb/7/my-notes-cron-directory-etccrond-ubuntu-1110/Answer https://stackoverflow.com/a/2546509/5593430 shows how to obtain the cron environment and use it for your script. But be aware that the environment can differ depending on the crontab file you use. I created three different cron entries to save the environment via env > log. These are the results on an Amazon Linux 4.4.35-33.55.amzn1.x86_64.Most importantly PATH, PWD and HOME differ. Make sure to set these in your cron scripts to rely on a stable environment.I don\'t believe that there is; the only way I know to test a cron job is to set it up to run a minute or two in the future and then wait.