I\'d like to find a Windows batch counterpart to Bash\'s $@ that holds a list of all arguments passed into a script. Or I have to bother with shift?dancavallaro has it right, %* for everything. You might also find these useful:%0 - the command used to call the batch file (could be foo, ..\\foo, c:\\bats\\foo, etc.)\n%1 is the first command line parameter,\n%2 is the second command line parameter,\nand so on till %9 (and SHIFT can be used for those after the 9th). %~nx0 - the actual name of the batch file, regardless of calling method (some-batch.bat)\n%~dp0 - drive and path to the script  (d:\\scripts)\n%~dpnx0 - is the fully qualified path name of the script (d:\\scripts\\some-batch.bat)  More info examples at http://www.ss64.com/nt/syntax-args.html and http://www.robvanderwoude.com/parameters.html%* seems to hold all of the arguments passed to the script.%1 ... %n and %* holds the arguments, but it can be tricky to access them, because the content will be interpreted.\nTherefore it is impossible to handle something like this with normal statementsEach line fails, as cmd.exe try to execute one of the ampersands (the content of %1 is "&"&)But there exists a workaround with a temporary fileThe trick is to enable echo on and expand the %1 after a rem statement (works also with %2 .. %*).\nBut to be able to redirect the output of echo on, you need the two FOR-LOOPS.  The extra characters * # are used to be safe against contents like /? (would show the help for REM).\nOr a caret ^ at the line end could work as a multiline character.  The FOR /F should be work with delayed expansion off, else contents with "!" would be destroyed.\nAfter removing the extra characters in param1 and you got it.  And to use param1 in a safe way, enable the delayed expansion.Edit: One remark to %0%0 contains the command used to call the batch, also preserving the case like in FoO.BaT\nBut after a call to a function %0 and also in %~0 contains the function name (or better the string that was used to call the function).\nBut with %~f0 you still can recall the filename.OutputI found that next time when you need to look up these information. Instead of opening a browser and google it, you could just type call /? in your cmd and you\'ll get it:The way to retrieve all the args to a script is here:Here is a fairly simple way to get the args and set them as env vars. In this example I will just refer to them as Keys and Values.Save the following code example as "args.bat". Then call the batch file\nyou saved from a command line.\nexample: arg.bat --x 90 --y 120I have provided some echo commands to step you through the process. But the\nend result is that --x will have a value of 90 and --y will have a value of 120(that is if you run the example as specified above ;-) ).You can then use the \'if defined\' conditional statement to determine whether or not to run your code block.\nSo lets say run:\n    "arg.bat --x hello-world" \nI could then use the statement "IF DEFINED --x echo %--x%" and the results would be "hello-world". It should make more sense if you run the batch.The following code simulates an array (\'params\') - takes the parameters received by the script and stores them in the variables params_1 .. params_n, where n=params_0=the number of elements of the array:Windows version (needs socat though)setting it up:Lot of the information above led me to further research and ultimately my answer so I wanted to contribute what I wound up doing in hopes it helps someone else:I also wanted to pass a varied number of variables to a batch file so that they could be processed within the file.I was ok with passing them to the batch file using quotesI would want them processed similar to the below - but using a loop instead of writing out manually:So I wanted to execute this:And via the magic of for loops do this within the batch file:Problem I was having is that all my attempts to use a for loop weren\'t working.  The below example:would just do:and not:even after setting Reason was that the for loop read the whole line and assigned my second parameter to %%B during the first iteration of the loop.  Because %* represents all arguments, there is only a single line to process - ergo only one pass of the for loop happens.  This is by design it turns out, and my logic was wrong.So I stopped trying to use a for loop and simplified what I was trying to do by using if, shift, and a goto statement.  Agreed its a bit of a hack but it\'s more suited to my needs. I can loop through all of the arguments and then use an if statement to drop out of the loop once I process them all.The winning statement for what I was trying to accomplish:UPDATE - I had to modify to the below instead, I was exposing all of the environment variables when trying to reference %1 and using shift in this manner:You can use %1, %2 etc to access the command line arguments. I don\'t think there\'s a variable that holds the entire list. You might be able to write a simple loop that determines how many arguments were passed.EDIT: Apparently there is :)For someone who needs trailing backslash from basepath