When should you use generator expressions and when should you use list comprehensions in Python?John\'s answer is good (that list comprehensions are better when you want to iterate over something multiple times).  However, it\'s also worth noting that you should use a list if you want to use any of the list methods.  For example, the following code won\'t work:Basically, use a generator expression if all you\'re doing is iterating once.  If you want to store and use the generated results, then you\'re probably better off with a list comprehension.Since performance is the most common reason to choose one over the other, my advice is to not worry about it and just pick one; if you find that your program is running too slowly, then and only then should you go back and worry about tuning your code.Iterating over the generator expression or the list comprehension will do the same thing. However, the list comprehension will create the entire list in memory first while the generator expression will create the items on the fly, so you are able to use it for very large (and also infinite!) sequences.Use list comprehensions when the result needs to be iterated over multiple times, or where speed is paramount. Use generator expressions where the range is large or infinite.The benefit of a generator expression is that it uses less memory since it doesn\'t build the whole list at once.  Generator expressions are best used when the list is an intermediary, such as summing the results, or creating a dict out of the results.For example:The advantage there is that the list isn\'t completely generated, and thus little memory is used (and should also be faster)You should, though, use list comprehensions when the desired final product is a list.  You are not going to save any memeory using generator expressions, since you want the generated list.  You also get the benefit of being able to use any of the list functions like sorted or reversed.For example:The important point is that the list comprehension creates a new list. The generator creates a an iterable object that will "filter" the source material on-the-fly as you consume the bits.Imagine you have a 2TB log file called "hugefile.txt", and you want the content and length for all the lines that start with the word "ENTRY".So you try starting out by writing a list comprehension:This slurps up the whole file, processes each line, and stores the matching lines in your array. This array could therefore contain up to 2TB of content. That\'s a lot of RAM, and probably not practical for your purposes.So instead we can use a generator to apply a "filter" to our content. No data is actually read until we start iterating over the result.Not even a single line has been read from our file yet. In fact, say we want to filter our result even further:Still nothing has been read, but we\'ve specified now two generators that will act on our data as we wish.Lets write out our filtered lines to another file:Now we read the input file. As our for loop continues to request additional lines, the long_entries generator demands lines from the entry_lines generator, returning only those whose length is greater than 80 characters. And in turn, the entry_lines generator requests lines (filtered as indicated) from the logfile iterator, which in turn reads the file.So instead of "pushing" data to your output function in the form of a fully-populated list, you\'re giving the output function a way to "pull" data only when its needed. This is in our case much more efficient, but not quite as flexible. Generators are one way, one pass; the data from the log file we\'ve read gets immediately discarded, so we can\'t go back to a previous line. On the other hand, we don\'t have to worry about keeping data around once we\'re done with it.When creating a generator from a mutable object (like a list) be aware that the generator will get evaluated on the state of the list at time of using the generator, not at time of the creation of the generator:If there is any chance of your list getting modified (or a mutable object inside that list) but you need the state at creation of the generator you need to use a list comprehension instead.Sometimes you can get away with the tee function from itertools, it returns multiple iterators for the same generator that can be used independently.I\'m using the Hadoop Mincemeat module. I think this is a great example to take a note of:Here the generator gets numbers out of a text file (as big as 15GB) and applies simple math on those numbers using Hadoop\'s map-reduce. If I had not used the yield function, but instead a list comprehension, it would have taken a much longer time calculating the sums and average (not to mention the space complexity).Hadoop is a great example for using all the advantages of Generators.