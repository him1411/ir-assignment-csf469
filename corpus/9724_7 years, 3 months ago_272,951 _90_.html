So, I\'m getting the infamously horrible "undefined reference to \'vtable..." error for the following code (The class in question is CGameModule.) and I cannot for the life of me understand what the problem is. At first, I thought it was related to forgetting to give a virtual function a body, but as far as I understand, everything is all here. The inheritance chain is a little long, but here is the related source code. I\'m not sure what other information I should provide.Note: The constructor is where this error is happening, it\'d seem.My code:Inherits from...Which inherits from....The GCC FAQ has an entry on it:The solution is to ensure that all virtual methods that are not pure are defined. Note that a destructor must be defined even if it is declared pure-virtual [class.dtor]/7.For what it is worth, forgetting a body on a virtual destructor generates the following: undefined reference to `vtable for CYourClass\'.  I am adding a note because the error message is deceptive.  (This was with gcc version 4.6.3.)So, I\'ve figured out the issue and it was a combination of bad logic and not being totally familiar with the automake/autotools world. I was adding the correct files to my Makefile.am template, but I wasn\'t sure which step in our build process actually created the makefile itself. So, I was compiling with an old makefile that had no idea about my new files whatsoever.Thanks for the responses and the link to the GCC FAQ. I will be sure to read that to avoid this problem occurring for a real reason.I simply got this error because my cpp file was not in the makefile.Undefined reference to vtable may occur due to the following situation also. Just try this:Class A Contains:Class B Contains:Class C Contains: Now you\'re writing a Class C in which you are going to derive it from Class A. Now if you try to compile you will get Undefined reference to vtable for Class C as error.Reason:functionA is defined as pure virtual and its definition is provided in Class B.\nfunctionB is defined as virtual (NOT PURE VIRTUAL) so it tries to find its definition in Class A itself but you provided its definition in Class B.Solution:If you are using Qt, try rerunning qmake. If this error is in the widget\'s class, qmake might have failed to notice that the ui class vtable should be regenerated. This fixed the issue for me.I just ran into another cause for this error that you can check for.The base class defined a pure virtual function as:And the subclass hadThe problem was the typo that the "=0" was supposed to be outside of the parenthesis:So, in case you\'re scrolling this far down, you probably didn\'t find the answer - this is something else to check for.The GNU C++ compiler has to make a decision where to put the vtable in case you have the definition of the virtual functions of an object spread across multiple compilations units (e.g. some of the objects virtual functions definitions are in a .cpp file others in another .cpp file, and so on). The compiler chooses to put the vtable in the same place as where the first declared virtual function is defined.Now if you for some reason forgot to provide a definition for that first virtual function declared in the object (or mistakenly forgot to add the compiled object at linking phase), you will get this error. As a side effect, please note that only for this particular virtual function you won\'t get the traditional linker error like you are missing function foo.This can happen quite easily if you forget to link to the object file that has the definition.Not to cross post but. If you are dealing with inheritance the second google hit was what I had missed, ie. all virtual methods should be defined.Such as:See answare C++ Undefined Reference to vtable and inheritance for details. Just realized it\'s already mentioned above, but heck it might help someone.This is a terrible error because it seems people have seemingly assumed few arbitrary things as cause for this error. For example, someone was saying you must have virtual non-pure destructor in base while other person was speculating that this destructor must be in its own cpp file and yet another saying that order of include files caused the error! These causes doesn\'t seem to be true. If all else fails then one way to debug this error is to build minimal program that does compile and then keep changing it so it gets to the state you want. In between, keep compiling to see when it starts to fail.So let me present a complete program that compiles fine, uses C++ style interfaces and has its own cpp and header files:IBase.hppDerived.hppDerived.cppmyclass.cppYou can compile this using GCC like this:Notice that this does not require any virtual destructors, constructors or any other extra files for compile to be successful (although you should have them). You can now reproduce the error by removing  = 0 in IBase.hpp. I get this error:The way to understand this error is as follows:\nLinker is looking for constructor of IBase. This it will need it for the constructor of Derived. However as Derived overrides methods from IBase, it has vtable attached to it that will reference IBase. When linker says "undefined reference to vtable for IBase" it basically means that Derived has vtable reference to IBase but it can\'t find any compiled object code of IBase to look up to. So the bottom line is that class IBase has declarations without implementations. This means a method in IBase is declared as virtual but we forgot to mark it as pure virtual OR provide its definition.Note on ROS and Catkin build systemIf you were compiling above set of classes in ROS using catkin build system then you will need following lines in CMakeLists.txt:The first line basically says that we want to make an executable named myclass and the code to build this can be found files that follows. One of these files should have main(). Notice that you don\'t have to specify .hpp files anywhere in CMakeLists.txt. Also you don\'t have to specify Derived.cpp as library.Perhaps missing the virtual destructor is contributing factor?Ok, the solution to this is that you may have missed out on the definition. See the example below to avoid the vtable compiler error:Not perhaps. Definitely ~CDasherModule() {} is missing. This was the first search result for me so I thought I\'d add another thing to check: make sure the definition of virtual functions are actually on the class. In my case, I had this:Header file:and in my .cc file:This should readI got this error in the following scenarioConsider a case where you have defined the implementation of member functions of a class in the header file itself. This header file is an exported header (in other words, it might be copied to some common/include directly in your codebase). Now you have decided to separate the implementation of the member functions to to .cpp file. After you separated/moved the implementation to .cpp, the header file now has just the prototypes of the member functions inside the class. After the above changes, if you build your codebase you may get the "undefined reference to \'vtable..." error.To fix this, before building, make sure you delete the header file (to which you made changes) in common/include directory. Also make sure you change your makefile to accomodate/add the new .o file that is built from the new .cpp file you just created. When you do these steps the compiler/linker will no longer complain.If all else fails, look for duplication.  I was misdirected by the explicit initial reference to constructors and destructors until I read a reference in another post.  It\'s any unresolved method.  In my case, I thought I had replaced the declaration that used char *xml as the parameter with one using the unnecessarily troublesome const char *xml, but instead, I had created a new one and left the other one in place.There are a lot of possibilities mentioned for causing this error, and I\'m sure many of them do cause the error.  In my case, there was another definition of the same class, due to a duplication of the source file.  This file was compiled, but not linked, so the linker was complaining about being unable to find it.To summarize, I would say that if you\'ve stared at the class long enough and can\'t see what possible syntax problem could be causing it, look for build issues like a missing file or a duplicated file.So many answers here but none of them seemed to have covered what my problem was.  I had the following:And in another file (included in the compilation and linking, of course)Well this didn\'t work and I got the error everyone is talking about.  To solve it, I had to move the actual definition of Foo out of the class declaration as such:I\'m no C++ guru so I can\'t explain why this is more correct but it solved the problem for me.So I was using Qt with Windows XP and MinGW compiler and this thing was driving me crazy.Basically the moc_xxx.cpp was generated empty even when I was addedQ_OBJECTDeleting everything making functions virtual, explicit and whatever you guess doesn\'t worked. Finally I started removing line by line and it turned out that I hadAround the file. Even when the #ifdef was true moc file was not generated.So removing all #ifdefs fixed the problem.This thing was not happening with Windows and VS 2013.It\'s also possible that you get a message likeif you forget to define a virtual function of a class FakeClass1 when you\'re trying to link a unit test for another class SomeClass.And In this case I suggest you check out your fake for class1 once again. You\'ll probably find  that you may have forgotten to define a virtual function ForgottenFunc in your fake class.I got this type of error in situations where I was trying to link to an object when I got a make bug that prevented the object being added to the archive.Say I have libXYZ.a that supposed to have bioseq.o in int but it does not.  I got an error:This is quit different from all of the above.  I would call this missing object in the archive problem.In my case I\'m using Qt and had defined a QObject subclass in a foo.cpp (not .h) file. The fix was to add #include "foo.moc" at the end of foo.cpp.I got this error when I added a second class to an existing source/header pair.  Two class headers in the same .h file, and function definitions for two classes in the same .cpp file.I\'ve done this successfully before, with classes that are meant to work closely together, but apparently something didn\'t like me this time.  Still don\'t know what, but splitting them into one class per compilation unit fixed it right up.The failed attempt:_gui_icondata.h:_gui_icondata.cpp:Again, adding a new source/header pair and cutting/pasting the IconWithData class verbatim into there "just worked".I got this error just because the name of a constructor argument differed in the header file and in the implementation file. The constructor signature isand what I wrote in the implementation started withthus I accidentaly replaced "pset" with "pest". The compiler was complaining about this one and two other constructors in which there was no error at all. I\'m using g++ version 4.9.1 under Ubuntu. And defining a virtual destructor in this derived class made no difference (it is defined in the base class). I would have never found this bug if I didn\'t paste the constructors\' bodies in the header file, thus defining them in-class.