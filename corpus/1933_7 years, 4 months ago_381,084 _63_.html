In a shell script how do I echo all shell commands called and expand any variable names?\nFor example, given the following line:I would like the script to run the command and display the followingThe purpose is to save a log of all shell commands called and their arguments. Perhaps there is a better way of generating such a a log?set -x or set -o xtrace expands variables and prints a little + sign before the line.set -v or set -o verbose does not expand the variables before printing.Use set +x and set +v to turn off the above settings.On the first line of the script, one can put #!/bin/sh -x to have the same effect as set -x later in the script.The above also works with /bin/sh.http://www.faqs.org/docs/abs/HTML/options.htmlset -x will give you what you want.Here is an example shell script to demonstrate:This expands all variables and prints the full commands before output of the command.output:You can also toggle this for select lines in your script by wrapping them in set -x and set +x  e.g.I use a function to echo then run the commandWhich outputsshuckc\'s answer for echoing select lines has a few downsides: you end up with the following set +x command being echoed as well, and you lose the ability to test the exit code with $? since it gets overwritten by the set +x.Another option is to run the command in a subshell:which will give you output like:This does incur the overhead of creating a new subshell for the command, though.Another option is to put "-x" at the top of your script instead of on the command line:(Insufficient rep to comment on chosen answer.)Type "bash -x" on the command line before the name of the bash script. For instance, to execute foo.sh, type:According to TLDP\'s Bash Guide for Beginners: Chapter 2. Writing and debugging scripts2.3.1. Debugging on the entire script...There is now a full-fledged debugger for Bash, available at SourceForge. These debugging features are available in most modern versions of Bash, starting from 3.x.2.3.2. Debugging on part(s) of the script...  Table 2-1. Overview of set debugging options ...Alternatively, these modes can be specified in the script itself, by\n  adding the desired options to the first line shell declaration.\n  Options can be combined, as is usually the case with UNIX commands:For zsh echoand for debuggingSomeone above posted:and this looks promising, but I can\'t for the life of me figure out what it does. I\'ve googled and searched in the man bash page for "\\$" and "$@", and find absolutely nothing.I understand a function is being created, named "exec()". I understand the curly-brackets mark the beginning and end of the function. I think I understand that the semi-colon marks a "hard return" between a multi-line command, so that \'{ echo "\\$ $@" ; "$@" ; }\' becomes, in essence:Can any one give me a brief explanation, or where to find this info, since obviously my google-fu is failing me?(Without meaning to start a new question on an old thread, my goal is to reroute the output to a file. The "set -x ; [commands] ; set +x" method would work adequately well for me, but I can\'t figure out how to echo the results to a file instead of the screen, so I was trying to understand this other method in hopes I could use me very poor understanding of redirection/pipes/tee/etc to do the same thing.)Thanks!LATER EDIT:With some tinkering, I believe I figured it out. Here\'s my equivalent code for what I\'m needing:The results in the logfile.txt look something like:Just what I needed. Thanks!For csh and tcsh, you can set verbose or set echo (or you can even set both, but it may result in some duplication most of the time).The verbose option prints pretty much the exact shell expression that you type.The echo option is more indicative of what will be executed through spawning.http://www.tcsh.org/tcsh.html/Special_shell_variables.html#verbosehttp://www.tcsh.org/tcsh.html/Special_shell_variables.html#echoSpecial shell variablesverbose\n    If set, causes the words of each command to be printed, after history substitution (if any). Set by the -v command line option.echo\n    If set, each command with its arguments is echoed just before it is executed. For non-builtin commands all expansions occur before echoing. Builtin commands are echoed before command and filename substitution, because these substitutions are then done selectively. Set by the -x command line option.You can execute a bash script in debug mode with the -x option. This will echo  all the commands.\nYou can also save the -x option in the script. Just specify the -x option in the shebang.To allow for compound commands to be echoed, I use eval plus Soth\'s exe function to echo then run the command.  This is useful for piped commands that would otherwise only show none or just the initial part of the piped command.Without eval:Outputs:With eval:Which outputsOutput is as follows: