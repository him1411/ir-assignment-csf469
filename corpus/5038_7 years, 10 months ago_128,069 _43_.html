How can you tell, from the command line, how many cores are on the machine when you\'re running Mac OS X?  On Linux, I use:It\'s not perfect, but it\'s close.  This is intended to get fed to make, which is why it gives a result 1 higher than the actual number.  And I know the above code can be written denser in Perl or can be written using grep, wc, and cut, but I decided the above was a good tradeoff between conciseness and readability.VERY LATE EDIT: Just to clarify: I\'m asking how many logical cores are available, because this corresponds with how many simultaneous jobs I want make to spawn. jkp\'s answer, further refined by Chris Lloyd, was exactly what I needed. YMMV.You can do this using the sysctl utility:sysctl -n hw.ncpuEven easier:To do this in C you can use the sysctl(3) family of functions:Interesting values to use in place of "hw.logicalcpu", which counts cores, are:This should be cross platform. At least for Linux and Mac OS X.A little bit slow but works.system_profiler SPHardwareDataType shows I have 1 processor and 4 cores.[~] system_profiler SPHardwareDataType\nHardware:[~] However, sysctl disagrees:[~] sysctl -n hw.logicalcpu\n8\n[~] sysctl -n hw.physicalcpu\n4\n[~] But sysctl appears correct, as when I run a program that should take up all CPU slots, I see this program taking close to 800% of CPU time (in top):PID   COMMAND      %CPU\n4306  top          5.6\n4304  java         745.7 \n4296  locationd    0.0  As jkp said in a comment, that doesn\'t show the actual number of physical cores. to get the number of physical cores you can use the following command:Use the system_profiler | grep "Cores" command.I have a:MacBook Pro Retina, Mid 2012.Processor: 2.6 GHz Intel Core i7According to Wikipedia, (http://en.wikipedia.org/wiki/Intel_Core#Core_i7) there is no Core i7 with 8 physical cores so the Hyperthreading idea must be the case.  Ignore sysctl and use the system_profiler value for accuracy.  The real question is whether or not you can efficiently run applications with 4 cores (long compile jobs?) without interrupting other processes.Running a compiler parallelized with 4 cores doesn\'t appear to dramatically affect regular OS operations.  So perhaps treating it as 8 cores is not so bad.On a MacBook Pro running Mavericks, sysctl -a | grep hw.cpu will only return some cryptic details.  Much more detailed and accessible information is revealed in the machdep.cpu section, ie:In particular, for processors with HyperThreading (HT), you\'ll see the total enumerated CPU count (logical_per_package) as double that of the physical core count (cores_per_package).  Comments for 2 good replies above:1) re the accepted reply (and comments) by jkp:  hw.ncpu is apparently deprecated in favor of hw.logicalcpu (https://ghc.haskell.org/trac/ghc/ticket/8594)2) re the 2014 update by Karl Ehr:  on my computer (with 2.5 ghz intel core i7),sysctl -a | grep machdep.cpu | grep per_package returns different numbers:machdep.cpu.logical_per_package: 16machdep.cpu.cores_per_package: 8The desired values are:machdep.cpu.core_count: 4machdep.cpu.thread_count: 8Which match:hw.physicalcpu: 4hw.logicalcpu: 8CLARIFICATIONWhen this question was asked the OP did not say that he wanted the number of LOGICAL cores rather than the actual number of cores, so this answer logically (no pun intended) answers with a way to get the actual number of real physical cores, not the number that the OS tries to virtualize through hyperthreading voodoo.UPDATE TO HANDLE FLAW IN YOSEMITEDue to a weird bug in OS X Yosemite (and possibly newer versions, such as the upcoming El Capitan), I\'ve made a small modification. (The old version still worked perfectly well if you just ignore STDERR, which is all the modification does for you.)Every other answer given here either The way to get just the number of cores, reliably, correctly, reasonably quickly, and without extra information or even extra characters around the answer, is this: