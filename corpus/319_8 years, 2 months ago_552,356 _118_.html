With the iPhone SDK:I have a UIView with UITextFields that brings up a keyboard.  I need it to be able to:Allow scrolling of the contents of the UIScrollView to see the other text fields once the keyboard is brought upAutomatically "jump" (by scrolling up) or shorteningI know that I need a UIScrollView.  I\'ve tried changing the class of my UIView to a UIScrollView but I\'m still unable to scroll the textboxes up or down.  Do I need both a UIView and a UIScrollView?  Does one go inside the other? [EDIT: I now know that you want a UIView inside of a UIScrollView, and the trick is to programatically set the content size of the UIScrollView to the frame size of the UIView.]Then what needs to be implemented in order to automatically scroll to the active text field?Ideally as much of the setup of the components as possible will be done in Interface Builder.  I\'d like to only write code for what needs it.Note: the UIView (or UIScrollView) that I\'m working with is brought up by a tabbar (UITabBar), which needs to function as normal.Edit: I am adding the scroll bar just for when the keyboard comes up.  Even though it\'s not needed, I feel like it provides a better interface because then the user can scroll and change textboxes, for example.  I\'ve got it working where I change the frame size of the UIScrollView when the keyboard goes up and down.  I\'m simply using: However this doesn\'t automatically "move up" or center the lower text fields in the visible area, which is what I would really like.You will only need a ScrollView if the contents you have now do not fit in the iPhone screen.\n(If you are adding the ScrollView as the superview of the components. just to make the TextField scroll up when keyboard comes up, then it\'s not needed.)For showing the textfields without being hidden by the keyboard, the standard way is to move up/down the view having textfields whenever the keyboard is shown.Here is some sample code:I was also having a lot of issue with a UIScrollView composing of multiple UITextFields, of which, one or more of them would get obscured by the keyboard when they are being edited.  Here are some things to consider if your UIScrollView is not properly scrolling.  1) Ensure that your contentSize is greater than the UIScrollView frame size.  The way to understand UIScrollViews is that the UIScrollView is like a viewing window on the content defined in the contentSize.  So when in order for the UIScrollview to scroll anywhere, the contentSize must be greater than the UIScrollView.  Else, there is no scrolling required as everything defined in the contentSize is already visible.  BTW, default contentSize = CGSizeZero.2) Now that you understand that the UIScrollView is really a window into your "content", the way to ensure that the keyboard is not obscuring your UIScrollView\'s viewing "window" would be to resize the UIScrollView so that when the keyboard is present, you have the UIScrollView window sized to just the original UIScrollView frame.size.height minus the height of the keyboard.  This will ensure that your window is only that small viewable area.3) Here\'s the catch:  When I first implemented this I figured I would have to get the CGRect of the edited textfield and call UIScrollView\'s scrollRecToVisible method.  I implemented the UITextFieldDelegate method textFieldDidBeginEditing with the call to the scrollRecToVisible method.  This actually worked with a strange side effect that the scrolling would snap the UITextField into position.  For the longest time I couldn\'t figure out what it was.  Then I commented out the textFieldDidBeginEditing Delegate method and it all work!!(???).  As it turned out, I believe the UIScrollView actually implicitly brings the currently edited UITextField into the viewable window implicitly.  My implementation of the UITextFieldDelegate method and subsequent call to the scrollRecToVisible was redundant and was the cause of the strange side effect.So here are the steps to properly scroll your UITextField in a UIScrollView into place when the keyboard appears.One thing to note is that the UIKeyboardWillShowNotification will fire even when the keyboard is already on the screen when you tab on another UITextField.  I took care of this by using an ivar to avoid resizing the UIScrollView when the keyboard is already on the screen.  Inadvertently resizing the UIScrollView when the keyboard is already there would be disastrous!Hope this code saves some of you a lot of headache.   It\'s actually best just to use Apple\'s implementation, as provided in the docs. However, the code they provide is faulty. Replace the portion found in keyboardWasShown: just below the comments to the following:The problems with Apple\'s code are these:\n(1) They always calculate if the point is within the view\'s frame, but it\'s a ScrollView, so it may already have scrolled and you need to account for that offset:(2) They shift the contentOffset by the height of the keyboard, but we want the opposite (we want to shift the contentOffset by the height that is visible on the screen, not what isn\'t):In textFieldDidBeginEditting and in textFieldDidEndEditing call the function [self animateTextField:textField up:YES] like so: I hope this code will help you. In Swift 2SWIFT 3Just using TextFields:1a) Using Interface Builder: Select All TextFields => Edit => Embed In => ScrollView1b) Manually embed TextFields in UIScrollView called scrollView2) Set UITextFieldDelegate3) Set each textField.delegate = self; (or make connections in Interface Builder)4) Copy / Paste:I\'ve put together a universal, drop-in UIScrollView, UITableView and even UICollectionView subclass that takes care of moving all text fields within it out of the way of the keyboard.When the keyboard is about to appear, the subclass will find the subview that\'s about to be edited, and adjust its frame and content offset to make sure that view is visible, with an animation to match the keyboard pop-up. When the keyboard disappears, it restores its prior size.It should work with basically any setup, either a UITableView-based interface, or one consisting of views placed manually.Here\' tis: solution for moving text fields out of the way of the keyboardFor Universal Solution, Here was my approach for implementing IQKeyboardManager.Step1:- I Added global notifications of UITextField, UITextView, and UIKeyboard in a singleton class. I call it IQKeyboardManager.Step2:- If found UIKeyboardWillShowNotification, UITextFieldTextDidBeginEditingNotification or UITextViewTextDidBeginEditingNotification notifications, I try to get topMostViewController instance from the UIWindow.rootViewController hierarchy. In order to properly uncover UITextField/UITextView on it, topMostViewController.view\'s frame needs to be adjusted.Step3:- I calculated expected move distance of topMostViewController.view with respect to first responded UITextField/UITextView.Step4:- I moved topMostViewController.view.frame up/down according to the expected move distance.Step5:- If found UIKeyboardWillHideNotification, UITextFieldTextDidEndEditingNotification or UITextViewTextDidEndEditingNotification notification, I again try to get topMostViewController instance from the UIWindow.rootViewController hierarchy.Step6:- I calculated disturbed distance of topMostViewController.view which needs to be restored to it\'s original position.Step7:- I restored topMostViewController.view.frame down according to the disturbed distance.Step8:- I instantiated singleton IQKeyboardManager class instance on app load, so every UITextField/UITextView in the app will adjust automatically according to the expected move distance.That\'s all IQKeyboardManager do for you with NO LINE OF CODE really!! only need to drag and drop related source file to project. IQKeyboardManager also support Device Orientation, Automatic UIToolbar Management, KeybkeyboardDistanceFromTextField and much more than you think.For Swift Programmers :This will do everything for you, just put these in your view controller class and implement the UITextFieldDelegate to your view controller & set the textField\'s delegate to self Implement the delegate callback methods:There are already a lot of answers, but still none of the solutions above had all the fancy positioning stuff required for a "perfect" bug-free, backwards compatible and flicker-free animation. (bug when animating frame/bounds and contentOffset together, different interface orientations, iPad split keyboard, ...)\nLet me share my solution: \n(assuming you have set up UIKeyboardWill(Show|Hide)Notification)I wanted to add a comment to Shiun\'s answer, but I apparently do not have enough rep points to add comments.  Perhaps someone with more points can add a comment with the info below, then I\'ll delete this answer...Shiun said "As it turned out, I believe the UIScrollView actually implicitly brings the currently edited UITextField into the viewable window implicitly"   This seems to be true for iOS 3.1.3, but not 3.2, 4.0, or 4.1.  I had to add an explicit scrollRectToVisible in order to make the UITextField visible on iOS >= 3.2.This document details a solution to this problem. Look at the source code under \'Moving Content That Is Located Under the Keyboard\'. It\'s pretty straightforward.EDIT: Noticed there\'s a wee glitch in the example. You will probably want to listen for UIKeyboardWillHideNotification instead of UIKeyboardDidHideNotification. Otherwise the scroll view behind of the keyboard will be clipped for the duration of the keyboard closing animation.One thing to consider is whether you ever want to use a UITextField on its own. I haven\xe2\x80\x99t come across any well-designed iPhone apps that actually use UITextFields outside of UITableViewCells.It will be some extra work, but I recommend you implement all data entry views a table views. Add a UITextView to your UITableViewCells.Easiest solution found Little fix that works for many UITextFieldsRPDP\'s code successfully moves the text field out of the way of the keyboard. But when you scroll to the top after using and dismissing the keyboard, the top has been scrolled up out of the view. This is true for the Simulator and the device. To read the content at the top of that view, one has to reload the view.Isn\'t his following code supposed to bring the view back down?I\'m not sure if moving the view up is the correct approach, I did it in a differente way, resizing the UIScrollView. I explained it in details on a little articleTo bring back to original view state, add:There so many solutions, but I\'ve spend some hours before it start works. So, I put this code here (just paste to the project, any modifications needn\'t):P.S: I hope the code help somebody make desired effect quickly. \n(Xcode 4.5)try this short trick...Happy coding :)....@user271753To get your view back to original add:It doesn\'t require a scroll view to be able to move the view frame.  You can change the frame of a viewcontroller\'s view so that the entire view moves up just enough to put the firstresponder text field above the keyboard.  When I ran into this problem I created a subclass of UIViewController that does this.  It observes for the keyboard will appear notification and finds the first responder subview and (if needed) it animates the main view upward just enough so that the first responder is above the keyboard.  When the keyboard hides, it animates the view back where it was.To use this subclass make your custom view controller a subclass of GMKeyboardVC and it inherits this feature (just be sure if you implement viewWillAppear and viewWillDisappear they must call super).  The class is on github.Here is the hack solution I came up with for a specific layout. This solution is similar to Matt Gallagher solution in that is scrolls a section into view. I am still new to iPhone development, and am not familiar with how the layouts work. Thus, this hack.My implementation needed to support scrolling when clicking in a field, and also scrolling when the user selects next on the keyboard.I had a UIView with a height of 775. The controls are spread out basically in groups of 3 over a large space. I ended up with the following IB layout.Here comes the hackI set the UIScrollView height to 500 units larger then the actual layout (1250). I then created an array with the absolute positions I need to scroll to, and a simple function to get them based on the IB Tag number.Now all you need to do is use the following two lines of code in textFieldDidBeginEditing and textFieldShouldReturn (the latter one if you are creating a next field navigation)An example.This method does not \'scroll back\' as other methods do. This was not a requirement. Again this was for a fairly \'tall\' UIView, and I did not have days to learn the internal layout engines.As per the docs, as of iOS 3.0, the UITableViewController class automatically resizes and repositions its table view when there is in-line editing of text fields. I think it\'s not sufficient to put the text field inside a UITableViewCell as some have indicated.From the docs:A table view controller supports inline editing of table view rows;\n  if, for example, rows have embedded text fields in editing mode, it\n  scrolls the row being edited above the virtual keyboard that is\n  displayed.Here I found the simplest solution to handle keypad.You need to just copy-paste below sample code and change your textfield or any view which you want to move up.Step-1 Just copy-paste below two method in your controllerStep-2 register  & deregister Keypad Notifications in viewWillAppear and\n  viewWillDisappear methods respectively.Step-3 Here comes the soul part, Just replace your textfield, and change\n  height how much you want to move upside.Reference:\nwell, Please appreciate this guy, who shared this beautiful code snip, clean solution.Hope this would be surly helpful someone out there.Been searching for a good tutorial for beginners on the subject, found the best tutorial here.In the MIScrollView.h example at the bottom of the tutorial be sure to put a space atas you see.When UITextField is in a UITableViewCell scrolling should be setup automatically.If it is not it is probably because of incorrect code/setup of the tableview.For example when i reloaded my long table with one UITextField at the bottom as follows,   then my textfield at the bottom was obscured by the keyboard which appeared when I clicked inside the textfield.To fix this I had to do this -Use this third party you don\'t need to write even one linehttps://github.com/hackiftekhar/IQKeyboardManagerdownload project and drag and drop IQKeyboardManager in your project.\nIf you find any issue please read README document.Guys really its remove headache to manage keyboard ..Thanks and best of luck!Try this:Note: this answer assumes your textField is in a scrollView.I prefer to deal with this using scrollContentInset and scrollContentOffset instead of messing with the frames of my view.First let\'s listen for the keyboard notifications Next step is to keep a property that represents the current first responder (UITextfield/ UITextVIew that currently has the keyboard).We use the delegate methods to set this property. If you\'re using another component, you will need something similar.Note that for textfield we set it in didBeginEditing and for textView in shouldBeginEditing. This is because textViewDidBeginEditing gets called after UIKeyboardWillShowNotification for some reason. Finally, here\'s  the magicThis is the solution using Swift.