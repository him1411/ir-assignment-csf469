I have the following structure for my React.js application using React Router:I want to pass some properties into the Comments component. (normally I\'d do this like <Comments myprop="value" />)What\'s the easiest and right way to do so with React Router?My preferred way is wrap the Comments component and pass the wrapper as a route handler.UPDATE This method was a temporary solution. Now you can pass props directly via the Route component, without using a Wrapper.This is your example with changes applied:If you\'d rather not write wrappers, I guess you could do this:Copying from the comments by ciantic in the accepted response: This is the most graceful solution in my opinion. It works. Helped me.Just a  follow-up to ColCh\'s answer. It is quite easy to abstract the wrapping of a component:I haven\'t tested this solution yet so any feedback is important.It\'s important to note that with this method, any props sent via the Router (such as params) get overwritten / removed.You can pass props by passing them to <RouteHandler> (in v0.13.x) or the Route component itself in v1.0;(from the upgrade guide at https://github.com/rackt/react-router/releases/tag/v1.0.0)All child handlers will receive the same set of props - this may be useful or not depending on the circumstance.This is the solution from Rajesh, without the inconvenient commented by yuji, and updated for React Router 4.The code would be like this:Note that I use render instead of component. The reason is to avoid undesired remounting. I also pass the props to that method, and I use the same props on the Comments component with the object spread operator (ES7 proposal).Using ES6 you can just make component wrappers inline:<Route path="/" component={() => <App myProp={someValue}/>} >If you need to pass children:<Route path="/" component={(props) => <App myProp={someValue}>{props.children}</App>} >now there is a new way, to do this, although very similar to the previous method.P.S. This works only in alpha version,  and  were removed after the v4 alpha release. In v4 latest,  is once again , with the path and exact props.react-lego an example app contains code that does exactly this in routes.js on its react-router-4 branchHere\'s the cleanest solution I\'ve come up with (React Router v4):MyComponent still has props.match and props.location, and has props.foo === "lol".You can pass in props via the <RouterHandler/> like this:The downside of this is you are passing props indiscriminately. So Comments may end up receiving props that are really intended for a different component depending on your routes configuration. It\'s not a huge deal since props is immutable, but this can be problematic if two different components are expecting a prop named foo but with different values.You could also use the RouteHandler mixin to avoid the wrapper component and more easily pass down the parent\'s state as props:Wrap it with a stateless function component:In 1.0 and 2.0 you can use createElement prop of Router to specify how exactly to create your target element. Documentation sourceYou can also combine es6 and stateless functions to get a much cleaner result:For react router 2.x.and in your routes...make sure the 3rd param is an object like: { checked: false }.The problem with the React Router is that it renders your components and so stops you passsing in props. The Navigation router, on the other hand, lets you render your own components. That means you don\'t have to jump through any hoops to pass in props as the following code and accompanying JsFiddle show.Use the component with or without router based on Rajesh Naroth answer.Or your could do it this way:React Router v 4 solutionI stumbled upon this question earlier today, and here is the pattern I use. Hopefully this is useful to anyone looking for a more current solution.I\'m not sure if this is the best solution, but this is my current pattern for this.  I have typically have a Core directory where I keep my commonly used components with their relevant configurations (loaders, modals, etc), and I include a file like this:Then, in the file in question, I\'ll do the following: You\'ll notice I import the default export of my component as humble camel-case, which lets me name the new, location-aware component in CamelCase so I can use it normally.  Other than the additional import line and the assignment line, the component behaves as expected and receives all its props normally, with the addition of all the route props. Thus, I can happily redirect from component lifecycle methods with this.props.history.push(), check the location, etc.Hope this helps!for the react-router 2.5.2,the solution is so easy:Using a custom route component, this is possible in React Router v3. As for the <MyRoute> component code, it should be something like:For more details about the custom route component approach, check out my blog post on the subject: http://marmelab.com/blog/2016/09/20/custom-react-router-component.html