I wanted to clarify if I understand this correctly:Am I correct in my understanding ?In general, the answer to  your question is "yes", but...With respect to the String class:The equals() method compares the "value" inside String instances (on the heap) irrespective if the two object references refer to the same String instance or not. If any two object references of type String refer to the same String instance then great! If the two object references refer to two different String instances .. it doesn\'t make a difference. Its the "value" (that is: the contents of the character array) inside each String instance that is being compared.On the other hand, the "==" operator compares the value of two object references to see whether they refer to the same String instance. If the value of both object references "refer to" the same String instance then the result of the boolean expression would be "true"..duh. If, on the other hand, the value of both object references "refer to" different String instances (even though both String instances have identical "values", that is, the contents of the character arrays of each String instance are the same) the result of the boolean expression would be "false".As with any explanation, let it sink in.I hope this clears things up a bit.There are some small differences depending whether you are talking about "primitives" or "Object Types"; the same can be said if you are talking about "static" or "non-static" members; you can also mix all the above...Here is an example (you can run it):You can compare the explanations for "==" (Equality Operator) and ".equals(...)" (method in the java.lang.Object class) through these links:Difference between == and equals confused me for sometime until I decided to have a closer look at it.\nMany of them say that for comparing string you should use equals and not ==. Hope in this answer I will be able to say the difference.The best way to answer this question will be by asking few question to yourself. so lets start:What is the output for the below program:if you say, I will say you are right but why did you said that?\nand If you say the output is,I will say you are wrong but I will still ask you, why you think that is right?Ok, Lets try to answer this one:What is the output for the below program:Now If you say,I will say you are wrong but why is it wrong now?\nthe correct output for this program isPlease compare the above program and try to think on it.Ok. Now this might help (please read this : print the address of object - not possible but still we can use it.)can you just try to think for the output of last three lines in above code:\nfor me ideone printed this out (you can check the code here):Oh! Now you see the identityHashCode(mango) is equal to identityHashCode(mango2) But it is not equal to identityHashCode(mango3)Even though all the string variables - mango,mango2 and mango3 has the same value of "mango". But still identityHashCode() for all is not same.Now try to uncomment this line // mango2 = "mang"; and run it again this time you will see all three identityHashCode() are different.\nHmm that is a helpful hintwe know that if hashcode(x)=N and hashcode(y)=N => x is equal to yI am not sure how java works internally, But I assume this is what happened when I said:java created a string "mango" and which was pointed(referenced) by variable mango something like thisNow in the next line when I said:It actually reused the same string "mango" which looks something like thisBoth mango and mango2 pointing to the same reference\nNow when I said It actually created a completely new reference(string) for "mango". which looks something like this,and thats why when I outputted the values for mango == mango2, it outputted true. and when I outputted the value for mango3 == mango2, it outputted false (even when the value were same).and when you uncommented the line // mango2 = "mang";\nIt actually created a string "mang" and which turned our graph like this:and this is why the identityHashCode is not same for all.Hope this help you guys.\nActually I wanted to generate a testcase where == fails and equals() pass.\nPlease feel free to comment and let me know If I am wrong.The == operator tests whether two variables have the same references\n  (aka pointer to a memory address).Whereas the equals() method tests whether two variables refer to objects\n  that have the same state (values).Cheers :-)You will have to override the equals function (along with others) to use this with custom classes.The equals method compares the objects.The == binary operator compares memory addresses.Both == and .equals() refers to the same object if you don\'t override .equals(). Its your wish  what you want to do once you override .equals(). You can compare the invoking object\'s state with the passed in object\'s state or you can just call super.equals()"==" is an operator and "equals" is a method.\noperators are used for primitive type comparisons and so "==" is used for memory address comparison."equals" method is used for comparing objects. Just remember that .equals(...) has to be implemented by the class you are trying to compare. Otherwise, there isn\'t much of a point; the version of the method for the Object class does the same thing as the comparison operation: Object#equals.The only time you really want to use the comparison operator for objects is wen you are comparing Enums. This is because there is only one instance of an Enum value at a time. For instance, given the enumYou will never have more than one instance of A at a time, and the same for B and C. This means that you can actually write a method like so:And you will have no problems whatsoever.The == operator:The == is a relational operator in Java that is used to compare two operands. It is used to determine whether the two operands are equal or not. Using the == operator, you can compare any primitive type such as int, char, float and Booleans. After comparison, the == operator returns a boolean value. If the two operands are equal, the == operator returns a true value. However, if the two operands are not equal, it returns a false value.\nWhen used with objects, the == operator compares the two object references and determines whether they refer to the same instance.The .equals() Methodequals() is a method available in the String class that is used to compare two strings and determine whether they are equal. This method returns a boolean value as a result of the comparison. If the two strings contain the same characters in the same order, the equals() method returns true. Otherwise, it returns a false value.For Examples:http://goo.gl/Sa3q5YWhen you evaluate the code, it is very clear that (==) compares according to memory address, while equals(Object o)  compares hashCode() of the instances. \nThat\'s why it is said do not break the contract between equals() and  hashCode() if you do not face surprises later. == can be used in many object types but you can use Object.equals for any type , especially Strings and Google Map Markers.Also note that .equals() normally contains == for testing as this is the first thing you would wish to test for if you wanted to test if two objects are equal. And == actually does look at values for primitive types, for objects it checks the reference.== operator always reference is compared. But in case of equals() methodit\'s depends\'s on implementation if we are overridden equals method than it compares object on basic of implementation given in overridden method. in above code both obj and obj1 object contains same data but reference is not same so equals return false and == also.\nbut if we overridden equals method thanknow check out it will return true and false for same case only we overridden equals method .it compare object on basic of content(id) of objectbut ==still compare references of object.----Output-----\n   true\n   false\n   trueIt may be worth adding that for wrapper objects for primitive types - i.e. Int, Long, Double - == will return true if the two values are equal.To contrast, putting the above two Longs into two separate ArrayLists, equals sees them as the same, but == doesn\'t.Since Java doesn\xe2\x80\x99t support operator overloading, == behaves identical\n  for every object but equals() is method, which can be overridden in\n  Java and logic to compare objects can be changed based upon business\n  rules.Main difference between == and equals in Java is that "==" is used to\n  compare primitives while equals() method is recommended to check\n  equality of objects.String comparison is a common scenario of using both == and equals method. Since java.lang.String class override equals method, It\n  return true if two String object contains same content but == will\n  only return true if two references are pointing to same object.Here is an example of comparing two Strings in Java for equality using == and equals() method which will clear some doubts:The String pool (aka interning) and Integer pool blur the difference further, and may allow you to use == for objects in some cases instead of .equalsThis can give you greater performance (?), at the cost of greater complexity.E.g.:Complexity tradeoff: the following may surprise you:I advise you to stay away from such micro-optimization, and always use .equals for objects, and == for primitives:Basically, == compares if two objects have the same reference on the heap, so unless two references are linked to the same object, this comparison will be false.equals() is a method inherited from Object class. This method by default compares if two objects have the same referece. It means:object1.equals(object2) <=> object1 == object2However, if you want to establish equality between two objects of the same class you should override this method. It is also very important to override the method hashCode() if you have overriden equals().Implement hashCode() when establishing equality is part of the Java Object Contract. If you are working with collections, and you haven\'t implemented hashCode(), Strange Bad Things could happen:null will be printed after executing the previous code if you haven\'t implemented hashCode().The major difference between == and equals() is1) == is used to compare primitives.For example : 2) equals() is used to compare objects.\nFor example :