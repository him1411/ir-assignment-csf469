I\'ve been trying to learn Go on my own, but I\'ve been stumped on trying read from and write to ordinary files.I can get as far as inFile, _ := os.Open(INFILE, 0, 0), but actually getting the content of the file doesn\'t make sense, because the read function takes a []byte as a parameter.Let\'s make a Go 1-compatible list of all the ways to read and write files in Go.Because file API has changed recently and most other answers don\'t work with Go 1. They also miss bufio which is important IMHO.In the following examples I copy a file by reading from it and writing to the destination file.Start with the basicsHere I used os.Open and os.Create which are convenient wrappers around os.OpenFile. We usually don\'t need to call OpenFile directly.Notice treating EOF. Read tries to fill buf on each call, and returns io.EOF as error if it reaches end of file in doing so. In this case buf will still hold data. Consequent calls to Read returns zero as the number of bytes read and same io.EOF as error. Any other error will lead to a panic.Using bufiobufio is just acting as a buffer here, because we don\'t have much to do with data. In most other situations (specially with text files) bufio is very useful by giving us a nice API for reading and writing easily and flexibly, while it handles buffering behind the scenes.Using ioutilEasy as pie! But use it only if you\'re sure you\'re not dealing with big files.This is good version:Using io.CopyIf you don\'t feel like reinventing the wheel, the io.Copy and io.CopyN may serve you well. If you check the source of the io.Copy function, it is nothing but one of the Mostafa\'s solutions (the \'basic\' one, actually) packaged in the Go library. They are using a significantly larger buffer than he is, though.[]byte is a slice (similar to a substring) of all or part of a byte array. Think of the slice as a value structure with a hidden pointer field for the system to locate and access all or part of an array (the slice), plus fields for the length and capacity of the slice, which you can access using the len() and cap() functions.Here\'s a working starter kit for you, which reads and prints a binary file; you will need to change the inName literal value to refer to a small file on your system.Try this:Which a new Go versions, reading/writing to/from file is easy. To read from a file:To write to a file:This will overwrite the content of a file (create a new file if it was not there).Just looking at the documentation it seems you should just declare a buffer of type []byte and pass it to read which will then read up to that many characters and return the number of characters actually read (and an error).The docs sayRead reads up to len(b) bytes from the File. It returns the number of bytes read and an Error, if any. EOF is signaled by a zero count with err set to EOF.Does that not work?EDIT: Also, I think you should perhaps use the Reader/Writer interfaces declared in the bufio package instead of using os package.The Read method takes a byte parameter because that is the buffer it will read into. It\'s a common Idiom in some circles and makes some sense when you think about it.This way you can determine how many bytes will be read by the reader and inspect the return to see how many bytes actually were read and handle any errors appropriately.As others have pointed in their answers bufio is probably what you want for reading from most files. I\'ll add one other hint since it\'s really useful. Reading a line from a file is best accomplished not by the ReadLine method but the ReadBytes or ReadString method instead.