Any idea why the piece of code below does not add the script element to the DOM?I\'ve seen issues where some browsers don\'t respect some changes when you do them directly (by which I mean creating the HTML from text like you\'re trying with the script tag), but when you do them with built-in commands things go better.  Try this:From: JSON for jQueryThe Good News is:It\'s 100% working.Just add something inside the script tag such as alert(\'voila!\');. The right question you might want to ask perhaps, "Why didn\'t I see it in the DOM?".Karl Swedberg has made a nice explanation to visitor\'s comment in jQuery API site. I don\'t want to repeat all his words, you can read directly there here (I found it hard to navigate through the comments there).All of jQuery\'s insertion methods use\n  a domManip function internally to\n  clean/process elements before and\n  after they are inserted into the DOM.\n  One of the things the domManip\n  function does is pull out any script\n  elements about to be inserted and run\n  them through an "evalScript routine"\n  rather than inject them with the rest\n  of the DOM fragment. It inserts the\n  scripts separately, evaluates them,\n  and then removes them from the DOM.I believe that one of the reasons jQuery\n  does this is to avoid "Permission\n  Denied" errors that can occur in\n  Internet Explorer when inserting\n  scripts under certain circumstances.\n  It also avoids repeatedly\n  inserting/evaluating the same script\n  (which could potentially cause\n  problems) if it is within a containing\n  element that you are inserting and\n  then moving around the DOM.The next thing is, I\'ll summarize what\'s the bad news by using .append() function to add a script.And The Bad News is..You can\'t debug your code.I\'m not joking, even if you add debugger; keyword between the line you want to set as breakpoint, you\'ll be end up getting only the call stack of the object without seeing the breakpoint on the source code, (not to mention that this keyword only works in webkit browser, all other major browsers seems to omit this keyword).If you fully understand what your code does, than this will be a minor drawback. But if you don\'t, you will end up adding a debugger; keyword all over the place just to find out what\'s wrong with your (or my) code. Anyway, there\'s an alternative, don\'t forget that javascript can natively manipulate HTML DOM. Workaround.Use javascript (not jQuery) to manipulate HTML DOMIf you don\'t want to lose debugging capability, than you can use javascript native HTML DOM manipulation. Consider this example:There it is, just like the old days isn\'t it. And don\'t forget to clean things up whether in the DOM or in the memory for all object that\'s referenced and not needed anymore to prevent memory leaks. You can consider this code to clean things up:The drawback from this workaround is that you may accidentally add a duplicate script, and that\'s bad. From here you can slightly mimic .append() function by adding an object verification before adding, and removing the script from the DOM right after it was added. Consider this example:This way, you can add script with debugging capability while safe from script duplicity. This is just a prototype, you can expand for whatever you want it to be. I have been using this approach and quite satisfied with this. Sure enough I will never use jquery .append() to add a script.Happy Coding,\nHendra Uzia.It is possible to dynamically load a JavaScript file using the jQuery function getScriptNow the external script will be called, and if it cannot be loaded it will gracefully degrade.What do you mean "not working"?jQuery detects that you\'re trying to create a SCRIPT element and will automatically run the contents of the element within the global context. Are you telling me that this doesn\'t work for you? -Edit: If you\'re not seeing the SCRIPT element in the DOM (in Firebug for example) after you run the command that\'s because jQuery, like I said, will run the code and then will delete the SCRIPT element - I believe that SCRIPT elements are always appended to the body... but anyway - placement has absolutely no bearing on code execution in this situation.This works:It seems like jQuery is doing something clever with scripts so you need to append the html element rather than jQuery object.Try this may be helpful: I want to do the same thing but to append a script tag in other frame!The </script> within the string literal terminates the entire script, to avoid that "</scr" + "ipt>" can be used instead.Adding the sourceURL in the script file helped as mentioned in this page:\nhttps://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/Your script is executing , you just can\'t use document.write from it. Use an alert to test it and avoid using document.write. The statements of your js file with document.write will not be executed and the rest of the function will be executed.This is what I think is the best solution. Google Analytics is injected this way.You don\'t need jQuery to create a Script DOM Element. It can be done with vanilla ES6 like so:It doesn\'t need to be wrapped in a Promise, but doing so allows you to resolve the promise when the script loads, helping prevent race conditions for long-running scripts.Append script to body:Another way you can do it if you want to append code is using the document.createElement method but then using .innerHTML instead of .src.Just create an element by parsing it with jQuery.Working example: https://plnkr.co/edit/V2FE28Q2eBrJoJ6PUEBz