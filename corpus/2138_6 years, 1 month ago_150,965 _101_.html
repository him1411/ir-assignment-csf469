It has just come to light that the UIDevice uniqueIdentifier property is deprecated in iOS5 and above. No alternative method or property appears to be available or forthcoming.Many of our existing apps are tightly dependent on this property for uniquely identifying a particular device.  Can anyone suggest any ideas how we might handle this problem going forward?The suggestion from the documentation is...Special ConsiderationsDo not use the uniqueIdentifier property. To create a unique identifier specific \n  to your app, you can call the CFUUIDCreate function to create a UUID, and write \n  it to the defaults database using the NSUserDefaults class.However this value won\'t be the same if a user uninstalls and re-installs the app.A UUID created by CFUUIDCreate is unique if a user uninstalls and re-installs the app: you will get a new one each time.But you might want it to be not unique, i. e. it should stay the same when the user uninstalls and re-installs the app. This requires a bit of effort, since the most reliable per-device-identifier seems to be the MAC address. You could query the MAC and use that as UUID.Edit: One needs to always query the MAC of the same interface, of course. I guess the best bet is with en0. The MAC is always present, even if the interface has no IP/is down.Edit 2: As was pointed out by others, the preferred solution since iOS 6 is -[UIDevice identifierForVendor]. In most cases, you should be able use it as a drop-in replacement to the old -[UIDevice uniqueIdentifier] (but a UUID that is created when the app starts for the first time is what Apple seems to want you to use).Edit 3: So this major point doesn\'t get lost in the comment noise: do not use the MAC as UUID, create a hash using the MAC. That hash will always create the same result every time, even across reinstalls and apps (if the hashing is done in the same way). Anyways, nowadays (2013) this isn\'t necessary any more except if you need a "stable" device identifier on iOS < 6.0.Edit 4: In iOS 7, Apple now always returns a fixed value when querying the MAC to specifically thwart the MAC as base for an ID scheme. So you now really should use -[UIDevice identifierForVendor] or create a per-install UUID.You can use your alternative for Apple UDID already. Kind guy gekitz wrote category on UIDevice which will generate some kind of UDID based on device mac-address and bundle identifier.You can find code on githubBased on the link proposed by @moonlight, i did several tests and it seems to be the best solution. As @DarkDust says the method goes to check en0 which is always available.\nThere are 2 options:\nuniqueDeviceIdentifier (MD5 of MAC+CFBundleIdentifier)\nand uniqueGlobalDeviceIdentifier(MD5 of the MAC), these always returns the same values.\nBelow the tests i\'ve done (with the real device):XXXX21f1f19edff198e2a2356bf4XXXX - (WIFI)UDID\n  XXXX7dc3c577446a2bcbd77935bdXXXX - (WIFI)GlobalAppUDID    XXXX21f1f19edff198e2a2356bf4XXXX - (3G)UDID\n  XXXX7dc3c577446a2bcbd77935bdXXXX - (3G)GlobalAppUDID       XXXX21f1f19edff198e2a2356bf4XXXX - (GPRS)UDID\n  XXXX7dc3c577446a2bcbd77935bdXXXX - (GPRS)GlobalAppUDIDXXXX21f1f19edff198e2a2356bf4XXXX - (AirPlane mode)UDID\n  XXXX7dc3c577446a2bcbd77935bdXXXX - (AirPlane mode)GlobalAppUDIDXXXX21f1f19edff198e2a2356bf4XXXX - (Wi-Fi)after removing and\n  reinstalling the app  XXXX7dc3c577446a2bcbd77935bdXXXX (Wi-Fi) after\n  removing and installing the appHope it\'s useful.EDIT:\nAs others pointed out, this solution in iOS 7 is no longer useful since uniqueIdentifier is no longer available and querying for MAC address now returns always 02:00:00:00:00:00check this out,we can use Keychain instead of NSUserDefaults class, to store UUID created by CFUUIDCreate.with this way we could avoid for UUID recreation with reinstallation, \nand obtain always same UUID for same application even user uninstall and reinstall again.UUID will recreated just when device reset by user.I tried this method with SFHFKeychainUtils and it\'s works like a charm. Create your own UUID and then store it in the Keychain. Thus it persists even when your app gets uninstalled. In many cases it also persists even if the user migrates between devices (e.g. full backup and restore to another device). Effectively it becomes a unique user identifier as far as you\'re concerned. (even better than device identifier).Example:I am defining a custom method for creating a UUID as :You can then store it in KEYCHAIN on the very first launch of your app. So that after first launch, we can simply use it from keychain, no need to regenerate it.  The main reason for using Keychain to store is: When you set the UUID to the Keychain, it will persist even if the user completely uninstalls the App and then installs it again. . So, this is the permanent way of storing it, which means the key will be unique all the way.On applictaion launch include the following code :Download SSKeychain.m and .h file from  sskeychain and Drag SSKeychain.m and .h file to your project  and add "Security.framework" to your project.\nTo use UUID afterwards simply use :Perhaps you can use:Apple\'s documentation describes identifierForVender as follows:The value of this property is the same for apps that come from the same vendor running on the same device. A different value is returned for apps on the same device that come from different vendors, and for apps on different devices regardless of vendor.You may want to consider using OpenUDID which is a drop-in replacement for the deprecated UDID.Basically, to match the UDID, the following features are required:OpenUDID fulfills the above and even has a built-in Opt-Out mechanism for later consideration.Check http://OpenUDID.org it points to the corresponding GitHub.\nHope this helps!As a side note, I would shy away from any MAC address alternative. While the MAC address appears like a tempting and universal solution, be sure that this low hanging fruit is poisoned. The MAC address is very sensitive, and Apple may very well deprecate access to this one before you can even say "SUBMIT THIS APP"... the MAC network address is used to authenticate certain devices on private lans (WLANs) or other virtual private networks (VPNs). .. it\'s even more sensitive than the former UDID!I\'m sure Apple have annoyed many people with this change. I develop a bookkeeping app for iOS and have an online service to sync changes made on different devices. The service maintains a database of all devices and the changes that need to be propagated to them. Therefore it\'s important to know which devices are which. I\'m keeping track of devices using the UIDevice uniqueIdentifier and for what it\'s worth, here are my thoughts.Generate a UUID and store in user defaults?\nNo good because this does not persist when the user deletes the app. If they install again later the online service should not create a new device record, that would waste resources on the server and give a list of devices containing the same one two or more times. Users would see more than one "Bob\'s iPhone" listed if they re-installed the app.Generate a UUID and store in the keychain?\nThis was my plan, since it persists even when the app is uninstalled. But when restoring an iTunes backup to a new iOS device, the keychain is transferred if the backup is encrypted. This could lead to two devices containing the same device id if the old and new devices are both in service. These should be listed as two devices in the online service, even if the device name is the same.Generate a hash the MAC address and bundle id?\nThis looks like the best solution for what I need. By hashing with the bundle id, the generated device id is not going to enable the device to be tracked across apps and I get a unique ID for the app+device combination.It\'s interesting to note that Apple\'s own documentation refers to validating Mac App Store receipts by computing a hash of the system MAC address plus the bundle id and version. So this seems allowable by policy, whether it passes through app review I don\'t yet know.It looks like for iOS 6, Apple is recommending you use the NSUUID class.From the message now in the UIDevice docs for uniqueIdentifier property:Deprecated in iOS 5.0. Use the identifierForVendor property of this\n  class or the advertisingIdentifier property of the ASIdentifierManager\n  class instead, as appropriate, or use the UUID method of the NSUUID\n  class to create a UUID and write it to the user defaults database.May help:\nuse below code it will always Unique except you erase(Format) your device.I would also suggest changing over from uniqueIdentifier to this open source library (2 simple categories really) that utilize the device\xe2\x80\x99s MAC Address along with the App Bundle Identifier to generate a unique ID in your applications that can be used as a UDID replacement.Keep in mind that unlike the UDID this number will be different for every app.You simply need to import the included NSString and UIDevice categories and call [[UIDevice currentDevice] uniqueDeviceIdentifier] like so:You can find it on Github here:UIDevice with UniqueIdentifier for iOS 5Here are the categories (just the .m files - check the github project for the headers):UIDevice+IdentifierAddition.mNSString+MD5Addition.m:You can achieve from this code : UIDevice-with-UniqueIdentifier-for-iOS-5The MAC address can be spoofed which makes such an approach useless for tying content to specific users or implementing security features like blacklists.After some further research it appears to me that we\'re left without a proper alternative as of now. I seriously hope Apple will reconsider their decision.Maybe it would be a good idea to email Apple about this topic and / or file a bug / feature request on this since maybe they are not even aware of the full consequences for developers.UIDevice identifierForVendor introduced in iOS 6 would work for your purposes.identifierForVendor is an alphanumeric string that uniquely identifies a device to the app\xe2\x80\x99s vendor. (read-only)The value of this property is the same for apps that come from the same vendor running on the same device. A different value is returned for apps onthe same device that come from different vendors, and for apps on different devices regardles of vendor.Available in iOS 6.0 and later and declared in UIDevice.hFor iOS 5 refer this link UIDevice-with-UniqueIdentifier-for-iOS-5Using the SSKeychain and code mentioned above. Here\'s code to copy/paste (add SSKeychain module):}This is code I\'m using to get ID for both iOS 5 and iOS 6, 7:From iOS 6 onwards, we have NSUUID class which complies RFC4122Apple Link : apple_ref for NSUUIDFollowing code helps to get UDID:iOS 11 has introduced the DeviceCheck framework. It has a fullproof solution for uniquely identifying the device.You can use Which is unique for the device in all application.Apple has added a new framework in iOS 11 called DeviceCheck which will help you to get the unique identifier very easily.\nRead this form more information.\nhttps://medium.com/@santoshbotre01/unique-identifier-for-the-ios-devices-590bb778290dDont use these libraries - libOmnitureAppMeasurement, It does use uniqueIdentifier which apple doesnt support anymoreIf someone stumble upon to this question, when searching for an alternative. I have followed this approach in IDManager class,\nThis is a collection from different solutions. KeyChainUtil is a wrapper to read from keychain. \nYou can also use the hashed MAC address as a kind of unique ID.Use this for finding UniqueIdetifier in iOS :https://github.com/gekitz/UIDevice-with-UniqueIdentifier-for-iOS-5/blob/master/Classes/UIDevice+IdentifierAddition.m#L32We can use identifierForVendor for ios7,--Important Note ---UDID and identifierForVendor are different:---Apple has hidden the UDID from all public APIs, starting with iOS 7. Any UDID that begins with FFFF is a fake ID. The "Send UDID" apps that previously worked can no longer be used to gather UDID for test devices. (sigh!)The UDID is shown when a device is connected to XCode (in the organizer), and when the device is connected to iTunes (although you have to click on \'Serial Number\' to get the Identifier to display.If you need to get the UDID for a device to add to a provisioning profile, and can\'t do it yourself in XCode, you will have to walk them through the steps to copy/paste it from iTunes.Is there a way since (iOS 7's release) to get the UDID without using iTunes on a PC/Mac?I had got some issue too, and solution is simple: A not perfect but one of the best and closest alternative to UDID (in Swift using iOS 8.1 and Xcode 6.1):Generating a random UUIDAnd use KeychainWrapper library:Add a string value to keychain:Retrieve a string value from keychain:Remove a string value from keychain:This solution uses the keychain, thus the record stored in the keychain will be persisted, even after the app is uninstalled and reinstalled. The only way of deleting this record is to Reset all contents and settings of the device. That is why I mentioned that this solution of substitution is not perfect but stays one of the best solution of replacement for UDID on iOS 8.1 using Swift.A working way to get UDID:An example using RoutingHTTPServer:Here are the contents of udid.mobileconfig:The profile installation will fail (I didn\'t bother to implement an expected response, see documentation), but the app will get a correct UDID. And you should also sign the mobileconfig. 