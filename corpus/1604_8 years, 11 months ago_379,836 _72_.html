Is there a good reason why there is no Pair in Java? What would be the equivalent of this C++ construct? I would rather avoid reimplementing my own.It seems that 1.6 is providing something similar (AbstractMap.SimpleEntry), but this looks quite convoluted.In a thread on comp.lang.java.help, Hunter Gratzner gives some arguments against the presence of a Pair construct in Java. The main argument is that a class Pair doesn\'t convey any semantics about the relationship between the two values (how do you know what "first" and "second" mean ?).A better practice is to write a very simple class, like the one Mike proposed, for each application you would have made of the Pair class. Map.Entry is an example of a pair that carry its meaning in its name.To sum up, in my opinion it is better to have a class Position(x,y), a class Range(begin,end) and a class Entry(key,value) rather than a generic Pair(first,second) that doesn\'t tell me anything about what it\'s supposed to do.This is Java. You have to make your own tailored Pair class with descriptive class and field names, and not to mind that you will reinvent the wheel by writing hashCode()/equals() or implementing Comparable again and again.HashMap compatible Pair class:The shortest pair that I could come up with is the following, using Lombok:It has all the benefits of the answer from @arturh (except the comparability), it has hashCode, equals, toString and a static \xe2\x80\x9cconstructor\xe2\x80\x9d.Another way to implement Pair with.Simple factory so you don\'t have to provide the types. e.g. Pair.of("hello", 1);Apache Commons Lang 3.0+ has a few Pair classes: \nhttp://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/tuple/package-summary.htmlHow about http://www.javatuples.org/index.html I have found it very useful.The javatuples offers you tuple classes from one to ten elements:It depends on what you want to use it for.  The typical reason to do so is to iterate over maps, for which you simply do this (Java 5+):android provides Pairclass (http://developer.android.com/reference/android/util/Pair.html) , here the implementation:The biggest problem is probably that one can\'t ensure immutability on A and B (see How to ensure that type parameters are immutable) so hashCode() may give inconsistent results for the same Pair after is inserted in a collection for instance (this would give undefined behavior, see Defining equals in terms of mutable fields). For a particular (non generic) Pair class the programmer may ensure immutability by carefully choosing A and B to be immutable.Anyway, clearing generic\'s warnings from @PeterLawrey\'s answer (java 1.7) :Additions/corrections much welcome :) In particular I am not quite sure about my use of Pair<?, ?>.For more info on why this syntax see here and for a detailed explanation hereAs many others have already stated, it really depends on the use case if a Pair class is useful or not.I think for a private helper function it is totally legitimate to use a Pair class if that makes your code more readable and is not worth the effort of creating yet another value class with all its boiler plate code.On the other hand, if your abstraction level requires you to clearly document the semantics of the class that contains two objects or values, then you should write a class for it. Usually that\'s the case if the data is a business object.As always, it requires skilled judgement.For your second question I recommend the Pair class from the Apache Commons libraries. Those might be considered as extended standard libraries for Java:https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/tuple/Pair.htmlYou might also want to have a look at Apache Commons\' EqualsBuilder, HashCodeBuilder and ToStringBuilder which simplify writing value classes for your business objects.In my opinion, there is no Pair in Java because, if you want to add extra functionality directly on the pair (e.g. Comparable), you must bound the types. In C++, we just don\'t care, and if types composing a pair do not have operator <, the pair::operator < will not compile as well.An example of Comparable with no bounding:An example of Comparable with compile-time check for whether type arguments are comparable:This is good, but this time you may not use non-comparable types as type arguments in Pair.\nOne may use lots of Comparators for Pair in some utility class, but C++ people may not get it. Another way is to write lots of classes in a type hierarchy with different bounds on type arguments, but there are too many possible bounds and their combinations...JavaFX (which comes bundled with Java 8) has the Pair< A,B > classMap.Entry interface come pretty close to c++ pair. Look at the concrete implementation, like AbstractMap.SimpleEntry and AbstractMap.SimpleImmutableEntry\nFirst item is getKey() and second is getValue().According to the nature of Java language, I suppose people do not actually require a Pair, an interface is usually what they need. Here is an example:So, when people want to return two values they can do the following:This is a pretty lightweight solution, and it answers the question "What is the semantic of a Pair<L,R>?". The answer is, this is an interface build with two (may be different) types, and it has methods to return each of them. It is up to you to add further semantic to it. For example, if you are using Position and REALLY want to indicate it in you code, you can define PositionX and PositionY that contains Integer, to make up a Pair<PositionX,PositionY>. If JSR 308 is available, you may also use Pair<@PositionX Integer, @PositionY Ingeger> to simplify that.EDIT:\nOne thing I should indicate here is that the above definition explicitly relates the type parameter name and the method name. This is an answer to those argues that a Pair is lack of semantic information. Actually, the method getL means "give me the element that correspond to the type of type parameter L", which do means something.EDIT:\nHere is a simple utility class that can make life easier:usage:Good News Java added key value Pair . just import javafx.util.Pair;and use simply as in c++ .e.g. You can use javafx utility class, Pair which serves the same purpose as pair <> in c++. https://docs.oracle.com/javafx/2/api/javafx/util/Pair.htmlPair would be a good stuff, to be a basic construction unit for a complex generics, for instance, this is from my code:It is just the same as Haskell\'s TupleFor programming languages like Java, the alternate data structure used by most programmers to represent pair like data-structures are two array, and data is accessed via the same index example: http://www-igm.univ-mlv.fr/~lecroq/string/node8.html#SECTION0080This isn\'t ideal as the data should be bound together, but also turn out to be pretty cheap. Also, if your use case demands storing co-ordinates then its better to build your own data structure. I\'ve something like this in my libraryDespite being syntactically similar, Java and C++ have very different paradigms. Writing C++ like Java is bad C++, and writing Java like C++ is bad Java.With a reflection based IDE like Eclipse, writing the necessarily functionality of a "pair" class is quick and simple. Create class, define two fields, use the various "Generate XX" menu options to fill out the class in a matter of seconds. Maybe you\'d have to type a "compareTo" real quick if you wanted the Comparable interface.With separate declaration / definition options in the language C++ code generators aren\'t so good, so hand writing little utility classes is more time consuming tedium. Because the pair is a template, you don\'t have to pay for functions you don\'t use, and the typedef facility allows assigning meaningful typenames to the code, so the objections about "no semantics" don\'t really hold up.Brian Goetz, Paul Sandoz and Stuart Marks explain why during QA session at Devoxx\'14.Having generic pair class in standard library will turn into technical debt once value types introduced.See also: Does Java SE 8 have Pairs or Tuples?Simple way Object [] - can be use as an\xd1\x83 dimention tupleI noticed all the Pair implementations being strewn around here attribute meaning to the order of the two values. When I think of a pair, I think of a combination of two items in which the order of the two is of no importance. Here\'s my implementation of an unordered pair, with hashCode and equals overrides to ensure the desired behaviour in collections. Also cloneable.This implementation has been properly unit tested and the use in a Set and Map has been tried out.  Notice I\'m not claiming to release this in the public domain. This is code I\'ve just written for use in an application, so if you\'re going to use it, please refrain from making a direct copy and mess about with the comments and names a bit. Catch my drift?If anyone wants a dead-simple and easy to use version I made my available at https://github.com/lfac-pt/Java-Pair. Also, improvements are very much welcome!You can use Google\'s AutoValue library - https://github.com/google/auto/tree/master/value.You create a very small abstract class and annotate it with @AutoValue and the annotation processor generates a concrete class for you that has a value semantic.Here are some libraries that have multiple degrees of tuples for your convenience:Other libraries have been mentioned to contain at least the Pair tuple.Specifically, in the context of functional programming which makes use of a lot of structural typing, rather than nominal typing (as advocated in the accepted answer), those libraries and their tuples come in very handy.usage :Immutable, only a pair !Many people are posting Pair code that is usable as a key in a Map...If you\'re trying to use a pair as a hashing key (a common idiom), be sure to check out Guava\'s Table<R,C,V>: http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Table. They give the following example usage, for graph edges:A Table maps two keys to a single value, and provides efficient lookups for both types of keys alone as well. I\'ve started using this data structure instead of a Map<Pair<K1,K2>, V> in many parts of my code. There are array, tree, and other implementations for both dense and sparse uses, with the option of specifying your own intermediate map classes.com.sun.tools.javac.util.Pair is an simple implementation of a pair. \nIt can be found in jdk1.7.0_51\\lib\\tools.jar.Other than the org.apache.commons.lang3.tuple.Pair, it\'s not just an interface.