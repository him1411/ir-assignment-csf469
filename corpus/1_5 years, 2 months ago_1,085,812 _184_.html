Here is a piece of C++ code that seems very peculiar. For some strange reason, sorting the data miraculously makes the code almost six times faster.Initially, I thought this might be just a language or compiler anomaly. So I tried it in Java.With a somewhat similar but less extreme result.My first thought was that sorting brings the data into the cache, but then I thought how silly that is because the array was just generated.You are a victim of branch prediction fail.Consider a railroad junction:\nImage by Mecanismo, via Wikimedia Commons. Used under the CC-By-SA 3.0 license.Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want to go. And then you set the switch appropriately.Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.Is there a better way? You guess which direction the train will go!If you guess right every time, the train will never have to stop.\nIf you guess wrong too often, the train will spend a lot of time stopping, backing up, and restarting.Consider an if-statement: At the processor level, it is a branch instruction:You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.Modern processors are complicated and have long pipelines. So they take forever to "warm up" and "slow down".Is there a better way? You guess which direction the branch will go!If you guess right every time, the execution will never have to stop.\nIf you guess wrong too often, you spend a lot of time stalling, rolling back, and restarting.This is branch prediction. I admit it\'s not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn\'t know which direction a branch will go until the last moment.So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every 3 times, you guess the same...In other words, you try to identify a pattern and follow it. This is more or less how branch predictors work.Most applications have well-behaved branches. So modern branch predictors will typically achieve >90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.Further reading: "Branch predictor" article on Wikipedia.Notice that the data is evenly distributed between 0 and 255. \nWhen the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.This is very friendly to the branch predictor since the branch consecutively goes the same direction many times.\nEven a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.Quick visualization:However, when the data is completely random, the branch predictor is rendered useless because it can\'t predict random data.\nThus there will probably be around 50% misprediction. (no better than random guessing)So what can be done?If the compiler isn\'t able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.Replace:with:This eliminates the branch and replaces it with some bitwise operations.(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it\'s valid for all the input values of data[].)Benchmarks: Core i7 920 @ 3.5 GHzC++ - Visual Studio 2010 - x64 ReleaseJava - Netbeans 7.1.1 JDK 7 - x64Observations:A general rule of thumb is to avoid data-dependent branching in critical loops. (such as in this example)Update:GCC 4.6.1 with -O3 or -ftree-vectorize on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.VC++ 2010 is unable to generate conditional moves for this branch even under /Ox.Intel Compiler 11 does something miraculous. It interchanges the two loops, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...If you give the Intel Compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...Branch prediction.With a sorted array, the condition data[c] >= 128 is first false for a streak of values, then becomes true for all later values. That\'s easy to predict. With an unsorted array, you pay for the branching cost.The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in Mysticial\'s answer.Now, if we look at the codewe can find that the meaning of this particular if... else... branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a conditional move statement, which would be compiled into a conditional move instruction: cmovl, in an x86 system. The branch and thus the potential branch prediction penalty is removed.In C, thus C++, the statement, which would compile directly (without any optimization) into the conditional move instruction in x86, is the ternary operator ... ? ... : .... So we rewrite the above statement into an equivalent one:While maintaining readability, we can check the speedup factor.On an Intel Core i7-2600K @ 3.4Â GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):x86x64The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.Now let\'s look more closely by investigating the x86 assembly they generate. For simplicity, we use two functions max1 and max2.max1 uses the conditional branch if... else ...:max2 uses the ternary operator ... ? ... : ...:On a x86-64 machine, GCC -S generates the assembly below.max2 uses much less code due to the usage of instruction cmovge. But the real gain is that max2 does not involve branch jumps, jmp, which would have a significant performance penalty if the predicted result is not right.So why does a conditional move perform better?In a typical x86 processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called pipelining.In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like Fetch and Decode does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction\'s execution time. This is why the conditional move version is slower than the branch when prediction is easy.The book Computer Systems: A Programmer\'s Perspective, second edition explains this in detail. You can check Section 3.6.6 for Conditional Move Instructions, entire Chapter 4 for Processor Architecture, and Section 5.11.2 for a special treatment for Branch Prediction and Misprediction Penalties.Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can\'t (the code in question is using Visual Studio\'s native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.If you are curious about even more optimizations that can be done to this code, consider this:Starting with the original loop:With loop interchange, we can safely change this loop to:Then, you can see that the if conditional is constant throughout the execution of the i loop, so you can hoist the if out:Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (/fp:fast is thrown, for example)That one is 100,000x faster than before No doubt some of us would be interested in ways of identifying code that is problematic for the CPU\'s branch-predictor. The Valgrind tool cachegrind has a branch-predictor simulator, enabled by using the --branch-sim=yes flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with g++, gives these results:Sorted:Unsorted:Drilling down into the line-by-line output produced by cg_annotate we see for the loop in question:Sorted:Unsorted:This lets you easily identify the problematic line - in the unsorted version the if (data[c] >= 128) line is causing 164,050,007 mispredicted conditional branches (Bcm) under cachegrind\'s branch-predictor model, whereas it\'s only causing 10,006 in the sorted version.Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.Sorted:Unsorted:It can also do source code annotation with dissassembly.See the performance tutorial for more details.Just read up on the thread and I feel an answer is missing. A common way to eliminate branch prediction that I\'ve found to work particularly good in managed languages is a table lookup instead of using a branch. (although I haven\'t tested it in this case)This approach works in general if:Background and whyPfew, so what the hell is that supposed to mean?From a processor perspective, your memory is slow. To compensate for the difference in speed, they build in a couple of caches in your processor (L1/L2 cache) that compensate for that. So imagine that you\'re doing your nice calculations and figure out that you need a piece of memory. The processor will get his \'load\' operation and loads the piece of memory into cache - and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this \'load\' will slow down your program. Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we\'ve already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!).Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.First thing we need to know is what is small? While smaller is generally better, a rule of thumb is to stick to lookup tables that are <=4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it\'s probably worth reconsidering.Constructing a tableSo we\'ve figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps a multiply). What you want is to have your input translated by the lookup function to some kind of \'unique key\' in your table, which then simply gives you the answer of all the work you wanted it to do.In this case: >=128 means we can keep the value, <128 means we get rid of it. The easiest way to do that is by using an \'AND\': if we keep it, we AND it with 7FFFFFFF ; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF\'s.Managed languagesYou might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don\'t mess up...Well, not exactly... :-)There has been quite some work on eliminating this branch for managed languages. For example:in this case it\'s obvious to the compiler that the boundary condition will never hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check all together. WOW - that means no branch. Similarly, it will deal with other obvious cases.If you run into trouble with lookups on managed languages - the key is to add a & 0x[something]FFF to your lookup function to make the boundary check predictable - and watch it going faster.The result for this caseAs data is distributed between 0 and 255 when array is sorted, around first half of the iterations will not enter the if-statement (if statement shared below).Question is what make the above statement not execute in certain case as in case of sorted data? Here comes the "Branch predictor" a branch predictor is a digital circuit that tries to guess which way a branch (e.g. an if-then-else structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!Lets do some bench marking to understand it betterThe performance of an if-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the if-statement will be much more expensive.Let\xe2\x80\x99s measure the performance of this loop with different conditions:Here are the timings of the loop with different True-False patterns:A \xe2\x80\x9cbad\xe2\x80\x9d true-false pattern can make an if-statement up to six times slower than a \xe2\x80\x9cgood\xe2\x80\x9d pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.So there is no doubt about impact of branch prediction on performance!One way to avoid branch prediction errors is to build a lookup table, and index it using the data.  Stefan de Bruijn discussed that in his answer.But in this case, we know values are in the range [0, 255] and we only care about values >= 128.  That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit.  Let\'s call this bit the "decision bit".By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted.  Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don\'t care about.  Here\'s the code:This code wastes half of the adds, but never has a branch prediction failure.  It\'s tremendously faster on random data than the version with an actual if statement.But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called lut for "LookUp Table" in the code).  Here\'s the C++ code:In this case the lookup table was only 256 bytes, so it fit nicely in cache and all was fast.  This technique wouldn\'t work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical.  On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table.  For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index.  A 12-bit table index implies a table of 4096 values, which might be practical.EDIT: One thing I forgot to put in.The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers, and used the "decision bit" technique to decide which one to follow.  For example, instead of:this library would do something like:Here\'s a link to this code: Red Black Trees, Eternally ConfuzzledIn the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.Indeed, the array is partitioned in a contiguous zone with data < 128 and another with data >= 128. So you should find the partition point with a dichotomic search (using Lg(arraySize) = 15 comparisons), then do a straight accumulation from that point.Something like (unchecked)or, slightly more obfuscatedA yet faster approach, that gives an approximate solution for both sorted or unsorted is: sum= 3137536; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) :-)The above behavior is happening because of Branch prediction.To understand branch prediction one must first understand Instruction Pipeline:Any instruction is broken into sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this example on Wikipedia.Generally modern processors have quite long pipelines, but for ease let\'s consider these 4 steps only.4-stage pipeline in general for 2 instructions.\nMoving back to the above question let\'s consider the following instructions:Without branch prediction the following would occur:To execute instruction B or instruction C the processor will have to wait till the instruction A doesn\'t reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.when if condition returns true:\nWhen if condition returns false:\nAs a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.So what is branch prediction?Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go onto that instruction (B or C in case of our example).In case of a correct guess, the pipeline looks something like this:\nIf it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. \nThe time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good branch predictor.In the OP\'s code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so first time it will randomly choose the next instruction. Later in the for loop it can base the prediction on the history. \nFor an array sorted in ascending order, there are three possibilities:Let us assume that the predictor will always assume the true branch on the first run.So in the first case it will always take the true branch since historically all its predictions are correct.\nIn the 2nd case, initially it will predict wrong, but after a few iterations it will predict correctly.\nIn the 3rd case it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it see branch prediction failure in history. In all these cases the failure will be too less in number and as a result only few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in less CPU cycles. But in case of random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.An official answer would be fromYou can also see from this lovely diagram why the branch predictor gets confused.Each element in the original code is a random valueso the predictor will change sides as the std::rand() blow.On the other hand, once it\'s sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.In the same line (I think this was not highlighted by any answer) it\'s good to mention that sometimes (specially in software where the performance matters\xe2\x80\x94like in the Linux kernel) you can find some if statements like the following:or similarly:Both likely() and unlikely() are in fact macros that are defined by using something like the GCC\'s __builtin_expect to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See this documentation that goes through the available GCC\'s builtins.Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it\'s critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.Frequently used Boolean operations in C++ produce many branches in compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value 0 for false and 1 for true.Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than 0 or 1, but operators that have Booleans as output can produce no other value than 0 or 1. This makes operations with Boolean variables as input less efficient than necessary.\nConsider example:This is typically implemented by the compiler in the following way:This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than 0 and 1. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if a and b have been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:char is used instead of bool in order to make it possible to use the bitwise operators (& and |) instead of the Boolean operators (&& and ||). The bitwise operators are single instructions that take only one clock cycle. The OR operator (|) works even if a and b have other values than 0 or 1. The AND operator (&) and the EXCLUSIVE OR operator (^) may give inconsistent results if the operands have other values than 0 and 1.~ can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be 0 or 1 by XOR\'ing it with 1:can be optimized to:a && b cannot be replaced with a & b if b is an expression that should not be evaluated if a is false ( && will not evaluate b, & will). Likewise, a || b can not be replaced with a | b if b is an expression that should not be evaluated if a is true.Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:is optimal in most cases (unless you expect the && expression to generate many branch mispredictions).This question has already been answered excellently many times over. Still I\'d like to draw the group\'s attention to yet another interesting analysis.Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted & unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.The link is here:\nhttp://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htmThat\'s for sure!...Branch Prediction makes the logic run slower because of the switching which happens in the code! It\'s like you going a straight street or a street with a lot of turning, for sure the straight one gonna be done in a faster time!If the array is sorted, your condition is false at the first step: data[c] >= 128, then becomes a true value for the whole way to the end of the street. That\'s how you get to the end of the logic faster. on the other hand, using unsorted array, you need alot of turning and processing which make your code run slower for sure...Look at the image I created for you below, which street gonna be finished faster?So programmatically, Branch Prediction causes the process be slower...Also at the end, it\'s good to know we have 2 kinds of branch predictions that each gonna effects your code differently:1. static2. dynamicStatic branch prediction is used by the microprocessor the first time\n  a conditional branch is encountered, and dynamic branch prediction is\n  used for succeeding executions of the conditional branch code.In order to effectively write your code to take advantage of these\n  rules, when writing if-else or switch statements, check the most\n  common cases first and work progressively down to the least common.\n  Loops do not necessarily require any special ordering of code for\n  static branch prediction, as only the condition of the loop iterator\n  is normally used.Branch-prediction gain!. It is important to understand, branch misprediction doesn\'t slow down programs. Cost of missed prediction is just as if branch prediction didn\'t exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).Whenever there\'s an if-else \\ switch statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional branch instructions are inserted. A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the if block) depending on some condition, which is the expression evaluation in our case.That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the if block, if the expression turns out to be true, then wonderful! we gained the time it took to evaluate it and made progress in the code, if not then we are running the wrong code, the pipeline is flushed and the correct block is run. Visualization:\nLets say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn\'t have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back. While flushing pipelines is super fast now-a-day taking this gamble is worthy. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes. 