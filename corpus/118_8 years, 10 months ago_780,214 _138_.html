I\'ve always been one to simply use:I use the interface as the type name for portability, so that when I ask questions such as these I can rework my code.  When should LinkedList be used over ArrayList and vice-versa?TL;DR ArrayList with ArrayDeque are preferable in much more use-cases than LinkedList. Not sure — just start with ArrayList.LinkedList and ArrayList are two different implementations of the List interface. LinkedList implements it with a doubly-linked list. ArrayList implements it with a dynamically re-sizing array.As with standard linked list and array operations, the various methods will have different algorithmic runtimes.For LinkedList<E>Note: O(n/4) is average, O(1) best case (e.g. index = 0), O(n/2) worst case (middle of list)For ArrayList<E>Note: O(n/2) is average, O(1) best case (end of list), O(n) worst case (start of list)LinkedList<E> allows for constant-time insertions or removals using iterators, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says "operations that index into the list will traverse the list from the beginning or the end, whichever is closer", so those methods are O(n/4) on average, though O(1) for index = 0.ArrayList<E>, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an ArrayList is O(n) in the worst case but constant on average.So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an ArrayList is technically faster, but unless you\'re doing something really performance-sensitive, you shouldn\'t worry about this -- they\'re both constants.)The main benefits of using a LinkedList arise when you re-use existing iterators to insert and remove elements. These operations can then be done in O(1) by changing the list locally only. In an array list, the remainder of the array needs to be moved (i.e. copied). On the other side, seeking in a LinkedList means following the links in O(n/2) for worst case, whereas in an ArrayList the desired position can be computed mathematically and accessed in O(1).Another benefit of using a LinkedList arise when you add or remove from the head of the list, since those operations are O(1), while they are O(n) for ArrayList. Note that ArrayDeque may be a good alternative to LinkedList for adding and removing from the head, but it is not a List.Also, if you have large lists, keep in mind that memory usage is also different. Each element of a LinkedList has more overhead since pointers to the next and previous elements are also stored. ArrayLists don\'t have this overhead. However, ArrayLists take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.The default initial capacity of an ArrayList is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you\'re going to add a lot of elements, construct the ArrayList with a higher initial capacity.Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a LinkedList is "lots more" than an ArrayList so I did some number crunching to demonstrate exactly how much both lists take up for N null references.Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit LinkedLists and ArrayLists.Note: The sizes shown for the ArrayList lines are for trimmed lists - In practice, the capacity of the backing array in an ArrayList is generally larger than its current element count.Note 2: (thanks BeeOnRope) As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.The result clearly shows that LinkedList is a whole lot more than ArrayList, especially with a very high element count. If memory is a factor, steer clear of LinkedLists.The formulas I used follow, let me know if I have done anything wrong and I will fix it up. \'b\' is either 4 or 8 for 32 or 64 bit systems, and \'n\' is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.ArrayList:LinkedList:ArrayList is what you want. LinkedList is almost always a (performance) bug.Why LinkedList sucks:As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.Algorithms: Big-Oh NotationArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.Yeah, I know, this is an ancient question, but I\'ll throw in my two cents:LinkedList is almost always the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList\'s ability to insert and delete elements in the middle of the list relatively quickly, once you\'ve navigated there with a ListIterator.There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this CircularArrayList implementation.  (Yes, it\'s from 2001, so you\'ll need to generify it, but I got comparable performance ratios to what\'s quoted in the article just now in a recent JVM)Correct or Incorrect: Please execute test locally and decide yourself!!Edit/Remove is faster in LinkedList than ArrayList.ArrayList, backed by Array, which needs to be double the size, is worse in large volume application.Below is the unit test result for each operation.Timing is given in Nanoseconds.It\'s an efficiency question.  LinkedList is fast for adding and deleting elements, but slow to access a specific element.  ArrayList is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.Array vs ArrayList vs LinkedList vs Vector:   -- goes more in depth, as does Linked listArrayList is essentially an array. LinkedList is implemented as a double linked list. The get is pretty clear. O(1) for ArrayList, because ArrayList allow random access by using index. O(n) for LinkedList, because it needs to find the index first. Note: there are different versions of add and remove. LinkedList is faster in add and remove, but slower in get. In brief, LinkedList should be preferred if: === ArrayList ====== LinkedList ===add(int index, E element)Here is a figure from programcreek.com (add and remove are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):ArrayList is randomly accessible, while LinkedList is really cheap to expand and remove elements from.  For most cases, ArrayList is fine.Unless you\'re created large lists and have measured a bottleneck, you\'ll probably never need to worry about the difference.1) Search: ArrayList search operation is pretty fast compared to the LinkedList search operation. get(int index) in ArrayList gives the performance of O(1) while LinkedList performance is O(n).Reason: ArrayList maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side LinkedList implements doubly linked list which requires the traversal through all the elements for searching an element.2) Deletion: LinkedList remove operation gives O(1) performance while ArrayList gives variable performance: O(n) in worst case (while removing first element) and O(1) in best case (While removing last element).Conclusion: LinkedList element deletion is faster compared to ArrayList.Reason: LinkedList\xe2\x80\x99s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.3) Inserts Performance: LinkedList add method gives O(1) performance while ArrayList gives O(n) in worst case. Reason is same as explained for remove.4) Memory Overhead: ArrayList maintains indexes and element data while LinkedList maintains element data and two pointers for neighbor nodes hence the memory consumption is high in LinkedList comparatively.There are few similarities between these classes which are as follows:Both ArrayList and LinkedList are implementation of List interface.\nThey both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.\nBoth these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.\nThe iterator and listIterator returned by these classes are fail-fast (if list is structurally modified at any time after the iterator is created, in any way except through the iterator\xe2\x80\x99s own remove or add methods, the iterator will throw a ConcurrentModificationException).When to use LinkedList and when to use ArrayList?1) As explained above the insert and remove operations give good performance (O(1)) in LinkedList compared to ArrayList(O(n)). Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.2) Search (get method) operations are fast in Arraylist (O(1)) but not in LinkedList (O(n)) so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.I know this is an old post, but I honestly can\'t believe nobody mentioned that LinkedList implements Deque.  Just look at the methods in Deque (and Queue); if you want a fair comparison, try running LinkedList against ArrayDeque and do a feature-for-feature comparison. If your code has add(0) and remove(0), use a LinkedList and it\'s prettier addFirst() and removeFirst() methods. Otherwise, use ArrayList.And of course, Guava\'s ImmutableList is your best friend.Here is the big O notation in both ArrayList and LinkedList and also CopyOnWrite-ArrayList\n\nArrayList\n\nget --> O(1) \nadd --> O(1) \ncontains --> O(n) \nnext --> O(1) \nremove --> O(n) \niterator.remove --> O(n) \nLinkedList \nget --> O(n) \nadd --> O(1) \ncontains --> O(n) \nnext --> O(1) \nremove --> O(1) \niterator.remove --> O(1) \nCopyOnWrite-ArrayList\n\nget --> O(1) \nadd --> O(n) \ncontains --> O(n) \nnext --> O(1) \nremove --> O(n) \niterator.remove --> O(n) \nBased on these you have to decide what to choose :)Joshua Bloch, the author of LinkedList:Does anyone actually use LinkedList?  I wrote it, and I never use it.Link: https://twitter.com/joshbloch/status/583813919019573248I\'m sorry for the answer for being not that informative as the other answers, but I thought it would be the most interesting and self-explanatory.Have a look at the below image....http://javaconceptoftheday.com/wp-content/uploads/2014/12/ArrayListVsLinkedList.pngImage Source : ArrayList Vs LinkedList In Java.Here is important different of bothIn addition to the other good arguments above, you should notice ArrayList implements RandomAccess interface, while LinkedList implements Queue.\nSo somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).See the Java Tutorials - List Implementations.An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.A linked list specifies a progression from one item to the next (Item a -> item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one. Let\'s compare LinkedList and ArrayList w.r.t. below parameters:ArrayList is the resizable array implementation of list interface , while LinkedList is the Doubly-linked list implementation of the list interface.ArrayList get(int index) operation runs in constant time i.e O(1)  while LinkedList get(int index) operation run time is O(n) .The reason behind ArrayList being faster than LinkedList is that ArrayList uses index based system for its elements as it internally uses array data structure , on the other hand ,LinkedList does not provide index based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.Insertions in LinkedList are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation . While in ArrayList, if array is full i.e worst case,  there is extra cost of  resizing array and copying elements to the new array , which makes runtime of add operation in ArrayList O(n) , otherwise it is O(1) .Remove operation in LinkedList is generally same as ArrayList i.e. O(n).In LinkedList , there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1) . The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as parameter . This method traverses the LinkedList until it found the Object and unlink it from the original list . Hence this method run time is O(n). While in ArrayList remove(int) method involves copying elements from old array to new updated array , hence its run time is O(n).LinkedList can be iterated in reverse direction using descendingIterator() while there is no descendingIterator() in ArrayList , so we need to write our own code to iterate over the ArrayList in reverse direction.If the constructor  is not overloaded , then ArrayList creates an empty list of initial capacity 10 , while LinkedList  only constructs the empty list without any initial capacity.Memory overhead in LinkedList is more as compared to ArrayList as node in LinkedList needs to maintain the addresses of next and previous node. While In ArrayList  each index only holds the actual object(data).SourceIt depends upon what operations you will be doing more on the List.ArrayList is faster to access an indexed value.  It is much worse when inserting or deleting objects.To find out more, read any article that talks about the difference betwen arrays and linked lists.I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.An important feature of a linked list (which I didn\'t read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)Important: For Java its LinkedList this is not true! See Is there a fast concat method for linked list in Java?Operation get(i) in ArrayList is faster than LinkedList, because:\nArrayList: Resizable-array implementation of the List interface\nLinkedList: Doubly-linked list implementation of the List and Deque interfacesOperations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ArrayList and LinkedList have their own pros and cons.ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList it is faster than doing n iterations with LinkedList.On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList. ArrayList and LinkedList both implements List interface  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.1) Search: ArrayList search operation is pretty fast compared to the LinkedList search operation. get(int index) in ArrayList gives the performance of O(1) while LinkedList performance is O(n).Reason: ArrayList maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side LinkedList implements doubly linked list which requires the traversal through all the elements for searching an element.2) Deletion: LinkedList remove operation gives O(1) performance while ArrayList gives variable performance: O(n) in worst case (while removing first element) and O(1) in best case (While removing last element).Conclusion: LinkedList element deletion is faster compared to\n  ArrayList.Reason: LinkedList\xe2\x80\x99s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.3) Inserts Performance: LinkedList add method gives O(1) performance while ArrayList gives O(n) in worst case. Reason is same as explained for remove.4) Memory Overhead: ArrayList maintains indexes and element data while LinkedList maintains element data and two pointers for neighbor nodes hence the memory consumption is high in LinkedList comparatively.Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.Both remove() and insert() have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However the reason behind the linear processing time comes from two very different reasons:In an ArrayList you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.In a LinkedList it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for remove() and 2 references for insert().Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Lets say we want to go through the entire List removing and inserting elements on our way. Usually you would start from the very beginning for each elements using the LinkedList, we could also "save" the current element we\'re working on with an Iterator. With the help of the Iterator we get a O(1) efficiency for remove() and insert() when working in a LinkedList. Making it the only performance benefit I\'m aware of where a LinkedList is always better than an ArrayList.When you want to add an item or delete an item from a list, without bothering about item\'s location, use ArrayList. It will be faster than linked list. Suppose if you want to add to or delete from a peculiar location in a collection, use linked listWhen should I use LinkedList? When working with stacks mostly, or when working with buffers.\nWhen should I use ArrayList? Only when working with indexes,  otherwise you can use HashTable with linked list, then you get:It seems like a good solution, and in most of the cases it is, how ever you should know:\nHashTable takes a lot of disc space, so when you need to manage 1,000,000 elements list it can become a thing that matters. This can happen in server implementations, in clients it is rarely the case.Also take a look at Red-Black-Tree