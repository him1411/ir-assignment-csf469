Is it possible to find all classes or interfaces in a given package? (Quickly looking at e.g. Package, it would seem like no.)Due to the dynamic nature of class loaders, this is not possible. Class loaders are not required to tell the VM which classes it can provide, instead they are just handed requests for classes, and have to return a class or throw an exception.However, if you write your own class loaders, or examine the classpaths and it\'s jars, it\'s possible to find this information. This will be via filesystem operations though, and not reflection. There might even be libraries that can help you do this.If there are classes that get generated, or delivered remotely, you will not be able to discover those classes.The normal method is instead to somewhere register the classes you need access to in a file, or reference them in a different class. Or just use convention when it comes to naming.Addendum: The Reflections Library will allow you to look up classes in the current classpath. It can be used to get all classes in a package:You should probably take a look at the open source Reflections library. With it you can easily achieve what you want.First, setup the reflections index (it\'s a bit messy since searching for all classes is disabled by default):Then you can query for all objects in a given package:Google Guava 14 includes a new class ClassPath with three methods to scan for top level classes:See the ClassPath javadocs for more info.This example is for Spring 4, but you can find the classpath scanner in earlier versions as well.Note: In version 14, the API is still marked as @Beta, so beware in production code.\nHello. I always have had some issues with the solutions above (and on other sites).\nI, as a developer, am programming a addon for a API. The API permitts the use of any external libraries or 3rd party tools. The setup also consists of a mixture of code in jar or zip files and class files located directly in some directories. So my code had to be able to work arround every setup. After a lot of research I have come up with a method that will work in at least 95% of all possible setups.The following code is basically the overkill method that will always work.This code scans a given package for all classes that are included in it. It will only work for all classes in the current ClassLoader.These three methods provide you with the ability to find all classes in a given package.\nYou use it like this:The method first gets the current ClassLoader. It then fetches all resources that contain said package and iterates of these URLs. It then creates a URLConnection and determines what type of URl we have. It can either be a directory (FileURLConnection) or a directory inside a jar or zip file (JarURLConnection). Depending on what type of connection we have two different methods will be called.First lets see what happens if it is a FileURLConnection.\nIt first checks if the passed File exists and is a directory. If that\'s the case it checks if it is a class file. If so a Class object will be created and put in the ArrayList. If it is not a class file but is a directory, we simply iterate into it and do the same thing. All other cases/files will be ignored.If the URLConnection is a JarURLConnection the other private helper method will be called. This method iterates over all Entries in the zip/jar archive. If one entry is a class file and is inside of the package a Class object will be created and stored in the ArrayList.After all resources have been parsed it (the main method) returns the ArrayList containig all classes in the given package, that the current ClassLoader knows about.If the process fails at any point a ClassNotFoundException will be thrown containg detailed information about the exact cause.Without using any extra libraries:In general class loaders do not allow for scanning through all the classes on the classpath. But usually the only used class loader is UrlClassLoader from which we can retrieve the list of directories and jar files (see getURLs) and open them one by one to list available classes. This approach, called class path scanning, is implemented in Scannotation and Reflections.Another approach is to use Java Pluggable Annotation Processing API to write annotation processor which will collect all annotated classes at compile time and build the index file for runtime use. This mechanism is implemented in ClassIndex library:Notice that no additional setup is needed as the scanning is fully automated thanks to Java compiler automatically discovering any processors found on the classpath.Here\'s how I do it. I scan all the subfolders (sub-packages) and I don\'t try to load anonymous classes:I put together a simple github project that solves this problem:https://github.com/ddopson/java-class-enumeratorIt should work for BOTH file-based classpaths AND for jar files.If you run \'make\' after checking out the project it will print this out:See also my other answerYou need to look up every class loader entry in the class path:If entry is directory, just look up in the right subdirectory: If the entry is the file, and it\'s jar, inspect the ZIP entries of it: Now once you have all class names withing package, you can try loading them with reflection and analyze if they are classes or interfaces, etc.I\'ve been trying to use the Reflections library, but had some problems using it, and there were too many jars I should include just to simply obtain the classes on a package.I\'ll post a solution I\'ve found in this duplicate question: How to get all classes names in a package?The answer was written by sp00m; I\'ve added some corrections to make it work:To use it just call the find method as sp00n mentioned in this example:\nI\'ve added the creation of instances of the classes if needed.I wrote FastClasspathScanner to solve this problem. It handles many different types of classpath scanning tasks, has a simple API, works with many different ClassLoaders and classpath environments, has been carefully parallelized and is highly optimized for high speed and low memory consumption. It can even generate a GraphViz visualization of the class graph, showing how classes are connected to each other.For your original question of finding all classes or interfaces in a given package, you can do:There are many possible variants to this -- see the documentation (linked above) for full info.Yeah using few API\'s you can, here is how i like doing it, faced this problem which i was using hibernate core & had to find classes which where annotated with a certain annotation.Make these an custom annotation using which you will mark which classes you want to be picked up.Then mark your class with it likeMake this utility class which has the following methodCall the allFoundClassesAnnotatedWithEntityToBeScanned() method to get a Set of Classes found.You will need libs given belowAlmost all the answers either uses Reflections or reads class files from file system. If you try to read classes from file system, you may get errors when you package your application as JAR or other. Also you may not want to use a separate library for that purpose. Here is another approach which is pure java and not depends on file system. Java 8 is not a must. You can use for loops instead of streams.\nAnd you can test it like thisWorth mentioningIf you want to have a list of all classes under some package, you can use Reflection the following way:This will create a list of classes that later you can use them as you wish.Provided you are not using any dynamic class loaders you can search the classpath and for each entry search the directory or JAR file.I just wrote a util class, it include test methods, you can have a check ~IteratePackageUtil.java:It is very possible, but without additional libraries like Reflections it is hard...\nIt is hard because you haven\'t full instrument for get class name.\nAnd, I take the code of my ClassFinder class:Aleksander Blomsk\xc3\xb8ld\'s solution did not work for me for parameterized tests @RunWith(Parameterized.class) when using Maven. The tests were named correctly and also where found but not executed:A similar issue has been reported here.In my case @Parameters is creating instances of each class in a package. The tests worked well when run locally in the IDE. However, when running Maven no classes where found with Aleksander Blomsk\xc3\xb8ld\'s solution.I did make it work with the following snipped which was inspired by David P\xc3\xa4rsson\'s comment on Aleksander Blomsk\xc3\xb8ld\'s answer:Based on @Staale\'s answer, and in an attempt not to rely on third party libraries, I would implement the File System approach by inspecting first package physical location with:It is not possible, since all classes in the package might not be loaded, while you always  knows package of a class.