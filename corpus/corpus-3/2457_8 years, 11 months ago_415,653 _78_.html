Is there a destructor for Java? I don\'t seem to be able to find any documentation on this. If there isn\'t, how can I achieve the same effect?To make my question more specific, I am writing an application that deals with data, and the specification say that there should be a \'reset\' button that brings the application back to its original just launched state. However, all data have to be \'live\' unless application is closed or reset button is pressed.Being usually a C/C++ programmer, I thought this would be trivial to implement. (And hence I planned to implement it last.) I structured my program such that all the \'reset-able\' objects would be in a same class so that I can just destroy all \'live\' objects when reset button is pressed.I was thinking, if all I did was just to dereference the data and wait for the garbage collector to collect them, wouldn\'t there be a memory leak if my user repeatedly entered data and pressed the reset button? I was also thinking, since Java is quite mature as a language, there should be a way to prevent this from happening or gracefully tackle this.Because Java is a garbage collected language you cannot predict when (or even if) an object will be destroyed. Hence there is no direct equivalent of a destructor.There is an inherited method called finalize, but this is called entirely at the discretion of the garbage collector. So for classes that need to explicitly tidy up, the convention is to define a close method and use finalize only for sanity checking (i.e. if close has not been called do it now and log an error).There was a question that spawned in-depth discussion of finalize recently, so that should provide more depth if required...Nope, no destructors here. The reason is that all Java objects are heap allocated and garbage collected. Without explicit deallocation (i.e. C++\'s delete operator) there is no sensible way to implement real destructors.Java does support finalizers, but they are meant to be used only as a safeguard for objects holding a handle to native resources like sockets, file handles, window handles, etc. When the garbage collector collects an object without a finalizer it simply marks the memory region as free and that\'s it. When the object has a finalizer, it\'s first copied into a temporary location (remember, we\'re garbage collecting here), then it\'s enqueued into a waiting-to-be-finalized queue and then a Finalizer thread polls the queue with very low priority and runs the finalizer.When the application exits, the JVM stops without waiting for the pending objects to be finalized, so there practically no guarantees that your finalizers will ever run.If you use Java 7, have a look at the try-with-resources statement. For example:Here the resource that is no longer needed is freed in the BufferedReader.close() method. You can create your own class that implements AutoCloseable and use it in a similar fashion. This statement is more limited than finalize in terms of code structuring, but at the same time it makes the code simpler to understand and maintain. Also, there is no guarantee that a finalize method is called at all during the livetime of the application.Use of finalize() methods should be avoided. They are not a reliable mechanism for resource clean up and it is possible to cause problems in the garbage collector by abusing them.If you require a deallocation call in your object, say to release resources, use an explicit method call. This convention can be seen in existing APIs (e.g. Closeable, Graphics.dispose(), Widget.dispose()) and is usually called via try/finally.Attempts to use a disposed object should throw a runtime exception (see IllegalStateException).EDIT:I was thinking, if all I did was just\n  to dereference the data and wait for\n  the garbage collector to collect them,\n  wouldn\'t there be a memory leak if my\n  user repeatedly entered data and\n  pressed the reset button?Generally, all you need to do is dereference the objects - at least, this is the way it is supposed to work. If you are worried about garbage collection, check out Java SE 6 HotSpot[tm] Virtual Machine Garbage Collection Tuning (or the equivalent document for your JVM version).With Java 1.7 released, you now have the additional option of using the try-with-resources block.  For example, If you execute this class, c.close() will be executed when the try block is left, and before the catch and finally blocks are executed.  Unlike in the case of the finalize() method, close() is guaranteed to be executed.  However, there is no need of executing it explicitly in the finally clause.I fully agree to other answers, saying not to rely on the execution of finalize.In addition to try-catch-finally blocks, you may use Runtime#addShutdownHook (introduced in Java 1.6) to perform final cleanups in your program. That isn\'t the same as destructors are, but one may implement a shutdown hook having listener objects registered on which cleanup methods (close persistent database connections, remove file locks, and so on) can be invoked - things that would normally be done in destructors.\nAgain - this is not a replacement for constructors but in some cases you can approach the wanted functionality with this.The advantage of this is having deconstruction bevaviour loosley coupled from the rest of your program.No, java.lang.Object#finalize is the closest you can get.However, when (and if) it is called, is not guaranteed.\nSee: java.lang.Runtime#runFinalizersOnExit(boolean)First, note that since Java is garbage-collected, it is rare to need to do anything about object destruction. Firstly because you don\'t usually have any managed resources to free, and secondly because you can\'t predict when or if it will happen, so it\'s inappropriate for things that you need to occur "as soon as nobody is using my object any more".You can be notified after an object has been destroyed using java.lang.ref.PhantomReference (actually, saying it has been destroyed may be slightly inaccurate, but if a phantom reference to it is queued then it\'s no longer recoverable, which usually amounts to the same thing). A common use is:There is also finalize(), which looks like a destructor but doesn\'t behave like one. It\'s usually not a good option.I am sorry if this strays from the main topic, but java.util.Timer (SE6) documentation says:"After the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer\'s task execution thread terminates gracefully (and becomes subject to garbage collection). However, this can take arbitrarily long to occur. By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating. If a caller wants to terminate a timer\'s task execution thread rapidly, the caller should invoke the timer\'s cancel method..." I would like to call cancel upon the class owning the Timer losing its last reference(or immeditalesky before).  Here a reliable destructor could do that for me.  The comments above indicate that finally is a poor choice, but is there an elegant solution?  That business of "...capable of keeping an application from terminating..." is not appealing.If it\'s just memory you are worried about, don\'t. Just trust the GC it does a decent job. I actually saw something about it being so efficient that it could be better for performance to create heaps of tiny objects than to utilize large arrays in some instances.I agree with most of the answers.You should not depend fully on either finalize or ShutdownHookfinalizeJVM does not guaranty when this finalize() method will be invoked.finalize() gets called only once by GC thread if object revives itself from finalize method than finalize will not be called again.In your application, you may have some live objects, on which garbage collection is never invoked.Any Exception is thrown by finalize method is ignored by GC threadSystem.runFinalization(true) and Runtime.getRuntime().runFinalization(true) methods increase the probability of invoking finalize() method but now these two methods have been deprecated. These methods are very dangerous due to lack of thread safety and possible deadlock creation.  shutdownHooksRegisters a new virtual-machine shutdown hook.The Java virtual machine shuts down in response to two kinds of events:Shutdown hooks should also finish their work quickly. When a program invokes exit the expectation is that the virtual machine will promptly shut down and exit.But even oracle documentation quoted that In rare circumstances the virtual machine may abort, that is, stop running without shutting down cleanlyThis occurs when the virtual machine is terminated externally, for example with the SIGKILL signal on Unix or the TerminateProcess call on Microsoft Windows. The virtual machine may also abort if a native method goes awry by, for example, corrupting internal data structures or attempting to access nonexistent memory. If the virtual machine aborts then no guarantee can be made about whether or not any shutdown hooks will be run.Conclusion : use try{} catch{} finally{} blocks appropriately and release critical resources in  finally(} block. During release of resources in finally{} block, catch Exception and Throwable.The finalize() function is the destructor.However, it should not be normally used because it is invoked after the GC and you can\'t tell when that will happen (if ever).Moreover, it takes more than one GC to deallocate objects that have finalize().You should try to clean up in the logical places in your code using the try{} finally{} statements!Perhaps you can use a try ... finally block to finalize the object in the control flow at which you are using the object. Of course it doesn\'t happen automatically, but neither does destruction in C++. You often see closing of resources in the finally block.The closest equivalent to a destructor in Java is the finalize() method.  The big difference to a traditional destructor is that you can\'t be sure when it\'ll be called, since that\'s the responsibility of the garbage collector.  I\'d strongly recommend carefully reading up on this before using it, since your typical RAIA patterns for file handles and so on won\'t work reliably with finalize().Though there have been considerable advancements in Java\'s GC technology, you still need to be mindful of your references.  Numerous cases of seemingly trivial reference patterns that are actually rats nests under the hood come to mind.  From your post it doesn\'t sound like you\'re trying to implement a reset method for the purpose of object reuse (true?).  Are your objects holding any other type of resources that need to be cleaned up (i.e., streams that must be closed, any pooled or borrowed objects that must be returned)?  If the only thing you\'re worried about is memory dealloc then I would reconsider my object structure and attempt to verify that my objects are self contained structures that will be cleaned up at GC time. If you\'re writing a Java Applet, you can override the Applet "destroy()" method. It is...Obviously not what you want, but might be what other people are looking for.Just thinking about the original question... which, I think we can conclude from all the other learned answers, and also from Bloch\'s essential Effective Java, item 7, "Avoid finalizers", seeks the solution to a legitimate question in a manner which is inappropriate to the Java language...: ... wouldn\'t a pretty obvious solution to do what the OP actually wants be to keep all your objects which need to be reset in a sort of "playpen", to which all other non-resettable objects have references only through some sort of accessor object... And then when you need to "reset" you disconnect the existing playpen and make a new one: all the web of objects in the playpen is cast adrift, never to return, and one day to be collected by the GC.If any of these objects are Closeable (or not, but have a close method) you could put them in a Bag in the playpen as they are created (and possibly opened), and the last act of the accessor before cutting off the playpen would be to go through all the Closeables closing them... ?The code would probably look something like this:closeCloseables would probably be a blocking method, probably involving a latch (e.g. CountdownLatch), to deal with (and wait as appropriate for) any Runnables/Callables in any threads specific to the Playpen to be ended as appropriate, in particular in the JavaFX thread.There is a @Cleanup annotation in Lombok that mostly resembles C++ destructors:When processing it (at compilation time), Lombok inserts appropriate try-finally block so that resource.close() is invoked, when execution leaves the scope of the variable. You can also specify explicitly another method for releasing the resource, e.g. resource.dispose(): I think what people are failing to recognize is that since Java does not have a destructor method, the programmer needs think differently about resource ownership.  For example:The following class maintains ownership of a resource (in this case a database connection).The programmer needs to create a close method.  This is not hard, but it does create a step that other users of this class must know about (i.e. they need to know to call the close method).This is why it\'s better just to pass the resource off.The method pass a standard initialized java api Connection class.  This has a close method everyone knows to call.  The point is to work with the language, instead of trying to make it into another language.I used to mainly deal with C++ and that is what lead me to the search of a destructor as well. I am using JAVA a lot now. What I did, and it may not be the best case for everyone, but I implemented my own destructor by reseting all the values to either 0 or there default through a function.Example:Ideally this won\'t work for all situations, but where there are global variables it will work as long as you don\'t have a ton of them.I know I am not the best Java programmer, but it seems to be working for me.