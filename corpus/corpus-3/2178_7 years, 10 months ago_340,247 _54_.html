For me, it just seems like a funky MOV. What\'s its purpose and when should I use it?As others have pointed out, LEA (load effective address) is often used as a "trick" to do certain computations, but that\'s not its primary purpose. The x86 instruction set was designed to support high-level languages like Pascal and C, where arrays—especially arrays of ints or small structs—are common. Consider, for example, a struct representing (x, y) coordinates:Now imagine a statement like:where points[] is an array of Point. Assuming the base of the array is already in EBX, and variable i is in EAX, and xcoord and ycoord are each 32 bits (so ycoord is at offset 4 bytes in the struct), this statement can be compiled to:which will land y in EDX. The scale factor of 8 is because each Point is 8 bytes in size. Now consider the same expression used with the "address of" operator &:In this case, you don\'t want the value of ycoord, but its address. That\'s where LEA (load effective address) comes in. Instead of a MOV, the compiler can generatewhich will load the address in ESI.From the "Zen of Assembly" by Abrash:LEA, the only instruction that performs memory addressing calculations but doesn\'t actually address memory. LEA accepts a standard memory addressing operand, but does nothing more than store the calculated memory offset in the specified register, which may be any general purpose register.What does that give us? Two things that ADD doesn\'t provide: And LEA does not alter the flags.Another important feature of the LEA instruction is that it does not alter the condition codes such as CF and ZF, while computing the address by arithmetic instructions like ADD or MUL does. This feature decreases the level of dependency among instructions and thus makes room for further optimization by the compiler or hardware scheduler.Despite all the explanations, LEA is an arithmetic operation:LEA Rt, [Rs1+a*Rs2+b] =>  Rt = Rs1 + a*Rs2 + bIt\'s just that its name is extremelly stupid for a shift+add operation. The reason for that was already explained in the top rated answers (i.e. it was designed to directly map high level memory references).Maybe just another thing about LEA instruction.\nYou can also use LEA for fast multiplying registers by 3, 5 or 9.lea is an abbreviation of "load effective address". It loads the address of the location reference by the source operand to the destination operand. For instance, you could use it to:to move ebx pointer eax items further (in a 64-bit/element array) with a single instruction. Basically, you benefit from complex addressing modes supported by x86 architecture to manipulate pointers efficiently.The biggest reason that you use LEA over a MOV is if you need to perform arithmetic on the registers that you are using to calculate the address.  Effectively, you can perform what amounts to pointer arithmetic on several of the registers in combination effectively for "free."What\'s really confusing about it is that you typically write an LEA just like a MOV but you aren\'t actually dereferencing the memory.  In other words:MOV  EAX, [ESP+4]This will move the content of what ESP+4 points to into EAX.LEA EAX, [EBX*8]This will move the effective address EBX * 8 into EAX, not what is found in that location.  As you can see, also, it is possible to multiply by factors of two (scaling) while a MOV is limited to adding/subtracting.The 8086 has a large family of instructions which accept a register operand and an effective address, perform some computations to compute the offset part of that effective address, and perform some operation involving the register and the memory referred to by the computed address.  It was fairly simple to have one of the instructions in that family behave as above except for skipping that actual memory operation.  This, the instructions:were implemented almost identically internally.  The difference is a skipped step.  Both instructions work something like:As for why Intel thought this instruction was worth including, I\'m not exactly sure, but the fact that it was cheap to implement would have been a big factor.  Another factor would have been the fact that Intel\'s assembler allowed symbols to be defined relative to the BP register.  If fnord was defined as a BP-relative symbol (e.g. BP+8), one could say:If one wanted to use something like stosw to store data to a BP-relative address, being able to saywas more convenient than:Note that forgetting the world "offset" would cause the contents of location [BP+8], rather than the value 8, to be added to DI.  Oops.As the existing answers mentioned, LEA has the advantages of performing memory addressing arithmetic without accessing memory, saving the arithmetic result to a different register instead of the simple form of add instruction. The real underlying performance benefit is that modern processor has a separate LEA ALU unit and port for effective address generation (including LEA and other memory reference address), this means the arithmetic operation in LEA and other normal arithmetic operation in ALU could be done in parallel in one core.Check this article of Haswell architecture for some details about LEA unit:\nhttp://www.realworldtech.com/haswell-cpu/4/Another important point which is not mentioned in other answers is LEA REG, [MemoryAddress] instruction is PIC (position independent code) which encodes the PC relative address in this instruction to reference MemoryAddress. This is different from MOV REG, MemoryAddress which encodes relative virtual address and requires relocating/patching in modern operating systems (like ASLR is common feature). So LEA can be used to convert such non PIC to PIC.The LEA instruction can be used to avoid time consuming calculations of effective addresses by the CPU. If an address is used repeatedly it is more effective to store it in a register instead of calculating the effective address every time it is used.LEA : just an "arithmetic" instruction..MOV transfers data between operands but lea is just calculating Here is an example.With -O (optimize) as compiler option, gcc will find the lea instruction for the indicated code line. The LEA instruction is a way of obtaining the address which arises from any of the Intel processor\'s memory addressing modes.That is to say, if we have a data move like this:it moves the contents of the designated memory location into the target register.If we replace the MOV by LEA, then the address of the  memory location is calculated in exactly the same way by the <MEM-OPERAND> addressing expression. But instead of the contents of the memory location, we get the location itself into the destination.LEA is not a specific arithmetic instruction; it is a way of intercepting the effective address arising from any one of the processor\'s memory addressing modes. For instance, we can use LEA on just a simple direct address. No arithmetic is involved at all:This is valid; we can test it at the Linux prompt:Here, there is no addition of a scaled value, and no offset.  Zero is moved into EAX.   We could do that using MOV with an immediate operand also.This is the reason why people who think that the brackets in LEA are superfluous are severely mistaken; the brackets are not LEA syntax but are part of the addressing mode.LEA is real at the hardware level. The generated instruction encodes the actual addressing mode and the processor carries it out to the point of calculating the address. Then it moves that address to the destination instead of generating a memory reference. (Since the address calculation of an addressing mode in any other instruction has no effect on CPU flags, LEA has no effect on CPU flags.)Contrast with loading the value from address zero:It\'s a very similar encoding, see? Just the 8d of LEA has changed to 8b.Of course, this LEA encoding is longer than moving an immediate zero into EAX:There is no reason for LEA to exclude this possibility though just because there is a shorter alternative; it\'s just combining in an orthogonal way with the available addressing modes.it because instead you write the code you can simply write 