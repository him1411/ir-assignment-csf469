I have been checking out some of the possible timers lately, and the Threading.Timer and Timers.Timer are the ones that look needful to me (since they support thread pooling). I am making a game, and I plan on using all types of events, with different intervals, etc. Which would be the best?This article offers a fairly comprehensive explanation:"Comparing the Timer Classes in the .NET Framework Class Library" - also available as a .chm fileThe specific difference appears to be that System.Timers.Timer is geared towards multithreaded applications and is therefore thread-safe via its SynchronizationObject property, whereas System.Threading.Timer is ironically not thread-safe out-of-the-box.I don\'t believe that there is a difference between the two as it pertains to how small your intervals can be.System.Threading.Timer is a plain timer. It calls you back on a thread pool thread (from the worker pool).System.Timers.Timer is a System.ComponentModel.Component that wraps a System.Threading.Timer, and provides some additional features used for dispatching on a particular thread.System.Windows.Forms.Timer instead wraps a native message-only-HWND and uses Window Timers to raise events in that HWNDs message loop.If your app has no UI, and you want the most light-weight and general-purpose .Net timer possible, (because you are happy figuring out your own threading/dispatching) then System.Threading.Timer is as good as it gets in the framework.I\'m not fully clear what the supposed \'not thread safe\' issues with System.Threading.Timer are. Perhaps it is just same as asked in this question: Thread-safety of System.Timers.Timer vs System.Threading.Timer, or perhaps everyone just means that:it\'s easy to write race conditions when you\'re using timers. E.g. see this question:\nTimer (System.Threading) thread safetyre-entrancy of timer notifications, where your timer event can trigger and call you back a second time before you finish processing the first event. E.g. see this question: Thread-safe execution using System.Threading.Timer and MonitorIn his book "CLR Via C#", Jeff Ritcher discourages using System.Timers.Timer, this timer is derived from System.ComponentModel.Component, allowing it to be used in design surface of Visual Studio. So that it would be only useful if you want a timer on a design surface.He prefers to use System.Threading.Timer for background tasks on a thread pool thread.I found a short comparison from MSDNThe .NET Framework Class Library includes four classes named Timer,\n  each of which offers different functionality:System.Timers.Timer, which fires an event and executes the code in one or more event sinks at regular intervals. The class is intended\n  for use as a server-based or service component in a multithreaded\n  environment; it has no user interface and is not visible at runtime.System.Threading.Timer, which executes a single callback method on a thread pool thread at regular intervals. The callback method is\n  defined when the timer is instantiated and cannot be changed. Like the\n  System.Timers.Timer class, this class is intended for use as a\n  server-based or service component in a multithreaded environment; it\n  has no user interface and is not visible at runtime.System.Windows.Forms.Timer, a Windows Forms component that fires an event and executes the code in one or more event sinks at regular\n  intervals. The component has no user interface and is designed for use\n  in a single-threaded environment.System.Web.UI.Timer, an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.System.Timers.Timer seems to be deprecated with .NET Core and ASP.NET Core.\nSo try using System.Threading.Timer in future apps.EDIT:\nOK, let me be more precise:With the new .NET Core Framework, Microsoft discontinued some technologies of .NET Framework. To understand that: .NET Core is a totally new framework - rewritten, cross platform, etc. I don\'t want to go to deep here in detail - please read the .NET Blog.On the blog is a good article abound porting to .NET Core which explains also the difficulties you can hit. One part of this is to use the .NET Portability Analyzer Visual Studio Add-In and fix the errors you get.For the System.Timers.Timer class, it said, that .NET Framework,Version=v4.6.2 is supported, but .NET Core,Version=v5.0 and \n.NETPlatform,Version=v5.0 is not. Recommended changes: Use System.Threading.Timer.So that looks for me that System.Timers.Timer is gone for .NET Core.P.S.: But it might come back - Microsoft announced that they want to make some changes to CoreCLR (the name of the framework you use for .NET Core) to make the porting effort easier.One important difference not mentioned above which might catch you out is that System.Timers.Timer silently swallows exceptions, whereas System.Threading.Timer doesn\'t.For example:vsThe two classes are functionally equivalent, except that System.Timers.Timer has an option to invoke all its timer expiration callbacks through ISynchronizeInvoke by setting SynchronizingObject. Otherwise, both timers invoke expiration callbacks on thread pool threads.When you drag a System.Timers.Timer onto a Windows Forms design surface, Visual Studio sets SynchronizingObject to the form object, which causes all expiration callbacks to be called on the UI thread.From MSDN: System.Threading.Timer is a simple, lightweight timer that uses callback methods and is served by thread pool threads. It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread. System.Windows.Forms.Timer is a better choice for use with Windows Forms. For server-based timer functionality, you might consider using System.Timers.Timer, which raises events and has additional features.Source