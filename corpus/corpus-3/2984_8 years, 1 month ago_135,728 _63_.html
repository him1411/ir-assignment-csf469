I\'m searching for an elegant way to convert a normal Python dict with some nested dicts to an object.For example:Should be accessible in this way:I think, this is not possible without recursion, but what would be a nice way to get an objectstyle for dicts?Update: In Python 2.6 and onwards, consider whether the namedtuple data structure suits your needs:The alternative (original answer contents) is:Then, you can use:Surprisingly no one has mentioned Bunch. This library is exclusively meant to provide attribute style access to dict objects and does exactly what the OP wants. A demonstration:A Python 3 library is available at https://github.com/Infinidat/munch - Credit goes to codyzuthen add recursion to this and you\'re done.edit this is how I\'d implement it:For anyone who happens to stumble upon this question nowadays. In Python 2.6+ there\'s a \ncollection helper called namedtuple, that can do this for you: Taking what I feel are the best aspects of the previous examples, here\'s what I came up with:Can be used with any sequence/dict/value structure of any depth.If your dict is coming from json.loads(), you can turn it into an object instead (rather than a dict) in one line:See also How to convert JSON data into a Python object.If you want to access dict keys as an object (or as a dict for difficult keys), do it recursively, and also be able to update the original dict, you could do:Example usage:x.__dict__.update(d) should do fine.This should get your started:It doesn\'t work for lists, yet. You\'ll have to wrap the lists in a UserList and overload __getitem__ to wrap dicts.I ended up trying BOTH the AttrDict and the Bunch libraries and found them to be way too slow for my uses.  After a friend and I looked into it, we found that the main method for writing these libraries results in the library aggressively recursing through a nested object and making copies of the dictionary object throughout.  With this in mind, we made two key changes.  1) We made attributes lazy-loaded 2) instead of creating copies of a dictionary object, we create copies of a light-weight proxy object.  This is the final implementation.  The performance increase of using this code is incredible.  When using AttrDict or Bunch, these two libraries alone consumed 1/2 and 1/3 respectively of my request time(what!?).  This code reduced that time to almost nothing(somewhere in the range of 0.5ms).  This of course depends on your needs, but if you are using this functionality quite a bit in your code, definitely go with something simple like this.  See the original implementation here by https://stackoverflow.com/users/704327/michael-merickel.The other thing to note, is that this implementation is pretty simple and doesn\'t implement all of the methods you might need.  You\'ll need to write those as required on the DictProxy or ListProxy objects.Old Q&A, but I get something more to talk. Seems no one talk about recursive dict. This is my code:I stumbled upon the case I needed to recursively convert a list of dicts to list of objects, so based on Roberto\'s snippet here what did the work for me:Note that any tuple will be converted to its list equivalent, for obvious reasons. Hope this helps someone as much as all your answers did for me, guys.Wanted to upload my version of this little paradigm.It preserves the attributes for the type that\'s imported into the class. My only concern would be overwriting methods from within the dictionary your parsing. But otherwise seems solid!You can leverage the json module of the standard library with a custom object hook:Example usage:And it is not strictly read-only as it is with namedtuple, i.e. you can change values \xe2\x80\x93 not structure:What about just assigning your dict to the __dict__ of an empty object?Of course this fails on your nested dict example unless you walk the dict recursively:And your example list element was probably meant to be a Mapping, a list of (key, value) pairs like this:Here is another way to implement SilentGhost\'s original suggestion:Let me explain a solution I almost used some time ago. But first, the reason I did not is illustrated by the fact that the following code:gives this error:Because "from" is a Python keyword there are certain dictionary keys you cannot allow.Now my solution allows access to the dictionary items by using their names directly. But it also allows you to use "dictionary semantics". Here is the code with example usage:Here\'s another implementation:[Edit] Missed bit about also handling dicts within lists, not just other dicts.  Added fix.How about this:This can then be used like this:I think a dict consists of number, string and dict is enough most time.\nSo I ignore the situation that tuples, lists and other types not appearing in the final dimension of a dict. Considering inheritance, combined with recursion, it solves the print problem conveniently and also provides two ways to query a data,one way to edit a data.See the example below, a dict that describes some information about students:Results:Usage:Building off my answer to "python: How to add property to a class dynamically?":You call makedata on the dictionary you want converted, or maybe trydata depending on what you expect as input, and it spits out a data object.Notes:This also works well tooI had some problems with __getattr__ not being called so I constructed a new style class version:This version also has the addition of NoneStruct that is returned when an attribute is called that is not set. This allows for None testing to see if an attribute is present. Very usefull when the exact dict input is not known (settings etc.).My dictionary is of this format:As can be seen, I have nested dictionaries and list of dicts.\nThis is because the addr_bk was decoded from protocol buffer data that converted to a python dict using lwpb.codec. There are optional field (e.g. email => where key may be unavailable) and repeated field (e.g. phone => converted to list of dict).I tried all the above proposed solutions. Some doesn\'t handle the nested dictionaries well. Others cannot print the object details easily.Only the solution, dict2obj(dict) by Dawie Strauss, works best.I have enhanced it a little to handle when the key cannot be found:Then, I tested it with:This is another, alternative, way to convert a list of dictionaries to an object: