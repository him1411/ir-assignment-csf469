After reading it, this is not a duplicate of Explicit vs Implicit SQL Joins.\nThe answer may be related (or even the same) but the question is different.What is the difference and what should go in each?If I understand the theory correctly, the query optimizer should be able to use both interchangeably.They are not the same thing.Consider these queries:andThe first will return an order and its lines, if any, for order number 12345.  The second will return all orders, but only order 12345 will have any lines associated with it.With an INNER JOIN, the clauses are effectively equivalent. However, just because they are functionally the same, in that they produce the same results, does not mean the two kinds of clauses have the same semantic meaning.On INNER JOINs they are interchangeable, and the optimizer will rearrange them at will.On OUTER JOINs, they are not necessarily interchangeable, depending on which side of the join they depend on.I put them in either place depending on the readability.Matters for outer joinsa. WHERE clause: After joining. Records will be filtered after join has taken place.b. ON clause - Before joining. Records (from right table) will be filtered before joining. This may end up as null in the result (since OUTER join).\nExample: Consider the below tables:a) Inside WHERE clause:b) Inside JOIN clauseOn an inner join, they mean the same thing. However you will get different results in an outer join depending on if you put the join condition in the WHERE vs the ON clause. Take a look at this related question and this answer (by me).I think it makes the most sense to be in the habit of always putting the join condition in the ON clause (unless it is an outer join and you actually do want it in the where clause) as it makes it clearer to anyone reading your query what conditions the tables are being joined on, and also it helps prevent the WHERE clause from being dozens of lines long.The way I do it is:Always put the join conditions in the on clause\nIf you are doing an inner join, so do not add any where conditions to the on clause, put them in the where clause If you are doing a left join, add any where conditions to the on clause for the table in the right side of the join. This is a must because adding a where clause that references the right side of the join will convert the join to an inner join (With one exception described below). The exception is that when you are looking for the records that are not in a particular table, you would add the refernce to a unique identifier(that is not ever null) in the right join table to the where clause this way "Where t2.idfield is null". So the only time you should reference a table on the right side of the join is to find those records which are not in the table.This article clearly explains the difference. It also explains the "ON joined_condition vs WHERE joined_condition or joined_alias is null".The WHERE clause filters both the left and the right side of the JOIN, while the ON clause will always filter the right side only. In terms of the optimizer, it shouldn\'t make a difference whether you define your join clauses with ON or WHERE.However, IMHO, I think it\'s much clearer to use the ON clause when performing joins.  That way you have a specific section of you query that dictates how the join is handled versus intermixed with the rest of the WHERE clauses.There is great difference between where clause vs. on clause, when it comes to left join. Here is example:There fid is id of table t2.Query on "on clause" : Query on "where clause":It is clear that, \nthe first query returns a record from t1 and its dependent row from t2, if any, for row t1.v = \'K\'. The second query returns rows from t1, but only for t1.v = \'K\' will have any associated row with it.for better performance tables should have a special indexed column to use for JOINS .so if the column you condition on is not one of those indexed columns then i suspect it is better to keep it in WHERE .so you JOIN using the indexed columns, then after JOIN you run the condition on the none indexed column .I think it\'s the join sequence effect. \nIn the upper left join case, SQL do Left join first and then do where filter.\nIn the downer case, find Orders.ID=12345 first, and then do join.In SQL, the \'WHERE\' and \'ON\' clause,are kind of Conditional Statemants, but the major difference between them are, the \'Where\' Clause is used in Select/Update Statements for specifying the Conditions, whereas the \'ON\' Clause is used in Joins, where it verifies or checks if the Records are Matched in the target and source tables, before the Tables are JoinedFor Example: - \'WHERE\'SELECT * FROM employee WHERE employee_id=101For Example: - \'ON\'*There are  two tables employee and employee_details, the matching columns are employee_id.*SELECT * FROM employee \n     INNER JOIN employee_details ON employee.employee_id=employee_details.employee_idHope I have answered your Question.Revert back for clarifications.For an inner join, WHERE and ON can be used interchangeably.  In fact, it\'s possible to use ON in a correlated subquery.  For example:This is (IMHO) utterly confusing to a human,  and it\'s very easy to forget to link table1 to anything (because the "driver" table doesn\'t have an "on" clause), but it\'s legal.  this is my solution.You must have the GROUP BY to get it to work.Hope this help.