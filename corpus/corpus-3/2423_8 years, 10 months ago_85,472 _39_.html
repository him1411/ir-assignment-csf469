in the System.Linq namespace, we can now extend our IEnumerable\'s to have theAny() and Count() extension methods.I was told recently that if i want to check that a collection contains 1 or more items inside it, I should use the .Any() extension method instead of the .Count() > 0 extension method because the .Count() extension method has to iterate through all the items.Secondly, some collections have a property (not an extension method) that is Count or Length. Would it be better to use those, instead of .Any() or .Count() ?yea / nae ?If you are starting with something that has a .Length or .Count (such as ICollection<T>, IList<T>, List<T>, etc) - then this will be the fastest option, since it doesn\'t need to go through the GetEnumerator()/MoveNext()/Dispose() sequence required by Any() to check for a non-empty IEnumerable<T> sequence.For just IEnumerable<T>, then Any() will generally be quicker, as it only has to look at one iteration. However, note that the LINQ-to-Objects implementation of Count() does check for ICollection<T> (using .Count as an optimisation) - so if your underlying data-source is directly a list/collection, there won\'t be a huge difference. Don\'t ask me why it doesn\'t use the non-generic ICollection...Of course, if you have used LINQ to filter it etc (Where etc), you will have an iterator-block based sequence, and so this ICollection<T> optimisation is useless.In general with IEnumerable<T> : stick with Any() ;-pNote:  This answer is no longer correct for newer versions of EntityFramework.  As of at least 6.1.1 .Any() has been fixed to generate better SQL and to be much faster than .Count() > 0, as show in testing by Ben and Kamo.  If you\'re forced to use an older version of EF, this answer is still valid.While I agree with most up-voted answer and comments - especially on the point Any signals developer intent better than Count() > 0 - I\'ve had situation in which Count is faster by order of magnitude on SQL Server (EntityFramework 4). Here is query with Any that thew timeout exception (on ~200.000 records):Count version executed in matter of milliseconds:I need to find a way to see what exact SQL both LINQs produce - but it\'s obvious there is a huge performance difference between Count and Any in some cases, and unfortunately it seems you can\'t just stick with Any in all cases.EDIT: Here are generated SQLs. Beauties as you can see ;)ANY:COUNT:Seems that pure Where with EXISTS works much worse than calculating Count and then doing Where with Count == 0.Let me know if you guys see some error in my findings. What can be taken out of all this regardless of Any vs Count discussion is that any more complex LINQ is way better off when rewritten as Stored Procedure ;).Since this is rather popular topic and answers differ I had to take a fresh look on problem.Testing env:\nEF 6.1.3, SQL Server, 300k recordsTable model:Test code:Results:Any() ~ 3msCount() ~ 230ms for first query, ~ 400ms for secondRemarks:For my case EF didn\'t generate SQL like @Ben mentioned in his post.EDIT: it was fixed in EF version 6.1.1. and this answer is no more actual For SQL Server and EF4-6, Count() performs about two times faster than Any().When you run Table.Any(), it will generate something like(alert: don\'t hurt the brain trying to understand it) that requires 2 scans of rows with your condition.I don\'t like to write Count() > 0 because it hides my intention. I prefer to use custom predicate for this:Well, the .Count() extension method won\'t use the .Count property, but I would assume you wouldn\'t use the .Count() method for a simple collection, but rather at the end of a LINQ statement with filtering criteria, etc.In that context, .Any() will be faster than .Count() > 0.It depends, how big is the data set and what are your performance requirements?If it\'s nothing gigantic use the most readable form,\nwhich for myself is any, because it\'s shorter and readable rather than an equation.You can make a simple test to figure this out:make any query and then:Check the values of testCount and testAny.