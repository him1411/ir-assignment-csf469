I am just getting started on ASP.NET MVC so bear with me.  I\'ve searched around this site and various others and have seen a few implementations of this.EDIT:  I forgot to mention I am using RC2Using URL Routing: The above seems to take care of requests like this (assuming default route tables setup by initial MVC project): "/blah/blah/blah/blah"Overriding HandleUnknownAction() in the controller itself:However the previous strategies do not handle a request to a Bad/Unknown controller.  For example, I do not have a "/IDoNotExist", if I request this I get the generic 404 page from the web server and not my 404 if I use routing + override.  So finally, my question is:  Is there any way to catch this type of request using a route or something else in the MVC framework itself? OR should I just default to using Web.Config customErrors as my 404 handler and forget all this?  I assume if I go with customErrors I\'ll have to store the generic 404 page outside of /Views due to the Web.Config restrictions on direct access.  Anyway any best practices or guidance is appreciated.The code is taken from http://blogs.microsoft.co.il/blogs/shay/archive/2009/03/06/real-world-error-hadnling-in-asp-net-mvc-rc2.aspx and works in ASP.net MVC 1.0 as well Here\'s how I handle http exceptions:The following are my requirements for a 404 solution and below i show how i implement it:I think you should save Application_Error in the Global.asax for higher things, like unhandled exceptions and logging (like Shay Jacoby\'s answer shows) but not 404 handling. This is why my suggestion keeps the 404 stuff out of the Global.asax file.This is a good idea for maintainability. Use an ErrorController so that future improvements to your well designed 404 page can adapt easily. Also, make sure your response has the 404 code!404s in ASP.NET MVC need to be caught at a number of places. The first is HandleUnknownAction.The InvokeHttp404 method creates a common place for re-routing to the ErrorController and our new Http404 action. Think DRY!Like so (it doesn\'t have to be StructureMap):MVC1.0 example:MVC2.0 example:I think its better to catch errors closer to where they originate. This is why i prefer the above to the Application_Error handler.This is the second place to catch 404s.This route should point to our Http404 action. Notice the url param will be a relative url because the routing engine is stripping the domain part here? That is why we have all that conditional url logic in Step 1.This is the third and final place to catch 404s in an MVC app that you don\'t invoke yourself. If you don\'t catch unmatched routes here then MVC will pass the problem up to ASP.NET (Global.asax) and you don\'t really want that in this situation.Like when a bad ID is submitted to my Loans controller (derives from MyController):It would be nice if all this could be hooked up in fewer places with less code but i think this solution is more maintainable, more testable and fairly pragmatic.  Thanks for the feedback so far. I\'d love to get more.NOTE: This has been edited significantly from my original answer but the purpose/requirements are the same - this is why i have not added a new answerASP.NET MVC doesn\'t support custom 404 pages very well. Custom controller factory, catch-all route, base controller class with HandleUnknownAction - argh!IIS custom error pages are better alternative so far:For the lazy people out there:Then remove this line from global.asaxAnd this is only for IIS7+ and IIS Express. If you\'re using Cassini .. well .. um .. er.. awkward ...\nI know this has been answered. But the answer is REALLY SIMPLE (cheers to David Fowler and Damian Edwards for really answering this).There is no need to do anything custom. For ASP.NET MVC3, all the bits and pieces are there.andNow take careful note of the ROUTES I\'ve decided to use. You can use anything, but my routes areSee how the first section in <system.web> only has one custom entry? The statusCode="404" entry? I\'ve only listed one status code because all other errors, including the 500 Server Error (ie. those pesky error that happens when your code has a bug and crashes the user\'s request) .. all the other errors are handled by the setting defaultRedirect="/ServerError" .. which says, if you are not a 404 page not found, then please goto the route /ServerError.Ok. that\'s out of the way.. now to my routes listed in global.asaxHere\'s my full route section..That lists two ignore routes -> axd\'s and favicons (ooo! bonus ignore route, for you!)\nThen (and the order is IMPERATIVE HERE), I have my two explicit error handling routes .. followed by any other routes. In this case, the default one. Of course, I have more, but that\'s special to my web site. Just make sure the error routes are at the top of the list. Order is imperative.Finally, while we are inside our global.asax file, we do NOT globally register the HandleError attribute. No, no, no sir. Nadda. Nope. Nien. Negative. Noooooooooo...Remove this line from global.asaxNow .. we add a controller with two action methods ...Ok, lets check this out. First of all, there is NO [HandleError] attribute here. Why? Because the built in ASP.NET framework is already handling errors AND we have specified all the shit we need to do to handle an error :) It\'s in this method! Next, I have the two action methods. Nothing tough there. If u wish to show any exception info, then u can use Server.GetLastError() to get that info.Bonus WTF: Yes, I made a third action method, to test error handling.And finally, create two views. Put em in the normal view spot, for this controller.And that, my friends, should be it.Now, congrats for reading this much and have a Unicorn as a prize!I\'ve investigated A LOT on how to properly manage 404s in MVC (specifically MVC3), and this, IMHO is the best solution I\'ve come up with:In global.asax:ErrorsController:(Optional)Explanation:AFAIK, there are 6 different cases that an ASP.NET MVC3 apps can generate 404s.(Automatically generated by ASP.NET Framework:)(1) An URL does not find a match in the route table.(Automatically generated by ASP.NET MVC Framework:)(2) An URL finds a match in the route table, but specifies a non-existent controller.(3) An URL finds a match in the route table, but specifies a non-existant action.(Manually generated:)(4) An action returns an HttpNotFoundResult by using the method HttpNotFound().(5) An action throws an HttpException with the status code 404.(6) An actions manually modifies the Response.StatusCode property to 404.Normally, you want to accomplish 3 objectives:(1) Show a custom 404 error page to the user.(2) Maintain the 404 status code on the client response (specially important for SEO).(3) Send the response directly, without involving a 302 redirection.There are various ways to try to accomplish this:(1)Problems with this solution:(2)Problems with this solution:(3)Problems with this solution:(4)andProblems with this solution:People that have troubled with this before even tried to create their own libraries (see http://aboutcode.net/2011/02/26/handling-not-found-with-asp-net-mvc3.html). But the previous solution seems to cover all the cases without the complexity of using an external library.I really like cottsaks solution and think its very clearly explained. my only addition was to alter step 2 as followsBasically this stops urls containing invalid actions AND controllers from triggering the exception routine twice. eg for urls such as asdfsdf/dfgdfgdThe only way I could get @cottsak\'s method to work for invalid controllers was to modify the existing route request in the CustomControllerFactory, like so:I should mention I\'m using MVC 2.0.Here is another method using MVC tools which you can handle requests to bad controller names, bad route names, and any other criteria you see fit inside of an Action method.  Personally, I prefer to avoid as many web.config settings as possible, because they do the 302 / 200 redirect and do not support ResponseRewrite (Server.Transfer) using Razor views.  I\'d prefer to return a 404 with a custom error page for SEO reasons.Some of this is new take on cottsak\'s technique above.This solution also uses minimal web.config settings favoring the MVC 3 Error Filters instead.Just throw a HttpException from an action or custom ActionFilterAttribute.Add the following setting to your web.config.  This is required to use MVC\'s HandleErrorAttribute. Add a custom HandleHttpErrorAttribute similar to the MVC framework\'s HandleErrorAttribute, except for HTTP errors:Add Filters to the GlobalFilterCollection (GlobalFilters.Filters) in Global.asax.  This example will route all InternalServerError (500) errors to the Error shared view (Views/Shared/Error.vbhtml).  NotFound (404) errors will be sent to ErrorHttp404.vbhtml in the shared views as well.  I\'ve added a 401 error here to show you how this can be extended for additional HTTP error codes.  Note that these must be shared views, and they all use the System.Web.Mvc.HandleErrorInfo object as a the model.Create a base controller class and inherit from it in your controllers.  This step allows us to handle unknown action names and raise the HTTP 404 error to our HandleHttpErrorAttribute.Create a ControllerFactory override, and override it in your Global.asax file in Application_Start.  This step allows us to raise the HTTP 404 exception when an invalid controller name has been specified.Include a special route in your RoutTable.Routes for the BaseController Unknown action.  This will help us raise a 404 in the case where a user accesses an unknown controller, or unknown action.This example demonstrated how one can use the MVC framework to return 404 Http Error Codes to the browser without a redirect using filter attributes and shared error views.  It also demonstrates showing the same custom error page when invalid controller names and action names are specified.I\'ll add a screenshot of an invalid controller name, action name, and a custom 404 raised from the Home/TriggerNotFound action if I get enough votes to post one =).  Fiddler returns a 404 message when I access the following URLs using this solution:  cottsak\'s post above and these articles were good references.  In MVC4 WebAPI 404 can be handle in the following way,COURSES APICONTROLLERHOME CONTROLLERVIEWGLOBALRESULTSTry NotFoundMVC on nuget. It works , no setup.My shortened solution that works with unhandled areas, controllers and actions:Create a view 404.cshtml.Create a base class for your controllers:Create a custom controller factory returning your base controller as a fallback:Add to Application_Start() the following line:Dealing with errors in ASP.NET MVC is just a pain in the butt. I tried a whole lot of suggestions on this page and on other questions and sites and nothing works good. One suggestion was to handle errors on web.config inside system.webserver but that just returns blank pages. My goal when coming up with this solution was to;Here is my solution.1.Add the following to system.web sectionThe above handles any urls not handled by routes.config and unhandled exceptions especially those encountered on the views. Notice I used aspx not html. This is so I can add a response code on the code behind.2. Create a folder called Error (or whatever you prefer) at the root of your project and add the two webforms. Below is my 404 page;And on the code behind I set the response codeDo the same for the 500 page3.To handle errors within the controllers. There\'s many ways to do it. This is what worked for me. All my controllers inherit from a base controller. In the base controller, I have the following methods4.Add the CustomError.cshtml to your Shared views folder. Below is mine;Now in your application controller you can do something like this;Now for the caveat.\nIt won\'t handle static file errors. So if you have a route such as example.com/widgets and the user changes it to example.com/widgets.html, they will get the IIS default error page so you have to handle IIS level errors some other way.My solution, in case someone finds it useful.In Web.config:In Controllers/ErrorController.cs:Add a PageNotFound.cshtml in the Shared folder, and that\'s it.Posting an answer since my comment was too long...It\'s both a comment and questions to the unicorn post/answer: https://stackoverflow.com/a/7499406/687549I prefer this answer over the others for it\'s simplicity and the fact that apparently some folks at Microsoft were consulted. I got three questions however and if they can be answered then I will call this answer the holy grail of all 404/500 error answers on the interwebs for an ASP.NET MVC (x) app.@Pure.KromeCan you update your answer with the SEO stuff from the comments pointed out by GWB (there was never any mentioning of this in your answer) - <customErrors mode="On" redirectMode="ResponseRewrite"> and <httpErrors errorMode="Custom" existingResponse="Replace">? Can you ask your ASP.NET team friends if it is okay to do it like that - would be nice to have some confirmation - maybe it\'s a big no-no to change redirectMode and existingResponse in this way to be able to play nicely with SEO?! Can you add some clarification surrounding all that stuff (customErrors redirectMode="ResponseRewrite", customErrors redirectMode="ResponseRedirect", httpErrors errorMode="Custom" existingResponse="Replace", REMOVE customErrors COMPLETELY as someone suggested) after talking to your friends at Microsoft? As I was saying; it would be supernice if we could make your answer more complete as this seem to be a fairly popular question with 54 000+ views.Update: Unicorn answer does a 302 Found and a 200 OK and cannot be changed to only return 404 using a route. It has to be a physical file which is not very MVC:ish. So moving on to another solution. Too bad because this seemed to be the ultimate MVC:ish answer this far.It seems to me that the standard CustomErrors configuration should just work however, due to the reliance on Server.Transfer it seems that the internal implementation of ResponseRewrite isn\'t compatible with MVC.This feels like a glaring functionality hole to me, so I decided to re-implement this feature using a HTTP module. The solution below allows you to handle any HTTP status code (including 404) by redirecting to any valid MVC route just as you would do normally.This has been tested on the following platforms;BenefitsThe SolutionUsageInclude this as the final HTTP module in your web.configFor those of you paying attention you will notice that in Integrated Pipeline mode this will always respond with HTTP 200 due to the way Server.TransferRequest works. To return the proper error code I use the following error controller.Adding my solution, which is almost identical to Herman Kan\'s, with a small wrinkle to allow it to work for my project.Create a custom error controller:Then create a custom controller factory:Finally, add an override to the custom error controller:And that\'s it. No need for Web.config changes.1) Make abstract Controller class. 2) Make inheritence from this abstract class in your all controllers  3) And add a view named "NotFound" in you View-Shared folder.I went through most of the solutions posted on this thread. While this question might be old, it is still very applicable to new projects even now, so I spent quite a lot of time reading up on the answers presented here as well as else where.As @Marco pointed out the different cases under which a 404 can happen, I checked the solution I compiled together against that list. In addition to his list of requirements, I also added one more. This solution is 2 fold: First part of it comes from @Guillaume at https://stackoverflow.com/a/27354140/2310818. Their solution takes care of any 404 that were caused due to invalid route, invalid controller and invalid action. The idea is to create a WebForm and then make it call the NotFound action of your MVC Errors Controller. It does all of this without any redirect so you will not see a single 302 in Fiddler. The original URL is also preserved, which makes this solution fantastic!  Second part of it comes from @Germ\xc3\xa1n at https://stackoverflow.com/a/5536676/2310818. Their solution takes care of any 404 returned by your actions in the form of HttpNotFoundResult() or throw new HttpException()! The idea is to have a filter look at the response as well as the exception thrown by your MVC controllers and to call the appropriate action in your Errors Controller. Again this solution works without any redirect and the original url is preserved! As you can see, both of these solutions together offer a very robust error handling mechanism and they achieve all the requirements listed by @Marco as well as my requirements. If you would like to see a working sample or a demo of this solution, please leave in the comments and I would be happy to put it together. I have gone through all articles but nothing works for me:\nMy requirement user type anything in your url custom 404 page should show.I thought it is very straight forward.But you should understand handling of 404 properly:I found this article very helpfull.should be read at once.Custome error page-Ben Foster