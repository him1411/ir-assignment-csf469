Consider this example (typical in OOP books):  I have an Animal class, where each Animal can have many friends.\nAnd subclasses like Dog, Duck, Mouse etc which add specific behavior like bark(), quack() etc.Here\'s the Animal class:And here\'s some code snippet with lots of typecasting:Is there any way I can use generics for the return type to get rid of the typecasting, so that I can say    Here\'s some initial code with return type conveyed to the method as a parameter that\'s never used. Is there a way to figure out the return type at runtime without the extra parameter using instanceof? Or at least by passing a class of the type instead of a dummy instance.\nI understand generics are for compile time type-checking, but is there a workaround for this?You could define callFriend this way:Then call it as such:This code has the benefit of not generating any compiler warnings. Of course this is really just an updated version of casting from the pre-generic days and doesn\'t add any additional safety. No. The compiler can\'t know what type jerry.callFriend("spike") would return. Also, your implementation just hides the cast in the method without any additional type safety. Consider this:In this specific case, creating an abstract talk() method and overriding it appropriately in the subclasses would serve you much better:You could implement it like this:(Yes, this is legal code; see Java Generics: Generic type defined as return type only.)The return type will be inferred from the caller. However, note the @SuppressWarnings annotation: that tells you that this code isn\'t typesafe. You have to verify it yourself, or you could get ClassCastExceptions at runtime.Unfortunately, the way you\'re using it (without assigning the return value to a temporary variable), the only way to make the compiler happy is to call it like this:While this may be a little nicer than casting, you are probably better off giving the Animal class an abstract talk() method, as David Schmitt said.This question is very similar to Item 29 in Effective Java - "Consider typesafe heterogeneous containers."  Laz\'s answer is the closest to Bloch\'s solution.  However, both put and get should use the Class literal for safety.  The signatures would become:Inside both methods you should check that the parameters are sane.  See Effective Java and the Class javadoc for more info.As you said passing a class would be OK, you could write this:And then use it like this:Not perfect, but this is pretty much as far as you get with Java generics. There is a way to implement Typesafe Heterogenous Containers (THC) using Super Type Tokens, but that has its own problems again.Not possible. How is the Map supposed to know which subclass of Animal it\'s going to get, given only a String key? The only way this would be possible is if each Animal accepted only one type of friend (then it could be a parameter of the Animal class), or of the callFriend() method got a type parameter. But it really looks like you\'re missing the point of inheritance: it\'s that you can only treat subclasses uniformly when using exclusively the superclass methods.Based on the same idea as Super Type Tokens, you could create a typed id to use instead of a string:But I think this may defeat the purpose, since you now need to create new id objects for each string and hold on to them (or reconstruct them with the correct type information).But you can now use the class in the way you originally wanted, without the casts.This is just hiding the type parameter inside the id, although it does mean you can retrieve the type from the identifier later if you wish.You\'d need to implement the comparison and hashing methods of TypedID too if you want to be able to compare two identical instances of an id.Additionally you can ask the method to return the value in a given type this wayMore examples here at Oracle Java documentationI\'ve written an article which contains a proof of concept, support classes and a test class which demonstrates how Super Type Tokens can be retrieved by your classes at runtime.\nIn a nutshell, it allows you to delegate to alternative implementations depending on actual generic parameters passed by the caller. Example:See:\nUsing TypeTokens to retrieve generic parameters ThanksRichard Gomes - Blog"Is there a way to figure out the return type at runtime without the extra parameter using instanceof?"As an alternative solution you could utilise the Visitor pattern like this. Make Animal abstract and make it implement Visitable:Visitable just means that an Animal implementation is willing to accept a visitor:And a visitor implementation is able to visit all the subclasses of an animal:So for example a Dog implementation would then look like this:The trick here is that as the Dog knows what type it is it can trigger the relevant overloaded visit method of the visitor v by passing "this" as a parameter. Other subclasses would implement accept() exactly the same way.The class that wants to call subclass specific methods must then implement the Visitor interface like this:I know it\'s a lot more interfaces and methods than you bargained for, but it\'s a standard way to get a handle on every specific subtype with precisely zero instanceof checks and zero type casts. And it\'s all done in a standard language agnostic fashion so it\'s not just for Java but any OO language should work the same.Not really, because as you say, the compiler only knows that callFriend() is returning an Animal, not a Dog or Duck.Can you not add an abstract makeNoise() method to Animal that would be implemented as a bark or quack by its subclasses?What you\'re looking for here is abstraction. Code against interfaces more and you should have to do less casting.The example below is in C# but the concept remains the same.I know this is a completely different thing that the one asked. Another way of resolving this would be reflection. I mean, this does not take the benefit from Generics, but it lets you emulate, in some way, the behavior you want to perform (make a dog bark, make a duck quack, etc.) without taking care of type casting: what about}Here is the simpler version======================Fully working code}I did the following in my lib kontraktor:subclassing:at least this works inside the current class and when having a strong typed reference. Multiple inheritance works, but gets really tricky then :)There is another approach, you can narrow the return type when you override a method. In each subclass you would have to override callFriend to return that subclass. The cost would be the multiple declarations of callFriend, but you could isolate the common parts to a method called internally. This seems a lot simpler to me than the solutions mentioned above, and does not need an extra argument to determine the return type.There are a lot of great answers here, but this is the approach I took for an Appium test where acting on a single element can result in going to different application states based on the user\'s settings. While it doesn\'t follow the conventions of OP\'s example, I hope it helps someone.If you don\'t want to throw the errors you can catch them like so:You can return any type and receive directly like. Don\'t need to typecast.This is best if you want to customize any other kind of records instead of real cursors.