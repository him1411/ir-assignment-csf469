What is the difference between == and ===?What would be some useful examples?The difference between the loosely == equal operator and the strict === identical operator is exactly explained in the manual:Comparison OperatorsIf you are using the == operator, or any other comparison operator which uses loosely comparison such as !=, <> or ==, you always have to look at the context to see what, where and why something gets converted to understand what is going on.As reference and example you can see the comparison table in the manual:Loose comparisons with ==If you are using the === operator, or any other comparison operator which uses strict comparison such as !== or ===, then you can always be sure that the types won\'t magically change, because there will be no converting going on. So with strict comparison the type and value have to be the same, not only the value.As reference and example you can see the comparison table in the manual:Strict comparisons with ===The operator == casts between two different types if they are different, while the === operator performs a \'typesafe comparison\'. That means that it will only return true if both operands have the same type and the same value.Examples:Warning: two instances of the same class with equivalent members do NOT match the === operator. Example:In regards to JavaScript:The === operator works the same as the == operator, but it requires that its operands have not only the same value, but also the same data type.For example, the sample below will display \'x and y are equal\', but not \'x and y are identical\'.A picture is worth a thousand words:Source code to create these images:https://github.com/sentientmachine/php_equality_chartsThose who wish to keep their sanity, read no further.PHP Variables that have not been declared yet are false.False is equal to 0, blankstring and empty array and "0".NAN does not == itself, but it is True.A fresh class is == to 1.If you are using PHP, Thou shalt not use the double equals operator, always use triple equals.An addition to the other answers concerning object comparison:== compares objects using the name of the object and their values. If two objects are of the same type and have the same member values, $a == $b yields true.=== compares the internal object id of the objects. Even if the members are equal, $a !== $b if they are not exactly the same object.In simplest terms:== checks if equivalent (value only)=== checks if the same (value && type)\n\nEquivalent vs. Same: An Analogy1 + 1 = 2 + 0 (equivalent)1 + 1 = 1 + 1 (same)\n\nIn PHP:true == 1 (true - equivalent in value)true === 1 (false - not the same in value && type)It\'s all about data types. Take a BOOL (true or false) for example:true also equals 1 and\nfalse also equals 0The == does not care about the data types when comparing:\nSo if you had a variable that is 1 (which could also be true):$var=1;And then compare with the ==:But $var does not actually equal true, does it? It has the int value of 1 instead, which in turn, is equal to true.With ===, the data types are checked to make sure the two variables/objects/whatever are using the same type.So if I didthat condition would not be true, as $var !== true it only == true (if you know what I mean).Why would you need this?Simple - let\'s take a look at one of PHP\'s functions: array_search():The array_search() function simply searches for a value in an array, and returns the key of the element the value was found in. If the value could not be found in the array, it returns false. But, what if you did an array_search() on a value that was stored in the first element of the array (which would have the array key of 0)....the array_search() function would return 0...which is equal to false..So if you did:So, do you see how this could be an issue now?Most people don\'t use == false when checking if a function returns false. Instead, they use the !. But actually, this is exactly the same as using ==false, so if you did:So for things like that, you would use the === instead, so that the data type is checked.One example is that a database attribute can be null or "":Given x = 51) Operator :  ==  is "equal to". x == 8 is false\n2) Operator :  === is "exactly equal to" (value and type) x === 5 is true, x === "5" is falseBe careful though. Here is a notorious problem.vs.In short, === works in the same manner that == does in most other programming languages.PHP allows you to make comparisons that don\'t really make sense. Example:While this allows for some interesting "shortcuts" you should beware since a function that returns something it shouldn\'t (like "error" instead of a number) will not get caught, and you will be left wondering what happened.In PHP, == compares values and performs type conversion if necessary (for instance, the string "12343sdfjskfjds" will become "12343" in an integer comparison). === will compare the value AND type and will return false if the type is not the same.If you look in the PHP manual, you will see that a lot of functions return "false" if the function fails, but they might return 0 in a successful scenario, which is why they recommend doing "if (function() !== false)" to avoid mistakes.Few of the examplesP.S.== Compares the value only, it won\'t bother about the data typesvs.=== Compares the values and data typesYou would use === to test whether a function or variable is false rather than just equating to false (zero or an empty string).In this case strpos would return 0 which would equate to false in the testorwhich is not what you want here.As for when to use one over the other, take for example the fwrite() function in PHP.This function writes content to a file stream. According to PHP, "fwrite() returns the number of bytes written, or FALSE on error.". If you want to test if the function call was successful, this method is flawed:It can return zero (and is considered successful), and your condition still gets triggered. The right way would be:Variables have a type and a value.When you use these variables (in PHP), sometimes you don\'t have the good type.\nFor example, if you doPHP have to convert ("to cast") $var to integer. In this case, "$var == 1" is true because any non-empty string is casted to 1.When using ===, you check that the value AND THE TYPE are equal, so "$var === 1" is false.This is useful, for example, when you have a function that can return false (on error) and 0 (result) :This code is wrong as if myFunction() returns 0, it is casted to false and you seem to have an error. The correct code is :because the test is that the return value "is a boolean and is false" and not "can be casted to false".The === operator is supposed to compare exact content equality while the == operator would compare semantic equality. In particular it will coerce strings to numbers.Equality is a vast subject. See the Wikipedia article on equality.PHP is a loosely typed language. Using the double equal operator allows for a loose checking of a variable.Loosely checking a value would allow for some similar, but not equal, values to equate as the same:All of these values would equate as equal using the double equal operator.All of the answers so far ignore a dangerous problem with ===. It has been noted in passing, but not stressed, that integer and double are different types, so the following code:gives:Note that this is NOT a case of a "rounding error". The two numbers are exactly equal down to the last bit, but they have different types.This is a nasty problem because a program using === can run happily for years if all of the numbers are small enough (where "small enough" depends on the hardware and OS you are running on). However, if by chance, an integer happens to be large enough to be converted to a double, its type is changed "forever" even though a subsequent operation, or many operations, might bring it back to a small integer in value. And, it gets worse. It can spread - double-ness infection can be passed along to anything it touches, one calculation at a time. In the real world, this is likely to be a problem in programs that handle dates beyond the year 2038, for example. At this time, UNIX timestamps (number of seconds since 1970-01-01 00:00:00 UTC) will require more than 32-bits, so their representation will "magically" switch to double on some systems. Therefore, if you calculate the difference between two times you might end up with a couple of seconds, but as a double, rather than the integer result that occurs in the year 2017.I think this is much worse than conversions between strings and numbers because it is subtle. I find it easy to keep track of what is a string and what is a number, but keeping track of the number of bits in a number is beyond me.So, in the above answers there are some nice tables, but no distinction between 1 (as an integer) and 1 (subtle double) and 1.0 (obvious double). Also, advice that you should always use === and never == is not great because === will sometimes fail where == works properly. Also, JavaScript is not equivalent in this regard because it has only one number type (internally it may have different bit-wise representations, but it does not cause problems for ===).My advice - use neither. You need to write your own comparison function to really fix this mess.