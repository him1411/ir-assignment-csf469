I often need to kill a process during programming.The way I do it now is:How can I extract the process id automatically and kill it in the same line?Like this:In bash, you should be able to do:Details on its workings are as follows:Here\'s a transcript showing it in action:and you can see it terminating all the sleepers.Explaining the grep \'[p]ython csp_build.py\' bit in a bit more detail:When you do sleep 3600 & followed by ps -ef | grep sleep, you tend to get two processes with sleep in it, the sleep 3600 and the grep sleep (because they both have sleep in them, that\'s not rocket science).However, ps -ef | grep \'[s]leep\' won\'t create a process with sleep in it, it instead creates grep \'[s]leep\' and here\'s the tricky bit: the grep doesn\'t find it because it\'s looking for the regular expression "any character from the character class [s] (which is s) followed by leep.In other words, it\'s looking for sleep but the grep process is grep \'[s]leep\' which doesn\'t have sleep in it.When I was shown this (by someone here on SO), I immediately started using it becauseif you have pkill, If you only want to grep against the process name (instead of the full argument list) then leave off -f.ps aux  |  grep -i csp_build  |  awk \'{print $2}\'  |  xargs sudo kill -9I also have 2 shortcut functions defined in my .bash_profile\n(~/.bash_profile is for osx, you have to see what works for your *nix machine).bash_profile code:bash_profile code:Try using Interpret process name pattern as an extended regular expression.You may use only pkill \'^python*\' for regex process killing. If you want to see what you gonna kill or find before killing just use pgrep -l \'^python*\' where -l outputs also name of the process. If you don\'t want to use \npkill, use just:pgrep \'^python*\' | xargs killyou can do it with awk and backtics$2 in awk prints column 2, and the backtics runs the statement that\'s printed.But a much cleaner solution would be for the python process to store it\'s process id in /var/run and then you can simply read that file and kill it.My task was kill everything matching regexp that is placed in specific directory (after selenium tests not everything got stop). This worked for me:Use pgrep - available on many platforms:pgrep -f will return all PIDs with coincidence "cps_build"A method using only awk (and ps):By using string equality testing I prevent matching this process itself.Kill our own processes started from a common PPID is quite frequently, pkill associated to the \xe2\x80\x93P flag is a winner for me. Using @ghostdog74 example :You don\'t need the user switch for ps.Give -f to pkill exact path of .py file is In some cases, I\'d like kill processes simutaneously like this way:But, I think it is a little bit inappropriate in your case.(May be there are running python a, python b, python x...in the background.)I started using something like this:It can be done even quicker than the accepted solution(s).If I want to kill midori, for example:kill -SIGTERM $(pgrep midori)Done!I use this to kill Firefox when it\'s being script slammed and cpu bashing :)\nReplace \'Firefox\' with the app you want to die. I\'m on the Bash shell - OS X 10.9.3 Darwin.kill -Hup $(ps ux | grep Firefox | awk \'NR == 1 {next} {print $2}\' | uniq | sort)I use gkill processname, where gkill is the following script:NOTE: it will NOT kill processes that have "grep" in their command lines.