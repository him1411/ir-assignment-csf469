I am trying to understand the difference between these four methods. I know by default that == calls the method equal? which returns true when both operands refer to exactly the same object.=== by default also calls == which calls equal?... okay, so if all these three methods are not overridden, then I guess\n===, == and equal? do exactly the same thing?Now comes eql?. What does this do (by default)? Does it make a call to the operand\'s hash/id? Why does Ruby have so many equality signs? Are they supposed to differ in semantics?I\'m going to heavily quote the Object documentation here, because I think it has some great explanations. I encourage you to read it, and also the documentation for these methods as they\'re overridden in other classes, like String.Side note: if you want to try these out for yourself on different objects, use something like this:At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendant classes to provide class-specific meaning.This is the most common comparison, and thus the most fundamental place where you (as the author of a class) get to decide if two objects are "equal" or not.For class Object, effectively the same as calling #==, but typically overridden by descendants to provide meaningful semantics in case statements.This is incredibly useful. Examples of things which have interesting === implementations:So you can do things like:See my answer here for a neat example of how case+Regex can make code a lot cleaner. And of course, by providing your own === implementation, you can get custom case semantics.The eql? method returns true if obj and other refer to the same hash key. This is used by Hash to test members for equality. For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition by aliasing eql? to their overridden == method, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so:So you\'re free to override this for your own uses, or you can override == and use alias :eql? :== so the two methods behave the same way.Unlike ==, the equal? method should never be overridden by subclasses: it is used to determine object identity (that is, a.equal?(b) iff a is the same object as b).This is effectively pointer comparison.I love jtbandes answer, but since it is pretty long, I will add my own compact answer:==, ===, eql?, equal?\nare 4 comparators, ie. 4 ways to compare 2 objects, in Ruby.\nAs, in Ruby, all comparators (and most operators) are actually method-calls, you can change, overwrite, and define the semantics of these comparing methods yourself. However, it is important to understand, when Ruby\'s internal language constructs use which comparator:== (value comparison)\nRuby uses :== everywhere to compare the values of 2 objects, eg. Hash-values:=== (case comparison)\nRuby uses :=== in case/when constructs. The following code snippets are logically identical:eql? (Hash-key comparison)\nRuby uses :eql? (in combination with the method hash) to compare Hash-keys. In most classes :eql? is identical with :==.\nKnowledge about :eql? is only important, when you want to create your own special classes:Note: The commonly used Ruby-class Set also relies on Hash-key-comparison.equal? (object identity comparison)\nRuby uses :equal? to check if two objects are identical. This method (of class BasicObject) is not supposed to be overwritten.The == operator, also known as equality or double equal, will return true if both objects are equal and false if they are not.The != operator, AKA inequality or bang-tilde, is the opposite of ==. It will return true if both objects are not equal and false if they are equal.Note that two arrays with the same elements in a different order are not equal, uppercase and lowercase versions of the same letter are not equal and so on. When comparing numbers of different types (e.g., integer and float), if their numeric value is the same, == will return true.Unlike the == operator which tests if both operands are equal, the equal method checks if the two operands refer to the same object. This is the strictest form of equality in Ruby.Example:\n    a = "zen"\n    b = "zen"In the example above, we have two strings with the same value. However, they are two distinct objects, with different object IDs. Hence, the equal? method will return false.Let\'s try again, only this time b will be a reference to a. Notice that the object ID is the same for both variables, as they point to the same object.In the Hash class, the eql? method it is used to test keys for equality. Some background is required to explain this. In the general context of computing, a hash function takes a string (or a file) of any size and generates a string or integer of fixed size called hashcode, commonly referred to as only hash. Some commonly used hashcode types are MD5, SHA-1, and CRC. They are used in encryption algorithms, database indexing, file integrity checking, etc. Some programming languages, such as Ruby, provide a collection type called hash table. Hash tables are dictionary-like collections which store data in pairs, consisting of unique keys and their corresponding values. Under the hood, those keys are stored as hashcodes. Hash tables are commonly referred to as just hashes. Notice how the word hashcan refer to a hashcode or to a hash table. In the context of Ruby programming, the word hash almost always refers to the dictionary-like collection.Ruby provides a built-in method called hash for generating hashcodes. In the example below, it takes a string and returns a hashcode. Notice how strings with the same value always have the same hashcode, even though they are distinct objects (with different object IDs).The hash method is implemented in the Kernel module, included in the Object class, which is the default root of all Ruby objects. Some classes such as Symbol and Integer use the default implementation, others like String and Hash provide their own implementations. In Ruby, when we store something in a hash (collection), the object provided as a key (e.g., string or symbol) is converted into and stored as a hashcode. Later, when retrieving an element from the hash (collection), we provide an object as a key, which is converted into a hashcode and compared to the existing keys. If there is a match, the value of the corresponding item is returned. The comparison is made using the eql? method under the hood. In most cases, the eql? method behaves similarly to the == method. However, there are a few exceptions. For instance, eql? does not perform implicit type conversion when comparing an integer to a float.Many of Ruby\'s built-in classes, such as String, Range, and Regexp, provide their own implementations of the === operator, also known as case-equality, triple equals or threequals. Because it\'s implemented differently in each class, it will behave differently depending on the type of object it was called on. Generally, it returns true if the object on the right "belongs to" or "is a member of" the object on the left. For instance, it can be used to test if an object is an instance of a class (or one of its subclasses).The same result can be achieved with other methods which are probably best suited for the job. It\'s usually better to write code that is easy to read by being as explicit as possible, without sacrificing efficiency and conciseness. Notice the last example returned false because integers such as 2 are instances of the Fixnum class, which is a subclass of the Integer class. The ===, is_a? and instance_of? methods return true if the object is an instance of the given class or any subclasses. The instance_of method is stricter and only returns true if the object is an instance of that exact class, not a subclass. The is_a? and kind_of? methods are implemented in the Kernel module, which is mixed in by the Object class. Both are aliases to the same method. Let\'s verify:Kernel.instance_method(:kind_of?) == Kernel.instance_method(:is_a?) # Output: => trueWhen the === operator is called on a range object, it returns true if the value on the right falls within the range on the left.Remember that the === operator invokes the === method of the left-hand object. So (1..4) === 3 is equivalent to (1..4).=== 3. In other words, the class of the left-hand operand will define which implementation of the === method will be called, so the operand positions are not interchangeable. Returns true if the string on the right matches the regular expression on the left.\n    /zen/ === "practice zazen today"  # Output: => true\n    # is the same as\n    "practice zazen today"=~ /zen/This operator is also used under the hood on case/when statements. That is its most common use.In the example above, if Ruby had implicitly used the double equal operator (==), the range 10..20 would not be considered equal to an integer such as 15. They match because the triple equal operator (===) is implicitly used in all case/when statements. The code in the example above is equivalent to:The =~ (equal-tilde) and !~ (bang-tilde) operators are used to match strings and symbols against regex patterns. The implementation of the =~ method in the String and Symbol classes expects a regular expression (an instance of the Regexp class) as an argument. The implementation in the Regexp class expects a string or a symbol as an argument. In all implementations, when the string or symbol matches the Regexp pattern, it returns an integer which is the position (index) of the match. If there is no match, it returns nil. Remember that, in Ruby, any integer value is "truthy" and nil is "falsy", so the =~ operator can be used in if statements and ternary operators.Pattern-matching operators are also useful for writing shorter if statements. Example:The !~ operator is the opposite of =~, it returns true when there is no match and false if there is a match.More info is available at this blog post.both works similar but "===" even do case statementshere the differenceRuby exposes several different methods for handling equality:a.equal?(b) # object identity - a and b refer to the same objecta.eql?(b) # object equivalence - a and b have the same valuea == b # object equivalence - a and b have the same value with type conversion.Continue reading by clicking the link below, it gave me a clear summarized understanding.https://www.relishapp.com/rspec/rspec-expectations/v/2-0/docs/matchers/equality-matchersHope it helps others.I would like to expand on the === operator.=== is not an equality operator!Not.Let\'s get that point really across. You might be familiar with === as an equality operator in Javascript and PHP, but this just not an equality operator in Ruby and has fundamentally different semantics.So what does === do?=== is the pattern matching operator!So how does this madness make sense?That is why you can use regular expressions and classes and ranges and even lambda expressions in a case when statement.Some examplesAll these example work with pattern === value too, as well as with grep method.I wrote a simple test for all the above.