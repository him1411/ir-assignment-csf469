This question already has an answer here:I noticed a Python script I was writing was acting squirrelly, and traced it to an infinite loop, where the loop condition was while line is not \'\'. Running through it in the debugger, it turned out that line was in fact \'\'. When I changed it to !=\'\' rather than is not \'\', it worked fine. Also, is it generally considered better to just use \'==\' by default, even when comparing int or Boolean values? I\'ve always liked to use \'is\' because I find it more aesthetically pleasing and pythonic (which is how I fell into this trap...), but I wonder if it\'s intended to just be reserved for when you care about finding two objects with the same id.For all built-in Python objects (like\n  strings, lists, dicts, functions,\n  etc.), if x is y, then x==y is also\n  True.Not always.  NaN is a counterexample.  But usually, identity (is) implies equality (==).  The converse is not true: Two distinct objects can have the same value.Also, is it generally considered better to just use \'==\' by default, even\n  when comparing int or Boolean values?You use == when comparing values and is when comparing identities.When comparing ints (or immutable types in general), you pretty much always want the former.  There\'s an optimization that allows small integers to be compared with is, but don\'t rely on it.For boolean values, you shouldn\'t be doing comparisons at all.   Instead of:write:For comparing against None, is None is preferred over == None.I\'ve always liked to use \'is\' because\n  I find it more aesthetically pleasing\n  and pythonic (which is how I fell into\n  this trap...), but I wonder if it\'s\n  intended to just be reserved for when\n  you care about finding two objects\n  with the same id.Yes, that\'s exactly what it\'s for.I would like to show a little example on how is and == are involved in immutable types. Try that:is compares two objects in memory, == compares their values. For example, you can see that small integers are cached by Python:You should use == when comparing values and is when comparing identities. (Also, from an English point of view, "equals" is different from "is".)The logic is not flawed.  The statementif x is y then x==y is also True should never be read to mean if x==y then x is y It is a logical error on the part of the reader to assume that the converse of a logic statement is true.  See http://en.wikipedia.org/wiki/Converse_(logic)See This questionYour logic in reading For all built-in Python objects (like\n  strings, lists, dicts, functions,\n  etc.), if x is y, then x==y is also\n  True.is slightly flawed.If is applies then == will be True, but it does NOT apply in reverse. == may yield True while is yields False.