Is there a better way to get the Property name when passed in via a lambda expression?\nHere is what i currently have.eg. It worked by casting it as a memberexpression only when the property was  a string. because not all properties are strings i had to use object but then it would return a unaryexpression for those.I recently did a very similar thing to make a type safe OnPropertyChanged method.Here\'s a method that\'ll return the PropertyInfo object for the expression. It throws an exception if the expression is not a property.The source parameter is used so the compiler can do type inference on the method call. You can do the followingI found another way you can do it was to have the source and property strongly typed and explicitly infer the input for the lambda. Not sure if that is correct terminology but here is the result.And then call it like so.and voila it works.\nThanks all.I was playing around with the same thing and worked this up. It\'s not fully tested but seems to handle the issue with value types (the unaryexpression issue you ran into)This handles member and unary expressions. The difference being that you will get a UnaryExpression if your expression represents a value type whereas you will get a MemberExpression if your expression represents a reference type. Everything can be cast to an object, but value types must be boxed. This is why the UnaryExpression exists. Reference.For the sakes of readability (@Jowen), here\'s an expanded equivalent:There\'s an edge case when it comes to Array.Length. While \'Length\' is exposed as a property, you can\'t use it in any of the previously proposed solutions.Now example usage:If PropertyNameFromUnaryExpr didn\'t check for ArrayLength, "someArray" would be printed to the console (compiler seems to generate direct access to the backing Length field, as an optimization, even in Debug, thus the special case).This is a general implementation to get the string name of fields/properties/indexers/methods/extension methods/delegates of struct/class/interface/delegate/array. I have tested with combinations of static/instance and non-generic/generic variants.This thing can be written in a simple while loop too:I like the recursive approach, though the second one might be easier to read. One can call it like: to print the last member.Note:In case of chained expressions like A.B.C, "C" is returned. This doesn\'t work with consts, array indexers or enums (impossible to cover all cases). Here\'s an update to method proposed by Cameron. The first parameter is not required.You can do the following:Extension methods:You can:I\'ve found that some of the suggested answers which drill down into the MemberExpression/UnaryExpression don\'t capture nested/subproperties.ex) o => o.Thing1.Thing2 returns Thing1 rather than Thing1.Thing2.This distinction is important if you\'re trying to work with EntityFramework DbSet.Include(...).I\'ve found that just parsing the Expression.ToString() seems to work fine, and comparatively quickly.  I compared it against the UnaryExpression version, and even getting ToString off of the Member/UnaryExpression to see if that was faster, but the difference was negligible.  Please correct me if this is a terrible idea.(Checking for the delimiter might even be overkill)Demonstration + Comparison code -- https://gist.github.com/zaus/6992590now in C# 6 you can simply use nameof like this nameof(User.UserId) which has many benefits, among them is that this is done at compile time, not runtime.https://msdn.microsoft.com/en-us/magazine/dn802602.aspxWell, there\'s no need to call .Name.ToString(), but broadly that is about it, yes. The only consideration you might need is whether x.Foo.Bar should return "Foo", "Bar", or an exception - i.e. do you need to iterate at all.(re comment) for more on flexible sorting, see here.I"m using an extension method for pre C# 6 projects and the nameof() for those targeting C# 6.And i call it like:It works fine with both fields and properties.I created an extension method on ObjectStateEntry to be able to flag properties (of Entity Framework POCO classes) as modified in a type safe manner, since the default method only accepts a string. Here\'s my way of getting the name from the property:I have done the INotifyPropertyChanged implementation similar to the method below. Here the properties are stored in a dictionary in the base class shown below. It is of course not always desirable to use inheritance, but for view models I think it is acceptable and gives very clean property references in the view model classes. The somewhat more complex base class is shown below. It handles the translation from lambda expression to property name. Note that the properties are really pseudo properties since only the names are used. But it will appear transparent to the view model and references to the properties on the view model.This is another answer:I\'ve updated @Cameron\'s answer to include some safety checks against Convert typed lambda expressions:I leave this function if you want to get multiples fields:Here is another way to get the PropertyInfo based off this answer. It eliminates the need for an object instance.It can be called like so: