I have the following element:In this case the site is HTTPS, but the site may also be just HTTP. (The JS file is on another domain.) I\'m wondering if it\'s valid to do the following for convenience sake:I\'m wondering if it\'s valid to remove the http: or https:?It seems to work everywhere I have tested, but are there any cases where it doesn\'t work?A relative URL without a scheme (http: or https:) is valid, per RFC 3986: "Uniform Resource Identifier (URI): Generic Syntax", Section 4.2.  If a client chokes on it, then it\'s the client\'s fault because they\'re not complying with the URI syntax specified in the RFC.Your example is valid and should work.  I\'ve used that relative URL method myself on heavily trafficked sites and have had zero complaints.  Also, we test our sites in Firefox, Safari, IE6, IE7 and Opera.  These browsers all understand that URL format.It is guaranteed to work in any mainstream browser (I\'m not taking browsers with less than 0.05% market share into consideration). Heck, it works in Internet Explorer 3.0.RFC 3986 defines a URI as composed of the following parts:When defining relative URIs (Section 5.2), you can omit any of those sections, always starting from the left. In pseudo-code, it looks like this:The URI you are describing is a scheme-less relative URI.are there any cases where it doesn\'t work?If the parent page was loaded from file://, then it probably does not work (it will try to get file://cdn.example.com/js_file.js, which of course you could provide locally as well).Many people call this a Protocol Relative URL.It causes a double-download of CSS files in IE 7 & 8.Here I duplicate the answer in Hidden features of HTML:Using a protocol-independent absolute\n  path:If the browser is viewing an page in\n  SSL through HTTPS, then it\'ll request\n  that asset with the https protocol,\n  otherwise it\'ll request it with HTTP.This prevents that awful "This Page\n  Contains Both Secure and Non-Secure\n  Items" error message in IE, keeping\n  all your asset requests within the\n  same protocol.Caveat: When used on a <link> or\n  @import for a stylesheet, IE7 and IE8\n  download the file twice. All other\n  uses, however, are just fine.It is perfectly valid to leave off the protocol.  The URL spec has been very clear about this for years, and I\'ve yet to find a browser that doesn\'t understand it.  I don\'t know why this technique isn\'t better known; it\'s the perfect solution to the thorny problem of crossing HTTP/HTTPS boundaries.  More here: Http-https transitions and relative URLsare there any cases where it doesn\'t work?Just to throw this in the mix, if you are developing on a local server, it might not work. You need to specify a scheme, otherwise the browser may assume that src="//cdn.example.com/js_file.js" is src="file://cdn.example.com/js_file.js", which will break since you\'re not hosting this resource locally.Microsoft Internet Explorer seem to be particularly sensitive to this, see this question: Not able to load jQuery in Internet Explorer on localhost (WAMP)You would probably always try to find a solution that works on all your environments with the least amount of modifications needed.The solution used by HTML5Boilerplate is to have a fallback when the resource is not loaded correctly, but that only works if you incorporate a check:UPDATE: HTML5Boilerplate now uses <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js after deciding to deprecate protocol relative URLs, see [here][3].Following the gnud\'s reference, the RFC 3986 section 5.2 says:If the scheme component is defined, indicating that the reference\n  starts with a scheme name, then the reference is interpreted as an\n  absolute URI and we are done. Otherwise, the reference URI\'s scheme\n  is inherited from the base URI\'s scheme component.So // is correct :-)Yes, this is documented in RFC 3986, section 5.2:(edit: Oops, my RFC reference was outdated).It is indeed correct, as other answers have stated. You should note though, that some web crawlers will set off 404s for these by requesting them on your server as if a local URL. (They disregard the double slash and treat it as a single slash).You may want to set up a rule on your webserver to catch these and redirect them.For example, with Nginx, you\'d add something like:Do note though, that if you use periods in your URIs, you\'ll need to increase the specificity or it will end up redirecting those pages to nonexistent domains.Also, this is a rather massive regex to be running for each query -- in my opinion, it\'s worth punishing non-compliant browsers with 404s over a (slight) performance hit on the majority of compliant browsers.We are seeing 404 errors in our logs when using //somedomain.com as references to JS files.  The references that cause the 404s come out looking like this:\nref:404 request:With these showing up regularly in our web server logs, it is safe to say that: All browsers and Bots DO NOT honor RFC 3986 section 4.2. The safest bet is to include the protocol whenever possible.The pattern I see on html5-boilerplate is:It runs smoothly on different schemes like http, https, file.