I used to know what this meant, but I\'m struggling now...Is this basically saying document.onload?It\xe2\x80\x99s an Immediately-Invoked Function Expression, or IIFE for short. It executes immediately after it\xe2\x80\x99s created.It has nothing to do with any event-handler for any events (such as document.onload).\nThe first pair of parentheses (function(){...}) turns the code within (in this case, a function) into an expression,  and the second pair of parentheses (function(){...})() calls the function that results from that evaluated expression.This pattern is often used when trying to avoid polluting the global namespace, because all the variables used inside the IIFE (like in any other normal function) are not visible outside its scope.\nThis is why, maybe, you confused this construction with an event-handler for window.onload, because it\xe2\x80\x99s often used as this:  Correction suggested by Guffa:The function is executed right after it\'s created, not after it is parsed. The entire script block is parsed before any code in it is executed. Also, parsing code doesn\'t automatically mean that it\'s executed, if for example the IIFE is inside a function then it won\'t be executed until the function is called.It\'s just an anonymous function that is executed right after it\'s created.It\'s just as if you assigned it to a variable, and used it right after, only without the variable:In jQuery there is a similar construct that you might be thinking of:That is the short form of binding the ready event:An immediately-invoked function expression (IIFE) immediately calls a function. This simply means that the function is executed immediately after the completion of the definition.Three more common wordings:If there are no special requirements for its return value, then we can write:Alternatively, it can be:You can even write:It declares an anonymous function, then calls it:That is saying execute immediately.so if I do:Fiddle: http://jsfiddle.net/maniator/LqvpQ/That construct is called Immediately Invoked Function Expression (IIFE) which means it gets executed immediately. Think of it as a function getting called automatically when the interpreter reaches that function.Most Common Use-case:One of its most common use case is to limit the scope of a variable made via var. Variables created via var have a scope limited to a function so this construct (which is a function wrapper around certain code) will make sure that your variable scope doesn\'t leak out of that function. In following example, count will not be available outside the immediately invoked function i.e. Scope of count will not leak out of the function. You should get a Reference Error, should you try to access it outside of the immediately invoked function anyway.ES6 Alternative (Recommended)In ES6, we now can have variables created via let and const. Both of them are block-scoped (unlike var which is a function-scoped).Therefore, instead of using that complex construct of IIFE for the use case I mentioned above, you can now write much, much simpler code to make sure that a variable\'s scope does not leak out of your desired block. In this example, we used let to define a count variable which makes count limited to the block of code, we created with the curly brackets {...}. I call it a Curly Jail. No, this construct just creates a scope for naming. If you break it in parts you can see that you have an externalThat is a function invocation. Inside the parenthesis you have:That is an anonymous function. Everything that is declared with var inside the construct will be visible only inside the same construct and will not pollute the global namespace.This is called IIFE (Immediately Invoked Function Expression). One of the famous javascript design pattern, and it is the heart and soul of modern day Module pattern. As the name suggests it executes immediately after it is created. This pattern creates an isolated or the private scope of execution.JavaScript prior to ECMAScript 6 using lexical scoping, IIFE is used for simulating the block scoping. (With ECMAScript 6 block scoping is possible with introduction of let and const keyword.)\nReference for issue with lexical scopingSimulate block scoping with IIFEThe Performance benefit of using IIFE\xe2\x80\x99s is the ability to pass commonly used global objects like window, document, etc. As an argument by reducing the scope lookup.(Remember Javascript looks for property in a local scope and way up chaining till global scope). So accessing global objects in local scope, reduce the lookup time like below.That is a self-invoking anonymous function.Check out the W3Schools explanation of a self-invoking function.Function expressions can be made "self-invoking".A self-invoking expression is invoked (started) automatically, without\n  being called.Function expressions will execute automatically if the expression is\n  followed by ().You cannot self-invoke a function declaration.This is the self-invoking anonymous function. It is executed while it is defined. Which means this function is defined and invokes itself immediate after the definition.And the explanation of the syntax is: The function within the first () parenthesis is the function which has no name and by the next (); parenthesis you can understand that it is called at the time it is defined. And you can pass any argument in this second () parenthesis which will be grabbed in the function which is in the first parenthesis. See this example:Here the \'object\' you are passing will be accessible within the function by \'obj\', as you are grabbing it in the function signature.Self-executing anonymous function. It\'s executed as soon as it is created.One short and dummy example where this is useful is:So instead of creating a list each time, you create it only once (less overhead).Self-executing functions are typically used to encapsulate context and avoid name collusions. Any variable that you define inside the (function(){..})() are not global.The codeproduces this output:By using this syntax you avoid colliding with global variables declared elsewhere in your JavaScript code.IIFE (Immediately invoked function expression) is a function which executes as soon as the script loads and goes away. Consider the function below written in a file named iife.jsThis code above will execute as soon as you load iife.js and will print \'Hello Stackoverflow!\' on the developer tools\' console. For a Detailed explanation see Immediately-Invoked Function Expression (IIFE)This an anonymous function which is self invoking. Commonly known as an Immediatly invoked Function Expression (IIFE).one more usecase is memoization where cache object is not global:An immediately invoked function expression (IIFE) is a function that\'s executed as soon as it\'s created. It has no connection with any events or asynchronous execution. You can define an IIFE as shown below:The first pair of parentheses function(){...} converts the code inside the parentheses into an expression.The second pair of parentheses calls the function resulting from the expression.An IIFE can also be described as a self-invoking anonymous function. Its most common usage is to limit the scope of a variable made via var or to encapsulate context to avoid name collisions.I think the 2 sets of brackets makes it a bit confusing but I saw another usage in googles example, they used something similar, I hope this will help you understand better:so if windows.app is not defined, then window.app = {} is immediately executed, so window.app is assigned with {} during the condition evaluation, so the result is both app and window.app now become {}, so console output is:Start here:Put it in a function and it is no longer global -- your primary goal.Call the function immediately -- oops:Use the parentheses to avoid a syntax error:You can leave off the function name:It doesn\'t need to be any more complicated than that.