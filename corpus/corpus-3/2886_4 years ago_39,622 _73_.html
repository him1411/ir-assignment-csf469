What is a good strategy for keeping IPython notebooks under version control?The notebook format is quite amenable for version control: if one wants to version control the notebook and the outputs then this works quite well. The annoyance comes when one wants only to version control the input, excluding the cell outputs (aka. "build products") which can be large binary blobs, especially for movies and plots.  In particular, I am trying to find a good workflow that:As mentioned, if I chose to include the outputs (which is desirable when using nbviewer for example), then everything is fine.  The problem is when I do not want to version control the output.  There are some tools and scripts for stripping the output of the notebook, but frequently I encounter the following issues:I have considered several options that I shall discuss below, but have yet to find a good comprehensive solution.  A full solution might require some changes to IPython, or may rely on some simple external scripts.  I currently use mercurial, but would like a solution that also works with git: an ideal solution would be version-control agnostic.This issue has been discussed many times, but there is no definitive or clear solution from the user\'s perspective. The answer to this question should provide the definitive strategy.  It is fine if it requires a recent (even development) version of IPython or an easily installed extension.Update: I have been playing with my modified notebook version which optionally saves a .clean version with every save using Gregory Crosswhite\'s suggestions.  This satisfies most of my constraints but leaves the following unresolved:Here is my solution with git. It allows you to just add and commit (and diff) as usual: those operations will not alter your working tree, and at the same time (re)running a notebook will not alter your git history.Although this can probably be adapted to other VCSs, I know it doesn\'t satisfy your requirements (at least the VSC agnosticity). Still, it is perfect for me, and although it\'s nothing particularly brilliant, and many people probably already use it, I didn\'t find clear instructions about how to implement it by googling around. So it may be useful to other people.Create the file ~/.gitattributes, with the following contentRun the following commands:Done!Limitations:My solution reflects the fact that I personally don\'t like to keep generated stuff versioned - notice that doing merges involving the output is almost guaranteed to invalidate the output or your productivity or both.EDIT:if you do adopt the solution as I suggested it - that is, globally - you will have trouble in case for some git repo you want to version output. So if you want to disable the output filtering for a specific git repository, simply create inside it a file .git/info/attributes, with**.ipynb    filter=as content. Clearly, in the same way it is possible to do the opposite: enable the filtering only for a specific repository.the code is now maintained in its own git repoif the instructions above result in ImportErrors, try adding "ipython" before the path of the script:EDIT: May 2016 (updated February 2017): there are several alternatives to my script - for completeness, here is a list of those I know: nbstripout (other variants), nbstrip, jq.We have a collaborative project where the product is Jupyter Notebooks, and we\'ve use an approach for the last six months that is working great:  we activate saving the .py files automatically and track both .ipynb files and the .py files.  That way if someone wants to view/download the latest notebook they can do that via github or nbviewer, and if someone wants to see how the the notebook code has changed, they can just look at the changes to the .py files.  For Jupyter notebook servers, this can be accomplished by adding the linesto the jupyter_notebook_config.py file and restarting the notebook server.  If you aren\'t sure in which directory to find your jupyter_notebook_config.py file, you can type jupyter --config-dir, and if you don\'t find the file there, you can create it by typing jupyter notebook --generate-config.For Ipython 3 notebook servers, this can be accomplished by adding the linesto the ipython_notebook_config.py file and restarting the notebook server.  These lines are from a github issues answer @minrk provided and @dror includes them in his SO answer as well.For Ipython 2 notebook servers, this can be accomplished by starting the server using:or by adding the line to the ipython_notebook_config.py file and restarting the notebook server.If you aren\'t sure in which directory to find your ipython_notebook_config.py file, you can type ipython locate profile default, and if you don\'t find the file there, you can create it by typing ipython profile create.Here\'s our project on github that is using this approach:  and here\'s a github example of exploring recent changes to a notebook. We\'ve been very happy with this.I have created nbstripout, based on MinRKs gist, which supports both Git and Mercurial (thanks to mforbes). It is intended to be used either standalone on the command line or as a filter, which is easily (un)installed in the current repository via nbstripout install / nbstripout uninstall.Get it from PyPI or simplyHere is a new solution from Cyrille Rossant for IPython 3.0, which persists to markdown files rather than json-based ipymd files:https://github.com/rossant/ipymdAs pointed out by, the --script is deprecated in 3.x. This approach can be used by applying a post-save-hook. In particular, add the following to ipython_notebook_config.py:The code is taken from #8009.Unfortunately, I do not know much about Mercurial, but I can give you a possible solution that works with Git, in the hopes that you might be able to translate my Git commands into their Mercurial equivalents.For background, in Git the add command stores the changes that have been made to a file into a staging area.  Once you have done this, any subsequent changes to the file are ignored by Git unless you tell it to stage them as well.  Hence, the following script, which, for each of the given files, strips out all of the outputs and prompt_number sections, stages the stripped file, and then restores the original:NOTE: If running this gets you an error message like ImportError: No module named IPython.nbformat, then use ipython to run the script instead of python.Once the script has been run on the files whose changes you wanted to commit, just run git commit.(2017-02)strategiestoolsI use a very pragmatic approach; which work well for several notebooks, at several sides. And it even enables me to \'transfer\' notebooks around. It works both for Windows as Unix/MacOS.\nAl thought it is simple, is solve the problems above...Basically, do not track the .ipnyb-files, only the corresponding .py-files.\nBy starting the notebook-server with the --script option, that file is automatically created/saved when the notebook is saved. Those .py-files do contain all input; non-code is saved into comments, as are the cell-borders. Those file can be read/imported ( and dragged) into the notebook-server to (re)create a notebook. Only the output is gone; until it is re-run.Personally I use mercurial to version-track the .py files; and use the normal (command-line) commands to add, check-in (ect) for that. Most other (D)VCS will allow this to.Its simple to track the history now; the .py are small, textual and simple to diff. Once and a while, we need a clone (just branch; start a 2nd notebook-sever there), or a older version (check-it out and import into a notebook-server), etc.To follow up on the excellent script by Pietro Battiston, if you get a Unicode parsing error like this:You can add at the beginning of the script:I did what Albert & Rich did - Don\'t version .ipynb files (as these can contain images, which gets messy).  Instead, either always run ipython notebook --script or put c.FileNotebookManager.save_script = True in your config file, so that a (versionable) .py file is always created when you save your notebook.To regenerate notebooks (after checking out a repo or switching a branch) I put the script py_file_to_notebooks.py in the directory where I store my notebooks.Now, after checking out a repo, just run python py_file_to_notebooks.py to generate the ipynb files.  After switching branch, you may have to run python py_file_to_notebooks.py -ov to overwrite the existing ipynb files.Just to be on the safe side, it\'s good to also add\n*.ipynb to your .gitignore file.Edit: I no longer do this because (A) you have to regenerate your notebooks from py files every time you checkout a branch and (B) there\'s other stuff like markdown in notebooks that you lose.  I instead strip output from notebooks using a git filter.  Discussion on how to do this is here.Ok, so it looks like the current best solution, as per a discussion here, is to make a git filter to automatically strip output from ipynb files on commit.Here\'s what I did to get it working (copied from that discussion):I modified cfriedline\'s nbstripout file slightly to give an informative error when you can\'t import the latest IPython:\nhttps://github.com/petered/plato/blob/fb2f4e252f50c79768920d0e47b870a8d799e92b/notebooks/config/strip_notebook_output\nAnd added it to my repo, lets say in ./relative/path/to/strip_notebook_outputAlso added the file .gitattributes file to the root of the repo, containing:And created a setup_git_filters.sh containingAnd ran source setup_git_filters.sh.  The fancy $(git rev-parse...) thing is to find the local path of your repo on any (Unix) machine.After digging around, I finally found this relatively simple pre-save hook on the Jupyter docs. It strips the cell output data. You have to paste it into the jupyter_notebook_config.py file (see below for instructions).From Rich Signell\'s answer:If you aren\'t sure in which directory to find your jupyter_notebook_config.py file, you can type jupyter --config-dir [into command prompt/terminal], and if you don\'t find the file there, you can create it by typing jupyter notebook --generate-config.I\'ve built python package that solves this problemhttps://github.com/brookisme/gitnbIt provides a CLI with a git-inspired syntax to track/update/diff notebooks inside your git repo.Heres\' an exampleNote that last step, where I\'m using "gitnb commit" is committing to your git repo.  Its essentially a wrapper for There are several more methods, and can be configured so that it requires more or less user input at each stage, but thats the general idea.