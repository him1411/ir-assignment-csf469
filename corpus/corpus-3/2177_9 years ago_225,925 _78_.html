For example, let\'s say I have an application that can read in a CSV file with piles of data rows.  I give the user a summary of the number of rows based on types of data, but I want to make sure that I don\'t read in too many rows of data and cause OutOfMemoryErrors.  Each row translates into an object.  Is there an easy way to find out the size of that object programmatically?  Is there a reference that defines how large primitive types and object references are for a VM?Right now, I have code that says read up to 32,000 rows, but I\'d also like to have code that says read as many rows as possible until I\'ve used 32MB of memory.  Maybe that is a different question, but I\'d still like to know. You can use the java.lang.instrument packageCompile and put this class in a JAR:Add the following to your MANIFEST.MF:Use getObjectSize:Invoke with:Some years back Javaworld had an article on determining the size of composite and potentially nested Java objects, they basically walk through creating a sizeof() implementation in Java. The approach basically builds on other work where people experimentally identified the size of primitives and typical Java objects and then apply that knowledge to a method that recursively walks an object graph to tally the total size.It is always going to be somewhat less accurate than a native C implementation simply because of the things going on behind the scenes of a class but it should be a good indicator.Alternatively a SourceForge project appropriately called sizeof that offers a Java5 library with a sizeof() implementation.P.S. Do not use the serialization approach, there is no correlation between the size of a serialized object and the amount of memory it consumes when live.Firstly "the size of an object" isn\'t a well-defined concept in Java. You could mean the object itself, with just its members, the Object and all objects it refers to (the reference graph). You could mean the size in memory or the size on disk. And the JVM is allowed to optimise things like Strings.So the only correct way is to ask the JVM, which a good profiler (I use YourKit), which probably isn\'t what you want.However, from the description above it sounds like each row will be self-contained, and not have a big dependency tree, so the serialization method will probably be a good approximation on most JVMs. The easiest way to do this is as follows:Remember that if you have objects with common references this will not give the correct result, and size of serialization will not always match size in memory, but it is a good approximation. The code will be a bit more efficient if you initialise the ByteArrayOutputStream size to a sensible value.You should use jol, a tool developed as part of the OpenJDK project.JOL (Java Object Layout) is the tiny toolbox to analyze object layout schemes in JVMs. These tools are using Unsafe, JVMTI, and Serviceability Agent (SA) heavily to decoder the actual object layout, footprint, and references. This makes JOL much more accurate than other tools relying on heap dumps, specification assumptions, etc.To get the sizes of primitives, references and array elements, use VMSupport.vmDetails().  On Oracle JDK 1.8.0_40 running on 64-bit Windows (used for all following examples), this method returnsYou can get the shallow size of an object instance using ClassLayout.parseClass(Foo.class).toPrintable() (optionally passing an instance to toPrintable).  This is only the space consumed by a single instance of that class; it does not include any other objects referenced by that class.  It does include VM overhead for the object header, field alignment and padding.  For java.util.regex.Pattern:You can get a summary view of the deep size of an object instance using GraphLayout.parseInstance(obj).toFootprint().  Of course, some objects in the footprint might be shared (also referenced from other objects), so it is an overapproximation of the space that could be reclaimed when that object is garbage collected.  For the result of Pattern.compile("^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$") (taken from this answer), jol reports a total footprint of 1840 bytes, of which only 72 are the Pattern instance itself.If you instead use GraphLayout.parseInstance(obj).toPrintable(), jol will tell you the address, size, type, value and path of field dereferences to each referenced object, though that\'s usually too much detail to be useful.  For the ongoing pattern example, you might get the following.  (Addresses will likely change between runs.)The "(something else)" entries describe other objects in the heap that are not part of this object graph.The best jol documentation is the jol samples in the jol repository.  The samples demonstrate common jol operations and show how you can use jol to analyze VM and garbage collector internals.If you would just like to know how much memory is being used in your JVM, and how much is free, you could try something like this:edit: I thought this might be helpful as the question author also stated he would like to have logic that handles "read as many rows as possible until I\'ve used 32MB of memory."Back when I worked at Twitter, I wrote a utility for calculating deep object size. It takes into account different memory models (32-bit, compressed oops, 64-bit), padding, subclass padding, works correctly on circular data structures and arrays. You can just compile this one .java file; it has no external dependencies:https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/objectsize/ObjectSizeCalculator.javaI accidentally found a java class\n"jdk.nashorn.internal.ir.debug.ObjectSizeCalculator", already in jdk, \nwhich is easy to use and seems quite useful for determining the size of an object.results:Much of the other answers provide shallow sizes - e.g. the size of a HashMap without any of the keys or values, which isn\'t likely what you want.The jamm project uses the java.lang.instrumentation package above but walks the tree and so can give you the deep memory use.https://github.com/jbellis/jammYou have to walk the objects using reflection.  Be careful as you do:@jodonnell: I like the simplicity of your solution, but many objects aren\'t Serializable (so this would throw an exception), fields can be transient, and objects can override the standard methods.The java.lang.instrument.Instrumentation class provides a nice way to get the size of a Java Object, but it requires you to define a premain and run your program with a java agent. This is very boring when you do not need any agent and then you have to provide a dummy Jar agent to your application.So I got an alternative solution using the Unsafe class from the sun.misc. So, considering the objects heap alignment according to the processor architecture and calculating the maximum field offset, you can measure the size of a Java Object. In the example below I use an auxiliary class UtilUnsafe to get a reference to the sun.misc.Unsafe object.You have to measure it with a tool, or estimate it by hand, and it depends on the JVM you are using.There is some fixed overhead per object. It\'s JVM-specific, but I usually estimate 40 bytes. Then you have to look at the members of the class. Object references are 4 (8) bytes in a 32-bit (64-bit) JVM. Primitive types are: Arrays follow the same rules; that is, it\'s an object reference so that takes 4 (or 8) bytes in your object, and then its length multiplied by the size of its element.Trying to do it programmatically with calls to Runtime.freeMemory() just doesn\'t give you much accuracy, because of asynchronous calls to the garbage collector, etc. Profiling the heap with -Xrunhprof or other tools will give you the most accurate results.There is also the Memory Measurer tool (formerly at Google Code, now on GitHub), which is simple and published under the commercial-friendly Apache 2.0 license, as discussed in a similar question.It, too, requires a command-line argument to the java interpreter if you want to measure memory byte consumption, but otherwise seems to work just fine, at least in the scenarios I have used it.Without having to mess with instrumentation and so on, and if you don\'t need to know the byte-exact size of an object, you could go with the following approach:This way you read the used memory before and after, and calling the GC just before getting the used memory you lower the "noise" almost to 0.For a more reliable result you can run your job n times, and then divide the used memory by n, obtaining how much memory one run takes. Even more, you can run the whole thing more times and make an average.I wrote a quick test once to estimate on the fly:General concept is allocate objects and measure change in free heap space. The key being getFreeMemory(), which requests GC runs and waits for the reported free heap size to stabilize. The output of the above is:Which is what we expect, given alignment behavior and possible heap block header overhead.The instrumentation method detailed in the accepted answer here the most accurate. The method I described is accurate but only under controlled conditions where no other threads are creating/discarding objects.Here is a utility I made using some of the linked examples to handle 32-bit, 64-bit and 64-bit with compressed OOP. It uses sun.misc.Unsafe.It uses Unsafe.addressSize() to get the size of a native pointer and Unsafe.arrayIndexScale( Object[].class ) for the size of a Java reference.It uses the field offset of a known class to work out the base size of an object.There isn\'t a method call, if that\'s what you\'re asking for. With a little research, I suppose you could write your own. A particular instance has a fixed sized derived from the number of references and primitive values plus instance bookkeeping data. You would simply walk the object graph. The less varied the row types, the easier.If that\'s too slow or just more trouble than it\'s worth, there\'s always good old-fashioned  row counting rule-of-thumbs.I recommend the java-sizeof library for carrotsearch. It is very simple.You can get it in maven:It is only one code line  that return the bytes of an object:You can see the source code at https://github.com/dweiss/java-sizeofAnd there is a presentation from the author of the library http://www.slideshare.net/DawidWeiss/sizeofobject-how-much-memory-objects-take-on-jvms-and-when-this-may-matter?ref=http://cheremin.blogspot.com/2012/05/how-much-memory-objects-take-on-jvm-and.htmlsize gives you the increase in memory usage of the jvm due to object creation and that typically is the size of the object.My answer is based on the code supplied by Nick. That code measures total amount of bytes which are occupied by the serialized object. So this actually measures serialization stuff + plain object memory footprint (just serialize for example int and you will see that total amount of serialized bytes is not 4). So if you want to get raw byte number used exactly for your object - you need to modify that code a bit. Like so:I\'ve tested this solution with primitive types, String, and on some trivial classes. There may be not covered cases also.UPDATE: Example modified to support memory footprint calculation of array objects.This answer is not related to Object size, but when you are using array to accommodate the objects; how much memory size it will allocate for the object.So arrays, list, or map all those collection won\'t be going to store objects really (only at the time of primitives, real object memory size is needed), it will store only references for those objects. Now the Used heap memory = sizeOfObj + sizeOfRef (* 4 bytes) in collectionPRIMITIVESOBJECTSI mean to say all the object REFERENCE needs only 4 bytes of memory. It may be String reference OR Double object reference, But depends on object creation the memory needed will vary.e.g) If i create object for the below class ReferenceMemoryTest then 4 + 4 + 4 = 12 bytes of memory will be created. The memory may differ when you are trying to initialize the references.So when are creating object/reference array, all its contents will be occupied with NULL references. And we know each reference requires 4 bytes.And finally, memory allocation for the below code is 20 bytes.ReferenceMemoryTest ref1 = new ReferenceMemoryTest(); ( 4(ref1) + 12 = 16 bytes)\nReferenceMemoryTest ref2 = ref1;                      ( 4(ref2) + 16 = 20 bytes)You could generate a heap dump (with jmap, for example) and then analyze the output to find object sizes.  This is an offline solution, but you can examine shallow and deep sizes, etc.I doubt you want to do it programmatically unless you just want to do it once and store it for future use.  It\'s a costly thing to do.  There\'s no sizeof() operator in Java, and even if there was, it would only count the cost of the references to other objects and the size of the primitives.One way you could do it is to serialize the thing to a File and look at the size of the file, like this:Of course, this assumes that each object is distinct and doesn\'t contain non-transient references to anything else.Another strategy would be to take each object and examine its members by reflection and add up the sizes (boolean & byte = 1 byte, short & char = 2 bytes, etc.), working your way down the membership hierarchy.  But that\'s tedious and expensive and ends up doing the same thing the serialization strategy would do.