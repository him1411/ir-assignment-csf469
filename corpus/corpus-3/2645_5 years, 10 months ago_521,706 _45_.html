I have a data.frame and some columns have NA values. I want to replace the NAs with zeros. How I do this?See my comment in @gsk3 answer. A simple example:There\'s no need to apply apply. =)EDITYou should also take a look at norm package. It has a lot of nice features for missing data analysis. =)For a single vector:For a data.frame, make a function out of the above, then apply it to the columns.Please provide a reproducible example next time as detailed here:How to make a great R reproducible example?dplyr example:I know the question is already answered, but doing it this way might be more useful to some:Define this function:Now whenever you need to convert NA\'s in a vector to zero\'s you can do:dplyr\'\'s mutate_all() reduces processing times by half - and the simpler syntax helps keep cerebral RAM available for your statistical and scientific endeavors.mutate_all(funs(coalesce(., 0L))) is now the speediest and most concise option;though the old replace hybrid offers nearly as strong an option:\n  mutate_all(funs(replace(., is.na(.), 0))))(If you are having difficulty getting the integer only coalesce option to zip over all your columns - you might elect to use the conditionally enhanced mutate_if(is.integer, funs(coalesce(., 0L))) instead.)microbenchmark results dataframe:Simple boxplot of results:A ggplot2 quickplot logplot: with special thanks to Tyler Rinker: https://www.r-bloggers.com/microbenchmarking-with-r/\n    and akrun: https://stackoverflow.com/a/41530071/5088194 and\nalexis_laz for helping me understand the use of the local() to keep the original dataframe untouched (and allow the subsetting operation to be compared on a level playing field.)Additionally, as alexis_laz points out here, you could reduce your processing times further by working with integers where possible. i.e.: making replacements with 0L can speed things up over a replacement with 0.Note: while Tidyr\'\'s replace_na is technically the fastest by a nose, it requires the hard coding in of all the variable names.\nIn similar fashion, mutate_at often comes in just a hair ahead of the rest of the mutate_at/all pack, but is a bit more fastidious about replacement value assignments.Good examples for the _at and _all function variants can be found here: https://rdrr.io/cran/dplyr/man/summarise_all.htmlAdditionally, I found this to be a well made summary of the new & improved functions that arrived with dplyr(0.5.0): https://blog.exploratory.io/dplyr-0-5-is-awesome-heres-why-be095fd4eb8aif you\'re trying to replace NAs when writing to csv, you can use:More general approach of using replace() in matrix or vector to replace NA to 0For example:This is also an alternative to using ifelse() in dplyrWith dplyr 0.5.0, you can use coalesce function which can be easily integrated into %>% pipeline by doing coalesce(vec, 0). This replaces all NAs in vec with 0:Say we have a data frame with NAs:If you want to replace NAs in factor variables, this might be useful:It transforms a factor-vector into a numeric vector and adds another artifical numeric factor level, which is then transformed back to a factor-vector with one extra "NA-level" of your choice.Would\'ve commented on @ianmunoz\'s post but I don\'t have enough reputation.  You can combine dplyr\'s mutate_each and replace to take care of the NA to 0 replacement.  Using the dataframe from @aL3xa\'s answer...We\'re using standard evaluation (SE) here which is why we need the underscore on "funs_."  We also use lazyeval\'s interp/~ and the . references "everything we are working with", i.e. the data frame.  Now there are zeros!Another example using imputeTS package:You can use replace()For example:Another dplyr pipe compatible option with tidyrmethod replace_na that works for several columns:You can easily restrict to e.g. numeric columns:This simple function extracted from Datacamp could help:Then