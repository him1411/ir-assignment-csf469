Why or why not?For performance, especially when you\'re iterating over a large range, xrange() is usually better.  However, there are still a few cases why you might prefer range():In python 3, range() does what xrange() used to do and xrange() does not exist.  If you want to write code that will run on both Python 2 and Python 3, you can\'t use xrange().range() can actually be faster in some cases - eg. if iterating over the same sequence multiple times.  xrange() has to reconstruct the integer object every time, but range() will have real integer objects.  (It will always perform worse in terms of memory however)xrange() isn\'t usable in all cases where a real list is needed.  For instance, it doesn\'t support slices, or any list methods.[Edit] There are a couple of posts mentioning how range() will be upgraded by the 2to3 tool.  For the record, here\'s the output of running the tool on some sample usages of range() and xrange()As you can see, when used in a for loop or comprehension, or where already wrapped with list(), range is left unchanged.No, they both have their uses:Use xrange() when iterating, as it saves memory.  Say:rather than:On the other hand, use range() if you actually want a list of numbers.You should favour range() over xrange() only when you need an actual list. For instance, when you want to modify the list returned by range(), or when you wish to slice it. For iteration or even just normal indexing, xrange() will work fine (and usually much more efficiently). There is a point where range() is a bit faster than xrange() for very small lists, but depending on your hardware and various other details, the break-even can be at a result of length 1 or 2; not something to worry about. Prefer xrange().One other difference is that xrange() can\'t support numbers bigger than C ints, so if you want to have a range using python\'s built in large number support, you have to use range().  Python 3 does not have this problem:xrange() is more efficient because instead of generating a list of objects, it just generates one object at a time. Instead of 100 integers, and all of their overhead, and the list to put them in, you just have one integer at a time. Faster generation, better memory use, more efficient code.Unless I specifically need a list for something, I always favor xrange()range() returns a list, xrange() returns an xrange object.xrange() is a bit faster, and a bit more memory efficient. But the gain is not very large.The extra memory used by a list is of course not just wasted, lists have more functionality (slice, repeat, insert, ...). Exact differences can be found in the documentation. There is no bonehard rule, use what is needed.Python 3.0 is still in development, but IIRC range() will very similar to xrange() of 2.X and list(range()) can be used to generate lists.I would just like to say that it REALLY isn\'t that difficult to get an xrange object with slice and indexing functionality.  I have written some code that works pretty dang well and is just as fast as xrange for when it counts (iterations).Honestly, I think the whole issue is kind of silly and xrange should do all of this anyway...Go with range for these reasons:1) xrange will be going away in newer Python versions.  This gives you easy future compatibility.2) range will take on the efficiencies associated with xrange.A good example given in book: Practical Python By Magnus Lie Hetland I wouldn\xe2\x80\x99t recommend using range instead of xrange in the preceding example\xe2\x80\x94although\nonly the first five numbers are needed, range calculates all the numbers, and that may take a lot\nof time. With xrange, this isn\xe2\x80\x99t a problem because it calculates only those numbers needed.Yes I read @Brian\'s answer: In python 3, range() is a generator anyway and xrange() does not exist.Okay, everyone here as a different opinion as to the tradeoffs and advantages of xrange versus range.  They\'re mostly correct, xrange is an iterator, and range fleshes out and creates an actual list.  For the majority of cases, you won\'t really notice a difference between the two.  (You can use map with range but not with xrange, but it uses up more memory.)What I think you rally want to hear, however, is that the preferred choice is xrange.  Since range in Python 3 is an iterator, the code conversion tool 2to3 will correctly convert all uses of xrange to range, and will throw out an error or warning for uses of range.  If you want to be sure to easily convert your code in the future, you\'ll use xrange only, and list(xrange) when you\'re sure that you want a list.  I learned this during the CPython sprint at PyCon this year (2008) in Chicago.range() does the same thing as xrange() used to do in Python 3 and there is not term xrange() exist in Python 3.\nrange() can actually be faster in some scenario if you iterating over the same sequence multiple times. xrange() has to reconstruct the integer object every time, but range() will have real integer objects.While xrange is faster than range in most circumstances, the difference in performance is pretty minimal. The little program below compares iterating over a range and an xrange:The results below shows that xrange is indeed faster, but not enough to sweat over.So by all means use xrange, but unless you\'re on a constrained hardware, don\'t worry too much about it.