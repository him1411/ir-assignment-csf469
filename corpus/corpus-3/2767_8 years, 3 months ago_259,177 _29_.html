In an Android app, is there anything wrong with the following approach:and pass it everywhere (e.g. SQLiteOpenHelper) where context is required (and not leaking of course)?There are a couple of potential problems with this approach, though in a lot of circumstances (such as your example) it will work well.In particular you should be careful when dealing with anything that deals with the GUI that requires a Context. For example, if you pass the application Context into the LayoutInflater you will get an Exception. Generally speaking, your approach is excellent: it\'s good practice to use an Activity\'s Context within that Activity, and the Application Context when passing a context beyond the scope of an Activity to avoid memory leaks.Also, as an alternative to your pattern you can use the shortcut of calling getApplicationContext() on a Context object (such as an Activity) to get the Application Context.In my experience this approach shouldn\'t be necessary.  If you need the context for anything you can usually get it via a call to View.getContext() and using the Context obtained there you can call Context.getApplicationContext() to get the Application context.  If you are trying to get the Appication context this from an Activity you can always call Activity.getApplication() which should be able to be passed as the Context needed for a call to SQLiteOpenHelper()Overall there doesn\'t seem to be a problem with your approach for this situation, but when dealing with Context just make sure you are not leaking memory anywhere as described on the official Google Android Developers blogSome people have asked: how can the singleton return a null pointer?\nI\'m answering that question. (I cannot answer in a comment because I need to post code.)It may return null in between two events: (1) the class is loaded, and (2) the object of this class is created. Here\'s an example:Let\'s run the code:The second line shows that Y.xinstance and X.yinstance are null; they are null because the variables X.xinstance ans Y.yinstance were read when they were null.Can this be fixed? Yes,and this code shows no anomaly:BUT this is not an option for the Android Application object: the programmer does not control the time when it is created.Once again: the difference between the first example and the second one is that the second example creates an instance if the static pointer is null. But a programmer cannot create the Android application object before the system decides to do it.You are trying to create a wrapper to get Application Context and there is a possibility that it might return "null" pointer.As per my understanding, I guess its better approach to call- any of the 2\nContext.getApplicationContext()  or Activity.getApplication().Application Class:Declare the Application in the AndroidManifest:Usage:It is a good approach. I use it myself as well. I would only suggest to override onCreate to set the singleton instead of using a constructor.And since you mentioned SQLiteOpenHelper: In onCreate () you can open the database as well.Personally I think the documentation got it wrong in saying that There is normally no need to subclass Application. I think the opposite is true: You should always subclass Application.I would use Application Context to get a System Service in the constructor. This eases testing & benefits from compositionTest class would then use the overloaded constructor.Android would use the default constructor.I like it, but I would suggest a singleton instead:I\'m using the same approach, I suggest to write the singleton a little better:but I\'m not using everywhere, I use getContext() and getApplicationContext() where I can do it!