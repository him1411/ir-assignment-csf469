Several months ago I learned from an answer on Stack Overflow how to perform multiple updates at once in MySQL using the following syntax:I\'ve now switched over to PostgreSQL and apparently this is not correct. It\'s referring to all the correct tables so I assume it\'s a matter of different keywords being used but I\'m not sure where in the PostgreSQL documentation this is covered.To clarify, I want to insert several things and if they already exist to update them.PostgreSQL since version 9.5 has UPSERT syntax, with ON CONFLICT clause. with the following syntax (similar to MySQL)Searching postgresql\'s email group archives for "upsert" leads to finding an example of doing what you possibly want to do, in the manual:Example 38-2. Exceptions with UPDATE/INSERTThis example uses exception handling to perform either UPDATE or INSERT, as appropriate:There\'s possibly an example of how to do this in bulk, using CTEs in 9.1 and above, in the hackers mailing list:See a_horse_with_no_name\'s answer for a clearer example.Warning: this is not safe if executed from multiple sessions at the same time (see caveats below).Another clever way to do an "UPSERT" in postgresql is to do two sequential UPDATE/INSERT statements that are each designed to succeed or have no effect.The UPDATE will succeed if a row with "id=3" already exists, otherwise it has no effect.The INSERT will succeed only if row with "id=3" does not already exist.You can combine these two into a single string and run them both with a single SQL statement execute from your application.  Running them together in a single transaction is highly recommended.This works very well when run in isolation or on a locked table, but is subject to race conditions that mean it might still fail with duplicate key error if a row is inserted concurrently, or might terminate with no row inserted when a row is deleted concurrently. A SERIALIZABLE transaction on PostgreSQL 9.1 or higher will handle it reliably at the cost of a very high serialization failure rate, meaning you\'ll have to retry a lot. See why is upsert so complicated, which discusses this case in more detail.This approach is also subject to lost updates in read committed isolation unless the application checks the affected row counts and verifies that either the insert or the update affected a row.With PostgreSQL 9.1 this can be achieved using a writeable CTE (common table expression):See these blog entries:Note that this solution does not prevent a unique key violation but it is not vulnerable to lost updates.\nSee the follow up by Craig Ringer on dba.stackexchange.comIn PostgreSQL 9.5 and newer you can use INSERT ... ON CONFLICT UPDATE.See the documentation.A MySQL INSERT ... ON DUPLICATE KEY UPDATE can be directly rephrased to a ON CONFLICT UPDATE. Neither is SQL-standard syntax, they\'re both database-specific extensions. There are good reasons MERGE wasn\'t used for this, a new syntax wasn\'t created just for fun. (MySQL\'s syntax also has issues that mean it wasn\'t adopted directly).e.g. given setup:the MySQL query:becomes:Differences:You must specify the column name (or unique constraint name) to use for the uniqueness check. That\'s the ON CONFLICT (columnname) DOThe keyword SET must be used, as if this was a normal UPDATE statementIt has some nice features too:You can have a WHERE clause on your UPDATE (letting you effectively turn ON CONFLICT UPDATE into ON CONFLICT IGNORE for certain values)The proposed-for-insertion values are available as the row-variable EXCLUDED, which has the same structure as the target table. You can get the original values in the table by using the table name. So in this case EXCLUDED.c will be 10 (because that\'s what we tried to insert) and "table".c will be 3 because that\'s the current value in the table. You can use either or both in the SET expressions and WHERE clause.For background on upsert see How to UPSERT (MERGE, INSERT ... ON DUPLICATE UPDATE) in PostgreSQL?i was looking for the same thing when i came here, but the lack of a generic "upsert" function botherd me a bit so i thought you could just pass the update and insert sql as arguments on that function form the manualthat would look like this:and perhaps to do what you initially wanted to do, batch "upsert", you could use Tcl to split the sql_update and loop the individual updates, the preformance hit will be very small see http://archives.postgresql.org/pgsql-performance/2006-04/msg00557.phpthe highest cost is executing the query from your code, on the database side the execution cost is much smallerThere is no simple command to do it.The most correct approach is to use function, like the one from docs.Another solution (although not that safe) is to do update with returning, check which rows were updates, and insert the rest of themSomething along the lines of:assuming id:2 was returned:Of course it will bail out sooner or later (in concurrent environment), as there is clear race condition in here, but usually it will work.Here\'s a longer and more comprehensive article on the topic.Personally, I\'ve set up a "rule" attached to the insert statement. Say you had a "dns" table that recorded dns hits per customer on a per-time basis:You wanted to be able to re-insert rows with updated values, or create them if they didn\'t exist already. Keyed on the customer_id and the time. Something like this:Update: This has the potential to fail if simultaneous inserts are happening, as it will generate unique_violation exceptions. However, the non-terminated transaction will continue and succeed, and you just need to repeat the terminated transaction.However, if there are tons of inserts happening all the time, you will want to put a table lock around the insert statements: SHARE ROW EXCLUSIVE locking will prevent any operations that could insert, delete or update rows in your target table. However, updates that do not update the unique key are safe, so if you no operation will do this, use advisory locks instead.Also, the COPY command does not use RULES, so if you\'re inserting with COPY, you\'ll need to use triggers instead.I custom "upsert" function above, if you want to INSERT AND REPLACE :`    And after to execute, do something like this : Is important to put double dollar-comma to avoid compiler errorsI have the same issue for managing account settings as name value pairs.\nThe design criteria is that different clients could have different settings sets.My solution, similar to JWP  is to bulk erase and replace, generating the merge record within your application.This is pretty bulletproof, platform independent and since there are never more than about 20 settings per client, this is only 3 fairly low load db calls - probably the fastest method.The alternative of updating individual rows - checking for exceptions then inserting - or some combination of is hideous code, slow and often breaks because (as mentioned above) non standard SQL exception handling changing from db to db - or even release to release.Similar to most-liked answer, but works slightly faster:(source: http://www.the-art-of-web.com/sql/upsert/)UPDATE will return the number of modified rows. If you use JDBC (Java), you can then check this value against 0 and, if no rows have been affected, fire INSERT instead. If you use some other programming language, maybe the number of the modified rows still can be obtained, check documentation. This may not be as elegant but you have much simpler SQL that is more trivial to use from the calling code. Differently, if you write ten line script in PL/PSQL, you probably should have unit test of one or another kind just for it.I use this function mergeAccording the PostgreSQL documentation of the INSERT statement, handling the ON DUPLICATE KEY case is not supported. That part of the syntax is a proprietary MySQL extension.Edit: This does not work as expected.  Unlike the accepted answer, this produces unique key violations when two processes repeatedly call upsert_foo concurrently.Eureka!  I figured out a way to do it in one query: use UPDATE ... RETURNING to test if any rows were affected:The UPDATE has to be done in a separate procedure because, unfortunately, this is a syntax error:Now it works as desired:For merging small sets, using the above function is fine. However, if you are merging large amounts of data, I\'d suggest looking into http://mbk.projects.postgresql.orgThe current best practice that I\'m aware of is: