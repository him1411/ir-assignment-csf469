I\'ve heard that the static_cast function should be preferred to C-style or simple function-style casting.  Is this true?  Why?The main reason is that classic C casts make no distinction between what we call static_cast<>(), reinterpret_cast<>(), const_cast<>(), and dynamic_cast<>(). These four things are completely different.A static_cast<>() is usually safe. There is a valid conversion in the language, or an appropriate constructor that makes it possible. The only time it\'s a bit risky is when you cast down to an inherited class; you must make sure that the object is a actually the descendant that you claim it is, by means external to the language (like a flag in the object). A dynamic_cast<>() is safe as long as the result is checked (pointer) or a possible exception is taken into account (reference). A reinterpret_cast<>() (or a const_cast<>()) on the other hand is always dangerous. You tell the compiler: "trust me: I know this doesn\'t look like a foo (this looks as if it isn\'t mutable), but it is". The first problem is that it\'s almost impossible to tell which one will occur in a C-style cast without looking at large and disperse pieces of code and knowing all the rules.Let\'s assume these:Now, these two are compiled the same way:However, let\'s see this almost identical code:As you can see, there is no easy way to distinguish between the two situations without knowing a lot about all the classes involved.The second problem is that the C-style casts are too hard to locate. In complex expressions it can be very hard to see C-style casts. It is virtually impossible to write an automated tool that needs to locate C-style casts (for example a search tool) without a full blown C++ compiler front-end. On the other hand, it\'s easy to search for "static_cast<" or "reinterpret_cast<".That means that, not only are C-style casts more dangerous, but it\'s a lot harder to find them all to make sure that they are correct.One pragmatic tip: you can search easily for the static_cast keyword in your source code if you plan to tidy up the project.In short:More Explanation:The static cast performs conversions between compatible types. It\n  is similar to the C-style cast, but is more restrictive. For example,\n  the C-style cast would allow an integer pointer to point to a char.Since this results in a 4-byte pointer pointing to 1 byte of allocated\n  memory, writing to this pointer will either cause a run-time error or\n  will overwrite some adjacent memory.In contrast to the C-style cast, the static cast will allow the\n  compiler to check that the pointer and pointee data types are\n  compatible, which allows the programmer to catch this incorrect\n  pointer assignment during compilation.Read more on:\nWhat is the difference between static_cast<> and C style casting \nand\nRegular cast vs. static_cast vs. dynamic_cast  The question is bigger than just using wither static_cast or C style casting because there are different things that happen when using C style casts.  The C++ casting operators are intended to make these operations more explicit.On the surface static_cast and C style casts appear to the same thing, for example when casting one value to another:Both of these cast the integer value to a double.  However when working with pointers things get more complicated.  some examples:In this example (1) maybe OK because the object pointed to by A is really an instance of B.  But what if you don\'t know at that point in code what a actually points to?  (2) maybe perfectly legal(you only want to look at one byte of the integer), but it could also be a mistake in which case an error would be nice, like (3).  The C++ casting operators are intended to expose these issues in the code by providing compile-time or run-time errors when possible.So, for strict "value casting" you can use static_cast.  If you want run-time polymorphic casting of pointers use dynamic_cast.  If you really want to forget about types, you can use reintrepret_cast.  And to just throw const out the window there is const_cast.They just make the code more explicit so that it looks like you know what you were doing.static_cast means that you can\'t accidentally const_cast or reinterpret_cast, which is a good thing.See Effective C++ IntroductionIt\'s about how much type-safety you want to impose.When you write (bar) foo (which is equivalent to reinterpret_cast<bar> foo if you haven\'t provided a type conversion operator) you are telling the compiler to ignore type safety, and just do as it\'s told.When you write static_cast<bar> foo you are asking the compiler to at least check that the type conversion makes sense and, for integral types, to insert some conversion code.EDIT 2014-02-26I wrote this answer more than 5 years ago, and I got it wrong. (See comments.) But it still gets upvotes!static_cast, aside from manipulating pointers to classes, can also be used to perform conversions explicitly defined in classes, as well as to perform standard conversions between fundamental types:C Style casts are easy to miss in a block of code. C++ style casts are not only better practice; they offer a much greater degree of flexibility.reinterpret_cast allows integral to pointer type conversions, however can be unsafe if misused.static_cast offers good conversion for numeric types e.g. from as enums to ints or ints to floats or any data types you are confident of type. It does not perform any run time checks.dynamic_cast on the other hand will perform these checks flagging any ambiguous assignments or conversions. It only works on pointers and references and incurs an overhead.There are a couple of others but these are the main ones you will come across.