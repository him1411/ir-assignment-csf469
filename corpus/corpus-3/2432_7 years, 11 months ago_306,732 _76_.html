How to I find and replace every occurrence of:with in every text file under the /home/www/ directory tree (recursive find/replace).Note: Do not run this command on a folder including a git repo - changes to .git could corrupt your git index.From man find:-print0   (GNU find  only) tells find to use the null character (\\0) instead of whitespace as the output delimiter between pathnames found.  This is a safer option if you files can contain blanks or other special character.  It is recommended to use the -print0 argument to find if you use -exec command or xargs (the -0 argument is needed in xargs.).Note: Do not run this command on a folder including a git repo - changes to .git could corrupt your git index.Compared to other answers here, this is simpler than most and uses sed instead of perl, which is what the original question asked for.All the tricks are almost the same, but I like this one:find <mydir>: look up in the  directory.-type f: File is of type: regular file-exec command {} +:This variant of the -exec action runs the specified command on the selected files, but the command line is built by appending\n            each  selected  file  name  at  the  end; the total number of invocations of the command will be much less than the number of\n            matched files.  The command line is built in much the same way that xargs builds its command lines.   Only  one  instance  of\n            `{}\' is allowed within the command.  The command is executed in the starting directory.The simplest way for me isFor me the easiest solution to remember is https://stackoverflow.com/a/2113224/565525, i.e.:NOTE: -i \'\' solves OSX problem sed: 1: "...": invalid command code .NOTE: If there are too many files to process you\'ll get Argument list too long. The workaround - use find -exec or xargs solution described above.For anyone using silver searcher (ag)Since ag ignores git/hg/svn file/folders by default, this is safe to run inside a repository.An one nice oneliner as an extra. Using git grep. This one is compatible with git repositories, and a bit simpler:Linux:Mac:(Thanks to http://blog.jasonmeridth.com/posts/use-git-grep-to-replace-strings-in-files-in-your-git-repository/)I just needed this and was not happy with the speed of the available examples. So I came up with my own:Ack-grep is very efficient on finding relevant files. This command replaced ~145 000 files with a breeze whereas others took so long I couldn\'t wait until they finish.find /home/www/ -type f  will list all files in /home/www/ (and its subdirectories).\nThe "-exec" flag tells find to run the following command on each file found.is the command run on the files (many at a time). The {} gets replaced by file names. \nThe + at the end of the command tells find to build one command for many filenames.Per the find man page: \n"The command line is built in much the same way that\nxargs builds its command lines."Thus it\'s possible to achieve your goal (and handle filenames containing spaces) without using xargs -0, or -print0.Try this:grep -lr \'subdomainA.example.com\' | while read file; do sed -i "s/subdomainA.example.com/subdomainB.example.com/g" "$file"; doneI guess most people don\'t know that they can pipe something into a "while read file" and it avoids those nasty -print0 args, while presevering spaces in filenames.Further adding an echo before the sed allows you to see what files will change before actually doing it.If you do not mind using vim together with grep or find tools, you could follow up the answer given by user Gert in this link --> How to do a text replacement in a big folder hierarchy?.Here\'s the deal:recursively grep for the string that you want to replace in a certain path, and take only the complete path of the matching file. (that would be the $(grep \'string\' \'pathname\' -Rl).(optional) if you want to make a pre-backup of those files on centralized directory maybe you can use this also: cp -iv $(grep \'string\' \'pathname\' -Rl) \'centralized-directory-pathname\'after that you can edit/replace at will in vim following a scheme similar to the one provided on the link given:For Qshell (qsh) on IBMi, not bash as tagged by OP.Limitations of qsh commands:Thus the solution in qsh:Caveats:If you wanted to use this without completely destroying your SVN repository, you can tell \'find\' to ignore all hidden files by doing:Using combination of grep and sedYou can use awk to solve this as below,hope this will help you !!!A bit old school but this worked on OS X.There are few trickeries:\xe2\x80\xa2 Will only edit files with extension .sls under the current directory\xe2\x80\xa2 . must be escaped to ensure sed does not evaluate them as "any character"\xe2\x80\xa2 , is used as the sed delimiter instead of the usual /Also note this is to edit a Jinja template to pass a variable in the path of an import (but this is off topic).First, verify your sed command does what you want (this will only print the changes to stdout, it will not change the files):Edit the sed command as needed, once you are ready to make changes:Note the -i \'\' in the sed command, I did not want to create a backup of the original files (as explained in In-place edits with sed on OS X or in Robert Lujo\'s comment in this page).Happy seding folks!To cut down on files to recursively sed through, you could grep for your string instance:If you run man grep you\'ll notice you can also define an --exlude-dir="*.git" flag if you want to omit searching through .git directories, avoiding git index issues as others have politely pointed out.Leading you to:A simpler way is to use the below on the command lineThis is the best all around solution I\'ve found for OSX and Windows (msys2).  Should work with anything that can get the gnu version of sed.  Skips the .git directories so it won\'t corrupt your checksums.On mac, just install coreutils first and ensure gsed is in the path -Then I stick this function in my zshrc/bashrc ->To replace all content matching string_1 with string_2 of all .c and .h files in the current directory and subdirectories (excluding .git/).This works on Mac:This should work on Linux (Have not tested yet):If you have access to node you can do a npm install -g rexreplace and thenFor replace all occurrences in a git repository you can use:See List files in local git repo? for other options to list all files in a repository. The -z options tells git to separate the file names with a zero byte, which assures that xargs (with the option -0) can separate filenames, even if they contain spaces or whatnot.just to avoid to change alsobut still (maybe not good in the idea behind domain root)to change multiple files (and saving a backup as *.bak):will take all files in directory and replace \xe2\x80\x9c|\xe2\x80\x9d with x\ncalled a \xe2\x80\x9cPerl pie\xe2\x80\x9d (easy as a pie)