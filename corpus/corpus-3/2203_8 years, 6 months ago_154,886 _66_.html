Today I needed a simple algorithm for checking if a number is a power of 2.The algorithm needs to be:I came up with this simple algorithm:But then I thought, how about checking if log2 x is an exactly round number? But when I checked for 2^63+1, Math.Log returned exactly 63 because of rounding. So I checked if 2 to the power 63 is equal to the original number - and it is, because the calculation is done in doubles and not in exact numbers:This returned true for the given wrong value: 9223372036854775809.Is there a better algorithm?There\'s a simple trick for this problem:Note, this function will report true for 0, which is not a power of 2. If you want to exclude that, here\'s how:First and foremost the bitwise binary & operator from MSDN definition:Binary & operators are predefined for the integral types and bool. For\n  integral types, & computes the logical bitwise AND of its operands.\n  For bool operands, & computes the logical AND of its operands; that\n  is, the result is true if and only if both its operands are true.Now let\'s take a look at how this all plays out:The function returns boolean (true / false) and accepts one incoming parameter of type unsigned long (x, in this case).  Let us for the sake of simplicity assume that someone has passed the value 4 and called the function like so:Now we replace each occurrence of x with 4:Well we already know that 4 != 0 evals to true, so far so good.  But what about:This translates to this of course:But what exactly is 4&3?The binary representation of 4 is 100 and the binary representation of 3 is 011 (remember the & takes the binary representation of these numbers.  So we have:Imagine these values being stacked up much like elementary addition. The & operator says that if both values are equal to 1 then the result is 1, otherwise it is 0. So 1 & 1 = 1, 1 & 0 = 0, 0 & 0 = 0, and 0 & 1 = 0. So we do the math:The result is simply 0. So we go back and look at what our return statement now translates to:Which translates now to:We all know that true && true is simply true, and this shows that for our example, 4 is a power of 2.Some sites that document and explain this and other bit twiddling hacks are:And the grandaddy of them, the book "Hacker\'s Delight" by Henry Warren, Jr.:As Sean Anderson\'s page explains, the expression ((x & (x - 1)) == 0) incorrectly indicates that 0 is a power of 2.  He suggests to use:to correct that problem.return (i & -i) == iI wrote an article about this recently at http://www.exploringbinary.com/ten-ways-to-check-if-an-integer-is-a-power-of-two-in-c/.  It covers bit counting, how to use logarithms correctly, the classic "x && !(x & (x - 1))" check, and others.Here\'s a simple C++ solution:And here\'s a general algorithm for finding out if a number is a power of another number.After posting the question I thought of the following solution:We need to check if exactly one of the binary digits is one. So we simply shift the number right one digit at a time, and return true if it equals 1. If at any point we come by an odd number ((number & 1) == 1), we know the result is false. This proved (using a benchmark) slightly faster than the original method for (large) true values and much faster for false or small values.Of course, Greg\'s solution is much better.The following explanation to the accepted answer might be useful for some people:A power of two, when expressed in binary, will always look like 1 followed by n zeroes where n is greater than or equal to 0. Ex:and so on.When we subtract 1 from these kind of numbers, they become 0 followed by n ones and again n is same as above. Ex:and so on.Coming to the crux What happens when we do a bitwise AND of a number x, which is a\n  power of 2, and x - 1?The one of x gets aligned with the zero of x - 1 and all the zeroes of x get aligned with ones of x - 1, causing the bitwise AND to result in 0. And that is how we have the single line answer mentioned above being right.So, we have a property at our disposal now:When we subtract 1 from any number, then in the binary representation\n  the rightmost 1 will become 0 and all the zeroes before that rightmost\n  1 will now become 1One awesome use of this property is in finding out - How many 1s are present in the binary representation of a given number? The short and sweet code to do that for a given integer x is:Another aspect of numbers that can be proved from the concept explained above is "Can every positive number be represented as the sum of powers of 2?".Yes, every positive number can be represented as the sum of powers of 2. For any number, take its binary representation. Ex: Take number 501.Find if the given number is a power of 2. This is really fast. It takes about 6 minutes and 43 seconds to check all 2^32 integers.If x is a power of two, its lone 1 bit is in position n. This means x \xe2\x80\x93 1 has a 0 in position n. To see why, recall how a binary subtraction works. When subtracting 1 from x, the borrow propagates all the way to position n; bit n becomes 0 and all lower bits become 1. Now, since x has no 1 bits in common with x \xe2\x80\x93 1, x & (x \xe2\x80\x93 1) is 0, and !(x & (x \xe2\x80\x93 1)) is true.A number is a power of 2 if it contains only 1 set bit. We can use this property and the generic function countSetBits to find if a number is power of 2 or not.This is a C++ program:We dont need to check explicitly for 0 being a Power of 2, as it returns False for 0 as well.OUTPUTHere is another method I devised, in this case using | instead of & :Improving the answer of @user134548, without bits arithmetic:This works fine for:ExampleAlgorithmUsing a bit mask, divide NUM the variable in binaryIF R > 0 AND L > 0: Return FALSEOtherwise, NUM becomes the one that is non-zeroIF NUM = 1: Return TRUEOtherwise, go to Step 1ComplexityTime ~ O(log(d)) where d is number of binary digitsfor any power of 2, the following also holds.NOTE: fails for n=0 , so need to check for it\nReason why this works is:\n-n is the 2s complement of n. -n will have every bit to the left of rightmost set bit of n flipped compared to n. For powers of 2 there is only one set bit.