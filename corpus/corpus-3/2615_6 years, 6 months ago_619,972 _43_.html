I\'ve got a problem sending a file to a serverside PHP-script using jQuery\'s ajax-function.\nIt\'s possible to get the File-List with $(\'#fileinput\').attr(\'files\') but how is it possible to send this Data to the server? The resulting array ($_POST) on the serverside php-script is 0 (NULL) when using the file-input.I know it is possible (though I didn\'t find any jQuery solutions until now, only Prototye code (http://webreflection.blogspot.com/2009/03/safari-4-multiple-upload-with-progress.html)).This seems to be relatively new, so please do not mention file upload would be impossible via XHR/Ajax, because it\'s definitely working.I need the functionality in Safari 5, FF and Chrome would be nice but are not essential.My code for now is:Starting with Safari 5/Firefox 4, it\xe2\x80\x99s easiest to use the FormData class:So now you have a FormData object, ready to be sent along with the XMLHttpRequest.It\xe2\x80\x99s imperative that you set the contentType option to false, forcing jQuery not to add a Content-Type header for you, otherwise, the boundary string will be missing from it.\nAlso, you must leave the processData flag set to false, otherwise, jQuery will try to convert your FormData into a string, which will fail.You may now retrieve the file in PHP using:(There is only one file, file-0, unless you specified the multiple attribute on your file input, in which case, the numbers will increment with each file.)Using the FormData emulation for older browsersCreate FormData from an existing formInstead of manually iterating the files, the FormData object can also be created with the contents of an existing form object:Use a PHP native array instead of a counterJust name your file elements the same and end the name in brackets:$_FILES[\'file\'] will then be an array containing the file upload fields for every file uploaded. I actually recommend this over my initial solution as it\xe2\x80\x99s simpler to iterate over.I\'ve just build this function based on some info I read.Use it like using .serialize(), instead just put .serializefiles();.\nWorking here in my tests.Just wanted to add a bit to Raphael\'s great answer. Here\'s how to get PHP to produce the same $_FILES, regardless of whether you use JavaScript to submit.HTML form:PHP produces this $_FILES, when submitted without JavaScript:If you do progressive enhancement, using Raphael\'s JS to submit the files...... this is what PHP\'s $_FILES array looks like, after using that JavaScript to submit:That\'s a nice array, and actually what some people transform $_FILES into, but I find it\'s useful to work with the same $_FILES, regardless if JavaScript was used to submit.  So, here are some minor changes to the JS:(14 April 2017 edit: I removed the form element from the constructor of FormData() -- that fixed this code in Safari.)That code does two things.With these changes, submitting with JavaScript now produces precisely the same $_FILES array as submitting with simple HTML.Look at my code, it does the job for meIf your form is defined in your HTML, it is easier to pass the form into the constructor than it is to iterate and add images.Devin Venable\'s answer was close to what I wanted, but I wanted one that would work on multiple forms, and use the action already specified in the form so that each file would go to the right place.I also wanted to use jQuery\'s on() method so I could avoid using .ready().That got me to this: \n(replace formSelector with your jQuery selector)The FormData class does work, however in iOS Safari (on the iPhone at least) I wasn\'t able to use Raphael Schweikert\'s solution as is.Mozilla Dev has a nice page on manipulating FormData objects.So, add an empty form somewhere in your page, specifying the enctype:Then, create FormData object as:and proceed as in Raphael\'s code.One gotcha I ran into today I think is worth pointing out related to this problem: if the url for the ajax call is redirected then the header for content-type: \'multipart/form-data\' can be lost.For example, I was posting to http://server.com/context?param=xIn the network tab of Chrome I saw the correct multipart header for this request but then a 302 redirect to http://server.com/context/?param=x (note the slash after context)During the redirect the multipart header was lost.  Ensure requests are not being redirected if these solutions are not working for you.As an alternative to AJAX, you could add a hidden iframe in your document, copy your form there and post it (so that no redirection occurs in your visible page). I guess you could delete the iframe afterwards.(HTML and JS are technologies for hackers, not for programmers. You will have to hack your way out of this... It\'s been... God knows how many year of patching and \'evolving\' JS and HTML and you still can\'t do something so simple without using external libs. I\'m sick of it. (I know about HTML5, just it\'s not enough and not widely supported))