In MySQL you can insert multiple rows like this:However, I am getting an error when I try to do something like this. Is it possible to insert multiple rows at a time in an SQLite database? What is the syntax to do that?As BrianCampbell points out here, SQLite 3.7.11 and above now supports the simpler syntax of the original post.  However, the approach shown is still appropriate if you want maximum compatibility across legacy databases.If I had privileges, I would bump andy\'s reply: You can insert multiple rows in SQLite, you just need different syntax.  To make it perfectly clear, the OPs MySQL example:This can be recast into SQLite as:I originally used this technique to efficiently load large datasets from Ruby on Rails.  However, as Jaime Cook points out, it\'s not clear this is any faster wrapping individual INSERTs within a single transaction:If efficiency is your goal, you should try this first.As several people commented, if you use UNION ALL (as shown above), all rows will be inserted, so in this case, you\'d get four rows of data1, data2.  If you omit the ALL, then duplicate rows will be eliminated (and the operation will presumably be a bit slower).  We\'re using UNION ALL since it more closely matches the semantics of the original post.P.S.: Please +1 andy\'s reply, not mine!  He presented the solution first.Yes it is possible, but not with the usual comma-separated insert values.Try this...Yes, it\'s a little ugly but easy enough to automate the generation of the statement from a set of values. Also, it appears you only need to declare the column names in the first select.Yes, as of SQLite 3.7.11 this is supported in SQLite. From the SQLite documentation:(when this answer was originally written, this was not supported)For compatibility with older versions of SQLite, you can use the trick suggested by andy and fearless_fool using UNION, but for 3.7.11 and later the simpler syntax described in here should be preferred.I wrote some ruby code to generate a single 500 element multi-row insert from a series of insert statements which was considerably faster than running the individual inserts. Then I tried simply wrapping the multiple inserts into a single transaction and found that I could get the same kind of speed up with considerably less code. According to this page it is not supported:Actually, according to the SQL92 standard, a VALUES expression should be able to stand on itself. For example, the following should return a one-column table with three rows: VALUES \'john\', \'mary\', \'paul\';As of version 3.7.11 SQLite does support multi-row-insert. Richard Hipp comments:"The new multi-valued insert is merely syntactic suger (sic) for the compound\n  insert.  There is no performance advantage one way or the other."As the other posters have said, SQLite does not support this syntax.  I don\'t know if compound INSERTs are part of the SQL standard, but in my experience they\'re not implemented in many products.As an aside, you should be aware that INSERT performance in SQLite is improved considerably if you wrap multiple INSERTs in an explicit transaction.Yes, sql can do this, but with a different syntax. The sqlite documentation is pretty good, by the way. It will also tell you that the only way to insert several row is use a select statement as the source of the data to be inserted.Sqlite3 can\'t do that directly in SQL except via a SELECT, and while SELECT can return a "row" of expressions, I know of no way to make it return a phony column.However, the CLI can do it:If you do put a loop around an INSERT, rather than using the CLI .import command, then be sure to follow the advice in the sqlite FAQ for INSERT speed:By default, each INSERT statement is\n  its own transaction. But if you\n  surround multiple INSERT statements\n  with BEGIN...COMMIT then all the\n  inserts are grouped into a single\n  transaction. The time needed to commit\n  the transaction is amortized over all\n  the enclosed insert statements and so\n  the time per insert statement is\n  greatly reduced.Another option is to run PRAGMA\n  synchronous=OFF. This command will\n  cause SQLite to not wait on data to\n  reach the disk surface, which will\n  make write operations appear to be\n  much faster. But if you lose power in\n  the middle of a transaction, your\n  database file might go corrupt.Alex is correct: the "select ... union" statement will lose the ordering which is very important for some users.  Even when you insert in a specific order, sqlite changes things so prefer to use transactions if insert ordering is important.fearless_fool has a great answer for older versions. I just wanted to add that you need to make sure you have all the columns listed. So if you have 3 columns, you need to make sure select acts on 3 columns.Example: I have 3 columns but I only want to insert 2 columns worth of data. Assume I don\'t care about the first column because it\'s a standard integer id. I could do the following...Note: Remember the "select ... union" statement will lose the ordering. (From AG1)Start from version 2012-03-20 (3.7.11), sqlite support the following INSERT syntax:Read documentation: http://www.sqlite.org/lang_insert.htmlPS: Please +1 to Brian Campbell\'s reply/answer. not mine! He presented the solution first.You can\'t but I don\'t think you miss anything. Because you call sqlite always in process, it almost doesn\'t matter in performance whether you execute 1 insert statement or 100 insert statements. The commit however takes a lot of time so put those 100 inserts inside a transaction. Sqlite is much faster when you use parameterized queries (far less parsing needed) so I wouldn\'t concatenate big statements like this:They need to be parsed again and again because every concatenated statement is different. in mysql lite you cannot insert multiple values,\nbut you can save time by opening connection only one time and then doing all insertions and then closing connection.\nIt saves a lot of timeThe problem with using transaction is that you lock the table also for reading. So if you have really much data to insert and you need to access to your data, for exemple a preview or so, this way doesn\'t work well.The problem with the other solution is that you lose the order of the insertingIn the sqlite the data will be store a,b,c,d...As of version 3.7.11 SQLite does support multi-row-insert. Richard\n  Hipp comments:I\'m using 3.6.13I command like this:With 50 records inserted at a time, it takes only a second or less.It\'s true using sqlite to insert multiple rows at a time is very possible.  By @Andy wrote.thanks Andy +1If you use the Sqlite manager firefox plugin, it supports bulk inserts from INSERT SQL statements.Infact it doesn\'t support this, but Sqlite Browser does (works on Windows, OS X, Linux)I have a query like below, but with ODBC driver SQLite has an error with "," it says.\nI run vbscript in HTA (Html Application).On sqlite 3.7.2:and so onI am able to make the query dynamic. This is my table: CREATE TABLE "tblPlanner" ("probid" text,"userid" TEXT,"selectedtime" DATETIME,"plannerid" TEXT,"isLocal" BOOL,"applicationid" TEXT, "comment" TEXT, "subject" TEXT)and I\'m getting all data through a JSON, so after getting everything inside an NSArray I followed this:And finally the output query is this:which is running well through code also and I\'m able to save everything in SQLite successfully.Before this i made UNION query stuff dynamic but that started giving some syntax error. Anyways, this is running well for me.you can use InsertHelper, it is easy and fastdocumentation:\nhttp://developer.android.com/reference/android/database/DatabaseUtils.InsertHelper.htmltutorial:\nhttp://www.outofwhatbox.com/blog/2010/12/android-using-databaseutils-inserthelper-for-faster-insertions-into-sqlite-database/Edit:\nInsertHelper is deprecated as of API Level 17I\'m surprised that no one has mentioned prepared statements. Unless you are using SQL on its own and not within any other language, then I would think that prepared statements wrapped in a transaction would be the most efficient way of inserting multiple rows.If you are using bash shell you can use this: Or if you are in sqlite CLI, then you need to do this: How does it work? \nIt makes use of that if table tab: then select a.id, b.id from tab a, tab b returnsand so on. After first execution we insert 2 rows, then 2^3=8. (three because we have tab a, tab b, tab c)After second execution we insert additional (2+8)^3=1000 rowsAftern thrid we insert about max(1000^3, 5e5)=500000 rows and so on...This is the fastest known for me method of populating SQLite database. 