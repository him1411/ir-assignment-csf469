C doesn\'t have any built-in boolean types. What\'s the best way to use them in C?Option 1Option 2Option 3Option 4 (C99)If you are undecided, go with #3!A few thoughts on booleans in C:I\'m old enough that I just use plain ints as my boolean type without any typedefs or special defines or enums for true/false values.  If you follow my suggestion below on never comparing against boolean constants, then you only need to use 0/1 to initialize the flags anyway.  However, such an approach may be deemed too reactionary in these modern times.  In that case, one should definitely use <stdbool.h> since it at least has the benefit of being standardized.Whatever the boolean constants are called, use them only for initialization.  Never ever write something likeThese can always be replaced by the clearer Note that these can actually reasonably and understandably be read out loud.Give your boolean variables positive names, ie full instead of notfull.  The latter leads to code that is difficult to read easily.  ComparewithBoth of the former pair read naturally, while !notfull is awkward to read even as it is, and becomes much worse in more complex boolean expressions.Boolean arguments should generally be avoided.  Consider a function defined like thisWithin in the body of the function, it is very clear what the argument means since it has a convenient, and hopefully meaningful, name.  But, the call sites look likeHere, it\'s essentially impossible to tell what the parameter mean without always looking at the function definition or declaration, and it gets much worse as soon if you add even more boolean parameters..  I suggest eitherorIn either casee, the call site now looks likewhich the reader has at least a chance of understanding without dredging up the definition of foo.A boolean in C is an integer: zero for false and non-zero for true.See also Boolean data type, section C, C++, Objective-C, AWK.Here is the version that I used:Because false only has one value, but a logical true could have many values, but technique sets true to be what the compiler will use for the opposite of false.This takes care of the problem of someone coding something that would come down to this:I think we would all agree that that is not a good practice, but for the one time cost of doing "true = !false" we eliminate that problem.[EDIT] In the end I used:to avoid name collision with other schemes that were defining true and false.  But the concept remains the same.[EDIT] To show conversion of integer to boolean:The first (right most) ! converts the non-zero integer to a 0, then the second (left most) ! converts the 0 to a myfalse value.  I will leave it as an exercise for the reader to convert a zero integer.  If you are using a C99 compiler it has built-in support for bool types:http://en.wikipedia.org/wiki/Boolean_data_typeC has a boolean type: bool (at least for the last 10(!) years)Include stdbool.h and true/false will work as expected.Anything nonzero is evaluated to true in boolean operations, so you could justand use the constants.@Thomas Matthews: Conditional expressions are considered to be true if they are non-zero, but the C standard requires that logical operators themselves return either 0 or 1.@Tom: #define TRUE !FALSE is bad and is completely pointless.  If the header file makes its way into compiled C++ code, then it can lead to problems:Some compilers will generate a warning about the int => bool conversion.  Sometimes people avoid this by doing:to force the expression to be a C++ bool.  But if you #define TRUE !FALSE, you end up with:which ends up doing an int-to-bool comparison that can trigger the warning anyway.You can simply use #define directive as follows:And use as follows:and so..onYou can use a char, or another small number container for it.PseduoIt is this: