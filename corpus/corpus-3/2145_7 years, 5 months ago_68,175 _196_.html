In terms that an OOP programmer would understand (without any functional programming background), what is a monad?What problem does it solve and what are the most common places it\'s used?EDIT:To clarify the kind of understanding I was looking for, let\'s say you were converting an FP application that had monads into an OOP application. What would you do to port the responsibilities of the monads to the OOP app?UPDATE: This question was the subject of an immensely long blog series, which you can read at Monads -- thanks for the great question!In terms that an OOP programmer would understand (without any functional programming background), what is a monad?A monad is an "amplifier" of types that obeys certain rules and which has certain operations provided.First, what is an "amplifier of types"?  By that I mean some system which lets you take a type and turn it into a more special type. For example, in C# consider Nullable<T>. This is an amplifier of types. It lets you take a type, say int, and add a new capability to that type, namely, that now it can be null when it couldn\'t before.As a second example, consider IEnumerable<T>. It is an amplifier of types. It lets you take a type, say, string, and add a new capability to that type, namely, that you can now make a sequence of strings out of any number of single strings.What are the "certain rules"? Briefly, that there is a sensible way for functions on the underlying type to work on the amplified type such that they follow the normal rules of functional composition. For example, if you have a function on integers, saythen the corresponding function on Nullable<int> can make all the operators and calls in there work together "in the same way" that they did before.(That is incredibly vague and imprecise; you asked for an explanation that didn\'t assume anything about knowledge of functional composition.)What are the "operations"? Again, take Nullable<T> as an example. You can turn an int into a Nullable<int> with the constructor. The C# compiler takes care of most nullable "lifting" for you, but if it didn\'t, the lifting transformation is straightforward: an operation, say, is transformed intoAnd turning a nullable int back into an int is done with the Value property.It\'s the function transformation that is the key bit. Notice how the actual semantics of the nullable operation -- that an operation on a null propagates the null -- is captured in the transformation. We can generalize this. Suppose you have a function from int to int, like our original M.  You can easily make that into a function that takes an int and returns a Nullable<int> because you can just run the result through the nullable constructor. Now suppose you have this higher-order method:See what you can do with that? Any method that takes an int and returns an int, or takes an int and returns a nullable int can now have the nullable semantics applied to it.Furthermore: suppose you have two methods and you want to compose them:That is, Z is the composition of X and Y. But you cannot do that because X takes an int, and Y returns a nullable int. But since you have the "bind" operation, you can make this work:The bind operation on a monad is what makes composition of functions on amplified types work. The "rules" I handwaved about above are that the monad preserves the rules of normal function composition; that composing with identity functions results in the original function, that composition is associative, and so on. In C#, "Bind" is called "SelectMany". Take a look at how it works on the sequence monad. We need to have three things: turn a value into a sequence, turn a sequence into a value, and bind operations on sequences. Those operations are:The nullable monad rule was "to combine two functions that produce nullables together, check to see if the inner one results in null; if it does, produce null, if it does not, then call the outer one with the result". That\'s the desired semantics of nullable.  The sequence monad rule is "to combine two functions that produce sequences together, apply the outer function to every element produced by the inner function, and then concatenate all the resulting sequences together".  The fundamental semantics of the monads are captured in the Bind/SelectMany methods; this is the method that tells you what the monad really means.We can do even better. Suppose you have a sequences of ints, and a method that takes ints and results in sequences of strings. We could generalize the binding operation to allow composition of functions that take and return different amplified types, so long as the inputs of one match the outputs of the other:So now we can say "amplify this bunch of individual integers into a sequence of integers. Transform this particular integer into a bunch of strings, amplified to a sequence of strings. Now put both operations together: amplify this bunch of integers into the concatenation of all the sequences of strings." Monads allow you to compose your amplifications.What problem does it solve and what are the most common places it\'s used?That\'s rather like asking "what problems does the singleton pattern solve?", but I\'ll give it a shot. Monads are typically used to solve problems like:(Note that these are basically three ways of saying the same thing.)C# uses monads in its design. As already mentioned, the nullable pattern is highly akin to the "maybe monad". LINQ is entirely built out of monads; the "SelectMany" method is what does the semantic work of composition of operations. (Erik Meijer is fond of pointing out that every LINQ function could actually be implemented by SelectMany; everything else is just a convenience.)To clarify the kind of understanding I was looking for, let\'s say you were converting an FP application that had monads into an OOP application. What would you do to port the responsibilities of the monads into the OOP app?Most OOP languages do not have a rich enough type system to represent the monad pattern itself directly; you need a type system that supports types that are higher types than generic types. So I wouldn\'t try to do that. Rather, I would implement generic types that represent each monad, and implement methods that represent the three operations you need: turning a value into an amplified value, turning an amplified value into a value, and transforming a function on unamplified values into a function on amplified values.A good place to start is how we implemented LINQ in C#. Study the SelectMany method; it is the key to understanding how the sequence monad works in C#. It is a very simple method, but very powerful!For a more in-depth and theoretically sound explanation of monads in C#, I highly recommend my colleague Wes Dyer\'s article on the subject. This article is what explained monads to me when they finally "clicked" for me.The Marvels of MonadsThen, we have a first big problem. This is a program:f(x) = 2 * xg(x,y) = x / yHow can we say  what is to be executed first? How can we form an ordered sequence of functions (i.e. a program) using no more than functions?Solution: compose functions. If you want first g and then f, just write f(g(x,y)). OK, but ...More problems: some functions might fail (i.e. g(2,0), divide by 0). We have no "exceptions" in FP. How do we solve it?Solution: Let\'s allow functions to return two kind of things: instead of having g : Real,Real -> Real (function from two reals into a real), let\'s allow g : Real,Real -> Real | Nothing (function from two reals into (real or nothing)). But functions should (to be simpler) return only one thing. Solution: let\'s create a new type of data to be returned, a "boxing type" that encloses maybe a real or be simply nothing. Hence, we can have g : Real,Real -> Maybe Real. OK, but ...What happens now to f(g(x,y))? f is not ready to consume a Maybe Real. And, we don\'t want to change every function we could connect with g to consume a Maybe Real.Solution: let\'s have a special function to "connect"/"compose"/"link" functions. That way, we can, behind the scenes, adapt the output of one function to feed the following one. In our case:  g >>= f (connect/compose g to f). We want >>= to get g\'s output, inspect it and, in case it is Nothing just don\'t call f and return Nothing; or on the contrary, extract the boxed Real and feed f with it. (This algorithm is just the implementation of >>= for the Maybe type).Many other problems arise which can be solved using this same pattern: 1. Use a "box" to codify/store different meanings/values, and have functions like g that return those "boxed values". 2. Have composers/linkers g >>= f to help connecting g\'s output to f\'s input, so we don\'t have to change f at all.Remarkable problems that can be solved using this technique are: having a global state that every function in the sequence of functions ("the program") can share: solution StateMonad. We don\'t like "impure functions": functions that yield different output for same input. Therefore, let\'s mark those functions, making them to return a tagged/boxed value: IO monad.Total happiness !!!!In terms that an OOP programmer would\n  understand (without any functional\n  programming background), what is a\n  monad?What problem does it solve and what\n  are the most common places it\'s used?are the most common places it\'s used?In terms of OO programming, a monad is an interface (or more likely a mixin), parameterized by a type, with two methods, return and bind that describe:The problem it solves is the same type of problem you\'d expect from any interface, namely,\n"I have a bunch of different classes that do different things, but seem to do those different things in a way that has an underlying similarity. How can I describe that similarity between them, even if the classes themselves aren\'t really subtypes of anything closer than \'the Object\' class itself?"More specifically, the Monad "interface" is similar to IEnumerator or IIterator in that it takes a type that itself takes a type. The main "point" of Monad though is being able to connect operations based on the interior type, even to the point of having a new "internal type", while keeping - or even enhancing - the information structure of the main class.I would say the closest OO analogy to monads is the "command pattern".In the command pattern you wrap an ordinary statement or expression in a command object. The command object expose an execute method which executes the wrapped statement. So statement are turned into first class objects which can passed around and executed at will. Commands can be composed so you can create a program-object by chaining and nesting command-objects. The commands are executed by a separate object, the invoker. The benefit of using the command pattern (rather than just execute a series of ordinary statements) is that different invokers can apply different logic to how the commands should be executed.The command pattern could be used to add (or remove) language features which is not supported by the host language. For example, in a hypothetical OO language without exceptions, you could add exception semantics by exposing "try" and "throw" methods to the commands. When a command calls throw, the invoker backtracks through the list (or tree) of commands until the last "try" call. Conversely, you could remove exception semantic from a language (if you believe exceptions are bad) by catching all exceptions thrown by each individual commands, and turning them into error codes which are then passed to the next command.Even more fancy execution semantics like transactions, non-deterministic execution or continuations can be implemented like this in a language which doesn\'t support it natively. It is a pretty powerful pattern if you think about it.Now in reality the command-patterns is not used as a general language feature like this. The overhead of turning each statement into a separate class would lead to an unbearable amount of boilerplate code. But in principle it can be used to solve the same problems as monads are used to solve in fp.You have a recent presentation "Monadologie -- professional help on type anxiety" by Christopher League (July 12th, 2010), which is quite interesting on topics of continuation and monad.\nThe video going with this (slideshare) presentation is actually available at vimeo.\nThe Monad part start around 37 minutes in, on this one hour video, and starts with slide 42 of its 58 slide presentation.It is presented as "the leading design pattern for functional programming", but the language used in the examples is Scala, which is both OOP and functional.\nYou can read more on Monad in Scala in the blog post "Monads - Another way to abstract computations in Scala", from Debasish Ghosh (March 27, 2008).A type constructor M is a monad if it supports these operations:So for instance (in Scala):Monad are a big deal in Scala because of convenient syntax built to take advantage of Monad structures:for comprehension in Scala:is translated by the compiler to:The key abstraction is the flatMap, which binds the computation through chaining.\nEach invocation of flatMap returns the same data structure type (but of different value), that serves as the input to the next command in chain.In the above snippet, flatMap takes as input a closure (SomeType) => List[AnotherType] and returns a List[AnotherType]. The important point to note is that all flatMaps take the same closure type as input and return the same type as output.This is what "binds" the computation thread - every item of the sequence in the for-comprehension has to honor this same type constraint.If you take two operations (that may fail) and pass the result to the third, like:but without taking advantage of Monad, you get convoluted OOP-code like:whereas with Monad, you can work with the actual types (Venue, User) like all the operations work, and keep the Option verification stuff hidden, all because of the flatmaps of the for syntax:The yield part will only be executed if all three functions have Some[X]; any None would directly be returned to confirm. So:Monads allow ordered computation within Functional Programing, that allows us to model sequencing of actions in a nice structured form, somewhat like a DSL.And the greatest power comes with the ability to compose monads that serve different purposes, into extensible abstractions within an application.This sequencing and threading of actions by a monad is done by the language compiler that does the transformation through the magic of closures.By the way, Monad is not only model of computation used in FP: see this blog post.Category theory proposes many models of computation. Among themI\'ve written a short article comparing standard OOP python code to monadic python code demonstrating the underlying computational process with diagrams. It assumes no previous knowledge of FP. Hope you find it useful - http://nikolaygrozev.wordpress.com/2013/12/10/monads-in-15-minutes/To respect fast readers, I start with precise definition first,\ncontinue with quick more "plain English" explanation, and then move to examples.Here is a both concise and precise definition slightly reworded:A monad (in computer science) is formally a map that:sends every type X of some given programming language to a new type T(X) (called the "type of T-computations with values in X");equipped with a rule for composing two functions of the form \n  f:X->T(Y) and g:Y->T(Z) to a function g\xe2\x88\x98f:X->T(Z);in a way that is associative in the evident sense and unital with respect to a given unit function called pure_X:X->T(X), to be thought of as taking a value to the pure computation that simply returns that value.So in simple words, a monad is a rule to pass from any type X to another type T(X), and a rule to pass from two functions f:X->T(Y) and g:Y->T(Z) (that you would like to compose but can\'t) to a new function h:X->T(Z). Which, however, is not the composition in strict mathematical sense. We are basically "bending" function\'s composition or re-defining how functions are composed. Plus, we require the monad\'s rule of composing to satisfy the "obvious" mathematical axioms:Again, in simple words, we can\'t just go crazy re-defining our function composition as we like: So again in brief: A monad is the rule of type extension and composing functions satisfying the two axioms -- associativity and unital property.In practical terms, you want the monad to be implemented for you by the language, compiler or framework that would take care of composing functions for you. So you can focus on writing your function\'s logic rather than worrying how their execution is implemented. That is essentially it, in a nutshell.Being professional mathematician, I prefer to avoid calling h the "composition" of f and g. Because mathematically, it isn\'t. Calling it the "composition" incorrectly presumes that h is the true mathematical composition, which it isn\'t. It is not even uniquely determined by f and g. Instead, it is the result of our monad\'s new "rule of  composing" the functions. Which can be totally different from the actual mathematical composition even if the latter exists!Monad is not a functor! A functor F is a rule to go from type X to type F(X) and functions (morphism) between types X and Y to functions between F(X) and F(Y) (sending objects to objects and their morphisms to morphisms in category theory). Instead a monad sends a pair of functions f and g to a new one h.To make it less dry, let me try to illustrate it by example\nthat I am annotating with small sections, so you can skip right to the point.Suppose we want to compose two functions:But f(0) is not defined, so an exception e is thrown. Then how can you define the compositional value g(f(0))? Throw an exception again, of course! Maybe the same e. Maybe a new updated exception e1.What precisely happens here? First, we need new exception value(s)  (different or same). You can call them nothing or null or whatever but the essence remains the same -- they should be new values, e.g. it should not be a number in our example here. I prefer not to call them null to avoid confusion with how null can be implemented in any specific language. Equally I prefer to avoid nothing because it is often associated with null, which, in principle, is what null should do, however, that principle often gets bended for whatever practical reasons.This is a trivial matter for any experienced programmer but I\'d like to drop few words just to extinguish any worm of confusion:Exception is an object encapsulating information about how the invalid result of execution occurred.This can range from throwing away any details and returning a single global value (like NaN or null) or generating a long log list or what exactly happened, send it to a database and replicating all over the distributed data storage layer ;)The important difference between these two extreme examples of exception is that in the first case there are no side-effects. In the second there are. Which brings us to the (thousand-dollar) question:Shorter answer: Yes, but only when they don\'t lead to side-effects. Longer answer. To be pure, your function\'s output must be uniquely determined by its input. So we amend our function f by sending 0 to the new abstract value e that we call exception. We make sure that value e contains no outside information that is not uniquely determined by our input, which is x. So here is an example of exception without side-effect:And here is one with side-effect:Actually, it only has side-effects if that message can possibly change in the future. But if it is guaranteed to never change, that value becomes uniquely predictable, and so there is no side-effect.To make it even sillier. A function returning 42 ever is clearly pure. But if someone crazy decides to make 42 a variable that value might change, the very same function stops being pure under the new conditions.Note that I am using the object literal notation for simplicity to demonstrate the essence. Unfortunately things are messed-up in languages like JavaScript, where error is not a type that behaves the way we want here with respect to function composition, whereas actual types like null or NaN do not behave this way but rather go through the some artificial and not always intuitive type conversions.As we want to vary the message inside our exception, we are really declaring a new type E for the whole exception object and then \nThat is what the maybe number does, apart from its confusing name, which is to be either of type number or of the new exception type E, so it is really the union number | E of number and E. In particular, it depends on how we want to construct E, which is neither suggested nor reflected in the name maybe number.It is the mathematical operation taking functions\nf: X -> Y and g: Y -> Z and constructing \ntheir composition as function h: X -> Z satisfying h(x) = g(f(x)).\nThe problem with this definition occurs when the result f(x) is not allowed as argument of g. In mathematics those functions cannot be composed without extra work.\nThe strictly mathematical solution for our above example of f and g is to remove 0 from the set of definition of f. With that new set of definition (new more restrictive type of x), f becomes composable with g.However, it is not very practical in programming to restrict the set of definition of f like that. Instead, exceptions can be used. Or as another approach, artificial values are created like NaN, undefined, null, Infinity etc. So you evaluate 1/0 to Infinity and 1/-0 to -Infinity. And then force the new value back into your expression instead of throwing exception. Leading to results you may or may not find predictable:And we are back to regular numbers ready to move on ;)JavaScript allows us to keep executing numerical expressions at any costs without throwing errors as in the above example. That means, it also allows to compose functions. Which is exactly what monad is about - it is a rule to compose functions satisfying the axioms as defined at the beginning of this answer.But is the rule of composing function, arising from JavaScript\'s implementation for dealing with numerical errors, a monad?To answer this question, all you need is to check the axioms (left as exercise as not part of the question here;).Indeed, a more useful monad would instead be the rule prescribing\nthat if f throws exception for some x, so does its composition with any g. Plus make the exception E globally unique with only one possible value ever (terminal object in category theory). Now the two axioms are instantly checkable and we get a very useful monad. And the result is what is well-known as the maybe monad.A monad is a data type that encapsulates a value and to which essentially two operations can be applied:That\'s what a monad is. There are a few more technicalities, but basically those two operations define a monad. The real question is what a monad does, and that depends on the monad \xe2\x80\x94 lists are monads, Maybes are monads, IO operations are monads. All that it means when we say those things are monads is that they have the monad interface of return and >>=.From wikipedia:In functional programming, a monad  is\n  a kind of abstract data type used to\n  represent computations  (instead of\n  data in the domain model). Monads\n  allow the programmer to chain actions\n  together to build a pipeline, in which\n  each action is decorated with\n  additional processing rules provided\n  by the monad. Programs written in\n  functional style can make use of\n  monads to structure procedures that\n  include sequenced operations,1[2] \n  or to define arbitrary control flows\n  (like handling concurrency,\n  continuations, or exceptions).Formally, a monad is constructed by\n  defining two operations (bind and\n  return) and a type constructor M that\n  must fulfill several properties to\n  allow the correct composition of\n  monadic functions (i.e. functions that\n  use values from the monad as their\n  arguments). The return operation takes\n  a value from a plain type and puts it\n  into a monadic container of type M.\n  The bind operation performs the\n  reverse process, extracting the\n  original value from the container and\n  passing it to the associated next\n  function in the pipeline.A programmer will compose monadic\n  functions to define a data-processing\n  pipeline. The monad acts as a\n  framework, as it\'s a reusable behavior\n  that decides the order in which the\n  specific monadic functions in the\n  pipeline are called, and manages all\n  the undercover work required by the\n  computation.[3] The bind and return\n  operators interleaved in the pipeline\n  will be executed after each monadic\n  function returns control, and will\n  take care of the particular aspects\n  handled by the monad.I believe it explains it very well.I\'ll try to make the shortest definition I can manage using OOP terms:A generic class CMonadic<T> is a monad if it defines at least the following methods:and if the following laws apply for all types T and their possible values tleft identity:right identityassociativity:Examples: A List monad may have:And flatMap on the list [1,2,3] could work like so:Iterables and Observables can also be made monadic, as well as Promises and Tasks.Commentary:Monads are not that complicated. The flatMap function is a lot like the more commonly encountered map. It receives a function argument (also known as delegate), which it may call (immediately or later, zero or more times) with a value coming from the generic class. It expects that passed function to also wrap its return value in the same kind of generic class. To help with that, it provides create, a constructor that can create an instance of that generic class from a value. The return result of flatMap is also a generic class of the same type, often packing the same values that were contained in the return results of one or more applications of flatMap to the previously contained values. This allows you to chain flatMap as much as you want:It just so happens that this kind of generic class is useful as a base model for a huge number of things. This (together with the category theory jargonisms) is the reason why Monads seem so hard to understand or explain. They\'re a very abstract thing and only become obviously useful once they\'re specialized.For example, you can model exceptions using monadic containers. Each container will either contain the result of the operation or the error that has occured. The next function (delegate) in the chain of flatMap callbacks will only be called if the previous one packed a value in the container. Otherwise if an error was packed, the error will continue to propagate through the chained containers until a container is found that has an error handler function attached via a method called .orElse() (such a method would be an allowed extension)Notes: Functional languages allow you to write functions that can operate on any kind of a monadic generic class. For this to work, one would have to write a generic interface for monads. I don\'t know if its possible to write such an interface in C#, but as far as I know it isn\'t: Whether a monad has a "natural" interpretation in OO depends on the monad.  In a language like Java, you can translate the maybe monad to the language of checking for null pointers, so that computations that fail (i.e., produce Nothing in Haskell) emit null pointers as results.  You can translate the state monad into the language generated by creating a mutable variable and methods to change its state.A monad is a monoid in the category of endofunctors.The information that sentence puts together is very deep.  And you work in a monad with any imperative language.  A monad is a "sequenced" domain specific language.  It satisfies certain interesting properties, which taken together make a monad a mathematical model of "imperative programming".  Haskell makes it easy to define small (or large) imperative languages, which can be combined in a variety of ways.As an OO programmer, you use your language\'s class hierarchy to organize the kinds of functions or procedures that can be called in a context, what you call an object.  A monad is also an abstraction on this idea, insofar as different monads can be combined in arbitrary ways, effectively "importing" all of the sub-monad\'s methods into the scope.  Architecturally, one then uses type signatures to explicitly express which contexts may be used for computing a value.One can use monad transformers for this purpose, and there is a high quality collection of all of the "standard" monads: with corresponding monad transformers and type classes.  Type classes allow a complementary approach to combining monads by unifying their interfaces, so that concrete monads can implement a standard interface for the monad "kind".  For example, the module Control.Monad.State contains a class MonadState s m, and (State s) is an instance of the formThe long story is that a monad is a functor which attaches "context" to a value, which has a way to inject a value into the monad, and which has a way to evaluate values with respect to the context attached to it, at least in a restricted way.So:is a function which injects a value of type a into a monad "action" of type m a.is a function which takes a monad action, evaluates its result, and applies a function to the result.  The neat thing about (>>=) is that the result is in the same monad.  In other words, in m >>= f, (>>=) pulls the result out of m, and binds it to f, so that the result is in the monad.  (Alternatively, we can say that (>>=) pulls f into m and applies it to the result.)  As a consequence, if we have f :: a -> m b, and g :: b -> m c, we can "sequence" actions:Or, using "do notation"The type for (>>) might be illuminating.  It is It corresponds to the (;) operator in procedural languages like C.  It allows do notation like:In mathematical and philosopical logic, we have frames and models, which are "naturally" modelled with monadism.  An interpretation is a function which looks into the model\'s domain and computes the truth value (or generalizations) of a proposition (or formula, under generalizations).  In a modal logic for necessity, we might say that a proposition is necessary if it is true in "every possible world" -- if it is true with respect to every admissible domain.  This means that a model in a language for a proposition can be reified as a model whose domain consists of collection of distinct models (one corresponding to each possible world).  Every monad has a method named "join" which flattens layers, which implies that every monad action whose result is a monad action can be embedded in the monad. More importantly, it means that the monad is closed under the "layer stacking" operation.  This is how monad transformers work:  they combine monads by providing "join-like" methods for types likeso that we can transform an action in (MaybeT m) into an action in m, effectively collapsing layers.  In this case, runMaybeT :: MaybeT m a -> m (Maybe a) is our join-like method.  (MaybeT m) is a monad, and MaybeT :: m (Maybe a) -> MaybeT m a is effectively a constructor for a new type of monad action in m.  A free monad for a functor is the monad generated by stacking f, with the implication that every sequence of constructors for f is an element of the free monad (or, more exactly, something with the same shape as the tree of sequences of constructors for f).  Free monads are a useful technique for constructing flexible monads with a minimal amount of boiler-plate.  In a Haskell program, I might use free monads to define simple monads for "high level system programming" to help maintain type safety (I\'m just using types and their declarations.  Implementations are straight-forward with the use of combinators):Monadism is the underlying architecture for what you might call the "interpreter" or "command" pattern, abstracted to its clearest form, since every monadic computation must be "run", at least trivially. (The runtime system runs the IO monad for us, and is the entry point to any Haskell program.  IO "drives" the rest of the computations, by running IO actions in order).The type for join is also where we get the statement that a monad is a monoid in the category of endofunctors.  Join is typically more important for theoretical purposes, in virtue of its type.  But understanding the type means understanding monads.  Join and monad transformer\'s join-like types are effectively compositions of endofunctors, in the sense of function composition.  To put it in a Haskell-like pseudo-language,Foo :: m (m a) <-> (m . m) aA monad is an array of functions (Pst: an array of functions is just a computation).Actually, instead of a true array (one function in one cell array) you have those functions chained by another function >>=. The >>= allows to adapt the results from function i to feed function i+1, perform calculations between them \nor, even, not to call function i+1. The types used here are "types with context". This is, a value with a "tag".\nThe functions being chained must take a "naked value" and return a tagged result.\nOne of the duties of >>= is to extract a naked value out of its context.\nThere is also the function "return", that takes a naked value and puts it with a tag.An example with Maybe. Let\'s use it to store a simple integer on which make calculations.Just to show that monads are array of functions with helper operations, consider\nthe equivalent to the above example, just using a real array of functionsAnd it would be used like this:If you\'ve ever used Powershell, the patterns Eric described should sound familiar.  Powershell cmdlets are monads; functional composition is represented by a pipeline.Jeffrey Snover\'s interview with Erik Meijer goes into more detail.Monads in typical usage are the functional equivalent of procedural programming\'s exception handling mechanisms.In modern procedural languages, you put an exception handler around a sequence of statements, any of which may throw an exception. If any of the statements throws an exception, normal execution of the sequence of statements halts and transfers to an exception handler. Functional programming languages, however, philosophically avoid exception handling features due to the "goto" like nature of them. The functional programming perspective is that functions should not have "side-effects" like exceptions that disrupt program flow.In reality, side-effects cannot be ruled out in the real world due primarily to I/O. Monads in functional programming are used to handle this by taking a set of chained function calls (any of which might produce an unexpected result) and turning any unexpected result into encapsulated data that can still flow safely through the remaining function calls.The flow of control is preserved but the unexpected event is safely encapsulated and handled.From a practical point of view (summarizing what has been said in many previous answers and related articles), it seems to me that one of the fundamental "purposes" (or usefulness) of the monad is to leverage the dependencies implicit in recursive method invocations aka function composition (i.e. when f1 calls f2 calls f3, f3 needs to be evaluated before f2 before f1) to represent sequential composition in a natural way, especially in the context of a lazy evaluation model (that is, sequential composition as a plain sequence, e.g. "f3(); f2(); f1();" in C - the trick is especially obvious if you think of a case where f3, f2 and f1 actually return nothing [their chaining as f1(f2(f3)) is artificial, purely intended to create sequence]).This is especially relevant when side-effects are involved, i.e. when some state is altered (if f1, f2, f3 had no side-effects, it wouldn\'t matter in what order they\'re evaluated; which is a great property of pure functional languages, to be able to parallelize those computations for example). The more pure functions, the better.I think from that narrow point of view, monads could be seen as syntactic sugar for languages that favor lazy evaluation (that evaluate things only when absolutely necessary, following an order that does not rely on the presentation of the code), and that have no other means of representing sequential composition. The net result is that sections of code that are "impure" (i.e. that do have side-effects) can be presented naturally, in an imperative manner, yet are cleanly separated from pure functions (with no side-effects), which can be evaluated lazily.This is only one aspect though, as warned here.See my answer to "What is a monad?"It begins with a motivating example, works through the example, derives an example of a monad, and formally defines "monad".It assumes no knowledge of functional programming and it uses pseudocode with function(argument) := expression syntax with the simplest possible expressions.This C++ program is an implementation of the pseudocode monad. (For reference: M is the type constructor, feed is the "bind" operation, and wrap is the "return" operation.)In OO terms, a monad is a fluent container.The minimum requirement is a definition of class <A> Something that supports a constructor Something(A a) and at least one method Something<B> flatMap(Function<A, Something<B>>)Arguably, it also counts if your monad class has any methods with signature Something<B> work() which preserves the class\'s rules -- the compiler bakes in flatMap at compile time.Why is a monad useful? Because it is a container that allows chain-able operations that preserve semantics. For example, Optional<?> preserves the semantics of isPresent for Optional<String>, Optional<Integer>, Optional<MyClass>, etc.As a rough example,Note we start with a string and end with an integer. Pretty cool.In OO, it might take a little hand-waving, but any method on Something that returns another subclass of Something meets the criterion of a container function that returns a container of the original type.That\'s how you preserve semantics -- i.e. the container\'s meaning and operations don\'t change, they just wrap and enhance the object inside the container.