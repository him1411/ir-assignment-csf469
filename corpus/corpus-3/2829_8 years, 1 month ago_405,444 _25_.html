I know that I can negate group of chars as in [^bar] but I need a regular expression where negation applies to the specific word - so in my example how do I negate an actual "bar" and not "any chars in bar"?A great way to do this is to use negative lookahead:Unless performance is of utmost concern, it\'s often easier just to run your results through a second pass, skipping those that match the words you want to negate. Regular expressions usually mean you\'re doing scripting or some sort of low-performance task anyway, so find a solution that is easy to read, easy to understand and easy to maintain.The following regex will do what you want (as long as negative lookbehinds and lookaheads are supported), matching things properly; the only problem is that it matches individual characters (i.e. each match is a single character rather than all characters between two consecutive "bar"s), possibly resulting in a potential for high overhead if you\'re working with very long strings.You could either use a negative look-ahead or look-behind:Or use just basics:These all match anything that does not contain bar.I came across this forum thread while trying to identify a regex for the following English statement:Given an input string, match everything unless this input string is exactly \'bar\'; for example I want to match \'barrier\' and \'disbar\' as well as \'foo\'.Here\'s the regex I came up with My English translation of the regex is "match the string if it starts with \'bar\' and it has at least one other character, or if the string does not start with \'bar\'.Solution:xxxxxx OKxxxSTRING1xxx KO (is whether it is desired)xxxSTRING2xxx KO (is whether it is desired)xxxSTRING3xxx KO (is whether it is desired)The accepted answer is  nice but is really a work-around for the lack of a simple sub-expression negation operator in regexes.  This is why grep --invert-match exits.  So in *nixes, you can accomplish the desired result using pipes and a second regex.Still a workaround, but maybe easier to remember.I had a list of file names, and I wanted to exclude certain ones, with this sort of behavior (Ruby):Here\'s my solution:My assumptions for this application:Just thought of something else that could be done. It\'s very different from my first answer, as it doesn\'t use regular expressions, so I decided to make a second answer post.Use your language of choice\'s split() method equivalent on the string with the word to negate as the argument for what to split on. An example using Python:The nice thing about doing it this way, in Python at least (I don\'t remember if the functionality would be the same in, say, Visual Basic or Java), is that it lets you know indirectly when "bar" was repeated in the string due to the fact that the empty strings between "bar"s are included in the list of results (though the empty string at the beginning is due to there being a "bar" at the beginning of the string). If you don\'t want that, you can simply remove the empty strings from the list.