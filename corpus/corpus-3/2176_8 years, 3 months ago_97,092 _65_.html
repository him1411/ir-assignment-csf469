Could someone please give me a brief introduction to lexical scoping?I understand them through examples. :)First, Lexical Scope (also called Static Scope), in C-like syntax:Every inner level can access its outer levels.There is another way, called Dynamic Scope used by first implementation of Lisp,\nagain in C-like Syntax:Here fun can either access x in dummy1 or dummy2, or any x in any function that call fun with x declared in it.will print 5,will print 10.The first one is called static because it can be deduced at compile-time, the second is called dynamic because the outer scope is dynamic and depends on the chain call of the functions.I find static scoping easier for the eye. Most languages went this way eventually even Lisp(can do both, right?). Dynamic scoping is like passing references of all variables to the called function.An example of why the compiler can not deduce the outer dynamic scope of a function, consider our last example, if we write something like this:The call chain depends on a run time condition. If it is true, then the call chain looks like:If the condition is false:The outer scope of fun in both cases is the caller plus the caller of the caller and so on.Just to mention that C language does not allow nested functions nor dynamic scoping.Lets try the shortest possible definition:Lexical Scoping defines how variable names are resolved in nested functions: inner functions contain the scope of parent functions even if the parent function has returned.That\'s all there is to it! To help myself understand what this means, I wrote an in depth blog post about function scope and lexical scoping in JavaScript which can be found here. Maybe this could serve someone else too.Lexical (AKA static) scoping refers to determining a variable\'s scope based solely on its position within the textual corpus of code. A variable always refers to its top-level environment. It\'s good to understand it in relation to dynamic scope.Scope defines the area, where functions, variables and such are available. The availability of a variable for example is defined within its  the context, let\'s say the function, file, or object, they are defined in. We usually call these local variables.The lexical part means that you can derive the scope from reading the source code. Lexical scope is also known as static scope.Dynamic scope defines global variables that can be called or referenced from anywhere after being defined. Sometimes they are called global variables, even though global variables in most programmin languages are of lexical scope. This means, it can be derived from reading the code that the variable is available in this context. Maybe one has to follow a uses or includes clause to find the instatiation or definition, but the code/compiler knows about the variable in this place.In dynamic scoping, by contrast, you search in the local function first, then you search in the function that called the local function, then you search in the function that called that function, and so on, up the call stack. "Dynamic" refers to change, in that the call stack can be different every time a given function is called, and so the function might hit different variables depending on where it is called from. (see here)To see an interesting example for dynamic scope see here.For further details see here and here.Some examples in Delphi/Object PascalDelphi has lexical scope.The closest Delphi gets to dynamic scope is the RegisterClass()/GetClass() function pair. For its use see here.Let\'s say that the time RegisterClass([TmyClass]) is called to register a certain class cannot be predicted by reading the code (it gets called in a button click method called by the user), code calling GetClass(\'TmyClass\') will get a result or not. The call to RegisterClass() does not have to be in the lexical scope of the unit using GetClass();Another possibility for dynamic scope are anonymous methods (closures) in Delphi 2009, as they know the variables of their calling function. It does not follow the calling path from there recursively and therefore is not fully dynamic.I love the fully featured, language-agnostic answers from folks like @Arak. Since this question was tagged JavaScript though, I\'d like to chip in some notes very specific to this language.In javascript our choices for scoping are:It\'s worth noting, I think, that JavaScript doesn\'t really have dynamic scoping. .bind adjusts the this keyword, and that\'s close, but not technically the same.Here is an example demonstrating both approaches. You do this every time you make a decision about how to scope callbacks so this applies to promises, event handlers, and more.Here is what you might term Lexical Scoping of callbacks in JavaScript:Another way to scope is to use Function.prototype.bind:These methods are, as far as I know, behaviorally equivalent.The above code will return "I am just a local". It will not return "I am a global". Because the function func() counts where is was originally defined which is under the scope of function whatismyscope.It will not bother from whatever it is being called(the global scope/from within another function even), that\'s why global scope value I am global will not be printed.This is called lexical scoping where "functions are executed using the scope chain that was in effect when they were defined" - according to JavaScript Definition Guide.Lexical scope is a very very powerful concept. Hope this helps..:)Lexical scoping: Variables declared outside of a function are global variables and are visible everywhere in a JavaScript program. Variables declared inside a function have function scope and are visible only to code that appears inside that function.IBM defines it as:The portion of a program or segment unit in which a declaration\n  applies. An identifier declared in a routine is known within that\n  routine and within all nested routines. If a nested routine declares\n  an item with the same name, the outer item is not available in the\n  nested routine.Example 1:Example 2:There is an important part of the conversation surrounding Lexical and Dynamic Scoping that is missing: a plain explanation of the lifetime of the scoped variable - or when the variable can be accessed. Dynamic scoping only very loosely corresponds to "global" scoping in the way that we traditionally think about it (the reason I bring up the comparison between the two is that it has already been mentioned - and I don\'t particularly like the linked article\'s explanation); it is probably best we don\'t make the comparison between global and dynamic - though supposedly, according to the linked article, "...[it] is useful as a substitute for globally scoped variables."So, in plain English, what\'s the important distinction between the two scoping mechanisms?Lexical scoping has been defined very well throughout the answers above: lexically scoped variables are available - or, accessible - at the local level of the function in which it was defined.However - as it is not the focus of the OP - dynamic scoping has not received a great deal of attention and the attention it has received means it probably needs a bit more (that\'s not a criticism of other answers, but rather a "oh, that answer made we wish there was a bit more"). So, here\'s a little bit more:Dynamic scoping means that a variable is accessible to the larger program during the lifetime of the function call - or, while the function is executing. Really, Wikipedia actually does a nice job with the explanation of the difference between the two. So as not to obfuscate it, here is the text that describes dynamic scoping:...[I]n dynamic scoping (or dynamic scope), if a variable name\'s scope is a\n  certain function, then its scope is the time-period during which the\n  function is executing: while the function is running, the variable\n  name exists, and is bound to its variable, but after the function\n  returns, the variable name does not exist.Lexical scope means that a function looks up variables in the context where it was defined, and not in the scope immediately around it. Look at how lexical scope works in Lisp if you want more detail. The selected answer by Kyle Cronin in Dynamic and Lexical variables in Common Lisp is a lot clearer than the answers here. Coincidentally I only learned about this in a Lisp class, and it happens to apply in JS as well.I ran this code in chrome\'s console.output:"Lexical scope" in general is the idea that:An identifier at a particular place in a program always refers to the same variable location \xe2\x80\x94 where \xe2\x80\x9calways\xe2\x80\x9d means \xe2\x80\x9cevery time that the containing expression is executed\xe2\x80\x9dThe variable location to which it refers can be determined by static examination of the source code context in which that identifier appears, without having to consider the flow of execution through the program as a whole.init() creates a local variable name and a function displayName(). displayName() is an inner function that is defined inside init() and is only available within the body of init(). displayName() has no local variables of its own. However, because inner functions have access to the variables of outer functions, displayName() can access the variable name declared in the parent function, init().Notice that alert() within displayName() successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word "lexical" refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.