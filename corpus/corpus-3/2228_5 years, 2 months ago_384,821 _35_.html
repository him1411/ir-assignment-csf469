I\'m writing a small AngularJS app that has a login view and a main view, configured like so:My LoginController checks the user/pass combination and sets a property on the $rootScope reflecting this:Everything works, but if I access http://localhost/#/main I end up bypassing the login screen. I wanted to write something like "whenever the route changes, if $rootScope.loggedUser is null then redirect to /login"...... wait. Can I listen to route changes somehow? I\'ll post this question anyway and keep looking.After some diving through some documentation and source code, I think I got it working. Perhaps this will be useful for someone else?I added the following to my module configuration:The one thing that seems odd is that I had to test the partial name (login.html) because the "next" Route object did not have a url or something else. Maybe there\'s a better way?Here is maybe a more elegant and flexible solution with \'resolve\' configuration property and \'promises\' enabling eventual data loading on routing and routing rules depending on data.You specify a function in \'resolve\' in routing config and in the function load and check data, do all redirects. If you need to load data, you return a promise, if you need to do redirect - reject promise before that.\nAll details can be found on $routerProvider and $q documentation pages.For russian-speaking folks there is a post on habr "\xd0\x92\xd0\xb0\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd\xd1\x82 \xd1\x83\xd1\x81\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe \xd1\x80\xd0\xb0\xd1\x83\xd1\x82\xd0\xb8\xd0\xbd\xd0\xb3\xd0\xb0 \xd0\xb2 AngularJS."I have been trying to do the same. Came up with another simpler solution after working with a colleague. I have a watch set up on $location.path(). That does the trick. I am just starting to learn AngularJS and find this to be more cleaner and readable.A different way of implementing login redirection is to use events and interceptors as described here.  The article describes some additional advantages such as detecting when a login is required, queuing the requests, and replaying them once the login is successful.You can try out a working demo here and view the demo source here.In your authentication service, set the currently authenticated user on the root scope.Alternatively you can set permissions on the user object and assign each route a permission, then check the permission in the event callback.Here\'s how I did it, in case it helps anyone:In the config, I set a publicAccess attribute on the few routes that I want open to the public (like login or register):then in a run block, I set a listener on the $routeChangeStart event that redirects to \'/login\' unless the user has access or the route is publicly accessible:You could obviously change the condition from isLoggedIn to anything else... just showing another way to do it.I\'m doing it using interceptors. I have created a library file which can be added to the index.html file. This way you\'ll have global error handling for your rest service calls and don\'t have to care about all errors individually. Further down I also pasted my basic-auth login library. There you can see that I also check for the 401 error and redirect to a different location. See lib/ea-basic-auth-login.jslib/http-error-handling.jscss/http-error-handling.cssindex.html\nlib/ea-basic-auth-login.jsNearly same can be done for the login. Here you have the answer to the redirect ($location.path("/login")).It\'s possible to redirect to another view with angular-ui-router. For this purpose, we have the method $state.go("target_view"). For example:In your app.js file:If you do not want to use angular-ui-router, but would like to have your controllers lazy loaded via RequireJS, there are couple of problems with event $routeChangeStart when using your controllers as RequireJS modules (lazy loaded).You cannot be sure the controller will be loaded before $routeChangeStart gets triggered -- in fact it wont be loaded. That means you cannot access properties of next route like locals or $$route because they are not yet setup.\nExample:This means you cannot check access rights in there.Solution:As loading of controller is done via resolve, you can do the same with your access control check:Note here that instead of using event $routeChangeStart I\'m using $routeChangeError