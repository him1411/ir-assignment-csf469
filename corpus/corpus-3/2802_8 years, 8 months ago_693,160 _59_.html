Looking for a solution in Bash (will be part of a script).Given a filename in the form someletters_12345_moreleters.ext, I want to extract the 5 digits and put them into a variable.So to emphasize the point.  I have a filename with x number of characters then a five digit sequence surrounded by a single underscore on either side then another set of x number of characters.  I want to take the 5 digit number and put that into a variable.I am very interested in the number of different ways that this can be accomplished.  As with most things, I am sure there are a number of different ways to tackle this problem.Use cut:More generic:If x is constant, the following parameter expansion performs substring extraction:where 12 is the offset (zero-based) and 5 is the lengthIf the underscores around the digits are the only ones in the input, you can strip off the prefix and suffix (respectively) in two steps:If there are other underscores, it\'s probably feasible anyway, albeit more tricky.  If anyone knows how to perform both expansions in a single expression, I\'d like to know too.Both solutions presented are pure bash, with no process spawning involved, hence very fast.Generic solution where the number can be anywhere in the filename, using the first of such sequences:Another solution to extract exactly a part of a variable:If your filename always have the format stuff_digits_... you can use awk:Yet another solution to remove everything except digits, usejust try to use cut -c startIndx-stopIndxIn case someone wants more rigorous information, you can also search it in man bash like thisResult:I\'m surprised this pure bash solution didn\'t come up:You probably want to reset IFS to what value it was before, or unset IFS afterwards!Building on jor\'s answer (which doesn\'t work for me):Following the requirementsI have a filename with x number of characters then a five digit\n  sequence surrounded by a single underscore on either side then another\n  set of x number of characters. I want to take the 5 digit number and\n  put that into a variable.I found some grep ways that may be useful:or betterAnd then with -Po syntax:Or if you want to make it fit exactly 5 characters:Finally, to make it be stored in a variable it is just need to use the var=$(command) syntax.Without any sub-processes you can:A very small variant of this will also work in ksh93.\nIf we focus in the concept of:\n    "A run of (one or several) digits"We could use several external tools to extract the numbers.\nWe could quite easily erase all other characters, either sed or tr:But if $name contains several runs of numbers, the above will fail:If "name=someletters_12345_moreleters_323_end.ext", then:We need to use regular expresions (regex).\nTo select only the first run (12345 not 323) in sed and perl:But we could as well do it directly in bash(1) :This allows us to extract the FIRST run of digits of any length\nsurrounded by any other text/characters.  Note: regex=[^0-9]*([0-9]{5,5}).*$; will match only exactly 5 digit runs. :-)(1):  faster than calling an external tool for each short texts. Not faster than doing all processing inside sed or awk for large files.Here\'s how i\'d do it:Note: the above is a regular expression and is restricted to your specific scenario of five digits surrounded by underscores. Change the regular expression if you need different matching.Here\'s a prefix-suffix solution (similar to the solutions given by JB and Darron) that matches the first block of digits and does not depend on the surrounding underscores:I love sed\'s capability to deal with regex groups:A slightly more general option would be not to assume that you have an underscore _ marking the start of your digits sequence, hence for instance stripping off all non-numbers you get before your sequence: s/[^0-9]\\+\\([0-9]\\+\\).*/\\1/p.More on this, in case you\'re not too confident with regexps:All escapes \\ are there to make sed\'s regexp processing work.There\'s also the bash builtin \'expr\' command:  similar to substr(\'abcdefg\', 2-1, 3) in php:Ok, here goes pure Parameter Substitution with an empty string. Caveat is that I have defined someletters and moreletters as only characters. If they are alphanumeric, this will not work as it is.My answer will have more control on what you want out of your string. Here is the code on how you can extract 12345 out of your stringThis will be more efficient if you want to extract something that has any chars like abc or any special characters like _ or -. For example: If your string is like this and you want everything that is after someletters_ and before _moreleters.ext :With my code you can mention what exactly you want.\nExplanation:#* It will remove the preceding string including the matching key. Here the key we mentioned is _ \n% It will remove the following string including the matching key. Here the key we mentioned is \'_more*\'Do some experiments yourself and you would find this interesting.Given test.txt is a file containing "ABCDEFGHIJKLMNOPQRSTUVWXYZ"A little late, but I just ran across this problem and found the following:I used it to get millisecond resolution on an embedded system that does not have %N for date:A bash solution:This will clobber a variable called x. The var x could be changed to the var _.