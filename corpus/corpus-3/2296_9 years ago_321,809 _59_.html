Is it possible to create an instance of a generic type in Java? I\'m thinking based on what I\'ve seen that the answer is no (due to type erasure), but I\'d be interested if anyone can see something I\'m missing:EDIT: It turns out that Super Type Tokens could be used to resolve my issue, but it requires a lot of reflection-based code, as some of the answers below have indicated.I\'ll leave this open for a little while to see if anyone comes up with anything dramatically different than Ian Robertson\'s Artima Article.You are correct.  You can\'t do "new E".  But you can change it toIt\'s a pain.  But it works.  Wrapping it in the factory pattern makes it a little more tolerable.Dunno if this helps, but when you subclass (including anonymously) a generic type, the type information is available via reflection. e.g.,So, when you subclass Foo, you get an instance of Bar e.g.,But it\'s a lot of work, and only works for subclasses. Can be handy though.You\'ll need some kind of abstract factory of one sort or another to pass the buck to:In Java 8 you can use the Supplier functional interface to achieve this pretty easily:You would construct this class like this:The syntax String::new on that line is a constructor reference.If your constructor takes arguments you can use a lambda expression instead:If you need a new instance of a type argument inside a generic class then make your constructors demand its class...Usage:Pros:Cons:You can do this now and it doesn\'t require a bunch of reflection code.Of course if you need to call the constructor that will require some reflection, but that is very well documented, this trick isn\'t!Here is the JavaDoc for TypeToken.Think about a more functional approach: instead of creating some E  out of nothing (which is clearly a code smell), pass a function that knows how to create one, i.e.From Java Tutorial - Restrictions on Generics:Cannot Create Instances of Type ParametersYou cannot create an instance of a type parameter. For example, the following code causes a compile-time error:As a workaround, you can create an object of a type parameter through reflection:You can invoke the append method as follows:Here is an option I came up with, it may help:EDIT: Alternatively you can use this constructor (but it requires an instance of E):If you want not to type class name twice during instantiation like in:You can use factory method:Like in:When you are working with E at compile time you don\'t really care the actual generic type "E" (either you use reflection or work with base class of generic type) so let the subclass provide instance of E.   I thought I could do that, but quite disappointed: it doesn\'t work, but I think it still worths sharing. Maybe someone can correct:It produces:Line 26 is the one with the [*].The only viable solution is the one by @JustinRuddYou can achieve this with the following snippet:You can use:But you need to supply the exact class name, including packages, eg. java.io.FileInputStream. I used this to create a math expressions parser.As you said, you can\'t really do it because of type erasure.  You can sort of do it using reflection, but it requires a lot of code and lot of error handling.If you mean \nnew E() \nthen it is impossible. And I would add that it is not always correct - how do you know if E has public no-args constructor?\nBut you can always delegate creation to some other class that knows how to create an instance - it can be Class<E> or your custom code like thisAn imporovement of @Noah\'s answer. Reason for Changea] Is safer if more then 1 generic type is used in case you changed the order.b] A class generic type signature changes from time to time so that you will not be surprised by unexplained exceptions in the runtime.Robust CodeOr use the one linerOne Line CodeThere are various libraries that can resolve E for you using techniques similar to what the Robertson article discussed. Here\'s an implemenation of createContents that uses TypeTools to resolve the raw class represented by E:This assumes that getClass() resolves to a subclass of SomeContainer and will fail otherwise since the actual parameterized value of E will have been erased at runtime if it\'s not captured in a subclass.Here\'s an implementation of createContents that uses TypeTools to resolve the raw class represented by E:This approach only works if SomeContainer is subclassed so the actual value of E is captured in a type definition:Otherwise the value of E is erased at runtime and is not recoverable.You can with a classloader and the class name, eventually some parameters.Java unfortunatly does not allow what you want to do. See http://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createObjectsYou cannot create an instance of a type parameter. For example, the following code causes a compile-time error:As a workaround, you can create an object of a type parameter through reflection:You can invoke the append method as follows: