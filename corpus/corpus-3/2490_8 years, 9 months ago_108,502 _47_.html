I know how I use these terms, but I\'m wondering if there are accepted definitions for faking, mocking, and stubbing for unit tests?  How do you define these for your tests?  Describe situations where you might use each.Here is how I use them:Fake: a class that implements an interface but contains fixed data and no logic.  Simply returns "good" or "bad" data depending on the implementation.Mock: a class that implements an interface and allows the ability to dynamically set the values to return/exceptions to throw from particular methods and provides the ability to check if particular methods have been called/not called.Stub: Like a mock class, except that it doesn\'t provide the ability to verify that methods have been called/not called.Mocks and stubs can be hand generated or generated by a mocking framework.  Fake classes are generated by hand.  I use mocks primarily to verify interactions between my class and dependent classes.  I use stubs once I have verified the interactions and am testing alternate paths through my code.  I use fake classes primarily to abstract out data dependencies or when mocks/stubs are too tedious to set up each time.You can get some information :Fake objects actually have working implementations, but usually take some shortcut which makes them not suitable for productionStubs provide canned answers to calls made during the test, usually not responding at all to anything outside what\'s programmed in for the test. Stubs may also record information about calls, such as an email gateway stub that remembers the messages it \'sent\', or maybe only how many messages it \'sent\'.Mocks are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.Fake: We acquire or build a very lightweight implementation of the same functionality as provided by a component that the SUT depends on and instruct the SUT to use it instead of the real.Stub : This implementation is configured to respond to calls from the SUT with the values (or exceptions) that will exercise the Untested Code (see Production Bugs on page X) within the SUT. A key indication for using a Test Stub is having Untested Code caused by the inability to control the indirect inputs of the SUTMock Object that implements the same interface as an object on which the SUT (System Under Test) depends. We can use a Mock Object as an observation point when we need to do Behavior Verification to avoid having an Untested Requirement (see Production Bugs on page X) caused by an inability to observe side-effects of invoking methods on the SUT.I try to simplify by using : Mock and Stub. I use Mock when it\'s an object that returns a value that is set to the tested class. I use Stub to mimic an Interface or Abstract class to be tested. In fact, it doesn\'t really matter what you call it, they are all classes that aren\'t used in production, and are used as utility classes for testing.Stub - an object that provides predefined answers to method calls. Mock - an object on which you set expectations.Fake - an object with limited capabilities (for the purposes of testing), e.g. a fake web service. Test Double is the general term for stubs, mocks and fakes. But informally, you\'ll often hear people simply call them mocks. I am surprised that this question has been around for so long and nobody has as yet provided an answer based on Roy Osherove\'s "The Art of Unit Testing".In "3.1 Introducing stubs" defines a stub as:A stub is a controllable replacement for an existing dependency\n  (or collaborator) in the system. By using a stub, you can test your code without\n  dealing with the dependency directly.And defines the difference between stubs and mocks as:The main thing to remember about mocks versus stubs is that mocks are just like stubs, but you assert against the mock object, whereas you do not assert against a stub.Fake is just the name used for both stubs and mocks. For example when you don\'t care about the distinction between stubs and mocks.The way Osherove\'s distinguishes between stubs and mocks, means that any class used as a fake for testing can be both a stub or a mock. Which it is for a specific test depends entirely on how you write the checks in your test. Example of a test where class FakeX is used as a stub:The fake instance is used as a stub because the Assert doesn\'t use fake at all.Example of a test where test class X is used as a mock:In this case the Assert checks a value on fake, making that fake a mock.Now, of course these examples are highly contrived, but I see great merit in this distinction. It makes you aware of how you are testing your stuff and where the dependencies of your test are.I agree with Osherove\'s thatfrom a pure maintainability perspective, in my tests using mocks creates more trouble than not using them. That has been my experience, but I\xe2\x80\x99m always learning something new.Asserting against the fake is something you really want to avoid as it makes your tests highly dependent upon the implementation of a class that isn\'t the one under test at all. Which means that the tests for class ActualClassUnderTest can start breaking because the implementation for ClassUsedAsMock changed. And that sends up a foul smell to me. Tests for ActualClassUnderTest should preferably only break when ActualClassUnderTest is changed.I realize that writing asserts against the fake is a common practice, especially when you are a mockist type of TDD subscriber. I guess I am firmly with Martin Fowler in the classicist camp (See Martin Fowler\'s "Mocks aren\'t Stubs") and like Osherove avoid interaction testing (which can only be done by asserting against the fake) as much as possible.For fun reading on why you should avoid mocks as defined here, google for "fowler mockist classicist". You\'ll find a plethora of opinions.It\'s a matter of making the tests expressive. I set expectations on a Mock if I want the test to describe a relationship between two objects. I stub return values if I\'m setting up a supporting object to get me to the interesting behaviour in the test.To illustrate the usage of stubs and mocks, I would like to also include an example based on Roy Osherove\'s "The Art of Unit Testing".Imagine, we have a LogAnalyzer application which has the sole functionality of printing logs. It not only needs to talk to a web service, but if the web service throws an error, LogAnalyzer has to log the error to a different external dependency, sending it by email to the web service administrator.Here\xe2\x80\x99s the logic we\xe2\x80\x99d like to test inside LogAnalyzer:How do you test that LogAnalyzer calls the email service correctly when the web service throws an exception?\nHere are the questions we\xe2\x80\x99re faced with:How can we replace the web service?How can we simulate an exception from the web service so that we can\ntest the call to the email service?How will we know that the email service was called correctly or at\nall?We can deal with the first two questions by using a stub for the web service. To solve the third problem, we can use a mock object for the email service.A fake is a generic term that can be used to describe either a stub or a mock.In our test, we\xe2\x80\x99ll have two fakes. One will be the email service mock, which we\xe2\x80\x99ll use to verify that the correct parameters were sent to the email service. The other will be a stub that we\xe2\x80\x99ll use to simulate an exception thrown from the web service. It\xe2\x80\x99s a stub because we won\xe2\x80\x99t be using the web service fake to verify the test result, only to make sure the test runs correctly. The email service is a mock because we\xe2\x80\x99ll assert against it that it was called correctly.I you are familiar with Arrange-Act-Assert, then one way of explaining the difference between stub and mock that might be useful for you, is that stubs belong to the arrange section, as they are for arranging input state, and mocks belong to the assert section as they are for asserting results against.Dummies don\'t do anything. They are just for filling up parameter lists, so that you don\'t get undefined or null errors. They also exist to satisfy the type checker in strictly typed languages, so that you can be allowed to compile and run.