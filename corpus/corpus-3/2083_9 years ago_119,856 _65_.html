Why does the \'sizeof\' operator return a size larger for a structure than the total sizes of the structure\'s members?This is because of padding added to satisfy alignment constraints. Data structure alignment impacts both performance and correctness of programs:Here\'s an example using typical settings for an x86 processor (all used 32 and 64 bit modes):One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure Z in the example above).IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special #pragma statements to change the structure alignment settings.Packing and byte alignment, as described in the C FAQ here:It\'s for alignment. Many processors can\'t access 2- and 4-byte\n  quantities (e.g. ints and long ints) if they\'re crammed in\n  every-which-way.Suppose you have this structure:Now, you might think that it ought to be possible to pack this\n  structure into memory like this:But it\'s much, much easier on the processor if the compiler arranges\n  it like this:In the packed version, notice how it\'s at least a little bit hard for\n  you and me to see how the b and c fields wrap around? In a nutshell,\n  it\'s hard for the processor, too. Therefore, most compilers will pad\n  the structure (as if with extra, invisible fields) like this:If you want the structure to have a certain size with GCC for example use __attribute__((packed)).On Windows you can set the alignment to one byte when using the cl.exe compier with the /Zp option.Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.So it is a matter of alignment basically.You need to have good reasons to change it.This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:Have members who\'s sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).See also:for Microsoft Visual C:http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspxand GCC claim compatibility with Microsoft\'s compiler.:http://gcc.gnu.org/onlinedocs/gcc/Structure_002dPacking-Pragmas.htmlIn addition to the previous answers, please note that regardless the packaging, there is no members-order-guarantee in C++. Compilers may (and certainly do) add virtual table pointer and base structures\' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.I\'m quite sure member-order is guaranteed in C, but I wouldn\'t count on it, when writing a cross-platform or cross-compiler program.It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that\'s not a multiple of 4 bytes.Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.C99 N1256 standard drafthttp://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf6.5.3.4 The sizeof operator:3 When applied to an operand that has structure or union type,\n  the result is the total number of bytes in such an object,\n  including internal and trailing padding.6.7.2.1 Structure and union specifiers:13 ... There may be unnamed\n  padding within a structure object, but not at its beginning.and:15 There may be unnamed padding at the end of a structure or union.The new C99 flexible array member feature (struct S {int is[];};) may also affect padding:16 As a special case, the last element of a structure with more than one named member may\n  have an incomplete array type; this is called a flexible array member. In most situations,\n  the flexible array member is ignored. In particular, the size of the structure is as if the\n  flexible array member were omitted except that it may have more trailing padding than\n  the omission would imply.Annex J Portability Issues reiterates:The following are unspecified: ...C++11 N3337 standard drafthttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf5.3.3 Sizeof:2 When applied\n  to a class, the result is the number of bytes in an object of that class including any padding required for\n  placing objects of that type in an array.9.2 Class members:A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:\n  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,\n  as necessary to achieve appropriate alignment. \xe2\x80\x94 end note ]I only know enough C++ to understand the note :-)In addition to the other answers, a struct can (but usually doesn\'t) have virtual functions, in which case the size of the struct will also include the space for the vtbl.The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors\' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.For example.  Consider the simple structure:If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper "packing".On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.For example:I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.C language leaves compiler some freedom about the location of the structural elements in the memory:The C language provides some assurance to the programmer of the elements layout in the structure:Problems related to the elements alignment:How alignment works:p.s More detailed info are available here: "Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)"The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.The x86 architecture has always been able to fetch misaligned addresses. However, it\'s slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today\'s mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)Finally, note that cache lines can be arbitrarily large, and the compiler doesn\'t attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line. TL;DR: alignment is important.