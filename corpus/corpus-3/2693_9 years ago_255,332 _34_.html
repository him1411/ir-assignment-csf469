Python gives us the ability to create \'private\' methods and variables within a class by prepending double underscores to the name, like this: __myPrivateMethod(). How, then, can one explain thisWhat\'s the deal?!I\'ll explain this a little for those who didn\'t quite get that.What I did there is create a class with a public method and a private method and instantiate it.Next, I call its public method.Next, I try and call its private method.Everything looks good here; we\'re unable to call it. It is, in fact, \'private\'. Well, actually it isn\'t. Running dir() on the object reveals a new magical method that python creates magically for all of your \'private\' methods.This new method\'s name is always an underscore, followed by the class name, followed by the method name.So much for encapsulation, eh?In any case, I\'d always heard Python doesn\'t support encapsulation, so why even try? What gives?The name scrambling is used to ensure that subclasses don\'t accidentally override the private methods and attributes of their superclasses. It\'s not designed to prevent deliberate access from outside.For example:Of course, it breaks down if two different classes have the same name.From http://www.faqs.org/docs/diveintopython/fileinfo_private.htmlStrictly speaking, private methods are\n  accessible outside their class, just\n  not easily accessible. Nothing in\n  Python is truly private; internally,\n  the names of private methods and\n  attributes are mangled and unmangled\n  on the fly to make them seem\n  inaccessible by their given names. You\n  can access the __parse method of the\n  MP3FileInfo class by the name\n  _MP3FileInfo__parse. Acknowledge that this is interesting, then promise to\n  never, ever do it in real code.\n  Private methods are private for a\n  reason, but like many other things in\n  Python, their privateness is\n  ultimately a matter of convention, not\n  force.When I first came from Java to Python i hated this. It scared me to death.Today it might just be the one thing I love most about Python.I love being on a platform, where people trust each other and don\'t feel like they need to build impenetrable walls around their code. In strongly encapsulated languages, if an API has a bug, and you have figured out what goes wrong, you may still be unable to work around it because the needed method is private. In Python the attitude is: "sure". If you think you understand the situation, perhaps you have even read it, then all we can say is "good luck!".Remember, encapsulation is not even weakly related to "security", or keeping the kids off the lawn. It is just another pattern that should be used to make a code base easier to understand.The phrase commonly used is "we\'re all consenting adults here".  By prepending a single underscore (don\'t expose) or double underscore (hide), you\'re telling the user of your class that you intend the member to be \'private\' in some way.  However, you\'re trusting everyone else to behave responsibly and respect that, unless they have a compelling reason not to (e.g. debuggers, code completion).If you truly must have something that is private, then you can implement it in an extension (e.g. in C for CPython).  In most cases, however, you simply learn the Pythonic way of doing things.It\'s not like you absolutly can\'t get around privateness of members in any language (pointer arithmetics in C++, Reflections in .NET/Java).The point is that you get an error if you try to call the private method by accident. But if you want to shoot yourself in the foot, go ahead and do it.Edit: You don\'t try to secure your stuff by OO-encapsulation, do you?Similar behavior exists when module attribute names begin with a single underscore (e.g. _foo).Module attributes named as such will not be copied into an importing module when using the from* method, e.g.:However, this is a convention and not a language constraint. These are not private attributes; they can be referenced and manipulated by any importer. Some argue that because of this, Python can not implement true encapsulation.Its just one of those language design choices. On some level they are justified. They make it so you need to go pretty far out of your way to try and call the method, and if you really need it that badly, you must have a pretty good reason! Debugging hooks and testing come to mind as possible applications, used responsibly of course.The class.__stuff naming convention lets the programmer know he isn\'t meant to access __stuff from outside. The name mangling makes it unlikely anyone will do it by accident.True, you still can work around this, it\'s even easier than in other languages (which BTW also let you do this), but no Python programmer would do this if he cares about encapsulation.with python-3.4 this is the behaviour:https://docs.python.org/3/tutorial/classes.html#tut-privateNote that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger.Even if the question is old I hope my snippet could be helpful. 