I\'m looking for very simple obfuscation (like encrypt and decrypt but not necessarily secure) functionality for some data. It\'s not mission critical. I need something to keep honest people honest, but something a little stronger than ROT13 or Base64.I\'d prefer something that is already included in the .NET framework 2.0, so I don\'t have to worry about any external dependencies.I really don\'t want to have to mess around with public/private keys, etc. I don\'t know much about encryption, but I do know enough to know that anything I wrote would be less than worthless... In fact, I\'d probably screw up the math and make it trivial to crack.Other answers here work fine, but AES is a more secure and up-to-date encryption algorithm.  This is a class that I obtained a few years ago to perform AES encryption that I have modified over time to be more friendly for web applications (e,g. I\'ve built Encrypt/Decrypt methods that work with URL-friendly string).  It also has the methods that work with byte arrays.  NOTE: you should use different values in the Key (32 bytes) and Vector (16 bytes) arrays!  You wouldn\'t want someone to figure out your keys by just assuming that you used this code as-is!  All you have to do is change some of the numbers (must be <= 255) in the Key and Vector arrays (I left one invalid value in the Vector array to make sure you do this...).  You can use https://www.random.org/bytes/ to generate a new set easily:Using it is easy: just instantiate the class and then call (usually) EncryptToString(string StringToEncrypt) and DecryptString(string StringToDecrypt) as methods.  It couldn\'t be any easier (or more secure) once you have this class in place.I cleaned up SimpleAES (above) for my use. Fixed convoluted encrypt/decrypt methods; separated methods for encoding byte buffers, strings, and URL-friendly strings; made use of existing libraries for URL encoding.The code is small, simpler, faster and the output is more concise. For instance, johnsmith@gmail.com produces:Code:Yes, add the System.Security assembly, import the System.Security.Cryptography namespace. Here\'s a simple example of a symmetric (DES) algorithm encryption:Just thought I\'d add that I\'ve improved Mud\'s SimplerAES by adding a random IV that\'s passed back inside the encrypted string. This improves the encryption as encrypting the same string will result in a different output each time.And bonus unit testA variant of Marks (excellent) answer Hope this helps[EDIT] Years later, I\'ve come back to say: don\'t do this!  See What's wrong with XOR encryption? for details.A very simple, easy two-way encrytpion is XOR encryption.If you just want simple encryption (i.e., possible for a determined cracker to break, but locking out most casual users), just pick two passphrases of equal length, say:and xor your data with both of them (looping the passphrases if necessary)(a).  For example:Someone searching your binary may well think the DNA string is a key, but they\'re unlikely to think the C code is anything other than uninitialized memory saved with your binary.(a) Keep in mind this is very simple encryption and, by some definitions, may not be considered encryption at all (since the intent of encryption is to prevent unauthorised access rather than just make it more difficult). Although, of course, even the strongest encryption is insecure when someone\'s standing over the key-holders with a steel pipe.As stated in the first sentence, this is a means to make it difficult enough for the casual attacker that they\'ll move on. It\'s similar to preventing burglaries on your home - you don\'t need to make it impregnable, you just need to make it less pregnable than the house next door :-)Encryption is easy: as others have pointed out, there are classes in the System.Security.Cryptography namespace that do all the work for you.  Use them rather than any home-grown solution.But decryption is easy too.  The issue you have is not the encryption algorithm, but protecting access to the key used for decryption.I would use one of the following solutions:DPAPI using the ProtectedData class with CurrentUser scope.  This is easy as you don\'t need to worry about a key.  Data can only be decrypted by the same user, so no good for sharing data between users or machines.DPAPI using the ProtectedData class with LocalMachine scope.  Good for e.g. protecting configuration data on a single secure server.  But anyone who can log into the machine can encrypt it, so no good unless the server is secure.Any symmetric algorithm.  I typically use the static SymmetricAlgorithm.Create() method if I don\'t care what algorithm is used (in fact it\'s Rijndael by default).  In this case you need to protect your key somehow.  E.g. you can obfuscate it in some way and hide it in your code.  But be aware that anyone who is smart enough to decompile your code will likely be able to find the key.I wanted to post my solution since none of the above the solutions are as simple as mine.  Let me know what you think:This assumes that the MachineKey of the server used to encrypt the value is the same as the one used to decrypt the value.  If desired, you can specify a static MachineKey in the Web.config so that your application can decrypt/encrypt data regardless of where it is run (e.g. development vs. production server).  You can generate a static machine key following these instructions.I combined what I found the best from several answers and comments.Code:Update 2015-07-18: Fixed mistake in private Encrypt() method by comments of @bpsilver and @Evereq. IV was accidentally encrypted, is now prepended in clear text as expected by Decrypt().The namespace System.Security.Cryptography contains the TripleDESCryptoServiceProvider and RijndaelManaged classesDon\'t forget to add a reference to the System.Security assembly.I changed this:to this:I know you said you don\'t care about how secure it is, but if you chose DES you might as well take AES it is the more up-to-date encryption method.Using the builtin .Net Cryptography library, this example shows how to use the Advanced Encryption Standard (AES).I\'ve been using the accepted answer by Mark Brittingham and its has helped me a lot. Recently I had to send encrypted text to a different organization and that\'s where some issues came up. The OP does not require these options but since this is a popular question I\'m posting my modification (Encrypt and Decrypt functions borrowed from here):Here is the class (test sample at the end):and..Here is the test sample:I think this is the worlds simplest one !Test