Is there a function to generate a random number in C?  Or will I have to use a third party library?Note: Don\'t use rand() for security. If you need a cryptographically secure number, see this answer instead.The rand() function in <stdlib.h> returns a  pseudo-random integer between 0 and RAND_MAX. You can use srand(unsigned int seed) to set a seed.It\'s common practice to use the % operator in conjunction with rand() to get a different range (though bear in mind that this throws off the uniformity somewhat). For example:If you really care about uniformity you can do something like this:As addressed in how to safely generate random numbers in various programming languages, you\'ll want to do one of the following:For example:randombytes_uniform() is cryptographically secure and unbiased.If you need better quality pseudo random numbers than what stdlib provides, check out Mersenne Twister. It\'s faster, too. Sample implementations are plentiful, for example here.Lets go through this. First we use the srand() function to seed the randomizer. Basically, the computer can generate random numbers based on the number that is fed to srand(). If you gave the same seed value, then the same random numbers would be generated every time. Therefore, we have to seed the randomizer with a value that is always changing. We do this by feeding it the value of the current time with the time() function.Now, when we call rand(), a new random number will be produced every time. The standard C function is rand().  It\'s good enough to deal cards for solitaire, but it\'s awful.  Many implementations of rand() cycle through a short list of numbers, and the low bits have shorter cycles.  The way that some programs call rand() is awful, and calculating a good seed to pass to srand() is hard.The best way to generate random numbers in C is to use a third-party library like OpenSSL.  For example,Why so much code?  Other languages like Java and Ruby have functions for random integers or floats.  OpenSSL only gives random bytes, so I try to mimic how Java or Ruby would transform them into integers or floats.For integers, we want to avoid modulo bias.  Suppose that we got some random 4 digit integers from rand() % 10000, but rand() can only return 0 to 32767 (as it does in Microsoft Windows).  Each number from 0 to 2767 would appear more often than each number from 2768 to 9999.  To remove the bias, we can retry rand() while the value is below 2768, because the 30000 values from 2768 to 32767 map uniformly onto the 10000 values from 0 to 9999.For floats, we want 53 random bits, because a double holds 53 bits of precision (assuming it\'s an IEEE double).  If we use more than 53 bits, we get rounding bias.  Some programmers write code like rand() / (double)RAND_MAX, but rand() might return only 31 bits, or only 15 bits in Windows.OpenSSL\'s RAND_bytes() seeds itself, perhaps by reading /dev/urandom in Linux.  If we need many random numbers, it would be too slow to read them all from /dev/urandom, because they must be copied from the kernel.  It is faster to allow OpenSSL to generate more random numbers from a seed.More about random numbers:STL doesn\'t exist for C. You have to call rand, or better yet, random. These are declared in the standard library header stdlib.h. rand is POSIX, random is a BSD spec function.The difference between rand and random is that random returns a much more usable 32-bit random number, and rand typically returns a 16-bit number. The BSD manpages show that the lower bits of rand are cyclic and predictable, so rand is potentially useless for small numbers.If your system supports the arc4random family of functions I would recommend using those instead the standard rand function.The arc4random family includes:arc4random returns a random 32-bit unsigned integer.arc4random_buf puts random content in it\'s parameter buf : void *. The amount of content is determined by the bytes : size_t parameter.arc4random_uniform returns a random 32-bit unsigned integer which follows the rule: 0 <= arc4random_uniform(limit) < limit, where limit is also an unsigned 32-bit integer.arc4random_stir reads data from /dev/urandom and passes the data to arc4random_addrandom to additionally randomize it\'s internal random number pool.arc4random_addrandom is used by arc4random_stir to populate it\'s internal random number pool according to the data passed to it.If you do not have these functions, but you are on Unix, then you can use this code:The urandom_init function opens the /dev/urandom device, and puts the file descriptor in urandom_fd. The urandom function is basically the same as a call to rand, except more secure, and it returns a long (easily changeable).However, /dev/urandom can be a little slow, so it is recommended that you use it as a seed for a different random number generator. If your system does not have a /dev/urandom, but does have a /dev/random or similar file, then you can simply change the path passed to open in urandom_init. The calls and APIs used in urandom_init and urandom are (I believe) POSIX-compliant, and as such, should work on most, if not all POSIX compliant systems.Notes: A read from /dev/urandom will NOT block if there is insufficient entropy available, so values generated under such circumstances may be cryptographically insecure. If you are worried about that, then use /dev/random, which will always block  if there is insufficient entropy.If you are on another system(i.e. Windows), then use rand or some internal Windows specific platform-dependent non-portable API.Wrapper function for urandom, rand, or arc4random calls:Have a look at ISAAC (Indirection, Shift, Accumulate, Add, and Count). Its uniformly distributed and has an average cycle length of 2^8295.You want to use rand().  Note (VERY IMPORTANT): make sure to set the seed for the rand function.  If you do not, your random numbers are not truly random.  This is very, very, very important.  Thankfully, you can usually use some combination of the system ticks timer and the date to get a good seed. FWIW, the answer is that yes, there is a stdlib.h function called rand; this function is tuned primarily for speed and distribution, not for unpredictability. Almost all built-in random functions for various languages and frameworks use this function by default. There are also "cryptographic" random number generators that are much less predictable, but run much slower. These should be used in any sort of security-related application.Well, STL is C++, not C, so I don\'t know what you want. If you want C, however, there is the rand() and srand() functions:These are both part of ANSI C. There is also the random() function:But as far as I can tell, random() is not standard ANSI C. A third-party library may not be a bad idea, but it all depends on how random of a number you really need to generate.This is hopefully a bit more random than just using srand(time(NULL)).rand() is the most convenient way to generate random numbers.You may also catch random number from any online service like random.org.This is a good way to get a random number between two numbers of your choice.Output the first time: 39Output the second time: 61Output the third time: 65You can change the values after randnum to whatever numbers you choose, and it will generate a random number for you between those two numbers.Hearing a good explanation of why using rand() to produce uniformly distributed random numbers in a given range is a bad idea, I decided to take a look at how skewed the output actually is. My test case was fair dice throwing. Here\'s the C code:and here\'s its output:I don\'t know how uniform you need your random numbers to be, but the above appears uniform enough for most needs.Edit: it would be a good idea to initialize the PRNG with something better than time(NULL).I had a serious issue with pseudo random number generator in my recent application: I repeatidly called my C program via a pyhton script and I was using as seed the following code:However, since:My program generated the same sequence of numbers.\nYou can do 3 things to solve this problem:mix time output with some other information changing on runs (in my application, the output name):I used djb2 as my hash function.Increase time resolution. On my platform, clock_gettime was available, so I use it:Use both methods together:Option 3 ensures you (as far as i know) the best seed randomity, but it may create a difference only on very fast application.\nIn my opinion option 2 is a safe bet.C Program to generate random number between 9 and 50In general we can generate a random number between lowerLimit - 1  and upperLimit i.e lowerLimit is inclusive or say r \xe2\x88\x88 [ lowerLimit, upperLimit ) My minimalistic solution should works for random numbers in range [min, max). Use srand(time(NULL)) before. Try this, I put it together from some of the concepts already referenced above: