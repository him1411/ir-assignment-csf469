This question already has an answer here:In Java, is it legal to call remove on a collection when iterating through the collection using a foreach loop?  For instance:As an addendum, is it legal to remove items that have not been iterated over yet? For instance, To safely remove from a collection while iterating over it you should use an Iterator.For example:From the Java Documentation :The iterators returned by this class\'s iterator and listIterator\n  methods are fail-fast: if the list is structurally modified at any\n  time after the iterator is created, in any way except through the\n  iterator\'s own remove or add methods, the iterator will throw a\n  ConcurrentModificationException. Thus, in the face of concurrent\n  modification, the iterator fails quickly and cleanly, rather than\n  risking arbitrary, non-deterministic behavior at an undetermined time\n  in the future.Perhaps what is unclear to many novices is the fact that iterating over a list using the for/foreach constructs implicitly creates an iterator which is necessarily inaccessible. This info can be found hereYou don\'t want to do that. It can cause undefined behavior depending on the collection. You want to use an Iterator directly. Although the for each construct is syntactic sugar and is really using an iterator, it hides it from your code so you can\'t access it to call Iterator.remove.The behavior of an iterator is\n  unspecified if the underlying\n  collection is modified while the\n  iteration is in progress in any way\n  other than by calling this method.Instead write your code:Note that the code calls Iterator.remove, not List.remove.Addendum:Even if you are removing an element that has not been iterated over yet, you still don\'t want to modify the collection and then use the Iterator. It might modify the collection in a way that is surprising and affects future operations on the Iterator.The java design of the "enhanced for loop" was to not expose the iterator to code, but the only way to safely remove an item is to access the iterator. So in this case you have to do it old school:If in the real code the enhanced for loop is really worth it, then you could add the items to a temporary collection and call removeAll on the list after the loop.EDIT (re addendum): No, changing the list in any way outside the iterator.remove() method while iterating will cause problems. The only way around this is to use a CopyOnWriteArrayList, but that is really intended for concurrency issues.The cheapest (in terms of lines of code) way to remove duplicates is to dump the list into a LinkedHashSet (and then back into a List if you need). This preserves insertion order while removing duplicates.You clone the list names and iterate through the clone while you remove from the original list. A bit cleaner than the top answer.I didn\'t know about iterators, however here\'s what I was doing until today to remove elements from a list inside a loop: This is always working, and could be used in other languages or structs not supporting iterators.Yes you can use the for-each loop,\nTo do that you have to maintain a separate list to hold removing items and then remove that list from names list using removeAll() method,Those saying that you can\'t safely remove an item from a collection except through the Iterator aren\'t quite correct, you can do it safely using one of the concurrent collections such as ConcurrentHashMap.Make sure this is not code smell.  Is it possible to reverse the logic and be \'inclusive\' rather than \'exclusive\'?The situation that led me to this page involved old code that looped through a List using indecies to remove elements from the List. I wanted to refactor it to use the foreach style.  It looped through an entire list of elements to verify which ones the user had permission to access, and removed the ones that didn\'t have permission from the list.To reverse this and not use the remove:When would "remove" be preferred? One consideration is if gien a large list or expensive "add", combined with only a few removed compared to the list size.  It might be more efficient to only do a few removes rather than a great many adds.  But in my case the situation did not merit such an optimization.It\'s better to use an Iterator when you want to remove element from a listbecause the source code of remove is so ,if you remove an element from the list, the list will be restructure ,the other element\'s index will be changed, this can result something that you want to happened.Use.remove() of Interator orUse CopyOnWriteArrayList