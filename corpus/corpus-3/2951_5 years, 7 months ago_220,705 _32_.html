Is there any difference between the following code?and I think, the difference is in usage patterns. I would prefer .on over .click because the former can use less memory and work for dynamically added elements.Consider the following html:where we add new buttons viaand want "Alert!" to show an alert. We can use either "click" or "on" for that. with the above, a separate handler gets created for every single element that matches the selector. That meanswith the above, a single handler for all elements that match your selector, including the ones created dynamically.As Adrien commented below, another reason to use .on is namespaced events. If you add a handler with .on("click", handler) you normally remove it with .off("click", handler) which will remove that very handler. Obviously this works only if you have a reference to the function, so what if you don\'t ? You use namespaces:with unbinding viaIs there any difference between the following code?No, there is no functional difference between the two code samples in your question.  .click(fn) is a "shortcut method" for .on("click", fn).  From the documentation for .on():There are shorthand methods for some events such as .click() that can be used to attach or trigger event handlers. For a complete list of shorthand methods, see the events category.Note that .on() differs from .click() in that it has the ability to create delegated event handlers by passing a selector parameter, whereas .click() does not.  When .on() is called without a selector parameter, it behaves exactly the same as .click().  If you want event delegation, use .on()..on() is the recommended way to do all your event binding as of jQuery 1.7. It rolls all the functionality of both .bind() and .live() into one function that alters behavior as you pass it different parameters.As you have written your example, there is no difference between the two. Both bind a handler to the click event of #whatever. on() offers additional flexibility in allowing you to delegate events fired by children of #whatever to a single handler function, if you choose.As mentioned by the other answers:Noting though that .on() supports several other parameter combinations that .click() doesn\'t, allowing it to handle event delegation (superceding .delegate() and .live()).(And obviously there are other similar shortcut methods for "keyup", "focus", etc.)The reason I\'m posting an extra answer is to mention what happens if you call .click() with no parameters:Noting that if you use .trigger() directly you can also pass extra parameters or a jQuery event object, which you can\'t do with .click().I also wanted to mention that if you look at the jQuery source code (in jquery-1.7.1.js) you\'ll see that internally the .click() (or .keyup(), etc.) function will actually call .on() or .trigger(). Obviously this means you can be assured that they really do have the same result, but it also means that using .click() has a tiny bit more overhead - not anything to worry or even think about in most circumstances, but theoretically it might matter in extraordinary circumstances.EDIT: Finally, note that .on() allows you to bind several events to the same function in one line, e.g.:No, there isn\'t.\nThe point of on() is its other overloads, and the ability to handle events that don\'t have shortcut methods.They appear to be the same... Documentation from the click() function:This method is a shortcut for .bind(\'click\', handler)Documentation from the on() function:As of jQuery 1.7, the .on() method provides all functionality required\n  for attaching event handlers. For help in converting from older jQuery\n  event methods, see .bind(), .delegate(), and .live(). To remove events\n  bound with .on(), see .off()..click events only work when element gets rendered and are only attached to elements loaded when the DOM is ready..on events are dynamically attached to DOM elements, which is helpful when you want to attach an event to DOM elements that are rendered on ajax request or something else (after the DOM is ready).