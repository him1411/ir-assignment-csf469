My code runs inside a JAR file, say foo.jar, and I need to know, in the code, in which folder the running foo.jar is.So, if foo.jar is in C:\\FOO\\, I want to get that path no matter what my current working directory is.Obviously, this will do odd things if your class was loaded from a non-file location.Best solution for me:This should solve the problem with spaces and special characters.To obtain the File for a given Class, there are two steps:It is important to understand both steps, and not conflate them.Once you have the File, you can call getParentFile to get the containing folder, if that is what you need.As discussed in other answers, there are two major ways to find a URL relevant to a Class.URL url = Bar.class.getProtectionDomain().getCodeSource().getLocation();URL url = Bar.class.getResource(Bar.class.getSimpleName() + ".class");Both have pros and cons.The getProtectionDomain approach yields the base location of the class (e.g., the containing JAR file). However, it is possible that the Java runtime\'s security policy will throw SecurityException when calling getProtectionDomain(), so if your application needs to run in a variety of environments, it is best to test in all of them.The getResource approach yields the full URL resource path of the class, from which you will need to perform additional string manipulation. It may be a file: path, but it could also be jar:file: or even something nastier like bundleresource://346.fwk2106232034:4/foo/Bar.class when executing within an OSGi framework. Conversely, the getProtectionDomain approach correctly yields a file: URL even from within OSGi.Note that both getResource("") and getResource(".") failed in my tests, when the class resided within a JAR file; both invocations returned null. So I recommend the #2 invocation shown above instead, as it seems safer.Either way, once you have a URL, the next step is convert to a File. This is its own challenge; see Kohsuke Kawaguchi\'s blog post about it for full details, but in short, you can use new File(url.toURI()) as long as the URL is completely well-formed.Lastly, I would highly discourage using URLDecoder. Some characters of the URL, : and / in particular, are not valid URL-encoded characters. From the URLDecoder Javadoc:It is assumed that all characters in the encoded string are one of the following: "a" through "z", "A" through "Z", "0" through "9", and "-", "_", ".", and "*". The character "%" is allowed but is interpreted as the start of a special escaped sequence....There are two possible ways in which this decoder could deal with illegal strings. It could either leave illegal characters alone or it could throw an IllegalArgumentException. Which approach the decoder takes is left to the implementation.In practice, URLDecoder generally does not throw IllegalArgumentException as threatened above. And if your file path has spaces encoded as %20, this approach may appear to work. However, if your file path has other non-alphameric characters such as + you will have problems with URLDecoder mangling your file path.To achieve these steps, you might have methods like the following:You can find these methods in the SciJava Common library:You can also use:Use ClassLoader.getResource() to find the URL for your current class.For example:(This example taken from a similar question.)To find the directory, you\'d then need to take apart the URL manually. See the JarClassLoader tutorial for the format of a jar URL.I\'m surprised to see that none recently proposed to use Path. Here follows a citation: "The Path class includes various methods that can be used to obtain information about the path, access elements of the path, convert the path to other forms, or extract portions of a path"Thus, a good alternative is to get the Path objest as:The only solution that works for me on Linux, Mac and Windows:the selected answer above is not working if you run your jar by click on it from Gnome desktop environment (not from any script or terminal).Instead, I have fond that the following solution is working everywhere:I had the the same problem and I solved it that way:I hope I was of help to you.Here\'s upgrade to other comments, that seem to me incomplete for the specifics of using a relative "folder" outside .jar file (in the jar\'s same\n  location):For getting the path of running jar file I have studied the above solutions and tried all methods which exist some difference each other. If these code are running in Eclipse IDE they all should be able to find the path of the file including the indicated class and open or create an indicated file with the found path.But it is tricky, when run the runnable jar file directly or through the command line, it will be failed as the path of jar file gotten from the above methods will give an internal path in the jar file, that is it always gives a path asrsrc:project-name (maybe I should say that it is the package name of the main class file - the indicated class)I can not convert the rsrc:... path to an external path, that is when run the jar file outside the Eclipse IDE it can not get the path of jar file.The only possible way for getting the path of running jar file outside Eclipse IDE is this code line may return the living path (including the file name) of the running jar file (note that the return path is not the working directory), as the java document and some people said that it will return the paths of all class files in the same directory, but as my tests if in the same directory include many jar files, it only return the path of running jar (about the multiple paths issue indeed it happened in the Eclipse).Actually here is a better version - the old one failed if a folder name had a space in it.As for failing with applets, you wouldn\'t usually have access to local files anyway. I don\'t know much about JWS but to handle local files might it not be possible to download the app.?The path always refers to the resource within the jar file.I tried to get the jar running path using c:\\app>java -jar application.jarRunning the jar application named "application.jar", on Windows in the folder "c:\\app", the value of the String variable "folder" was "\\c:\\app\\application.jar" and I had problems testing for path\'s correctness  So I tried to define "test" as:to get path in a right format like "c:\\app" instead of "\\c:\\app\\application.jar" and I noticed that it work.The simplest solution is to pass the path as an argument when running the jar.You can automate this with a shell script (.bat in Windows, .sh anywhere else):I used . to pass the current working directory.UPDATEYou may want to stick the jar file in a sub-directory so users don\'t accidentally click it. Your code should also check to make sure that the command line arguments have been supplied, and provide a good error message if the arguments are missing.I had to mess around a lot before I finally found a working (and short) solution. \nIt is possible that the jarLocation comes with a prefix like file:\\ or jar:file\\, which can be removed by using String#substring().Works good on WindowsSomething that is frustrating is that when you are developing in Eclipse MyClass.class.getProtectionDomain().getCodeSource().getLocation() returns the /bin directory which is great, but when you compile it to a jar, the path includes the /myjarname.jar part which gives you illegal file names. To have the code work both in the ide and once it is compiled to a jar, I use the following piece of code:Other answers seem to point to the code source which is Jar file location which is not a directory.UseNot really sure about the others but in my case it didn\'t work with a "Runnable jar" and i got it working by fixing codes together from phchen2 answer and another from this link :How to get the path of a running JAR file?\nThe code:Mention that it is checked only in Windows but i think it works perfect on other Operating Systems [Linux,MacOs,Solaris] :).I had 2 .jar files in the same directory . I wanted from the one .jar file to start the other .jar file which is in the same directory.The problem is that when you start it from the cmd the current directory is system32.Warnings!\xf0\x9f\x8d\x82..\xf0\x9f\x8d\x82getBasePathForClass(Class<?> classs):This code worked for me:Ignore backup lad answer, it may look ok sometimes but has several problems:here both should be +1 not -1:Very dangerous because is not immediately evident if the path has no white spaces, but replacing just the "%" will leave you with a bunch of 20 in each white space:There are better ways than that loop for the white spaces.Also it will cause problems at debugging time.This method, called from code in the archive, returns the folder where the .jar file is. It should work in either Windows or Unix.Derived from code at: Determine if running from JARI write in Java 7, and test in Windows 7 with Oracle\'s runtime, and Ubuntu with the open source runtime. This works perfect for those systems:The path for the parent directory of any running jar file (assuming the class calling this code is a direct child of the jar archive itself):So, the path of foo.jar would be:Again, this wasn\'t tested on any Mac or older WindowsThe getProtectionDomain approach might not work sometimes e.g. when you have to find the jar for some of the core java classes (e.g in my case StringBuilder class within IBM JDK), however following works seamlessly:I have another way to get the String location of a class.The output String will have the form of The spaces and other characters are handled, and in the form without file:/. So will be easier to use.Or you can pass throw the current Thread like this :This one liner works for folders containing spaces or special characters (like \xc3\xa7 or \xc3\xb5). The original question asks for the absolute path (working dir), without the JAR file itself. Tested in here with Java7 on Windows7:Reference: http://www.mkyong.com/java/how-to-get-the-current-working-directory-in-java/