What is the difference between List<? super T> and List<? extends T> ?I used to use List<? extends T>, but it does not allow me to add elements to it list.add(e), whereas the List<? super T> does.The wildcard declaration of List<? extends Number> foo3 means that any of these are legal assignments:Reading - Given the above possible assignments, what type of object are you guarenteed to read from List foo3:Writing - Given the above possible assignments, what type of object could you add to List foo3 that would be legal for all the above possible ArrayList assignments:You can\'t add any object to List<? extends T> because you can\'t guarantee what kind of List it is really pointing to, so you can\'t guarantee that the object is allowed in that List.  The only "guarantee" is that you can only read from it and you\'ll get a T or subclass of  T.Now consider List <? super T>.The wildcard declaration of List<? super Integer> foo3 means that any of these are legal assignments:Reading - Given the above possible assignments, what type of object are you guaranteed to receive when you read from List foo3:Writing - Given the above possible assignments, what type of object could you add to List foo3 that would be legal for all the above possible ArrayList assignments:Remember PECS: "Producer Extends, Consumer Super"."Producer Extends" - If you need a List to produce T values (you want to read Ts from the list), you need to declare it with ? extends T, e.g. List<? extends Integer>. But you cannot add to this list."Consumer Super" - If you need a List to consume T values (you want to write Ts into the list), you need to declare it with ? super T, e.g. List<? super Integer>. But there are no guarantees what type of object you may read from this list.If you need to both read from and write to a list, you need to declare it exactly with no wildcards, e.g. List<Integer>.Note this example from the Java Generics FAQ. Note how the source list src (the producing list) uses extends, and the destination list dest (the consuming list) uses super:Also see \nHow can I add to List<? extends Number> data structures?Imagine having this hierarchyBy writing you are saying that list will be able to reference an object of type (for example) ArrayList whose generic type is one of the 7 subtypes of C2 (C2 included):and so on. Seven different cases:We have a set of "storable" types for each possible case: 7 (red) sets here graphically representedAs you can see, there is not a safe type that is common to every case:and so on. By writing you are saying that list will be able to reference an object of type (for example) ArrayList whose generic type is one of the 7 supertypes of C2 (C2 included):and so on. Seven different cases:We have a set of "storable" types for each possible case: 7 (red) sets here graphically representedAs you can see, here we have seven safe types that are common to every case: C2, D1, D2, E1, E2, E3, E4.and so on. You probably noticed that these types correspond to the hierarchy starting from type C2.Here the complete hierarchy if you wish to make some testsI love the answer from @Bert F but this is the way my brain sees it.I have an X in my hand.  If I want to write my X into a List, that List needs to be either a List of X or a List of things that my X can be upcast to as I write them in i.e. any superclass of X...If I get a List and I want to read an X out of that List, that better be a List of X or a List of things that can be upcast to X as I read them out, i.e. anything that extends XHope this helps. Based on Bert F\'s answer I would like to explain my understanding.Lets say we have 3 classes asHere We haveOk now lets try to get some value from fruitExtendedListAgain lets try Same is the case for Now lets try to set some object in fruitExtendedListAdding fruit objectAdding Melon objectFinally let try to add WaterMelon object But wait what if someone decides to make a new type of  Lemon lets say for arguments sake SaltyLemon asNow fruitExtendedList can be list of Fruit, Melon, WaterMelon or SaltyLemon.So, our statement is not valid either.Basically we can say that we cannot write anything to a fruitExtendedList.This sums up List<? extends Fruit>Now lets seeNow lets try to get some value from melonSuperListSimilarly Melon, WaterMelon or any other object cannot be read.But note that we can read Object type instancesNow, lets try to set some value from melonSuperList.Adding Object type objectAdding Fruit type objectAdding Melon type objectAdding WaterMelon type objectTo sum it up we can add Melon or its subclass in melonSuperList and read only Object type object.super is a lower bound, and extends is an upper bound.According to http://download.oracle.com/javase/tutorial/extra/generics/morefun.html :The solution is to use a form of\n  bounded wildcard we haven\'t seen yet:\n  wildcards with a lower bound. The\n  syntax ? super T denotes an unknown\n  type that is a supertype of T (or T\n  itself; remember that the supertype\n  relation is reflexive). It is the dual\n  of the bounded wildcards we\'ve been\n  using, where we use ? extends T to\n  denote an unknown type that is a\n  subtype of T.Using extends you can only get from the collection. You cannot put into it. Also, though super allows to both get and put, the return type during get is ? super T. A detailed explanation is given in my blog http://preciselyconcise.com/java/generics/c_wildcards.phpThe most confusing thing here is that whatever type restrictions we specify, assignment works only one way:You may think that Integer extends Number and it is ok, but the compiler believes that <? extends Number> cannot be converted to Integer (that is, in human parlance, it is wrong that anything that extends number can be converted to Integer):hs.set(i); is ok because Integer can be converted to any superclass of Number (and not because Integer is a superclass of Number, which is not true).EDIT added a comment about Consumer Extends and Producer Super -- they are not meaningful because they specify, correspondingly, nothing and just Object. You are advised to remember PECS because CEPS is never useful.When to use extends and superWildcards are most useful in method parameters. They allow for the necessary flexibility in method interfaces.People are often confused when to use extends and when to use super bounds. The rule of thumb is the get-put principle. If you get something from a parametrized container, use extends.The method totalFuel gets Vehicles from the list, asks them about how much fuel they have, and computes the total.\nIf you put objects into a parameterized container, use super.The method totalValue puts Vehicles into the Valuer.\nIt\'s useful to know that extends bound is much more common than super.The generic wildcards target two primary needs:Reading from a generic collection\nInserting into a generic collection\nThere are three ways to define a collection (variable) using generic wildcards. These are:List<?> means a list typed to an unknown type. This could be a List<A>, a List<B>, a List<String> etc.List<? extends A> means a List of objects that are instances of the class A, or subclasses of A (e.g. B and C).\nList<? super A> means that the list is typed to either the A class, or a superclass of A.Read more : http://tutorials.jenkov.com/java-generics/wildcards.htmlYou can go through all the answers above to understand why the .add() is restricted to \'<?>\', \'<? extends>\', and partly to \'<? super>\'.But here\'s the conclusion of it all if you want to remember it, and dont want to go exploring the answer every time:List<? extends A> means this will accept any List of A and subclass of A. \nBut you cannot add anything to this list. Not even objects of type A.List<? super A> means this will accept any list of A and superclass of A.\nYou can add objects of type A and its subclasses.