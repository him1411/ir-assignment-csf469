The character \xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6 (family with two women, one girl, and one boy) is encoded as such:U+1F469 WOMAN,\n\xe2\x80\x8dU+200D ZWJ,\nU+1F469 WOMAN,\nU+200D ZWJ,\nU+1F467 GIRL,\nU+200D ZWJ,\nU+1F466 BOYSo it\'s very interestingly-encoded; the perfect target for a unit test. However, Swift doesn\'t seem to know how to treat it. Here\'s what I mean:So, Swift says it contains itself (good) and a boy (good!). But it then says it does not contain a woman, girl, or zero-width joiner. What\'s happening here? Why does Swift know it contains a boy but not a woman or girl? I could understand if it treated it as a single character and only recognized it containing itself, but the fact that it got one subcomponent and no others baffles me.This does not change if I use something like "\xf0\x9f\x91\xa9".characters.first!.Even more confounding is this:Even though I placed the ZWJs in there, they aren\'t reflected in the character array. What followed was a little telling:So I get the same behavior with the character array... which is supremely annoying, since I know what the array looks like.This also does not change if I use something like "\xf0\x9f\x91\xa9".characters.first!.This has to do with how the String type works in Swift, and how the  contains(_:) method works. The \'\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6 \' is what\'s known as an emoji sequence, which is rendered as one visible character in a string. The sequence is made up of Character objects, and at the same time it is made up of UnicodeScalar objects.If you check the character count of the string, you\'ll see that it is made up of four characters, while if you check the unicode scalar count, it will show you a different result:Now, if you parse through the characters and print them, you\'ll see what seems like normal characters, but in fact the three first characters contain both an emoji as well as a zero-width joiner in their UnicodeScalarView:As you can see, only the last character does not contain a zero-width joiner, so when using the contains(_:) method, it works as you\'d expect. Since you aren\'t comparing against emoji containing zero-width joiners, the method won\'t find a match for any but the last character.To expand on this, if you create a String which is composed of an emoji character ending with a zero-width joiner, and pass it to the contains(_:) method, it will also evaluate to false. This has to do with contains(_:) being the exact same as range(of:) != nil, which tries to find an exact match to the given argument. Since characters ending with a zero-width joiner form an incomplete sequence, the method tries to find a match for the argument while combining characters ending with a zero-width joiners into a complete sequence. This means that the method won\'t ever find a match if:To demonstrate:However, since the comparison only looks ahead, you can find several other complete sequences within the string by working backwards:The easiest solution would be to provide a specific compare option to the range(of:options:range:locale:) method. The option String.CompareOptions.literal performs the comparison on an exact character-by-character equivalence. As a side note, what\'s meant by character here is not the Swift Character, but the UTF-16 representation of both the instance and comparison string \xe2\x80\x93 however, since String doesn\'t allow malformed UTF-16, this is essentially equivalent to comparing the Unicode scalar representation.Here I\'ve overloaded the Foundation method, so if you need the original one, rename this one or something:Now the method works as it "should" with each character, even with incomplete sequences:The first problem is you\'re bridging to Foundation with contains (Swift\'s String is not a Collection), so this is NSString behavior, which I don\'t believe handles composed Emoji as powerfully as Swift. That said, Swift I believe is implementing Unicode 8 right now, which also needed revision around this situation in Unicode 10 (so this may all change when they implement Unicode 10; I haven\'t dug into whether it will or not).To simplify thing, let\'s get rid of Foundation, and use Swift, which provides views that are more explicit. We\'ll start with characters:OK. That\'s what we expected. But it\'s a lie. Let\'s see what those characters really are.Ah\xe2\x80\xa6 So it\'s ["\xf0\x9f\x91\xa9ZWJ", "\xf0\x9f\x91\xa9ZWJ", "\xf0\x9f\x91\xa7ZWJ", "\xf0\x9f\x91\xa6"]. That makes everything a bit more clear. \xf0\x9f\x91\xa9 is not a member of this list (it\'s "\xf0\x9f\x91\xa9ZWJ"), but \xf0\x9f\x91\xa6 is a member.The problem is that Character is a "grapheme cluster," which composes things together (like attaching the ZWJ). What you\'re really searching for is a unicode scalar. And that works exactly as you\'re expecting:And of course we can also look for the actual character that is in there:(This heavily duplicates Ben Leggiero\'s points. I posted this before noticing he\'d answered. Leaving in case it is clearer to anyone.)It seems that Swift considers a ZWJ to be an extended grapheme cluster with the character immediately preceding it. We can see this when mapping the array of characters to their unicodeScalars:This prints the following from LLDB:Additionally, .contains groups extended grapheme clusters into a single character. For instance, taking the hangul characters \xe1\x84\x92, \xe1\x85\xa1, and \xe1\x86\xab (which combine to make the Korean word for "one": \xe1\x84\x92\xe1\x85\xa1\xe1\x86\xab):This could not find \xe1\x84\x92 because the three codepoints are grouped into one cluster which acts as one character. Similarly, \\u{1F469}\\u{200D} (WOMAN ZWJ) is one cluster, which acts as one character.The other answers discuss what Swift does, but don\'t go into much detail about why.Do you expect \xe2\x80\x9cA\xcc\x8a\xe2\x80\x9d to equal \xe2\x80\x9c\xc3\x85\xe2\x80\x9d? I expect you would.One of these is a letter with a combiner, the other is a single composed character. You can add many different combiners to a base character, and a human would still consider it to be a single character. To deal with this sort of discrepancy the concept of a grapheme was created to represent what a human would consider a character regardless of the codepoints used.Now text messaging services have been combining characters into graphical emoji for years :)\xc2\xa0\xe2\x86\x92\xc2\xa0\xf0\x9f\x99\x82. So various emoji were added to Unicode.\nThese services also started combining emoji together into composite emoji.\nThere of course is no reasonable way to encode all possible combinations into individual codepoints, so The Unicode Consortium decided to expand on the concept of graphemes to encompass these composite characters.What this boils down to is "\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6" should be considered as a single "grapheme cluster" if you trying to work with it at the grapheme level, as Swift does by default.If you want to check if it contains "\xf0\x9f\x91\xa6" as a part of that, then you should go down to a lower level.I don\'t know Swift syntax so here is some Perl\xc2\xa06 which has similar level of support for Unicode.\n(Perl 6 supports Unicode version 9 so there may be discrepancies)Let\'s go down a levelGoing down to this level can make some things harder though.I assume that .contains in Swift makes that easier, but that doesn\'t mean there aren\'t other things which become more difficult.Working at this level makes it much easier to accidentally split a string in the middle of a composite character for example.What you are inadvertently asking is why does this higher level representation not work like a lower level representation would. The answer is of course, it\'s not supposed to.If you are asking yourself \xe2\x80\x9cwhy does this have to be so complicated\xe2\x80\x9d, the answer is of course \xe2\x80\x9chumans\xe2\x80\x9d.Swift 4.0 updateString receives lots of revisions in swift 4 update, as documented in SE-0163.\nTwo emoji are used for this demo representing two different structures. Both are combined with a sequence of emoji.\xf0\x9f\x91\x8d\xf0\x9f\x8f\xbd is the combination of two emoji, \xf0\x9f\x91\x8d and \xf0\x9f\x8f\xbd\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6 is the combination of four emoji, with zero with joined connected them. The format is \xf0\x9f\x91\xa9\xe2\x80\x8djoiner\xf0\x9f\x91\xa9\xe2\x80\x8djoiner\xf0\x9f\x91\xa7\xe2\x80\x8djoiner\xf0\x9f\x91\xa61. CountsIn swift 4.0. emoji is counted as grapheme cluster. Every single emoji is counted as 1. The count property is also directly available for string. So you can directly call it like this.Character array of a string is also counted as grapheme clusters in swift 4.0, so both of the following codes print 1. These two emoji are examples of emoji sequences, where several emoji are combined together with or without zero width joiner \\u{200d} between them. In swift 3.0, character array of such string separates out each emoji and results an array with multiple elements (emoji). The joiner is ignored in this process. However in swift 4.0, character array sees all emoji as one piece. So that of any emoji will always be 1.unicodeScalars remains unchanged in swift 4. It provides the unique Unicode characters in the given string.2. ContainsIn swift 4.0, contains method ignores zero width joiner in emoji. So it returns true for any of the four emoji components of "\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6", and return false if you check for the joiner. However, in swift 3.0, the joiner is not ignored and is combined with the emoji in front of it. So when you check if "\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6" contains the first three component emoji, the result will be false