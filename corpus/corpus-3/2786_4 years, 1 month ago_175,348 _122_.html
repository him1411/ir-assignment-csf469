I would like to have my Gradle build to create a release signed apk file using Gradle.I\'m not sure if the code is correct or if I\'m missing a parameter when doing gradle build?This is some of the code in my gradle file:The gradle build finishes SUCCESSFUL, and in my build/apk folder I only see the ...-release-unsigned.apk and ...-debug-unaligned.apk files. Any suggestions on how to solve this?Easier way than previous answers:Put this into ~/.gradle/gradle.propertiesModify your build.gradle like this:Then you can run gradle assembleReleaseI managed to solve it adding this code, and building with gradle build:This generates a signed release apk file.Note that @sdqali\'s script will (at least when using Gradle 1.6) ask for the password\nanytime you invoke any gradle task. Since you only need it when doing gradle assembleRelease (or similar), you could use the following trick:Note that I also had to add the following (under android) to make it work:If you want to avoid hardcoding your keystore & password in build.gradle, you can use a properties file as explained here: HANDLING SIGNING CONFIGS WITH GRADLEBasically:1) create a myproject.properties file at /home/[username]/.signing with such contents:2) create a gradle.properties file (perhaps at the root of your project directory) with the contents:3) refer to it in your build.gradle like this:Like @Destil said but allow others who don\'t have the key to build:\nEasier way than previous answers:Put this into ~/.gradle/gradle.propertiesModify your build.gradle like this:Then you can run gradle assembleRelease\nOR\ngradle build(In reply to user672009 above.)An even easier solution, if you want to keep your passwords out of a git repository; yet, want to include your build.gradle in it, that even works great with product flavors, is to create a separate gradle file. Let\'s call it \'signing.gradle\' (include it in your .gitignore). Just as if it were your build.gradle file minus everything not related to signing in it.Then in your build.gradle file include this line right underneath "apply plugin: \'android\'"If you don\'t have or use multiple flavors, rename "flavor1" to "release" above, and you should be finished. If you are using flavors continue.Finally link your flavors to its correct signingConfig in your build.gradle file and you should be finished.This is a reply to user672009 and addition to sdqali\'s post (his code will crash on building debug version by IDE\'s "Run" button):You can use the following code:In newer Android Studio, there is a GUI way which is very easy and it populates Gradle file as well. File -> Project StructureModule -> Choose the main module (\'app\' or other custom name)Signing tab -> Plus image to add new configurationFill data on the right side OK and Gradle file is automatically createdYou will manually have to add a line signingConfig signingConfigs.NameOfYourConfig inside builtTypes{release{}}Images:Two important(!) notes:(EDIT 12/15)To create signed APK, you\'d have to open Terminal tab of Android Studio (the bottom of the main interface) and issue a command ./gradlew assembleReleaseIf you forgot keyAlias (what happens often to me), you will have to initiate Build -> Generate Signed APK to start the process and see the name of the Alias key. If you build apk via command line like me then you can provide signing configuration as arguments.Add this to your build.gradleMake your signingConfigs like thisThen you execute gradlew like thisYou can also use -P command line option of gradle to help the signing. In your build.gradle, add singingConfigs like this:Then call gradle build like this:You can use -P to set storeFile and keyAlias if you prefer.This is basically Destil\'s solution but with the command line options.For more details on gradle properties, check the gradle user guide.It\'s amazing how many convoluted ways there are for doing this. Here is my own way, where I try to adhere to Googles own recommendation. However, their explanation is not fully clear, so I will describe the procedure for Linux in detail. The default Google instructions for automatically signing an app \nduring the build, without keeping the passwords and signature files \nin your app development (GIT) path, is rather obscure. Here are the \nclarified step-by-step instructions how to do so. You have an app called "MyApp" in a directory given by the following path:\n$HOME/projects/mydev/MyApp. However, the MyApp directory is used and \ncontrolled with GIT. We obviously don\'t want to have our signature or password files anywhere in\nthe GIT controlled directory, even if we are very able to use .gitignore etc, it is still too risky and easy to make a mistake. So we want our keystore and signature files outside.We need to do three (3) things:For this example we name the two files:We can put both of these files here:The first file contain the clear text passwords used in; and paths to the release-key file in (2). Start with filling this out, as it will make a copy paste operation easier for the next step.Edit keystore.properties so that it\'s content is: The only tricky part here, is the myStoreFileLocation. This is the path as seen from the module build.gradle file during the build. This usually means a path similar and relative to: $HOME/projects/mydev/MyApp/app/build.gradle. So in order to point to the MyApp-release-key.jks\nfile, what we need to put here is:../../../MyApp-release-key.jksHere, we also chose the "myapp" alias for the key. Then the final file should look:The second file is automatically generated when you create the signature key. \nIf you have no other apps and this is your only keystore, then create the file with:This will ask you for two passwords and a bunch of info. (Same stuff as in Android Studio.) Now copy/paste your previously chosen passwords.The following parts need to be present in your app/module\'s Gradle build file. First, add the following lines outside and before your android {} block.Then, inside the android {} block, add:Now from shell, you can re-build your app with:This should generate a properly signed app that can be used in Google Play. @Destil\'s answer is good if you can reuse the same configuration across all projects. Alternatively, Android Studio comes with a local.properties file that can maybe be used instead, but it\'s supposedly IDE-generated and I can\'t find a way to extend it from within Android Studio.This is a variation of @jonbo\'s answer. That answer allows project specific settings but it comes with a bit of developer overhead. Specifically, significant boilerplate is required to move the signingConfigs definition into a separate file -- especially if you need to do so for multiple projects, which is a prime reason for picking this solution over Destil\'s. This can be somewhat alleviated by also including the linein the credentials file, as this will allow IDE completion.Finally, most solutions here do not allow building the project in debug mode -- which handles debug-signing automatically -- without providing a syntactically if not semantically valid signingConfigs definition. If you do not need to produce a release build from a given machine, this extra step can be seen as an unnecessary obstacle. On the other hand, it can be an aid against ignorant or lazy colleagues running debug builds in production.This solution will allow debug builds without worrying about credentials at all, but it will require valid credentials to produce release builds, and it takes very little boilerplate. However, as a downside it might encourage others to replace dummy values with real credentials and there\'s no way to protect against that.This creates a dummy property that serves purely to produce a syntactically valid build file. The values assigned to ext.signing\'s properties are irrelevant as far as debug builds go. To enable release builds, copy ext.signing into signing.gradle and replace the dummy values with valid credentials.Of course, signing.gradle should be ignored by VCS.Almost all platforms now offer some sort of keyring, so there is no reason to leave clear text passwords around.I propose a simple solution that uses the Python Keyring module (mainly the companion console script keyring) and a minimal wrapper around Groovy [\'do\', \'something\'].execute() feature:Using this function, the signingConfigs section becomes:Before running gradle assembleRelease you have to set the passwords in your keyring, only once:Happy releases!I had quite a lot of fun figuring this one out. Here is my walk-through.A to Z walk-through on how to create a gradle build file in IntelliJ (v.13.1.4)\nThis walk-through assumes you know how to make a keystore file.\nFor this tutorial to work you will need your keystore file to be located in your app folder and you will need to have your zipalign.exe file to be located in \'SDK-ROOT\\tools\'. This file is usually found in \'SDK-ROOT\\build-tools\' and under this folder it will be in the highest api folder (alpha or beta I recommend the alpha version).For those of you that wish to jump straight in here is the gradle build file.You can build part of this build file (above) from menu option: File/Project Structure\nFrom here select Facets and click \'Android-Gradle(App).\nFrom here you will see tabs: \'Properties\', \'Signing\', \'Flavors\', \'Build Types\' and \'Dependencies\' for this walk-through we will just be using \'Signing\' and \'Build Types\'.\nUnder \'Build Types\' (in the name section) enter any name that you wish to identify your build type configuration and in the other 4 fields enter your keystore information (setting the keystore path the the one under your app folder).Under the \'Build Types\' enter the value \'assembleRelease\' into the name field, \'Debuggable\' should be set to false, \'Jni Debug Build\' should be false, set \'Run Proguard\' to true and \'Zip Align\' to true. This will generate build file, but not as depicted above, you will have to add a few things to the build file afterwards. The ProGuard file location here will be set manually in the gradle build file. (as depicted above)The DSL containers you will have to add afterwards are as follows:You will also have to add:note this DSL container above(\'dependencies\') should be at the bottom of the config file but not inside the android DSL container.\nIn order to build the dependencies container from the IntelliJ menu, select: File/Project Structure. From there select Facets again and then Android-Gradle(app). You will see the same 5 tabs as mentioned above. Select the \'Dependencies\' tab and add the dependencies you require.After all of this is done you should see a Gradle build file similar to the file at the top of this walk-through.\nTo build your signed zip aligned release you will need to open the Gradle tasks. You can get to this window by selecting View/Tool Windows/Gradle.\nFrom here you can double Click \'assembleAssembleRelease. This should generate your deployable APK.The potential problems that can occur when compiling your release are (but not limited to): Your Gradle build file being in the wrong place. There are two Gradle build files; one in your application root folder and another in the app folder under the application root. You must user the latter.You may also have lint problems. (Note: Android Developer Studio is much better at spotting Lint problems than IntelliJ you will notice this when trying to generate an signed APK from the menu options)To get around lint problems you will need to put the following DSL container inside the android container (at the top):putting this inside your android DSL container will cause an error file to be generated in the build folder (directly under your app folder) the file name should be something like \'lint-results-release-fatal.html\' this file will tell you the the class where the error occurred. Another file that will be generated is an XML file that contains the \'issue ID\' associated with the lint error. The file name should be something like \'lint-results-release-fatal.xml\'. Somewhere near the top of the file you will see a node \'issue\' inside which you will see something similar to \'id="IDOfYourLintProblem"\'To correct this problem open the file in your project that was listed in the \'lint-results-assembleRelease-fatal.html\' file and enter the following line of code in the Java Class file just above the class name: @SuppressLint("IDOfYourLintProblem"). You may have to import \'android.annotation.SuppressLint;\'So your java class file should appear like:Note that suppressing lint errors is not always the best IDEA you may be better off to change your code that caused the lint errors.Another problem that could potentially occur is if you have not set the environment variable for the Gradle HOME environment variable. This variable is named \'GRADLE_HOME\' and should be set the the path of the gradle home directory, something like \'C:\\gradle-1.12\'\nSometimes you may also want to set the environment variable for \'ANDROID_HOME\' set this to \'YOUR-SDK-Root\\sdk\'After this is done return to the Gradle tasks window and double click the assembleAssembleRelease.If all is successful you should be able to go to the folder app\\build\\apk and find your deployable APK file.Extending the answer by David Vavra,create a file ~/.gradle/gradle.properties and addThen in build.gradleI had several issues that I put the following line in a wrong place:Make sure that you put the signingConfigs parts inside the android section:instead of It is easy to make this mistake.Yet another approach to the same problem. As it is not recommended to store any kind of credential within the source code, we decided to set the passwords for the key store and key alias in a separate properties file as follows:If you use git, you can create a text file called, for example, secure.properties. You should make sure to exclude it from your repository (if using git, adding it to the .gitignore file). Then, you would need to create a signing configuration, like some of the other answers indicate. The only difference is in how you would load the credentials:Never forget to assign the signingConfig to the release build type manually (for some reason I sometimes assume it will be used automatically). Also, it is not mandatory to enable proguard, but it is recommendable.We like this approach better than using environment variables or requesting user input because it can be done from the IDE, by switching to the realease build type and running the app, rather than having to use the command line.To complement the other answers, you can also place your gradle.properties file in your own module folder, together with build.gradle, just in case your keystore is specific to one project.i am work in  Ubuntu14.04. \nvim ~/.bashrc  and add\nexport ANDROID_KEYSTORE=\nexport ANDROID_KEYALIAS=and then in build.gradle set.An alternative is to define a task that runs only on release builds.You can request passwords from the command line:The if-then-else block prevents requests for passwords when you\'re building a release. Although the else branch is unreachable, it tricks Gradle into creating an install...Release task.Backstory. As noted by https://stackoverflow.com/a/19130098/3664487, "Gradle scripts can prompt for user input using the System.console().readLine method." Unfortunately, Gradle will always request a password, even when you\'re building a debug release (cf. How to create a release signed apk file using Gradle?). Fortunately, this can be overcome, as I have shown above. if you don\'t want to see Cannot invoke method readLine() on null object. you need write in gradle.properties first.If you, like me, just want to be able to run the release on your device for testing purposes, consider creating a second keystore for signing, so you can simply put the passwords for it into your build.gradle without worrying for your market key store security.You can create a new keystore by clicking Build/Generate Signed APK/Create new...