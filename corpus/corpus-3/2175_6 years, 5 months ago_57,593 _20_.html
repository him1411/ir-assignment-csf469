CSS Selectors are matched by browser engines from right to left. So they first find the children and then check their parents to see if they match the rest of the parts of the rule.To me the simplest way to do it would be use the selectors with the least number of elements. So IDs first (as they should only return 1 element). Then maybe classes or an element that has the fewest number of nodes \xe2\x80\x94 e.g. there may only be one span on the page so go directly to that node with any rule that references a span.Here are some links backing up my claimsIt sounds like that it is done this way to avoid having to look at all the children of parent (which could be many) rather than all the parents of a child which must be one. Even if the DOM is deep it would only look at one node per level rather than multiple in the RTL matching. Is it easier/faster to evaluate CSS selectors LTR or RTL?Keep in mind that when a browser is doing selector matching it has one element (the one it\'s trying to determine style for) and all your rules and their selectors and it needs to find which rules match the element.  This is different from the usual jQuery thing, say, where you only have one selector and you need to find all the elements that match that selector.If you only had one selector and only one element to compare against that selector, then left-to-right makes more sense in some cases.  But that\'s decidedly not the browser\'s situation.  The browser is trying to render Gmail or whatever and has the one <span> it\'s trying to style and the 10,000+ rules Gmail puts in its stylesheet (I\'m not making that number up).In particular, in the situation the browser is looking at most of the selectors it\'s considering don\'t match the element in question.  So the problem becomes one of deciding that a selector doesn\'t match as fast as possible; if that requires a bit of extra work in the cases that do match you still win due to all the work you save in the cases that don\'t match.If you start by just matching the rightmost part of the selector against your element, then chances are it won\'t match and you\'re done.  If it does match, you have to do more work, but only proportional to your tree depth, which is not that big in most cases.On the other hand, if you start by matching the leftmost part of the selector... what do you match it against?  You have to start walking the DOM, looking for nodes that might match it.  Just discovering that there\'s nothing matching that leftmost part might take a while.So browsers match from the right; it gives an obvious starting point and lets you get rid of most of the candidate selectors very quickly.  You can see some data at http://groups.google.com/group/mozilla.dev.tech.layout/browse_thread/thread/b185e455a0b3562a/7db34de545c17665 (though the notation is confusing), but the upshot is that for Gmail in particular two years ago, for 70% of the (rule, element) pairs you could decide that the rule does not match after just examining the tag/class/id parts of the rightmost selector for the rule.  The corresponding number for Mozilla\'s pageload performance test suite was 72%.  So it\'s really worth trying to get rid of those 2/3 of all rules as fast as you can and then only worry about matching the remaining 1/3.Note also that there are other optimizations browsers already do to avoid even trying to match rules that definitely won\'t match.  For example, if the rightmost selector has an id and that id doesn\'t match the element\'s id, then there will be no attempt to match that selector against that element at all in Gecko: the set of "selectors with IDs" that are attempted comes from a hashtable lookup on the element\'s ID.  So this is 70% of the rules which have a pretty good chance of matching that still don\'t match after considering just the tag/class/id of the rightmost selector.It allows for cascading from the more specific to the less specific. It also allows a short circuit in application. If the more specific rule applies in all aspects that the parent rule applies to, all parent rules are ignored. If there are other bits in the parent, they are applied.If you went the other way around, you would format according to parent and then overwrite every time the child has something different. In the long run, this is a lot more work than ignoring items in rules that are already taken care of.Left-Right parsing also called as bottom-up parsing is actually efficient for the browser.   Consider the following:The browser first checks for a, then li, then ul, and then #menu. This is because as the browser is scanning the page it just needs to look at the current element/node and all the previous nodes/elements that it has scanned. The thing to note is that the browser starts processing moment it gets a complete tag/node and needn\'t have to wait for the whole page except when it finds a script, in which case it temporarily pauses and completes execution of the script and then goes forward. If it does the other way round it will be inefficient because the browser found the element it was scanning on the first check, but was then forced to continue looking through the document for all the additional selectors. For this the browser needs to have the entire html and may need to scan the whole page before it starts css painting.This is contrary to how most libs parse dom. There the dom is constructed and it doesn\'t need to scan the entire page just find the first element and then go on matching others inside it .