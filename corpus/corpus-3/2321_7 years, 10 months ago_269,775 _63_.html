Which one is better to use among the below statements in C?or orGenerally speaking:Because it respects scope and is type-safe.The only caveat I could see: if you want the variable to be possibly defined on the command line. There is still an alternative:Whenever possible, instead of macros / ellipsis, use a type-safe alternative.If you really NEED to go with a macro (for example, you want __FILE__ or __LINE__), then you\'d better name your macro VERY carefully: in its naming convention Boost recommends all upper-case, beginning by the name of the project (here BOOST_), while perusing the library you will notice this is (generally) followed by the name of the particular area (library) then with a meaningful name.It generally makes for lengthy names :)It depends on what you need the value for.  You (and everyone else so far) omitted the third alternative:Ignoring issues about the choice of name, then:So, in most contexts, prefer the \'enum\' over the alternatives.  Otherwise, the first and last bullet points are likely to be the controlling factors \xe2\x80\x94 and you have to think harder if you need to satisfy both at once.If you were asking about C++, then you\'d use option (1) \xe2\x80\x94 the static const \xe2\x80\x94 every time.In C, specifically? In C the correct answer is: use #define (or, if appropriate, enum)While it is beneficial to have the scoping and typing properties of a const object, in reality const objects in C (as opposed to C++) are not true constants and therefore are usually useless in most practical cases.So, in C the choice should be determined by how you plan to use your constant. For example, you can\'t use a const int object as a case label (while a macro will work). You can\'t use a const int object as a bit-field width (while a macro will work). In C89/90 you can\'t use a const object to specify an array size (while a macro will work). Even in C99 you can\'t use a const object to specify an array size when you need a non-VLA array.If this is important for you then it will determine your choice. Most of the time, you\'ll have no choice but to use #define in C. And don\'t forget another alternative, that produces true constants in C - enum.In C++ const objects are true constants, so in C++ it is almost always better to prefer the const variant (no need for explicit static in C++ though).The difference between static const and #define is that the former uses the memory and the later does not use the memory for storage. Secondly, you cannot pass the address of an #define whereas you can pass the address of a static const. Actually it is depending on what circumstance we are under, we need to select one among these two. Both are at their best under different circumstances. Please don\'t assume that one is better than the other... :-)If that would have been the case, Dennis Ritchie  would have kept the best one alone... hahaha... :-)In C #define is much more popular. You can use those values for declaring array sizes for example:ANSI C doesn\'t allow you to use static consts in this context as far as I know. In C++ you should avoid macros in these cases. You can writeand even leave out static because internal linkage is implied by const already [in C++ only].Another drawback of const in C is that you can\'t use the value in initializing another const.Even this does not work with a const since the compiler does not see it as a constant:I\'d be happy to use typed const in these cases, otherwise...If you can get away with it, static const has a lot of advantages.  It obeys the normal scope principles, is visible in a debugger, and generally obeys the rules that variables obey.However, at least in the original C standard, it isn\'t actually a constant.  If you use #define var 5, you can write int foo[var]; as a declaration, but you can\'t do that (except as a compiler extension" with static const int var = 5;.  This is not the case in C++, where the static const version can be used anywhere the #define version can, and I believe this is also the case with C99.However, never name a #define constant with a lowercase name.  It will override any possible use of that name until the end of the translation unit.  Macro constants should be in what is effectively their own namespace, which is traditionally all capital letters, perhaps with a prefix. #define var 5 will cause you trouble if you have things like mystruct.var.For example,The preprocessor will replace it and the code won\'t compile. For this reason, traditional coding style suggest all constant #defines uses capital letters to avoid conflict.I wrote quick test program to demonstrate one difference:This compiles with these errors and warnings:Note that enum gives an error when define gives a warning.Don\'t think there\'s an answer for "which is always best" but, as Matthieu said static constis type safe. My biggest pet peeve with #define, though, is when debugging in Visual Studio you cannot watch the variable. It gives an error that the symbol cannot be found.Incidentally, an alternative to #define, which provides proper scoping but behaves like a "real" constant, is "enum".  For example:In many cases, it\'s useful to define enumerated types and create variables of those types; if that is done, debuggers may be able to display variables according to their enumeration name. One important caveat with doing that, however: in C++, enumerated types have limited compatibility with integers. For example, by default, one cannot perform arithmetic upon them. I find that to be a curious default behavior for enums; while it would have been nice to have a "strict enum" type, given the desire to have C++ generally compatible with C, I would think the default behavior of an "enum" type should be interchangeable with integers.The definitiondoes not always define a constant value. Some compilers (for example tcc 0.9.26) just allocate memory identified with the name "const_value". Using the identifier "const_value" you can not modify this memory. But you still could modify the memory using another identifier:This means the definitionis the only way to define a constant value which can not be modified by any means.It is ALWAYS preferable to use const, instead of #define. That\'s because const is treated by the compiler and #define by the preprocessor. It is like #define itself is not part of the code (roughly speaking).Example:The symbolic name PI may never be seen by compilers; it may be removed by the preprocessor before the source code even gets to a compiler. As a result, the name PI may not get entered into the symbol table. This can be confusing if you get an error during compilation involving the use of the constant, because the error message may refer to 3.1416, not PI. If PI were defined in a header file you didn\xe2\x80\x99t write, you\xe2\x80\x99d have no idea where that 3.1416 came from.This problem can also crop up in a symbolic debugger, because, again, the name you\xe2\x80\x99re programming with may not be in the symbol table.Solution:A simple difference:At pre-processing time, the constant is replaced with its value.\nSo you could not apply the dereference operator to a define, but you can apply the dereference operator to a variable.As you would suppose, define is faster that static const.For example, having:you can not do printf("address of constant is %p",&mymax);.But havingyou can do printf("address of constant is %p",&mymax_var);.To be more clear, the define is replaced by its value at the pre-processing stage, so we do not have any variable stored in the program. We have just the code from the text segment of the program where the define was used.However, for static const we have a variable that is allocated somewhere. For gcc, static const are allocated in the text segment of the program.Above, I wanted to tell about the reference operator so replace dereference with reference.We looked at the produced assembler code on the MBF16X... Both variants result in the same code for arithmetic operations (ADD Immediate, for example).So const int is preferred for the type check while #define is old style. Maybe it is compiler-specific. So check your produced assembler code.I have seen the #define method used to to control the scope of the constant, thus mimicking a private class variable in C++.