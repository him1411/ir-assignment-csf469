We now have C++11 with many new features. An interesting and confusing one (at least for me) is the new nullptr.Well, no need anymore for the nasty macro NULL.Still, I am not getting how nullptr works. For example, Wikipedia article says:C++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant: nullptr. It is of type nullptr_t, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for bool.How is it a keyword and an instance of a type?Also, do you have another example (beside the Wikipedia one) where nullptr is superior to good old 0?How is it a keyword and an instance of a type?This isn\'t surprising. Both true and false are keywords and as literals they have a type ( bool ). nullptr is a pointer literal of type std::nullptr_t, and it\'s a prvalue (you cannot take the address of it using &). 4.10 about pointer conversion says that a prvalue of type std::nullptr_t is a null pointer constant, and that an integral null pointer constant can be converted to std::nullptr_t. The opposite direction is not allowed. This allows overloading a function for both pointers and integers, and passing nullptr to select the pointer version. Passing NULL or 0 would confusingly select the int version. A cast of nullptr_t to an integral type needs a reinterpret_cast, and has the same semantics as a cast of (void*)0 to an integral type (mapping implementation defined). A reinterpret_cast cannot convert nullptr_t to any pointer type. Rely on the implicit conversion if possible or use static_cast. The Standard requires that sizeof(nullptr_t) be sizeof(void*). From nullptr: A Type-safe and Clear-Cut Null Pointer:The new C++09 nullptr keyword designates an rvalue constant that serves as a universal null pointer literal, replacing the buggy and weakly-typed literal 0 and the infamous NULL macro. nullptr thus puts an end to more than 30 years of embarrassment, ambiguity, and bugs. The following sections present the nullptr facility and show how it can remedy the ailments of NULL and 0.Other references:When you have a function that can receive pointers to more than one type then calling it with NULL is ambiguous, the way this is worked around now is very hacky by accepting an int and assuming it\'s NULL.In C++11 you would be able to overload on nullptr_t so that ptr<T> p(42); would be a compile-time error rather than a run-time assert.nullptr can\'t be assigned to an integral type such as an int but only a type pointer; either a built-in pointer type such as int *ptr or a smart pointer such as std::shared_ptr<T>I believe this is an important distinction because NULL can still be assigned to an integral type and a pointer as NULL is a macro expanded to 0 which can serve as both an initial value for an int as well as a pointer.It is a keyword because the standard will specify it as such. ;-) According to the latest public draft (n2914)2.14.7 Pointer literals [lex.nullptr]The pointer literal is the keyword nullptr. It is an rvalue of type std::nullptr_t.It\'s useful because it does not implicitly convert to an integral value. Well, other languages have reserved words that are instances of types.  Python, for instance:This is actually a fairly close comparison because None is typically used for something that hasn\'t been intialized, but at the same time comparisons such as None == 0 are false.On the other hand, in plain C,  NULL == 0 would return true IIRC because NULL is just a macro returning 0, which is always an invalid address (AFAIK).Also, do you have another example (beside the Wikipedia one) where nullptr is superior to good old 0?Yes. It\'s also a (simplified) real-world example that occurred in our production code. It only stood out because gcc was able to issue a warning when crosscompiling to a platform with different register width (still not sure exactly why only when crosscompiling from x86_64 to x86, warns warning: converting to non-pointer type \'int\' from NULL):Consider this code (C++03):It yields this output:NULL need not to be 0. As long you use always NULL and never 0, NULL can be any value. Asuming you programme a von Neuman Microcontroller with flat memory, that has its interrupt vektors at 0. If NULL is 0 and something writes at a NULL Pointer the Microcontroller crashes. If NULL is lets say 1024 and at 1024 there is a reserved variable, the write won\'t crash it, and you can detect NULL Pointer assignments from inside the programme. This is Pointless on PCs, but for space probes, military or medical equipment it is important not to crash.