What\'s the difference between struct and class in .NET?I\'m looking for a clear, concise and accurate answer. Ideally as the actual answer, although links to good explanations are welcome.In .NET, there are two categories of types, reference types and value types.Structs are value types and classes are reference types.The general difference is that a reference type lives on the heap, and a value type lives inline, that is, wherever it is your variable or field is defined.A variable containing a value type contains the entire value type value. For a struct, that means that the variable contains the entire struct, with all its fields.A variable containing a reference type contains a pointer, or a reference to somewhere else in memory where the actual value resides.This has one benefit, to begin with:Internally, reference types are implemented as pointers, and knowing that, and knowing how variable assignment works, there are other behavioral patterns:When you declare variables or fields, here\'s how the two types differ:A short summary of each:Classes Only:Structs Only:Both Classes and Structs:In .NET the struct and class declarations differentiate between reference types and value types.When you pass round a reference type there is only one actually stored.  All the code that accesses the instance is accessing the same one.When you pass round a value type each one is a copy. All the code is working on its own copy.This can be shown with an example:For a class this would be differentClasses can be nothing - the reference can point to a null.Structs are the actual value - they can be empty but never null. For this reason structs always have a default constructor with no parameters - they need a \'starting value\'.Instances of classes are stored on the managed heap. All variables \'containing\' an instance are simply a reference to the instance on the heap. Passing an object to a method results in a copy of the reference being passed, not the object itself.Structures (technically, value types) are stored wherever they are used, much like a primitive type. The contents may be copied by the runtime at any time and without invoking a customised copy-constructor. Passing a value type to a method involves copying the entire value, again without invoking any customisable code.The distinction is made better by the C++/CLI names: "ref class" is a class as described first, "value class" is a class as described second. The keywords "class" and "struct" as used by C# are simply something that must be learned.In addition to all differences described in the other answers:If you are after a video explaining all the differences, you can check out Part 29 - C# Tutorial - Difference between classes and structs in C#.From Microsoft\'s Choosing Between Class and Struct ...As a rule of thumb, the majority of types in a framework should be\n  classes. There are, however, some situations in which the\n  characteristics of a value type make it more appropriate to use\n  structs.\xe2\x9c\x93 CONSIDER a struct instead of a class:X AVOID a struct unless the type has all of the following\n  characteristics:Structure vs ClassA structure is a value type so it is stored on the stack, but a class is a reference type and is stored on the heap.A structure doesn\'t support inheritance, and polymorphism, but a class supports both.By default, all the struct members are public but class members are by default private in nature.As a structure is a value type, we can\'t assign null to a struct object, but it is not the case for a class.Well, for starters, a struct is passed by value rather than by reference.  Structs are good for relatively simple data structures, while classes have a lot more flexibility from an architectural point of view via polymorphism and inheritance.Others can probably give you more detail than I, but I use structs when the structure that I am going for is simple.Besides the basic difference of access specifier, and few mentioned above I would like to add some of the major differences including few of the mentioned above with a code sample with output, which will give a more clear idea of the reference and value Structs: Class:Code SampleOutputInitial value of Struct Object is: 10Inside Struct Method\nInside Method value of Struct Object is: 20After Method call value of Struct Object is: 10Initial value of Class Object is: 10Inside Class Method\nInside Method value of Class Object is: 20After Method call value of Class Object is: 20Here you can clearly see the difference between call by value and call by reference.Just to make it complete, there is another difference when using Equals method, which is inherited by all classes and structures. Lets\'s say we have a class and a structure:and in the Main method, we have 4 objects.Then:So, structures are suited for numeric-like objects, like points (save x and y coordinates). And classes are suited for others. Even if 2 people have save name, height, weight..., they are still 2 people. Structs are the actual value - they can be empty but never nullThis is true, however also note that as of .NET 2 structs support a Nullable version and C# supplies some syntactic sugar to make it easier to use.As previously mentioned: Classes are reference type while Structs are value types with all the consequences.As a thumb of rule Framework Design Guidelines recommends using Structs instead of classes if: To add to the other answers, there is one fundamental difference that is worth noting, and that is how it\'s stored in memory. Structs are value types, so they store a value, classes are reference types, so they reference a class.This is also true with arrays, so an array of structs looks like this in memory[struct][struct][struct][struct][struct][struct][struct][struct]Where as an array of classes looks like this[pointer][pointer][pointer][pointer][pointer][pointer][pointer][pointer]For a vast majority of applications this difference doesn\'t really matter, however, in high performance code this will effect locality of data within memory. Using classes when you could/should have used structs will massively increase the number of cache misses on the CPU and will impact performance.The slowest thing a modern CPU does is not crunch numbers, it\'s fetch data from memory, and a L1 cache hit is many times faster than reading data from RAM.Events declared in a class have their += and -= access automatically locked via a lock(this) to make them thread safe (static events are locked on the typeof the class). Events declared in a struct do not have their += and -= access automatically locked. A lock(this) for a struct would not work since you can only lock on a reference type expression.Creating a struct instance cannot cause a garbage collection (unless the constructor directly or indirectly creates a reference type instance) whereas creating a reference type instance can cause garbage collection.A struct always has a built-in public default constructor.This means that a struct is always instantiable whereas a class might not be since all its constructors could be private.A struct cannot have a destructor. A destructor is just an override of object.Finalize in disguise, and structs, being value types, are not subject to garbage collection.A struct is implicitly sealed, a class isn\'t. \nA struct can\'t be abstract, a class can. \nA struct can\'t call : base() in its constructor whereas a class with no explicit base class can. \nA struct can\'t extend another class, a class can. \nA struct can\'t declare protected members (for example, fields, nested types) a class can. \nA struct can\'t declare abstract function members, an abstract class can. \nA struct can\'t declare virtual function members, a class can. \nA struct can\'t declare sealed function members, a class can. \nA struct can\'t declare override function members, a class can. \nThe one exception to this rule is that a struct can override the virtual methods of System.Object, viz, Equals(), and GetHashCode(), and ToString(). Every variable or field of a primitive value type or structure type holds a unique instance of that type, including all its fields (public and private). By contrast, variables or fields of reference types may hold null, or may refer to an object, stored elsewhere, to which any number of other references may also exist. The fields of a struct will be stored in the same place as the variable or field of that structure type, which may be either on the stack or may be part of another heap object. Creating a variable or field of a primitive value type will create it with a default value; creating a variable or field of a structure type will create a new instance, creating all fields therein in the default manner.  Creating a new instance of a reference type will start by creating all fields therein in the default manner, and then running optional additional code depending upon the type.Copying one variable or field of a primitive type to another will copy the value. Copying one variable or field of structure type to another will copy all the fields (public and private) of the former instance to the latter instance. Copying one variable or field of reference type to another will cause the latter to refer to the same instance as the former (if any).It\'s important to note that in some languages like C++, the semantic behavior of a type is independent of how it is stored, but that isn\'t true of .NET. If a type implements mutable value semantics, copying one variable of that type to another copies the properties of the first to another instance, referred to by the second, and using a member of the second to mutate it will cause that second instance to be changed, but not the first. If a type implements mutable reference semantics, copying one variable to another and using a member of the second to mutate the object will affect the object referred to by the first variable; types with immutable semantics do not allow mutation, so it doesn\'t matter semantically whether copying creates a new instance or creates another reference to the first.In .NET, it is possible for value types to implement any of the above semantics, provided that all of their fields can do likewise. A reference type, however, can only implement mutable reference semantics or immutable semantics; value types with fields of mutable reference types are limited to either implementing mutable reference semantics or weird hybrid semantics.