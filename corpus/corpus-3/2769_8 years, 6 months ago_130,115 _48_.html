I have a variable, x, and I want to know whether it is pointing to a function or not.I had hoped I could do something like:But that gives me:The reason I picked that is because If this is for Python 2.x or for Python 3.2+, you can also use callable(). It used to be deprecated, but is now undeprecated, so you can use it again. You can read the discussion here: http://bugs.python.org/issue10518. You can do this with:If this is for Python 3.x but before 3.2, check if the object has a __call__ attribute. You can do this with:The oft-suggested types.FunctionTypes approach is not correct because it fails to cover many cases that you would presumably want it to pass, like with builtins:The proper way to check properties of duck-typed objects is to ask them if they quack, not to see if they fit in a duck-sized container. Don\'t use types.FunctionType unless you have a very specific idea of what a function is.Builtin types that don\'t have constructors in the built-in namespace (e.g. functions, generators, methods) are in the types module. You can use types.FunctionType in an isinstance call.Since Python 2.1 you can import isfunction from the inspect module.The accepted answer was at the time it was offered thought to be correct; As it\nturns out, there is no substitute for callable(), which is back in python\n3.2:  Specifically, callable() checks the tp_call field of the object being\ntested.  There is no plain python equivalent.  Most of the suggested tests are\ncorrect most of the time:We can throw a monkey-wrench into this by removing the __call__ from the\nclass.  And just to keep things extra exciting, add a fake __call__ to the instance!Notice this really isn\'t callable:callable() returns the correct result:But hasattr is wrong:can_o_spam does have that attribute after all, its just not used when calling\nthe instance.Even more subtle, isinstance() also gets this wrong:Because we used this check earlier and later deleted the method, abc.ABCMeta\ncaches the result.  Arguably this is a bug in abc.ABCMeta.  That said,\nthere\'s really no possible way it could produce a more accurate result than\nthe result than by using callable() itself, since the typeobject->tp_call\nslot method is not accessible in any other way.Just use callable()The following should return a boolean:Python\'s 2to3 tool (http://docs.python.org/dev/library/2to3.html) suggests:It seems this was chosen instead of the hasattr(x, \'__call__\') method because of http://bugs.python.org/issue7006.callable(x) will return true if the object passed can be called in Python, but the function does not exist in Python 3.0, and properly speaking will not distinguish between:You\'ll get <class \'A\'> True and <type function> True as output.isinstance works perfectly well to determine if something is a function (try isinstance(b, types.FunctionType)); if you\'re really interested in knowing if something can be called, you can either use hasattr(b, \'__call__\') or just try it.This, of course, won\'t tell you whether it\'s callable but throws a TypeError when it executes, or isn\'t callable in the first place.  That may not matter to you.If you want to detect everything that syntactically looks like a function: a function, method, built-in fun/meth, lambda ... but exclude callable objects (objects with __call__ method defined), then try this one:I compared this with the code of is*() checks in inspect module and the expression above is much more complete, especially if your goal is filtering out any functions or detecting regular properties of an object.Try using callable(x).Since classes also have __call__ method, I recommend another solution:A function is just a class with a __call__ method, so you can doFor example:That is the "best" way of doing it, but depending on why you need to know if it\'s callable or note, you could just put it in a try/execpt block:It\'s arguable if try/except is more Python\'y than doing if hasattr(x, \'__call__\'): x().. I would say hasattr is more accurate, since you wont accidently catch the wrong TypeError, for example:Instead of checking for \'__call__\' (which is not exclusive to functions), you can check whether a user-defined function has attributes func_name, func_doc, etc. This does not work for methods. Another way of checking is using the isfunction() method from the inspect module.To check if an object is a method, use inspect.ismethod()Here\'s a couple of other ways:Here\'s how I came up with the second:Whatever function is a class so you can take the name of the class of instance x and compare:The solutions using hasattr(obj, \'__call__\') and callable(.) mentioned in some of the answers have a main drawback: both also return True for classes and instances of classes with a __call__() method. Eg.One proper way of checking if an object is a user-defined function (and nothing but a that) is to use isfunction(.):If you need to check for other types, have a look at inspect \xe2\x80\x94 Inspect live objects.In Python3 I came up with type (f) == type (lambda x:x) which yields True if f is a function and False if it is not. But I think I prefer isinstance (f, types.FunctionType), which feels less ad hoc. I wanted to do type (f) is function, but that doesn\'t work. Note that Python classes are also callable.To get functions (and by functions we mean standard functions and lambdas) use:Following previous replies, I came up with this:If the code will go on to perform the call if the value is callable, just perform the call and catch TypeError.