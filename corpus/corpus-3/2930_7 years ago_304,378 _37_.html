I\'m writing a program that parses 10 websites, locates data files, saves the files, and then parses them to make data that can be readily used in the NumPy library. There are tons of errors this file encounters through bad links, poorly formed XML, missing entries, and other things I\'ve yet to categorize. I initially made this program to handle errors like this:But now I want to log errors:Note this is printing to a log file for later review. This usually prints very useless data. What I want is to print the exact same lines printed when the error triggers without the try-except intercepting the exception, but I don\'t want it to halt my program since it is nested in a series of for loops that I would like to see to completion.Some other answer have already pointed out the traceback module.Please notice that with print_exc, in some corner cases, you will not obtain what you would expect. In Python 2.x:...will display the traceback of the last exception:If you really need to access the original traceback one solution is to cache the exception infos as returned from exc_info in a local variable and display it using print_exception:Producing:Few pitfalls with this though:From the doc of sys_info:Assigning the traceback return value to a local variable in a function that is handling an exception will cause a circular reference. This will prevent anything referenced by a local variable in the same function or by the traceback from being garbage collected. [...] If you do need the traceback, make sure to delete it after use (best done with a try ... finally statement)but, from the same doc:Beginning with Python 2.2, such cycles are automatically reclaimed when garbage collection is enabled and they become unreachable, but it remains more efficient to avoid creating cycles.On the other hand, by allowing you to access the traceback associated with an exception, Python 3 produce a less surprising result:... will display:traceback.format_exc() or sys.exc_info() will yield more info if that\'s what you want.If you\'re debugging and just want to see the current stack trace, you can simply call:traceback.print_stack()There\'s no need to manually raise an exception just to catch it again.When you don\'t want to halt your program on an error, you need to handle that error with a try/except:To extract the full traceback, we\'ll use the traceback module from the standard library:And to create a decently complicated stacktrace to demonstrate that we get the full stacktrace:To print the full traceback, use the traceback.print_exc method:Which prints:However, a best practice is to have a logger set up for your module. It will know the name of the module and be able to change levels (among other attributes, such as handlers)In which case, you\'ll want the logger.exception function instead:Which logs:Or perhaps you just want the string, in which case, you\'ll want the traceback.format_exc function instead:Which logs:And for all three options, we see we get the same output as when we have an error:To get the precise stack trace, as a string, that would have been raised if no try/except were there to step over it, simply place this in the except block that catches the offending exception.Here\'s how to use it (assuming flaky_func is defined, and log calls your favorite logging system): It\'s a good idea to catch and re-raise KeyboardInterrupts, so that you can still kill the program using Ctrl-C.  Logging is outside the scope of the question, but a good option is logging.  Documentation for the sys and traceback modules.You will need to put the try/except inside the most innerloop where the error may occur, i.e.... and so onIn other words, you will need to wrap statements that may fail in try/except as specific as possible, in the most inner-loop as possible.   You want the traceback module. It will let you print stack dumps like Python normally does. In particular, the print_last function will print the last exception and a stack trace.