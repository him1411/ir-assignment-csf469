This question already has an answer here:I need to read a whole file into memory and place it in a C++ std::string.If I were to read it into a char[], the answer would be very simple:Now, I want to do the exact same thing, but using a std::string instead of a char[]. I want to avoid loops, i.e. I don\'t want to:Any ideas?Update: Turns out that this method, while following STL idioms well, is actually surprisingly inefficient! Don\'t do this with large files. (See: http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html)You can make a streambuf iterator out of the file and initialize the string with it:Not sure where you\'re getting the t.open("file.txt", "r") syntax from. As far as I know that\'s not a method that std::ifstream has. It looks like you\'ve confused it with C\'s fopen.Edit: Also note the extra parentheses around the first argument to the string constructor. These are essential. They prevent the problem known as the "most vexing parse", which in this case won\'t actually give you a compile error like it usually does, but will give you interesting (read: wrong) results.Following KeithB\'s point in the comments, here\'s a way to do it that allocates all the memory up front (rather than relying on the string class\'s automatic reallocation):There are a couple of possibilities. One I like to use a stringstream as a go-between:Now the contents of "file.txt" are available in a string as buffer.str().Another possibility (though I certainly don\'t like it as well) is much more like your original:Officially, this isn\'t required to work under the C++98 or 03 standard (string isn\'t required to store data contiguously) but in fact it works with all known implementations, and C++11 and later do require contiguous storage, so it\'s guaranteed to work with them.As to why I don\'t like the latter as well: first, because it\'s longer and harder to read. Second, because it requires that you initialize the contents of the string with data you don\'t care about, then immediately write over that data (yes, the time to initialize is usually trivial compared to the reading, so it probably doesn\'t matter, but to me it still feels kind of wrong). Third, in a text file, position X in the file doesn\'t necessarily mean you\'ll have read X characters to reach that point -- it\'s not required to take into account things like line-end translations. On real systems that do such translations (e.g., Windows) the translated form is shorter than what\'s in the file (i.e., "\\r\\n" in the file becomes "\\n" in the translated string) so all you\'ve done is reserved a little extra space you never use. Again, doesn\'t really cause a major problem but feels a little wrong anyway.I think best way is to use string stream. simple and quick !!!You may not find this in any book or site but I found out that it works pretty well:Try one of these two methods:I figured out another way that works with most istreams, including std::cin!I could do it like this:If this is something to be frowned upon, please let me know whyIf you happen to use glibmm you can try Glib::file_get_contents.I don\'t think you can do this without an explicit or implicit loop, without reading into a char array (or some other container) first and ten constructing the string.  If you don\'t need the other capabilities of a string, it could be done with vector<char> the same way you are currently using a char *.