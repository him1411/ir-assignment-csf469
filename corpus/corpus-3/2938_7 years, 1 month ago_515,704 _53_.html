Is there a good available (standard Java) data structure to represent a tree in Java?Specifically I need to represent the following:Is there an available structure for this or do I need to create my own (if so implementation suggestions would be great).Here: That is a basic tree structure that can be used for String or any other object.  It is fairly easy to implement simple trees to do what you need.All you need to add are methods for add to, removing from, traversing, and constructors.  The Node is the basic building block of the Tree.Yet another tree structure:Sample usage:BONUS\nSee fully-fledged tree with:https://github.com/gt4dev/yet-another-tree-structureThere is actually a pretty good tree structure implemented in the JDK.Have a look at javax.swing.tree, TreeModel, and TreeNode. They are designed to be used with the JTreePanel but they are, in fact, a pretty good tree implementation and there is nothing stopping you from using it with out a swing interface.What about this? (BTW, no matter what I seem to try, I cannot paste code that the site\'s code formatter will process properly. Sorry about that.)I wrote a little library that handles generic trees. It\'s much more lightweight than the swing stuff. I also have a maven project for it.Obviously you can add utility methods to add/remove children.You should start by defining what a tree is (for the domain), this is best done by defining the interface first. Not all trees structures are modifyable, being able to add and remove nodes should be an optional feature, so we make an extra interface for that.There\'s no need to create node objects which hold the values, in fact I see this as a major design flaw and overhead in most tree implementations. If you look at Swing, the TreeModel is free of node classes (only DefaultTreeModel makes use of TreeNode), as they are not really needed.Given these interfaces, code that uses trees doesn\'t have to care much about how the tree is implemented. This allows you to use generic implementations as well as specialized ones, where you realize the tree by delegating functions to another API.\nExample: File tree structure.No answer mentions over-simplified but working code, so here it is:Along the same lines as Gareth\'s answer, check out DefaultMutableTreeNode.  It\'s not generic, but otherwise seems to fit the bill.  Even though it\'s in the javax.swing package, it doesn\'t depend on any AWT or Swing classes.  In fact, the source code actually has the comment // ISSUE: this class depends on nothing in AWT -- move to java.util?You can use any XML API of Java as Document and Node..as XML is a tree structure with StringsThere are a couple of tree data structures in Java, such as DefaultMutableTreeNode in JDK Swing, Tree in Stanford parser package, and other toy codes. But none of these are sufficient yet small enough for general purpose.Java-tree project attempts to provide another general-purpose tree data structure in Java. The difference between this and others areSince the question asks for an available data structure, a tree can be constructed from lists or arrays:instanceof can be used to determine whether an element is a subtree or a terminal node.As simple as it gets and very easy to use.  To use it, extend it:  For example : Custom Tree implement of Tree without using the Collection framework. It contains different fundamental operation needed in Tree implementation.You can use the HashTree class included in Apache JMeter that is part of the Jakarta Project.HashTree class is included in the package org.apache.jorphan.collections. Although this package is not released outside the JMeter project, you can get it easily:1) Download the JMeter sources.2) Create a new package.3) Copy on it /src/jorphan/org/apache/jorphan/collections/ . All files except Data.java4) Copy also /src/jorphan/org/apache/jorphan/util/JOrphanUtils.java5) HashTree is ready to use.Please check the below code, where I have used Tree data structures, without using Collection classes. The code may have bugs/improvements but please use this just for reference  There is no specific data structure in Java which suits to your requirements. Your requirements are quite specific and for that you need to design your own data structure. Looking at your requirements anyone can say that you need some kind of n-ary tree with some specific functionality. You can design your data structure in following way:I would suggest, you write structure of the node in one class like Class Node { String  value; List children;} and all other methods like search, insert and getChildren in another NodeUtils class so that you can also pass the root of tree to perform operation on specific tree like:\nclass NodeUtils{ public static Node search(Node root, String value){// perform BFS and return Node}In the past I have just used a nested map for this. This is what I use today, it is very simple but it fits my needs. Maybe this will help another one.I wrote a tree library that plays nicely with Java8 and that has no other dependencies. It also provides a loose interpretation of some ideas from functional programming and lets you map/filter/prune/search the entire tree or subtrees.https://github.com/RutledgePaulV/pruneThe implementation doesn\'t do anything special with indexing and I didn\'t stray away from recursion, so it\'s possible that with large trees performance will degrade and you could blow the stack. But if all you need is a straightforward tree of small to moderate depth, I think it works well enough. It provides a sane (value based) definition of equality and it also has a toString implementation that lets you visualize the tree!You can use TreeSet class in java.util.*. It is working like Binary search tree, so it is already sorted. TreeSet class implements Iterable, Collection and Set interfaces. You can traverse through the tree with iterator like a set. You can check, Java Doc and some other .If you\'re doing whiteboard coding, an interview, or even just planning to use a tree, the verbosity of these is all a little much.It should further be said that the reason a tree is not in there like, say, a Pair (about which the same could be said), is because you should be encapsulating your data in the class using it, and the simplest implementation looks like:That\'s really it for an arbitrary width tree.If you wanted a binary tree it\'s often easier to use with named fields:Or if you wanted a trie:Now you said you wantto be able to get all the children (some sort of list or array of Strings) given an input string representing a given nodeThat sounds like your homework.\nBut since I\'m reasonably sure any deadline has now passed\xe2\x80\xa6This gets you use like: