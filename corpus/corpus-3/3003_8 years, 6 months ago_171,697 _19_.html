I\'ve got a script \'myscript\' that outputs the following:in another script, I call:and $RESULT gets the valueIs there a way to store the result either with the newlines, or with \'\\n\' character so I can output it with \'echo -e\'?Actually, RESULT contains what you want \xe2\x80\x94 to demonstrate:What you show is what you get from:As noted in the comments, the difference is that (1) the double-quoted version of the variable (echo "$RESULT") preserves internal spacing of the value exactly as it is represented in the variable \xe2\x80\x94 newlines, tabs, multiple blanks and all \xe2\x80\x94 whereas (2) the unquoted version (echo $RESULT) replaces each sequence of one or more blanks, tabs and newlines with a single space. Thus (1) preserves the shape of the input variable, whereas (2) creates a potentially very long single line of output with \'words\' separated by single spaces (where a \'word\' is a sequence of non-whitespace characters; there needn\'t be any alphanumerics in any of the words).Another pitfall with this is that command substitution \xe2\x80\x94 $() \xe2\x80\x94 strips trailing newlines. Probably not always important, but if you really want to preserve exactly what was output, you\'ll have to use another line and some quoting:This is especially important if you want to handle all possible filenames (to avoid undefined behavior like operating on the wrong file).In addition to the answer given by @l0b0 I just had the situation where I needed to both keep any trailing newlines output by the script and check the script\'s return code.\nAnd the problem with l0b0\'s answer is that the \'echo x\' was resetting $? back to zero... so I managed to come up with this very cunning solution:In case that you\'re interested in specific lines, use a result-array:How about this, it will read each line to a variable and that can be used subsequently  !\nsay myscript output is redirected to a file called  myscript_outputAfter trying most of the solutions here, the easiest thing I found was the obvious - using a temp file. I\'m not sure what you want to do with your multiple line output, but you can then deal with it line by line using read. About the only thing you can\'t really do is easily stick it all in the same variable, but for most practical purposes this is way easier to deal with.Quick hack to make it do the requested action:Note this adds an extra line. If you work on it you can code around it, I\'m just too lazy.EDIT: While this case works perfectly well, people reading this should be aware that you can easily squash your stdin inside the while loop, thus giving you a script that will run one line, clear stdin, and exit. Like ssh will do that I think? I just saw it recently, other code examples here: https://unix.stackexchange.com/questions/24260/reading-lines-from-a-file-with-bash-for-vs-whileOne more time! This time with a different filehandle (stdin, stdout, stderr are 0-2, so we can use &3 or higher in bash).you can also use mktemp, but this is just a quick code example. Usage for mktemp looks like:Then use $filenamevar like you would the actual name of a file. Probably doesn\'t need to be explained here but someone complained in the comments.