Just started using Xcode 4.5 and I got this error in the console:Warning: Attempt to present < finishViewController: 0x1e56e0a0 > on < ViewController: 0x1ec3e000> whose view is not in the window hierarchy!The view is still being presented and everything in the app is working fine. Is this something new in iOS 6?This is the code I\'m using to change between views:Where are you calling this method from? I had an issue where I was attempting to present a modal view controller within the viewDidLoad method. The solution for me was to move this call to the viewDidAppear: method.My presumption is that the view controller\'s view is not in the window\'s view hierarchy at the point that it has been loaded (when the viewDidLoad message is sent), but it is in the window hierarchy after it has been presented (when the viewDidAppear: message is sent).CautionIf you do make a call to presentViewController:animated:completion: in the viewDidAppear: you may run into an issue whereby the modal view controller is always being presented whenever the view controller\'s view appears (which makes sense!) and so the modal view controller being presented will never go away...Maybe this isn\'t the best place to present the modal view controller, or perhaps some additional state needs to be kept which allows the presenting view controller to decide whether or not it should present the modal view controller immediately.Another potential cause:I had this issue when I was accidentally presenting the same view controller twice. (Once with performSegueWithIdentifer:sender: which was called when the button was pressed, and a second time with a segue connected directly to the button).Effectively, two segues were firing at the same time, and I got the error: Attempt to present X on Y whose view is not in the window hierarchy!viewWillLayoutSubviews and viewDidLayoutSubviews (iOS 5.0+) can be used for this purpose. They are called earlier than viewDidAppear.I\'ve also encountered this problem when I tried to present a view controller in viewDidLoad. I\'ve tried James Bedford\'s answer. It works but my app will show the background firstly for 1 or 2 seconds. After research I finally find another way to solve this is is use child view controller.For Display any  subview to main view,Please use following codeFor Dismiss any  subview from main view,Please use following codeProbably, like me, you have a wrong root viewControllerI want to display a ViewController in a non-UIViewController context,So I can\'t use such code:So, I get a UIViewController:For some reason (logical bug), the rootViewController is something other than expected (a normal UIViewController). Then I correct the bug, replacing rootViewController with a UINavigationController, and the problem is gone.My issue was I was performing the segue in UIApplicationDelegate\'s didFinishLaunchingWithOptions method before I called makeKeyAndVisible() on the window.I had the same issue. The problem was, the performSegueWithIdentifier was triggered by a notification, as soon as I put the notification on the main thread the warning message was gone. If you have AVPlayer object with played video you have to pause video first.I had the same problem. I had to embed a navigation controller and present the controller through it. Below is the sample code.It happened to me that the segue in the storybaord was some kind of broken. Deleting the segue (and creating the exact same segue again) solved the issue.In case it helps anyone, my issue was extremely silly. Totally my fault of course. A notification was triggering a method that was calling the modal. But I wasn\'t removing the notification correctly, so at some point, I would have more than one notification, so the modal would get called multiple times. Of course, after you call the modal once, the viewcontroller that calls it it\'s not longer in the view hierarchy, that\'s why we see this issue. My situation caused a bunch of other issue too, as you would expect.So to summarize, whatever you\'re doing make sure the modal is not being called more than once.I\'ve ended up with such a code that finally works to me (Swift), considering you want to display some viewController from virtually anywhere. This code will obviously crash when there is no rootViewController available, that\'s the open ending. It also does not include usually required switch to UI thread using I had this issue, and the root cause was subscribing to a button click handler (TouchUpInside) multiple times.It was subscribing in ViewWillAppear, which was being called multiple times since we had added navigation to go to another controller, and then unwind back to it.TL;DR You can only have 1 rootViewController and its the most recently presented one. So don\'t try having a viewcontroller present another viewcontroller when it\'s already presented one that hasn\'t been dismissed.After doing some of my own testing I\'ve come to a conclusion.If you have a rootViewController that you want to present everything then you can run into this problem.Here is my rootController code (open is my shortcut for presenting a viewcontroller from the root).If I call open twice in a row (regardless of time elapsed), this will work just fine on the first open, but NOT on the second open. The second open attempt will result in the error above. However if I close the most recently presented view then call open, it works just fine when I call open again (on another viewcontroller).What I have concluded is that the rootViewController of only the MOST-RECENT-CALL is on the view Hierarchy (even if you didn\'t dismiss it or remove a view). I tried playing with all the loader calls (viewDidLoad, viewDidAppear, and doing delayed dispatch calls) and I have found that the only way I could get it to work is ONLY calling present from the top most view controller. You can also get this warning when performing a segue from a view controller that is embedded in a container. The correct solution is to use segue from the parent of container, not from container\'s view controller.Have to write below line.instead of in UIViewController It\'s working fine try this.LinkWith Swift 3...Another possible cause to this, which happened to me, was having a segue from a tableViewCell to another ViewController on the Storyboard. I also used override func prepare(for segue: UIStoryboardSegue, sender: Any?) {} when the cell was clicked.I fixed this issue by making a segue from ViewController to ViewController.I just had this issue too, but it had nothing to do with the timing. I was using a singleton to handle scenes, and I set it as the presenter. In other words "Self" wasn\'t hooked up to anything. I just made its inner "scene" the new presenter and voila, it worked. (Voila loses its touch after you learn its meaning, heh).So yeah, it\'s not about "magically finding the right way", it\'s about understanding where your code stands and what it\'s doing. I\'m happy Apple gave such a plain-English warning message, even with emotion to it. Kudos to the apple dev who did that!!If other solutions does not look good for some reason, you can still use this good old workaround of presenting with the delay of 0, like this:While I\'ve seen no documented guarantee that your VC would be on the view hierarchy on the time dispatch block is scheduled to execution, I\'ve observed it would work just fine. And the best thing - this way you don\'t need to mess with boolean variable in viewDidAppear: