I have a scenario. (Windows Forms, C#, .NET)The pseudocode would look like this:CODE 1The Exception it gave wasCross-thread operation not valid: Control accessed from a thread other than the thread it was created on.To know more about this I did some googling and a suggestion came up like using the following codeCODE 2BUT BUT BUT... it seems I\'m back to square one. The Application again \nbecome nonresponsive. It seems to be due to the execution of line #1 if condition. The loading task is again done by the parent thread and not the third that I spawned.I don\'t know whether I perceived this right or wrong. I\'m new to threading.How do I resolve this and also what is the effect of execution of Line#1 if block?The situation is this: I want to load data into a global variable based on the value of a control. I don\'t want to change the value of a control from the child thread. I\'m not going to do it ever from a child thread. So only accessing the value so that the corresponding data can be fetched from the database.As per Prerak K\'s update comment (since deleted):I guess I have not presented the question properly.Situation is this: I want to load data into a global variable based on the value of a control. I don\'t want to change the value of a control from the child thread. I\'m not going to do it ever from a child thread.So only accessing the value so that corresponding data can be fetched from the database.The solution you want then should look like:Do your serious processing in the separate thread before you attempt to switch back to the control\'s thread. For example:Please read the Threading Model in UI applications in order to understand basic concepts. The link navigates to page that describes the WPF threading model. However, Windows Forms utilizes the same idea.Read answers on question How to update the GUI from another thread in C#?.\nFor C# 5.0 and .NET 4.5 the recommended solution is here.You only want to use Invoke or BeginInvoke for the bare minimum piece of work required to change the UI. Your "heavy" method should execute on another thread (e.g. via BackgroundWorker) but then using Control.Invoke/Control.BeginInvoke just to update the UI. That way your UI thread will be free to handle UI events etc.See my threading article for a WinForms example - although the article was written before BackgroundWorker arrived on the scene, and I\'m afraid I haven\'t updated it in that respect. BackgroundWorker merely simplifies the callback a bit.I have had this problem with the FileSystemWatcher and found that the following code solved the problem:fsw.SynchronizingObject = thisThe control then uses the current form object to deal with the events, and will therefore be on the same thread.Controls in .NET are not generally thread safe.  That means you shouldn\'t access a control from a thread other than the one where it lives.  To get around this, you need to invoke the control, which is what your 2nd sample is attempting.  However, in your case all you\'ve done is pass the long-running method back to the main thread.  Of course, that\'s not really what you want to do.  You need to rethink this a little so that all you\'re doing on the main thread is setting a quick property here and there.I find the check-and-invoke code which needs to be littered within all methods related to forms to be way too verbose and unneeded. Here\'s a simple extension method which lets you do away with it completely:And then you can simply do this:No more messing around - simple.The cleanest (and proper) solution for UI cross-threading issues is to use SynchronizationContext, see Synchronizing calls to the UI in a multi-threaded application article, it explains it very nicely.You need to look at the Backgroundworker example:\nhttp://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx\nEspecially how it interacts with the UI layer.  Based on your posting, this seems to answer your issues.I found a need for this while programming an iOS-Phone monotouch app controller in a visual studio winforms prototype project outside of xamarin stuidio. Preferring to program in VS over xamarin studio as much as possible, I wanted the controller to be completely decoupled from the phone framework. This way implementing this for other frameworks like Android and Windows Phone would be much easier for future uses.I wanted a solution where the GUI could respond to events without the burden of dealing with the cross threading switching code behind every button click. Basically let the class controller handle that to keep the client code simple. You could possibly have many events on the GUI where as if you could handle it in one place in the class would be cleaner. I am not a multi theading expert, let me know if this is flawed.The GUI form is unaware the controller is running asynchronous tasks.Follow the simplest (in my opinion) way to modify objects from another thread:A new look using Async/Await and callbacks.  You only need one line of code if you keep the extension method in your project.  You can add other things to the Extension method such as wrapping it in a Try/Catch statement, allowing caller to tell it what type to return after completion, an exception callback to caller:Adding Try Catch, Auto Exception Logging and CallBackHere is an alternative way if the object you are working with doesn\'t have This is useful if you are working with the main form in a class other than the main form with an object that is in the main form, but doesn\'t have InvokeRequiredIt works the same as above, but it is a different approach if you don\'t have an object with invokerequired, but do have access to the MainFormThis is not the recommended way to solve this error but you can suppress it quickly, it will do the job . I prefer this for prototypes or demos . add in Form1() constructor . For example to get the text from a Control of the UI thread:Along the same lines as previous answers,\nbut a very short addition that Allows to use all Control properties without having cross thread invokation exception.Helper MethodSample UsageSame question here\nTwo Ways \n1.] return value in e.result and use it to set yout textbox value in backgroundWorker_RunWorkerCompleted event\n\n2.] declare some variable to hold these kind of values in a separate class (which will work as data holder) . Create static instance of this class adn you can access it over any thread \nExample: