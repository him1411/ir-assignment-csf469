I\'m learning about async/await, and ran into a situation where I need to call an async method synchronously. How can I do that?Async method:Normal usage:I\'ve tried using the following: I also tried a suggestion from here, however it doesn\'t work when the dispatcher is in a suspended state.Here is the exception and stack trace from calling RunSynchronously:System.InvalidOperationExceptionMessage: RunSynchronously may not be called on a task unbound to a delegate.InnerException: nullSource: mscorlibStackTrace:Here\'s a workaround I found that works for all cases (including suspended dispatchers). It\'s not my code and I\'m still working to fully understand it, but it does work.It can be called using:customerList = AsyncHelpers.RunSync<List<Customer>>(() => GetCustomers());Code is from hereBe advised this answer is three years old. I wrote it based mostly on a experience with .Net 4.0, and very little with 4.5 especially with async-await.\nGenerally speaking it\'s a nice simple solution, but it sometimes breaks things. Please read the discussion in the comments.Just use this:See:\nTaskAwaiter,\nTask.Result,\nTask.RunSynchronouslyUse this:...or this:It\'s much simpler to run the task on the thread pool, rather than trying to trick the scheduler to run it synchronously. That way you can be sure that it won\'t deadlock. Performance is affected because of the context switch.Surprised no one mentioned this:Not as pretty as some of the other methods here, but it has the following benefits:Also, since GetAwaiter is duck-typed, this should work for any object that is returned from an async method (like ConfiguredAwaitable or YieldAwaitable), not just Tasks.I\'m learning about async/await, and ran into a situation where I need to call an async method synchronously. How can I do that?The best answer is you don\'t, with the details dependent on what the "situation" is.Is it a property getter/setter? In most cases, it\'s better to have asynchronous methods than "asynchronous properties". (For more info, see my blog post on asynchronous properties).Is this an MVVM app and you want to do asynchronous data binding? Then use something like my NotifyTask, as described in my MSDN article on asynchronous data binding.Is it a constructor? Then you probably want to consider an asynchronous factory method. (For more info, see my blog post on asynchronous constructors).There\'s almost always a better answer than to do sync-over-async.If it\'s not possible for your situation (and you know this by asking a question here describing the situation), then I\'d recommend just using synchronous code. Async all the way is best; sync all the way is second-best. Sync-over-async is not recommended.However, there are a handful of situations where sync-over-async is necessary. Specifically, you are constrained by the calling code so that you have to be sync (and have absolutely no way to re-think or re-structure your code to allow asynchrony), and you have to call async code. This is a very rare situation, but it does come up from time to time.In that case, you would need to use one of the hacks described in my article on brownfield async development, specifically:Nested message loops are the most dangerous of all the hacks, because it causes re-entrancy. Re-entrancy is extremely tricky to reason about, and (IMO) is the cause of most application bugs on Windows. In particular, if you\'re on the UI thread and you block on a work queue (waiting for the async work to complete), then the CLR actually does some message pumping for you - it\'ll actually handle some Win32 messages from within your code. Oh, and you have no idea which messages - when Chris Brumme says "Wouldn\xe2\x80\x99t it be great to know exactly what will get pumped? Unfortunately, pumping is a black art which is beyond mortal comprehension.", then we really have no hope of knowing.So, when you block like this on a UI thread, you\'re asking for trouble. Another cbrumme quote from the same article: "From time to time, customers inside or outside the company discover that we are pumping messages during managed blocking on an STA [UI thread]. This is a legitimate concern, because they know that it\xe2\x80\x99s very hard to write code that\xe2\x80\x99s robust in the face of reentrancy."Yes, it is. Very hard to write code that\'s robust in the face of reentrancy. And nested message loops force you to write code that\'s robust in the face of reentrancy. This is why the accepted (and most-upvoted) answer for this question is extremely dangerous in practice.If you are completely out of all other options - you can\'t redesign your code, you can\'t restructure it to be async - you are forced by unchangeable calling code to be sync - you can\'t change the downstream code to be sync - you can\'t block - you can\'t run the async code on a separate thread - then and only then should you consider embracing reentrancy.If you do find yourself in this corner, I would recommend using something like Dispatcher.PushFrame for WPF apps, looping with Application.DoEvents for WinForm apps, and for the general case, my own AsyncContext.Run.If I am reading your question right - the code that wants the synchronous call to an async method is executing on a suspended dispatcher thread. And you want to actually synchronously block that thread until the async method is completed.Async methods in C# 5 are powered by effectively chopping the method into pieces under the hood, and returning a Task that can track the overall completion of the whole shabang. However, how the chopped up methods execute can depend on the type of the expression passed to the await operator.Most of the time, you\'ll be using await on an expression of type Task. Task\'s implementation of the await pattern is "smart" in that it defers to the SynchronizationContext, which basically causes the following to happen:That\'s why you\'re probably running into problems - the async method implementation is trying to run the rest on the Dispatcher - even though it\'s suspended..... backing up! ....I have to ask the question, why are you trying to synchronously block on an async method? Doing so would defeat the purpose on why the method wanted to be called asynchronously. In general, when you start using await on a Dispatcher or UI method, you will want to turn your entire UI flow async. For example, if your callstack was something like the following:Then once the code has been transformed to use async, you\'ll typically end up withActually AnsweringThe AsyncHelpers class above actually works because it behaves like a nested message loop, but it installs its own parallel mechanic to the Dispatcher rather than trying to execute on the Dispatcher itself. That\'s one workaround for your problem.Another workaround is to execute your async method on a threadpool thread, and then wait for it to complete. Doing so is easy - you can do it with the following snippet:The final API will be Task.Run(...), but with the CTP you\'ll need the Ex suffixes (explanation here).This is working well for meI\'ve faced it a few times, mostly in unit testing or in a windows service development. Currently I always use this feature:It\'s simple, easy and I had no problems.The simplest way I have found to run task synchronously and without blocking UI thread is to use RunSynchronously() like:In my case, I have an event that fires when something occurs.  I dont know how many times it will occur.  So, I use code above in my event, so whenever it fires, it creates a task.  Tasks are executed synchronously and it works great for me.  I was just surprised that it took me so long to find out of this considering how simple it is.  Usually, recommendations are much more complex and error prone.  This was it is simple and clean.I found this code at Microsoft.AspNet.Identity.Core component, and it works.Just a little note - this approach:works for WinRT.Let me explain:Moreover this approach works for Windows Store solutions only!Note: This way isn\'t thread safe if you call your method inside of other async method (according to comments of @Servy)Why not create a call like:that isn\'t async.In your code, your first wait for task to execute but you haven\'t started it so it waits indefinitely. Try this:Edit:You say that you get an exception. Please post more details, including stack trace.\nMono contains the following test case:Check if this works for you. If it does not, though very unlikely, you might have some odd build of Async CTP. If it does work, you might want to examine what exactly the compiler generates and how Task instantiation is different from this sample.Edit #2:I checked with Reflector that the exception you described occurs when m_action is null. This is kinda odd, but I\'m no expert on Async CTP. As I said,  you should decompile your code and see how exactly Task is being instantiated any how come its m_action is null.P.S. What\'s the deal with the occasional downvotes? Care to elaborate?This answer is designed for anyone who is using WPF for .NET 4.5.If you attempt to execute Task.Run() on the GUI thread, then task.Wait() will hang indefinitely, if you do not have the async keyword in your function definition.This extension method solves the problem by checking to see if we are on the GUI thread, and if so, running the task on the WPF dispatcher thread.This class can act as the glue between the async/await world and the non-async/await world, in situations where it is unavoidable, such as MVVM properties or dependencies on other APIs that do not use async/await.use below code snipYou can use CoRoutines. See Caliburn.Micro implementation. I have a custom implementation here.I think the following helper method could also solve the problem.Can be used the following way:On wp8:Wrap it:Call it:Or you could just go with:For this to compile make sure you reference extension assembly:Try following code it works for me: