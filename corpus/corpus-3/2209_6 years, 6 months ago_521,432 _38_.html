I would like to run a find and replace on an HTML file through the command line.My command looks something like this:When I run this and look at the file afterward, it is empty. It deleted the contents of my file.When I run this after restoring the file again:The stdout is the contents of the file, and the find and replace has been executed.Why is this happening?When the shell sees  > index.html in the command line it opens the file index.html for writing, wiping off all its previous contents.To fix this you need to pass the -i option to sed to make the changes inline and create a backup of the original file before it does the changes in-place:Without the .bak the command will fail on some platforms, such as Mac OSX.An alternative, useful, pattern is:That has much the same effect, without using the -i option, and additionally means that, if the sed script fails for some reason, the input file isn\'t clobbered.  Further, if the edit is successful, there\'s no backup file left lying around.  This sort of idiom can be useful in Makefiles.Quite a lot of seds have the -i option, but not all of them; the posix sed is one which doesn\'t.  If you\'re aiming for portability, therefore, it\'s best avoided.This does a global in-place substitution on the file index.html. Quoting the string prevents problems with whitespace in the query and replacement.use sed\'s -i option, e.g.To change multiple files (and saving a backup of each as *.bak):will take all files in directory and replace | with x\nthis is called a \xe2\x80\x9cPerl pie\xe2\x80\x9d (easy as a pie)You should try using the option -i for in-place editing.Besides the -i option of sed\nyou can use the tee utility.From man:tee - read from standard input and write to standard output and filesSo, the solution would be:If you have a link to be added, try this. Search for the URL as above (starting with https and ending with.com here) and replace it with a URL string. I have used a variable $pub_url here. s here means search and g means global replacement. It works !And the ed answer: To reiterate what codaddict answered, the shell handles the redirection first, wiping out the "input.html" file, and then the shell invokes the "sed" command passing it a now empty file. The problem with the commandis that file is truncated by the shell before sed actually gets to process it. As a result, you get an empty file. The sed way to do this is to use -i to edit in place, as other answers suggested. However, this is not always what you want. -i will create a temporary file that will then be used to replace the original file. This is problematic if your original file was a link (the link will be replaced by a regular file). If you need to preserve links, you can use a temporary variable to store the output of sed before writing it back to the file, like this:Better yet, use printf instead of echo since echo is likely to process \\\\ as \\ in some shells (e.g. dash):You can use Vim in Ex mode:% select all linesx save and closeI was searching for the option where I can define the line range and found the answer. For example I want to change host1 to host2 from line 36-57. You can use gi option as well to ignore the character case. With all due respect to the above correct answers, it\'s always a good idea to  "dry run" scripts like that, so that you don\'t corrupt your file and have to start again from scratch.Just get your script to spill the output to the command line instead of writing it to the file, for example, like that:ORThis way you can see and check the output of the command without getting your file truncated.