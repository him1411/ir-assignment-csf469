I have two iterables in Python, and I want to go over them in pairs:It should result in:One way to do it is to iterate over the indices:But that seems somewhat unpythonic to me. Is there a better way to do it?zip stops when the shorter of foo or bar stops.In Python 2, zip\nreturns a list of tuples. This is fine when foo and bar are not massive. If\nthey are both massive then forming zip(foo,bar) is an unnecessarily massive\ntemporary variable, and should be replaced by itertools.izip or\nitertools.izip_longest, which returns an iterator instead of a list.izip stops when either foo or bar is exhausted.\nizip_longest stops when both foo and bar are exhausted.\nWhen the shorter iterator(s) are exhausted, izip_longest yields a tuple with None in the position corresponding to that iterator. You can also set a different fillvalue besides None if you wish. See here for the full story.In Python 3, zip\nreturns an iterator of tuples, like itertools.izip in Python2.  To get a list\nof tuples, use list(zip(foo, bar)). And to zip until both iterators are\nexhausted, you would use\nitertools.zip_longest.Note also that zip and its zip-like brethen can accept an arbitrary number of iterables as arguments. For example,printsYou want the zip function.The builtin zip does exactly what you want. If you want the same over iterables instead of lists you could look at itertools.izip which does the same thing but gives results one at a time.What you\'re looking for is called zip.You should use \'zip\' function. Here is an example how your own zip function can look likezip function solves the issue\nDocs: ZIP Library functionAIM: To put the output side by side\nProblem:Output:\n     review1\n     review2\n     review3\n     date1\n     date2\n     date3Solution:Output:\nreview1:date1\nreview2:date2\nreview3:date3