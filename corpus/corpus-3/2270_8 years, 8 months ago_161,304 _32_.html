I am trying to build the search for a Django site I am building, and in the search I am searching in 3 different models. And to get pagination on the search result list I would like to use a generic object_list view to display the results. But to do that i have to merge 3 querysets into one.How can i do that? I\'ve tried this:But this doesn\'t work I get an error when I try to use that list in the generic view. The list is missing the clone attribute.Anybody know how I can merge the three lists, page_list, article_list and post_list?Concatenating the querysets into a list is the simplest approach. If the database will be hit for all querysets anyway (e.g. because the result needs to be sorted), this won\'t add further cost.Using itertools.chain is faster than looping each list and appending elements one by one, since itertools is implemented in C. It also consumes less memory than converting each queryset into a list before concatenating.Now it\'s possible to sort the resulting list e.g. by date (as requested in hasen j\'s comment to another answer). The sorted() function conveniently accepts a generator and returns a list:If you\'re using Python 2.4 or later, you can use attrgetter instead of a lambda. I remember reading about it being faster, but I didn\'t see a noticeable speed difference for a million item list.Try this:Retains all the functions of the querysets which is nice if you want to order_by or similar.Oops, please note that this doesn\'t work on querysets from two different models...You can use the QuerySetChain class below. When using it with Django\'s paginator, it should only hit the database with COUNT(*) queries for all querysets and SELECT() queries only for those querysets whose records are displayed on the current page.Note that you need to specify template_name= if using a QuerySetChain with generic views, even if the chained querysets all use the same model.In your example, the usage would be:Then use matches with the paginator like you used result_list in your example.The itertools module was introduced in Python 2.3, so it should be available in all Python versions Django runs on.Related, for mixing querysets from the same model, or for similar fields from a few models, Starting with Django 1.11 a qs.union() method is also available:union()New in Django 1.11. Uses SQL\xe2\x80\x99s UNION operator to combine the results of two or more QuerySets. For example:The UNION operator selects only distinct values by default. To allow duplicate values, use the all=True\n  argument.union(), intersection(), and difference() return model instances of\n  the type of the first QuerySet even if the arguments are QuerySets of\n  other models. Passing different models works as long as the SELECT\n  list is the same in all QuerySets (at least the types, the names don\xe2\x80\x99t\n  matter as long as the types in the same order).In addition, only LIMIT, OFFSET, and ORDER BY (i.e. slicing and\n  order_by()) are allowed on the resulting QuerySet. Further, databases\n  place restrictions on what operations are allowed in the combined\n  queries. For example, most databases don\xe2\x80\x99t allow LIMIT or OFFSET in\n  the combined queries.https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.unionThe big downside of your current approach is its inefficiency with large search result sets, as you have to pull down the entire result set from the database each time, even though you only intend to display one page of results.In order to only pull down the objects you actually need from the database, you have to use pagination on a QuerySet, not a list.  If you do this, Django actually slices the QuerySet before the query is executed, so the SQL query will use OFFSET and LIMIT to only get the records you will actually display.  But you can\'t do this unless you can cram your search into a single query somehow.Given that all three of your models have title and body fields, why not use model inheritance?  Just have all three models inherit from a common ancestor that has title and body, and perform the search as a single query on the ancestor model.In case you want to chain a lot of querysets, try this:where: docs is a list of querysetsQuoted from https://groups.google.com/forum/#!topic/django-users/6wUNuJa4jVw. See Alex Gaynor Looks like t_rybik has created a comprehensive solution at http://www.djangosnippets.org/snippets/1933/For searching it\'s better to use dedicated solutions like Haystack - it\'s very flexible.here\'s an idea... just pull down one full page of results from each of the three and then throw out the 20 least useful ones... this eliminates the large querysets and that way you only sacrifice a little performance instead of a lot