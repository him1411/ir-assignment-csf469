In JavaScript, I want to create an object instance (via the new operator), but pass an arbitrary number of arguments to the constructor. Is this possible?What I want to do is something like this (but the code below does not work):The AnswerFrom the responses here, it became clear that there\'s no built-in way to call .apply() with the new operator. However, people suggested a number of really interesting solutions to the problem.My preferred solution was this one from Matthew Crumley (I\'ve modified it to pass the arguments property):With ECMAScript5\'s Function.prototype.bind things get pretty clean:It can be used as follows:or even directly:This and the eval-based solution are the only ones that always work, even with special constructors like Date:editA bit of explanation: \nWe need to run new on a function that takes a limited number of arguments. The bind method allows us to do it like so:The anything parameter doesn\'t matter much, since the new keyword resets f\'s context. However, it is required for syntactical reasons. Now, for the bind call: We need to pass a variable number of arguments, so this does the trick:Let\'s wrap that in a function. Cls is passed as arugment 0, so it\'s gonna be our anything.Actually, the temporary f variable is not needed at all:Finally, we should make sure that bind is really what we need. (Cls.bind may have been overwritten). So replace it by Function.prototype.bind, and we get the final result as above.Here\'s a generalized solution that can call any constructor (except native constructors that behave differently when called as functions, like String, Number, Date, etc.) with an array of arguments:An object created by calling construct(Class, [1, 2, 3]) would be identical to an object created with new Class(1, 2, 3).You could also make a more specific version so you don\'t have to pass the constructor every time. This is also slightly more efficient, since it doesn\'t need to create a new instance of the inner function every time you call it.The reason for creating and calling the outer anonymous function like that is to keep function F from polluting the global namespace. It\'s sometimes called the module pattern.[UPDATE]For those who want to use this in TypeScript, since TS gives an error if F returns anything:Suppose you\'ve got an Items constructor which slurps up all the arguments you throw at it:You can create an instance with Object.create() and then .apply() with that instance:Which when run prints 10 since 1 + 2 + 3 + 4 == 10:If your environment supports ECMA Script 2015\'s spread operator (...), you can simply use it like thisNote: Now that the ECMA Script 2015\'s specifications are published and most JavaScript engines are actively implementing it, this would be the preferred way of doing this.You can check the Spread operator\'s support in few of the major environments, here.@Matthew\nI think it\'s better to fix the constructor property also.In ES6, Reflect.construct() is quite convenient:You could move the init stuff out into a separate method of Something\'s prototype:An improved version of @Matthew\'s answer. This form has the slight performance benefits obtained by storing the temp class in a closure, as well as the flexibility of having one function able to be used to create any classThis would be used by calling applyCtor(class, [arg1, arg2, argn]);This answer is a little late, but figured anyone who sees this might be able to use it. There is a way to return a new object using apply. Though it requires one little change to your object declaration.For the first if statement to work in testNew you have to return this; at the bottom of the function. So as an example with your code:Update: I\'ve changed my first example to sum any number of arguments, instead of just two.I just came across this problem, and I solved it like this: Yeah, it\'s a bit ugly, but it solves the problem, and it\'s dead simple.if you\'re interested in an eval-based solutionSee also how CoffeeScript does it.s = new Something([a,b,c]...)becomes:This constructor approach works both with and without the new keyword:It assumes support for Object.create but you could always polyfill that if you\'re supporting older browsers. See the support table on MDN here.Here\'s a JSBin to see it in action with console output.This works!You can\'t call a constructor with a variable number of arguments like you want with the new operator.What you can do is change the constructor slightly. Instead of:Do this instead:Or if you must use an array:Matthew Crumley\'s solutions in CoffeeScript:orIf your target browser doesn\'t support ECMAScript 5 Function.prototype.bind, the code won\'t work. It is not very likely though, see compatibilty table.modified @Matthew answer. Here I can pass any number of parameters to function as usual (not array). Also \'Something\' is not hardcoded into:This one-liner should do it:Solution without ES6 or polyfills:\noutput\n\nDemo {arg1: "X", arg2: "Y", arg3: "Z"}\n\n\n... or "shorter" way:\nedit:\nI think this might be a good solution:It\'s also intresting to see how the issue of reusing the temporary F() constructor, was addressed by using arguments.callee, aka the creator/factory function itself:\nhttp://www.dhtmlkitchen.com/?category=/JavaScript/&date=2008/05/11/&entry=Decorator-Factory-AspectAny function (even a constructor) can take a variable number of arguments. Each function has an "arguments" variable which can be cast to an array with [].slice.call(arguments).The above tests produce the following output:Here is my version of createSomething:Based on that, I tried to simulate the new keyword of JavaScript: I tested it and it seems that it works perfectly fine for all scenarios. It also works on native constructors like Date. Here are some tests:While the other approaches are workable, they\'re unduly complex.  In Clojure you generally create a function that instantiates types/records and use that function as the mechanism for instantiation.  Translating this to JavaScript:By taking this approach you avoid the use of new except as described above.  And this function, of course, has no issues working with apply or any number of other functional programming features.By using this approach, all of your type constructors (e.g. Person) are vanilla, do-nothing constructors.  You just pass in arguments and assign them to properties of the same name.  The hairy details go in the constructor function (e.g. person).It is of little bother having to create these extra constructor functions since they are a good practice anyhow.  They can be convenient since they allow you to potentially have several constructor functions with different nuances.Yes we can, javascript is more of prototype inheritance in nature.when we create an object with "new" then our created object INHERITS getAge(), But if we used apply(...) or call(...) to call Actor, then we are passing an object for "this" but the object we pass WON\'T inherit from Actor.prototypeunless, we directly pass apply or call Actor.prototype but then.... "this" would point to "Actor.prototype" and this.name would write to: Actor.prototype.name. Thus affecting all other objects created with Actor...since we overwrite the prototype rather than the instanceLet\'s try with applyBy passing Actor.prototype to Actor.call() as the first argument, when the Actor() function is ran, it executes this.name=name, Since "this" will point to Actor.prototype, this.name=name; means Actor.prototype.name=name;Coming back to orginal question how to use new operator with apply, here is my take.... since ES6 this is possible through the Spread operator, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator#Apply_for_newThis answer was already, sort of given in comment https://stackoverflow.com/a/42027742/7049810, but seems to have been missed by mostThanks to posts here I\'ve used it this way:and implementation:As a late answer I though I would just drop this here as a more complete solution using many of the principals already outlined here. Implements.jsTo get you started, here is a basic usage:why do you make the things so complex. After new use anonymous function which returns the constructor function with applied array with arguments.