I  currently have a local Git repository, which I push to a Github repository.The local repository has ~10 commits, and the Github repository is a synchronised duplicate of this.What I\'d like to do is remove ALL the version history from the local Git repository, so the current contents of the repository appear as the only commit (and therefore older versions of files within the repository are not stored). I\'d then like to push these changes to Github.I have investigated Git rebase, but this appears to be more suited to removing specific versions.\nAnother potential solution is to delete the local repo, and create a new one - though this would probably create a lot of work!ETA: There are specific directories / files that are untracked - if possible I would like to maintain the untracking of these files.Here\'s the brute-force approach. It also removes the configuration of the repository.Note: This does NOT work if the repository has submodules! If you are using submodules, you should use e.g. interactive rebaseStep 1: remove all history (Make sure you have backup, this cannot be reverted)Step 2: reconstruct the Git repo with only the current contentStep 3: push to GitHub.The only solution that works for me (and keeps submodules working) isDeleting .git/ always causes huge issues when I have submodules.\nUsing git rebase --root would somehow cause conflicts for me (and take long since I had a lot of history).This is my favoured approach:This will create a new branch with one commit that adds everything in HEAD. It doesn\'t alter anything else, so it\'s completely safe.The other option, which could turn out to be a lot of work if you have a lot of commits, is an interactive rebase (assuming your git version is >=1.7.12):git rebase --root -iWhen presented with a list of commits in your editor:Save and close. Git will start rebasing. At the end you would have a new root commit that is a combination of all the ones that came after it.The advantage is that you don\'t have to delete your repository and if you have second thoughts you always have a fallback.If you really do want to nuke your history, reset master to this commit and delete all other branches.Variant of larsmans\'s proposed method:Save your untrackfiles list:Save your git configuration:Then perform larsmans\'s first steps:Restore your config:Untrack you untracked files:Then commit:And finally push to your repository:You could use shallow clones (git > 1.9):Further reading: http://blogs.atlassian.com/2014/05/handle-big-repositories-git/Create a branch, copy all the contents to it, commit it and then delete the master branch:The method below is exactly reproducible, so there\'s no need to run clone again if both sides were consistent, just run the script on the other side too.If you then want to clean it up, try this script:http://sam.nipl.net/b/git-gc-all-ferociousI wrote a script which "kills history" for each branch in the repository:http://sam.nipl.net/b/git-kill-historysee also: http://sam.nipl.net/b/confirmThis will remove all local branches and tags, make a single no-history commit with the state of your current checkout on whatever branch is current, and leave everything else about your repo untouched.  You can then force-push to your remotes as you like.What I\'d like to do is remove ALL the version history from the local Git repository, so the current contents of the repository appear as the only commit (and therefore older versions of files within the repository are not stored). A more conceptual answer:git automatically garbage collects old commits if no tags/branches/refs point to them. So you simply have to remove all tags/branches and create a new orphan commit, associated with any branch - by convention you would let the branch master point to that commit.The old, unreachable commits will then never again be seen by anyone unless they go digging with low-level git commands. If that is enough for you, I would just stop there and let the automatic GC do it\'s job whenever it wishes to. If you want to get rid of them right away, you can use git gc (possibly with --aggressive --prune=all). For the remote git repository, there\'s no way for you to force that though, unless you have shell access to their file system.To remove the last commit from git, you can simply run If you are removing multiple commits from the top, you can run to remove the last two commits. You\n  can increase the number to remove even more commits.More info here.Git tutoturial here provides help on how to purge repository:you want to remove the file from history and add it to the .gitignore\n  to ensure it is not accidentally re-committed. For our examples, we\'re\n  going to remove Rakefile from the GitHub gem repository.Now that we\'ve erased the file from history, let\'s ensure that we\n  don\'t accidentally commit it again.If you\'re happy with the state of the repository, you need to\n  force-push the changes to overwrite the remote repository.I solved a similar issue by just deleting the .git folder from my project and reintegrating with version control through IntelliJ. \nNote: The .git folder is hidden. You can view it in the terminal with ls -a , and then remove it using rm -rf .git .For that use Shallow Clone command \ngit clone --depth 1 URL - It will clones only the current HEAD of the repository