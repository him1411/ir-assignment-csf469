How do I determine whether or not two lines intersect, and if they do, at what x,y point?There\xe2\x80\x99s a nice approach to this problem that uses vector cross products.  Define the 2-dimensional vector cross product v\xc2\xa0\xc3\x97\xc2\xa0w to be vx\xc2\xa0wy\xc2\xa0\xe2\x88\x92\xc2\xa0vy\xc2\xa0wx.Suppose the two line segments run from p to p\xc2\xa0+\xc2\xa0r and from q to q\xc2\xa0+\xc2\xa0s.  Then any point on the first line is representable as p\xc2\xa0+\xc2\xa0t\xc2\xa0r (for a scalar parameter\xc2\xa0t) and any point on the second line as q\xc2\xa0+\xc2\xa0u\xc2\xa0s (for a scalar parameter\xc2\xa0u).The two lines intersect if we can find t and u such that:p + t\xc2\xa0r = q + u\xc2\xa0sCross both sides with s, getting(p + t\xc2\xa0r) \xc3\x97 s = (q + u\xc2\xa0s) \xc3\x97 sAnd since s\xc2\xa0\xc3\x97\xc2\xa0s = 0, this meanst\xc2\xa0(r \xc3\x97 s) = (q \xe2\x88\x92 p) \xc3\x97 sAnd therefore, solving for t:t = (q \xe2\x88\x92 p) \xc3\x97 s / (r \xc3\x97 s)In the same way, we can solve for u:(p + t\xc2\xa0r) \xc3\x97 r = (q + u\xc2\xa0s) \xc3\x97 ru\xc2\xa0(s \xc3\x97 r) = (p \xe2\x88\x92 q) \xc3\x97 ru = (p \xe2\x88\x92 q) \xc3\x97 r / (s \xc3\x97 r)To reduce the number of computation steps, it\'s convenient to rewrite this as follows (remembering that s\xc2\xa0\xc3\x97\xc2\xa0r = \xe2\x88\x92\xc2\xa0r\xc2\xa0\xc3\x97\xc2\xa0s):u = (q \xe2\x88\x92 p) \xc3\x97 r / (r \xc3\x97 s)Now there are four cases:If r\xc2\xa0\xc3\x97\xc2\xa0s\xc2\xa0=\xc2\xa00 and (q\xc2\xa0\xe2\x88\x92\xc2\xa0p)\xc2\xa0\xc3\x97\xc2\xa0r\xc2\xa0=\xc2\xa00, then the two lines are collinear.In this case, express the endpoints of the second segment (q and q\xc2\xa0+\xc2\xa0s) in terms of the equation of the first line segment (p + t r):t0 = (q \xe2\x88\x92 p)\xc2\xa0\xc2\xb7\xc2\xa0r / (r\xc2\xa0\xc2\xb7\xc2\xa0r)t1 = (q + s \xe2\x88\x92 p)\xc2\xa0\xc2\xb7\xc2\xa0r / (r\xc2\xa0\xc2\xb7\xc2\xa0r) = t0 + s\xc2\xa0\xc2\xb7\xc2\xa0r / (r\xc2\xa0\xc2\xb7\xc2\xa0r)If the interval between t0 and t1 intersects the interval [0, 1] then the line segments are collinear and overlapping; otherwise they are collinear and disjoint.Note that if s and r point in opposite directions, then s\xc2\xa0\xc2\xb7\xc2\xa0r < 0 and so the interval to be checked is [t1, t0] rather than [t0, t1].If r\xc2\xa0\xc3\x97\xc2\xa0s\xc2\xa0=\xc2\xa00 and (q\xc2\xa0\xe2\x88\x92\xc2\xa0p)\xc2\xa0\xc3\x97\xc2\xa0r\xc2\xa0\xe2\x89\xa0\xc2\xa00, then the two lines are parallel and non-intersecting.If r\xc2\xa0\xc3\x97\xc2\xa0s\xc2\xa0\xe2\x89\xa0\xc2\xa00 and 0\xc2\xa0\xe2\x89\xa4\xc2\xa0t\xc2\xa0\xe2\x89\xa4\xc2\xa01 and 0\xc2\xa0\xe2\x89\xa4\xc2\xa0u\xc2\xa0\xe2\x89\xa4\xc2\xa01, the two line segments meet at the point p + t\xc2\xa0r = q + u\xc2\xa0s.Otherwise, the two line segments are not parallel but do not intersect.Credit: this method is the 2-dimensional specialization of the 3D line intersection algorithm from the article "Intersection of two lines in three-space" by Ronald Goldman, published in Graphics Gems, page 304. In three dimensions, the usual case is that the lines are skew (neither parallel nor intersecting) in which case the method gives the points of closest approach of the two lines.FWIW, the following function (in C) both detects line intersections and determines the intersection point. It is based on an algorithm in Andre LeMothe\'s "Tricks of the Windows Game Programming Gurus". It\'s not dissimilar to some of the algorithm\'s in other answers (e.g. Gareth\'s). LeMothe then uses Cramer\'s Rule (don\'t ask me) to solve the equations themselves.I can attest that it works in my feeble asteroids clone, and seems to deal correctly with the edge cases described in other answers by Elemental, Dan and Wodzu. It\'s also probably faster than the code posted by KingNestor because it\'s all multiplication and division, no square roots!I guess there\'s some potential for divide by zero in there, though it hasn\'t been an issue in my case. Easy enough to modify to avoid the crash anyway.BTW, I must say that in LeMothe\'s book, though he apparently gets the algorithm right, the concrete example he shows plugs in the wrong numbers and does calculations wrong. For example:(4 * (4 - 1) + 12 * (7 - 1)) / (17 * 4 + 12 * 10) = 844/0.88 = 0.44That confused me for hours. :(The problem reduces to this question: Do two lines from A to B and from C to D intersect?  Then you can ask it four times (between the line and each of the four sides of the rectangle).Here\'s the vector math for doing it.  I\'m assuming the line from A to B is the line in question and the line from C to D is one of the rectangle lines.  My notation is that Ax is the "x-coordinate of A" and Cy is the "y-coordinate of C."  And "*" means dot-product, so e.g. A*B = Ax*Bx + Ay*By.This h number is the key.  If h is between 0 and 1, the lines intersect, otherwise they don\'t.  If F*P is zero, of course you cannot make the calculation, but in this case the lines are parallel and therefore only intersect in the obvious cases.The exact point of intersection is C + F*h.More Fun:If h is exactly 0 or 1 the lines touch at an end-point.  You can consider this an "intersection" or not as you see fit.Specifically, h is how much you have to multiply the length of the line in order to exactly touch the other line.Therefore, If h<0, it means the rectangle line is "behind" the given line (with "direction" being "from A to B"), and if h>1 the rectangle line is "in front" of the given line.Derivation:A and C are vectors that point to the start of the line; E and F are the vectors from the ends of A and C that form the line.For any two non-parallel lines in the plane, there must be exactly one pair of scalar g and h such that this equation holds:Why?  Because two non-parallel lines must intersect, which means you can scale both lines by some amount each and touch each other.(At first this looks like a single equation with two unknowns!  But it isn\'t when you consider that this is a 2D vector equation, which means this is really a pair of equations in x and y.)We have to eliminate one of these variables.  An easy way is to make the E term zero.  To do that, take the dot-product of both sides of the equation using a vector that will dot to zero with E.  That vector I called P above, and I did the obvious transformation of E.You now have:I have tried to implement the algorithm so elegantly described by Jason above; unfortunately while working though the mathematics in the debugging I found many cases for which it doesn\'t work.For example consider the points A(10,10) B(20,20) C(10,1) D(1,10) gives h=.5 and yet it is clear by examination that these segments are no-where near each other. Graphing this makes it clear that 0 < h < 1 criteria only indicates that the intercept point would lie on CD if it existed but tells one nothing of whether that point lies on AB.\nTo ensure that there is a cross point you must do the symmetrical calculation for the variable g and the requirement for interception is:\n0 < g < 1 AND 0 < h < 1Here\'s an improvement to Gavin\'s answer. marcp\'s solution is similar also, but neither postpone the division.This actually turns out to be a practical application of Gareth Rees\' answer as well, because the cross-product\'s equivalent in 2D is the perp-dot-product, which is what this code uses three of. Switching to 3D and using the cross-product, interpolating both s and t at the end, results in the two closest points between the lines in 3D.\nAnyway, the 2D solution:Basically it postpones the division until the last moment, and moves most of the tests until before certain calculations are done, thereby adding early-outs. Finally, it also avoids the division by zero case which occurs when the lines are parallel.You also might want to consider using an epsilon test rather than comparison against zero. Lines that are extremely close to parallel can produce results that are slightly off. This is not a bug, it is a limitation with floating point math.I have searched for the same topic, and I wasn\'t happy with the answers. So I have written an article that explains very detailed how to check if two line segments intersect with a lot of images. There is complete (and tested) Java-code.Here is the article, cropped to the most important parts:The algorithm, that checks if line segment a intersects with line segment b, looks like this:What are bounding boxes? Here are two bounding boxes of two line segments:If both bounding boxes have an intersection, you move line segment a so that one point is at (0|0). Now you have a line through the origin defined by a. Now move line segment b the same way and check if the new points of line segment b are on different sides of line a. If this is the case, check it the other way around. If this is also the case, the line segments intersect. If not, they don\'t intersect.You know that two line segments a and b intersect. If you don\'t know that, check it with the tools I gave you in "Question C".Now you can go through some cases and get the solution with 7th grade math (see code and interactive example).Let\'s say your point A = (x1, y1), point B = (x2, y2), C = (x_3, y_3), D = (x_4, y_4).\nYour first line is defined by AB (with A != B), and your second one by CD (with C != D).Check with Question B if they intersect at all.The lines a and b are defined by two points for each line.\nYou can basically apply the same logic was used in Question A.The answer once accepted here is incorrect (it has since been unaccepted, so hooray!).  It does not correctly eliminate all non-intersections.  Trivially it may appear to work but it can fail, especially in the case that 0 and 1 are considered valid for h.Consider the following case:Lines at (4,1)-(5,1) and (0,0)-(0,2)These are perpendicular lines which clearly do not overlap.A=(4,1)\nB=(5,1)\nC=(0,0)\nD=(0,2)\nE=(5,1)-(4,1)=(-1,0)\nF=(0,2)-(0,0)=(0,-2)\nP=(0,1)\nh=((4,1)-(0,0)) dot (0,1) / ((0,-2) dot (0,1)) = 0\nAccording to the above answer, these two line segments meet at an endpoint (values of 0 and 1).  That endpoint would be:(0,0)+(0,-2)*0=(0,0)So, apparently the two line segments meet at (0,0), which is on line CD, but not on line AB.  So what is going wrong?  The answer is that the values of 0 and 1 are not valid and only sometimes HAPPEN to correctly predict endpoint intersection.  When the extension of one line (but not the other) would meet the line segment, the algorithm predicts an intersection of line segments, but this is not correct.  I imagine that by testing starting with AB vs CD and then also testing with CD vs AB, this problem would be eliminated.  Only if both fall between 0 and 1 inclusively can they be said to intersect.I recommend using the vector cross product method if you must predict end-points.-DanPython version of iMalc\'s answer:Just wanted to mention that a good explanation and explicit solution can be found in the Numeric Recipes series. I\'ve got the 3rd edition and the answer is on page 1117, section 21.4. Another solution with a different nomenclature can be found in a paper by Marina Gavrilova Reliable Line Section Intersection Testing. Her solution is, to my mind, a little simpler.My implementation is below:Based on Gareth Rees\' answerMany of the functions and structs are private, but you should pretty easy be able to know what\'s going on. \nThis is public on this repo https://github.com/hfossli/AGGeometryKit/This is working well for me.  Taken from here.Plenty of solutions are available above, but I think below solution is pretty simple and easy to understand.Two segments Vector AB and Vector CD intersect if and only ifMore specifically a and b are on opposite side of segment CD if and only if exactly one of the two triples a,c,d and b,c,d is in counterclockwise order.Here CCW represent counterclockwise which returns true/false based on the orientation of the points.Source : http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\nPage 2I tried some of these answers, but they didnt work for me (sorry guys); after some more net searching I found this.With a little modification to his code I now have this function that will return the point of intersection or if no intersection is found it will return -1,-1.I think there is a much much simpler solution for this problem. I came up with another idea today and it seems to work just fine (at least in 2D for now). All you have to do, is to calculate the intersection between two lines, then check if the calculated intersection point is within the boundig boxes of both line segments. If it is, the line segments intersect. That\'s it.EDIT:This is how I calculate the intersection (I don\'t know anymore where I found this code snippet)comes fromand this is my (simplified for the purpose of the answer) BoundingBox class:I have tried lots of the other answers here and most are riddled with mistakes. The code provided below is what I use for programming competitions, meaning it has been tested against judge data. This code works. Yes it is a little long but it is well documented. Essentially with segment to segment intersection three things can happen:1) The segments do not intersect 2) There is a unique intersection point3) The intersection is another segment This code will account for all three cases.IMPORTANT NOTE: This code has only been tested against integer coordinates. It *should* work for real numbers but I have not tested so myself.Here is a simple usage example:This solution may helpI tried lot of ways and then I decided to write my own. So here it is:Based on these two formulas: (I simplified them from equation of lines and other formulas)This based on Gareth Ree\'s answer. It also returns the overlap of the line segments if they do. Coded in C++, V is a simple vector class. Where the cross product of two vectors in 2D returns a single scalar. It was tested and passed by my schools automatic testing system.I ported Kris\'s above answer to JavaScript. After trying numerous different answers, his provided the correct points. I thought I was going crazy that I wasn\'t getting the points I needed.Here\'s a basic implementation of a line segment in C#, with corresponding intersection detection code.  It requires a 2D vector/point struct called Vector2f, though you can replace this with any other type that has X/Y properties. You could also replace float with double if that suits your needs better.This code is used in my .NET physics library, Boing.There seems to be some interest in Gavin\'s answer for which cortijon proposed a javascript version in the comments and iMalc provided a version with slightly fewer computations.  Some have pointed out shortcomings with various code proposals and others have commented on the efficiency of some code proposals.The algorithm provided by iMalc via Gavin\'s answer is the one that I am currently using in a javascript project and I just wanted to provide a cleaned up version here if it may help anyone.If each side of the rectangle is a line segment, and the user drawn portion is a line segment, then you need to just check the user drawn segment for intersection with the four side line segments. This should be a fairly simple exercise given the start and end points of each segment.A C++ program to check if two given line segments intersectBased on t3chb0t\'s answer:I read these algorithm from the book "multiple view geometry"following text using\' as transpose sign* as dot productx as cross product, when using as operatora point x_vec = (x, y)\' lies on the line ax + by + c = 0we denote L = (a, b, c)\', the point as (x, y, 1)\' as homogeneous coordinatesthe line equation can be written as(x, y, 1)(a, b, c)\' = 0 or x\' * L = 0we have two lines L1=(a1, b1, c1)\', L2=(a2, b2, c2)\'assume x is a point, a vector, and x = L1 x L2 (L1 cross product L2). be careful, x is always a 2D point, please read homogeneous coordinates if you are confused about (L1xL2) is a three elements vector, and x is a 2D coordinates.according to triple product, we know thatL1 * ( L1 x L2 ) = 0, and L2 * (L1 x L2) = 0, because of L1,L2 co-planewe substitute (L1xL2) with vector x, then we have L1*x=0, L2*x=0, which means x lie on both L1 and L2, x is the intersection point.be careful, here x is homogeneous coordinates, if the last element of x is zero, it means L1 and L2 are parallel.Based on @Gareth Rees answer, version for Python:Many answers have wrapped up all the calculations into a single function. If you need to calculate the line slopes, y-intercepts, or x-intercepts for use elsewhere in your code, you\'ll be making those calculations redundantly. I have separated out the respective functions, used obvious variable names, and commented my code to make it easier to follow. I needed to know if lines intersect infinitely beyond their endpoints, so in JavaScript:http://jsfiddle.net/skibulk/evmqq00u/