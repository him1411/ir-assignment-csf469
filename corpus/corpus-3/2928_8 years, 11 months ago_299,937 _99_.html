A strict equality operator will tell you if two object types are equal. However, is there a way to tell if two objects are equal, much like the hash code value in Java?Stack Overflow question Is there any kind of hashCode function in JavaScript? is similar to this question, but requires a more academic answer. The scenario above demonstrates why it would be necessary to have one, and I\'m wondering if there is any equivalent solution.The short answerThe simple answer is: No, there is no generic means to determine that an object is equal to another in the sense you mean. The exception is when you are strictly thinking of an object being typeless.The long answerThe concept is that of an Equals method that compares two different instances of an object to indicate whether they are equal at a value level. However, it is up to the specific type to define how an Equals method should be implemented. An iterative comparison of attributes that have primitive values may not be enough, there may well be attributes which are not to be considered part of the object value. For example,In this above case, c is not really important to determine whether any two instances of MyClass are equal, only a and b are important. In some cases c might vary between instances and yet not be significant during comparison. Note this issue applies when members may themselves also be instances of a type and these each would all be required to have a means of determining equality.Further complicating things is that in JavaScript the distinction between data and method is blurred.An object may reference a method that is to be called as an event handler, and this would likely not be considered part of its \'value state\'. Whereas another object may well be assigned a function that performs an important calculation and thereby makes this instance different from others simply because it references a different function.What about an object that has one of its existing prototype methods overridden by another function? Could it still be considered equal to another instance that it otherwise identical? That question can only be answered in each specific case for each type.As stated earlier, the exception would be a strictly typeless object. In which case the only sensible choice is an iterative and recursive comparison of each member. Even then one has to ask what is the \'value\' of a function?Why reinvent the wheel? Give Lodash a try. It has a number of must-have functions such as isEqual().It will brute force check each key value - just like the other examples on this page - using ECMAScriptÂ 5 and native optimizations if they\'re available in the browser.Note: Previously this answer recommended Underscore.js, but lodash has done a better job of getting bugs fixed and addressing issues with consistency.The default equality operator in JavaScript for Objects yields true when they refer to the same location in memory.If you require a different equality operator you\'ll need to add an equals(other) method, or something like it to your classes and the specifics of your problem domain will determine what exactly that means.Here\'s a playing card example:If you are working in AngularJS, the angular.equals function will determine if two objects are equal. In Ember.js use isEqual.If you are using a JSON library, you can encode each object as JSON, then compare the resulting strings for equality.NOTE: While this answer will work in many cases, as several people have pointed out in the comments it\'s problematic for a variety of reasons. In pretty much all cases you\'ll want to find a more robust solution.This is my version. It is using new Object.keys feature that is introduced in ES5 and ideas/tests from +, + and +:If you have a deep copy function handy, you can use the following trick to still use JSON.stringify while matching the order of properties:Demo: http://jsfiddle.net/CU3vb/3/Rationale:Since the properties of obj1 are copied to the clone one by one, their order in the clone will be preserved. And when the properties of obj2 are copied to the clone, since properties already existing in obj1 will simply be overwritten, their orders in the clone will be preserved.Are you trying to test if two objects are the equal? ie: their properties are equal?If this is the case, you\'ll probably have noticed this situation:you might have to do something like this:Obviously that function could do with quite a bit of optimisation, and the ability to do deep checking (to handle nested objects: var a = { foo : { fu : "bar" } }) but you get the idea.As FOR pointed out, you might have to adapt this for your own purposes, eg: different classes may have different definitions of "equal". If you\'re just working with plain objects, the above may suffice, otherwise a custom MyClass.equals() function may be the way to go.In Node.js, you can use its native require("assert").deepEqual. More info: \nhttp://nodejs.org/api/assert.htmlFor example:Another example that returns true / false instead of returning errors:Short functional deepEqual implementation:Edit: version 2, using jib\'s suggestion and ES6 arrow functions:A simple solution to this issue that many people don\'t realize is to sort the JSON strings (per character). This is also usually faster than the other solutions mentioned here:Another useful thing about this method is you can filter comparisons by passing a "replacer" function to the JSON.stringify functions (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Example_of_using_replacer_parameter). The following will only compare all objects keys that are named "derp":I use this comparable function to produce copies of my objects that are JSON comparable:Comes in handy in tests (most test frameworks have an is function). E.g.If a difference is caught, strings get logged, making differences spottable:Heres\'s a solution in ES6/ES2015 using a functional-style approach:demo available hereIf you\'re using ES6+ via Babel or otherwise, you can also use Object.is(x, y).Reference: http://wiki.ecmascript.org/doku.php?id=harmony:egal#object.is_x_yI\'d advise against hashing or serialization (as the JSON solution suggest).  If you need to test if two objects are equal, then you need to define what equals means.  It could be that all data members in both objects match, or it could be that must the memory locations match (meaning both variables reference the same object in memory), or may be that only one data member in each object must match.Recently I developed an object whose constructor creates a new id (starting from 1 and incrementing by 1) each time an instance is created.  This object has an isEqual function that compares that id value with the id value of another object and returns true if they match.In that case I defined "equal" as meaning the the id values match.  Given that each instance has a unique id this could be used to enforce the idea that matching objects also occupy the same memory location.  Although that is not necessary.Needing a more generic object comparison function than had been posted, I cooked up the following. Critique appreciated...If you are comparing JSON objects you can use https://github.com/mirek/node-rus-diffUsage:If two objects are different, a MongoDB compatible {$rename:{...}, $unset:{...}, $set:{...}} like object is returned.I faced the same problem and deccided to write my own solution. But because I want to also compare Arrays with Objects and vice-versa, I crafted a generic solution. I decided to add the functions to the prototype, but one can easily rewrite them to standalone functions. Here is the code:This Algorithm is split into two parts; The equals function itself and a function to find the numeric index of a property in an array / object. The find function is only needed because indexof only finds numbers and strings and no objects .One can call it like this:The function either returns true or false, in this case true.\nThe algorithm als allows comparison between very complex objects:The upper example will return true, even tho the properties have a different ordering. One small detail to look out for: This code also checks for the same type of two variables, so "3" is not the same as 3.I\'m making the following assumptions with this function:This should be treated as a demonstration of a simple strategy.This is an addition for all the above, not a replacement. If you need to fast shallow-compare objects without need to check extra recursive cases. Here is a shot.This compares for: 1) Equality of number of own properties, 2) Equality of key names, 3) if bCompareValues == true, Equality of corresponding property values and their types (triple equality)I know this is a bit old, but I would like to add a solution that I came up with for this problem.\nI had an object  and I wanted to know when its data changed. "something similar to Object.observe" and what I did was:This here can be duplicated and create an other set of arrays to compare the values and keys.\nIt is very simple because they are now arrays and will return false if objects have different sizes.Pulling out from my personal library, which i use for my work repeatedly. The following function is a lenient recursive deep equal, which does not checkI mainly use this to check if i get equal replies against various API implementation. Where implementation difference (like string vs number) and additional null values, can occur. Its implementation is quite straightforward and short (if all the comments is stripped off)Just wanted to contribute my version of objects comparison utilizing some es6 features. It doesn\'t take an order into account. After converting all if/else\'s to ternary I\'ve came with following:I don\'t know if anyone\'s posted anything similar to this, but here\'s a function I made to check for object equalities.Also, it\'s recursive, so it can also check for deep equality, if that\'s what you call it.Depends on what you mean by equality. And therefore it is up to you, as the developer of the classes, to define their equality.There\'s one case used sometimes, where two instances are considered \'equal\' if they point to the same location in memory, but that is not always what you want. For instance, if I have a Person class, I might want to consider two Person objects \'equal\' if they have the same Last Name, First Name, and Social Security Number (even if they point to different locations in memory).On the other hand, we can\'t simply say that two objects are equal if the value of each of their members is the same, since, sometimes, you don\'t want that. In other words, for each class, it\'s up to the class developer to define what members make up the objects \'identity\' and develop a proper equality operator (be it via overloading the == operator or an Equals method).Saying that two objects are equal if they have the same hash is one way out. However you then have to wonder how the hash is calculated for each instance. Going back to the Person example above, we could use this system if the hash was calculated by looking at the values of the First Name, Last Name, and Social Security Number fields. On top of that, we are then relying on the quality of the hashing method (that\'s a huge topic on its own, but suffice it to say that not all hashes are created equal, and bad hashing methods can lead to more collisions, which in this case would return false matches).It\'s useful to consider two objects equal if they have all the same values for all properties and recursively for all nested objects and arrays.  I also consider the following two objects equal:Similarly, arrays can have "missing" elements and undefined elements.  I would treat those the same as well:A function that implements this definition of equality:Source code (including the helper functions, generalType and uniqueArray):\nUnit Test and Test Runner here.Here is a very basic approach to checking an object\'s "value equality".Demo - JSFiddleAs you can see, to check the objects\' "value equality" we essentially have to iterate over every property in the objects to see whether they are equal. And while this simple implementation works for our example, there are a lot of cases that it doesn\'t handle. For instance:For a robust method of checking objects\' "value equality" it is better to rely on a well-tested library that covers the various edge cases like Underscore. Demo - JSFiddleFor comparing keys for simple key/value pairs object instances, I use:Once keys are compared, a simple additional for..in loop is enough.Complexity is O(N*N) with N is the number of keys. I hope/guess objects I define won\'t hold more than 1000 properties... I need to mock jQuery POST requests, so the equality that matters to me is that both objects have the same set of properties (none missing in either object), and that each property value is "equal" (according to this definition).  I don\'t care about the objects having mismatching methods.Here\'s what I\'ll be using, it should be good enough for my specific requirements:Use like so:I\'ve written a small library that runs on Node.js and the browser called compare.js. It offers the usual comparison operators, such as ==, !=, >, >=, <, <= and identity on all data types of JavaScript.E.g., you can useand this will check for equality (using a deep-equal approach). Otherwise, if you doit will compare by reference, hence check for identity.\nYou can also use < and > on objects, which mean subset and superset.compare.js is covered by nearly 700 unit tests, hence it should hopefully not have too many bugs ;-).You can find it on https://github.com/goloroden/compare.js for free, it is open-sourced under the MIT license.