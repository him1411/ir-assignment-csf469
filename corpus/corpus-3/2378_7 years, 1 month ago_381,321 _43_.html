I have a generics class, Foo<T>. In a method of Foo, I want to get the class instance of type T, but I just can\'t call T.class.What is the preferred way to get around it using T.class?The short answer is, that there is no way to find out the runtime type of generic type parameters in Java. I suggest reading the chapter about type erasure in the Java Tutorial for more details.A popular solution to this is to pass the Class of the type parameter into the constructor of the generic type, e.g.I was looking for a way to do this myself without adding an extra dependency to the classpath. After some investigation I found that it is possible as long as you have a generic supertype. This was OK for me as I was working with a DAO layer with a generic layer supertype. If this fits your scenario then it\'s the neatest approach IMHO.Most generics use cases I\'ve come across have some kind of generic supertype e.g. List<T> for ArrayList<T> or GenericDAO<T> for DAO<T>, etc.The article Accessing generic types at runtime in Java explains how you can do it using pure Java.My project was using Spring which is even better as Spring has a handy utility method for finding the type. This is the best approach for me as it looks neatest. I guess if you weren\'t using Spring you could write your own utility method.There is a small loophole however: if you define your Foo class as abstract.\nThat would mean you have to instantiate you class as:(Note the double braces at the end.)Now you can retrieve the type of T at runtime:Note however that mySuperclass has to be the superclass of the class definition actually defining the final type for T.It is also not very elegant, but you have to decide whether you  prefer new Foo<MyType>(){} or new Foo<MyType>(MyType.class); in your code.For example:Then:A standard approach/workaround/solution is to add a class object to the constructor(s), like:Imagine you have an abstract superclass that is generic:And then you have a second class that extends Foo with a generic Bar that extends T:You can get the class Bar.class in the Foo class by selecting the Type (from bert bruynooghe answer) and infering it using Class instance:You have to note this operation is not ideal, so it is a good idea to cache the computed value to avoid multiple calculations on this. One of the typical uses is in generic DAO implementation. The final implementation:The value returned is Bar.class when invoked from Foo class in other function or from Bar class.Here is working solution!!!NOTES:\nCan be used only as superclass\n 1. Has to be extended with typed class  (Child extends Generic<Integer>)\nOR\n 2. Has to be created as anonymous implementation (new Generic<Integer>() {};)   You can\'t do it because of type erasure. See also Stack Overflow question Java generics - type erasure - when and what happens.A better route than the Class the others suggested is to pass in an object that can do what you would have done with the Class, e.g., create a new instance.I had this problem in an abstract generic class. In this particular case, the solution is simpler:and later on the derived class:It\'s possible:You need two functions from svn/trunk/dao/src/main/java/com/googlecode/genericdao/dao/ DAOUtil.java.For more explanations, see Reflecting generics.If you are extending or implementing any class/interface that are using generics , you may get the Generic Type of parent class/interface, without modifying any existing class/interface at all.There could be three possibilities, Case 1\nWhen your class is extending a class that is using GenericsCase 2\nWhen your class is implementing an interface that is using GenericsCase 3\nWhen your interface is extending an interface that is using GenericsActually, I suppose you have a field in your class of type T. If there\'s no field of type T, what\'s the point of having a generic Type? So, you can simply do an instanceof on that field.In my case, I have a Of course, this only works if the total number of possible classes is limited.As explained in other answers, to use this ParameterizedType approach, you need to extend the class, but that seems like extra work to make a whole new class that extends it...So, making the class abstract it forces you to extend it, thus satisfying the subclassing requirement. (using lombok\'s @Getter).Now to extend it without defining a new class. (Note the {} on the end... extended, but don\'t overwrite anything - unless you want to).I\'m using workaround for this: