This question already has an answer here:This code separates a string into tokens and stores them in an array of strings, and then compares a variable with the first home ... why isn\'t it working?Use the string.equals(Object other) function to compare strings, not the == operator.The function checks the actual contents of the string, the == operator checks whether the references to the objects are equal.  Note that string constants are usually "interned" such that two constants with the same value can actually be compared with ==, but it\'s better not to rely on that.NB: the compare is done on \'usuario\' because that\'s guaranteed non-null in your code, although you should still check that you\'ve actually got some tokens in the datos array otherwise you\'ll get an array-out-of-bounds exception.Jorman is a successful businessman and has 2 houses. But others don\'t know that.When you ask neighbours from either Madison or Burke streets, this is the only thing they can say:Using the residence alone, it\'s tough to confirm that it\'s the same Jorman. Since they\'re 2 different addresses, it\'s just natural to assume that those are 2 different persons.That\'s how the operator == behaves. So it will say that datos[0]==usuario is false, because it only compares the addresses.What if we sent an investigator? We know that it\'s the same Jorman, but we need to prove it. Our detective will look closely at all physical aspects. With thorough inquiry, the agent will be able to conclude whether it\'s the same person or not. Let\'s see it happen in Java terms.Here\'s the source code of String\'s equals() method:It compares the Strings character by character, in order to come to a conclusion that they are indeed equal.That\'s how the String equals method behaves. So datos[0].equals(usuario) will return true, because it performs a logical comparison.It\'s good to notice that in some cases use of "==" operator can lead to the expected result, because the way how java handles strings - string literals are interned  (see String.intern()) during compilation - so when you write for example "hello world" in two classes and compare those strings with "==" you could get result: true, which is expected according to specification; when you compare same strings (if they have same value) when the first one is string literal (ie. defined through "i am string literal") and second is constructed during runtime ie. with "new" keyword like new String("i am string literal"), the == (equality) operator returns false, because both of them are different instances of the String class. Only right way is using .equals() -> datos[0].equals(usuario). == says only if two objects are the same instance of object (ie. have same memory address)Update: 01.04.2013 I updated this post due comments below which are somehow right. Originally I declared that interning (String.intern) is side effect of JVM optimization. Although it certainly save memory resources (which was what i meant by "optimization") it is mainly feature of languageequals() function is a method of Object class which should be overridden by programmer. String class overrides it to check if two strings are equal i.e. in content and not reference. == operator checks if the references of both the objects are the same. Consider the programsHere the abc and xyz, both refer to same String "Awesome". Hence the expression (abc == xyz) is true.Here abc and xyz are two different strings with the same content "Hello World". Hence here the expression (abc == xyz) is false where as (abc.equals(xyz)) is true.Hope you understood the difference between == and <Object>.equals() Thanks.Instead ofuse == compares the reference of the variable where .equals() compares the values which is what you want.== tests for reference equality..equals() tests for value equality.Consequently, if you actually want to test whether two strings have the same value you should use .equals() (except in a few situations where you can guarantee that two strings with the same value will be represented by the same object eg: String interning).== is for testing whether two strings are the same Object.It is important to note that == is much cheaper than equals() (a single pointer comparision instead of a loop), thus, in situations where it is applicable (i.e. you can guarantee that you are only dealing with interned strings) it can present an important performance improvement. However, these situations are rare.Note that .equals() method belongs to Class Object(Super class of all classes). You need to override it as per you class requirement but for String it is already implemented and it checks whether two string have same value or not.It will also work if you call intern() on the string before inserting it into the array.\nInterned strings are reference-equal (==) if and only if they are value-equal (equals().)Let\'s analyze the following Java, to understand the identity and equality of Strings:When the first line of code String str1 = "Hello world." executes, a string \\Hello world."\nis created, and the variable str1 refers to it. Another string "Hello world." will not be created again when the next line of code executes because of optimization. The variable str2 also refers to the existing ""Hello world.".The operator == checks identity of two objects (whether two variables refer to same object). Since str1 and str2 refer to same string in memory, they are identical to each other. The method equals checks equality of two objects (whether two objects have same content). Of course, the content of str1 and str2 are same.When code String str3 = new String("Hello world.") executes, a new instance of string with content "Hello world." is created, and it is referred to by the variable str3. And then another instance of string with content "Hello world." is created again, and referred to by\nstr4. Since str3 and str4 refer to two different instances, they are not identical, but their\ncontent are same.Therefore, the output contains four lines:You should use string equals to compare two strings for equality, not operator == which just compares the references.== operator compares the reference of an object in java. You can use string\'s equals method .The == operator is a simple comparison of values.\nFor object references the (values) are the (references). So x == y returns true if x and y reference the same object.I know this is an old question but here\'s how I look at it (I find very useful):Technical explanationsIn Java, all variables are either primitive types or references.(If you need to know what a reference is: "Object variables" are just pointers to objects. So with Object something = ..., something is really an address in memory (a number).)== compares the exact values. So it compares if the primitive values are the same, or if the references (addresses) are the same. That\'s why == often doesn\'t work on Strings; Strings are objects, and doing == on two string variables just compares if the address is same in memory, as others have pointed out. .equals() calls the comparison method of objects, which will compare the actual objects pointed by the references. In the case of Strings, it compares each character to see if they\'re equal.The interesting part:So why does == sometimes return true for Strings? Note that Strings are immutable. In your code, if you doSince strings are immutable (when you call .trim() or something, it produces a new string, not modifying the original object pointed to in memory), you don\'t really need two different String("hi") objects. If the compiler is smart, the bytecode will read to only generate one String("hi") object. So if you do right after, they\'re pointing to the same object, and will return true. But you rarely intend this. Instead, you\'re asking for user input, which is creating new strings at different parts of memory, etc. etc.Note: If you do something like baz = new String(bar) the compiler may still figure out they\'re the same thing. But the main point is when the compiler sees literal strings, it can easily optimize same strings.I don\'t know how it works in runtime, but I assume the JVM doesn\'t keep a list of "live strings" and check if a same string exists. (eg if you read a line of input twice, and the user enters the same input twice, it won\'t check if the second input string is the same as the first, and point them to the same memory). It\'d save a bit of heap memory, but it\'s so negligible the overhead isn\'t worth it. Again, the point is it\'s easy for the compiler to optimize literal strings.There you have it... a gritty explanation for == vs. .equals() and why it seems random.@Melkhiah66 You can use equals method instead of \'==\' method to check the equality.\nIf you use intern() then it checks whether the object is in pool if present then returns\nequal else unequal. equals method internally uses hashcode and gets you the required result.\nIf You are going to compare any assigned value of the string ie)primitive string, Both "==" and .equals will work, but for the new string object you should use only .equals, here "==" will not workExample:if(a == b)  and (a.equals(b)) will return true.butin this case if(a == b) will return falseso its better to use .equals operator....The .equals() will check if the two strings have the same value and return the boolean value where as the == operator checks to see if the two strings are the same object.Generally .equals is used for Object comparison, where you want to verify if two Objects have an identical value.== for reference comparison (are the two Objects the same Object on the heap) & to check if the Object is null. It is also used to compare the values of primitive types.Use Split rather than tokenizer,it will surely provide u exact output\nfor E.g:After this I am sure you will get better results.....Someone said on a post higher up that  == is used for int and for checking nulls.\nIt may also be used to check for Boolean operations and char types.Be very careful though and double check that you are using a char and not a String.\nfor example for strings you would then check\nThis would be correctbut would be incorrect, you would need to do the followinga==bCompares references, not values. The use of == with object references is generally limited to the following:Comparing to see if a reference is null.Comparing two enum values. This works because there is only one object for each enum constant.You want to know if two references are to the same object"a".equals("b")Compares values for equality. Because this method is defined in the Object class, from which all other classes are derived, it\'s automatically defined for every class. However, it doesn\'t perform an intelligent comparison for most classes unless the class overrides it. It has been defined in a meaningful way for most Java core classes. If it\'s not defined for a (user) class, it behaves the same as ==.