How do I declare an Android UI element using XML?The Android Developer Guide has a section called Building Custom Components. Unfortunately, the discussion of XML attributes only covers declaring the control inside the layout file and not actually handling the values inside the class initialisation. The steps are as follows:Notice the use of an unqualified name in the declare-styleable tag. Non-standard android  attributes like extraInformation need to have their type declared. Tags declared in the  superclass will be available in subclasses without having to be redeclared.Since there are two constructors that use an AttributeSet for initialisation, it is convenient to create a separate initialisation method for the constructors to call. R.styleable.MyCustomView is an autogenerated int[] resource where each element is the ID of an attribute. Attributes are generated for each property in the XML by appending the attribute name to the element name. For example, R.styleable.MyCustomView_android_text contains the android_text attribute for MyCustomView. Attributes can then be retrieved from the TypedArray using various get functions. If the attribute is not defined in the defined in the XML, then null is returned. Except, of course, if the return type is a primitive, in which case the second argument is returned.If you don\'t want to retrieve all of the attributes, it is possible to create this array manually.The ID for standard android attributes are included in android.R.attr, while attributes for this project are in R.attr.Please note that you should not use anything in android.R.styleable, as per this thread it may change in the future. It is still in the documentation as being to view all these constants in the one place is useful.Include the namespace declaration xmlns:app="http://schemas.android.com/apk/res-auto" in the top level xml element. Namespaces provide a method to avoid the conflicts that sometimes occur when different schemas use the same element names (see this article for more info). The URL is simply a manner of uniquely identifying schemas - nothing actually needs to be hosted at that URL. If this doesn\'t appear to be doing anything, it is because you don\'t actually need to add the namespace prefix unless you need to resolve a conflict.Reference the custom view using the fully qualified name.If you want a complete example, look at the android label view sample.LabelView.javaattrs.xmlcustom_view_1.xmlThis is contained in a LinearLayout with a namespace attribute: xmlns:app="http://schemas.android.com/apk/res-auto"Great reference. Thanks!\nAn addition to it:If you happen to have a library project included which has declared custom attributes for a custom view, you have to declare your project namespace, not the library one\'s. Eg:Given that the library has the package "com.example.library.customview" and the working project has the package "com.example.customview", then:Will not work (shows the error " error: No resource identifier found for attribute \'newAttr\' in package \n     \'com.example.library.customview\'" ):Will work:Addition to most voted answer.I want to add some words about obtainStyledAttributes() usage, when we create custom view using android:xxx prdefined attributes. Especially when we use TextAppearance.\nAs was mentioned in "2. Creating constructors", custom view gets AttributeSet on its creation. Main usage we can see in TextView source code (API 16).What we can see here?\nobtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)\nAttribute set is processed by theme according to documentation. Attribute values are compiled step by step. First attributes are filled from theme, then values are replaced by values from style, and finally exact values from XML for special view instance replace others.\nArray of requested attributes - com.android.internal.R.styleable.TextView\nIt is an ordinary array of constants. If we are requesting standard attributes, we can build this array manually.What is not mentioned in documentation - order of result TypedArray elements.\nWhen custom view is declared in attrs.xml, special constants for attribute indexes are generated. And we can extract values this way: a.getString(R.styleable.MyCustomView_android_text). But for manual int[] there are no constants. I suppose, that getXXXValue(arrayIndex) will work fine.And other question is: "How we can replace internal constants, and request standard attributes?" We can use android.R.attr.* values.So if we want to use standard TextAppearance attribute in custom view and read its values in constructor, we can modify code from TextView this way:Where CustomLabel is defined:Maybe, I\'m mistaken some way, but Android documentation on obtainStyledAttributes() is very poor.At the same time we can just extend standard UI component, using all its declared attributes.\nThis approach is not so good, because TextView for instance declares a lot of properties. And it will be impossible\nto implement full functionality in overriden onMeasure() and onDraw().But we can sacrifice theoretical wide reusage of custom component. Say "I know exactly what features I will use", and\ndon\'t share code with anybody.Then we can implement constructor CustomComponent(Context, AttributeSet, defStyle). \nAfter calling super(...) we will have all attributes parsed and available through getter methods.It seems that Google has updated its developer page and added various trainings there. One of them deals with the creation of custom views and can be found hereThanks a lot for the first answer.As for me, I had just one problem with it. When inflating my view, i had a bug :\njava.lang.NoSuchMethodException : MyView(Context, Attributes)I resolved it by creating a new constructor :Hope this will help !You can include any layout file in other layout file as-here the layout files in include tag are other .xml layout files in the same res folder.