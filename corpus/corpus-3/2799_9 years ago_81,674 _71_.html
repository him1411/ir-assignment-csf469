I\'ve seen references to curried functions in several articles and blogs but I can\'t find a good explanation (or at least one that makes sense!)Currying is when you break down a function that takes multiple arguments into a series of functions that take part of the arguments. Here\'s an example in JavaScript:This is a function that takes two arguments, a and b, and returns their sum. We will now curry this function:This is a function that takes one argument, a, and returns a function that takes another argument, b, and that function returns their sum.The first statement returns 7, like the add(3, 4) statement. The second statement defines a new function called add3 that will add 3 to its argument. This is what some people may call a closure. The third statement uses the add3 operation to add 3 to 4, again producing 7 as a result.In an algebra of functions, dealing with functions that take multiple arguments (or equivalent one argument that\'s an N-tuple) is somewhat inelegant -- but, as Moses Sch\xc3\xb6nfinkel (and, independently, Haskell Curry) proved, it\'s not needed: all you need are functions that take one argument.So how do you deal with something you\'d naturally express as, say, f(x,y)?  Well, you take that as equivalent to f(x)(y) -- f(x), call it g, is a function, and you apply that function to y.  In other words, you only have functions that take one argument -- but some of those functions return other functions (which ALSO take one argument;-).As usual, wikipedia has a nice summary entry about this, with many useful pointers (probably including ones regarding your favorite languages;-) as well as slightly more rigorous mathematical treatment.Here\'s a concrete example:Suppose you have a function that calculates the gravitational force acting on an object. If you don\'t know the formula, you can find it here. This function takes in the three necessary parameters as arguments.Now, being on the earth, you only want to calculate forces for objects on this planet. In a functional language, you could pass in the mass of the earth to the function and then partially evaluate it. What you\'d get back is another function that takes only two arguments and calculates the gravitational force of objects on earth. This is called currying.Currying is a transformation that can be applied to functions to allow them to take one less argument than previously.For example, in F# you can define a function thus:-Here function f takes parameters x, y and z and sums them together so:-Returns 6.From our definition we can can therefore define the curry function for f:-Where \'fun x -> f x\' is a lambda function equivilent to x => f(x) in C#. This function inputs the function you wish to curry and returns a function which takes a single argument and returns the specified function with the first argument set to the input argument.Using our previous example we can obtain a curry of f thus:-We can then do the following:-Which provides us with a function f1 which is equivilent to f1 y z = 1 + y + z. This means we can do the following:-Which returns 6.This process is often confused with \'partial function application\' which can be defined thus:-Though we can extend it to more than one parameter, i.e.:-A partial application will take the function and parameter(s) and return a function that requires one or more less parameters, and as the previous two examples show is implemented directly in the standard F# function definition so we could achieve the previous result thus:-Which will return a result of 6.In conclusion:-The difference between currying and partial function application is that:-Currying takes a function and provides a new function accepting a single argument, and returning the specified function with its first argument set to that argument. This allows us to represent functions with multiple parameters  as a series of single argument functions. Example:-Partial function application is more direct - it takes a function and one or more arguments and returns a function with the first n arguments set to the n arguments specified. Example:-A curried function is a function of several arguments rewritten such that it accepts the first argument and returns a function that accepts the second argument and so on. This allows functions of several arguments to have some of their initial arguments partially applied.It can be a way to use functions to make other functions. In javascript:Would allow us to call it like so:When this runs the 10 is passed in as x;which means we are returned this function:So when you callyou are really calling:So if you do this:it\'s the same as:So our addTen() always adds ten to whatever we pass in. We can make similar functions in the same way:Here\'s a toy example in Python:(Just using concatenation via + to avoid distraction for non-Python programmers.)Editing to add:See http://docs.python.org/library/functools.html?highlight=partial#functools.partial,\nwhich also shows the partial object vs. function distinction in the way Python implements this.I found this article, and the article it references, useful, to better understand currying:\nhttp://blogs.msdn.com/wesdyer/archive/2007/01/29/currying-and-partial-function-application.aspxAs the others mentioned, it is just a way to have a one parameter function.This is useful in that you don\'t have to assume how many parameters will be passed in, so you don\'t need a 2 parameter, 3 parameter and 4 parameter functions.If you understand partial you\'re halfway there.  The idea of partial is to preapply arguments to a function and give back a new function that wants only the remaining arguments.  When this new function is called it includes the preloaded arguments along with whatever arguments were supplied to it.In Clojure + is a function but to make things starkly clear:You may be aware that the inc function simply adds 1 to whatever number it\'s passed.Let\'s build it ourselves using partial:Here we return another function that has 1 loaded into the first argument of add.  As add takes two arguments the new inc function wants only the b argument -- not 2 arguments as before since 1 has already been partially applied.  Thus partial is a tool from which to create new functions with default values presupplied.  That is why in a functional language functions often order arguments from general to specific.  This makes it easier to reuse such functions from which to construct other functions.Now imagine if the language were smart enough to understand introspectively that add wanted two arguments.  When we passed it one argument, rather than balking, what if the function partially applied the argument we passed it on our behalf understanding that we probably meant to provide the other argument later?  We could then define inc without explicitly using partial.This is the way some languages behave.  It is exceptionally useful when one wishes to compose functions into larger transformations.  This would lead one to transducers.A curried function is applied to multiple argument lists, instead of just\none. Here is a regular, non-curried function, which adds two Int\nparameters, x and y:Here is similar function that\xe2\x80\x99s curried. Instead\nof one list of two Int parameters, you apply this function to two lists of one\nInt parameter each:What\xe2\x80\x99s happening here is that when you invoke curriedSum, you actually get two traditional function invocations back to back. The first function\ninvocation takes a single Int parameter named x , and returns a function\nvalue for the second function. This second function takes the Int parameter\ny. Here\xe2\x80\x99s a function named first that does in spirit what the first traditional\nfunction invocation of curriedSum would do:Applying 1 to the first function\xe2\x80\x94in other words, invoking the first function\nand passing in 1 \xe2\x80\x94yields the second function:Applying 2 to the second function yields the result:An example of currying would be when having functions you only know one of the parameters at the moment:For example:Here, since you don\'t know the second parameter for callback when sending it to performAsyncRequest(_:) you would have to create another lambda / closure to send that one to the function.I really can\'t help myself, but it looks to me like a way how to write recursion backwards. Typical recursion - at the bottom I have function which is returning function (itself in this case), which is returning function, which is ... unless some condition is fulfilled or my computer has blown up if I wrote it wrong.fact = (n) => n == 0 ? 1 : n*fact(n-1);\nfrom here\nSo currying occurs to me like manually write each step of recursion. Maybe the name is from this fact - re + CURR + sion -> CURR + ying. I do not know, just guessing.To give a real world (and potentially useful) example of currying check out how you can make server calls in javascript with the fetch libraryWhere getPromiseForFetchWithToken is a curried function that returns a Promise with the result of the fetch, shown below: This allows you to await the call of the Get function and then appropriately handle the return value regardless of what it is, you can re-use the getPromiseForFetchWithToken function anywhere you need to make a server call that needs to include a bearer token. (Put, Delete, Post, etc)