How to make a Python class serializable?  A simple class:What should I do to be able to get output of:Without an error (FileItem instance at ... is not JSON serializable)Do you have an idea about the expected output? For e.g. will this do?In that case you can merely call json.dumps(f.__dict__). If you want more customized output then you will have to subclass JSONEncoder and implement your own custom serialization. For a trivial example, see below.Then you pass this class into the json.dumps() method as cls kwarg:If you also want to decode then you\'ll have to supply a custom object_hook to the JSONDecoder class. For e.g.Here is a simple solution for a simple feature:Instead of a JSON serializable class, implement a serializer method:So you just call it to serialize:will output:For more complex classes you could consider the tool jsonpickle:jsonpickle is a Python library for serialization and deserialization of complex Python objects to and from JSON.The standard Python libraries for encoding Python into JSON, such as the stdlib\xe2\x80\x99s json, simplejson, and demjson, can only handle Python primitives that have a direct JSON equivalent (e.g. dicts, lists, strings, ints, etc.). jsonpickle builds on top of these libraries and allows more complex data structures to be serialized to JSON. jsonpickle is highly configurable and extendable\xe2\x80\x93allowing the user to choose the JSON backend and add additional backends.(jsonpickle on PyPi)Most of the answers involve changing the call to json.dumps(), which is not always possible or desirable (it may happen inside a framework component for example).If you want to be able to call  json.dumps(obj) as is, then a simple solution is inheriting from dict:This works if your class is just basic data representation, for trickier things you can always set keys explicitly.I like Onur\'s answer but would expand to include an optional toJSON() method for objects to serialize themselves:Another case is to wrap JSON dumping in the own class:Or even subclassing FileItem class from a JSONSerializable class:Testing:I came across this problem the other day and implemented a more general version of an Encoder for Python objects that can handle nested objects and inherited fields:Example:Result:json is limited in terms of objects it can print, and jsonpickle (you may need a pip install jsonpickle) is limited in terms it can\'t indent text. If you would like to inspect the contents of an objecth whose class you can\'t change, I still couldn\'t find a straighter way than:Note that still they can\'t print the object methods. This class can do the trick, it converts object to standard json .usage:working in python2.7 and python3.if use standard json, u need to define a default functionjsonweb seems to be the best solution for me. See http://www.jsonweb.info/en/latest/Just add to_json method to your class like this:And add this code somewhere at the top of everything:This will monkey-patch json module when it\'s imported so\nJSONEncoder.default() automatically checks for a special "to_json()"\nmethod and uses it to encode the object if found.Just like Onur said, but this time you don\'t have to update every json.dumps() in your project.Here is my 3 cents ...\nThis demonstrates explicit json serialization for a tree-like python object.\nNote: If you actually wanted some code like this you could use the twisted \nFilePath class.This is a small library that serializes an object with all its children to JSON and also parses it back:https://github.com/Toubs/PyJSONSerialization/If you don\'t mind installing a package for it, you can use json-tricks:After that you just need to import dump(s) from json_tricks instead of json, and it\'ll usually work:which\'ll giveAnd that\'s basically it!This will work great in general. There are some exceptions, e.g. if special things happen in __new__, or more metaclass magic is going on.Obviously loading also works (otherwise what\'s the point):This does assume that module_name.test_class.MyTestCls can be imported and hasn\'t changed in non-compatible ways. You\'ll get back an instance, not some dictionary or something, and it should be an identical copy to the one you dumped.If you want to customize how something gets (de)serialized, you can add special methods to your class, like so:which serializes only part of the attributes parameters, as an example.And as a free bonus, you get (de)serialization of numpy arrays, date & times, ordered maps, as well as the ability to include comments in json.Disclaimer: I created json_tricks, because I had the same problem as you.I came up with my own solution. Use this method, pass any document (dict,list, ObjectId etc) to serialize.There are many approaches to this problem.  \'ObjDict\'  (pip install objdict) is another.  There is an emphasis on providing javascript like objects which can also act like dictionaries to best handle data loaded from JSON, but there are other features which can be useful as well.  This provides another alternative solution to the original problem.I chose to use decorators to solve the datetime object serialization problem.\nHere is my code:By importing the above module, my other modules use json in a normal way (without specifying the default keyword) to serialize data that contains date time objects. The datetime serializer code is automatically called for json.dumps and json.dump.