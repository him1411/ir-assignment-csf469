I created a JavaScript object, but how I can determine the class of that object?I want something similar to Java\'s .getClass() method. There\'s no exact counterpart to Java\'s getClass() in JavaScript. Mostly that\'s due to JavaScript being a prototype-based language, as opposed to Java being a class-based one.Depending on what you need getClass() for, there are several options in JavaScript: A few examples:Note: if you are compiling your code with Uglify it will change non-global class names. To prevent this, Uglify has a --mangle param that you can set to false is using gulp or grunt.works in most cases in modern browsers, despite Function.name not being officially added to the standard until ES6. If the object is instantiated with var obj = new MyClass(), it will return "MyClass" as a string.It will return "Number" for numbers, "Array" for arrays and "Function" for functions, etc. It seems to be quite reliable. The only cases where it fails are if an object is created without a prototype, via Object.create( null ), or the object was instantiated from an anonymously-defined (unnamed) function.Arguably, obj.constructor.name is much more intuitive than typeof, and could be encapsulated in a function to handle the odd case where constructor isn\'t defined (and to handle null references).Note: Another advantage to this method is it works intuitively across DOM boundaries versus comparing the constructor objects directly or using instanceOf. The reason that doesn\'t work as you might expect is there are actually different instances of the constructor function on each DOM, thus doing an object comparison on their constructors won\'t work.Note 2: Oddly enough, this method appears to return the name of the base-most function used in a prototype chain, which is unfortunately not intuitive. For example if B derives prototypically from A and you create a new instance of B, b, b.constructor.name returns "A"! So that feels totally backwards. It does work fine for single-level prototypes and all primitives, however.This function returns either "undefined", "null", or the "class" in [object class] from Object.prototype.toString.call(someObject).To get the "pseudo class", you can get the constructor function, byassuming the constructor is set correctly when you do the inheritance -- which is by something like:and these two lines, together with:will make woofie.constructor point to Dog.  Note that Dog is a constructor function, and is a Function object.  But you can do if (woofie.constructor === Dog) { ... }.If you want to get the class name as a string, I found the following working well:http://blog.magnetiq.com/post/514962277/finding-out-class-names-of-javascript-objectsIt gets to the constructor function, converts it to string, and extracts the name of the constructor function.Note that obj.constructor.name could have worked well, but it is not standard.  It is on Chrome and Firefox, but not on IE, including IE 9 or IE 10 RTM.You can get a reference to the constructor function which created the object by using the constructor property:If you need to confirm the type of an object at runtime you can use the instanceof operator:I find object.constructor.toString() return [object objectClass] in IE ,rather than function objectClass () {} returned in chome. So,I think the code in http://blog.magnetiq.com/post/514962277/finding-out-class-names-of-javascript-objects may not work well in IE.And I fixed the code as follows:For Javascript Classes in ES6 you can use object.constructor. In the example class below the getClass() method returns the ES6 class as you would expect:If you instantiate the class from the getClass method make sure you wrap it in brackets e.g. ruffles = new ( fluffy.getClass() )( args... );In javascript, there are no classes, but I think that you want the constructor name and obj.constructor.toString() will tell you what you need.Agree with dfa, that\'s why i consider the prototye as the class when no named class foundHere is an upgraded function of the one posted by Eli Grey, to match my way of mindYou are able to get a reference for an Object\'s class using window.Javascript is a class-less languages: there are no classes that defines the behaviour of a class statically as in Java. JavaScript uses prototypes instead of classes for defining object properties, including methods, and inheritance. It is possible to simulate many class-based features with prototypes in JavaScript.In keeping with its unbroken record of backwards-compatibility, ECMAScript 6, JavaScript still doesn\'t have a class type (though not everyone understands this). It does have a class keyword as part of its class syntax for creating prototypes\xe2\x80\x94but still no thing called class. JavaScript is not now and has never been a classical OOP language. Speaking of JS in terms of class is only either misleading or a sign of not yet grokking prototypical inheritance (just keeping it real).That means this.constructor is still a great way to get a reference to the constructor function. And this.constructor.prototype is the way to access the prototype itself. Since this isn\'t Java, it\'s not a class. It\'s the prototype object your instance was instantiated from. Here is an example using the ES6 syntactic sugar for creating a prototype chain:This is what that outputs using babel-node:There you have it! In 2016, there\'s a class keyword in JavaScript, but still no class type. this.constructor is the best way to get the constructor function, this.constructor.prototype the best way to get access to the prototype itself.Question seems already answered but the OP wants to access the class of and object, just like we do in Java and the selected answer is not enough (imho).With the following explanation, we can get a class of an object(it\'s actually called prototype in javascript).You can add a property like this:But .last property will only be available to \'arr\' object which is instantiated from Array prototype. So, in order to have the .last property to be available for all objects instantiated from Array prototype, we have to define the .last property for Array prototype:The problem here is, you have to know which object type (prototype) the \'arr\' and \'arr2\' variables belongs to! In other words, if you don\'t know class type (prototype) of the \'arr\' object, then you won\'t be able to define a property for them. In the above example, we know arr is instance of the Array object, that\'s why we used Array.prototype to define a property for Array. But what if we didn\'t know the class(prototype) of the \'arr\'?As you can see, without knowing that \'arr\' is an Array, we can add a new property just bu referring the class of the \'arr\' by using \'arr.__proto__\'.We accessed the prototype of the \'arr\' without knowing that it\'s an instance of Array and I think that\'s what OP asked.i had a situation to work generic now and used this:thats the only way i found to get the class name by type input if you don\'t have a instance of an object.(written in ES2017)dot notation also works fine