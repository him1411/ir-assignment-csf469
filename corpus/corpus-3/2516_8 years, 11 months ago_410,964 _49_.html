I have a generic list of objects in C#, and wish to clone the list. The items within the list are cloneable, but there doesn\'t seem to be an option to do list.Clone().Is there an easy way around this?You can use an extension method.If your elements are value types, then you can just do:However, if they are reference types and you want a deep copy (assuming your elements properly implement ICloneable), you could do something like this:Obviously, replace ICloneable in the above generics and cast with whatever your element type is that implements ICloneable.If your element type doesn\'t support ICloneable but does have a copy-constructor, you could do this instead:Personally, I would avoid ICloneable because of the need to guarantee a deep copy of all members. Instead, I\'d suggest the copy-constructor or a factory method like YourType.CopyFrom(YourType itemToCopy) that returns a new instance of YourType.Any of these options could be wrapped by a method (extension or otherwise).This is one way to do it with C# and .NET 2.0. Your object requires to be [Serializable()]. The goal is to lose all references and build new ones.For a shallow copy, you can instead use the GetRange method of the generic List class.Quoted from: Generics RecipesAfter a slight modification you can also clone:If you only care about value types...And you know the type:If you don\'t know the  type before, you\'ll need a helper function:The just:Use AutoMapper (or whatever mapping lib you prefer) to clone is simple and a lot maintainable.Define your mapping:Do the magic:Unless you need an actual clone of every single object inside your List<T>, the best way to clone a list is to create a new list with the old list as the collection parameter.Changes to myList such as insert or remove will not affect cloneOfMyList and vice versa.The actual objects the two Lists contain are still the same however.If you have already referenced Newtonsoft.Json in your project and your objects are serializeable you could always use:Possibly not the most efficient way to do it, but unless you\'re doing it 100s of 1000s of times you may not even notice the speed difference.You could also simply convert the list to an array using ToArray, and then clone the array using Array.Clone(...).\nDepending on your needs, the methods included in the Array class could meet your needs.You can use extension method:  You can clone all objects by using their value type members for example, consider this class:  Note: if you do any change on copy (or clone) it will not affect the original object.If you need a cloned list with the same capacity, you can try this:I\'ve made for my own some extension which converts ICollection of items that not implement IClonableI use automapper to copy an object. I just setup a mapping that maps one object to itself. You can wrap this operation any way you like. http://automapper.codeplex.com/My friend Gregor Martinovic and I came up with this easy solution using a JavaScript Serializer. There is no need to flag classes as Serializable and in our tests using the Newtonsoft JsonSerializer even faster than using BinaryFormatter. With extension methods usable on every object.Standard .NET JavascriptSerializer option:Faster option using Newtonsoft JSON:The following code should transfer onto a list with minimal changes. Basically it works by inserting a new random number from a greater range with each successive loop. If there exist numbers already that are the same or higher than it, shift those random numbers up one so they transfer into the new larger range of random indexes.Another thing: you could use reflection. If you\'ll cache this properly, then it\'ll clone 1,000,000 objects in 5.6 seconds (sadly, 16.4 seconds with inner objects).I measured it in a simple way, by using the Watcher class.RESULT: With inner object PersonInstance - 16.4, PersonInstance = null - 5.6CopyFactory is just my test class where I have dozen of tests including usage of expression. You could implement this in another form in an extension or whatever. Don\'t forget about caching.I didn\'t test serializing yet, but I doubt in an improvement with a million classes. I\'ll try something fast protobuf/newton.P.S.: for the sake of reading simplicity, I only used auto-property here. I could update with FieldInfo, or you should easily implement this by your own.I recently tested the Protocol Buffers serializer with the DeepClone function out of the box. It wins with 4.2 seconds on a million simple objects, but when it comes to inner objects, it wins with the result 7.4 seconds.SUMMARY: If you don\'t have access to the classes, then this will help.   Otherwise it depends on the count of the objects. I think you could use reflection up to 10,000 objects (maybe a bit less), but for more than this the Protocol Buffers serializer will perform better.There is a simple way to clone objects in C# using a JSON serializer and deserializer.You can create an extension class:To clone and object: