Is there a reason to prefer using map() over list comprehension or vice versa?  Is either of them generally more efficient or considered generally more pythonic than the other?map may be microscopically faster in some cases (when you\'re NOT making a lambda for the purpose, but using the same function in map and a listcomp). List comprehensions may be faster in other cases and most (not all) pythonistas consider them more direct and clearer.An example of the tiny speed advantage of map when using exactly the same function:An example of how performance comparison gets completely reversed when map needs a lambda:Cases"Pythonism"I dislike the word "pythonic" because I don\'t find that pythonic is always elegant in my eyes. Nevertheless, map and filter and similar functions (like the very useful itertools module) are probably considered unpythonic in terms of style.LazinessIn terms of efficiency, like most functional programming constructs, MAP CAN BE LAZY, and in fact is lazy in python. That means you can do this (in python3) and your computer will not run out of memory and lose all your unsaved data:Try doing that with a list comprehension:Do note that list comprehensions are also inherently lazy, but python has chosen to implement them as non-lazy. Nevertheless, python does support lazy list comprehensions in the form of generator expressions, as follows:You can basically think of the [...] syntax as passing in a generator expression to the list constructor, like list(x for x in range(5)).Brief contrived exampleList comprehensions are non-lazy, so may require more memory (unless you use generator comprehensions). The square brackets [...] often make things obvious, especially when in a mess of parentheses. On the other hand, sometimes you end up being verbose like typing [x for x in.... As long as you keep your iterator variables short, list comprehensions are usually clearer if you don\'t indent your code. But you could always indent your code.or break things up:Efficiency comparison for python3map is now lazy:Therefore if you will not be using all your data, or do not know ahead of time how much data you need, map in python3 (and generator expressions in python2 or python3) will avoid calculating their values until the last moment necessary. Usually this will usually outweigh any overhead from using map. The downside is that this is very limited in python as opposed to most functional languages: you only get this benefit if you access your data left-to-right "in order", because python generator expressions can only be evaluated the order x[0], x[1], x[2], ....However let\'s say that we have a pre-made function f we\'d like to map, and we ignore the laziness of map by immediately forcing evaluation with list(...). We get some very interesting results:In results are in the form AAA/BBB/CCC where A was performed with on a circa-2010 Intel workstation with python 3.?.?, and B and C were performed with a circa-2013 AMD workstation with python 3.2.1, with extremely different hardware. The result seems to be that map and list comprehensions are comparable in performance, which is most strongly affected by other random factors. The only thing we can tell seems to be that, oddly, while we expect list comprehensions [...] to perform better than generator expressions (...), map is ALSO more efficient that generator expressions (again assuming that all values are evaluated/used).It is important to realize that these tests assume a very simple function (the identity function); however this is fine because if the function were complicated, then performance overhead would be negligible compared to other factors in the program. (It may still be interesting to test with other simple things like f=lambda x:x+x)If you\'re skilled at reading python assembly, you can use the dis module to see if that\'s actually what\'s going on behind the scenes:  It seems it is better to use [...] syntax than list(...). Sadly the map class is a bit opaque to disassembly, but we can make due with our speed test.An objective reason why you should prefer them even though they\'re not "Pythonic" is this:\nThey require functions/lambdas as arguments, which introduce a new scope.I\'ve gotten bitten by this more than once:but if instead I had said:then everything would\'ve been fine.You could say I was being silly for using the same variable name in the same scope.I wasn\'t. The code was fine originally -- the two xs weren\'t in the same scope.\nIt was only after I moved the inner block to a different section of the code that the problem came up (read: problem during maintenance, not development), and I didn\'t expect it.Yes, if you never make this mistake then list comprehensions are more elegant.\nBut from personal experience (and from seeing others make the same mistake) I\'ve seen it happen enough times that I think it\'s not worth the pain you have to go through when these bugs creep into your code.Use map and filter. They prevent subtle hard-to-diagnose scope-related bugs.Don\'t forget to consider using imap and ifilter (in itertools) if they are appropriate for your situation!Actually, map and list comprehensions behave quite differently in the Python 3 language. Take a look at the following Python 3 program:You might expect it to print the line "[1, 4, 9]" twice, but instead it prints "[1, 4, 9]" followed by "[]". The first time you look at squares it seems to behave as a sequence of three elements, but the second time as an empty one.In the Python 2 language map returns a plain old list, just like list comprehensions do in both languages. The crux is that the return value of map in Python 3 (and imap in Python 2) is not a list - it\'s an iterator!The elements are consumed when you iterate over an iterator unlike when you iterate over a list. This is why squares looks empty in the last print(list(squares)) line.To summarize:I find list comprehensions are generally more expressive of what I\'m trying to do than map - they both get it done, but the former saves the mental load of trying to understand what could be a complex lambda expression.There\'s also an interview out there somewhere (I can\'t find it offhand) where Guido lists lambdas and the functional functions as the thing he most regrets about accepting into Python, so you could make the argument that they\'re un-Pythonic by virtue of that.Here is one possible case:versus:I am guessing the zip() is an unfortunate and unnecessary overhead you need to indulge in if you insist on using list comprehensions instead of the map.  Would be great if someone clarifies this whether affirmatively or negatively.If you plan on writing any asynchronous, parallel, or distributed code, you will probably prefer map over a list comprehension -- as most asynchronous, parallel, or distributed packages provide a map function to overload python\'s map.  Then by passing the appropriate map function to the rest of your code, you may not have to modify your original serial code to have it run in parallel (etc).Another reason to use list comprehension over map() and filter() is that Psyco can\'t compile these functions. See http://psyco.sourceforge.net/So since Python 3, map() is an iterator, you need to keep in mind what do you need: an iterator or list object.As @AlexMartelli already mentioned, map() is faster than list comprehension only if you don\'t use lambda function.I will present you some time comparisons.\nPython 3.5.2 and CPythonI\'ve used Jupiter notebook and especially %timeit built-in magic command\nMeasurements: s == 1000 ms == 1000 * 1000 \xc2\xb5s = 1000 * 1000 * 1000 ns Setup:Built-in function:lambda function:There is also such thing as generator expression, see PEP-0289. So i thought it would be useful to add it to comparisonUse list comprehension if it\'s custom function, use list(map()) if there is builtin functionAlways use map()!I consider that the most Pythonic way is to use a list comprehension instead of map and filter. The reason is that list comprehensions are clearer than map and filter.As you an see, a comprehension does not require extra lambda expressions as map needs. Furthermore, a comprehension also allows filtering easily, while map requires filter to allow filtering.