What are some common, real world examples of using the Builder Pattern?  What does it buy you?  Why not just use a Factory Pattern?The key difference between a builder and factory IMHO, is that a builder is useful when you need to do lots of things to build an object. For example imagine a DOM. You have to create plenty of nodes and attributes to get your final object. A factory is used when the factory can easily create the entire object within one method call.One example of using a builder is a building an XML document, I\'ve used this model when building HTML fragments for example I might have a Builder for building a specific type of table and it might have the following methods (parameters are not shown):This builder would then spit out the HTML for me. This is much easier to read then walking through a large procedural method.Check out Builder Pattern on Wikipedia.Below are some reasons arguing for the use of the pattern and example code in Java, but it is an implementation of the Builder Pattern covered by the Gang of Four in Design Patterns. The reasons you would use it in Java are also applicable to other programming languages as well.As Joshua Bloch states in Effective Java, 2nd Edition: The builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters.We\'ve all at some point encountered a class with a list of constructors where each addition adds a new option parameter:This is called the Telescoping Constructor Pattern. The problem with this pattern is that once constructors are 4 or 5 parameters long it becomes difficult to remember the required order of the parameters as well as what particular constructor you might want in a given situation.One alternative you have to the Telescoping Constructor Pattern is the JavaBean Pattern where you call a constructor with the mandatory parameters and then call any optional setters after: The problem here is that because the object is created over several calls it may be in an inconsistent state partway through its construction. This also requires a lot of extra effort to ensure thread safety.The better alternative is to use the Builder Pattern.Note that Pizza is immutable and that parameter values are all in a single location. Because the Builder\'s setter methods return the Builder object they are able to be chained.This results in code that is easy to write and very easy to read and understand. In this example, the build method could be modified to check parameters after they have been copied from the builder to the Pizza object and throw an IllegalStateException if an invalid parameter value has been supplied. This pattern is flexible and it is easy to add more parameters to it in the future. It is really only useful if you are going to have more than 4 or 5 parameters for a constructor. That said, it might be worthwhile in the first place if you suspect you may be adding more parameters in the future.I have borrowed heavily on this topic from the book Effective Java, 2nd Edition by Joshua Bloch. To learn more about this pattern and other effective Java practices I highly recommend it. Consider a restaurant. The creation of "today\'s meal" is a factory pattern, because you tell the kitchen "get me today\'s meal" and the kitchen (factory) decides what object to generate, based on hidden criteria.The builder appears if you order a custom pizza. In this case, the waiter tells the chef (builder) "I need a pizza; add cheese, onions and bacon to it!" Thus, the builder exposes the attributes the generated object should have, but hides how to set them..NET StringBuilder class is a great example of builder pattern. It is mostly used to create a string in a series of steps. The final result you get on doing ToString() is always a string but the creation of that string varies according to what functions in the StringBuilder class were used. To sum up, the basic idea is to build complex objects and hide the implementation details of how it is being built.For a multi-threaded problem, we needed a complex object to be built up for each thread. The object represented the data being processed, and could change depending on the user input.Could we use a factory instead? YesWhy didn\'t we? Builder makes more sense I guess. Factories are used for creating different types of objects that are the same basic type (implement the same interface or base class). Builders build the same type of object over and over, but the construction is dynamic so it can be changed at runtime.You use it when you have lots of options to deal with.  Think about things like jmock:It feels a lot more natural and is...possible.There\'s also xml building, string building and many other things.  Imagine if java.util.Map had put as a builder.  You could do stuff like this:While going through Microsoft MVC framework, I got a thought about builder pattern. I came across the pattern in the ControllerBuilder class. This class is to return the controller factory class, which is then used to build concrete controller.Advantage I see in using builder pattern is that, you can create a factory of your own and plug it into the framework. @Tetha, there can be a restaurant (Framework) run by Italian guy, that serves Pizza. In order to prepare pizza Italian guy (Object Builder) uses Owen (Factory) with a pizza base (base class).Now Indian guy takes over the restaurant from Italian guy. Indian restaurant (Framework) servers dosa instead of pizza. In order to prepare dosa Indian guy (object builder) uses Frying Pan (Factory) with a Maida (base class)If you look at scenario, food is different,way food is prepared is different, but in the same restaurant (under same framework). Restaurant should be build in such a way that it can support Chinese, Mexican or any cuisine. Object builder inside framework facilitates to plugin kind of cuisine you want. for exampleAnother advantage of the builder is that if you have a Factory, there is still some coupling in you code, because for the Factory to work, it has to know all the objects it can possibly create. If you add another object that could be created, you will have to modify the factory class to include him. This happens in the Abstract Factory as well.With the builder, on the other hand, you just have to create a new concrete builder for this new class. The director class will stay the same, because it receives the builder in the constructor.Also, there are many flavors of builder. Kamikaze Mercenary`s gives another one.Building on the previous answers (pun intended), an excellent real-world example is Groovy\'s built in support for Builders.See Builders in the Groovy DocumentationI used builder in home-grown messaging library. The library core was receiving data from the wire, collecting it with Builder instance, then, once Builder decided it\'ve got everything it needed to create a Message instance, Builder.GetMessage() was constructing a message instance using the data collected from the wire.When I wanted to use the standard XMLGregorianCalendar for my XML to object marshalling of DateTime in Java, I heard a lot of comments on how heavy weight and cumbersome it was to use it. I was trying to comtrol the XML fields in the xs:datetime structs to manage timezone, milliseconds, etc.So I designed a utility to build an XMLGregorian calendar from a GregorianCalendar or java.util.Date.Because of where I work I\'m not allowed to share it online without legal, but here\'s an example of how a client uses it. It abstracts the details and filters some of the implementation of XMLGregorianCalendar that are less used for xs:datetime.Granted this pattern is more of a filter as it sets fields in the xmlCalendar as undefined so they are excluded, it still "builds" it. I\'ve easily added other options to the builder to create an xs:date, and xs:time struct and also to manipulate timezone offsets when needed.If you\'ve ever seen code that creates and uses XMLGregorianCalendar, you would see how this made it much easier to manipulate.Check out InnerBuilder, an IntelliJ IDEA plugin that adds a \'Builder\' action to the Generate menu (Alt+Insert) which generates an inner builder class as described in Effective Javahttps://github.com/analytically/innerbuilderI always disliked the Builder pattern as something unwieldy, obtrusive and very often abused by less experienced programmers. Its a pattern which only makes sense if you need to assemble the object from some data which requires a post-initialisation step (i.e. once all the data is collected - do something with it). Instead, in 99% of the time builders are simply used to initialise the class members.In such cases it is far better to simply declare withXyz(...) type setters inside the class and make them return a reference to itself. Consider this:Now we have a neat single class that manages its own initialization and does pretty much the same job as the builder, except that its far more elegant. A great real world example is to use when unit testing your classes. You use sut (System Under Test) builders.Example:Class:Test:sut Builder: