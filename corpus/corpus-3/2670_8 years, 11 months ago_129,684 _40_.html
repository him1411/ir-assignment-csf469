I\'m a fan of extension methods in C#, but haven\'t had any success adding an extension method to a static class, such as Console.For example, if I want to add an extension to Console, called \'WriteBlueLine\', so that I can go:I tried this by adding a local, public static method, with Console as a \'this\' parameter... but no dice!    This didn\'t add a \'WriteBlueLine\' method to Console... am I doing it wrong? Or asking for the impossible?No.  Extension methods require an instance of an object.  You can however, write a static wrapper around the ConfigurationManager interface.  If you implement the wrapper, you don\'t need an extension method since you can just add the method directly.Can you add static extensions to classes in C#? No but you can do this:Here\'s how it works.  While you can\'t technically write static extension methods, instead this code exploits a loophole in extension methods.  That loophole being that you can call extension methods on null objects without getting the null exception (unless you access anything via @this).So here\'s how you would use this:Now WHY did I pick calling the default constructor as an example, and AND why don\'t I just return new T() in the first code snippet without doing all of that Expression garbage?\nWell todays your lucky day because you get a 2fer.  As any advanced .NET developer knows, new T() is slow because it generates a call to System.Activator which uses reflection to get the default constructor before calling it.  Damn you Microsoft!\nHowever my code calls the default constructor of the object directly.Static extensions would be better than this but desperate times call for desperate measures.Its not possible.And yes I think MS made a mistake here.Their decision does not make sense and forces programmers to write (as described above) a pointless wrapper class.Here is a good example: Trying to extend static MS Unit testing class Assert: I want 1 more Assert method AreEqual(x1,x2). The only way to do this is to point to different classes or write a wrapper around 100s of different Assert methods. Why!? If the decision was been made to allow extensions of instances I see no logical reason to not allow static extensions. The arguments about sectioning libraries does not stand up once instances can be extended.Maybe you could add a static class with your custom namespace and the same class name:Nope.  Extension method definitions require an instance of the type you\'re extending.  Its unfortunate; I\'m not sure why its required...You can\'t add static methods to a type.  You can only add (pseudo-)instance methods to an instance of a type.The point of the this modifier is to tell the C# compiler to pass the instance on the left-side of the . as the first parameter of the static/extension method.In the case of adding static methods to a type, there is no instance to pass for the first parameter.As for extension methods, extension methods themselves are static; but they are invoked as if they are instance methods.  Since a static class is not instantiable, you would never have an instance of the class to invoke an extension method from.  For this reason the compiler does not allow extension methods to be defined for static classes.Mr. Obnoxious wrote: "As any advanced .NET developer knows, new T() is slow because it generates a call to System.Activator which uses reflection to get the default constructor before calling it".New() is compiled to the IL "newobj" instruction if the type is known at compile time.  Newobj takes a constructor for direct invocation.  Calls to System.Activator.CreateInstance() compile to the IL "call" instruction to invoke System.Activator.CreateInstance().  New() when used against generic types will result in a call to System.Activator.CreateInstance().  The post by Mr. Obnoxious was unclear on this point... and well, obnoxious.  This code:produces this IL:I tried to do this with System.Environment back when I was learning extension methods and was not successful. The reason is, as others mention, because extension methods require an instance of the class.I stumbled up on this thread while trying to find an answer to the same question the OP had. I didn\'t find the answer I wanted but I ended up doing this. And I use it like this:yes, in a limited sense. This works but Console doesn\'t because it\'s static.This works because as long as it\'s not on the same namespace. The problem is that you have to write a proxy static method for every method that System.Console have. It\'s not necessarily a bad thing as you can add something like this:orThe way it works is that you hook something into the standard WriteLine. It could be a line count or bad word filter or whatever. Whenever you just specify Console in your namespace say WebProject1 and import the namespace System, WebProject1.Console will be chosen over System.Console as default for those classes in namespace WebProject1. So this code will turn all the Console.WriteLine calls into blue insofar as you never specified System.Console.WriteLine.The following was rejected as an edit to tvanfosson\'s answer. I was asked to contribute it as my own answer. I used his suggestion and finished the implementation of a ConfigurationManager wrapper. In principle I simply filled out the ... in tvanfosson\'s answer.No. Extension methods require an instance of an object. You can\n  however, write a static wrapper around the ConfigurationManager\n  interface. If you implement the wrapper, you don\'t need an extension\n  method since you can just add the method directly.You can use a cast on null to make it work.The extension:YourType:You CAN do this if you are willing to "frig" it a little by making a variable of the static class and assigning it to null. However, this method would not be available to static calls on the class, so not sure how much use it would be: