Using SQL Server 2005, how do I split a string so I can access item x?For exampleTake a string "Hello John Smith". How can I split the string by space and access the item at index 1 which should return "John"?You may find the solution in SQL User Defined Function to Parse a Delimited String helpful (from The Code Project).You can use this simple logic:I don\'t believe SQL Server has a built-in split function, so other than a UDF, the only other answer I know is to hijack the PARSENAME function:PARSENAME takes a string and splits it on the period character.  It takes a number as its second argument, and that number specifies which segment of the string to return (working from back to front).Obvious problem is when the string already contains a period.  I still think using a UDF is the best way...any other suggestions?First, create a function (using CTE, common table expression does away with the need for a temp table) Then, use it as any table (or modify it to fit within your existing stored proc) like this. UpdatePrevious version would fail for input string longer than 4000 chars. This version takes care of the limitation:Usage remains the same.Most of the solutions here use while loops or recursive CTEs. A set-based approach will be superior, I promise:More on split functions, why (and proof that) while loops and recursive CTEs don\'t scale, and better alternatives, if splitting strings coming from the application layer:http://www.sqlperformance.com/2012/07/t-sql-queries/split-stringshttp://www.sqlperformance.com/2012/08/t-sql-queries/splitting-strings-now-with-less-t-sqlhttp://sqlblog.com/blogs/aaron_bertrand/archive/2010/07/07/splitting-a-list-of-integers-another-roundup.aspxYou can leverage a Number table to do the string parsing. Create a physical numbers table:Create test table with 1000000 rowsCreate the functionUsage (outputs 3mil rows in 40s on my laptop)cleanupPerformance here is not amazing, but calling a function over a million row table is not the best idea. If performing a string split over many rows I would avoid the function. Here is a UDF which will do it.  It will return a table of the delimited values, haven\'t tried all scenarios on it but your example works fine.You would call it like this:Edit:  Updated solution to handle delimters with a len>1 as in :No code, but read the definitive article on this. All solutions in other answers are flavours of the ones listed in this article: Arrays and Lists in SQL Server 2005 and BeyondPersonally, I\'ve used a Numbers table solution most often because it suits what I have to do...Here I post a simple way of solution\n    Execute the function like thisIn my opinion you guys are making it way too complicated. Just create a CLR UDF and be done with it.What about using string and values() statement?Result-set achieved.I use the answer of frederic but this did not work in SQL Server 2005I modified it and I\'m using select with union all and it worksAnd the result-set is:This pattern works fine and you can generalizenote FIELD, INDEX and TYPE.Let some table with identifiers likeThen, you can writesplitting and casting all parts.I was looking for the solution on net and the below works for me.\nRef.And you call the function like this :Yet another get n\'th part of string by delimeter function:and the usage:which returns:Try this:Test it like this:The following example uses a recursive CTEUpdate 18.09.2013Demo on SQLFiddlequestion is not about a string split approach, but about how to get the nth element. All answers here are doing some kind of string splitting using recursion, CTEs, multiple CHARINDEX or PATINDEX, inventing functions, call for CLR methods, number tables, CROSS APPLYs ... Most answers cover many lines of code.But - if you really want nothing more than an approach to get the nth element - this can be done as real one-liner, no UDF, not even a sub-select... And as an extra benefit: type safeGet part 2 delimited by a space:Of course you can use variables for delimiter and position (use sql:column to retrieve the position directly from a query\'s value):If your string might include forbidden characters, you still can do it this way. Just use FOR XML PATH on your string first to replace all forbidden characters with the fitting escape sequence implicitly.It\'s a very special case if - additionally - your delimiter is the semicolon. In this case I replace the delimiter first to \'#DLMT#\', and replace this to the XML tags finally:I know it\'s an old Question, but i think some one can benefit from my solution.SQL FIDDLEAdvantages:Limitations:Note: the solution can give sub-string up to to N.To overcame the limitation we can use the following ref.But again the above solution can\'t be use in a table (Actaully i wasn\'t able to use it).Again i hope this solution can help some-one.Update: In case of Records > 50000 it is not advisable to use LOOPS as it will degrade the PerformanceAlmost all the other answers split code are replacing the string being split which wastes CPU cycles and performs unnecessary memory allocations.I cover a much better way to do a string split here: http://www.digitalruby.com/split-string-sql-server/Here is the code:Pure set-based solution using TVF with recursive CTE. You can JOIN and APPLY this function to any dataset.Usage:Result:You can split a string in SQL without needing a function:If you need to support arbitrary strings (with xml special characters)Well, mine isn\'t all that simpler, but here is the code I use to split a comma-delimited input variable into individual values, and put it into a table variable. I\'m sure you could modify this slightly to split based on a space and then to do a basic SELECT query against that table variable to get your results.The concept is pretty much the same. One other alternative is to leverage the .NET compatibility within SQL Server 2005 itself. You can essentially write yourself a simple method in .NET that would split the string and then expose that as a stored procedure/function.This is something I did in order to get a specific token in a string. (Tested in MSSQL 2008)First, creating the following functions: (found in: hereandthen you can use it like that:which return 1111Recursive CTE solution with server pain, test itMS SQL Server 2008 Schema Setup:Query 1:Results:while similar to the xml based answer by josejuan, i found that processing the xml path only once, then pivoting was moderately more efficient:ran in 8:30ran in 9:20AND USE ITif anyone wants to get only one part of the seperatured text can use thisselect * from fromSplitStringSep(\'Word1 wordr2 word3\',\' \') I devoloped this,the only attention you should is dot \'.\' that end of the @x is always should be there.building on @NothingsImpossible solution, or, rather, comment on the most voted answer (just below the accepted one), i found the following quick-and-dirty solution fulfill my own needs - it has a benefit of being solely within SQL domain.given a string "first;second;third;fourth;fifth", say, I want to get the third token. this works only if we know how many tokens the string is going to have - in this case it\'s 5. so my way of action is to chop the last two tokens away (inner query), and then to chop the first two tokens away (outer query)i know that this is ugly and covers the specific conditions i was in, but am posting it just in case somebody finds it useful. cheers