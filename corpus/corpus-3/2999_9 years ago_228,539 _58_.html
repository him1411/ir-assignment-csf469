Imagine this directory structure:I\'m coding mod1, and I need to import something from mod2. How should I do it?  I tried from ..sub2 import mod2 but I\'m getting an "Attempted relative import in non-package".I googled around but found only "sys.path manipulation" hacks. Isn\'t there a clean way?  Edit: all my __init__.py\'s are currently empty  Edit2: I\'m trying to do this because sub2 contains classes that are shared across sub packages (sub1, subX, etc.).Edit3: The behaviour I\'m looking for is the same as described in PEP 366 (thanks John B)Everyone seems to want to tell you what you should be doing rather than just answering the question.The problem is that you\'re running the module as \'__main__\' by passing the mod1.py as an argument to the interpreter.From PEP 328:Relative imports use a module\'s __name__ attribute to determine that module\'s position in the package hierarchy. If the module\'s name does not contain any package information (e.g. it is set to \'__main__\') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.In Python 2.6, they\'re adding the ability to reference modules relative to the main module.  PEP 366 describes the change.Update: According to Nick Coghlan, the recommended alternative is to run the module inside the package using the -m switch.Alternatively 2 or 3 could use: from app.package_a import module_aThat will work as long as you have app in your PYTHONPATH. main.py could be anywhere then.So you write a setup.py to copy (install) the whole app package and subpackages to the target system\'s python folders, and main.py to target system\'s script folders.Here is the solution which works for me:I do the relative imports as  from ..sub2 import mod2\nand then, if I want to run mod1.py then I go to the parent directory of app and run the module using the python -m switch as  python -m app.sub1.mod1.The real reason why this problem occurs with relative imports, is that relative imports works by taking the __name__ property of the module. If the module is being directly run, then __name__ is set to __main__ and it doesn\'t contain any information about package structure. And, thats why python complains about the relative import in non-package error.  So, by using the -m switch you provide the package structure information to python, through which it can resolve the relative imports successfully.I have encountered this problem many times while doing relative imports. And, after reading all the previous answers, I was still not able to figure out how to solve it, in a clean way, without needing to put boilerplate code in all files. (Though some of the comments were really helpful, thanks to @ncoghlan and @XiongChiamiov)Hope this helps someone who is fighting with relative imports problem, because going through PEP is really not fun."Guido views running scripts within a package as an anti-pattern" (rejected\nPEP-3122)I have spent so much time trying to find a solution, reading related posts here on Stack Overflow and saying to myself "there must be a better way!". Looks like there is not.I\'m using this snippet to import modules from paths, hope that helpsThis is solved 100%:Import settings/local_setting.py in app/main.py:main.py:explanation of nosklo\'s answer with examplesnote: all __init__.py files are empty.if you run $ python main.py it returns:so file in folder package_b used file in folder package_a, which is what you want. Right??This is unfortunately a sys.path hack, but it works quite well.I encountered this problem with another layer: I already had a module of the specified name, but it was the wrong module.what I wanted to do was the following (the module I was working from was module3):Note that I have already installed mymodule, but in my installation I do not have "mymodule1"and I would get an ImportError because it was trying to import from my installed modules.I tried to do a sys.path.append, and that didn\'t work.  What did work was a sys.path.insertSo kind of a hack, but got it all to work!\nSo keep in mind, if you want your decision to override other paths then you need to use sys.path.insert(0, pathname) to get it to work!  This was a very frustrating sticking point for me, allot of people say to use the "append" function to sys.path, but that doesn\'t work if you already have a module defined (I find it very strange behavior)Let me just put this here for my own reference. I know that it is not good Python code, but I needed a script for a project I was working on and I wanted to put the script in a scripts directory.As @EvgeniSergeev says in the comments to the OP, you can import code from a .py file at an arbitrary location with:This is taken from this SO answer.Take a look at http://docs.python.org/whatsnew/2.5.html#pep-328-absolute-and-relative-imports. You could do From Python doc,In Python 2.5, you can switch import\xe2\x80\x98s behaviour to absolute imports using a from __future__ import absolute_import directive. This absolute- import behaviour will become the default in a future version (probably Python 2.7). Once absolute imports are the default, import string will always find the standard library\xe2\x80\x99s version. It\xe2\x80\x99s suggested that users should begin using absolute imports as much as possible, so it\xe2\x80\x99s preferable to begin writing from pkg import string in your codeI found it\'s more easy to set "PYTHONPATH" enviroment variable to the top folder:then:of course, PYTHONPATH is "global", but it didn\'t raise trouble for me yet.On top of what John B said, it seems like setting the __package__ variable should help, instead of changing __main__ which could screw up other things. But as far as I could test, it doesn\'t completely work as it should.I have the same problem and neither PEP 328 or 366 solve the problem completely, as both, by the end of the day, need the head of the package to be included in sys.path, as far as I could understand.I should also mention that I did not find how to format the string that should go into those variables. Is it "package_head.subfolder.module_name" or what? Suppose you run at the top level, then in mod1 use:instead ofWhy you even need this? Why you just do not import it asI think that what you have to ask yourself is:I don\'t know the context why you want to do it this way. But for me a cleaner design would be to have the following packages structure:Then you only have to do:Don\'t do relative imports. They\'ll only make your code more fragile. If you do an absolute import as Matej suggested, you\'ll be less vulnerable to changes in sys.path and changes in file locations.