How do I send a cross-domain POST request via JavaScript?Notes - it shouldn\'t refresh the page, and I need to grab and parse the response afterward.Your help with some code examples will be much appreciated.Update: Before continuing everyone should read and understand the html5rocks tutorial on CORS. It is easy to understand and very clear.If you control the server being POSTed, simply leverage the "Cross-Origin Resource Sharing standard" by setting response headers on the server.  This answer is discussed in other answers in this thread, but not very clearly in my opinion.In short here is how you accomplish the cross domain POST from from.com/1.html to to.com/postHere.php (using PHP as an example). Note: you only need to set Access-Control-Allow-Origin for NON OPTIONS requests - this example always sets all headers for a smaller code snippet.In postHere.php setup the following:This allows your script to make cross domain POST, GET and OPTIONS.  This will become clear as you continue to read...Setup your cross domain POST from JS (jQuery example):When you do the POST in step 2, your browser will send a "OPTIONS" method to the server.  This is a "sniff" by the browser to see if the server is cool with you POSTing to it.  The server responds with an "Access-Control-Allow-Origin" telling the browser its OK to POST|GET|ORIGIN if request originated from "http://from.com" or "https://from.com".  Since the server is OK with it, the browser will make a 2nd request (this time a POST).  It is good practice to have your client set the content type it is sending - so you\'ll need to allow that as well.MDN has a great write-up about HTTP access control, that goes into detail of how the entire flow works. According to their docs, it should "work in browsers that support cross-site XMLHttpRequest". This is a bit misleading however, as I THINK only modern browsers allow cross domain POST.  I have only verified this works with safari,chrome,FF 3.6.Keep in mind the following if you do this:If you control the remote server, you should probably use CORS, as described in this answer; it\'s supported in IE8 and up, and all recent versions of FF, GC, and Safari. (But in IE8 and 9, CORS won\'t allow you to send cookies in the request.)So, if you don\'t control the remote server, or if you have to support IE7, or if you need cookies and you have to support IE8/9, you\'ll probably want to use an iframe technique.Here\'s sample code; I tested it on IE6, IE7, IE8, IE9, FF4, GC11, S5.Beware! You won\'t be able to directly read the response of the POST, since the iframe exists on a separate domain. Frames aren\'t allowed to communicate with each other from different domains; this is the same-origin policy.If you control the remote server but you can\'t use CORS (e.g. because you\'re on IE8/IE9 and you need to use cookies), there are ways to  work around the same-origin policy, for example by using window.postMessage and/or one of a number of libraries allowing you to send cross-domain cross-frame messages in older browsers:If you don\'t control the remote server, then you can\'t read the response of the POST, period. It would cause security problems otherwise.PseudocodeYou probably want to style the iframe, to be hidden and absolutely positioned.  Not sure cross site posting will be allowed by the browser, but if so, this is how to do it.If you have access to all servers involved, put the following in the header of the reply for the page being requested in the other domain:PHP:For example, in Drupal\'s xmlrpc.php code you would do this:This probably creates a security problem, and you should make sure that you take the appropriate measures to verify the request.Keep it simple: cross-domain POST:\nuse crossDomain: true,shouldn\'t refresh the page: \nNo, it will not refresh the page as the success or error async callback will be called when the server send back the response. Check the post_method function in http://taiyolab.com/mbtweet/scripts/twitterapi_call.js - a good example for the iframe method described above.Create two hidden iframes (add "display: none;" to the css style). Make your second iframe point to something on your own domain.Create a hidden form, set its method to "post" with target = your first iframe, and optionally set enctype to "multipart/form-data" (I\'m thinking you want to do POST because you want to send multipart data like pictures?)When ready, make the form submit() the POST.If you can get the other domain to return javascript that will do Cross-Domain Communication With Iframes (http://softwareas.com/cross-domain-communication-with-iframes) then you are in luck, and you can capture the response as well. Of course, if you want to use your server as a proxy, you can avoid all this. Simply submit the form to your own server, which will proxy the request to the other server (assuming the other server isn\'t set up to notice IP discrepancies), get the response, and return whatever you like.One more important thing to note!!!\nIn example above it\'s described how to use JQuery 1.6 and lower has a bug with cross-domain XHR.\nAccording to Firebug no requests except OPTIONS were sent. No POST. At all.Spent 5 hours testing/tuning my code. Adding a lot of headers on the remote server (script). Without any effect.\nBut later, I\'ve updated JQuery lib to 1.6.4, and everything works like a charm.If you want to do this in ASP.net MVC environment with JQuery AJAX, follow these steps:\n(this is a summary of the solution offered at this thread) Assume that "caller.com"(can be any website) needs to post to "server.com"(an ASP.net MVC application)On the "server.com" app\'s Web.config add the following section:On the "server.com", we\'ll have the following action on the controller(called "Home") to which we will be posting:Then from the "caller.com", post data from a form(with the html id "formId") to "server.com" as follow:High level.... You need to have a cname setup on your server so that other-serve.your-server.com points to other-server.com.Your page dynamically creates an invisible iframe, which acts as your transport to other-server.com.  You then have to communicate via JS from your page to the other-server.com and have call backs that return the data back to your page.  Possible but requires coordination from your-server.com and other-server.comThis is an old question, but some new technology might help someone out.If you have administrative access to the other server then you can use the opensource Forge project to accomplish your cross-domain POST. Forge provides a cross-domain JavaScript XmlHttpRequest wrapper that takes advantage of Flash\'s raw socket API. The POST can even be done over TLS.The reason you need administrative access to the server you are POSTing to is because you must provide a cross-domain policy that permits access from your domain.http://github.com/digitalbazaar/forgeI think the best way is to use XMLHttpRequest (e.g. $.ajax(), $.post() in jQuery) with one of Cross-Origin Resource Sharing polyfills https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#wiki-CORSI have a code example for this problem.http://reddymails.blogspot.com/2012/05/solving-cross-domain-problem-using.htmlThere is one more way (using html5 feature). You can use proxy iframe hosted on that other domain, you send message using postMessage to that iframe, then that iframe can do POST request (on same domain) and postMessage back with reposnse to the parent window.parent on sender.comiframe on reciver.comShould be possible with a YQL custom table + JS XHR, take a look at:\nhttp://developer.yahoo.com/yql/guide/index.htmlI use it to do some client side (js) html scraping, works fine \n(I have a full audio player, with search on internet/playlists/lyrics/last fm informations, all client js + YQL)I know this is an old question, but I wanted to share my approach. I use cURL as a proxy, very easy and consistent. Create a php page called submit.php, and add the following code:Then, in your js (jQuery here):CORS is for you.\nCORS is "Cross Origin Resource Sharing", is a way to send cross domain request.Now the XMLHttpRequest2 and Fetch API both support CORS, and it can send both POST and GET requestBut it has its limits.Server need to specific claim the Access-Control-Allow-Origin, and it can not be set to \'*\'.And if you want any origin can send request to you, you need JSONP (also need to set Access-Control-Allow-Origin, but can be \'*\')For lots of request way if you don\'t know how to choice, I think you need a full functional component to do that.Let me introduce a simple component https://github.com/Joker-Jelly/cattaIf you are using modern browser (> IE9, Chrome, FF, Edge, etc.), Very Recommend you to use a simple but beauty component https://github.com/Joker-Jelly/catta.It have no dependence, Less than 3KB, and it support Fetch, AJAX and JSONP with same deadly sample syntax and options.It also it support all the way to import to your project, like ES6 module, CommonJS and even <script> in HTML.