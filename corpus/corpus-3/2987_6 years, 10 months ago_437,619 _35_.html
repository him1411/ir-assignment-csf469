Suppose we have a HashMap<String, Integer> in Java.How do I update (increment) the integer-value of the string-key for each existence of the string I find?One could remove and reenter the pair, but overhead would be a concern.\nAnother way would be to just put the new pair and the old one would be replaced.In the latter case, what happens if there is a hashcode collision with a new key I am trying to insert? The correct behavior for a hashtable would be to assign a different place for it, or make a list out of it in the current bucket.should be fine.  It will update the value for the existing mapping.  Note that this uses auto-boxing.The method put will replace the value of an existing key and will create it if doesn\'t exist.You can use computeIfPresent method and supply it a mapping function, which will be called to compute a new value based on existing one.For example,Alternatevely, you could use merge method, where 1 is the default value and function increments existing value by 1:In addition, there is a bunch of other useful methods, such as putIfAbsent, getOrDefault, forEach, etc.Replace Integer by AtomicInteger and call one of the incrementAndGet/getAndIncrement methods on it.An alternative is to wrap an int in your own MutableInteger class which has an increment() method, you only have a threadsafety concern to solve yet.@Matthew\'s solution is the simplest and will perform well enough in most cases.If you need high performance, AtomicInteger is a better solution ala @BalusC.However, a faster solution (provided thread safety is not an issue) is to use TObjectIntHashMap which provides a increment(key) method and uses primitives and less objects than creating AtomicIntegers. e.g.You can increment like below but you need to check for existence so that a NullPointerException is not thrownDoes the hash exist (with 0 as the value) or is it "put" to the map on the first increment? If it is "put" on the first increment, the code should look like:The simplified Java 8 way:This uses the method of HashMap that retrieves the value for a key, but if the key can\'t be retrieved it returns the specified default value (in this case a \'0\').This is supported within core Java: HashMap<K,V> getOrDefault(Object key, V defaultValue)One line solution:It may be little late but here are my two cents.If you are using Java 8 then you can make use of computeIfPresent method. If the value for the specified key is present and non-null then it attempts to compute a new mapping given the key and its current mapped value.We can also make use of another method putIfAbsent to put a key. If the specified key is not already associated with a value (or is mapped to null) then this method associates it with the given value and returns null, else returns the current value.In case the map is shared across threads then we can make use of ConcurrentHashMap and AtomicInteger. From the doc:An AtomicInteger is an int value that may be updated atomically.  An\n  AtomicInteger is used in applications such as atomically incremented\n  counters, and cannot be used as a replacement for an Integer. However,\n  this class does extend Number to allow uniform access by tools and\n  utilities that deal with numerically-based classes.We can use them as shown:One point to observe is we are invoking get to get the value for key B and then invoking incrementAndGet() on its value which is of course AtomicInteger. We can optimize it as the method putIfAbsent returns the value for the key if already present: On a side note if we plan to use AtomicLong then as per documentation under high contention expected throughput of LongAdder is significantly higher, at the expense of higher space consumption. Also check this question.Use a for loop to increment the index:There are misleading answers to this question here that imply Hashtable put method will replace the existing value if the key exists, this is not true for Hashtable but rather for HashMap. See Javadoc for HashMap http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html#put%28K,%20V%29Try:NOTE:You can change either the key or the value in your hashmap, but you can\'t change both at the same time. or