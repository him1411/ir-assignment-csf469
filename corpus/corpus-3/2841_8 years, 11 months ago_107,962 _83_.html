I have a method that is suppose to return an object if it is found.If it is not found, should I:If you are always expecting to find a value then throw the exception if it is missing.  The exception would mean that there was a problem.If the value can be missing or present and both are valid for the application logic then return a null.More important: What do you do other places in the code?  Consistency is important.Only throw an exception if it is truly an error. If it is expected behavior for the object to not exist, return the null.Otherwise it is a matter of preference.As a general rule, if the method should always return an object, then go with the exception. If you anticipate the occasional null and want to handle it in a certain way, go with the null. Whatever you do, I highly advise against the third option: Returning a string that says "WTF".If null never indicates an error then just return null.If null is always an error then throw an exception.If null is sometimes an exception then code two routines. One routine throws an exception and the other is a boolean test routine that returns the object in an output parameter and the routine returns a false if the object was not found.It\'s hard to misuse a Try routine. It\'s real easy to forget to check for null.So when null is an error you just writeWhen the null isn\'t an error you can code something likeI just wanted to recapitulate the options mentioned before, throwing some new ones in:Or you might combine these options:Provide several overloaded versions of your getter, so the caller can decide which way to go. In most cases, only the first one has an implementation of the search algorithm, and the other ones just wrap around the first one:Even if you choose to provide only one implementation, you might want to use a naming convention like that to clarify your contract, and it helps you should you ever decide to add other implementations as well.You should not overuse it, but it may be helpfull, espeacially when writing a helper Class which you will use in hundreds of different applications with many different error handling conventions.Use the null object pattern or throw an exception.Be consistent with the API(s) you\'re using.Just ask yourself:  "is it an exceptional case that the object is not found"?  If it is expected to happen in the normal course of your program, you probably should not raise an exception (since it is not exceptional behavior).Short version:  use exceptions to handle exceptional behavior, not to handle normal flow of control in your program.-Alan.it depends if your language and code promotes: \nLBYL (look before you leap)\nor \nEAFP (easier to ask forgiveness than permission)LBYL says you should check for values (so return a null)\nEAFP says to just try the operation and see if it fails (throw an exception)though I agree with above.. exceptions should be used for exceptional/error conditions, and returning a null is best when using checks.EAFP vs. LBYL in Python: \nhttp://mail.python.org/pipermail/python-list/2003-May/205182.html \n(Web Archive)I prefer to just return a null, and rely on the caller to handle it appropriately. The (for lack of a better word) exception is if I am absolutely \'certain\' this method will return an object. In that case a failure is an exceptional should and should throw.Depends on what it means that the object is not found.If it\'s a normal state of affairs, then return null. This is just something that might happen once in an while, and the callers should check for it. If it\'s an error, then throw an exception, the callers should decide what to do with the error condition of missing object. Ultimately either would work, although most people generally consider it good practice to only use Exceptions when something, well, Exceptional has happened.Exceptions are related to Design by Contract. The interface of an objects is actually a contract between two objects, the caller must meet the contract or else the receiver may just fail with an exception. There are two possible contracts1) all input the method is valid, in which case you must return null when the object is not found.2) only some input is valid, ie that which results in a found object. In which case you MUST offer a second method that allows the caller to determine if its input will be correct. For exampleIF and ONLY IF you provide both methods of the 2nd contract, you are allowed to throw an exception is nothing is found!Advantages of throwing an exception:For more explanation with examples, see: http://metatations.com/2011/11/17/returning-null-vs-throwing-an-exception/In some functions I add a parameter:True means throw, false means return some error return value. This way, whoever uses this function has both options. The default should be true, for the benefit of those who forget about error handling.Return a null instead of throwing an exception and clearly document the possibility of a null return value in the API documentation. If the calling code doesn\'t honor the API and check for the null case, it will most probably result in some sort of "null pointer exception" anyway :)In C++, I can think of 3 different flavors of setting up a method that finds an object.Option AReturn null when an object can\'t be found. Nice and simple. I\'d go with this one. The alternative approaches below are for people who don\'t hate out-params.Option BPass in a reference to variable that will be receiving the object. The method thrown an exception when an object can\'t be found. This convention is probably more suitable if it\'s not really expected for an object not to be found -- hence you throw an exception to signify that it\'s an unexpected case.Option CThe method returns false when an object can\'t be found. The advantage of this over option A is that you can check for the error case in one clear step:Here are a couple more suggestions.If returning a collection, avoid returning null, return an empty collection which makes enumeration easier to deal with without a null check first.Several .NET API\'s use the pattern of a thrownOnError parameter which gives the caller the choice as whether it is really an exceptional situation or not if the object is not found.  Type.GetType is an example of this.  Another common pattern with BCL is the TryGet pattern where a boolean is returned and the value is passed via an output parameter.You could also consider the Null Object pattern in some circumstances which can either be a default or a version with no behaviour.  The key is avoid null checks throughout the code base.  See here for more information http://geekswithblogs.net/dsellers/archive/2006/09/08/90656.aspxreferring only to the case where null is not considered an exceptional behavior i am definitely for the try method, it is clear, no need to "read the book" or "look before you leap" as was said hereso basically: and this means that the user\'s code will also be clearIf it\'s important for client code to know the difference between found and not found and this is supposed to be a routine behavior, then it\'s best to return null.  Client code can then decide what to do.Generally it should return null. The code calling the method should decide whether to throw an exception or to attempt something else.Or return an OptionAn option is basically a container class that forces the client to handle booth cases. Scala has this concept, look up it\'s API.Then you have methods like T getOrElse(T valueIfNull) on this object thet either return the found object, or an allternative the client specifieces.As long as it\'s supposed to return a reference to the object, returning a NULL should be good. However, if it\'s returning the whole bloody thing (like in C++ if you do: \'return blah;\' rather than \'return &blah;\' (or \'blah\' is a pointer), then you can\'t return a NULL, because it\'s not of type \'object\'. In that case, throwing an exception, or returning a blank object that doesn\'t have a success flag set is how I would approach the problem.Don\'t think anyone mentioned the overhead in exception handling - takes additional resources to load up and process the exception so unless its a true app killing or process stopping event (going forward would cause more harm than good) I would opt for passing back a value the calling environment could interpret as it sees fit.I agree with what seems to be the consensus here (return null if "not found" is a normal possible outcome, or throw an exception if the semantics of the situation require that the object always be found).There is, however, a third possibility that might make sense depending on your particular situation. Your method could return a default object of some sort in the "not found" condition, allowing calling code to be assured that it will always receive a valid object without the need for null checking or exception catching.Return a null, exceptions are exactly that:  something your code does that isn\'t expected.Exceptions should be exceptional. Return null if it is valid to return a null.Prefer returning null --If the caller uses it without checking, the exception happens right there anyway.If the caller doesn\'t really use it, don\'t tax him a try/catch blockUnfortunately JDK is inconsistent, if you trying access non existing key in resource bundle, you get not found exception and when you request value from map you get null if it doesn\'t exists. So I would change winner answer to the following, if found value can be null, then raise exception when it isn\'t found, otherwise return null. So follow to the rule with one exception, if you need to know why value isn\'t found then always raise exception, or.. If the method returns a collection, then return an empty collection (like sayed above). But please not Collections.EMPTY_LIST or such! (in case of Java)If the method retrives a single object, then You have some options.Be careful, if you decide to return a null. If you are not the only programmer in project you will get NullPointerExceptions (in Java or whatever in other Languages) at run time! So don\'t return nulls which are not checked at compile time.If you are using a library or another class which throws an exception, you should rethrow it. Here is an example. Example2.java is like library and Example.java uses it\'s object. Main.java is an example to handle this Exception. You should show a meaningful message and (if needed) stack trace to the user in the calling side.Main.javaExample.javaExample2.javaThat really depends on if you expect to find the object, or not. If you follow the school of thought that exceptions should be used for indicating something, well, err, exceptional has occured then:Otherwise, return null.