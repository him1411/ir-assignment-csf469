My program does some network activity in a background thread. Before starting, it pops up a progress dialog. The dialog is dismissed on the handler. This all works fine, except when screen orientation changes while the dialog is up (and the background thread is going). At this point the app either crashes, or deadlocks, or gets into a weird stage where the app does not work at all until all the threads have been killed.How can I handle the screen orientation change gracefully?The sample code below matches roughly what my real program does:Stack:I have tried to dismiss the progress dialog in onSaveInstanceState, but that just prevents an immediate crash. The background thread is still going, and the UI is in partially drawn state. Need to kill the whole app before it starts working again.When you switch orientations, Android will create a new View.  You\'re probably getting crashes because your background thread is trying to change the state on the old one.  (It may also be having trouble because your background thread isn\'t on the UI thread)I\'d suggest making that mHandler volatile and updating it when the orientation changes.Edit: Google engineers do not recommend this approach, as described by Dianne Hackborn (a.k.a. hackbod) in this StackOverflow post. Check out this blog post for more information.You have to add this to the activity declaration in the manifest:so it looks likeThe matter is that the system destroys the activity when a change in the configuration occurs. See ConfigurationChanges.So putting that in the configuration file avoids the system to destroy your activity. Instead it invokes the onConfigurationChanged(Configuration) method. I came up with a rock-solid solution for these issues that conforms with the \'Android Way\' of things. I have all my long-running operations using the IntentService pattern.\nThat is my activities broadcast intents, the IntentService does the work, saves the data in the DB and then broadcasts STICKY intents.\nThe sticky part is important, such that even if the Activity was paused during during the time after the user initiated the work and misses the real time broadcast from the ItentService we can still respond and pick up the data from the calling Activity.\nProgressDialogs can work into this pattern quite nicely with onSaveInstanceSate().\nBasically, you need to save a flag that you have a progress dialog running in the saved instance bundle. DO NOT save the progress dialog object because this will leak the entire Activity.\n To have a persistent handle to the progress dialog, I store it as a Weak-reference in the application object.\nOn orientation change or any thing else that causes the Activity to pause (phone call, user hits home etc) and then resume, I dismiss the old dialog and recreate a new dialog in the newly created Activity.\n For indefinite progress dialogs this is easy. For progress bar style, you have to put the last known progress in the bundle and whatever information you\'re using locally in the activity to keep track of the progress.\nOn restore the progress, you\'ll use this information to re-spawn the progress bar in the same state as before and then update based on the current state of things.\nSo to summarize, putting long-running tasks into an IntentService coupled with juidcious use of onSaveInstanceState() allows you to efficiently keep track of dialogs and restore then across the Activity life-cycle events.  Relevant bits of Activity code are below. You\'ll also need logic in your BroadcastReceiver to handle Sticky intents appropriately, but that is beyond the scope of this. I met the same problem. My activity needs to parse some data from a URL and it\'s slow. So I create a thread to do so then show a progressdialog. I let the thread post a msg back to UI thread via Handler when it\'s finished. In Handler.handleMessage, I get the data object (ready now) from thread and populate it to UI. So it\'s very similar to your example.After many trial and error it looks like I found a solution. At least now I can rotate screen at any moment, before or after the thread is done. In all tests, the dialog is properly closed and all behaviors are as expected.What I did is shown below. The goal is to fill my data model (mDataObject) and then populate it to UI. Should allow screen rotation at any moment without surprise.That\'s what works for me. I don\'t know if this is the "correct" method as designed by Android -- they claim this "destroy/recreate activity during screen rotation" actually makes things easier, so I guess it shouldn\'t be too tricky.Let me know if you see a problem in my code. As said above I don\'t really know if there is any side effect.My solution was to extend the ProgressDialog class to get my own MyProgressDialog.\nI redefined show() and dismiss() methods to lock the orientation before showing the Dialog and unlock it back when Dialog is dismissed. So when the Dialog is shown and the orientation of the device changes, the orientation of the screen remains until dismiss() is called, then screen-orientation changes according to sensor-values/device-orientation.Here is my code:The original perceived problem was that the code would not survive a screen orientation change. Apparently this was "solved" by having the program handle the screen orientation change itself, instead of letting the UI framework do it (via calling onDestroy)).  I would submit that if the underlying problem is that the program will not survive onDestroy(), then the accepted solution is just a workaround that leaves the program with serious other problems and vulnerabilities.  Remember that the Android framework specifically states that your activity is at risk for being destroyed almost at any time due to circumstances outside your control. Therefore, your activity must be able to survive onDestroy() and subsequent onCreate() for any reason, not just a screen orientation change.If you are going to accept handling screen orientation changes yourself to solve the OP\'s problem, you need to verify that other causes of onDestroy() do not result in the same error. Are you able to do this?  If not, I would question whether the "accepted" answer is really a very good one. I faced this same problem, and I came up with a solution that didn\'t invole using the ProgressDialog and I get faster results.What I did was create a layout that has a ProgressBar in it.Then in the onCreate method do the followingThen do the long task in a thread, and when that\'s finished have a Runnable set the content view to the real layout you want to use for this activity.For example:This is what I did, and I\'ve found that it runs faster than showing the ProgressDialog and it\'s less intrusive and has a better look in my opinion.However, if you\'re wanting to use the ProgressDialog, then this answer isn\'t for you.I going to contribute my approach to handling this rotation issue. This may not be relevant to OP as he\'s not using AsyncTask, but maybe others will find it useful. It\'s pretty simple but it seems to do the job for me:I have a login activity with a nested AsyncTask class called BackgroundLoginTask.In my BackgroundLoginTask I don\'t do anything out of the ordinary except to add a null check upon calling ProgressDialog\'s dismiss:This is to handle the case where the background task finishes while the Activity is not visible and, therefore, the progress dialog has already been dismissed by the onPause() method.Next, in my parent Activity class, I create global static handles to my AsyncTask class and my ProgressDialog (the AsyncTask, being nested, can access these variables):This serves two purposes: First, it allows my Activity to always access the AsyncTask object even from a new, post-rotated activity. Second, it allows my BackgroundLoginTask to access and dismiss the ProgressDialog even after a rotate.Next, I add this to onPause(), causing the progress dialog to disappear when our Activity is leaving the foreground (preventing that ugly "force close" crash):Finally, I have the following in my onResume() method:This allows the Dialog to reappear after the Activity is recreated.Here is the entire class:I am by no means a seasoned Android developer, so feel free to comment.I discovered a solution to this that I haven\'t yet seen elsewhere. You can use a custom application object that knows if you have background tasks going, instead of trying to do this in the activity that gets destroyed and recreated on orientation change. I blogged about this in here.Move the long task to a seperate class. Implement it as a subject-observer pattern. Whenever the activity is created register and while closing unregister with the task class. Task class can use AsyncTask.The trick is to show/dismiss the dialog within AsyncTask during onPreExecute/onPostExecute as usual, though in case of orientation-change create/show a new instance of the dialog in the activity and pass its reference to the task.I have done it like this:You can also try and let me know it works for you or not If you create a background Service that does all the heavy lifting (tcp requests/response, unmarshalling), the View and Activity can be destroyed and re-created without leaking window or losing data. This allows the Android recommended behavior, which is to destroy an Activity on each configuration change (eg. for each orientation change). It is a bit more complex, but it is the best way for invoking server request, data pre/post-processing, etc.You may even use your Service to queue each request to a server, so it makes it easy and efficient to handle those things. The dev guide has a full chapter on Services.I have an implementation which allows the activity to be destroyed on a screen orientation change, but still destroys the dialog in the recreated activity successfully. \nI use ...NonConfigurationInstance to attach the background task to the recreated activity. \nThe normal Android framework handles recreating the dialog itself, nothing is changed there.I subclassed AsyncTask adding a field for the \'owning\' activity, and a method to update this owner.In my activity class I added a field backgroundTask referring to the \'owned\' backgroundtask, and I update this field using onRetainNonConfigurationInstance and getLastNonConfigurationInstance.Suggestions for further improvement:If you maintain two layouts, all UI thread should be terminated. If you use AsynTask, then you can easily call .cancel() method inside onDestroy() method of current activity.For AsyncTask, read more in "Cancelling a task" section at here.Update:\nAdded condition to check status, as it can be only cancelled if it is in running state.\nAlso note that the AsyncTask can only be executed one time.Tried to implement jfelectron\'s solution because it is a "rock-solid solution to these issues that conforms with the \'Android Way\' of things" but it took some time to look up and put together all the elements mentioned. Ended up with this slightly different, and I think more elegant, solution posted here in it\'s entirety. Uses an IntentService fired from an activity to perform the long running task on a separate thread. The service fires back sticky Broadcast Intents to the activity which update the dialog. The Activity uses showDialog(), onCreateDialog() and onPrepareDialog() to eliminate the need to have persistent data passed in the application object or the savedInstanceState bundle. This should work no matter how your application is interrupted.Activity Class:IntentService Class:Manifest file entries:before application section:inside application sectionThis is my proposed solution:I\'ve tried EVERYTHING. Spent days experimenting. I didn\'t want to block the activity from rotating. My scenario was:The problem was, when rotating the screen, every solution on the book failed. Even with the AsyncTask class, which is the correct Android way of dealing with this situations. When rotating the screen, the current Context that the starting thread is working with, is gone, and that messes up with the dialog that is showing. The problem was always the Dialog, no matter how many tricks I added to the code (passing new contexts to running threads, retaining thread states through rotations, etc...). The code complexity at the end was always huge and there was always something that could go wrong.The only solution that worked for me was the Activity/Dialog trick. It\'s simple and genius and it\'s all rotation proof:Instead of creating a Dialog and ask to show it, create an Activity that has been set in the manifest with android:theme="@android:style/Theme.Dialog". So, it just looks like a dialog.Replace showDialog(DIALOG_ID) with startActivityForResult(yourActivityDialog, yourCode);Use onActivityResult in the calling Activity to get the results from the executing thread (even the errors) and update the UI.On your \'ActivityDialog\', use threads or AsyncTask to execute long tasks and onRetainNonConfigurationInstance to save "dialog" state when rotating the screen.This is fast and works fine. I still use dialogs for other tasks and the AsyncTask for something that doesn\'t require a constant dialog on screen. But with this scenario, I always go for the Activity/Dialog pattern.And, I didn\'t try it, but it\'s even possible to block that Activity/Dialog from rotating, when the thread is running, speeding things up, while allowing the calling Activity to rotate.These days there is a much more distinct way to handle these types of issues. The typical approach is:Anything that is a background process should be in a retained Fragment (set this with Fragment.setRetainInstance(). This becomes your \'persistent data storage\' where anything data based that you would like retained is kept. After the orientation change event, this Fragment will still be accessible in its original state through a FragmentManager.findFragmentByTag() call (when you create it you should give it a tag not an ID as it is not attached to a View).See the Handling Runtime Changes developed guide for information about doing this correctly and why it is the best option.You must reverse your linking process. At the moment your background process attaches itself to a View - instead your View should be attaching itself to the background process. It makes more sense right? The View\'s action is dependent on the background process, whereas the background process is not dependent on the View.This means changing the link to a standard Listener interface. Say your process (whatever class it is - whether it is an AsyncTask, Runnable or whatever)  defines a OnProcessFinishedListener, when the process is done it should call that listener if it exists.This answer is a nice concise description of how to do custom listeners.Now you must worry about interfacing the background task with whatever your current View structure is. If you are handling your orientation changes properly (not the configChanges hack people always recommend), then your Dialog will be recreated by the system. This is important, it means that on the orientation change, all your Dialog\'s lifecycle methods are recalled. So in any of these methods (onCreateDialog is usually a good place), you could do a call like the following:See the Fragment lifecycle for deciding where setting the listener best fits in your individual implementation.This is a general approach to providing a robust and complete solution to the generic problem asked in this question. There is probably a few minor pieces missing in this answer depending on your individual scenario, but this is generally the most correct approach for properly handling orientation change events.I faced the same situation. What I did was get only one instance for my progress dialog in the entire application.First, I created a DialogSingleton class to get only one instance (Singleton pattern)As I show in this class, I have the progress dialog as attribute. Every time I need to show a progress dialog, I get the unique instance and create a new ProgressDialog. When I am done with the background task, I call again the unique instance and dismiss its dialog.I save the background task status in my shared preferences. When I rotate the screen, I ask if I have a task running for this activity: (onCreate)When I start running a background task:When I finish running a background task:I hope it helps.This is a very old question that came up on the sidebar for some reason.If the background task only needs to survive while the activity is in the foreground, the "new" solution is to host the background thread (or, preferably, AsyncTask) in a retained fragment, as described in this developer guide and numerous Q&As.A retained fragment survives if the activity is destroyed for a configuration change, but not when the activity is destroyed in the background or back stack.  Therefore, the background task should still be interrupted if isChangingConfigurations() is false in onPause().Seems far too \'quick and dirty\' to be true so please point out the flaws but what I found worked was...Within the onPostExecute method of my AsyncTask, I simply wrapped the \'.dismiss\' for the progress dialog in a try/catch block (with an empty catch) and then simply ignored the exception that was raised. Seems wrong to do but appears there are no ill effects (at least for what I am doing subsequently which is to start another activity passing in the result of my long running query as an Extra)The simplest and most flexible solution is to use an AsyncTask with a static reference to ProgressBar. This provides an encapsulated and thus reusable solution to orientation change problems. This solution has served me well for varying asyncronous tasks including internet downloads, communicating with Services, and filesystem scans. The solution has been well tested on multiple android versions and phone models. A complete demo can be found here with specific interest in DownloadFile.javaI present the following as a concept exampleUsage in an Android Activity is simplei have found and easier solution to handle threads when orientation change. You can just keep an static reference to your activity/fragment and verify if its null before acting on the ui. I suggest using a try catch too:If you\'re struggling with detecting orientation change events of a dialog INDEPENDENT OF AN ACTIVITY REFERENCE, this method works excitingly well.  I use this because I have my own dialog class that can be shown in multiple different Activities so I don\'t always know which Activity it\'s being shown in.  With this method you don\'t need to change the AndroidManifest, worry about Activity references, and you don\'t need a custom dialog (as I have). You do need, however, a custom content view so you can detect the orientation changes using that particular view. Here\'s my example:I am a fresher in android and I tried this and it\'s worked.