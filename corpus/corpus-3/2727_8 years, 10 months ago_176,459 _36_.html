My question is similar to "What is the difference between include and extend in Ruby?".What\'s the difference between require and include in Ruby?  If I just want to use the methods from a module in my class, should I require it or include it?What\'s the difference between\n  "include" and "require" in Ruby?Answer:The include and require methods do\n  very different things.The require method does what include\n  does in most other programming\n  languages: run another file. It also\n  tracks what you\'ve required in the\n  past and won\'t require the same file\n  twice. To run another file without\n  this added functionality, you can use\n  the load method.The include method takes all the\n  methods from another module and\n  includes them into the current module.\n  This is a language-level thing as\n  opposed to a file-level thing as with\n  require. The include method is the\n  primary way to "extend" classes with\n  other modules (usually referred to as\n  mix-ins). For example, if your class\n  defines the method "each", you can\n  include the mixin module Enumerable\n  and it can act as a collection. This\n  can be confusing as the include verb\n  is used very differently in other\n  languages.SourceSo if you just want to use a module, rather than extend it or do a mix-in, then you\'ll want to use require.Oddly enough, Ruby\'s require is analogous to C\'s include, while Ruby\'s include is almost nothing like C\'s include.From the Metaprogramming Ruby book,  The require() method is quite similar to load(), but it\xe2\x80\x99s meant for\n  a different purpose. You use load() to execute code, and you use\n  require() to import libraries.If you\'re using a module, that means you\'re bringing all the methods into your class. \n   If you extend a class with a module, that means you\'re "bringing in" the module\'s methods as class methods.\n   If you include a class with a  module, that means you\'re "bringing in" the module\'s methods as instance methods.EX:B.say\n=> undefined method \'say\' for B:ClassB.new.say\n=> this is module AC.say\n=> this is module AC.new.say\n=> undefined method \'say\' for C:ClassRuby require is more like "include" in other languages (such as C). It tells Ruby that you want to bring in the contents of another file. Similar mechanisms in other languages are:Ruby includeis an object-oriented inheritance mechanism used for mixins.There is a good explanation here:[The] simple answer is that require and include are essentially unrelated."require" is similar to the C include, which may cause newbie confusion.\n  (One notable difference is that locals inside the required file "evaporate"\n  when the require is done.)The Ruby include is nothing like the C include. The include statement "mixes in" a module into a class. It\'s a limited form\n  of multiple inheritance. An included module literally bestows an "is-a"\n  relationship on the thing including it.Emphasis added.Have you ever tried to require a module? What were the results? Just try:Modules cannot be required, only included!From Programming Ruby 1.9We\xe2\x80\x99ll make a couple of points about the include statement before we go on. First, it has\n  nothing to do with files. C programmers use a preprocessor directive called #include to\n  insert the contents of one file into another during compilation. The Ruby include statement\n  simply makes a reference to a module. If that module is in a separate file, you must use\n  require (or its less commonly used cousin, load) to drag that file in before using include.\n  Second, a Ruby include does not simply copy the module\xe2\x80\x99s instance methods into the class.\n  Instead, it makes a reference from the class to the included module. If multiple classes\n  include that module, they\xe2\x80\x99ll all point to the same thing. If you change the definition of a\n  method within a module, even while your program is running, all classes that include that\n  module will exhibit the new behavior.Include\nWhen you Include a module into your class as shown below, it\xe2\x80\x99s as if you took the code defined within the module and inserted it within the class, where you \xe2\x80\x98include\xe2\x80\x99 it. It allows the \xe2\x80\x98mixin\xe2\x80\x99 behavior. It\xe2\x80\x99s used to DRY up your code to avoid duplication, for instance, if there were multiple classes that would need the same code within the module.Load\nThe load method is almost like the require method except it doesn\xe2\x80\x99t keep track of whether or not that library has been loaded. So it\xe2\x80\x99s possible to load a library multiple times and also when using the load method you must specify the \xe2\x80\x9c.rb\xe2\x80\x9d extension of the library file name.Require\nThe require method allows you to load a library and prevents it from being loaded more than once. The require method will return \xe2\x80\x98false\xe2\x80\x99 if you try to load the same library after the first time. The require method only needs to be used if library you are loading is defined in a separate file, which is usually the case.You can prefer this \nhttp://ionrails.com/2009/09/19/ruby_require-vs-load-vs-include-vs-extend/It will return bolean true/falseThe name which is passed as parameter to the require, ruby will try to find the source file with that name in your load path.\n The require method will return \xe2\x80\x98false\xe2\x80\x99 if you try to load the same library after the first time. The require method only needs to be used if library you are loading is defined in a separate file.\nSo it keeps track of whether that library was already loaded or not.Suppose if you have some methods that you need to have in two different classes. Then you don\'t have to write them in both the classes. Instead what you can do is, define it in module. And then include this module in other classes.\nIt is provided by Ruby just to ensure DRY principle.  It\xe2\x80\x99s used to DRY up your code to avoid duplication