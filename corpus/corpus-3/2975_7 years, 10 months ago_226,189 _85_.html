In C, one can do like this:or So I wonder what is the difference? I want to know what actually happens for memory allocation during compile time and run time. The difference here is that will place "Hello world" in the read-only parts of the memory, and making s a pointer to that makes any writing operation on this memory illegal. While doing:puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus makinglegal.First off, in function arguments, they are exactly equivalent:In other contexts, char * allocates a pointer, while char [] allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):Using the array syntax directly allocates it into new memory. Thus modification is safe:However the array only lives as long as its contaning scope, so if you do this in a function, don\'t return or leak a pointer to this array - make a copy instead with strdup() or similar. If the array is allocated in global scope, of course, no problem.This declaration:Creates one object - a char array of size 6, called s, initialised with the values \'h\', \'e\', \'l\', \'l\', \'o\', \'\\0\'.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it\'s outside a function, it will probably be stored within an "initialised data segment" that is loaded from the executable file into writeable memory when the program is run.On the other hand, this declaration:Creates two objects:The unnamed read-only array is typically located in the "text" segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the s pointer variable in memory depends on where the declaration appears (just like in the first example).Given the declarationsassume the following hypothetical memory map:The string literal "hello world" is a 12-element array of char (const char in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.  The linedefines s0 as a pointer to char with auto storage duration (meaning the variable s0 only exists for the scope in which it is declared) and copies the address of the string literal (0x00008000 in this example) to it. Note that since s0 points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., strtok(), strcat(), strcpy(), etc.).  The linedefines s1 as a 12-element array of char (length is taken from the string literal) with auto storage duration and copies the contents of the literal to the array.  As you can see from the memory map, we have two copies of the string "hello world"; the difference is that you can modify the string contained in s1.  s0 and s1 are interchangeable in most contexts; here are the exceptions:You can reassign the variable s0 to point to a different string literal or to another variable.  You cannot reassign the variable s1 to point to a different array.  C99 N1256 draftThere are two completely different uses of array literals:Initialize char[]:This is "more magic", and described at 6.7.8/14 "Initialization":An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.So this is just a shortcut for:Like any other regular array, c can be modified.Everywhere else: it generates an:So when you write:This is similar to:Note the implicit cast from char[] to char *, which is always legal.Then if you modify c[0], you also modify __unnamed, which is UB.This is documented at 6.4.5 "String literals":5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.6.7.8/32 "Initialization" gives a direct example:EXAMPLE 8: The declarationdefines "plain" char array objects s and t whose elements are initialized with character string literals.This declaration is identical toThe contents of the arrays are modifiable. On the other hand, the declarationdefines p with type "pointer to char" and initializes it to point to an object with type "array of char" with length 4 whose elements are initialized with a character string literal. If an attempt is made to use p to modify the contents of the array, the behavior is undefined.GCC 4.8 x86-64 ELF implementationProgram:Compile and decompile:Output contains:Conclusion: GCC stores char* it in .rodata section, not in .text.If we do the same for char[]:we obtain:so it gets stored in the stack (relative to %rbp).Note however that the default linker script puts .rodata and .text in the same segment, which has execute but no write permission. This can be observed with:which contains:declares s to be an array of char which is long enough to hold the initializer (5 + 1 chars) and initializes the array by copying the members of the given string literal into the array.declares s to be a pointer to one or more (in this case more) chars and points it directly at a fixed (read-only) location containing the literal "hello".As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with [] or *(<var> + <index>)\nformat:And:Obviously, if you attempt to doYou will probably get a Segmentation Fault, as you are trying to access read-only memory.Just to add: you also get different values for their sizes.As mentioned above, for an array \'\\0\' will be allocated as the final element.Here, s is an array of characters, which can be overwritten if we wish.A string literal is used to create these character blocks somewhere in the memory which this pointer s is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can\'t be changed.The above sets str to point to the literal value "Hello" which is hard-coded in the program\'s binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.will change the str to "Mello".For more details, please go through the similar question:Why do I get a segmentation fault when writing to a string initialized with "char *s" but not "char s[]"?In the case of:x is an lvalue -- it can be assigned to. But in the case of:x is not an lvalue, it is an rvalue -- you cannot assign to it.In the light of comments here it should be obvious that : char * s = "hello" ;\nIs a bad idea, and should be used in very narrow scope. This might be a good opportunity to point out that "const correctness" is a "good thing". Whenever and wherever You can, use the "const" keyword to protect your code, from "relaxed" callers or programmers, which are usually most "relaxed" when pointers come into play.Enough melodrama, here is what one can achieve when adorning pointers with "const".\n(Note: One has to read pointer declarations right-to-left.)\nHere are the 3 different ways to protect yourself when playing with pointers :\xe2\x80\x94 that is, the DBJ object can\'t be changed via p.\xe2\x80\x94 that is, you can change the DBJ object via p, but you can\'t change the pointer p itself.\xe2\x80\x94 that is, you can\'t change the pointer p itself, nor can you change the DBJ object via p.The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.(Assumption is you are using C++ compiler, of course ?)--DBJ