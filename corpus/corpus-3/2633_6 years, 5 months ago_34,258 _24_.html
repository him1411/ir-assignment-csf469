I just found a comment in this answer saying that using iostream::eof in a loop condition is "almost certainly wrong". I generally use something like while(cin>>n) - which I guess implicitly checks for EOF, why is checking for eof explicitly using iostream::eof wrong?  How is it different from using scanf("...",...)!=EOF in C (which I often use with no problems)?Because iostream::eof will only return true after reading the end of the stream. It does not indicate, that the next read will be the end of the stream.Consider this (and assume then next read will be at the end of the stream):Against this:And on your second question: Becauseis the same asand not the same asBottom-line top:  With proper handling of white-space, the following is how eof can be used (and even, be more reliable than fail() for error checking):(Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.)The main argument against using eof() seems to be missing an important subtlety about the role of white space. My proposition is that, checking eof() explicitly is not only not "always wrong" -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the always correct solution (although, not necessarily the tersest).To summarize what is being suggested as the "proper" termination and read order is the following:The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: while(in>>data) terminates with a set failbit for all three input. In the first and third, eofbit is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).Whereas, take the following: Here, in.fail() verifies that as long as there is something to read, it is the correct one. It\'s purpose is not a mere while-loop terminator. So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against eof() as terminator?We don\'t need to surrender our error handling; just eat up the white-space:std::ws skips any potential (zero or more) trailing space in the stream while setting the eofbit, and not the failbit.  So, in.fail() works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:Summary: A properly constructed while(!eof) is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, while(!fail) is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. Because if programmers don\'t write while(stream >> n), they possibly write this:Here the problem is, you cannot do some work on n without first checking if the stream read was successful, because if it was unsuccessful, your some work on n would produce undesired result.The whole point is that, eofbit, badbit, or failbit are set after an attempt is made to read from the stream. So if stream >> n fails, then eofbit, badbit, or failbit is set immediately, so its more idiomatic if you write while (stream >> n), because the returned object stream converts to false if there was some failure in reading from the stream and consequently the loop stops. And it converts to true if the read was successful and the loop continues.If you use line 2 in 3 and line 3 in 2 you will get ch printed twice.\nSo cout before read.