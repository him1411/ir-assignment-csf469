I am using the following code to check if the temporary table exists and drop the table if it exists before creating again. It works fine as long as I don\'t change the columns. If I add a column later, it will give an error saying "invalid column". Please let me know what I am doing wrong.I cannot reproduce the error.  Perhaps I\'m not understanding the problem.The following works fine for me in SQL Server 2005, with the extra "foo" column appearing in the second select result:The statement should be of the orderWithout \'GO\' in between, the whole thing will be considered as one single script and when the select statement looks for the column,it won\'t be found.With \'GO\' , it will consider the part of the script up to \'GO\' as one single batch and will execute before getting into the query after \'GO\'.This worked for me:\nsocial.msdn.microsoft.com/Forums/en/transactsql/thread/02c6da90-954d-487d-a823-e24b891ec1b0?prof=requiredInstead of dropping and re-creating the temp table you can truncate and reuse it If you are using Sql Server 2016 or Azure Sql Database then use the below syntax to drop the temp table and recreate it. More info here MSDNSyntaxDROP TABLE [ IF EXISTS ] [ database_name . [ schema_name ] . |\n  schema_name . ] table_name [ ,...n ]Query:Just a little comment from my side since the OBJECT_ID doesn\'t work for me. It always returns that `#tempTable doesn\'t exist..even though it does exist. I just found it\'s stored with different name (postfixed by _ underscores) like so :#tempTable________ This works well for me:pmac72 is using GO to break down the query into batches and using an ALTER.You appear to be running the same batch but running it twice after changing it:     DROP... CREATE... edit... DROP... CREATE..Perhaps post your exact code so we can see what is going on.I think the problem is you need to add GO statement in between to separate the execution into batches. As the second drop script i.e. IF OBJECT_ID(\'tempdb..#Results\') IS NOT NULL DROP TABLE #Results did not drop the temp table being part of single batch. Can you please try the below script.I usually hit this error when I have already created the temp table; the code that checks the SQL statement for errors sees the "old" temp table in place and returns a miscount on the number of columns in later statements, as if the temp table was never dropped.After changing the number of columns in a temp table after already creating a version with less columns, drop the table and THEN run your query.I recently saw a DBA do something similar to this:My code uses a Source table that changes, and a Destination table that must match those changes.