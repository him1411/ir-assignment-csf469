How do you get the logical xor of two variables in Python?For example, I have two variables that I expect to be strings. I want to test that only one of them contains a True value (is not None or the empty string):The ^ operator seems to be bitwise, and not defined on all objects:If you\'re already normalizing the inputs to booleans, then != is xor.You can always use the definition of xor to compute it from other logical operations:But this is a little too verbose for me, and isn\'t particularly clear at first glance. Another way to do it is:The xor operator on two booleans is logical xor (unlike on ints, where it\'s bitwise). Which makes sense, since bool is just a subclass of int, but is implemented to only have the values 0 and 1. And logical xor is equivalent to bitwise xor when the domain is restricted to 0 and 1.So the logical_xor function would be implemented like:Credit to Nick Coghlan on the Python-3000 mailing list.Exclusive-or is already built-in to Python, in the operator module:As Zach explained, you can use:Personally, I favor a slightly different dialect:This dialect is inspired from a logical diagramming language I learned in school where "OR" was denoted by a box containing \xe2\x89\xa51 (greater than or equal to 1) and "XOR" was denoted by a box containing =1.This has the advantage of correctly implementing exclusive or on multiple operands.To keep most of that way of thinking, my logical xor definintion would be:That way it can return a, b, or False:I\'ve tested several approaches and not a != (not b) appeared to be the fastest.Here are some testsExclusive Or is defined as followsAs I don\'t see the simple variant of xor using variable arguments and only operation on Truth values True or False, I\'ll just throw it here for anyone to use.\nIt\'s as noted by others, pretty (not to say very) straightforward.And usage is straightforward as well:As this is the generalized n-ary logical XOR, it\'s truth value will be True whenever the number of True operands is odd (and not only when exactly one is True, this is just one case in which n-ary XOR is True).Thus if you are in search of a n-ary predicate that is only True when exactly one of it\'s operands is, you might want to use:How about this?will give a if b is false\nwill give b if a is false\nwill give False otherwiseOr with the Python 2.5+ ternary expression:Some of the implementations suggested here will cause repeated evaluation of the operands  in some cases, which may lead to unintended side effects and therefore must be avoided.That said, a xor implementation that returns either True or False is fairly simple; one that returns one of the operands, if possible, is much trickier, because no consensus exists as to which operand should be the chosen one, especially when there are more than two operands. For instance, should xor(None, -1, [], True) return None, [] or False? I bet each answer appears to some people as the most intuitive one.For either the True- or the False-result, there are as many as five possible choices: return first operand (if it matches end result in value, else boolean), return first match (if at least one exists, else boolean), return last operand (if ... else ...), return last match (if ... else ...), or always return boolean. Altogether, that\'s 5 ** 2 = 25 flavors of xor.It\'s easy when you know what XOR does:XOR is implemented in operator.xor.Rewarding thread:Anoder idea... Just you try the (may be) pythonic expression \xc2\xabis not\xc2\xbb in order to get behavior of logical \xc2\xabxor\xc2\xbbThe truth table would be:And for your example string:However; as they indicated above, it depends of the actual behavior you want to pull out about any couple strings, because strings aren\'t boleans... and even more: if you \xc2\xabDive Into Python\xc2\xbb you will find \xc2\xabThe Peculiar Nature of "and" and "or"\xc2\xbb\nhttp://www.diveintopython.net/power_of_introspection/and_or.htmlSorry my writed English, it\'s not my born language.Regards.I know this is late, but I had a thought and it might be worth, just for documentation. Perhaps this would work:np.abs(x-y) The idea is that Sometimes I find myself working with 1 and 0 instead of boolean True and False values.  In this case xor can be defined as which has the following truth table:This gets the logical exclusive XOR for two (or more) variablesThe first problem with this setup is that it most likely traverses the whole list twice and, at a minimum, will check at least one of the elements twice.  So it may increase code comprehension, but it doesn\'t lend to speed (which may differ negligibly depending on your use case).   The second problem with this setup is that it checks for exclusivity regardless of the number of variables.  This is may at first be regarded as a feature, but the first problem becomes a lot more significant as the number of variables increases (if they ever do).Simple, easy to understand:If an exclusive choice is what you\'re after, it can be expanded to multiple arguments: