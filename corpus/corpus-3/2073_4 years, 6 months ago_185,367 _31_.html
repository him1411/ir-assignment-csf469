When you create a directive, you can put code into the compiler, the link function or the controller. In the docs, they explain that:However, for me it is not clear, which kind of code should go where.E.g.: Can I create functions in compile and have them attached to the scope in link or only attach functions to the scope in the controller?How are controllers shared between directives, if each directive can have its own controller? Are the controllers really shared or is it just the scope properties?Compile : This is the phase where Angular actually compiles your directive. This compile function is called just once for each references to the given directive. For example, say you are using the ng-repeat directive. ng-repeat will have to look up the element it is attached to, extract the html fragment that it is attached to and create a template function. If you have used HandleBars, underscore templates or equivalent, its like compiling their templates to extract out a template function. To this template function you pass data and the return value of that function is the html with the data in the right places. The compilation phase is that step in Angular which returns the template function. This template function in angular is called the linking function. Linking phase : The linking phase is where you attach the data ( $scope ) to the linking function and it should return you the linked html. Since the directive also specifies where this html goes or what it changes, it is already good to go. This is the function where you want to make changes to the linked html, i.e the html that already has the data attached to it. In angular if you write code in the linking function its generally the post-link function (by default). It is kind of a callback that gets called after the linking function has linked the data with the template.  Controller :The controller is a place where you put in some directive specific logic. This logic can go into the linking function as well, but then you would have to put that logic on the scope to make it "shareable". The problem with that is that you would then be corrupting the scope with your directives stuff which is not really something that is expected.\nSo what is the alternative if two Directives want to talk to each other / co-operate with each other? Ofcourse you could put all that logic into a service and then make both these directives depend on that service but that just brings in one more dependency. The alternative is to provide a Controller for this scope ( usually isolate scope ? ) and then this controller is injected into another directive when that directive "requires" the other one. See tabs and panes on the first page of angularjs.org for an example. I wanted to add also what the O\'Reily AngularJS book by the Google Team has to say:Controller - Create a controller which publishes an API for communicating across directives. A good example is Directive to Directive CommunicationLink - Programmatically modify resulting DOM element instances, add event listeners, and set up data binding.Compile - Programmatically modify the DOM template for features across copies of a directive, as when used in ng-repeat. Your compile function can also return link functions to modify the resulting element instances.A directive allows you to extend the HTML vocabulary in a declarative fashion for building web components. The ng-app attribute is a directive, so is ng-controller and all of the ng- prefixed attributes. Directives can be attributes, tags or even class names, comments.How directives are born (compilation and instantiation)Compile: We\xe2\x80\x99ll use the compile function to both manipulate the DOM before it\xe2\x80\x99s rendered and return a link function (that will handle the linking for us). This also is the place to put any methods that need to be shared around with all of the instances of this directive.link: We\xe2\x80\x99ll use the link function to register all listeners on a specific DOM element (that\xe2\x80\x99s cloned from the template) and set up our bindings to the page.If set in the compile() function they would only have been set once (which is often what you want). If set in the link() function they would be set every time the HTML element is bound to data in the \n object.Compile function returns the pre and post link function. In the pre link function we have the instance template and also the scope from the controller, but yet the template is not bound to scope and still don\'t have transcluded content. Post link function is where post link is the last function to execute. Now the transclusion is complete, the template is linked to a scope, and the view will update with data bound values after the next digest cycle. The link option is just a shortcut to setting up a post-link function.controller: The directive controller can be passed to another directive linking/compiling phase. It can be injected into other directices as a mean to use in inter-directive communication. You have to specify the name of the directive to be required \xe2\x80\x93 It should be bound to same element or its parent. The name can be prefixed with:Use square bracket [\xe2\x80\x98directive1\xe2\x80\xb2, \xe2\x80\x98directive2\xe2\x80\xb2, \xe2\x80\x98directive3\xe2\x80\xb2] to require multiple directives controller. this is a good sample for understand directive phases\nhttp://codepen.io/anon/pen/oXMdBQ?editors=101htmlAlso, a good reason to use a controller vs. link function (since they both have access to the scope, element, and attrs) is because you can pass in any available service or dependency into a controller (and in any order), whereas you cannot do that with the link function. Notice the different signatures:vs.