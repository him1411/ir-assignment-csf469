What\'s the correct way to communicate between controllers?I\'m currently using a horrible fudge involving window:Edit: The issue addressed in this answer have been resolved in angular.js version 1.2.7. $broadcast now avoids bubbling over unregistered scopes and runs just as fast as $emit.\nSo, now you can:Original Answer BelowI highly advise not to use $rootScope.$broadcast + $scope.$on but rather $rootScope.$emit+ $rootScope.$on. The former can cause serious performance problems as raised by @numan. That is because the event will bubble down through all scopes. However, the latter (using $rootScope.$emit + $rootScope.$on) does not suffer from this and can therefore be used as a fast communication channel!From the angular documentation of $emit:Dispatches an event name upwards through the scope hierarchy notifying the registeredSince there is no scope above $rootScope, there is no bubbling happening. It is totally safe to use $rootScope.$emit()/ $rootScope.$on() as an EventBus.However, there is one gotcha when using it from within Controllers. If you directly bind to $rootScope.$on() from within a controller, you\'ll have to clean up the binding yourself when  your local $scope gets destroyed. This is because controllers (in contrast to services) can get instantiated multiple times over the lifetime of an application which would result into bindings summing up eventually creating memory leaks all over the place :)To unregister, just listen on your $scope\'s $destroy event and then call the function that was returned by $rootScope.$on.I would say, that\'s not really an angular specific thing as it applies to other EventBus implementations as well, that you have to clean up resources.However, you can make your life easier for those cases. For instance, you could monkey patch $rootScope and give it a $onRootScope that subscribes to events emitted on the $rootScope but also directly cleans up the handler when the local $scope gets destroyed.The cleanest way to monkey patch the $rootScope to provide such $onRootScope method would be through a decorator (a run block will probably do it just fine as well but pssst, don\'t tell anybody)To make sure the $onRootScope property doesn\'t show up unexpected when enumerating over $scope we use Object.defineProperty() and set enumerable to false. Keep in mind that you might need an ES5 shim.With this method in place the controller code from above can be simplified to:So as a final outcome of all this I highly advise you to use $rootScope.$emit + $scope.$onRootScope.Btw, I\'m trying to convince the angular team to address the problem within angular core. There\'s a discussion going on here: https://github.com/angular/angular.js/issues/4574Here is a jsperf that shows how much of a perf impact $broadcastbrings to the table in a decent scenario with just 100 $scope\'s.http://jsperf.com/rootscope-emit-vs-rootscope-broadcastThe top answer here was a work around from an Angular problem which no longer exists (at least in versions >1.2.16 and "probably earlier") as @zumalifeguard has mentioned. But I\'m left reading all these answers without an actual solution. It seems to me that the answer now should be So to publishAnd subscribePlunkersIf you register the listener on the local $scope, it will be destroyed automatically by $destroy itself when the associated controller is removed. Using $rootScope.$broadcast and $scope.$on for a PubSub communication.Also, see this post: AngularJS \xe2\x80\x93 Communicating Between ControllersSince defineProperty has browser compatibility issue, I think we can think about using a service.and use it in controller like this:controller 1  controller 2  GridLinked posted a PubSub solution which seems to be designed pretty well. The service can be found, here.Also a diagram of their service:Actually using emit and broadcast is inefficient because the event bubbles up and down the scope hierarchy which can easily degrade into performance bottlement for a complex application.I would suggest to use a service. Here is how I recently implemented it in one of my projects - https://gist.github.com/3384419. Basic idea - register a pubsub/event bus as a service. Then inject that eventbus where ever you need to subscribe or publish events/topics.Using get and set methods within a service you can passing messages between controllers very easily.in HTML HTML you can check like thisRegarding the original code - it appears you want to share data between scopes.  To share either Data or State between $scope the docs suggest using a service:Ref: Angular Docs link hereI\'ve actually started using Postal.js as a message bus between controllers.There are lots of benefits to it as a message bus such as AMQP style bindings, the way postal can integrate w/ iFrames and web sockets, and many more things.I used a decorator to get Postal set up on $scope.$bus...Here\'s a link to a blog post on the topic...\nhttp://jonathancreamer.com/an-angular-event-bus-with-postal-js/This is how I do it with Factory / Services and simple dependency injection (DI).I liked the way how $rootscope.emit was used to achieve intercommunication. I suggest the clean and performance effective solution without polluting global space.Here\'s the quick and dirty way.Here is an example function to add within any of the sibling controllers:and of course here\'s your HTML:You can access this hello function anywhere in the module Controller onesecond controllerMore info hereI will create a service and use notification.As at any point Notification Service is singleton it should be able to provide persisted data across.Hope this helpsYou can use AngularJS build-in service $rootScope and inject this service in both of your controllers.\nYou can then listen for events that are fired on $rootScope object. $rootScope provides two event dispatcher called $emit and $broadcast which are responsible for dispatching events(may be custom events) and use $rootScope.$on function to add event listener.You should use the Service , because $rootscope is access from whole Application , and it increases the load, or youc use the rootparams if your data is not more.You can do it by using angular events that is $emit and $broadcast. As per our knowledge this is the best, efficient and effective way.First we call a function from one controller.You can also use $rootScope in place of $scope. Use your controller accordingly.Starting angular 1.5 and it\'s component based development focus. The recommended way for components to interact is through the use of the \'require\' property and through property bindings (input/output).A component would require another component (for instance the root component) and get a reference to it\'s controller:You can then use the methods of the root component in your child component:This is the root component controller function:Here is a complete architectual overview: Component Communications