I can use set_error_handler() to catch most PHP errors, but it doesn\'t work for fatal (E_ERROR) errors, such as calling a function that doesn\'t exist. Is there another way to catch these errors?I am trying to call mail() for all errors and am running PHP 5.2.3.Log fatal errors using register_shutdown_function, which requires PHP 5.2+:You will have to define the error_mail and format_error functions. For example:Use Swift Mailer to write the error_mail function.See also:Just came up with this solution (PHP 5.2.0+):Different error types defined at http://www.php.net/manual/en/errorfunc.constants.phpPHP doesn\'t provide conventional means for catching and recovering from fatal errors. This is because processing should not typically be recovered after a fatal error. String matching an output buffer (as suggested by the original post the technique described on PHP.net) is definitely ill-advised. It\'s simply unreliable.Calling the mail() function from within an error handler method prove to be problematic, too. If you had a lot of errors, your mail server would be loaded with work, and you could find yourself with a gnarly inbox. To avoid this, you might consider running a cron to scan error logs periodically and send notifications accordingly. You might also like to look into system monitoring software, such as Nagios.To speak to the bit about registering a shutdown function:It\'s true that you can register a shutdown function, and that\'s a good answer.The point here is that we typically shouldn\'t try to recover from fatal errors, especially not by using a regular expression against your output buffer. I was responding to the accepted answer, which linked to a suggestion on php.net which has since been changed or removed.That suggestion was to use a regex against the output buffer during exception handling, and in the case of a fatal error (detected by the matching against whatever configured error text you might be expecting), try to do some sort of recovery or continued processing. That would not be a recommended practice (I believe that\'s why I can\'t find the original suggestion, too. I\'m either overlooking it, or the php community shot it down).It might be worth noting that the more recent versions of PHP (around 5.1) seem to call the shutdown function earlier, before the output buffering callback is envoked.  In version 5 and earlier, that order was the reverse (the output buffering callback was followed by the shutdown function). Also, since about 5.0.5 (which is much earlier than the questioner\'s version 5.2.3), objects are unloaded well before a registered shutdown function is called, so you won\'t be able to rely on your in-memory objects to do much of anything.So registering a shutdown function is fine, but the sort of tasks that ought to be performed by a shutdown function are probably limited to a handful of gentle shutdown procedures.The key take-away here is just some words of wisdom for anyone who stumbles upon this question and sees the advice in the originally accepted answer. Don\'t regex your output buffer.Well it seems possible to catch Fatal Errors some other way :)I developed a way to catch all error types in PHP (almost all)! I have no sure about E_CORE_ERROR ( I think will not works only for that error)! But, for other fatal errors (E_ERROR, E_PARSE, E_COMPILE...) works fine using only one error handler function! There goes my solution:Put this following code on your main file (index.php):I hope this helps many people! I was searching for this solution too long time and didn\'t find! Then I developed one!You cannot throw exception inside registered shutdown function like that:But you can capture and redirect request to another page.You can\'t catch/handle fatal errors, but you can log/report them.\nFor quick debugging I modified one answer to this simple codeIf you are using php >= 5.1.0\nJust do something like this with the ErrorException class:This class allows you to start the specific ErrorHandler sometimes if you need it. And then you can also stop the Handler.Use this class e.g. like this:Link to the full class code: https://github.com/zendframework/zf2/blob/master/library/Zend/Stdlib/ErrorHandler.phpIt can also handle FATAL_ERRORS using the register_shutdown_function function. According to this class a FATAL_ERROR is one of the following array(E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR, E_USER_ERROR).I need to handle fatal errors for a production to instead show a static styled 503 Service Unavailable HTML output. This is surely a reasonable approach to "catching fatal errors". This is what I\'ve done:I have a custom error handling function "error_handler" which will display my "503 service unavailable" HTML page on any E_ERROR, E_USER_ERROR etc. This will now be called on the shutdown function catching my fatal error.in my custom error_handler function, if the error is E_ERROR or E_USER_ERROR etc. I also call @ob_end_clean(); to empty the buffer, thus removing PHP\'s "fatal error" message.Take important note of the strict isset() checking and @ silencing functions since we dont want our error_handler scripts to generate any errors.In still agreeing with keparo, catching fatal errors does defeat the purpose of "FATAL error" so its not really intended for you to do further processing. Do not run any mail() functions in this shutdown process as you will certainly back up the mail server or your inbox. Rather log these occurrences to file and schedule a cron to find these error.log files and mail them to administrators.PHP has catchable fatal errors. They are defined as E_RECOVERABLE_ERROR. The PHP manual describes an E_RECOVERABLE_ERROR as:Catchable fatal error. It indicates that a probably dangerous error occured, but did not leave the Engine in an unstable state. If the error is not caught by a user defined handle (see also set_error_handler()), the application aborts as it was an E_ERROR.You can "catch" these "fatal" errors by using set_error_handler() and checking for E_RECOVERABLE_ERROR. I find it useful to throw an Exception when this error is caught, then you can use try/catch.This question and answer provides a useful example: How can I catch a "catchable fatal error" on PHP type hinting?E_ERROR errors, however, can be handled, but not recovered from as the engine is in an unstable state.Just a nice trick to get the current error_handler method =)Also i wan\'t to note that if you call Php stops displaying the error, otherwise the error text will be send to the client prior to your error handlerSince most answers here are unnecesarily verbose, here\'s my non-ugly version of the top voted answer:Not really. Fatal errors are called that, because they are fatal. You can\'t recover from them.I developed this function to make it possible to "sandbox" code that could cause a fatal error. Since exceptions thrown from the closure register_shutdown_function don\'t get emitted from the pre-fatal error call stack, I\'m forced to exit after this function to provide a uniform way of using it.There are certain circumstances that even fatal errors should be caught (you might need to do some clean up before exiting gracefully and dont just die..).\nI have implemented a pre_system hook on my codeigniter applications so that I can get my fatal errors through emails, and this helped me finding bugs that were not reported (or were reported after they were fixed, as I already knew about them :)).\nSendemail check if the error has already been reported so that it does not spam you with known errors multiple times.I wrote up a Wiki-style Q&A with a Complete solution for catching All errors in PHP; which can be viewed/gleaned/stolen/critiqued here.The solution includes 5 methods that wrap all errors PHP can generate, that will eventually pass said errors up to an \'ErrorHandler\' typed object. Hope some folks get some use out of it. Even if you don\'t steal it outright, I\'m sure that the solution is at least a good example of how to handle errors in PHP - in every respect.@Lucas Batistussi got points for creativity - I figure I could share my solution as well and shoot for some similar points...