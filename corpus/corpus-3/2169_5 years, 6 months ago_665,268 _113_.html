I have installed an application, when I try to run it (it\'s an executable jar) nothing happens. When I run it from the commandline with: java -jar "app.jar"I get the following message:no main manifest attribute, in "app.jar"Normally, if I had created the program myself, I would have added a main class attribute to the manifest file. But in this case, since the file is from an application, i cannot do that. I also tried extracting the jar to see if I could find the main class, but there are to many classes and none of them has the word "main" in it\'s name. There must be a way to fix this because the program runs fine on other systems.First, it\'s kind of weird, to see you run java -jar "app" and not java -jar app.jarSecond, to make a jar executable... you need to jar a file called META-INF/MANIFEST.MFthe file itself should have (at least) this one liner:Where com.mypackage.MyClass is the class holding the public static void main(String[] args) entry point.Note that there are several ways to get this done either with the CLI, Maven or Ant:For CLI, the following command will do: (tks @dvvrt)\n\njar cmvf META-INF/MANIFEST.MF <new-jar-filename>.jar  <files to include>\nFor Maven, something like the following snippet should do the trick. Note that this is only the plugin definition, not the full pom.xml:(Pick a <version> appropriate to your project.)For Ant, the snippet below should help:Credits Michael Niemand -That should have been java -jar app.jar instead of java -jar "app".The -jar option only works if the JAR file is an executable JAR file, which means it must have a manifest file with a Main-Class attribute in it. See Packaging Programs in JAR Files to learn how to create an executable JAR.If it\'s not an executable JAR, then you\'ll need to run the program with something like:where com.somepackage.SomeClass is the class that contains the main method to run the program. (What that class is depends on the program, it\'s impossible to tell from the information you\'ve supplied).Alternatively, you can use maven-assembly-plugin, as shown in the below example:In this example all the dependency jars as specified in  section will be automatically included in your single jar. Note that jar-with-dependencies should be literally put as, not to be replaced with the jar file names you want to include.That is because Java cannot find the Main attribute in the MANIFEST.MF file.\nThe Main attribute is necessary to tell java which class it should use as the application\'s entry point. Inside the jar file, the MANIFEST.MF file is located in META-INF folder. Wondering how you could look at what\'s inside a jar file? Open the jar file with WinRAR.The main attribute inside the MANIFEST.MF looks like this:You get this "no main manifest attribute" error when this line is missing from the MANIFEST.MF file. It\'s really a huge mess to specify this attribute inside the MANIFEST.MF file.Update: I just found a really neat way to specify the Application\'s entry point in eclipse.\nWhen you say Export, For maven, this is what solved it (for me, for a Veetle codebase on GitHub):Cheers...The Gradle answer is to add a jar/manifest/attributes setting like this:Try this command to include the jar: For me, none of the answers really helped - I had the manifest file in correct place, containing the Main-Class and everything. What tripped me over was this:Warning: The text file from which you are creating the manifest must\n  end with a new line or carriage return. The last line will not be\n  parsed properly if it does not end with a new line or carriage return.(source). Adding a newline at the end of the manifest fixed it.I had this issue when creating a jar using IntelliJ IDEA. See this discussion.What solved it for me was to re-create the jar artifact, choosing JAR > From modules with dependencies, but not accepting the default Directory for META-INF/MANIFEST.MF. Change it from -/src/main/java to -/src/main/resources.Otherwise it was including a manifest file in the jar, but not the one in -/src/main/java that it should have.If the jar isn\'t following the rules, it\'s not an executable jar.If using Maven, include following in the pomAny executable jar file Should run either by clicking or running using command prompt like java -jar app.jar (use "if path of jar contains space" - i.e. java -jar "C:\\folder name\\app.jar"). If your executable jar is not running, which means it is not created properly.For better understanding, extract the jar file (or view using any tool, for windows 7-Zip is nice one) and check the file under /META-INF/MANIFEST.MF. If you find any entry likeMain-Class: your.package.name.ClaaswithMain - then it\'s fine, otherwise you have to provide it.Be aware of appending Main-Class entry on MANIFEST.MF file, check where you are saving it! You might not have created the jar file properly:ex: missing option m in jar creationThe following works:For me this error occurred simply because I forgot tell Eclipse that I wanted a runnable jar file and not a simple library jar file.  So when you create the jar file in Eclipse make sure that you click the right radio buttonI faced the same issue and it\'s fixed now:)\nJust follow the below steps and the error could be for anything, but the below steps makes the process smoother. I spend lot of time to find the fix.1.Try restart the Eclipse (if you are using Eclipse to built JAR file)\n--> Actually this helped my issue in exporting the JAR file properly.2.After eclipse restart, try to see if your eclipse is able to recognize the main class/method by your Java project --> right click --> Run as --> Run configurations --> Main --> click Search button to see if your eclipse is able to lookup for your main class in the JAR file.\n--> This is for the validation that JAR file will have the entry point to the main class.After this, export your Java Dynamic project as "Runnable JAR" file and not JAR file.In Java launch configuration, choose your main class.Once export the jar file, use the below command to execute.\njava -cp [Your JAR].jar [complete package].MainClass\neg: java -cp AppleTCRuleAudit.jar com.apple.tcruleaudit.classes.TCRuleAuditYou might face the unsupported java version error. the fix is to change the java_home in your shell bash profile to match the java version used to compile the project in eclipse.Hope this helps! Kindly let me know if you still have any issues.You Can Simply follow this step \n Create a jar file usingWhile running the jar file simple run like thisThe above answers were only partly helpful for me. java -cp was part of the answer, but I needed more specific info on how to identify the class to run. Here is what worked for me:Step 1: find the class I need to runThe top lines of the result were:App.class contained the main class to run. I\'m not 100% sure if you can always assume the class you need is the first one, but it was for me. If it isn\'t, I\'d imagine it isn\'t too hard to use grep to exclude library-related results to pare the class list down to a manageable size.From there it was easy: I just use that path (minus the ".class" suffix):I had the same problem. A lot of the solutions mentioned here didn\'t give me the whole picture, so I\'ll try to give you a summary of how to pack jar files from the command line.If you want to have your .class files in packages, add the package in the beginning of the .java.Test.javaTo compile your code with your .class files ending up with the structure given by the package name use:The -d . makes the compiler create the directory structure you want.When packaging the .jar file, you need to instruct the jar routine on how to pack it. Here we use the option set cvfeP. This is to keep the package structure (option P), specify the entry point so that the manifest file contains meaningful information (option e). Option f lets you specify the file name, option c creates an archive and option v sets the output to verbose. The important things to note here are P and e.Then comes the name of the jar we want test.jar.Then comes the entry point .And then comes -C . <packagename>/ to get the class files from that folder, preserving the folder structure.Check your .jar file in a zip program. It should have the following structuretest.jarThe MANIFEST.MF should contain the followingIf you edit your manifest by hand be sure to keep the newline at the end otherwise java doesn\'t recognize it.Execute your .jar file withSince you\'ve add MANIFEST.MF, I think you should consider the order of Field in this file. My env is  java version "1.8.0_91"and my MANIFEST.MF as hereHowever, this as below run throughI had the same issue today. My problem was solved my moving META-INF to the resources folder. (first post - so it may not be clean)This is my fix for OS X 11.6, Maven-based Netbeans 8.2 program. Up to now my app is 100% Netbeans - no tweaking (just a few shell escapes for the impossible!).Having tried most all of the answers here and elsewhere to no avail, I returned to the art of "use what works". The top answer here (olivier-refalo thanx) looked like the right place to start but didn\'t help. Looking at other projects which did work, I noticed some minor differences in the manifest lines: Not sure why (I am only 3 months into java) or how, but can only say this worked. Here is just the modified manifest block used:You might have the same problem as I do. After creating your .jar file, write jar xf app.jar META-INF/MANIFEST.MF. This will create a copy of the file to your current directory so you can read it. If it only says something like:Manifest-Version: 1.0Created-By: 1.8.0_51 (Oracle Corporation)and does not contain the "Main-Class" declaration, then I think you found your problem.I do not know how to solve it, though. I checked other people with same/similar problems on StackOverflow and couldn\'t find an answer. However with this information you can perhaps get some better help (given the fact that you have the same problem as I).Edit: I had tried with a manifest-file but didn\'t get it to work, but my mistake was to only name one of the classes when creating the jar-file. I wrote *.class instead and it works now.Although I don\'t know why there is a need to create a manifest-file. But I guess it\'s fine as long as it works.Check your local .m2 direcory for a sub directory of this artifact.\nIf exixts - delete it, and perform Maven update againIf you are using the command line to assemble .jar it is possible to point to the main without adding Manifest file. Example:(param "e" does that: TheNameOfClassWithMainMethod is a name of the class with the method main()  and app.jar - name of executable .jar and *.class - just all classes files to assemble)check your jar file inside MANIFEST.MF Main-Class is available or notfirst.javaBefore:After: I had a similar issue as you, \nin below a syntax to create successfully .war File:-jar {cvf} [jar-file] [manifest-file]manifest\n  When creating (c) or updating (u) a JAR file, the manifest operand defines the preexisting manifest files with names and values of attributes to be included in MANIFEST.MF in the JAR file. The manifest operand must be specified if the f option is present \'[1]\'.In order to create manifest file you need to defined a value for some attributes, you could put asterisk after the (.WAR) file name to avoid creating manifest file:-jar -cvf foo.war *To be honest with you I don\'t know if that is a best practice but it do the work for me :).I got same error just now.\nIf u\'re using gradle, just add next one in ur gradle.build:Where com.company.project.MainClass path to ur class with public static void main(String[] args) method.I had this problem and i solved it recently by doing this in Netbeans 8 (Refer to the image below):Just to make one point clear about If you don\'t have package you have to ignore that part, like this: