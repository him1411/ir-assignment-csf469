This question already has an answer here:I want a true deep copy. In Java, this was easy, but how do you do it in C#?I\'ve seen a few different approaches to this, but I use a generic utility method as such:    Notes:Your source file must include the following code:I wrote a deep object copy extension method, based on recursive "MemberwiseClone". It is fast (three times faster than BinaryFormatter), and it works with any object. You don\'t need a default constructor or serializable attributes.Building on Kilhoffer\'s solution...With C# 3.0 you can create an extension method as follows:which extends any class that\'s been marked as [Serializable] with a DeepClone methodYou can use Nested MemberwiseClone to do a deep copy. Its almost the same speed as copying a value struct, and its an order of magnitude faster than (a) reflection or (b) serialization (as described in other answers on this page).Note that if you use Nested MemberwiseClone for a deep copy, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code below.Here is the output of the code showing the relative performance difference (4.77 seconds for deep nested MemberwiseCopy vs. 39.93 seconds for Serialization). Using nested MemberwiseCopy is almost as fast as copying a struct, and copying a struct is pretty darn close to the theoretical maximum speed .NET is capable of.To understand how to do a deep copy using MemberwiseCopy, here is the demo project:Then, call the demo from main:Again, note that if you use Nested MemberwiseClone for a deep copy, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code above.Note that when it comes to cloning an object, there is is a big difference between a "struct" and a "class":UpdateIt\'s probably possible to use reflection to recursively walk through the object graph to do a deep copy. WCF uses this technique to serialize an object, including all of its children. The trick is to annotate all of the child objects with an attribute that makes it discoverable. You might lose some performance benefits, however.UpdateQuote on independent speed test (see comments below):I\'ve run my own speed test using Neil\'s serialize/deserialize\n  extension method, Contango\'s Nested MemberwiseClone, Alex Burtsev\'s\n  reflection-based extension method and AutoMapper, 1 million times\n  each. Serialize-deserialize was slowest, taking 15.7 seconds. Then\n  came AutoMapper, taking 10.1 seconds. Much faster was the\n  reflection-based method which took 2.4 seconds. By far the fastest was\n  Nested MemberwiseClone, taking 0.1 seconds. Comes down to performance\n  versus hassle of adding code to each class to clone it. If performance\n  isn\'t an issue go with Alex Burtsev\'s method. \n  \xe2\x80\x93 Simon TewsiI believe that the BinaryFormatter approach is relatively slow (which came as a surprise to me!). You might be able to use ProtoBuf .NET for some objects if they meet the requirements of ProtoBuf. From the ProtoBuf Getting Started page (http://code.google.com/p/protobuf-net/wiki/GettingStarted):Notes on types supported:Custom classes that:The code assumes that types will be mutable around the elected members. Accordingly, custom structs are not supported, since they should be immutable.If your class meets these requirements you could try:Which is VERY fast indeed...Maybe you only need a shallow copy, in that case use Object.MemberWiseClone().There are good recommendations in the documentation for MemberWiseClone() for strategies to deep copy: -http://msdn.microsoft.com/en-us/library/system.object.memberwiseclone.aspxYou can try thisThanks to DetoX83 article on code project.The best way is:This way is a few times faster than BinarySerialization AND this does not require the [Serializable] attribute.The MSDN documentation seems to hint that Clone should perform a deep copy, but it is never explicitly stated:The ICloneable interface contains one member, Clone, which is intended to support cloning beyond that supplied by MemberWiseClone\xe2\x80\xa6 The MemberwiseClone method creates a shallow copy\xe2\x80\xa6You can find my post helpful. http://pragmaticcoding.com/index.php/cloning-objects-in-c/I have a simpler idea. Use LINQ with a new selection.