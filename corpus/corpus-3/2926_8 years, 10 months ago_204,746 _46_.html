What is the idiomatic Python equivalent of this C/C++ code?specifically, how does one implement the static member at the function level, as opposed to the class level? And does placing the function into a class change anything?A bit reversed, but this should work:If you want the counter initialization code at the top instead of the bottom, you can create a decorator:Then use the code like this:It\'ll still require you to use the foo. prefix, unfortunately.EDIT (thanks to ony): This looks even nicer:You can add attributes to a function, and use it as a static variable.Alternatively, if you don\'t want to setup the variable outside the function, you can use hasattr() to avoid an AttributeError exception:Anyway static variables are rather rare, and you should find a better place for this variable, most likely inside a class.One could also consider:Reasoning:Other answers have demonstrated the way you should do this. Here\'s a way you shouldn\'t:Default values are initialized only when the function is first evaluated, not each time it is executed, so you can use a list or any other mutable object to store static values.Many people have already suggested testing \'hasattr\', but there\'s a simpler answer:No try/except, no testing hasattr, just getattr with a default.Here is a fully encapsulated version that doesn\'t require an external initialization call:In Python, functions are objects and we can simply add member variables to them via the special attribute __dict__. The built-in vars() returns the special attribute __dict__.   EDIT: Note, unlike the alternative try:except AttributeError answer, with this approach the variable will always be ready for the code logic following initialization. I think the try:except AttributeError alternative to the following will be less DRY and/or have awkward flow:   Python doesn\'t have static variables but you can fake it by defining a callable class object and then using it as a function. Also see this answer.Note that __call__ makes an instance of a class (object) callable by its own name. That\'s why calling foo() above calls the class\' __call__ method. From the documentation:Instances of arbitrary classes can be made callable by defining a __call__() method in their class.Use a generator function to generate an iterator.Then use it likeIf you want an upper limit:If the iterator terminates (like the example above), you can also loop over it directly, likeOf course, in these simple cases it\'s better to use xrange :)Here is the documentation on the yield statement.Python customarily uses underscores to indicate private variables. The only reason in C to declare the static variable inside the function is to hide it outside the function, which is not really idiomatic Python.Much like vicent\'s code above, this would be used as a function decorator and static variables must be accessed with the function name as a prefix. The advantage of this code (although admittedly anyone might be smart enough to figure it out) is that you can have multiple static variables and initialize them in a more conventional manner.Using an attribute of a function as static variable has some potential drawbacks:Idiomatic python for the second issue would probably be naming the variable with a leading underscore to signal that it is not meant to be accessed, while keeping it accessible after the fact. An alternative would be a pattern using lexical closures, which are supported with the nonlocal keyword in python 3.Sadly I know no way to encapsulate this solution into a decorator.Prompted by this question, may I present another alternative which might be a bit nicer to use and will look the same for both methods and functions:If you like the usage, here\'s the implementation:A little bit more readable, but more verbose:The idiomatic way is to use a class, which can have attributes.  If you need instances to not be separate, use a singleton.There are a number of ways you could fake or munge "static" variables into Python (one not mentioned so far is to have a mutable default argument), but this is not the Pythonic, idiomatic way to do it.  Just use a class.Or possibly a generator, if your usage pattern fits.I personally prefer the following to decorators. To each their own.A static variable inside a Python methodAnother (not recommended!) twist on the callable object like https://stackoverflow.com/a/279598/916373, if you don\'t mind using a funky call signature, would be to doSure this is an old question but I think I might provide some update.It seems that the performance argument is obsolete. \nThe same test suite appears to give similar results for siInt_try and isInt_re2.\nOf course results vary, but this is one session on my computer with python 3.4.4 on kernel 4.3.01 with Xeon W3550.\nI have run it several times and the results seem to be similar.\nI moved the global regex into function static, but the performance difference is negligible. With performance issue out of the way, it seems that try/catch would produce the most future- and cornercase- proof code so maybe just wrap it in function