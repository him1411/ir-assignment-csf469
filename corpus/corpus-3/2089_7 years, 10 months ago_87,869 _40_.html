The ExpandoObject class being added to .NET 4 allows you to arbitrarily set properties onto an object at runtime.Are there any advantages to this over using a Dictionary<string,object>, or really even a Hashtable?  As far as I can tell, this is nothing but a hash table that you can access with slightly more succinct syntax.For example, why is this:Really better, or substantially different, than:What real advantages are gained by using ExpandoObject instead of just using an arbitrary dictionary type, other than not being obvious that you\'re using a type that\'s going to be determined at runtime.Since I wrote the MSDN article you are referring to, I guess I have to answer this one.First, I anticipated this question and that\'s why I wrote a blog post that shows a more or less real use case for ExpandoObject: Dynamic in C# 4.0: Introducing the ExpandoObject. Shortly, ExpandoObject can help you create complex hierarchical objects. For example, imagine that you have a dictionary within a dictionary:The deeper is the hierarchy, the uglier is the code. With ExpandoObject it stays elegant and readable.Second, as it was already pointed out, ExpandoObject implements INotifyPropertyChanged interface which gives you more control over properties than a dictionary.Finally, you can add events to ExpandoObject like here:One advantage is for binding scenarios.  Data grids and property grids will pick up the dynamic properties via the TypeDescriptor system.  In addition, WPF data binding will understand dynamic properties, so WPF controls can bind to an ExpandoObject more readily than a dictionary.Interoperability with dynamic languages, which will be expecting DLR properties rather than dictionary entries, may also be a consideration in some scenarios.The real benefit for me is the totally effortless data binding from XAML:......Interop with other languages founded on the DLR is #1 reason I can think of. You can\'t pass them a Dictionary<string, object> as it\'s not an IDynamicMetaObjectProvider. Another added benefit is that it implements INotifyPropertyChanged which means in the databinding world of WPF it also has added benefits beyond what Dictionary<K,V> can provide you.It\'s all about programmer convenience. I can imagine writing quick and dirty programs with this object.I think it will have a syntactic benefit, since you\'ll no longer be "faking" dynamically added properties by using a dictionary.That, and interop with dynamic languages I would think.It\'s example from great MSDN article about using ExpandoObject for creating dynamic ad-hoc types for incoming structured data (i.e XML, Json). We can also assign delegate to ExpandoObject\'s dynamic property:Thus it allows us to inject some logic into dynamic object at runtime. \nTherefore, together with lambda expressions, closures, dynamic keyword and DynamicObject class, we can introduce some elements of functional programming into our C# code, which we knows from dynamic languages as like JavaScript or PHP.There are some cases where this is handy. I\'ll use it for a Modularized shell for instance. Each module defines it\'s own Configuration Dialog databinded to it\'s settings. I provide it with an ExpandoObject as it\'s Datacontext and save the values in my configuration Storage. This way the Configuration Dialog writer just has to Bind to a Value and it\'s automatically created and saved. (And provided to the module for using these settings of course)It\' simply easier to use than an Dictionary. But everyone should be aware that internally it is just a Dictionary.It\'s like LINQ just syntactic sugar, but it makes things easier sometimes.So to answer your question directly: It\'s easier to write and easier to read. But technically it essentially is a Dictionary<string,object> (You can even cast it into one to list the values).I think that only works because everything has a ToString(), otherwise you\'d have to know the type that it was and cast the \'object\' to that type.Some of these are useful more often than others, I\'m trying to be thorough.It may be far more natural to access a collection, in this case what is effectively a "dictionary", using the more direct dot notation.It seems as if this could be used as a really nice Tuple. You can still call your members "Item1", "Item2" etc... but now you don\'t have to, it\'s also mutable, unlike a Tuple. This does have the huge drawback of lack of intellisense support.You may be uncomfortable with "member names as strings", as is the feel with the dictionary, you may feel it is too like "executing strings", and it may lead to naming conventions getting coded in, and dealing with working with morphemes and syllables when code is trying understand how to use members :-PCan you assign a value to an ExpandoObject itself or just it\'s members? Compare and contrast with dynamic/dynamic[], use whichever best suits your needs.I don\'t think dynamic/dynamic[] works in a foreach loop, you have to use var, but possibly you can use ExpandoObject.You cannot use dynamic as a data member in a class, perhaps because it\'s at least sort of like a keyword, hopefully you can with ExpandoObject.I expect it "is" an ExpandoObject, might be useful to label very generic things apart, with code that differentiates based on types where there is lots of dynamic stuff being used.Be nice if you could drill down multiple levels at once.Thats not the best possible example, imagine elegant uses as appropriate in your own projects.It\'s a shame you cannot have code build some of these and push the results to intellisense. I\'m not sure how this would work though.Be nice if they could have a value as well as members.