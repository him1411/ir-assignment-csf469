I wonder about what the best way is to create an JavaScript object that has properties and methods.I have seen examples where the person used var self = this and then uses self. in all functions to make sure the scope is always correct.Then I have seen examples of using .prototype to add properties, while others do it inline.Can someone give me a proper example of a JavaScript object with some properties and methods?There are two models for implementing classes and instances in JavaScript: the prototyping way, and the closure way. Both have advantages and drawbacks, and there are plenty of extended variations. Many programmers and libraries have different approaches and class-handling utility functions to paper over some of the uglier parts of the language.The result is that in mixed company you will have a mishmash of metaclasses, all behaving slightly differently. What\'s worse, most JavaScript tutorial material is terrible and serves up some kind of in-between compromise to cover all bases, leaving you very confused. (Probably the author is also confused. JavaScript\'s object model is very different to most programming languages, and in many places straight-up badly designed.)Let\'s start with the prototype way. This is the most JavaScript-native you can get: there is a minimum of overhead code and instanceof will work with instances of this kind of object.We can add methods to the instance created by new Shape by writing them to the prototype lookup of this constructor function:Now to subclass it, in as much as you can call what JavaScript does subclassing. We do that by completely replacing that weird magic prototype property:before adding methods to it:This example will work and you will see code like it in many tutorials. But man, that new Shape() is ugly: we\'re instantiating the base class even though no actual Shape is to be created. It happens to work in this simple case because JavaScript is so sloppy: it allows zero arguments to be passed in, in which case x and y become undefined and are assigned to the prototype\'s this.x and this.y. If the constructor function were doing anything more complicated, it would fall flat on its face.So what we need to do is find a way to create a prototype object which contains the methods and other members we want at a class level, without calling the base class\'s constructor function. To do this we are going to have to start writing helper code. This is the simplest approach I know of:This transfers the base class\'s members in its prototype to a new constructor function which does nothing, then uses that constructor. Now we can write simply:instead of the new Shape() wrongness. We now have an acceptable set of primitives to built classes.There are a few refinements and extensions we can consider under this model. For example here is a syntactical-sugar version:Either version has the drawback that the constructor function cannot be inherited, as it is in many languages. So even if your subclass adds nothing to the construction process, it must remember to call the base constructor with whatever arguments the base wanted. This can be slightly automated using apply, but still you have to write out:So a common extension is to break out the initialisation stuff into its own function rather than the constructor itself. This function can then inherit from the base just fine:Now we\'ve just got the same constructor function boilerplate for each class. Maybe we can move that out into its own helper function so we don\'t have to keep typing it, for example instead of Function.prototype.subclass, turning it round and letting the base class\'s Function spit out subclasses:...which is starting to look a bit more like other languages, albeit with slightly clumsier syntax. You can sprinkle in a few extra features if you like. Maybe you want makeSubclass to take and remember a class name and provide a default toString using it. Maybe you want to make the constructor detect when it has accidentally been called without the new operator (which would otherwise often result in very annoying debugging):Maybe you want to pass in all the new members and have makeSubclass add them to the prototype, to save you having to write Class.prototype... quite so much. A lot of class systems do that, eg:There are a lot of potential features you might consider desirable in an object system and no-one really agrees on one particular formula.The closure way, then. This avoids the problems of JavaScript\'s prototype-based inheritance, by not using inheritance at all. Instead:Now every single instance of Shape will have its own copy of the toString method (and any other methods or other class members we add).The bad thing about every instance having its own copy of each class member is that it\'s less efficient. If you are dealing with large numbers of subclassed instances, prototypical inheritance may serve you better. Also calling a method of the base class is slightly annoying as you can see: we have to remember what the method was before the subclass constructor overwrote it, or it gets lost.[Also because there is no inheritance here, the instanceof operator won\'t work; you would have to provide your own mechanism for class-sniffing if you need it. Whilst you could fiddle the prototype objects in a similar way as with prototype inheritance, it\'s a bit tricky and not really worth it just to get instanceof working.]The good thing about every instance having its own method is that the method may then be bound to the specific instance that owns it. This is useful because of JavaScript\'s weird way of binding this in method calls, which has the upshot that if you detach a method from its owner:then this inside the method won\'t be the Circle instance as expected (it\'ll actually be the global window object, causing widespread debugging woe). In reality this typically happens when a method is taken and assigned to a setTimeout, onclick or EventListener in general.With the prototype way, you have to include a closure for every such assignment:or, in the future (or now if you hack Function.prototype) you can also do it with function.bind():if your instances are done the closure way, the binding is done for free by the closure over the instance variable (usually called that or self, though personally I would advise against the latter as self already has another, different meaning in JavaScript). You don\'t get the arguments 1, 1 in the above snippet for free though, so you would still need another closure or a bind() if you need to do that.There are lots of variants on the closure method too. You may prefer to omit this completely, creating a new that and returning it instead of using the new operator:Which way is \xe2\x80\x9cproper\xe2\x80\x9d? Both. Which is \xe2\x80\x9cbest\xe2\x80\x9d? That depends on your situation. FWIW I tend towards prototyping for real JavaScript inheritance when I\'m doing strongly OO stuff, and closures for simple throwaway page effects.But both ways are quite counter-intuitive to most programmers. Both have many potential messy variations. You will meet both (as well as many in-between and generally broken schemes) if you use other people\'s code/libraries. There is no one generally-accepted answer. Welcome to the wonderful world of JavaScript objects.[This has been part 94 of Why JavaScript Is Not My Favourite Programming Language.]I use this pattern fairly frequently - I\'ve found that it gives me a pretty huge amount of flexibility when I need it.  In use it\'s rather similar to Java-style classes.This uses an anonymous function that is called upon creation, returning a new constructor function.  Because the anonymous function is called only once, you can create private static variables in it (they\'re inside the closure, visible to the other members of the class).  The constructor function is basically a standard Javascript object - you define private attributes inside of it, and public attributes are attached to the this variable.Basically, this approach combines the Crockfordian approach with standard Javascript objects  to create a more powerful class.You can use it just like you would any other Javascript object:Douglas Crockford discusses that topic extensively in The Good Parts. He recommends to avoid the new operator to create new objects. Instead he proposes to create customized constructors. For instance:In Javascript a function is an object, and can be used to construct objects out of together with the new operator. By convention, functions intended to be used as constructors start with a capital letter. You often see things like:In case you forget to use the new operator while instantiating a new object, what you get is an ordinary function call, and this is bound to the global object instead to the new object.To continue off of bobince\'s answerIn es6 you can now actually create a classSo now you can do:So extend to a circle (as in the other answer) you can do:Ends up a bit cleaner in es6 and a little easier to read.Here is a good example of it in action: You can also do it this way, using structures :Then :When one uses the trick of closing on "this" during a constructor invocation, it\'s in order to write a function that can be used as a callback by some other object that doesn\'t want to invoke a method on an object. It\'s not related to "making the scope correct".Here\'s a vanilla JavaScript object:You might get a lot out of reading what Douglas Crockford has to say about JavaScript. John Resig is also brilliant. Good luck!Closure is versatile. bobince has well summarized the prototype vs. closure approaches when creating objects. However you can mimic some aspects of OOP using closure in a functional programming way. Remember functions are objects in JavaScript; so use function as object in a different way.Here is an example of closure:A while ago I came across the Mozilla\'s article on Closure. Here is what jump at my eyes: "A closure lets you associate some data (the environment) with a function that operates on that data. This has obvious parallels to object oriented programming, where objects allow us to associate some data (the object\'s properties) with one or more methods". It was the very first time I read a parallelism between closure and classic OOP with no reference to prototype.How?Suppose you want to calculate the VAT of some items. The VAT is likely to stay stable during the lifetime of an application. One way to do it in OOP (pseudo code):Basically you pass a VAT value into your constructor and your calculate method can operate upon it via closure.\nNow instead of using a class/constructor, pass your VAT as an argument into a function. Because the only stuff you are interested in is the calculation itself, returns a new function, which is the calculate method:In your project identify top-level values that are good candidate of what VAT is for calculation. As a rule of thumb whenever you pass the same arguments on and on, there is a way to improve it using closure. No need to create traditional objects.https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/ClosuresAnother way would be http://jsfiddle.net/nnUY4/\n(i dont know if this kind of handling object creation and revealing functions follow any specific pattern)In addition to the accepted answer from 2009. If you can can target modern browsers, one can make use of the Object.defineProperty. The Object.defineProperty() method defines a new property directly on\n  an object, or modifies an existing property on an object, and returns\n  the object.\n  Source: MozillaTo see a desktop and mobile compatibility list, see Mozilla\'s Browser Compatibility list. Yes, IE9+ supports it as well as Safari mobile. Bascially there is no concept of class in JS so we use function as a class constructor which is relevant with the existing design patterns.Till now JS has no clue that you want to create an object so here comes the new keyword.Ref : Professional JS for web developers - Nik Z