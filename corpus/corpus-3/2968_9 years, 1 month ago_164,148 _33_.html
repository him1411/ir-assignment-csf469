Using reflection, how can I get all types that implement an interface with C# 3.0/.NET 3.5 with the least code, and minimizing iterations?This is what I want to re-write:Mine would be this in c# 3.0 :)Basically, the least amount of iterations will always be:To find all types in an assembly that implement IFoo interface:Note that Ryan Rinaldi\'s suggestion was incorrect. It will return 0 types. You cannot writebecause type is a System.Type instance, and will never be of type IFoo. Instead, you check to see if IFoo is assignable from the type. That will get your expected results.Also, Adam Wright\'s suggestion, which is currently marked as the answer, is incorrect as well, and for the same reason. At runtime, you\'ll see 0 types come back, because all System.Type instances weren\'t IFoo implementors.This worked for me. It loops though the classes and checks to see if they are derrived from myInterfaceI appreciate this is a very old question but I thought I would add another answer for future users as all the answers to date use some form of Assembly.GetTypes. Whilst GetTypes() will indeed return all types, it does not necessarily mean you could activate them and could thus potentially throw a ReflectionTypeLoadException.A classic example for not being able to activate a type would be when the type returned is derived from base but base is defined in a different assembly from that of derived, an assembly that the calling assembly does not reference. So say we have:If in ClassC which is in AssemblyC we then do something as per accepted answer:Then it will throw a ReflectionTypeLoadException. This is because without a reference to AssemblyA  in AssemblyC you would not be able to:In other words ClassB is not loadable which is something that the call to GetTypes checks and throws on.So to safely qualify the result set for loadable types then as per this Phil Haacked article Get All Types in an Assembly and Jon Skeet code you would instead do something like:And then:Other answers here use IsAssignableFrom.  You can also use FindInterfaces from the System namespace, as described here.Here\'s an example that checks all assemblies in the currently executing assembly\'s folder, looking for classes that implement a certain interface (avoiding LINQ for clarity).You can set up a list of interfaces if you want to match more than one.loop through all loaded assemblies, loop through all their types, and check if they implement the interface.something like:This worked for me (if you wish you could exclude system types in the lookup):Edit: I\'ve just seen the edit to clarify that the original question was for the reduction of iterations / code and that\'s all well and good as an exercise, but in real-world situations you\'re going to want the fastest implementation, regardless of how cool the underlying LINQ looks.Here\'s my Utils method for iterating through the loaded types.  It handles regular classes as well as interfaces, and the excludeSystemTypes option speeds things up hugely if you are looking for implementations in your own / third-party codebase.It\'s not pretty, I\'ll admit.There\'s no easy way (in terms of performance) to do what you want to do.Reflection works with assemblys and types mainly so you\'ll have to get all the types of the assembly and query them for the right interface. Here\'s an example:That will get you all the types that implement the IMyInterface in the Assembly MyAssemblyYou could use some LINQ to get the list:But really, is that more readable?