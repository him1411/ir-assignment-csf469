We are currently working in a private beta and so are still in the process of making fairly rapid changes, although obviously as usage is starting to ramp up, we will be slowing down this process.  That being said, one issue we are running into is that after we push out an update with new JavaScript files, the client browsers still use the cached version of the file and they do not see the update.  Obviously, on a support call, we can simply inform them to do a ctrlF5 refresh to ensure that they get the up-to-date files from the server, but it would be preferable to handle this before that time.Our current thought is to simply attach a version number onto the name of the JavaScript files and then when changes are made, increment the version on the script and update all references.  This definitely gets the job done, but updating the references on each release could get cumbersome.As I\'m sure we\'re not the first ones to deal with this, I figured I would throw it out to the community.  How are you ensuring clients update their cache when you update your code?  If you\'re using the method described above, are you using a process that simplifies the change?As far as I know a common solution is to add a ?<version> to the script\'s src link.For instance:I assume at this point that there isn\'t a better way than find-replace to increment these "version numbers" in all of the script tags?You might have a version control system do that for you? Most version control systems have a way to automatically inject the revision number on check-in for instance.It would look something like this:Of course, there are always better solutions like this one.Appending the current time to the URL is indeed a common solution. However, you can also manage this at the web server level, if you want to. The server can be configured to send different HTTP headers for javascript files. For example, to force the file to be cached for no longer than 1 day, you would send:For beta, if you want to force the user to always get the latest, you would use:Google Page-Speed: Don\'t include a query string in the URL for static resources.\nMost proxies, most notably Squid up through version 3.0, do not cache resources with a "?" in their URL even if a Cache-control: public header is present in the response. To enable proxy caching for these resources, remove query strings from references to static resources, and instead encode the parameters into the file names themselves. In this case, you can include the version into URL ex: http://abc.com/v1.2/script.js and use apache mod_rewrite to redirect the link to http://abc.com/script.js. When you change the version, client browser will update the new file.This answer is only 6 years late, but I don\'t see this answer in many places... HTML5 has introduced Application Cache which is used to solve this problem. I was finding that new server code I was writing was crashing old javascript stored in people\'s browsers, so I wanted to find a way to expire their javascript. Use a manifest file that looks like this:and generate this file with a new time stamp every time you want users to update their cache. As a side note, if you add this, the browser will not reload (even when a user refreshes the page) until the manifest tells it to.How about adding the filesize as a load parameter?So every time you update the file the "filever" parameter changes.How about when you update the file and your update results in the same file size? what are the odds?Not all browsers cache files with \'?\' in it. What I did to make sure it was cached as much as possible, I included the version in the filename. So instead of stuff.js?123, I did stuff_123.js I used mod_redirect(I think) in apache to to have stuff_*.js to go stuff.jsFor ASP.NET pages I am using the followingBEFOREAFTER (force reload)Adding the DateTime.Now.Ticks works very well.For ASP.NET I suppose next solution with advanced options (debug/release mode, versions):Js or Css files included by such way:Global.JsPostfix and Global.CssPostfix is calculated by the following way in Global.asax:If you\'re generating the page that links to the JS files a simple solution is appending the file\'s last modification timestamp to the generated links. This is very similar to Huppie\'s answer, but works in version control systems without keyword substitution. It\'s also better than append the current time, since that would prevent caching even when the file didn\'t change at all.The jQuery function getScript can also be used to ensure that a js file is indeed loaded every time the page is loaded.This is how I did it:Check the function at http://api.jquery.com/jQuery.getScript/By default, $.getScript() sets the cache setting to false. This appends a timestamped query parameter to the request URL to ensure that the browser downloads the script each time it is requested.My colleague just found a reference to that method right after I posted (in reference to css) at http://www.stefanhayden.com/blog/2006/04/03/css-caching-hack/.  Good to see that others are using it and it seems to work.  I assume at this point that there isn\'t a better way than find-replace to increment these "version numbers" in all of the script tags?Athough it is framework specific, Django 1.4 has this functionailty which works in a similar fashion to the link to the \'greenfelt\' site in the above answer In PHP:In HTML:How it works:In HTML, write the filepath and name as you wold do, but in the function only.\nPHP gets the filetime of the file and returns the filepath+name+"?"+time of latest change One simple way.\nEdit htaccessOne solution is to append a query string with a timestamp in it to the URL when fetching the resource. This takes advantage of the fact that a browser will not cache resources fetched from URLs with query strings in them.You probably don\'t want the browser not to cache these resources at all though; it\'s more likely that you want them cached, but you want the browser to fetch a new version of the file when it is made available.The most common solution seems to be to embed a timestamp or revision number in the file name itself. This is a little more work, because your code needs to be modified to request the correct files, but it means that, e.g. version 7 of your snazzy_javascript_file.js (i.e. snazzy_javascript_file_7.js) is cached on the browser until you release version 8, and then your code changes to fetch snazzy_javascript_file_8.js instead.Simplest solution?  Don\'t let the browser cache at all.  Append the current time (in ms) as a query.(You are still in beta, so you could make a reasonable case for not optimizing for performance.  But YMMV here.)The advantage of using a file.js?V=1 over a fileV1.js is that you do not need to store multiple versions of the JavaScript files on the server.The trouble I see with file.js?V=1 is that you may have dependant code in another JavaScript file that breaks when using the new version of the library utilities.For the sake of backwards compatibility, I think it is much better to use jQuery.1.3.js for your new pages and let existing pages use jQuery.1.1.js, until you are ready to upgrade the older pages, if necessary.Use a version GET variable to prevent browser caching.Appending ?v=AUTO_INCREMENT_VERSION to the end of your url prevents browser caching - avoiding any and all cached scripts.Cache Busting in ASP.NET Core via a tag helper will handle this for you and allow your browser to keep cached scripts/css until the file changes. Simply add the tag helper asp-append-version="true" to your script (js) or link (css) tag:Dave Paquette has a good example and explanation of cache busting here (bottom of page) Cache Busting 