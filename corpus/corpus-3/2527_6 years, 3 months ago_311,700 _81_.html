What\'s the difference between addEventListener and onclick?The code above resides together in a separate .js file, and they both work perfectly.Both are correct, but none of them are "best" per se, and there may be a reason the developer chose to use both approaches.Event Listeners (addEventListener and IE\'s attachEvent)Earlier versions of Internet Explorer implement javascript differently from pretty much every other browser.  With versions less than 9, you use the attachEvent[doc]  method, like this:In most other browsers (including IE 9 and above), you use addEventListener[doc], like this:Using this approach (DOM Level 2 events), you can attach a theoretically unlimited number of events to any single element. The only practical limitation is client-side memory and other performance concerns, which are different for each browser.The examples above represent using an anonymous function[doc]. You can also add an event listener using a function reference[doc] or a closure[doc]:Another important feature of addEventListener is the final parameter, which controls how the listener reacts to bubbling events[doc]. I\'ve been passing false in the examples, which is standard for probably 95% of use cases. There is no equivalent argument for attachEvent, or when using inline events.Inline events (HTML onclick="" property and element.onclick)In all browsers that support javascript, you can put an event listener inline, meaning right in the HTML code.  You\'ve probably seen this:Most experienced developers shun this method, but it does get the job done; it is simple and direct. You may not use closures or anonymous functions here (though the handler itself is an anonymous function of sorts), and your control of scope is limited.The other method you mention:... is the equivalent of inline javascript except that you have more control of the scope (since you\'re writing a script rather than HTML) and can use anonymous functions, function references, and/or closures.The significant drawback with inline events is that unlike event listeners described above, you may only have one inline event assigned. Inline events are stored as an attribute/property of the element[doc], meaning that it can be overwritten.Using the example <a> from the HTML above:... when you clicked the element, you\'d only see "Did stuff #2" - you overwrote the first assigned of the onclick property with the second value, and you overwrote the original inline HTML onclick property too. Check it out here: http://jsfiddle.net/jpgah/.Which is Best?The question is a matter of browser compatibility and necessity. Do you currently need to attach more than one event to an element? Will you in the future? Odds are, you will. attachEvent and addEventListener are necessary. If not, an inline event will do the trick.jQuery and other javascript frameworks encapsulate the different browser implementations of DOM level 2 events in generic models so you can write cross-browser compliant code without having to worry about IE\'s history as a rebel.  Same code with jQuery, all cross-browser and ready to rock:Don\'t run out and get a framework just for this one thing, though. You can easily roll your own little utility to take care of the older browsers:Try it: http://jsfiddle.net/bmArj/Taking all of that into consideration, unless the script you\'re looking at took the browser differences into account some other way (in code not shown in your question), the part using addEventListener would not work in IE versions less than 9.Documentation and Related ReadingThe difference you could see if you had another couple of functions:Functions 2, 3 and 4 work, but 1 does not.  This is because addEventListener does not overwrite existing event handlers, whereas onclick overrides any existing onclick = fn event handlers.The other significant difference, of course, is that onclick will always work, whereas addEventListener does not work in Internet Explorer before version 9. You can use the analogous attachEvent (which has slightly different syntax) in IE <9.In this answer I will describe the three methods of defining DOM event handlers.Code example:element.addEventListener() has multiple advantages:Code example:This was a way to register event handlers in DOM 0. It\'s now discouraged, because it:Code example:Similarly to element.onevent, it\'s now discouraged. Besides the issues that element.onevent has, it:While onclick works in all browsers, addEventListener does not work in older versions of Internet Explorer, which uses attachEvent instead.The downside of onclick is that there can only be one event handler, while the other two will fire all registered callbacks.As far as I know, the DOM "load" event still does only work very limited. That means it\'ll only fire for the window object, images and <script> elements for instance. The same goes for the direct onload assignment. There is no technical difference between those two. Probably .onload = has a better cross-browser availabilty.However, you cannot assign a load event to a <div> or <span> element or whatnot.If you are not too worried about browser support, there is a way to rebind the \'this\' reference in the function called by the event. It will normally point to the element that generated the event when the function is executed, which is not always what you want. The tricky part is to at the same time be able to remove the very same event listener, as shown in this example: http://jsfiddle.net/roenbaeck/vBYu3/The code above works well in Chrome, and there\'s probably some shim around making "bind" compatible with other browsers.Using inline handlers is incompatible with Content Security Policy so the addEventListener approach is more secure from that point of view. Of course you can enable the inline handlers with unsafe-inline but, as the name suggests, it\'s not safe as it brings back the whole hordes of JavaScript exploits that CSP prevents.One detail hasn\'t been noted yet: modern desktop browsers consider different button presses to be "clicks" for AddEventListener(\'click\' and onclick by default.Also, middle-click behavior is very inconsistent across browsers when scroll cursors are involved:It is also worth noting that "click" events for any keyboard-selectable HTML element such as input also fire on space or enter when the element is selected.It should also be possible to either extend the listener by prototyping it (if we have a reference to it and its not an anonymous function) -or make the \'onclick\' call a call to a function library (a function calling other functions)likethis means we never has to chenge the onclick call just alter the function myFunctionList() to do what ever we want, but this leave us without control of bubbling/catching phases so should be avoided for newer browsers.just in case someone find this thread in the future...addEventListener lets you set multiple handlers, but isn\'t supported in IE8 or lower.IE does have attachEvent, but it\'s not exactly the same.Javascript tends to blend everything into objects and that can make it confusing. All into one is the JavaScript way.Essentially onclick is a HTML attribute. Conversely addEventListener is a method on the DOM object representing a HTML element.In JavaScript objects, a method is merely a property that has a function as a value and that works against the object it is attached to (using this for example).In JavaScript as HTML element represented by DOM will have it\'s attributes mapped onto its properties.This is where people get confused because JavaScript melds everything into a single container or namespace with no layer of indirection.In a normal OO layout (which does at least merge the namespace of properties/methods) you would might have something like:There are variations like it could use a getter/setter for onload or HashMap for attributes but ultimately that\'s how it would look. JavaScript eliminated that layer of indirection at the expect of knowing what\'s what among other things. It merged domElement and attributes together.Barring compatibility you should as a best practice use addEventListener. As other answers talk about the differences in that regard rather than the fundamental programmatic differences I will forgo it. Essentially, in an ideal world you\'re really only meant to use on* from HTML but in an even more ideal world you shouldn\'t be doing anything like that from HTML.Why is it dominant today? It\'s quicker to write, easier to learn and tends to just work.The whole point of onload in HTML is to give access to the addEventListener method or functionality in the first place. By using it in JS you\'re going through HTML when you could be applying it directly.Hypothetically you can make your own attributes:What JS does with is a bit different to that.You can equate it to something like (for every element created):The actual implementation details will likely differ with a range of subtle variations making the two slightly different in some cases but that\'s the gist of it.It\'s arguably a compatibility hack that you can pin a function to an on attribute since by default attributes are all strings.According to MDN, the difference as below: addEventListener:The EventTarget.addEventListener() method adds the specified\n  EventListener-compatible object to the list of event listeners for the\n  specified event type on the EventTarget on which it\'s called. The\n  event target may be an Element in a document, the Document itself, a\n  Window, or any other object that supports events (such as\n  XMLHttpRequest).onclick:The onclick property returns the click event handler code on the\n  current element. When using the click event to trigger an action, also\n  consider adding this same action to the keydown event, to allow the\n  use of that same action by people who don\'t use a mouse or a touch\n  screen. Syntax element.onclick = functionRef; where functionRef is a\n  function - often a name of a function declared elsewhere or a function\n  expression. See "JavaScript Guide:Functions" for details.There is also a syntax difference in use as you see in the below codes:\naddEventListener:onclick:The context referenced by \'this\' keyword in JavasSript is different.look at the following code:What it does is really simple. when you click the button, the button will be disabled automatically.First when you try to hook up the events in this way button.onclick = function(),\nonclick event will be triggered by clicking the button, however, the button will not be disabled because there\'s no explicit binding between button.onclick and onclick event handler. If you debug see the \'this\' object, you can see it refers to \'window\' object.Secondly, if you comment btnSubmit.onclick = disable(); and uncomment \n//btnSubmit.addEventListener(\'click\', disable, false); you can see that the button is disabled because with this way there\'s explicit binding between button.onclick event and onclick event handler. If you debug into disable function, you can see \'this\' refers to the button control rather than the window.This is something I don\'t like about JavaScript which is inconsistency.\nBtw, if you are using jQuery($(\'#btnSubmit\').on(\'click\', disable);), it uses explicit binding. 