I\'m a bit confused regarding the difference between push_back and emplace_back.As there is a push_back overload taking a rvalue reference I don\'t quite see what the purpose of emplace_back becomes?In addition to what visitor said :The function void emplace_back(Type&& _Val) provided by MSCV10 is non conforming and redundant, because as you noted it is strictly equivalent to push_back(Type&& _Val).But the real C++0x form of emplace_back is really useful: void emplace_back(Args&&...);Instead of taking a value_type it takes a variadic list of arguments, so that means that you can now perfectly forward the arguments and construct directly an object into a container without a temporary at all. That\'s useful, Because no matter how much cleverness RVO and move semantic bring to the table there is still complicated cases where a push_back is likely to make unnecessary copies (or move). For example, with the traditional insert() function of a std::map, you have to create a temporary, which will then be copied into a std::pair<Key, Value>, which will then be copied into the map : So why didn\'t they implement the right version of emplace_back in MSVC ? Actually it bugged me too a while ago, so I asked the same question on the Visual C++ blog. Here is the answer from Stephan T Lavavej, the official maintainer of the Visual C++ standard library implementation at Microsoft.Q : Are beta 2 emplace functions just some kind of placeholder right now ?A : As you may know, variadic templates\n  aren\'t implemented in VC10. We\n  simulate them with preprocessor\n  machinery for things like\n  make_shared<T>(), tuple, and the new\n  things in <functional>. This\n  preprocessor machinery is relatively\n  difficult to use and maintain. Also,\n  it significantly affects compilation\n  speed, as we have to repeatedly\n  include subheaders. Due to a\n  combination of our time constraints\n  and compilation speed concerns, we\n  haven\'t simulated variadic templates\n  in our emplace functions.When variadic templates are\n  implemented in the compiler, you can\n  expect that we\'ll take advantage of\n  them in the libraries, including in\n  our emplace functions. We take\n  conformance very seriously, but\n  unfortunately we can\'t do everything\n  all at once.It\'s an understandable decision. Everyone who tried just once to emulate variadic template with preprocessor horrible tricks know how disgusting this stuff gets. emplace_back shouldn\'t take an argument of type vector::value_type, but instead variadic arguments that are forwarded to the constructor of the appended item.It is possible to pass a value_type which will be forwarded to the copy constructor.Because it forwards the arguments, this means that if you don\'t have rvalue, this still means that the container will store a "copied" copy, not a moved copy.But the above should be identical to what push_back does. It is probably rather meant for use cases like:Optimization for emplace_back can be demonstrating in next example.For emplace_back constructor A (int x_arg) will be called. And for \npush_back A (int x_arg) is called first and move A (A &&rhs) is called afterwards.Of course constructor has to be marked explicit, but for current example is good to remove explicitness.output:emplace_back conforming implementation will forward arguments to the vector<Object>::value_typeconstructor when added to the vector. I recall Visual Studio didn\'t support variadic templates, but with variadic templates will be supported in Visual Studio 2013 RC, so I guess a conforming signature will be added.With emplace_back, if you forward the arguments directly to vector<Object>::value_type constructor, you don\'t need a type to be movable or copyable for emplace_back function, strictly speaking. In the vector<NonCopyableNonMovableObject> case, this is not useful, since vector<Object>::value_type  needs a copyable or movable type to grow. But note that this could be useful for std::map<Key, NonCopyableNonMovableObject>, since once you allocate an entry in the map, it doesn\'t need to be moved or copied ever anymore, unlike with vector, meaning that you can use std::map effectively with a mapped type that is neither copyable nor movable.