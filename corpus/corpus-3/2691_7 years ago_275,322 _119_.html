I\'m looking for any alternatives to the below for creating a JavaScript array containing 1 through to N where N is only known at runtime.To me it feels like there should be a way of doing this without the loop.If I get what you are after, you want an array of numbers 1..n that you can later loop through.If this is all you need, can you do this instead?then when you want to use it... (un-optimized, just for example)e.g. if you don\'t need to store anything in the array, you just need a container of the right length that you can iterate over... this might be easier.See it in action here: http://jsfiddle.net/3kcvm/You can do so:result:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]or with random values:result: [0.7082694901619107, 0.9572225909214467, 0.8586748542729765,\n  0.8653848143294454, 0.008339877473190427, 0.9911756622605026, 0.8133423360995948, 0.8377588465809822, 0.5577575915958732, 0.16363654541783035]First, note that Number.call(undefined, N) is equivalent to Number(N), which just returns N.  We\'ll use that fact later.Array.apply(null, [undefined, undefined, undefined]) is equivalent to Array(undefined, undefined, undefined), which produces a three-element array and assigns undefined to each element.How can you generalize that to N elements?  Consider how Array() works, which goes something like this:Since ECMAScript 5, Function.prototype.apply(thisArg, argsArray) also accepts a duck-typed array-like object as its second parameter.  If we invoke Array.apply(null, { length: N }), then it will executeNow we have an N-element array, with each element set to undefined.  When we call .map(callback, thisArg) on it, each element will be set to the result of callback.call(thisArg, element, index, array).  Therefore, [undefined, undefined, \xe2\x80\xa6, undefined].map(Number.call, Number) would map each element to (Number.call).call(Number, undefined, index, array), which is the same as Number.call(undefined, index, array), which, as we observed earlier, evaluates to index.  That completes the array whose elements are the same as their index.Why go through the trouble of Array.apply(null, {length: N}) instead of just Array(N)?  After all, both expressions would result an an N-element array of undefined elements.  The difference is that in the former expression, each element is explicitly set to undefined, whereas in the latter, each element was never set.  According to the documentation of .map():callback is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.Therefore, Array(N) is insufficient; Array(N).map(Number.call, Number) would result in an uninitialized array of length N.Since this technique relies on behaviour of Function.prototype.apply() specified in ECMAScript 5, it will not work in pre-ECMAScript 5 browsers such as Chrome 14 and Internet Explorer 9.In ES6 using Array from() and keys() methods.Shorter version using spread operator.In ES6 you can do:Array(N).fill().map((e,i)=>i+1);http://jsbin.com/molabiluwa/edit?js,consoleEdit:\nChanged Array(45) to Array(N) since you\'ve updated the question.Use the very popular Underscore _.range methodThus :Then called byThere is no built-in way to do this in Javascript, but it\'s a perfectly valid utility function to create if you need to do it more than once.Edit: In my opinion, the following is a better range function. Maybe just because I\'m biased by LINQ, but I think it\'s more useful in more cases. Your mileage may vary.You can use this:for examplewill create following array:If you happen to be using d3.js in your app as I am, D3 provides a helper function that does this for you.So to get an array from 0 to 4, it\'s as easy as:and to get an array from 1 to 5, as you were requesting:Check out this tutorial for more info.This is prolly the fastest way to generate an array of numbersShortestInlineIf you want to start from 1Want a function?WHY?while is the fastest loopDirect setting is faster than push[] is faster than new Array(10)it\'s short... look the first code. then look at all other functions in here.If you like can\'t live without forornote: apply, map, join-split .... srsly ??? that is damn slow!!!!!!and compatibility???Using ES2015/ES6 spread operatorI know your question is asking to populate an array numerically, but I\'m uncertain why you\'d want to do this. Arrays innately manage their lengths.  As they are traversed, their indexes can be held in memory and referenced at that point.  If a random index needs to be known, the indexOf method can be used.\nThis said, for your needs you may just want to declare an array of a certain size:  Making use of the spread operator (...) and keys method, enables you to create a temporary array of size N to produce the indexes, and then a new array that can be assigned to your variable:You can first create the size of the array you need, fill it with undefined and then create a new array using map, which sets each element to the index.Final Summary report .. Drrruummm Rolll -This is the shortest code to generate an Array of size N (here 10) without using ES6. Cocco\'s version above is close but not the shortest.But the undisputed winner of this Code golf(competition to solve a particular problem in the fewest bytes of source code) is Niko Ruotsalainen . Using Array Constructor and ES6 spread operator . (Most of the ES6 syntax is valid typeScript, but following is not. So be judicious while using it) There is another way in ES6, using Array.from which takes 2 arguments, the first is an arrayLike (in this case an object with length property), and the second is a mapping function (in this case we map the item to its index)this is shorter and can be used for other sequences like generating even numbersAlso this has better performance than most other ways because it only loops once through the array.\nCheck the snippit for some comparisonsUsing new Array methods and => function syntax from ES6 standard (only Firefox at the time of writing).By filling holes with undefined: Array.from turns "holes" into undefined so Array.map works as expected:Try this: If you are using CoffeeScript, you can create a range by doing:Otherwise, if you are using vanilla JavaScript, you\'ll have to use a loop if you want to initialize an array up to a variable length.If you are using lodash, you can use _.range:_.range([start=0], end, [step=1])Creates an array of numbers\n  (positive and/or negative) progressing from start up to, but not\n  including, end. A step of -1 is used if a negative start is specified\n  without an end or step. If end is not specified, it\'s set to start\n  with start then set to 0.Examples:I was looking for a functional solution and I ended up with:Note: join().split(\',\') transforms the sparse array into a contiguous one.The following function returns an array populated with numbers:Note that an array created with the array constructor consists of holes, so it cannot be traversed with array functions like map. Hence using the Array.apply function.A little bit simpler than the string variant:Returns [0, 1, 2]. Very similar to Igor Shubin\'s excellent answer, but with slightly less trickery (and one character longer).I didn\'t see any solution based on recursive functions (and never wrote recursive functions myself) so here is my try.Note that array.push(something) returns the new length of the array: And with a recursive function:EDIT : two other solutionsandImprovising on the above:one can get the following options:1) Array.init to value v2) get a reversed range:Just another ES6 version.By making use of Array.from second optional argument:Array.from(arrayLike[, mapFn[, thisArg]])We can build the numbered array from the empty Array(10) positions:You can use a function generator or function* expression.\nHere\'s [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function] And a reference to the function generator link to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function].let a = 1, b = 10;function* range(a, b) {\n  for (var i = a; i <= b; ++i) yield i;\n}Array.from(range(a, b));\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10][...range(a, b)]\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]Stealing Igors Number.call trick but using fill() to shorten slightly. Only works with ES6 and above.It seems the only flavor not currently in this rather complete list of answers is one featuring a generator; so to remedy that:const gen = N => [...(function*(){let i=0;while(i<N)yield i++})()]\nwhich can be used thus:gen(4) // [0,1,2,3]\nThe nice thing about this is you don\'t just have to increment... To take inspiration from the answer @igor-shubin gave, you could create an array of randoms very easily:const gen = N => [...(function*(){let i=0;\n  while(i++<N) yield Math.random()\n})()]\nAnd rather than something lengthy like:const slow = N => new Array(N).join().split(\',\').map((e,i)=>i*5)\n// [0,5,10,15,...]\n\nyou could instead do:const fast = N => [...(function*(){let i=0;while(i++<N)yield i*5})()]\nTry adding an iterator to Number\'s prototype.Now that numbers are iterable, simply pass a number to Array.fromor anywhere else an iterable is required, like for...of loops.It\'s somewhat convoluted, but also cool. Iterable version using a generator function that doesn\'t modify Number.prototype.