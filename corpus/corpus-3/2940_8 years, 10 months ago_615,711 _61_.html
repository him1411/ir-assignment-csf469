I have the string I want to count the occurrences of \'.\' in an idiomatic way, preferably a one-liner.(Previously I had expressed this constraint as "without a loop", in case you\'re wondering why everyone\'s trying to answer without using a loop).My \'idiomatic one-liner\' for this is:Why write it yourself when it\'s already in commons lang?Spring Framework\'s oneliner for this is:How about this. It doesn\'t use regexp underneath so should be faster than some of the other solutions and won\'t use a loop.Sooner or later, something has to loop. It\'s far simpler for you to write the (very simple) loop than to use something like split which is much more powerful than you need.By all means encapsulate the loop in a separate method, e.g.Then you don\'t need have the loop in your main code - but the loop has to be there somewhere.Summarize other answer and what I know all ways to do this using a one-liner:1) Using Apache Commons2) Using Spring Framework\'s3) Using replace4) Using replaceAll (case 1)5) Using replaceAll (case 2)6) Using split7)  Using Java8 (case 1)8)  Using Java8 (case 2), may be better for unicode than case 19)   Using StringTokenizerFrom comment: Be carefull for the StringTokenizer, for a.b.c.d it will work but for a...b.c....d or ...a.b.c.d or a....b......c.....d... or etc. it will not work. It just will count for . between characters just onceMore info in githubPerfomance test (using JMH, mode = AverageTime, score 0.010 better then 0.351): I had an idea similar to Mladen, but the opposite...ReplaceAll(".") would replace all characters.PhiLho\'s solution uses ReplaceAll("[^.]",""), which does not need to be escaped, since [.] represents the character \'dot\', not \'any character\'.My \'idiomatic one-liner\' solution:Have no idea why a solution that uses StringUtils is accepted. A shorter example ishere is a solution without a loop:well, there is a loop,  but it is invisible :-)-- YonatanI don\'t like the idea of allocating a new string for this purpose. And as the string already has a char array in the back where it stores it\'s value, String.charAt() is practically free.does the trick, without additional allocations that need collection, in 1 line or less, with only J2SE.Okay, inspired by Yonatan\'s solution, here\'s one which is purely recursive - the only library methods used are length() and charAt(), neither of which do any looping:Whether recursion counts as looping depends on which exact definition you use, but it\'s probably as close as you\'ll get.I don\'t know whether most JVMs do tail-recursion these days... if not you\'ll get the eponymous stack overflow for suitably long strings, of course.Inspired by Jon Skeet, a non-loop version that wont blow your stack. Also useful starting point if you want to use the fork-join framework.(Disclaimer: Not tested, not compiled, not sensible.)Perhaps the best (single-threaded, no surrogate-pair support) way to write it:Not sure about the efficiency of this, but it\'s the shortest code I could write without bringing in 3rd party libs:Complete sample:Call:With java-8 you could also use streams to achieve this. Obviously there is an iteration behind the scenes, but you don\'t have to write it explicitly!In case you\'re using Spring framework, you might also use "StringUtils" class.\nThe method would be "countOccurrencesOf".You can use the split() function in just one line code While methods can hide it, there is no way to count without a loop (or recursion). You want to use a char[] for performance reasons though.Using replaceAll (that is RE) does not sound like the best way to go.Somewhere in the code, something has to loop. The only way around this is a complete unrolling of the loop:...etc, but then you\'re the one doing the loop, manually, in the source editor - instead of the computer that will run it. See the pseudocode:Here is a slightly different style recursion solution:Why not just split on the character and then get the length of the resulting array. array length will always be number of instances + 1.  Right?The following source code will give you no.of occurrences of a given string in a word entered by user :- Using Eclipse CollectionsIf you have more than one character to count, you can use a CharBag as follows:Note: I am a committer for Eclipse Collections.Try this method:Why are you trying to avoid the loop? I mean you can\'t count the "numberOf" dots without checking every single character of the string, and if you call any function, somehow it will loop. This is, String.replace should do a loop verifying if the string appears so it can replace every single occurrence.If you\'re trying to reduce resource usage, you won\'t do it like that because you\'re creating a new String just for counting the dots.Now if we talk about the recursive "enter code here" method, someone said that it will fail due to an OutOfMemmoryException, I think he forgot StackOverflowException.So my method would be like this (I know it is like the others but, this problem requires  the loop):