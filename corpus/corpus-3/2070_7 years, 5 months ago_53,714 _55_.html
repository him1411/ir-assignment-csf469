I came across PECS (short for Producer extends and Consumer super) while reading up on generics. Can someone explain to me how to use PECS to resolve confusion between extends and super?tl;dr: "PECS" is from the collection\'s point of view. If you are only pulling items from a generic collection, it is a producer and you should use extends; if you are only stuffing items in, it is a consumer and you should use super. If you do both with the same collection, you shouldn\'t use either extends or super.Suppose you have a method that takes as its parameter a collection of things, but you want it to be more flexible than just accepting a Collection<Thing>.Case 1: You want to go through the collection and do things with each item.\nThen the list is a producer, so you should use a Collection<? extends Thing>.The reasoning is that a Collection<? extends Thing> could hold any subtype of Thing, and thus each element will behave as a Thing when you perform your operation. (You actually cannot add anything to a Collection<? extends Thing>, because you cannot know at runtime which specific subtype of Thing the collection holds.)Case 2: You want to add things to the collection.\nThen the list is a consumer, so you should use a Collection<? super Thing>.The reasoning here is that unlike Collection<? extends Thing>, Collection<? super Thing> can always hold a Thing no matter what the actual parameterized type is. Here you don\'t care what is already in the list as long as it will allow a Thing to be added; this is what ? super Thing guarantees.The principles behind this in Computer Science is named after The picture below should explain the concept.Picture courtesy : Andrey TyukinPECS (short for "Producer extends and Consumer super") can be explained by : Get and Put PrincipleIt states,1. For Extends Wildcard(get values i.e Producer extends)Here is a method, that takes a collection of numbers, converts each to a double, and sums them upLet\'s call the method :Since, sum() method uses extends, all of the following calls are legal.\nThe first two calls would not be legal if extends was not used.EXCEPTION : You cannot put  anything  into  a  type  declared  with  an extends wildcard\xe2\x80\x94except  for  the  value null, which belongs to every reference type:2. For Super Wildcard(put values i.e Consumer super)Here is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:Let\'s call the method :Since, count() method uses super, all of the following calls are legal:\nThe last two calls would not be legal if super was not used.EXCEPTION : you cannot get anything out from a type declared with a super wildcard\xe2\x80\x94except for a value of type Object, which is a supertype of every reference type:3. When both Get and Put, don\'t Use wildcardWhenever you both put values into and get values out of the same structure, you should not use a wildcard.PECS(Producer extends and Consumer super) mnemonic --> Input and Output (i.e. return type principle)In Java, arguments and type arguments does not support inheritance as follows.for generics type arguments:These kind of problem are solved by using Generics with wildcards:   Note: wildcard ? means zero or one time.   A wildcard describes a family of types.  There are 3 different flavours of wildcards:   Angelika Langer is best to learn genericsGuidelines for Wildcard Use One of the more confusing aspects when learning to program with generics is determining when to use an upper bounded wildcard and when to use a lower bounded wildcard.    For purposes of this discussion, it is helpful to think of variables as providing one of two functions:  An "In" Variable\nAn "in" variable serves up data to the code. Imagine a copy method with two arguments: copy(src, dest). The src argument provides the data to be copied, so it is the "in" parameter.  An "Out" Variable\nAn "out" variable holds data for use elsewhere. In the copy example, copy(src, dest), the dest argument accepts data, so it is the "out" parameter.  Wildcard Guidelines: source Analogy: source In the following picture, the type A is a set of horses, the type B is a set of people, and the arrows describe a function of type Function1[A,B].  The variance tells me that I can use this function with a more flexible type than plain Function1[A,B], I can use it with any type Function1[X,Y] where X is a subset of A and Y is a superset of B. "Using with this type" here means that I call this function in a context where I know (or, rather, the compiler can prove) that the argument passed to the function is always a member of the set X, and the code handling the result of the function can process any value that is a member of set Y. This is illustrated in the following picture:   But the full type of Function1[-A,+B] contains these funny little signs that denote the variance, the minus meaning that it is contravariant in A, the plus meaning that it is covariant in B. The variance tells me that I can use this function with a more flexible type than plain Function1[A,B], I can use it with any type Function1[X,Y] where X is a subset of A and Y is a superset of B. "Using with this type" here means that I call this function in a context where I know (or, rather, the compiler can prove) that the argument passed to the function is always a member of the set X, and the code handling the result of the function can process any value that is a member of set Y. This is illustrated in the following picture:\n It doesn\'t hurt at all if I restrict the function to just the brown horses, it will always return a well defined person for that horse. But it would fail if I called it with a cow.As I explain in my answer to another question, PECS is a mnemonic device  created by Josh Bloch to help remember Producer extends, Consumer super.This means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.When a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.Note that generally you should only be using ? extends T and ? super T for the parameters of some method. Methods should just use T as the type parameter on a generic return type.In nutshell easy to remember PECS (adding an answer because never enough examples with Generics wildcards)