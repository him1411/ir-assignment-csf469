What are the scenarios when one is preferable over the other? And why?It is rare, in reality, that you would want to use an array. Definitely use a List<T> any time you want to add/remove data, since resizing arrays is expensive. If you know the data is fixed length, and you want to micro-optimise for some very specific reason (after benchmarking), then an array may be useful.List<T> offers a lot more functionality than an array (although LINQ evens it up a bit), and is almost always the right choice. Except for params arguments, of course. ;-pAs a counter - List<T> is one-dimensional; where-as you have have rectangular (etc) arrays like int[,] or string[,,] - but there are other ways of modelling such data (if you need) in an object model.See also:That said, I make a lot of use of arrays in my protobuf-net project; entirely for performance:But this is definitely an exception; for general line-of-business processing, a List<T> wins every time.Really just answering to add a link which I\'m surprised hasn\'t been mentioned yet: Eric\'s Lippert\'s blog entry on "Arrays considered somewhat harmful."You can judge from the title that it\'s suggesting using collections wherever practical - but as Marc rightly points out, there are plenty of places where an array really is the only practical solution.Use an array when you are dealing with data that is:Use a list for:Use a hashmap for:In reality, you\'ll want a list or hashmap almost all of the time. Next time you pick a data structure, think about what it must do well for you (or your code, anyway). Then pick something based on that. When in doubt, pick something as general as possible, i.e. an interface you can replace the implementation of quite easily. Some good links in the other answers as well.Notwithstanding the other answers recommending List<T>, you\'ll want to use arrays when handling:Unless you are really concerned with performance, and by that I mean, "Why are you using .Net instead of C++?" you should stick with List<>. It\'s easier to maintain and does all the dirty work of resizing an array behind the scenes for you. (If necessary, List<> is pretty smart about choosing array sizes so it doesn\'t need to usually.)Arrays should be used in preference to List when the immutability of the collection itself is part of the contract between the client & provider code (not necessarily immutability of the items within the collection) AND when IEnumerable is not suitable.For example,It is clear that modification of "strChars" will not mutate the original "str" object, irrespective implementation-level knowledge of "str"\'s underlying type.But suppose thatIn this case, it\'s not clear from that code-snippet alone if the insert method will or will not mutate the original "str" object. It requires implementation level knowledge of String to make that determination, which breaks Design by Contract approach. In the case of String, it\'s not a big deal, but it can be a big deal in almost every other case. Setting the List to read-only does help but results in run-time errors, not compile-time.If I know exactly how many elements I\'m going to need, say I need 5 elements and only ever 5 elements then I use an array. Otherwise I just use a List<T>.Most of the times, using a List would suffice. A List uses an internal array to handle its data, and automatically resizes the array when adding more elements to the List than its current capacity, which makes it more easy to use than an array, where you need to know the capacity beforehand.See http://msdn.microsoft.com/en-us/library/ms379570(v=vs.80).aspx#datastructures20_1_topic5 for more information about Lists in C# or just decompile System.Collections.Generic.List<T>.If you need multidimensional data (for example using a matrix or in graphics programming), you would probably go with an array instead.As always, if memory or performance is an issue, measure it! Otherwise you could be making false assumptions about the code.Another situation not yet mentioned is when one will have a large number of items, each of which consists of a fixed bunch of related-but-independent variables stuck together (e.g. the coordinates of a point, or the vertices of a 3d triangle).  An array of exposed-field structures will allow the its elements to be efficiently modified "in place"--something which is not possible with any other collection type.  Because an array of structures holds its elements consecutively in RAM, sequential accesses to array elements can be very fast.  In situations where code will need to make many sequential passes through an array, an array of structures may outperform an array or other collection of class object references by a factor of 2:1; further, the ability to update elements in place may allow an array of structures to outperform any other kind of collection of structures.Although arrays are not resizable, it is not difficult to have code store an array reference along with the number of elements that are in use, and replace the array with a larger one as required.  Alternatively, one could easily write code for a type which behaved much like a List<T> but exposed its backing store, thus allowing one to say either MyPoints.Add(nextPoint); or MyPoints.Items[23].X += 5;.  Note that the latter would not necessarily throw an exception if code tried to access beyond the end of the list, but usage would otherwise be conceptually quite similar to List<T>.It completely depends on the contexts in which the data structure is needed. For example, if you are creating items to be used by other functions or services using List is the perfect way to accomplish it.Now if you have a list of items and you just want to display them, say on a web page array is the container you need to use. Rather than going through a comparison of the features of each data type, I think the most pragmatic answer is "the differences probably aren\'t that important for what you need to accomplish, especially since they both implement IEnumerable, so follow popular convention and use a List until you have a reason not to, at which point you probably will have your reason for using an array over a List." Most of the time in managed code you\'re going to want to favor collections being as easy to work with as possible over worrying about micro-optimizations.Lists in .NET are wrappers over arrays, and use an array internally.  The time complexity of operations on lists is the same as would be with arrays, however there is a little more overhead with all the added functionality / ease of use of lists (such as automatic resizing and the methods that come with the list class).  Pretty much, I would recommend using lists in all cases unless there is a compelling reason not to do so, such as if you need to write extremely optimized code, or are working with other code that is built around arrays.