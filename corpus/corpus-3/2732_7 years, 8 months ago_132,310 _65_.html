Occasionally I dropped a DVD-rip into a website project, then carelessly git commit -a -m ..., and, zap, the repo was bloated by 2.2 gigs. Next time I made some edits, deleted the video file, and committed everything, but the compressed file is still there in the repository, in history.I know I can start branches from those commits and rebase one branch onto another. But what should I do to merge together the 2 commits so that the big file didn\'t show in the history and were cleaned in garbage collection procedure?Use the BFG Repo-Cleaner, a simpler, faster alternative to git-filter-branch specifically designed for removing unwanted files from Git history.Carefully follow the usage instructions, the core part is just this:Any files over 100MB in size (that aren\'t in your latest commit) will be removed from your Git repository\'s history. You can then use git gc to clean away the dead data:The BFG is typically at least 10-50x faster than running git-filter-branch, and generally easier to use.Full disclosure: I\'m the author of the BFG Repo-Cleaner.What you want to do is highly disruptive if you have published history to other developers. See \xe2\x80\x9cRecovering From Upstream Rebase\xe2\x80\x9d in the git rebase documentation for the necessary steps after repairing your history.You have at least two options: git filter-branch and an interactive rebase, both explained below.I had a similar problem with bulky binary test data from a Subversion import and wrote about removing data from a git repository.Say your git history is:Note that git lola is a non-standard but highly useful alias. With the --name-status switch, we can see tree modifications associated with each commit.In the \xe2\x80\x9cCareless\xe2\x80\x9d commit (whose SHA1 object name is ce36c98) the file oops.iso is the DVD-rip added by accident and removed in the next commit, cb14efd. Using the technique described in the aforementioned blog post, the command to execute is:Options:After some churning, the history is now:Notice that the new \xe2\x80\x9cCareless\xe2\x80\x9d commit adds only other.html and that the \xe2\x80\x9cRemove DVD-rip\xe2\x80\x9d commit is no longer on the master branch. The branch labeled refs/original/refs/heads/master contains your original commits in case you made a mistake. To remove it, follow the steps in \xe2\x80\x9cChecklist for Shrinking a Repository.\xe2\x80\x9dFor a simpler alternative, clone the repository to discard the unwanted bits.Using a file:///... clone URL copies objects rather than creating hardlinks only.Now your history is:The SHA1 object names for the first two commits (\xe2\x80\x9cIndex\xe2\x80\x9d and \xe2\x80\x9cAdmin page\xe2\x80\x9d) stayed the same because the filter operation did not modify those commits. \xe2\x80\x9cCareless\xe2\x80\x9d lost oops.iso and \xe2\x80\x9cLogin page\xe2\x80\x9d got a new parent, so their SHA1s did change.With a history of:you want to remove oops.iso from \xe2\x80\x9cCareless\xe2\x80\x9d as though you never added it, and then \xe2\x80\x9cRemove DVD-rip\xe2\x80\x9d is useless to you. Thus, our plan going into an interactive rebase is to keep \xe2\x80\x9cAdmin page,\xe2\x80\x9d edit \xe2\x80\x9cCareless,\xe2\x80\x9d and discard \xe2\x80\x9cRemove DVD-rip.\xe2\x80\x9dRunning $ git rebase -i 5af4522 starts an editor with the following contents.Executing our plan, we modify it toThat is, we delete the line with \xe2\x80\x9cRemove DVD-rip\xe2\x80\x9d and change the operation on \xe2\x80\x9cCareless\xe2\x80\x9d to be edit rather than pick.Save-quitting the editor drops us at a command prompt with the following message.As the message tells us, we are on the \xe2\x80\x9cCareless\xe2\x80\x9d commit we want to edit, so we run two commands.The first removes the offending file from the index. The second modifies or amends \xe2\x80\x9cCareless\xe2\x80\x9d to be the updated index and -C HEAD instructs git to reuse the old commit message. Finally, git rebase --continue goes ahead with the rest of the rebase operation.This gives a history of:which is what you want.Why not use this simple but powerful command?The --tree-filter option runs the specified command after each checkout of the project and then recommits the results. In this case, you remove a file called DVD-rip from every snapshot, whether it exists or not. See this link.These commands worked in my case:It is little different from the above versions.For those who need to push this to github/bitbucket (I only tested this with bitbucket):git filter-branch --tree-filter \'rm -f path/to/file\' HEAD \nworked pretty well for me, although I ran into the same problem as described here, which I solved by following this suggestion.The pro-git book has an entire chapter on rewriting history - have a look at the filter-branch/Removing a File from Every Commit section.Just note that this commands can be very destructive. If more people are working on the repo they\'ll all have to pull the new tree. The three middle commands are not necessary if your goal is NOT to reduce the size. Because the filter branch creates a backup of the removed file and it can stay there for a long time. If you know your commit was recent instead of going through the entire tree do the following:\n\ngit filter-branch --tree-filter \'rm LARGE_FILE.zip\' HEAD~10..HEAD\nI ran into this with a bitbucket account, where I had accidentally stored ginormous *.jpa backups of my site. git filter-branch --prune-empty --index-filter \'git rm -rf --cached --ignore-unmatch MY-BIG-DIRECTORY-OR-FILE\' --tag-name-filter cat -- --allRelpace MY-BIG-DIRECTORY with the folder in question to completely rewrite your history (including tags). source: http://naleid.com/blog/2012/01/17/finding-and-purging-big-files-from-git-historyAfter trying virtually every answer in SO, I finally found this gem that quickly removed and deleted the large files in my repository and allowed me to sync again: http://www.zyxware.com/articles/4027/how-to-delete-files-permanently-from-your-local-and-remote-git-repositoriesCD to your local working folder and run the following command:replace FOLDERNAME with the file or folder you wish to remove from the given git repository.Once this is done run the following commands to clean up the local repository:Now push all the changes to the remote repository:This will clean up the remote repository.Use Git Extensions, it\'s a UI tool. It has a plugin named "Find large files" which finds lage files in repositories and allow removing them permenently.Don\'t use \'git filter-branch\' before using this tool, since it won\'t be able to find files removed by \'filter-branch\' (Altough \'filter-branch\' does not remove files completely from the repository pack files).When you run into this problem, git rm will not suffice, as git remembers that the file existed once in our history, and thus will keep a reference to it.To make things worse, rebasing is not easy either, because any references to the blob will prevent git garbage collector from cleaning up the space. This includes remote references and reflog references.I put together git forget-blob, a little script that tries removing all these references, and then uses git filter-branch to rewrite every commit in the branch.Once your blob is completely unreferenced, git gc will get rid of itThe usage is pretty simple git forget-blob file-to-forget. You can get more info herehttps://ownyourbits.com/2017/01/18/completely-remove-a-file-from-a-git-repository-with-git-forget-blob/I put this together thanks to the answers from Stack Overflow and some blog entries. Credits to them!You can do this using the branch filter command:git filter-branch --tree-filter \'rm -rf path/to/your/file\' HEADI basically did what was on this answer:\nhttps://stackoverflow.com/a/11032521/1286423(for history, I\'ll copy-paste it here)It didn\'t work, because I like to rename and move things a lot. So some big file were in folders that have been renamed, and I think the gc couldn\'t delete the reference to those files because of reference in tree objects pointing to those file.\nMy ultimate solution to really kill it was to:My repo (the .git) changed from 32MB to 388KB, that even filter-branch couldn\'t clean.