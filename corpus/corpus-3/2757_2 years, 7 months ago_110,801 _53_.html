I have restructured my code to promises, and built a wonderful long flat promise chain, consisting of multiple .then() callbacks. In the end I want to return some composite value, and need to access multiple intermediate promise results. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?When you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don\'t forget, a promise just represents (proxies) a future value! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.This will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.Instead of the parameter destructuring in the callback after Promise.all that only became avail­able with ES6, in ES5 the then call would be replaced by a nifty helper method that was provided by many promise libraries (Q, Bluebird, when, \xe2\x80\xa6): .spread(function(resultA, resultB) { \xe2\x80\xa6.Bluebird also features a dedicated join function to replace that Promise.all+spread combination with a simpler (and more efficient) construct:Of course, this problem was recognized by the language designers as well. They did a lot of work and the async functions proposal finally made it intoYou don\'t need a single then invocation or callback function any more, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don\'t need them here:While we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with generator functions, which allow to break the execution apart in pieces at arbitrarily placed yield keywords. Those slices can be run after each other, independently, even asynchronously - and that\'s just what we do when we want to wait for a promise resolution before running the next step.There are dedicated libraries (like co or task.js), but also many promise libraries have helper functions (Q, Bluebird, when, \xe2\x80\xa6) that do this async step-by-step execution for you when you give them a generator function that yields promises.This did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.However, if you want/need to be backwards-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on generators and async functions.And then, there are also many other compile-to-JS languages\nthat are dedicated to easing asynchronous programming. They usually use a syntax similar to await, (e.g. Iced CoffeeScript), but there are also others that feature a Haskell-like do-notation (e.g. LatteJs, monadic, PureScript or LispyScript).Assigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird\'s .value() method but many libraries provide similar method.This can be used for as many values as you like:Using closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily nest and flatten .then() callbacks - they are semantically equivalent, except for the scope of the inner one.Of course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the pyramid of doom: modularize, use extra named functions, and flatten the promise chain as soon as you don\'t need a variable any more.\nIn theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.You can also use helper functions for this kind of partial application, like _.partial from Underscore/lodash or the native .bind() method, to further decrease indentation:Similar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.Here, that little arrow b => [resultA, b] is the function that closes over resultA, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.Before destructuring became available with ES6, a nifty helper method called .spread() was pro­vi­ded by many promise libraries (Q, Bluebird, when, \xe2\x80\xa6). It takes a function with multiple parameters - one for each array element - to be used as .spread(function(resultA, resultB) { \xe2\x80\xa6.Of course, that closure needed here can be further simplified by some helper functions, e.g.Alternatively, you can employ Promise.all to produce the promise for the array:And you might not only use arrays, but arbitrarily complex objects. For example, with _.extend or Object.assign in a different helper function:While this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.The trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:Instead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.This solution has several drawbacks:The Bluebird library encourages the use of an object that is passed along, using their bind() method to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable this keyword. While object properties are more prone to undetected typos than variables, the pattern is quite clever:This approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):Another answer, using babel-node version <6 Using async - await npm install -g babel@5.6.14example.js:Then, run babel-node example.js and voila!Node 7.4 now supports async/await calls with the harmony flag.Try this: and run the file with:node --harmony-async-await getExample.jsSimple as can be!Another answer, using sequential executor nsynjs:I am not going to use this pattern in my own code since I\'m not a big fan of using global variables. However, in a pinch it will work.User is a promisified Mongoose model.When using bluebird, you can use .bind method to share variables in promise chain:please check this link for further information:http://bluebirdjs.com/docs/api/promise.bind.htmleasy way :DI think you can use hash of RSVP.Something like as below :Using a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it\'s simple and good to read. I hope this can help you.According to how-to-chain-javascript-promisesok, let\'s look at the code: