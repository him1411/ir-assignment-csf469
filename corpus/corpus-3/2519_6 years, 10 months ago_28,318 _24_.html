This snippet gives the following output (newlines are replaced by spaces):a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl cm cn co cp cq cr cs ct cu cv cw cx cy cz da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz ea eb ec ed ee ef eg eh ei ej ek el em en eo ep eq er es et eu ev ew ex... on to yzFrom the docs:PHP follows Perl\'s convention when dealing with arithmetic operations on character variables and not C\'s.For example, in Perl \'Z\'+1 turns into \'AA\', while in C \'Z\'+1 turns into \'[\' ( ord(\'Z\') == 90, ord(\'[\') == 91 ).Note that character variables can be incremented but not decremented and even so only plain ASCII characters (a-z and A-Z) are supported.From Comments:-\nIt should also be noted that <= is a lexicographical comparison, so \'z\'+1 \xe2\x89\xa4 \'z\'. (Since \'z\'+1 = \'aa\' \xe2\x89\xa4 \'z\'. But \'za\' \xe2\x89\xa4 \'z\' is the first time the comparison is false.) Breaking when $i == \'z\' would work, for instance.Example here.Because once \'z\' is reached (and this is a valid result within your range, the $i++ increments it to the next value in sequence), the next value will be \'aa\'; and alphabetically, \'aa\' is < \'z\', so the comparison is never metOthers answers explain the observed behavior of the posted code.  Here is one way to do what you want (and it\'s cleaner code, IMO):In response to ShreevatsaR\'s comment/question about the range function:  Yes, it produces the "right endpoint", i.e. the values passed to the function are in the range.  To illustrate, the output from the above code was:Others already said why PHP doesn\'t show what you expect. Here\'s how you get the result you might want:Why not just use range(\'a\',\'z\')?Try this code. I think this code will be helpful to you.Display 26 letters in sequence.Also this can be used:PHP has the function of looping letters and can exceed beyond single characters; the rest will be done this way: aa ab ac... zz, and so on.While the above answers are insightful to what\'s going on, and pretty interesting (I didn\'t know it would behave like this, and its good to see why.The easiest fix (although perhaps not the most meaningful) would be just to change the condition to $i != \'z\'The PHP does not consider \'AA\' less than \'Z\'.\nThe best way to make this is:abcdefghijklmnopqrstuvwxyzPerhaps this code will work. It\xe2\x80\x99s easy & can be understood:where 26 is the total number of letters in the alphabet.Wow I really didn\'t know about this but its not a big code you can try echo "z" after loop Mark is Absolutely Right I use his method but if you want alternative then this may also you can try