I have the following code:We know he should have writen just x++ or x=x+1, but on x = x++ it should first attribute x to itself, and later increment it. Why does x continue with 0 as value?--updateHere\'s the bytecode:I\'ll read about the instructions to try to understand...Note: Originally I posted C# code in this answer for purposes of illustration, since C# allows you to pass int parameters by reference with the ref keyword. I\'ve decided to update it with actual legal Java code using the first MutableInt class I found on Google to sort of approximate what ref does in C#. I can\'t really tell if that helps or hurts the answer. I will say that I personally haven\'t done all that much Java development; so for all I know there could be much more idiomatic ways to illustrate this point.Perhaps if we write out a method to do the equivalent of what x++ does it will make this clearer.Right? Increment the value passed and return the original value: that\'s the definition of the postincrement operator.Now, let\'s see how this behavior plays out in your example code:postIncrement(x) does what? Increments x, yes. And then returns what x was before the increment. This return value then gets assigned to x.So the order of values assigned to x is 0, then 1, then 0.This might be clearer still if we re-write the above:Your fixation on the fact that when you replace x on the left side of the above assignment with y, "you can see that it first increments x, and later attributes it to y" strikes me as confused. It is not x that is being assigned to y; it is the value formerly assigned to x. Really, injecting y makes things no different from the scenario above; we\'ve simply got:So it\'s clear: x = x++ effectively does not change the value of x. It always causes x to have the values x0, then x0 + 1, and then x0 again.Update: Incidentally, lest you doubt that x ever gets assigned to 1 "between" the increment operation and the assignment in the example above, I\'ve thrown together a quick demo to illustrate that this intermediate value does indeed "exist," though it will never be "seen" on the executing thread.The demo calls x = x++; in a loop while a separate thread continuously prints the value of x to the console.Below is an excerpt of the above program\'s output. Notice the irregular occurrence of both 1s and 0s.x = x++ works in the following way:So, the sequence of events looks like follows (it\'s an actual decompiled bytecode, as produced by javap -c, with my comments):For comparison, x = ++x:This happens because the value of x doesn\'t get incremented at all.is equivalent toExplanation:Let\'s look at the byte code for this operation. Consider a sample class:Now running the class disassembler on this we get:Now the Java VM is stack based which means for each operation, the data will be pushed onto the stack and from stack the data will popped out to perform the operation. There is also another data structure, typically an array to store the local variables. The local variables are given ids which are just the indexes to the array.Let us look at the mnemonics in main() method:Hence the value of x does not change resulting in the infinite loop.However "=" has a lower operator precedence than "++".So x=x++; should evaluate as followsNone of the answers where quite spot on, so here goes:When you\'re writing int x = x++, you\'re not assigning x to be itself at the new value, you\'re assigning x to be the return value of the x++ expression. Which happens to be the original value of x, as hinted in Colin Cochrane\'s answer .For fun, test the following code:The result will be The return value of the expression is the initial value of x, which is zero. But later on, when reading the value of x, we receive the updated value , that is one.It has been already explained well by other. I just include the links to the relevant Java specification sections.x = x++ is an expression. Java will follow the evaluation order.\nIt will first evaluate the expression x++, which will increment x and set result value to the previous value of x.\nThen it will assign the expression result to the variable x. At the end, x is back at its previous value.This statement:evaluates like this:So the value is unchanged. Compare that to:which evaluates as:What you want is:The answer is pretty straightforward. It has to do with the order things are evaluated. x++ returns the value x then increments x.Consequently, the value of the expression x++ is 0. So you are assigning x=0 each time in the loop. Certainly x++ increments this value, but that happens before the assignment.From http://download.oracle.com/javase/tutorial/java/nutsandbolts/op1.htmlThe increment/decrement operators can\n  be applied before (prefix) or after\n  (postfix) the operand. The code\n  result++; and ++result; will both end\n  in result being incremented by one.\n  The only difference is that the prefix\n  version (++result) evaluates to the\n  incremented value, whereas the\n  postfix version (result++) evaluates\n  to the original value. If you are\n  just performing a simple\n  increment/decrement, it doesn\'t really\n  matter which version you choose. But\n  if you use this operator in part of a\n  larger expression, the one that you\n  choose may make a significant\n  difference.To illustrate, try the following:Which will print 1 and 0.You\'re effectively getting the following behavior.The idea being that the post-increment operator (x++) increments that variable in question AFTER returning its value for use in the equation it\'s used in.Edit: Adding a slight bit because of the comment. Consider it like the following.You don\'t really need the machine code to understand what\'s happending.According the definitions:The assignment operator evaluates the right-hand side expression, and stores it in a temporary variable.1.1. The current value of x is copied into this temporary variable1.2. x is incremented now.The temporary variable is then copied into the left-hand side of the expression, which is x by chance! So that\'s why the old value of x is again copied into itself.It is pretty simple.This is because it never gets incremented in this case. x++ will use the value of it first before incrementing like on this case it will be like:But if you do ++x; this will increase.The value stays at 0 because the value of x++ is 0. In this case it doesn\'t matter if the value of x is increased or not, the assignment x=0 is executed. This will overwrite the temporary incremented value of x (which was 1 for a "very short time").This works how you expect the other one to.  It\'s the difference between prefix and postfix.Think of x++ as a function call that "returns" what X was before the increment (that\'s why it\'s called a post-increment).So the operation order is:\n1: cache the value of x before incrementing\n2: increment x\n3: return the cached value (x before it was incremented)\n4: return value is assigned to xWhen the ++ is on the rhs, the result is returned before the number is incremented.\nChange to ++x and it would have been fine.\nJava would have optimised this to perform a single operation (the assignment of x to x) rather than the increment.Well as far as I can see, the error occurs, due to the assignment overriding the incremented value, with the value prior to incrementation, i.e. it undoes the increment.Specifically, the "x++" expression, has the value of \'x\' prior to increment as opposed to "++x" which has the value of \'x\' after incrementation.If you are interested in investigating the bytecode, we will take a look at the three lines in question:7: iload_1 # Will put the value of the 2nd local variable on the stack \n8: iinc 1,1 # will increment the 2nd local variable with 1, note that it leaves the stack untouched!\n9: istore_1 # Will pop the top of stack and save the value of this element to the 2nd local variable\n(You can read the effects of each JVM instruction here)This is why the above code will loop indefinitely, whereas the version with ++x will not.\nThe bytecode for ++x should look quite different, as far as I remember from the 1.3 Java compiler I wrote a little over a year ago, the bytecode should go something like this:So just swapping the two first lines, changes the semantics so that the value left on the top of stack, after the increment (i.e. the \'value\' of the expression) is the value after the increment.So:WhereasSo:Of course the end result is the same as just x++; or ++x; on a line by itself.Sentence "translates" to That\'s it.because of above statement x never reaches 3;I wonder if there\'s anything in the Java spec that precisely defines the behavior of this. (The obviously implication of that statement being that I\'m too lazy to check.)Note from Tom\'s bytecode, the key lines are 7, 8 and 11. Line 7 loads x into the computation stack. Line 8 increments x. Line 11 stores the value from the stack back to x. In normal cases where you are not assigning values back to themselves, I don\'t think there would be any reason why you couldn\'t load, store, then increment. You would get the same result.Like, suppose you had a more normal case where you wrote something like:\n    z=(x++)+(y++);Whether it said (pseudocode to skip technicalities)orshould be irrelevant. Either implementation should be valid, I would think.I\'d be extremely cautious about writing code that depends on this behavior. It looks very implementation-dependent, between-the-cracks-in-the-specs to me. The only time it would make a difference is if you did something crazy, like the example here, or if you had two threads running and were dependent on the order of evaluation within the expression.I think because in Java ++ has a higher precedence than = (assignment)...Does it?\nLook at http://www.cs.uwf.edu/~eelsheik/cop2253/resources/op_precedence.html...The same way if you write x=x+1...+ has a higher precedence than = (assignment)The x++ expression evaluates to x. The ++ part affect the value after the evaluation, not after the statement. so x = x++ is effectively translated intoBefore incrementing the value by one, the value is assigned to the variable.It\'s happening because it\'s post incremented. It means that the variable is incremented after the expression is evaluated.x is now 10, but y is 9, the value of x before it was incremented.See more in Definition of Post Increment.Check the  below code,the output will be, post increment means increment the value and return the value before the increment. That is why the value temp is 0. So what if temp = i and this is in a loop (except for the first line of code). just like in the question !!!!The increment operator is applied to the same variable as you are assigning to. That\'s asking for trouble. I am sure that you can see the value of your x variable while running this program.... that\'s should make it clear why the loop never ends.