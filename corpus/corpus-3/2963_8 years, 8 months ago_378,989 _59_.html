Is there a way to step between 0 and 1 by 0.1? I thought I could do it like the following, but it failed:Instead, it says that the step argument cannot be zero, which I did not expect.You can also use the NumPy library (which isn\'t part of standard library but is relatively easy to obtain) which has the arange function:as well as the linspace function which lets you have control over what happens at the endpoint (non-trivial for floating point numbers when things won\'t always divide into the correct number of "slices"):Building on \'xrange([start], stop[, step])\', you can define a generator that accepts and produces any type you choose (stick to types supporting + and <):Python\'s range() can only do integers, not floating point. In your specific case, you can use a list comprehension instead:(Replace the call to range with that expression.) For the more general case, you may want to write a custom function or generator.Increase the magnitude of i for the loop and then reduce it when you need it.EDIT: I honestly cannot remember why I thought that would work syntacticallyThat should have the desired output. scipy has a built in function arange which generalizes Python\'s range() constructor to satisfy your requirement of float handling. from scipy import arangeSimilar to R\'s seq function, this one returns a sequence in any order given the correct step value. The last value is equal to the stop value. [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0][10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0][10, 8, 6, 4, 2, 0]NumPy is a bit overkill, I think.Generally speaking, to do a step-by-1/x up to y you would do(1/x produced less rounding noise when I tested).The range() built-in function returns a sequence of integer values, I\'m afraid, so you can\'t use it to do a decimal step.  I\'d say just use a while loop:If you\'re curious, Python is converting your 0.1 to 0, which is why it\'s telling you the argument can\'t be zero.in Python 2.7x gives you the result of:[0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]but if you use:gives you the desired:[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]Here\'s a solution using itertools:Usage Example:Output:And if you do this often, you might want to save the generated list rMy versions use the original range function to create multiplicative indices for the shift. This allows same syntax to the original range function.\nI have made two versions, one using float, and one using Decimal, because I found that in some cases I wanted to avoid the roundoff drift introduced by the floating point arithmetic.It is consistent with empty set results as in range/xrange.Passing only a single numeric value to either function will return the standard range output to the integer ceiling value of the input parameter (so if you gave it 5.5, it would return range(6).)Edit: the code below is now available as package on pypi: FrangesThis is my solution to get ranges with float steps.\nUsing this function it\'s not necessary to import numpy, nor install it.\nI\'m pretty sure that it could be improved and optimized. Feel free to do it and post it here.The output is:For completeness of boutique, a functional solution:You can use this function:My answer is similar to others using map(), without need of NumPy, and without using lambda (though you could).    To get a list of float values from 0.0 to t_max in steps of dt:Add auto-correction for the possibility of an incorrect sign on step:My solution:The trick to avoid round-off problem is to use a separate number to move through the range, that starts and half the step ahead of start.Alternatively, numpy.arange can be used.It can be done using Numpy library. arange() function allows steps in float. But, it returns a numpy array which can be converted to list using tolist() for our convenience.Best Solution: no rounding error\n__________________________________________________________________________________________________________________________________________________________________\nOr, for a set range instead of set data points (e.g. continuous function), use:To implement a function: replace x / pow(step, -1) with f( x / pow(step, -1) ), and define f.\nFor example:Here is my solution which works fine with float_range(-1, 0, 0.01) and works without floating point representation errors. It is not very fast, but works fine:    I am only a beginner, but I had the same problem, when simulating some calculations. Here is how I attempted to work this out, which seems to be working with decimal steps.I am also quite lazy and so I found it hard to write my own range function.Basically what I did is changed my xrange(0.0, 1.0, 0.01) to xrange(0, 100, 1) and used the division by 100.0 inside the loop.\nI was also concerned, if there will be rounding mistakes. So I decided to test, whether there are any. Now I heard, that if for example 0.01 from a calculation isn\'t exactly the float 0.01 comparing them should return False (if I am wrong, please let me know).So I decided to test if my solution will work for my range by running a short test:And it printed True for each.Now, if I\'m getting it totally wrong, please let me know.This one liner will not clutter your code. The sign of the step parameter is important.frange(start, stop, precision)