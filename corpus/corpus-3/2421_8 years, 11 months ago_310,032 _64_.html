I want to detect whether module has changed. Now, using inotify is simple, you just need to know the directory you want to get notifications from.How do I retrieve a module\'s path in python?Will actually give you the path to the .pyc file that was loaded, at least on Mac OS X. So I guess you can doYou can also tryTo get the directory to look for changes.There is inspect module in python.The inspect module provides several useful functions to help get\n  information about live objects such as modules, classes, methods,\n  functions, tracebacks, frame objects, and code objects. For example,\n  it can help you examine the contents of a class, retrieve the source\n  code of a method, extract and format the argument list for a function,\n  or get all the information you need to display a detailed traceback.Example:As the other answers have said, the best way to do this is with __file__ (demonstrated again below). However, there is an important caveat, which is that __file__ does NOT exist if you are running the module on its own  (i.e. as __main__).For example, say you have two files (both of which are on your PYTHONPATH):andRunning foo.py will give the output:HOWEVER if you try to run bar.py on its own, you will get:Hope this helps. This caveat cost me a lot of time and confusion while testing the other solutions presented.I will try tackling a few variations on this question as well:(Some of these questions have been asked on SO, but have been closed as duplicates and redirected here.)For a module that you have imported:will return the absolute path of the module.  However, given the folowing script foo.py:Calling it with \'python foo.py\' Will return simply \'foo.py\'.  If you add a shebang:and call it using ./foo.py, it will return \'./foo.py\'.  Calling it from a different directory, (eg put foo.py in directory bar), then calling eitheror adding a shebang and executing the file directly:will return \'bar/foo.py\' (the relative path).Now going from there to get the directory, os.path.dirname(__file__) can also be tricky.  At least on my system, it returns an empty string if you call it from the same directory as the file.  ex.will output:In other words, it returns an empty string, so this does not seem reliable if you want to use it for the current file (as opposed to the file of an imported module).  To get around this, you can wrap it in a call to abspath:which outputs something like:Note that abspath() does NOT resolve symlinks.  If you want to do this, use realpath() instead.  For example, making a symlink file_import_testing_link pointing to file_import_testing.py, with the following content:executing will print absolute paths something like:file_import_testing_link -> file_import_testing.py@SummerBreeze mentions using the inspect module.This seems to work well, and is quite concise, for imported modules:obediently returns the absolute path.  However for finding the path of the currently executing script, I did not see a way to use it.This was trivial.Each module has a __file__ variable that shows its relative path from where you are right now.Therefore, getting a directory for the module to notify it is simple as:I don\'t get why no one is talking about this, but to me the simplest solution is using imp.find_module("modulename") (documentation here):It gives a tuple with the path in second position:The advantage of this method over the "inspect" one is that you don\'t need to import the module to make it work, and you can use a string in input. Useful when checking modules called in another script for example.EDIT:In python3, importlib module should do:Doc of importlib.util.find_spec:Return the spec for the specified module.First, sys.modules is checked to see if the module was already imported. If so, then sys.modules[name].spec is returned. If that happens to be\n  set to None, then ValueError is raised. If the module is not in\n  sys.modules, then sys.meta_path is searched for a suitable spec with the\n  value of \'path\' given to the finders. None is returned if no spec could\n  be found.If the name is for submodule (contains a dot), the parent module is\n  automatically imported.The name and package arguments work the same as importlib.import_module().\n  In other words, relative module names (with leading dots) work.So I spent a fair amount of time trying to do this with py2exe\nThe problem was to get the base folder of the script whether it was being run as a python script or as a py2exe executable. Also to have it work whether it was being run from the current folder, another folder or (this was the hardest) from the system\'s path.Eventually I used this approach, using sys.frozen as an indicator of running in py2exe:Packages support one more special attribute, __path__. This is\n  initialized to be a list containing the name of the directory holding\n  the package\xe2\x80\x99s __init__.py before the code in that file is executed.\n  This variable can be modified; doing so affects future searches for\n  modules and subpackages contained in the package.While this feature is not often needed, it can be used to extend the\n  set of modules found in a package.SourceYou can tweak it to a command line utility,Create /usr/local/bin/python-whichMake it executable If the only caveat of using __file__ is when current, relative directory is blank (ie, when running as a script from the same directory where the script is), then a trivial solution is:And the result:The trick is in or \'.\' after the dirname() call. It sets the dir as ., which means current directory and is a valid directory for any path-related function.Thus, using abspath() is not truly needed. But if you use it anyway, the trick is not needed: abspath() accepts blank paths and properly interprets it as the current directory.From within modules of a python package I had to refer to a file that resided in the same directory as package. Ex.So in above I had to call maincli.py from my_lib_a.py module knowing that top_package and maincli.py are in the same directory. Here\'s how I get the path to maincli.py:Based on posting by PlasmaBinturong I modified the code.If you wish to do this dynamically in a "program" try this code:\nMy point is, you may not know the exact name of the module to "hardcode" it.\nIt may be selected from a list or may not be currently running to use __file__.(I know, it will not work in Python 3)I tried to get rid of the "global" issue but found cases where it did not work\nI think "execfile()" can be emulated in Python 3\nSince this is in a program, it can easily be put in a method or module for reuse.