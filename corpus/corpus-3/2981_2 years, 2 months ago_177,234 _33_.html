In a project I\'m collaborating on, we have two choices on which module system we can use:Are there any performance benefits to using one over the other? Is there anything else that we should know if we were to use ES6 modules over Node ones?Are there any performance benefits to using one over the other? Keep in mind that there is no JavaScript engine yet that natively supports ES6 modules. You said yourself that you are using Babel. Babel converts import and export declaration to CommonJS (require/module.exports) by default anyway. So even if you use ES6 module syntax, you will be using CommonJS under the hood if you run the code in Node.There are technical difference between CommonJS and ES6 modules, e.g. CommonJS allows you to load modules dynamically. ES6 doesn\'t allow this, but there is an API in development for that.Since ES6 modules are part of the standard, I would use them.There are several usage / capabilities you might want to consider:Require:ES6 Imports:Also, the Require module system isn\'t standard based. It\'s is highly unlikely to become standard now that ES6 modules exist. In the future there will be native support for ES6 Modules in various implementations which will be advantageous in terms of performance.The main advantages are syntactic:You are unlikely to see any performance benefits with ES6 modules. You will still need an extra library to bundle the modules, even when there is full support for ES6 features in the browser.Using ES6 modules can be useful for \'tree shaking\'; i.e. enabling Webpack 2, Rollup (or other bundlers) to identify code paths that are not used/imported, and therefore don\'t make it into the resulting bundle. This can significantly reduce its file size by eliminating code you\'ll never need, but with CommonJS is bundled by default because Webpack et al have no way of knowing whether it\'s needed.This is done using static analysis of the code path.For example, using:... gives the bundler a hint that package.anotherPart isn\'t required (if it\'s not imported, it can\'t be used- right?), so it won\'t bother bundling it.To enable this for Webpack 2, you need to ensure that your transpiler isn\'t spitting out CommonJS modules. If you\'re using the es2015 plug-in with babel, you can disable it in your .babelrc like so:Rollup and others may work differently - view the docs if you\'re interested.Are there any performance benefits to using one over the other?The current answer is no, because none of the current browser engines implements import/export from the ES6 standard.Some comparison charts http://kangax.github.io/compat-table/es6/ don\'t take this into account, so when you see almost all greens for Chrome, just be careful. import keyword from ES6 hasn\'t been taken into account.In other words, current browser engines including V8 cannot import new JavaScript file from the main JavaScript file via any JavaScript directive.( We may be still just a few bugs away or years away until V8 implements that according to the ES6 specification. )This document is what we need, and this document is what we must obey.And the ES6 standard said that the module dependencies should be there  before we read the module like in the programming language C, where we had (headers) .h files.This is a good and well-tested structure, and I am sure the experts that created the ES6 standard had that in mind.This is what enables Webpack or other package bundlers to optimize the bundle in some special cases, and reduce some dependencies from the bundle that are not needed. But in cases we have perfect dependencies this will never happen.It will need some time until import/export native support goes live, and the require keyword will not go anywhere for a long time. What is require?This is node.js way to load modules. ( https://github.com/nodejs/node )Node uses system-level methods to read files. You basically rely on that when using require. require will end in some system call like uv_fs_open (depends on the end system, Linux, Mac, Windows) to load JavaScript file/module.To check that this is true, try to use Babel.js, and you will see that the import keyword will be converted into require.