I\'m developing a page that pulls images from Flickr and Panoramio via jQuery\'s AJAX support.The Flickr side is working fine, but when I try to $.get(url, callback) from Panoramio, I see an error in Chrome\'s console:XMLHttpRequest cannot load http://www.panoramio.com/wapi/data/get_photos?v=1&key=dummykey&tag=test&offset=0&length=20&callback=processImages&minx=-30&miny=0&maxx=0&maxy=150. Origin null is not allowed by Access-Control-Allow-Origin.If I query that URL from a browser directly it works fine.  What is going on, and can I get around this?  Am I composing my query incorrectly, or is this something that Panoramio does to hinder what I\'m trying to do?Google didn\'t turn up any useful matches on the error message.EDITHere\'s some sample code that shows the problem:You can run the example online.EDIT 2Thanks to Darin for his help with this.  THE ABOVE CODE IS WRONG.  Use this instead:For the record, as far as I can tell, you had two problems:You weren\'t passing a "jsonp" type specifier to your $.get, so it was using an ordinary XMLHttpRequest. However, your browser supported CORS (Cross-Origin Resource Sharing) to allow cross-domain XMLHttpRequest if the server OKed it. That\'s where the Access-Control-Allow-Origin header came in.I believe you mentioned you were running it from a file:// URL. There are two ways for CORS headers to signal that a cross-domain XHR is OK. One is to send Access-Control-Allow-Origin: * (which, if you were reaching Flickr via $.get, they must have been doing) while the other was to echo back the contents of the Origin header. However, file:// URLs produce a null Origin which can\'t be authorized via echo-back.The first was solved in a roundabout way by Darin\'s suggestion to use $.getJSON. It does a little magic to change the request type from its default of "json" to "jsonp" if it sees the substring callback=? in the URL.That solved the second by no longer trying to perform a CORS request from a file:// URL.To clarify for other people, here are the simple troubleshooting instructions:You need to maybe add a HEADER in your called script, here is what I had to do in PHP:More details in Cross domain AJAX ou services WEB (in French).For a simple HTML project:Then browse your file.Works for me on Google Chrome v5.0.375.127 (I get the alert):Also I would recommend you using the $.getJSON() method instead as the previous doesn\'t work on IE8 (at least on my machine):You may try it online from here.UPDATE:Now that you have shown your code I can see the problem with it. You are having both an anonymous function and inline function but both will be called processImages. That\'s how jQuery\'s JSONP support works. Notice how I am defining the callback=? so that you can use an anonymous function. You may read more about it in the documentation.Another remark is that you shouldn\'t call eval. The parameter passed to your anonymous function will already be parsed into JSON by jQuery.As long as the requested server supports the JSON data format, use the JSONP (JSON Padding) interface. It allows you to make external domain requests without proxy servers or fancy header stuff.We managed it via the http.conf file (edited and then restarted the HTTP service):In the Header set Access-Control-Allow-Origin "*", you can put a precise URL.It\'s the same origin policy, you have to use a JSON-P interface or a proxy running on the same host.If you are doing local testing or calling the file from something like file:// then you need to disable browser security.On MAC:\nopen -a Google\\ Chrome --args --disable-web-securityIn my case, same code worked fine on Firefox, but not on Google Chrome. Google Chrome\'s JavaScript console said:I had to drop the www part of the Ajax URL for it to match correctly with the origin URL and it worked fine then.As final note the Mozilla documentation explicitly says thatThe above example would fail if the header was wildcarded as: \n  Access-Control-Allow-Origin: *.   Since the Access-Control-Allow-Origin explicitly mentions http://foo.example,\n  the credential-cognizant content is returned to the invoking web\n  content.As consequence is a not simply a bad practice to use \'*\'. Simply does not work :)Not all servers support jsonp. It requires the server to set the callback function in it\'s results. I use this to get json responses from sites that return pure json but don\'t support jsonp:I use Apache server, so I\'ve used mod_proxy module. Enable modules:Then add:Finally, pass proxy-url to your script.I also got the same error in Chrome (I didn\'t test other browers). It was due to the fact that I was navigating on domain.com instead of www.domain.com. A bit strange, but I could solve the problem by adding the following lines to .htaccess. It redirects domain.com to www.domain.com and the problem was solved. I am a lazy web visitor so I almost never type the www but apparently in some cases it is required.Make sure you are using the latest version of JQuery. We were facing this error for JQuery 1.10.2 and the error got resolved after using JQuery 1.11.1Folks,I ran into a similar issue. But using Fiddler, I was able to get at the issue. The problem is that the client URL that is configured in the CORS implementation on the Web API side must not have a trailing forward-slash. After submitting your request via Google Chrome and inspect the TextView tab of the Headers section of Fiddler, the error message states something like this:*"The specified policy origin your_client_url:/\' is invalid. It cannot end with a forward slash."This is real quirky because it worked without any issues on Internet Explorer, but gave me a headache when testing using Google Chrome. I removed the forward-slash in the CORS code and recompiled the Web API, and now the API is accessible via Chrome and Internet Explorer without any issues. Please give this a shot.Thanks,\nAndyThere is a small problem in the solution posted  in this link , where if you change a file, you\'ll have to restart the server to actually use the updated file (at least, in my case).So searching a bit, I found this one To use:And then it will serve at http://localhost:8000.