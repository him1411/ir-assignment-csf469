I can\'t find a definitive answer for this. AFAIK, you can\'t have multiple __init__ functions in a Python class. So what is a good way to solve this problem? Suppose I have an class called Cheese with the number_of_holes property. How can I have two ways of creating cheese-objects...I can think of only one way to do this, but that seems kinda clunky:What do you say? Is there a better way?Actually None is much better for "magic" values:Now if you want complete freedom of adding more parameters:To better explain the concept of *args and **kwargs (you can actually change these names):http://docs.python.org/reference/expressions.html#callsUsing num_holes=None as the default is fine if you are going to have just __init__.If you want multiple, independent "constructors", you can provide these as class methods. These are usually called factory methods.  In this case you could have the default for num_holes be 0.Now create object like this:All of these answers are excellent if you want to use optional parameters, but another Pythonic possibility is to use a classmethod to generate a factory-style pseudo-constructor:Why do you think your solution is "clunky"? Personally I would prefer one constructor with default values over multiple overloaded constructors in situations like yours (Python does not support method overloading anyway):For really complex cases with lots of different constructors, it might be cleaner to use different factory functions instead:In your cheese example you might want to use a Gouda subclass of Cheese though...Those are good ideas for your implementation, but if you are presenting a cheese making interface to a user.  They don\'t care how many holes the cheese has or what internals go into making cheese.  The user of your code just wants "gouda" or "parmesean" right?So why not do this:And then you can use any of the methods above to actually implement the functions:This is a good encapsulation technique, and I think it is more Pythonic.  To me this way of doing things fits more in line more with duck typing.  You are simply asking for a gouda object and you don\'t really care what class it is.The best answer is the one above about default arguments, but I had fun writing this, and it certainly does fit the bill for "multiple constructors". Use at your own risk.What about the new method."Typical implementations create a new instance of the class by invoking the superclass\xe2\x80\x99s new() method using super(currentclass, cls).new(cls[, ...]) with appropriate arguments and then modifying the newly-created instance as necessary before returning it."So you can have the new method modify your class definition by attaching the appropriate constructor method.Use num_holes=None as a default, instead. Then check for whether num_holes is None, and if so, randomize. That\'s what I generally see, anyway.More radically different construction methods may warrant a classmethod that returns an instance of cls.One should definitely prefer the solutions already posted, but since no one mentioned this solution yet, I think it is worth mentioning for completeness.The @classmethod approach can be modified to provide an alternative constructor which does not invoke the default constructor (__init__). Instead, an instance is created using __new__. This could be used if the type of initialization cannot be selected based on the type of the constructor argument, and the constructors do not share code. Example:I\'d use inheritance. Especially if there are going to be more differences than number of holes. Especially if Gouda will need to have different set of members then Parmesan.(as mentioned by the comment from @ariddell)OK, I\'ve researched and read the posts (and the FAQ) on how to simulate\n  multiple constructors. Alex Martelli provided the most robust answer by\n  testing the number of *args and executing the appropriate section of code.\n  However in another post he saysThis \'overloads\' the constructors based on how many arguments are\n    given -- how elegant (and how Pythonic...!) this is, being of course\n    debatable.  Overloading on types would be less elegant and less Pythonic, though you could easily extend this idea to do it -- I would\n    discourage it even more strongly.I think this part of my response is what makes it "robust":-).In other words, the best answer to this sort of queries is most\noften: yes, you can do it (and here\'s how), but there are better\napproaches (and here they are).  I didn\'t get fully into the\n"here\'s how" and "here they are" parts, admittedly.However, what I need to do is exactly what is being discouraged, that is\n  creating 3 constructors both with 2 arguments where the second argument of\n  each is a different type. The real kicker is that in one of the\n  constructors, I need to check the class of the object to make sure the\n  method is receiving the proper object. I have no problem coding this if\n  this\n  is the way it has to be but if there are more acceptable (and Pythonic)\n  ways\n  to do this, I would appreciate some pointers.Why do you think you NEED to distinguish your processing based on\nan argument\'s type, or class?  More likely, what you want to know\nabout an argument (to determine different processing in different\ncases) is how it BEHAVES -- which you can\'t do by testing types,\nor classes; rather, you may use hasattr or try/except to find out.By focusing on behavior, rather than on type-identity, you make\nlife easier for the client-code programmer: he or she can then\nmake polymorphic use of your components with any instance that\nimplements the needed behavior, which IS all your code needs.The idea of \'overloading\' -- having a callable with a single given\nname that maps to multiple internal callables depending on various\nconditions -- is also related to polymorphism; the only good reason\nto supply a single callable that maps to multiple ones is to let\nclient-code use that single callable polymorphically if need be.It\'s generally a good idea to ALSO expose the multiple callables\ndirectly -- don\'t make client-code programmers go through strange\ncontortions to make sure the \'right\' overload is invoked in the\nend; when their need are non-polymorphic, let them explicitly\nstate as much in the simplest possible way.  This does not sit in\nwell with \'constructors\' -- which is why factory functions tend\nto be preferable whenever any application need of some richness\nand complexity is involved (factory callables that are not\nfunctions are also OK, but meet a rarer, yet-more-involved need).In Python (just like in VB, and other languages with the concept\nof explicitly-named and default-valued arguments) you have another\nstylistic alternative to \'multiple callables\': one callable can\nbe explicitly used for several related purposes by supplying\ndifferent named-arguments.  This can easily be overdone (and VB\nsupplies a LOT of examples of this style being overused!-) but,\nused with taste and moderation, it can be very helpful too.Let\'s try to see one typical example.  We want to expose a class\nMunger, whose instances need to be initialized with \'a lot of\ndata to be munged\'; the \'lot of data\' could be a file, a string,\nor an instance of our own class DataBuffer which provides the\ndata-access features Munger instances need -- in fact, when we\nare given a file or string, we construct a DataBuffer ourselves\nand hold that anyway.The \'overload\' style might be:Now, this IS intended as a \'bad example\', and maybe I\'ve overdone\nthe badness, but I hope at least it IS clear why doing it this\nway would be heavily sub-optimal.  This does not exploit in any\nway the polymorphism of DataBuffer\'s own constructor, AND\nit seriously inhibits polymorphism capabilities of client-code\n(except via such tricks as naming a class as, say, \'string\'...!).It\'s clearly simpler to frame this as \'a Munger needs to be\npassed a DataBuffer, or anything a DataBuffer may be built from\':at least, we have some simplicity here.  Polymorphism is still\nnot optimal, though; if client-code wants to mimic a data\nbuffer, it needs to inherit from our DataBuffer class, even\nif it\'s not using any of its implementation, just to satisfy\nour isinstance check.  At the very least, one would \'split out\'\nfrom DataBuffer the interface and implementation parts:etc, with class DataBuffer inheriting from this (and providing\nthe needed overrides, of course) and the isinstance check\ndone against IDataBuffer.  Not very Pythonic, but workable\nif there are a LOT of DataBuffer methods we need -- checking\nfor each of them separately may become more trouble than\nit\'s worth.DataBuffer\'s own \'overloading\' ("am I being initialized from\na file or from a string?") needs to be handled.  Once again,\nit would be seriously wrong to code:because it horribily inhibits client-code\'s polymorphism.\nHere, all we need from a \'file object\' is a .read method\nwe can call without arguments to supply our data -- so\nwhy not code that directly...:this is MUCH simpler, of course.  One may add some\ntests at initialization to ensure the resulting data\nare usable for our purposes, but it\'s generally no\nbig problem if the error (if any) comes at first\nusage rather than at initialization.An alternative architecture is also worth considering.  DOES\nclient code REALLY NEED the polymorphism implicit in passing\na Munger constructor, either a file(-like) object, or a\nstring(-like) one, with very different implied semantics\nregarding how one gets data from said object?  Python libraries\ngive us counterexamples of that -- file-like objects and\nstring-like ones are generally passed through separate\nmethods; there\'s no real polymorphism opportunity there!So...:There, isn\'t THIS better?  Two non-overloaded factory\nfunctions, maximal simplicity in the constructors proper.Client-code knows what it IS using to construct the\nMunger and doesn\'t need the polymorphism -- it will\nbe clearer and more explicit and readable if it calls\nFileMunger or StringMunger appropriately, and only\nuses Munger\'s ctor directly for those cases where it\nneeds to reuse some existing IDataBuffer instance.If very occasionally a polymorphic use may benefit\nthe client-code author, we can add a further factory\nfunction for that purpose only:However, one doesn\'t go around just adding such stuff\nunless its appropriateness is clearly shown by some\nspecific use-case/scenario -- "you ain\'t gonna need it"\nis a GREAT design principle:-) [XP rules...!-)].Now, this IS of course a toy-level example, but I hope\nthat just because of this it may show up the issues more\nclearly -- and perhaps convince you to rethink your\ndesign in simpler and more usable ways.AlexThis is how I solved it for a YearQuarter class I had to create. I created an __init__ with a single parameter called value. The code for the __init__ just decides what type the value parameter is and process the data accordingly. In case you want multiple input parameters you just pack them into a single tuple and test for value being a tuple.You use it like this:And this is how the __init__ and the rest of the class looks like:You can expand the __init__ with multiple error messages of course. I omitted them for this example. 