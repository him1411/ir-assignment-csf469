After discussion with colleagues regarding the use of the \'var\' keyword in C# 3 I wondered what people\'s opinions were on the appropriate uses of type inference via var?For example I rather lazily used var in questionable circumstances, e.g.:-More legitimate uses of var are as follows:-Interestingly LINQ seems to be a bit of a grey area, e.g.:-It\'s clear what results will be in that it will be a type which implements IEnumerable, however it isn\'t entirely obvious in the same way a var declaring a new object is.It\'s even worse when it comes to LINQ to objects, e.g.:-This is no better than the equivilent foreach(var item in someList) { // ... } equivilent.There is a real concern about type safety here - for example if we were to place the results of that query into an overloaded method that accepted IEnumerable<int> and IEnumerable<double> the caller might inadvertently pass in the wrong type.var does maintain strong typing but the question is really whether it\'s dangerous for the type to not be immediately apparent on definition, something which is magnified when overloads mean compiler errors might not be issued when you unintentionally pass the wrong type to a method.I still think var can make code more readable in some cases. If I have a Customer class with an Orders property, and I want to assign that to a variable, I will just do this:I don\'t care if Customer.Orders is IEnumerable<Order>, ObservableCollection<Order> or BindingList<Order> - all I want is to keep that list in memory to iterate over it or get its count or something later on.Contrast the above declaration with:To me, the type name is just noise. And if I go back and decide to change the type of the Customer.Orders down the track (say from ObservableCollection<Order> to IList<Order>) then I need to change that declaration too - something I wouldn\'t have to do if I\'d used var in the first place.I use var extensively. There has been criticism that this diminishes the readability of the code, but no argument to support that claim.Admittedly, it may mean that it\'s not clear what type we are dealing with. So what? This is actually the point of a decoupled design. When dealing with interfaces, you are emphatically not interested in the type a variable has. var takes this much further, true, but I think that the argument remains the same from a readability point of view: The programmer shouldn\'t actually be interested in the type of the variable but rather in what a variable does. This is why Microsoft also calls type inference \xe2\x80\x9cduck typing.\xe2\x80\x9dSo, what does a variable do when I declare it using var? Easy, it does whatever IntelliSense tells me it does. Any reasoning about C# that ignores the IDE falls short of reality. In practice, every C# code is programmed in an IDE that supports IntelliSense.If I am using a var declared variable and get confused what the variable is there for, there\'s something fundamentally wrong with my code. var is not the cause, it only makes the symptoms visible. Don\'t blame the messenger.Now, the C# team has released a coding guideline stating that var should only be used to capture the result of a LINQ statement that creates an anonymous type (because here, we have no real alternative to var). Well, screw that. As long as the C# team doesn\'t give me a sound argument for this guideline, I am going to ignore it because in my professional and personal opinion, it\'s pure baloney. (Sorry; I\'ve got no link to the guideline in question.)Actually, there are some (superficially) good explanations on why you shouldn\'t use var but I still believe they are largely wrong. Take the example of \xe2\x80\x9csearchabililty\xe2\x80\x9d: the author claims that var makes it hard to search for places where MyType is used. Right. So do interfaces. Actually, why would I want to know where the class is used? I might be more interested in where it is instantiated and this will still be searchable because somewhere its constructor has to be invoked (even if this is done indirectly, the type name has to be mentioned somewhere).Var, in my opinion, in C# is a good thingtm.  Any variable so typed is still strongly typed, but it gets its type from the right-hand side of the assignment where it is defined.  Because the type information is available on the right-hand side, in most cases, it\'s unnecessary and overly verbose to also have to enter it on the left-hand side.  I think this significantly increases readability without decreasing type safety.From my perspective, using good naming conventions for variables and methods is more important from a readability perspective than explicit type information.  If I need the type information, I can always hover over the variable (in VS) and get it.  Generally, though, explicit type information shouldn\'t be necessary to the reader.  For the developer, in VS you still get Intellisense, regardless of how the variable is declared.  Having said all of that, there may still be cases where it does make sense to explicitly declare the type -- perhaps you have a method that returns a List<T>, but you want to treat it as an IEnumerable<T> in your method. To ensure that you are using the interface, declaring the variable of the interface type can make this explicit. Or, perhaps, you want to declare a variable without an initial value -- because it immediately gets a value based on some condition.  In that case you need the type. If the type information is useful or necessary, go ahead and use it. I feel, though, that typically it isn\'t necessary and the code is easier to read without it in most cases.Neither of those is absolutely true; var can have both positive and negative effects on readability. In my opinion, var should be used when either of the following is true:var has no performance impacts, as it\'s syntactic sugar; the compiler infers the type and defines it once it\'s compiled into IL; there\'s nothing actually dynamic about it.From Eric Lippert, a Senior Software Design Engineer on the C# team:Why was the var keyword introduced?There are two reasons, one which\n  exists today, one which will crop up\n  in 3.0.The first reason is that this code is\n  incredibly ugly because of all the\n  redundancy:Dictionary<string, List<int>> mylists = new Dictionary<string, List<int>>();And that\'s a simple example \xe2\x80\x93 I\'ve\n  written worse. Any time you\'re forced\n  to type exactly the same thing twice,\n  that\'s a redundancy that we can\n  remove. Much nicer to writevar mylists = new Dictionary<string,List<int>>();and let the compiler figure out what\n  the type is based on the assignment.Second, C# 3.0 introduces anonymous\n  types. Since anonymous types by\n  definition have no names, you need to\n  be able to infer the type of the\n  variable from the initializing\n  expression if its type is anonymous.Emphasis mine. The whole article, C# 3.0 is still statically typed, honest!, and the ensuing series are pretty good.This is what var is for. Other uses probably will not work so well. Any comparison to JScript, VBScript, or dynamic typing is total bunk. Note again, var is required in order to have certain other features work in .NET.I think the use of var should be coupled with wisely-chosen variable names.I have no problem using var in a foreach statement, provided it\'s not like this:If it were more like this:... then someone reading the code would be much more likely to understand what "list" is. If you have control over the name of the list variable itself, that\'s even better.The same can apply to other situations. This is pretty useless:... but this makes sense:Each to his own, I guess. I\'ve found myself doing this, which is just insane:I need some sort of 12-step var program. My name is Matt, and I (ab)use var.We\'ve adopted the ethos "Code for people, not machines", based on the assumption that you spend multiple times longer in maintenance mode than on new development.For me, that rules out the argument that the compiler "knows" what type the variable is - sure, you can\'t write invalid code the first time because the compiler stops your code from compiling, but when the next developer is reading the code in 6 months time they need to be able to deduce what the variable is doing correctly or incorrectly and quickly identify the cause of issues.Thus,is outlawed by our coding standards, but the following is encouraged in our team because it increases readability:It\'s not bad, it\'s more a stylistic thing, which tends to be subjective. It can add inconsistencies, when you do use var and when you don\'t. Another case of concern, in the following call you can\'t tell just by looking at the code the type returned by CallMe:That\'s my main complain against var.I use var when I declare anonymous delegates in methods, somehow var looks cleaner than if I\'d use Func. Consider this code:EDIT: Updated the last code sample based on Julian\'s inputVar is not like variant at all. The variable is still strongly typed, it\'s just that you don\'t press keys to get it that way. You can hover over it in Visual Studio to see the type. If you\'re reading printed code, it\'s possible you might have to think a little to work out what the type is. But there is only one line that declares it and many lines that use it, so giving things decent names is still the best way to make your code easier to follow.Is using Intellisense lazy? It\'s less typing than the whole name. Or are there things that are less work but don\'t deserve criticism? I think there are, and var is one of them.The most likely time you\'ll need this is for anonymous types (where it is 100% required); but it also avoids repetition for the trivial cases, and IMO makes the line clearer. I don\'t need to see the type twice for a simple initialization.For example:(please don\'t edit the hscroll in the above - it kinda proves the point!!!)vs:There are, however, occasions when this is misleading, and can potentially cause bugs. Be careful using var if the original variable and initialized type weren\'t identical. For example:One specific case where var is difficult: offline code reviews, especially the ones done on paper.You can\'t rely on mouse-overs for that.I don\'t see what the big deal is..You still have full intellisense on \'something\', and for any ambiguous case you have your unit tests, right? ( do you? )It\'s not varchar, it\'s not dim, and it\'s certainly not dynamic or weak typing. It is stopping maddnes like this:and reducing that total mindclutter to:Nice, not quite as nice as:But then that\'s what Boo is for.If someone is using the var keyword because they don\'t want to "figure out the type", that is definitely the wrong reason. The var keyword doesn\'t create a variable with a dynamic type, the compiler still has to know the type. As the variable always has a specific type, the type should also be evident in the code if possible.Good reasons to use the var keyword are for example:Writing out the data type often makes the code easier to follow. It shows what data types you are using, so that you don\'t have to figure out the data type by first figuring out what the code does.Given how powerful Intellisense is now, I am not sure var is any harder to read than having member variables in a class, or local variables in a method which are defined off the visible screen area. If you have a line of code such as Is is much easier or harder to read than:I think the key thing with VAR is to only use it where appropriate i.e. when doing things in Linq that it facilitates (and probably in other cases). If you\'ve got a type for something in the then you should use it - not to do so is simple laziness (as opposed to creative laziness which is generally to be encouraged - good programmers oft work very hard to be lazy and could be considered the source of the thing in the first place).A blanket ban is as bad as abusing the construct in the first place but there does need to be a sensible coding standard.The other thing to remember is that its not a VB type var in that it can\'t change types - it is a strongly typed variable its just that the type is inferred (which is why there are people that will argue that its not unreasonable to use it in, say, a foreach but I\'d disagree for reasons of both readability and maintainability).I suspect this one is going to run and run (-:MurphSure, int is easy, but when the variable\'s type is IEnumerable<MyStupidLongNamedGenericClass<int, string>>, var makes things much easier.Stolen from the post on this issue at CodingHorror:Unfortunately, you and everyone else pretty much got it wrong. While I agree with you that redundancy is not a good thing, the better way to solve this issue would have been to do something like the following:MyObject m = new();Or if you are passing parameters:Person p = new("FirstName", "LastName);Where in the creation of a new object, the compiler infers the type from the left-hand side, and not the right. This has other advantages over "var", in that it could be used in field declarations as well (there are also some other areas that it could be useful as well, but I won\'t get into it here).In the end, it just wasn\'t intended to reduce redundancy. Don\'t get me wrong, "var" is VERY important in C# for anonymous types/projections, but the use here is just WAY off (and I\'ve been saying this for a long, long time) as you obfuscate the type that is being used. Having to type it twice is too often, but declaring it zero times is too few.Nicholas Paldino .NET/C# MVP on June 20, 2008 08:00 AMI guess if your main concern is to have to type less -- then there isn\'t any argument that\'s going to sway you from using it.If you are only going to ever be the person who looks at your code, then who cares?  Otherwise, in a case like this:it\'s fine, but in a case like this:it short circuits any immediate type deductions my brain could begin forming from the \'English\' of the code.Otherwise, just use your best judgment and programming \'courtesy\' towards others who might have to work on your project.Using var instead of explicit type makes refactorings much easier (therefore I must contradict the previous posters who meant it made no difference or it was purely "syntactic sugar").You can change the return type of your methods without changing every file where this method is called. Imaginewhich is used likeIf you wanted to refactor SomeMethod() to return an IEnumerable<MySecondClass>, you would have to change the variable declaration (also inside the foreach) in every place you used the method.If you writeinstead, you don\'t have to change it.@aku: One example is code reviews. Another example is refactoring scenarios.Basically I don\'t want to go type-hunting with my mouse. It might not be available.It\'s a matter of taste. All this fussing about the type of a variable disappears when you get used to dynamically typed languages. That is, if you ever start to like them (I\'m not sure if everybody can, but I do).C#\'s var is pretty cool in that it looks like dynamic typing, but actually is static typing - the compiler enforces correct usage.The type of your variable is not really that important (this has been said before). It should be relatively clear from the context (its interactions with other variables and methods) and its name - don\'t expect customerList to contain an int...I am still waiting to see what my boss thinks of this matter - I got a blanket "go ahead" to use any new constructs in 3.5, but what will we do about maintenance?In your comparison between IEnumerable<int> and IEnumerable<double> you don\'t need to worry - if you pass the wrong type your code won\'t compile anyway.There\'s no concern about type-safety, as var is not dynamic. It\'s just compiler magic and any type unsafe calls you make will get caught. Var is absolutely needed for Linq:Now look at anonEnumeration in intellisense and it will appear something like IEnumerable<\'a>The C# compiler is pretty clever - anon types generated separately will have the same generated type if their properties match.Outside of that, as long as you have intellisense it makes good sense to use var anywhere the context is clear.I guess it depends on your perspective.  I personally have never had any difficulty understanding a piece of code because of var "misuse", and my coworkers and I use it quite a lot all over.  (I agree that Intellisense is a huge aid in this regard.)  I welcome it as a way to remove repetitive cruft.After all, if statements likewere really that impossible to deal with, nobody would use dynamically typed languages.I only use var when it\'s clear to see what type is used.For example, I would use var in this case, because you can see immediately that x will be of the type "MyClass":I would NOT use var in cases like this, because you have to drag the mouse over the code and look at the tooltip to see what type MyFunction returns:Especially, I never use var in cases where the right side is not even a method, but only a value:(because the compiler can\'t know if I want a byte, short, int or whatever)To me, the antipathy towards var illustrates why bilingualism in .NET is important.  To those C# programmers who have also done VB .NET, the advantages of var are intuitively obvious.  The standard C# declaration of:is the equivalent, in VB .NET, of typing this:Nobody does that in VB .NET, though.  It would be silly to, because since the first version of .NET you\'ve been able to do this......which creates the variable and initializes it all in one reasonably compact line.  Ah, but what if you want an IList<string>, not a List<string>?  Well, in VB .NET that means you have to do this:Just like you\'d have to do in C#, and obviously couldn\'t use var for:If you need the type to be something different, it can be.  But one of the basic principles of good programming is reducing redundancy, and that\'s exactly what var does.Use it for anonymous types - that\'s what it\'s there for. Anything else is a use too far. Like many people who grew up on C, I\'m used to looking at the left of the declaration for the type. I don\'t look at the right side unless I have to. Using var for any old declaration makes me do that all the time, which I personally find uncomfortable.Those saying \'it doesn\'t matter, use what you\'re happy with\' are not seeing the whole picture. Everyone will pick up other people\'s code at one point or another and have to deal with whatever decisions they made at the time they wrote it. It\'s bad enough having to deal with radically different naming conventions, or - the classic gripe - bracing styles, without adding the whole \'var or not\' thing into the mix. The worst case will be where one programmer didn\'t use var and then along comes a maintainer who loves it, and extends the code using it. So now you have an unholy mess. Standards are a good thing precisely because they mean you\'re that much more likely to be able to pick up random code and be able to grok it quickly. The more things that are different, the harder that gets. And moving to the \'var everywhere\' style makes a big difference.I don\'t mind dynamic typing, and I don\'t mind implict typing - in languages that are designed for them. I quite like Python. But C# was designed as a statically explicitly-typed language and that\'s how it should stay. Breaking the rules for anonymous types was bad enough; letting people take that still further and break the idioms of the language even more is something I\'m not happy with. Now that the genie is out of the bottle, it\'ll never go back in. C# will become balkanised into camps. Not good.Many time during testing, I find myself having code like this:Now, sometimes, I\'ll want to see what the SomeOtherThing itself contains, SomeOtherThing is not the same type that CallMethod() returns. Since I\'m using var though, I just change this:to this:Without var, I\'d have to keep changing the declared type on the left hand side as well. I know it\'s minor, but it\'s extremely convenient.For the afficionados that think var saves time, it takes less keystrokes to type:thanCount em if you don\'t believe me...19 versus 21I\'ll explain if I have to, but just try it... (depending on the current state of your intellisense you may have to type a couple more for each one)And it\'s true for every type you can think of!!My personal feeling is that var should never be used except where the type is not known because it reduces recognition readabiltiy in code. It takes the brain longer to recognize the type than a full line. Old timers who understand machine code and bits know exactly what I am talking about. The brain processes in parallel and when you use var you force it to serialize its input. Why would anyone want to make their brain work harder? That\'s what computers are for.I split var all over the places, the only questionable places for me are internal short types, e.g. I prefer int i = 3; over var i = 3;It can certainly make things simpler, from code I wrote yesterday:This would have be extremely verbose without var.Addendum: A little time spent with a language with real type inference (e.g. F#) will show just how good compilers are at getting the type of expressions right. It certainly has meant I tend to use var as much as I can, and using an explicit type now indicates that the variable is not of the initialising expression\'s type.None, except that you don\'t have to write the type name twice. http://msdn.microsoft.com/en-us/library/bb383973.aspx