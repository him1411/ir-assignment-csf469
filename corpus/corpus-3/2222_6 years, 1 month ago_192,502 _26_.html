I am going through some blogs on SpringSource and in one of the blog author is using @Inject and I suppose he can also use @AutowiredHere is the piece of code:@Inject private CustomerOrderService customerOrderService;I am not sure about the difference between @Inject and @Autowired and would appreciate if someone can explain the difference and which one to use under what situation?Assuming here you\'re referring to the javax.inject.Inject annotations. @Inject is part of the Java CDI (Contexts and Dependency Injection) standard introduced in Java EE 6 (JSR-299), read more. Spring has chosen to support using @Inject synonymously with their own @Autowired annotation.So, to answer your question, @Autowired is Spring\'s own (legacy) annotation. @Inject is part of a new Java technology called CDI that defines a standard for dependency injection similar to Spring. In a Spring application, the two annotations works the same way as Spring has decided to support some JSR-299 annotations in addition to their own.Here is a blog post that compares @Resource, @Inject, and @Autowired, and appears to do a pretty comprehensive job.From the link:With the exception of test 2 & 7 the configuration and outcomes were\n  identical. When I looked under the hood I determined that the\n  \xe2\x80\x98@Autowired\xe2\x80\x99 and \xe2\x80\x98@Inject\xe2\x80\x99 annotation behave identically. Both of\n  these annotations use the \xe2\x80\x98AutowiredAnnotationBeanPostProcessor\xe2\x80\x99 to\n  inject dependencies. \xe2\x80\x98@Autowired\xe2\x80\x99 and \xe2\x80\x98@Inject\xe2\x80\x99 can be used\n  interchangeable to inject Spring beans. However the \xe2\x80\x98@Resource\xe2\x80\x99\n  annotation uses the \xe2\x80\x98CommonAnnotationBeanPostProcessor\xe2\x80\x99 to inject\n  dependencies. Even though they use different post processor classes\n  they all behave nearly identically. Below is a summary of their\n  execution paths.Tests 2 and 7 that the author references are \'injection by field name\' and \'an attempt at resolving a bean using a bad qualifier\', respectively.The Conclusion should give you all the information you need.To handle the situation in which there is no wiring, beans are available with @Autowired required attribute set to false.But when using @Inject, the Provider interface works with the bean which means that the bean is not injected directly but with the Provider.As of Spring 3.0, Spring offers support for JSR-330 dependency injection annotations (@Inject, @Named, @Singleton).There is a separate section in the Spring documentation about them, including comparisons to their Spring equivalents.The key significant difference(noticed when reading the Spring Docs) between both the @Autowired and @Inject is that, @Autowired has the \'required\' attribute while the @Inject has no \'required\' attribute.@Inject has no \'required\' attribute@Autowired annotation is defined in the Spring framework.@Inject annotation is a standard annotation, which is defined in the standard "Dependency Injection for Java" (JSR-330). Spring (since the version 3.0) supports the a generalized model of dependency injection which is defined in the standard JSR-330. (Google Guice frameworks and Picocontainer framework is also support this model).With @Inject can be injected the reference to the implementation of the  Provider interface, which allows inject the deferred references.Annotations @Inject and @Autowired- is almost complete analogies. As well as @Autowired annotation, @Inject annotation can be used for automatic binding properties, methods, and constructors.In contrast to @Autowired annotation, @Inject annotation has no required attribute. Therefore, if the dependencies will not be found - will be thrown exception.There are also differences in the clarifications of the binding properties. If there is ambiguity in the choice of components for the injection the @Named qualifier should be added. In a similar situation for @Autowired annotation will be added @Qualifier qualifier (JSR-330 defines it\'s own @Qualifier annotation and via this qualifier annotation @Named is defined).In addition to the above:Better use @Inject all the time. Because it is java configuration approach(provided by sun) which makes our application agnostic to the framework. So if you spring also your classes will work.If you use @Autowired it will works only with spring because @Autowired is spring provided annotation.