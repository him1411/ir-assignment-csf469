I\'m building a class library that will have some public & private methods. I want to be able to unit test the private methods (mostly while developing, but also it could be useful for future refactoring).What is the correct way to do this?You should use the InternalsVisibleToAttribute. If you want to unit test a private method, something may be wrong. Unit tests are (generally speaking) meant to test the interface of a class, meaning its public (and protected) methods. You can of course "hack" a solution to this (even if just by making the methods public), but you may also want to consider:It might not be useful to test private methods. However, I also sometimes like to call private methods from test methods. Most of the time in order to prevent code duplication for test data generation...Microsoft provides two mechanisms for this:AccessorsHowever, the mechanism is sometimes a bit intractable when it comes to changes of the interface of the original class. So, most of the times I avoid using this.PrivateObject class\nThe other way is to use Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObjectI don\'t agree with the "you should only be interested in testing the external interface" philosophy.  It\'s a bit like saying that a car repair shop should only have tests to see if the wheels turn.  Yes, ultimately I\'m interested in the external behavior but I like my own, private, internal tests to be a bit more specific and to the point.  Yes, if I refactor, I may have to change some of the tests, but unless it\'s a massive refactor, I\'ll only have to change a few and the fact that the other (unchanged) internal tests still work is a great indicator that the refactoring has been successful.You can try to cover all internal cases using only the public interface and theoretically it\'s possible to test every internal method (or at least every one that matters) entirely by using the public interface but you may have to end up standing on your head to achieve this and the connection between the test cases being run through the public interface and the internal portion of the solution they\'re designed to test may be difficult or impossible to discern.  Having pointed, individual tests that guarantee that the internal machinery is working properly is well worth the minor test changes that come about with refactoring - at least that\'s been my experience.  If you have to make huge changes to your tests for every refactoring, then maybe this doesn\'t make sense, but in that case, maybe you ought to rethink your design entirely.  A good design should be flexible enough to allow for most changes without massive redesigns.  In the rare cases I have wanted to test private functions, I have usually modified them to be protected instead, and the I have written a subclass with a public wrapper function.The Class:Subclass for testing:I think a more fundamental question should be asked is that why are you trying to test the private method in the first place. That is a code smell that you\'re trying to test the private method through that class\' public interface whereas that method is private for a reason as it\'s an implementation detail. One should only be concerned with the behaviour of the public interface not on how it\'s implemented under the covers. If I want to test the behaviour of the private method,  by using common refactorings, I can extract its code into another class (maybe with package level visibility so ensure it\'s not part of a public API). I can then test its behaviour in isolation.The product of the refactoring means that private method is now a separate class that has become a collaborator to the original class. Its behaviour will have become well understood via its own unit tests. I can then mock its behaviour when I try to test the original class so that I can then concentrate on test the behaviour of that class\' public interface rather than having to test a combinatorial explosion of the public interface and the behaviour of all its private methods. I see this analogous to driving a car. When I drive a car I don\'t drive with the bonnet up so I can see that the engine is working. I rely on the interface the car provides, namely the rev counter and the speedometer to  know the engine is working. I rely on the fact that the car actually moves when I press the gas pedal. If I want to test the engine I can do checks on that in isolation. :DOf course testing private methods directly may be a last resort if you have a legacy application but I would prefer that legacy code is refactored to enable better testing. Michael Feathers has written a great book on this very subject. http://www.amazon.co.uk/Working-Effectively-Legacy-Robert-Martin/dp/0131177052Private types, internals and private members are so because of some reason, and often you don\xe2\x80\x99t want to mess with them directly. And if you do, chances are that you\xe2\x80\x99ll break later, because there is no guarantee that the guys who created those assemblies will keep the private/internal implementations as such.But ,at times, when doing some hacks/exploration of compiled or third party assemblies, I have myself ended up wanting to initialize a private class or a class with a private or internal constructor. Or, at times, when dealing with pre-compiled legacy libraries that I can\xe2\x80\x99t change - I end up writing some tests against a private method.Thus born the AccessPrivateWrapper - http://amazedsaint.blogspot.com/2010/05/accessprivatewrapper-c-40-dynamic.html -  it\'s is a quick wrapper class that\xe2\x80\x99ll make the job easy using C# 4.0 dynamic features and reflection.You can create internal/private types likeI\'ve also used the InternalsVisibleToAttribute method. It\'s worth mentioning too that, if you feel uncomfortable making your previously private methods internal in order to achieve this, then maybe they should not be the subject of direct unit tests anyway.After all, you\'re testing the behaviour of your class, rather than it\'s specific implementation - you can change the latter without changing the former and your tests should still pass.Well you can unit test private method in two waysyou can create instance of PrivateObject class the syntax is as followsYou can use reflection.MS Test has a nice feature built in that makes private members and methods available in the project by creating a file called VSCodeGenAccessorsWith classes that derive from BaseAccessorsuch as There are 2 types of private methods. Static Private Methods and Non Static Private methods(Instance Methods). The following 2 articles explain how to unit test private methods with examples.I tend not to use compiler directives because they clutter things up quickly. One way to mitigate it if you really need them is to put them in a partial class and have your build ignore that .cs file when making the production version.On CodeProject, there is an article that briefly discusses pros and cons of testing private methods.  It then provides some reflection code to access private methods (similar to the code Marcus provides above.)  The only issue I\'ve found with the sample is that the code doesn\'t take into account overloaded methods.You can find the article here:http://www.codeproject.com/KB/cs/testnonpublicmembers.aspxDeclare them internal, and then use the InternalsVisibleToAttribute to allow your unit test assembly to see them.Sometimes, it can be good to test private declarations.\nFundamentally, a compiler only has one public method: Compile( string outputFileName, params string[] sourceSFileNames ). I\'m sure you understand that would be difficult to test such a method without testing each "hidden" declarations!That\'s why we have created Visual T#: to make easier tests. It\'s a free .NET programming language (C# v2.0 compatible).We have added \'.-\' operator. It just behave like \'.\' operator, except you can also access any hidden declaration from your tests without changing anything in your tested project.Take a look at our web site: download it for free.You should not be testing the private methods of your code in the first place. You should be testing the \'public interface\' or API, the public things of your classes. The API are all the public methods you expose to outside callers.The reason is that once you start testing the private methods and internals of your class you are coupling the implementation of your class (the private things) to your tests. This means that when you decide to change your implementation details you will also have to change your tests.You should for this reason avoid using InternalsVisibleToAtrribute. Here is a great talk by Ian Cooper which covers this subject: Ian Cooper: TDD, where did it all go wrongMbUnit got a nice wrapper for this called Reflector.  You can also set and get values from propertiesRegarding the "test private" I agree that.. in the perfect world. there is no point in doing private unit tests. But in the real world you might end up wanting to write private tests instead of refactoring code. I\'m surprised nobody has said this yet, but a solution I have employed is to make a static method inside the class to test itself.  This gives you access to everything public and private to test with.Furthermore, in a scripting language (with OO abilities, like Python, Ruby and PHP), you can make the file test itself when run.  Nice quick way of making sure your changes didn\'t break anything.  This obviously makes a scalable solution to testing all your classes:  just run them all.  (you can also do this in other languages with a void main which always runs its tests as well).I want to create a clear code example here which you can use on any class in which you want to test private method. In your test case class just include these methods and then employ them as indicated.$this->_callMethod(\'_someFunctionName\', array(param1,param2,param3));Just issue the parameters in the order that they appear in the original private functionFor anyone who wants to run private methods without all the fess and mess. This works with any unit testing framework using nothing but good old Reflection.Then in your actual tests, you can do something like this:This is a neat way of managing things:http://elegantcode.com/2010/01/28/calling-non-public-methods/And another:http://elegantcode.com/2010/04/16/linfu-duck-typing-part-1-revealing-secrets/Here is good article about unit testing of private methods. But I\'m not sure what\'s better, to make you application designed specially for testing(it\'s like creating tests for testing only) or use reflexion for testing.\nPretty sure most of us will choose second way.You could generate the test method for the private method from Visual studio 2008. When you create a unit test for a private method, a Test References folder is added to your test project and an accessor is added to that folder. The accessor is also referred to in the logic of the unit test method. This accessor allows your unit test to call private methods in the code that you are testing.\nFor details have a look athttp://msdn.microsoft.com/en-us/library/bb385974.aspxAlso note that the InternalsVisibleToAtrribute has a requirement that your assembly be strong named, which creates it\'s own set of problems if you\'re working in a solution that had not had that requirement before.  I use the accessor to test private methods.  See this question that for an example of this.Here\'s an example, first the method signature:Here\'s the test:A way to do this is to have your method protected and write a test fixture which inherits your class to be tested. This way, you are nor turning your method public, but you enable the testing.1) If you have a legacy code then the only way to test private methods is by reflection.2) If it is new code then you have the following options:I prefer the annotation method, simplest and least complicated. The only issue is that we have increased the visibility which I think is not a big concern.\nWe should always be coding to interface, so if we have an interface MyService and an implementation MyServiceImpl then we can have the corresponding test classes that is MyServiceTest (test interface methods) and MyServiceImplTest (test private methods). All clients should anyway be using the interface so in a way even though the visibility of the private method has been increased it should not really matter.You could also declare it as public or internal (with InternalsVisibleToAttribute) while building in debug-Mode:It bloats the code, but it will be private in a release build.In my opinion you should only unit test your classe\'s public API. Making a method public, in order to unit test it, breaks encapsulation exposing implementation details.A good public API solves an immediate goal of the client code and solves that goal completely.