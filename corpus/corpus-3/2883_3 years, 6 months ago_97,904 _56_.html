I want to work with promises but I have a callback API in a format like:Promises have state, they start as pending and can settle to:Promise returning functions should never throw, they should return rejections instead. Throwing from a promise returning function will force you to use both a } catch { and a .catch. People using promisified APIs do not expect promises to throw. If you\'re not sure how async APIs work in JS - please see this answer first.So, creating promises generally means specifying when they settle - that means when they move to the fulfilled or rejected phase to indicate the data is available (and can be accessed with .then).With modern promise implementations that support the Promise constructor like native ES6 promises:You would then use the resulting promise like so:With libraries that support deferred (Let\'s use $q for this example here, but we\'ll also use jQuery later):Or with a jQuery like API, hooking on an event happening once:These APIs are rather common since well... callbacks are common in JS. Let\'s look at the common case of having onSuccess and onFail:With modern promise implementations that support the Promise constructor like native ES6 promises:With libraries that support deferred (Let\'s use jQuery for this example here, but we\'ve also used $q above):jQuery also offers a $.Deferred(fn) form, which has the advantage of allowing us to write an expression that emulates very closely the new Promise(fn) form, as follows:Note: Here we exploit the fact that a jQuery deferred\'s resolve and reject methods are "detachable"; ie. they are bound to the instance of a jQuery.Deferred(). Not all libs offer this feature.Node style callbacks (nodebacks) have a particular format where the callbacks is always the last argument and its first parameter is an error. Let\'s first promisify one manually:To:With deferreds you can do the following (let\'s use Q for this example, although Q now supports the new syntax which you should prefer): In general, you should not promisify things manually too much, most promise libraries that were designed with Node in mind as well as native promises in Node 8+ have a built in method for promisifying nodebacks. For exampleThere is no golden rule here, you promisify them one by one. However, some promise implementations allow you to do this in bulk, for example in Bluebird, converting a nodeback API to a promise API is as simple as:Or with native promises in Node:Notes:I don\'t think the window.onload suggestion by @Benjamin will work all the time, as it doesn\'t detect whether it is called after the load. I have been bitten by that many times. Here is a version which should always work:Today, I can use Promise in Node.js as a plain Javascript method.A simple and basic example to Promise (with a KISS way):Plain Javascript Async API code:Promise Javascript Async API code:(I recommend visiting this beautiful source)Also Promise can be used with together async\\await in ES7 to make the program flow wait for a fullfiled result like the following:Another usage with the same code by using .then() methodHope this helps.You can use JavaScript native promises with Node JS.My Cloud 9 code link: https://ide.c9.io/adx2803/native-promises-in-nodeIn release candidate for Node.js 8.0.0, there\'s a new utility, util.promisify (I\'ve written about util.promisify), that encapsulates the capacity of promisifying whatever function.It is not much different from the approaches suggested in the other answers, but has the advantage of being a core method, and not requiring additional dependencies. Then you\'ve a readFile method that returns a native Promise.The Q library by kriskowal includes callback-to-promise functions.\nA method like this:can be converted with Q.ninvokeWhen you have a few functions that take a callback and you want them to return a promise instead you can use this function to do the conversion.With plain old vanilla javaScript, here\'s a solution to promisify an api callback.Under node v7.6+ which has built in promises and async:How to use:You can use native Promise in ES6, for exemple dealing with setTimeout:In this exemple, the Promise has no reason to fail, so reject() is never called.Node.js 8.0.0 includes a new util.promisify() API that allows standard Node.js callback style APIs to be wrapped in a function that returns a Promise. An example use of util.promisify() is shown below.See Improved support for PromisesBefore converting a function as promise In Node.JSAfter Converting ItIncase you need to handle multiple request The callback style function always like this(almost all function in node.js is this style):This style has same feature: the callback function is passed by last argument. the callback function always accept the error object as it\'s first argument. So, you could write a function for convert a function with this style like this:For more concise, above example used ramda.js. Ramda.js is a excellent library for functional programming. In above code, we used it\'s apply(like javascript function.prototype.apply) and append(like javascript function.prototype.push ).\nSo, we could convert the a callback style function to promise style function now:toPromise and checkErr function is own by berserk library, it\'s a functional programming library fork by ramda.js(create by me).Hope this answer is useful for you.You can use callback2Promise npm package to convert node style functions to Promises.`