I want to take an existing enum and add more elements to it as follows:Is this possible in Java?No, you can\'t do this in Java. Aside from anything else, d would then presumably be an instance of A (given the normal idea of "extends"), but users who only knew about A wouldn\'t know about it - which defeats the point of an enum being a well-known set of values.If you could tell us more about how you want to use this, we could potentially suggest alternative solutions.Enums represent a complete enumeration of possible values. So the (unhelpful) answer is no.As an example of a real problem take weekdays, weekend days and, the union, days of week. We could define all days within days-of-week but then we would not be able to represent properties special to either weekdays and weekend-days.What we could do, is have three enum types with a mapping between weekdays/weekend-days and days-of-week.Alternatively, we could have an open-ended interface for day-of-week:Or we could combine the two approaches:The recommended solution to this is the extensible enum pattern.This involves creating an interface and using that where you currently use the enum. Then make the enum implement the interface. You can add more constants by making that new enum also extend the interface.Under the covers your ENUM is just a regular class generated by the compiler. That generated class extends java.lang.Enum. The technical reason you can\'t extend the generated class is that the generated class is final. The conceptual reasons for it being final are discussed in this topic. But I\'ll add the mechanics to the discussion.Here is a test enum:The resulting code from javap:Conceivably you could type this class on your own and drop the "final". But the compiler prevents you from extending "java.lang.Enum" directly. You could decide NOT to extend java.lang.Enum, but then your class and its derived classes would not be an instanceof java.lang.Enum ... which might not really matter to you any way!can be written as:How it can be useful: Let say we want something like:\nWe have events and we are using enums. Those enums can be grouped by similar processing. If we have operation with many elements, then some events starts operation, some are just step and other end the operation. To gather such operation and avoid long switch case we can group them as in example and use:Example:Add some more advanced:At above if we have some fail (myEvent.is(State_StatusGroup.FAIL)) then iterating by previous events we can easily check if we must revert money transfer by:It can be useful for:Here is a way how I found how to extend a enum into other enum, is a very straighfoward approach:Suposse you have a enum with common constants:then you can try to do a manual extends in this way:of course every time you need to extend a constant you have to modify your SubEnum files.In case you missed it, there\'s a chapter in the excellent Joshua Bloch\'s book "Java Effective, 2nd edition".Extract here.Just the conclusion :A minor disadvantage of the use of interfaces to emulate extensible enums is\n  that implementations cannot be inherited from one enum type to another. In the\n  case of our Operation example, the logic to store and retrieve the symbol associated\n  with an operation is duplicated in BasicOperation and ExtendedOperation.\n  In this case it doesn\xe2\x80\x99t matter because very little code is duplicated. If there were a\n  larger amount of shared functionality, you could encapsulate it in a helper class or\n  a static helper method to eliminate the code duplication.  In summary, while you cannot write an extensible enum type, you can\n  emulate it by writing an interface to go with a basic enum type that implements\n  the interface. This allows clients to write their own enums that implement\n  the interface. These enums can then be used wherever the basic enum type can be\n  used, assuming APIs are written in terms of the interface.I tend to avoid enums, because they are not extensible. To stay with the example of the OP, if A is in a library and B in your own code, you can\'t extend A if it is an enum. This is how I sometimes replace enums:There are some pits to avoid, see the comments in the code. Depending on your needs, this is a solid, extensible alternative to enums.This is how I enhance the enum inheritance pattern with runtime check in static initializer.\nThe BaseKind#checkEnumExtender checks that "extending" enum declares all the values of the base enum in exactly the same way so #name() and #ordinal() remain fully compatible.There is still copy-paste involved for declaring values but the program fails fast if somebody added or modified a value in the base class without updating extending ones.Common behavior for different enums extending each other:Base enum, with verifying method:Extension sample:Having had this same problem myself I\'d like to post my perspective. I think that there are a couple motivating factors for doing something like this:Using an interface doesn\'t really cut it: you can accidentally get duplicate enum values. Not desirable.I ended up just combining the enums: this ensures that there cannot be any duplicate values, at the expense of being less tightly tied to its associated class. But, I figured the duplicate issue was my main concern...As an aid to understanding why extending an Enum is not reasonable at the language implementation level consider what would happen if you passed an instance of the extended Enum to a routine that only understands the base Enum. A switch that the compiler promised had all cases covered would in fact not cover those extended Enum values. This further emphasizes that Java Enum values are not integers such as C\'s are, for instances: to use a java Enum as an array index you must explicitly ask for its ordinal() member, to give a java Enum an arbitrary integral value you must add an explicit field for that and reference that named member.This is not a comment on the OP\'s desire, just on why Java ain\'t never going to do it.Based on @Tom Hawtin - tackline answer we add switch support,My way to code that would be as follows:LinkedHashSet provides both that each entry only exists once, and that their order is preserved. If order doesn\xe2\x80\x99t matter, you can use HashSet instead. The following code is not possible in Java:The code can be written as follows:From Java 7 onwards you can even do the same with String:Using the enum replacement:In the hopes this elegant solution of a colleague of mine is even seen in this long post I\'d like to share this approach for subclassing which follows the interface approach and beyond.Please be aware that we use custom exceptions here and this code won\'t compile unless you replace it with your exceptions.The documentation is extensive and I hope it\'s understandable for most of you.The interface that every subclassed enum needs to implement.The implementing ENUM base class.The subclassed ENUM which "inherits" from base class.Finally the generic ParameterImpl to add some utilities.I suggest you take the other way around approach.  Instead of extending the existing enumeration, create a larger one and create a subset of it.\nFor exemple if you had an enumeration called PET and you wanted to extend it to ANIMAL you should do this instead: Be careful, pets is not an immutable collections, you might want to use Guava or Java9 for more safety.