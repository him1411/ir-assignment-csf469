What is the difference between undefined, unspecified, and implementation-defined behavior in C and C++?Undefined behavior is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!Let\'s look at a classic example:The variable p points to the string literal "hello!\\n", and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes undefined behavior:The effect of attempting to modify a string literal is undefined.I can hear people screaming "But wait, I can compile this no problem and get the output yellow" or "What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump". This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a "correct" behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.Other examples of undefined behavior include accessing an array beyond its bounds, dereferencing the null pointer, accessing objects after their lifetime ended or writing allegedly clever expressions like i++ + ++i.Section 1.9 of the C++ standard also mentions undefined behavior\'s two less dangerous brothers, unspecified behavior and implementation-defined behavior:The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.Certain aspects and operations of the abstract machine are described in this International Standard as implementation-defined (for example, sizeof(int)). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.Certain other aspects and operations of the abstract machine are described in this International Standard as unspecified (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.Certain other operations are described in this International Standard as undefined (for example, the  effect of dereferencing the null pointer). [ Note: this International Standard imposes no requirements on the behavior of programs that contain undefined behavior. \xe2\x80\x94end note ]Specifically, section 1.3.24 states:Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).What can you do to avoid running into undefined behavior? Basically, you have to read good C++ books by authors who know what they\'re talking about. Screw internet tutorials. Screw bullschildt.Well, this is basically a straight copy-paste from the standard3.4.1 1 implementation-defined behavior unspecified behavior where\n  each implementation documents how the\n  choice is made 2 EXAMPLE An example of\n  implementation-defined behavior is the\n  propagation of the high-order bit when\n  a signed integer is shifted right.3.4.3 1 undefined behavior behavior, upon use of a nonportable or erroneous\n  program construct or of erroneous\n  data, for which this International\n  Standard imposes no requirements 2\n  NOTE Possible undefined behavior\n  ranges from ignoring the situation\n  completely with unpredictable results,\n  to behaving during translation or\n  program execution in a documented\n  manner characteristic of the\n  environment (with or without the\n  issuance of a diagnostic message), to\n  terminating a translation or execution\n  (with the issuance of a diagnostic\n  message).3 EXAMPLE An example of\n  undefined behavior is the behavior on\n  integer overflow.3.4.4 1 unspecified behavior use of an unspecified value, or other behavior\n  where this International Standard\n  provides two or more possibilities and\n  imposes no further requirements on\n  which is chosen in any instance 2\n  EXAMPLE An example of unspecified\n  behavior is the order in which the\n  arguments to a function are evaluated.Maybe easy wording could be easier for understanding than the rigorous definition of the standards.implementation-defined behavior\nThe language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.undefined behavior\nYou are doing something wrong. For example, you have a very large value in an int that doesn\'t fit in char. How do you put that value in char? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in char. It is just wrong to do that to assign the first byte, but thats what happens under the hood.unspecified behavior\nWhich function of these two is executed first?The language doesn\'t specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn\'t result in an undefined behavior, but certainly your program should not produce an unspecified behavior.@eSKay I think your question is worth editing the answer to clarify more :)for fun(fun1(), fun2()); isn\'t the\n  behaviour "implementation defined"?\n  The compiler has to choose one or the\n  other course, after all?The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn\'t have to in the second case. For example, an implementation must have one and only one definition of sizeof(int). So, it can\'t say that sizeof(int) is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function\'s arguments are evaluated right-to-left. It can happen in the same program, that\'s why it is called unspecified. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at Dr. Stroustrup\'s answer for that:It is claimed that the difference\n  between what can be produced giving\n  the compiler this freedom and\n  requiring "ordinary left-to-right\n  evaluation" can be significant. I\'m\n  unconvinced, but with innumerable\n  compilers "out there" taking advantage\n  of the freedom and some people\n  passionately defending that freedom, a\n  change would be difficult and could\n  take decades to penetrate to the\n  distant corners of the C and C++\n  worlds. I am disappointed that not all\n  compilers warn against code such as\n  ++i+i++. Similarly, the order of evaluation of arguments is\n  unspecified.IMO far too many "things" are left\n  undefined, unspecified,\n  implementation-defined, etc. However,\n  that\'s easy to say and even to give\n  examples of, but hard to fix. It\n  should also be noted that it is not\n  all that difficult to avoid most of\n  the problems and produce portable\n  code.From the official C Rationale DocumentThe terms unspecified behavior, undefined behavior, and implementation-defined behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. Unspecified behavior gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. Undefined behavior gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. Implementation-defined behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. Undefined Behavior vs. Unspecified Behavior has a short description of it.Their final summary:To sum up, unspecified behavior is usually something you shouldn\'t\n  worry about, unless your software is required to be portable.\n  Conversely, undefined behavior is always undesirable and should never\n  occur.Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that\'s useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose whether the Standard requires it or not.The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior even in cases where nothing the implementation could possibly do would be useful.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but whether there might be implementations where defining a behavior would be simultaneously costly and useless.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren\'t worth the cost even in application fields where they\'re vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse not to do so.For example, given the following code:a two\'s-complement implementation would not have to expend any effort\nwhatsoever to treat the expression v << pow as a two\'s-complement shift\nwithout regard for whether v was positive or negative.The preferred philosophy among some of today\'s compiler writers, however, would suggest that because v can only be negative if the program is going to engage in Undefined Behavior, there\'s no reason to have the program clip the negative range of v.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.Implementation defined- Implementors wish,should be well documented,standard gives choices but sure to compileUnspecified -Same as implementation-defined but not documentedUndefined-Anything might happen,take care of it.C++ standard n3337  \xc2\xa7 1.3.10\nimplementation-defined behaviorbehavior, for a well-formed program construct and correct data, that\n  depends on the implementation and that each implementation documentsSometimes C++ Standard doesn\'t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and described by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn\'t describe this. C++ standard n3337  \xc2\xa7 1.3.24\nundefined behaviorbehavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed. \xe2\x80\x94 end note ]When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). C++ standard n3337  \xc2\xa7 1.3.25\nunspecified behaviorbehavior, for a well-formed program construct and correct data, that\n  depends on the implementation [ Note: The implementation is not\n  required to document which behavior occurs. The range of possible\n  behaviors is usually delineated by this International Standard. \xe2\x80\x94 end\n  note ]C++ Standard doesn\'t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( bot not necessary described) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.