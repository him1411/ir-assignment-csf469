I found this code in a RailsCast:What does the (&:name) in map(&:name) mean?It\'s shorthand for tags.map(&:name.to_proc).join(\' \')If foo is an object with a to_proc method, then you can pass it to a method as &foo, which will call foo.to_proc and use that as the method\'s block.The Symbol#to_proc method was originally added by ActiveSupport but has been integrated into Ruby 1.8.7. This is its implementation:Another cool shorthand, unknown to many, iswhich is a shorthand for By calling method(:foo) we took a Method object from self that represents its foo method, and used the & to signify that it has a to_proc method that converts it into a Proc.This is very useful when you want to do things point-free style. An example is to check if there is any string in an array that is equal to the string "foo". There is the conventional way:And there is the point-free way:The preferred way should be the most readable one.It\'s equivalent toWhile let us also note that ampersand #to_proc magic can work with any class, not just Symbol. Many Rubyists choose to define #to_proc on Array class:Ampersand & works by sending to_proc message on its operand, which, in the above code, is of Array class. And since I defined #to_proc method on Array, the line becomes:It\'s shorthand for tags.map { |tag| tag.name }.join(\' \')Josh Lee\'s answer is almost correct except that the equivalent Ruby code should have been as follows. notWith this code, when print [[1,\'a\'],[2,\'b\'],[3,\'c\']].map(&:first) is executed, Ruby splits the first input [1,\'a\'] into 1 and \'a\' to give obj 1 and args* \'a\' to cause an error as Fixnum object 1 does not have the method self (which is :first). When [[1,\'a\'],[2,\'b\'],[3,\'c\']].map(&:first) is executed;:first is a Symbol object, so when &:first is given to a map method as a parameter, Symbol#to_proc is invoked.map sends call message to :first.to_proc with parameter [1,\'a\'], e.g., :first.to_proc.call([1,\'a\']) is executed. to_proc procedure in Symbol class sends a send message to an array object ([1,\'a\']) with parameter (:first), e.g., [1,\'a\'].send(:first) is executed.iterates over the rest of the elements in [[1,\'a\'],[2,\'b\'],[3,\'c\']] object.This is the same as executing [[1,\'a\'],[2,\'b\'],[3,\'c\']].map(|e| e.first) expression.is The same as&:name just uses the symbol as the method name to be called.Two things are happening here, and it\'s important to understand both.As described in other answers, the Symbol#to_proc method is being called.But the reason to_proc is being called on the symbol is because it\'s being passed to map as a block argument. Placing & in front of an argument in a method call causes it to be passed this way. This is true for any Ruby method, not just map with symbols.The Symbol gets converted to a Proc because it\'s passed in as a block. We can show this by trying to pass a proc to .map without the ampersand: Even though it doesn\'t need to be converted, the method won\'t know how to use it because it expects a block argument. Passing it with & gives .map the block it expects.(&:name) is short for (&:name.to_proc) it\ni t is same as tags.map{ |t| t.name }.join(\' \')to_proc is actually implemented in CIt is same as below:Here :name is the symbol which point to the method name of tag object.\nWhen we pass &:name to map, it will treat name as a proc object. \nFor short, tags.map(&:name) acts as: it means