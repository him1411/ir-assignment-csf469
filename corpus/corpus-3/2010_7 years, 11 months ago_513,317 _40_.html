I notice that a pre-increment/decrement operator can be applied on a variable (like ++count). It compiles, but it does not actually change the value of the variable!What is the behavior of the pre-increment/decrement operators (++/--) in Python? Why does Python deviate from the behavior of these operators seen in C/C++?++ is not an operator. It is two + operators. The + operator is the identity operator, which does nothing. (Clarification: the + and - unary operators only work on numbers, but I presume that you wouldn\'t expect a hypothetical ++ operator to work on strings.)Parses asWhich translates toYou have to use the slightly longer += operator to do what you want to do:I suspect the ++ and -- operators were left out for consistency and simplicity. I don\'t know the exact argument Guido van Rossum gave for the decision, but I can imagine a few arguments:When you want to increment or decrement, you typically want to do that on an integer. Like so:But in Python, integers are immutable. That is you can\'t change them. This is because the integer objects can be used under several names. Try this:a and b above are actually the same object. If you incremented a, you would also increment b. That\'s not what you want. So you have to reassign. Like this:Or simpler:Which will reassign b to b+1. That is not an increment operator, because it does not increment b, it reassigns it.In short: Python behaves differently here, because it is not C, and is not a low level wrapper around machine code, but a high-level dynamic language, where increments don\'t make sense, and also are not as necessary as in C, where you use them every time you have a loop, for example.While the others answers are correct in so far as they show what a mere + usually does (namely, leave the number as it is, if it is one), they are incomplete in so far as they don\'t explain what happens.To be exact, +x evaluates to x.__pos__() and ++x to x.__pos__().__pos__().I could imagine a VERY weird class structure (Children, don\'t do this at home!) like this:In Python, a distinction between expressions and statements is rigidly\n  enforced, in contrast to languages such as Common Lisp, Scheme, or\n  Ruby.WikipediaSo by introducing such operators, you would break the expression/statement split. For the same reason you can\'t writeas you can in some other languages where such distinction is not preserved.Python does not have these operators, but if you really need them you can write a function having the same functionality.Usage:Inside a function you have to add locals() as a second argument if you want to change local variable, otherwise it will try to change global.Also with these functions you can do:But in my opinion following approach is much clearer:Decrement operators:I used these functions in my module translating javascript to python.Yeah, I missed ++ and -- functionality as well. A few million lines of c code engrained that kind of thinking in my old head, and rather than fight it... Here\'s a class I cobbled up that implements:Here \'tis:You might use it like this:...already having c, you could do this.......or just......and for (re-)assignment into integer......while this will maintain c as type counter:EDIT:And then there\'s this bit of unexpected (and thoroughly unwanted) behavior,...because inside that tuple, getitem() isn\'t what used, instead a reference to the object is passed to the formatting function. Sigh. So:...or, more verbosely, and explicitly what we actually wanted to happen, although counter-indicated in actual form by the verbosity (use c.v instead)...