Is there a C# official guideline for the order of items in terms of class structure?Does it go:I\'m curious if there is a hard and fast rule about the order of items? I\'m kind of all over the place. I want to stick with a particular standard so I can do it everywhere.The real problem is my more complex properties end up looking a lot like methods and they feel out of place at the top before the constructor.Any tips/suggestions?According to the StyleCop  Rules Documentation the ordering is as follows.Within a class, struct or interface: (SA1201 and SA1203)Within each of these groups order by access: (SA1202)Within each of the access groups, order by static, then non-static: (SA1204)Within each of the static/non-static groups of fields,  order by readonly, then non-readonly : (SA1214 and SA1215)An unrolled list is 130 lines long, so I won\'t unroll it here. The methods part unrolled is:The documentation notes that if the prescribed order isn\'t suitable - say, multiple interfaces are being implemented, and the interface methods and properties should be grouped together - then use a partial class to group the related methods and properties together.Rather than grouping by visibility or by type of item (field, property, method, etc.), how about grouping by functionality?I would recommend using the coding standards from IDesign or the ones listed on Brad Abram\'s website. Those are the best two that I have found.Brad would say... Classes member should be alphabetized, and grouped into sections (Fields, Constructors, Properties, Events, Methods, Private interface implementations, Nested types)This is an old but still very relevant question, so I\'ll add this: What\'s the first thing you look for when you open up a class file that you may or may not have read before? Fields? Properties? I\'ve realized from experience that almost invariably I go hunting for the constructors, because the most basic thing to understand is how this object is constructed.Therefore, I\'ve started putting constructors first in class files, and the result has been psychologically very positive. The standard recommendation of putting constructors after a bunch of other things feels dissonant.The upcoming primary constructor feature in C# 6 provides evidence that the natural place for a constructor is at the very top of a class - in fact primary constructors are specified even before the open brace.It\'s funny how much of a difference a reordering like this makes. It reminds me of how using statements used to be ordered - with the System namespaces first. Visual Studio\'s "Organize Usings" command used this order. Now usings are just ordered alphabetically, with no special treatment given to System namespaces. The result just feels simpler and cleaner.I don\'t know about a language or industry standard, but I tend to put things in this order with each section wrapped in a #region:using StatementsNamespaceClassPrivate membersPublic propertiesConstructorsPublic methodsPrivate methodsAs mentioned before there is nothing in the C# language that dictates the layout, I personally use regions, and I do something like this for an average class.It makes sense to me anywayFrom StyleCopprivate fields, public fields, constructors, properties, public methods, private methodsAs StyleCop is part of the MS build process you could view that as a de facto standardUsually I try to follow the next pattern:Each part (static and instance) consists of the following member types:Then the members are sorted by visibility (from less to more visible):The order is not a dogma: simple classes are easier to read, however, more complex classes need context-specific grouping.The closest you\'re likely to find is "Design Guidelines, Managed code and the .NET Framework" (http://blogs.msdn.com/brada/articles/361363.aspx) by Brad Abrams Many standards are outlined here. The relevant section is 2.8 I think.My preference is to order by kind and then be decreasing visibility as followsI know this violates Style Cop and if someone can give me a good reason why I should place the implementation details of a type before its interface I am willing to change. At present, I have a strong preference for putting private members last.Note: I don\'t use public or protected fields.the only coding guidelines I\'ve seen suggested for this is to put fields at the top of the class definition.i tend to put constructors next.my general comment would be that you should stick to one class per file and if the class is big enough that the organization of properties versus methods is a big concern, how big is the class and should you be refactoring it anyway? does it represent multiple concerns?I prefer to put the private fields up at the top along with the constructor(s), then put the public interface bits after that, then the private interface bits.Also, if your class definition is long enough for the ordering of items to matter much, that\'s probably a code smell indicating your class is too bulky and complex and you should refactor.There certainly is nothing in the language that enforces it in any way. I tend to group things by visibility (public, then protected, then private) and use #regions to group related things functionally, regardless of whether it is a property, method, or whatever. Construction methods (whether actual ctors or static factory functions) are usually right at the top since they are the first thing clients need to know about.I keep it as simple as possible (for me at least)Enumerations\nDeclarations\nConstructors\nOverrides\nMethods\nProperties\nEvent HandlerOrder things where they feel clean to you and whoever maintains the code. Everyone usually has some degree of personal preference.I don\'t think it\'s necessary to force a particular style or ordering into a class.It completely depends on you. You must be agree on some standards. even a bad standard.\nBut It is better to follow a good standard :)