I want to write a function that takes an array of letters as an argument and a number of those letters to select. Say you provide an array of 8 letters and want to select 3 letters from that. Then you should get:Arrays (or words) in return consisting of 3 letters each.Art of Computer Programming Volume 4: Fascicle 3 has a ton of these that might fit your particular situation better than how I describe.An issue that you will come across is of course memory and pretty quickly, you\'ll have problems by 20 elements in your set -- 20C3 = 1140. And if you want to iterate over the set it\'s best to use a modified gray code algorithm so you aren\'t holding all of them in memory. These generate the next combination from the previous and avoid repetitions. There are many of these for different uses. Do we want to maximize the differences between successive combinations? minimize? et cetera.Some of the original papers describing gray codes: Here are some other papers covering the topic:Phillip J Chase, `Algorithm 382: Combinations of M out of N Objects\' (1970)The algorithm in C...You can also reference a combination by its index (in lexicographical order).  Realising that the index should be some amount of change from right to left based on the index we can construct something that should recover a combination.So, we have a set {1,2,3,4,5,6}... and we want three elements. Let\'s say {1,2,3} we can say that the difference between the elements is one and in order and minimal. {1,2,4} has one change, and is lexicographically number 2. So the number of \'changes\' in the last place accounts for one change in the lexicographical ordering. The second place, with one change {1,3,4} has one change, but accounts for more change since it\'s in the second place (proportional to the number of elements in the original set).The method I\'ve described is a deconstruction, as it seems, from set to the index, we need to do the reverse --which is much trickier. This is how Buckles solves the problem. I wrote some C to compute them, with minor changes --I used the index of the sets rather than a number range to represent the set, so we are always working from 0...n.\nNote:There is another way:, its concept is easier to grasp and program but it\'s without the optimizations of Buckles. Fortunately, it also does not produce duplicate combinations:The set  that maximizes , where .For an example: 27 = C(6,4) + C(5,3) + C(2,2) + C(1,1). So, the 27th lexicographical combination of four things is: {1,2,5,6}, those are the indexes of whatever set you want to look at. Example below (OCaml), requires choose function, left to reader:\nIn C#:Usage:Result:\nMay I present my recursive Python solution to this problem? Example usage:I like it for its simplicity.\nShort java solution:Result will beLets say your array of letters looks like this: "ABCDEFGH". You have three indices (i, j, k) indicating which letters you are going to use for the current word, You start with:First you vary k, so the next step looks like that:If you reached the end you go on and vary j and then k again.Once you j reached G you start also to vary i.Written in code this look something like thatThe following recursive algorithm picks all of the k-element combinations from an ordered set:Iterate the above for each i in the set.It is essential that you pick the rest of the elements as larger than i, to avoid repetition. This way [3,5] will be picked only once, as [3] combined with [5], instead of twice (the condition eliminates [5] + [3]). Without this condition you get variations instead of combinations.\nI found this thread useful and thought I would add a Javascript solution that you can pop into Firebug.  Depending on your JS engine, it could take a little time if the starting string is large.The output should be as follows:\nIn C++ the following routine will produce all combinations of length distance(first,k) between the range  [first,last):It can be used like this:This will print the following:\nShort example in Python:For explanation, the recursive method is described with the following example: Example: A B C D E\nAll combinations of 3 would be:\nSimple recursive algorithm in HaskellWe first define the special case, i.e. selecting zero elements. It produces a single result, which is an empty list (i.e. a list that contains an empty list).For n > 0, x goes through every element of the list and xs is every element after x.rest picks n - 1 elements from xs using a recursive call to combinations. The final result of the function is a list where each element is x : rest (i.e. a list which has x as head and rest as tail) for every different value of x and rest.And of course, since Haskell is lazy, the list is gradually generated as needed, so you can partially evaluate exponentially large combinations.of groups of four. When idx4 comes to the end of the array, we increment idx3 by 1 and set idx4 to idx3+1. Then we run idx4 to the end again.  We proceed in this manner, augmenting idx3,idx2, and idx1 respectively until the position of idx1 is less than 4 from the end of the array.  That finishes the algorithm.\nHere is an elegant, generic implementation in Scala, as described on 99 Scala Problems.If you can use SQL syntax - say, if you\'re using LINQ to access fields of an structure or array, or directly accessing a database that has a table called "Alphabet" with just one char field "Letter", you can adapt following code:This will return all combinations of 3 letters, notwithstanding how many letters you have in table "Alphabet" (it can be 3, 8, 10, 27, etc.).If what you want is all permutations, rather than combinations (i.e. you want "ACB" and "ABC" to count as different, rather than appear just once) just delete the last line (the AND one) and it\'s done.Post-Edit: After re-reading the question, I realise what\'s needed is the general algorithm, not just a specific one for the case of selecting 3 items. Adam Hughes\' answer is the complete one, unfortunately I cannot vote it up (yet). This answer\'s simple but works only for when you want exactly 3 items.\nHere you have a lazy evaluated version of that algorithm coded in C#:And test part:Hope this help you!https://gist.github.com/3118596There is an implementation for JavaScript. It has functions to get k-combinations and all combinations of an array of any objects. Examples:\nI had a permutation algorithm I used for project euler, in python:If you should have all combination you need without repetition, do you need it?It is a generator, so you use it in something like this:Another C# version with lazy generation of the combination indices. This version maintains a single array of indices to define a mapping between the list of all values and the values for the current combination, i.e. constantly uses O(k) additional space during the entire runtime. The code generates individual combinations, including the first one, in O(k) time.Test code:Output:I created a solution in SQL Server 2005 for this, and posted it on my website: http://www.jessemclain.com/downloads/code/sql/fn_GetMChooseNCombos.sql.htmHere is an example to show usage:results:\nHere is my proposition in C++I tried to impose as little restriction on the iterator type as i could so this solution assumes just forward iterator, and it can be a const_iterator. This should work with any standard container. In cases where arguments don\'t make sense it throws std::invalid_argumnent\nAll said and and done here comes the O\'caml code for that.\nAlgorithm is evident from the code..Clojure version:\nHere is a code I recently wrote in Java, which calculates and returns all the combination of "num" elements from "outOf" elements.\nA concise Javascript solution:\nHere is a method which gives you all combinations of specified size from a random length string. Similar to quinmars\' solution, but works for varied input and k.The code can be changed to wrap around, ie \'dab\' from input \'abcd\' w k=3.Output for "abcde": abc abd abe acd ace ade bcd bce bde cdeI have written a class to handle common functions for working with the binomial coefficient, which is the type of problem that your problem falls under.  It performs the following tasks:Outputs all the K-indexes in a nice format for any N choose K to a file.  The K-indexes can be substituted with more descriptive strings or letters.  This method makes solving this type of problem quite trivial.Converts the K-indexes to the proper index of an entry in the sorted binomial coefficient table.  This technique is much faster than older published techniques that rely on iteration.  It does this by using a mathematical property inherent in Pascal\'s Triangle.  My paper talks about this.  I believe I am the first to discover and publish this technique, but I could be wrong.Converts the index in a sorted binomial coefficient table to the corresponding K-indexes.Uses Mark Dominus method to calculate the binomial coefficient, which is much less likely to overflow and works with larger numbers.The class is written in .NET C# and provides a way to manage the objects related to the problem (if any) by using a generic list.  The constructor of this class takes a bool value called InitTable that when true will create a generic list to hold the objects to be managed.  If this value is false, then it will not create the table.  The table does not need to be created in order to perform the 4 above methods.  Accessor methods are provided to access the table.There is an associated test class which shows how to use the class and its methods.  It has been extensively tested with 2 cases and there are no known bugs.To read about this class and download the code, see Tablizing The Binomial Coeffieicent.It should not be hard to convert this class to C++.Here\'s my JavaScript solution that is a little more functional through use of reduce/map, which eliminates almost all variables\nJumping on the bandwagon, and posting another solution. This is a generic Java implementation. Input: (int k) is number of elements to choose and (List<T> list) is the list to choose from. Returns a list of combinations (List<List<T>>).\nAnd here\'s a Clojure version that uses the same algorithm I describe in my OCaml implementation answer:It provides three ways to call it:(a) for exactly n selected items as the question demands:(b) for between n1 and n2 selected items:(c) for between 0 and the size of the collection selected items: