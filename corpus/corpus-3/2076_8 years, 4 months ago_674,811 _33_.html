How do I convert a java.io.File to a byte[]?It depends on what best means for you. Productivity wise, don\'t reinvent the wheel and use Apache Commons. Which is here IOUtils.toByteArray(InputStream input).From JDK 7 you can use Files.readAllBytes(Path).Example:Documentation for Java 8: http://docs.oracle.com/javase/8/docs/api/java/io/RandomAccessFile.htmlSince JDK 7 - one liner:No external dependencies needed.Basically you have to read it in memory. Open the file, allocate the array, and read the contents from the file into the array. The simplest way is something similar to this: This has some unnecessary copying of the file content (actually the data is copied three times: from file to buffer, from buffer to ByteArrayOutputStream, from ByteArrayOutputStream to the actual resulting array).You also need to make sure you read in memory only files up to a certain size (this is usually application dependent) :-). You also need to treat the IOException outside the function.Another way is this: This has no unnecessary copying.FileTooBigException is a custom application exception. \nThe MAX_FILE_SIZE constant is an application parameters.For big files you should probably think a stream processing algorithm or use memory mapping (see java.nio). As someone said, Apache Commons File Utils might have what you are looking forExample use (Program.java):You can use the NIO api as well to do it. I could do this with this code as long as the total file size (in bytes) would fit in an int.I think its very fast since its using MappedByteBuffer.Guava has Files.toByteArray() to offer you. It has several advantages:Simplest Way for reading bytes from fileIf you don\'t have Java 8, and agree with me that including a massive library to avoid writing a few lines of code is a bad idea:Caller is responsible for closing the stream.Using the same approach as the community wiki answer, but cleaner and compiling out of the box (preferred approach if you don\'t want to import Apache Commons libs, e.g. on Android):I belive this is the easiest way:ReadFully Reads b.length bytes from this file into the byte array, starting at the current file pointer. This method reads repeatedly from the file until the requested number of bytes are read. This method blocks until the requested number of bytes are read, the end of the stream is detected, or an exception is thrown.Simple way to do it:Let me add another solution without using third-party libraries. It re-uses an exception handling pattern that was proposed by Scott (link). And I moved the ugly part into a separate message (I would hide in some FileUtils class ;) )If you want to read bytes into a pre-allocated byte buffer, this answer may help.Your first guess would probably be to use InputStream read(byte[]). However, this method has a flaw that makes it unreasonably hard to use: there is no guarantee that the array will actually be completely filled, even if no EOF is encountered.Instead, take a look at DataInputStream readFully(byte[]). This is a wrapper for input streams, and does not have the above mentioned issue. Additionally, this method throws when EOF is encountered. Much nicer.Another Way for reading bytes from file