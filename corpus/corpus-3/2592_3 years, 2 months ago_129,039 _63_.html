When writing an Angular directive, one can use any of the following functions to manipulate the DOM behaviour, contents and look of the element on which the directive is declared:There seem to be some confusion as for which function should one use. This question covers:Based on the following plunk, consider the following HTML markup:With the following directive declaration:The console output will be:We can see that compile is executed first, then controller, then pre-link and last is post-link.Note: The following does not apply to directives that render their children in their link function. Quite a few Angular directives do so (like ngIf, ngRepeat, or any directive with transclude). These directives will natively have their link function called before their child directives compile is called.The original HTML markup is often made of nested elements, each with its own directive. Like in the following markup (see plunk):The console output will look like this:We can distinguish two phases here - the compile phase and the link phase.When the DOM is loaded Angular starts the compile phase, where it traverses the markup top-down, and calls compile on all directives. Graphically, we could express it like so:It is perhaps important to mention that at this stage, the templates the compile function gets are the source templates (not instance template).DOM instances are often simply the result of a source template being rendered to the DOM, but they may be created by ng-repeat, or introduced on the fly.Whenever a new instance of an element with a directive is rendered to the DOM, the link phase starts.In this phase, Angular calls controller, pre-link, iterates children, and call post-link on all directives, like so:The various directive functions are executed from within two other angular functions called $compile (where the directive\'s compile is executed) and an internal function called nodeLinkFn (where the directive\'s controller, preLink and postLink are executed). Various things happen within the angular function before and after the directive functions are called. Perhaps most notably is the child recursion. The following simplified illustration shows key steps within the compile and link phases:To demonstrate the these steps, let\'s use the following HTML markup:With the following directive:The compile API looks like so:Often the parameters are prefixed with t to signify the elements and attributes provided are those of the source template, rather than that of the instance.Prior to the call to compile transcluded content (if any) is removed, and the template is applied to the markup. Thus, the element provided to the compile function will look like so:Notice that the transcluded content is not re-inserted at this point.Following the call to the directive\'s .compile, Angular will traverse all child elements, including those that may have just been introduced by the directive (the template elements, for instance).In our case, three instances of the source template above will be created (by ng-repeat). Thus, the following sequence will execute three times, once per instance.The controller API involves:Entering the link phase, the link function returned via $compile is now provided with a scope.First, the link function create a child scope (scope: true) or an isolated scope (scope: {...}) if requested.The controller is then executed, provided with the scope of the instance element.The pre-link API looks like so:Virtually nothing happens between the call to the directive\'s .controller and the .preLink function. Angular still provide recommendation as to how each should be used.Following the .preLink call, the link function will traverse each child element - calling the correct link function and attaching to it the current scope (which serves as the parent scope for child elements).The post-link API is similar to that of the pre-link function:Perhaps worth noticing that once a directive\'s .postLink function is called, the link process of all its children elements has completed, including all the children\'s .postLink functions.This means that by the time .postLink is called, the children are \'live\' are ready. This includes:The template at this stage will thus look like so:If one is to use all four function, the directive will follow this form:Notice that compile returns an object containing both the pre-link and post-link functions; in Angular lingo we say the compile function returns a template function.If pre-link isn\'t necessary, the compile function can simply return the post-link function instead of a definition object, like so:Sometimes, one wishes to add a compile method, after the (post) link method was defined. For this, one can use:If no compile function is needed, one can skip its declaration altogether and provide the post-link function under the link property of the directive\'s configuration object:In any of the examples above, one can simply remove the controller function if not needed. So for instance, if only post-link function is needed, one can use:The fact that Angular allows DOM manipulation means that the input markup into the compilation process sometimes differ from the output. Particularly, some input markup may be cloned a few times (like with ng-repeat) before being rendered to the DOM. Angular terminology is a bit inconsistent, but it still distinguishes between two types of markups:The following markup demonstrates this:The source html defineswhich serves as the source template.But as it is wrapped within an ng-repeat directive, this source template will be cloned (3 times in our case). These clones are instance template, each will appear in the DOM and be bound to the relevant scope.Each directive\'s compile function is only called once, when Angular bootstraps.Officially, this is the place to perform (source) template manipulations that do not involve scope or data binding.Primarily, this is done for optimisation purposes; consider the following markup:The <my-raw> directive will render a particular set of DOM markup. So we can either:If there are 1000 items in the raws collection, the latter option may be faster than the former one.When the post-link function is called, all previous steps have taken place - binding, transclusion, etc.This is typically a place to further manipulate the rendered DOM.Each directive\'s controller function is called whenever a new related element is instantiated.Officially, the controller function is where one:Again, it is important to remember that if the directive involves an isolated scope, any properties within it that inherit from the parent scope are not yet available.Each directive\'s pre-link function is called whenever a new related element is instantiated.As seen previously in the compilation order section, pre-link functions are called parent-then-child, whereas post-link functions are called child-then-parent.The pre-link function is rarely used, but can be useful in special scenarios; for example, when a child controller registers itself with the parent controller, but the registration has to be in a parent-then-child fashion (ngModelController does things this way).