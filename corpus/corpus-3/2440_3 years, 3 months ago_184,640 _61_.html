I\'ve gone through the iBook from Apple, and couldn\'t find any definition of it :Can someone explain the structure of dispatch_after?A clearer idea of the structure:dispatch_time_t is a UInt64. The dispatch_queue_t is actually type aliased to an NSObject, but you should just use your familiar GCD methods to get queues. The block is a Swift closure. Specifically, dispatch_block_t is defined as () -> Void, which is equivalent to () -> ().Example usage:EDIT:I recommend using @matt\'s really nice delay function.EDIT 2:In Swift 3, there will be new wrappers for GCD. See here: https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.mdThe original example would be written as follows in Swift 3:Note that you can write the deadlineTime declaration as DispatchTime.now() + 1.0 and get the same result because the + operator is overridden as follows (similarly for -):This means that if you don\'t use the DispatchTimeInterval enum and just write a number, it is assumed that you are using seconds.I use dispatch_after so often that I wrote a top-level utility function to make the syntax simpler:And now you can talk like this:Wow, a language where you can improve the language. What could be better?Seems almost not worth bothering with, now that they\'ve improved the calling syntax:matt\'s syntax is very nice and if you need to invalidate the block, you may want to use this :Use as follow creditsLink above seems to be down. Original Objc code from GithubTo expand on Cezary\'s answer, which will execute after 1 nanosecond, I had to do the following to execute after 4 and a half seconds.Edit: I discovered that my original code was slightly wrong.  Implicit typing causes a compile error if you don\'t cast NSEC_PER_SEC to a Double.If anyone can suggest a more optimal solution I\'d be keen to hear it.== Update for Swift 3 ==This is super-easy and elegant in Swift 3:Apple has a dispatch_after snippet for Objective-C:Here is the same snippet ported to Swift 3:Another way is to extend Double like this:Then you can use it like this:I like matt\'s delay function but just out of preference I\'d rather limit passing closures around.Simplest solution in Swift 3.0 & Swift 4.0UsageIn Swift 3.0 Dispatch queuesDispatch after 5 seconds1) Add this method as a part of UIViewController Extension.Call this method on VC:     2) performSelector("yourMethod Name", withObject: nil, afterDelay: 1)3) //Compact Form}Although not the original question by the OP, certain NSTimer related questions have been marked as duplicates of this question, so it is worth including an NSTimer answer here.Create an NSTimer instance.Start the timer with the delay that you need.Add a function to be called after the delay (using whatever name you used for the selector parameter above).If you have a one time event with no need to cancel then there is no need to create the timer instance variable. The following will suffice:See my fuller answer here.Swift 3.0  versionFollowing closure function execute some task after delay on main thread. Call this function like:Another helper to delay your code that is 100% Swift in usage and optionally allows for choosing a different thread to run your delayed code from:Now you simply delay your code on the Main thread like this:If you want to delay your code to a different thread:If you prefer a Framework that also has some more handy features then checkout HandySwift. You can add it to your project via Carthage then use it exactly like in the examples above, e.g.:This worked for me.Swift 3:Objective-C:use this code to perform some UI related task after 2.0 seconds.Swift 3.0  versionFollowing closure function execute some task after delay on main thread. Call this function like: