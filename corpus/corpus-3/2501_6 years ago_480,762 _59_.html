What I want is to start counting time somewhere in my code and then get the passed time, to measure the time it took to execute few function. I think I\'m using the timeit module wrong, but the docs are just confusing for me.If you just want to measure the elapsed wall-clock time between two points, you could use  time.time():This gives the execution time in seconds.Another option since 3.3 might be to use perf_counter or process_time, depending on your requirements. Before 3.3 it was recommended to use use time.clock (thanks @Amber). However, it is currently deprecated:On Unix, return the current processor time as a floating point number\n  expressed in seconds. The precision, and in fact the very definition\n  of the meaning of \xe2\x80\x9cprocessor time\xe2\x80\x9d, depends on that of the C function\n  of the same name.On Windows, this function returns wall-clock seconds elapsed since the\n  first call to this function, as a floating point number, based on the\n  Win32 function QueryPerformanceCounter(). The resolution is typically\n  better than one microsecond.Deprecated since version 3.3: The behaviour of this function depends\n  on the platform: use perf_counter() or process_time() instead,\n  depending on your requirements, to have a well defined behaviour.Use timeit.default_timer instead of timeit.timeit. The former provides the best clock available on your platform and version of Python automatically:timeit.default_timer is assigned to time.time() or time.clock() depending on OS. On Python 3.3+ default_timer is time.perf_counter() on all platforms. See Python - time.clock() vs. time.time() - accuracy?See also:Given a function you\'d like to time,test.py:the easiest way to use timeit is to call it from the command line:Do not try to use time.time or time.clock (naively) to compare the speed of functions. They can give misleading results.PS. Do not put print statements in a function you wish to time; otherwise the time measured will depend on the speed of the terminal.Since time.clock() is deprecated as of Python 3.3, you will want to use time.perf_counter() for system-wide timing, or time.process_time() for process-wide timing, just the way you used to use time.clock():The new function process_time will not include time elapsed during sleep.It\'s fun to do this with a context-manager that automatically remembers the start time upon entry to a with block, then freezes the end time on block exit. With a little trickery, you can even get a running elapsed-time tally inside the block from the same context-manager function. The core library doesn\'t have this (but probably ought to). Once in place, you can do things like:Here\'s contextmanager code sufficient to do the trick:And some runnable demo code:Note that by design of this function, the return value of elapsed() is frozen on block exit, and further calls return the same duration (of about 6 seconds in this toy example). Using time.time to measure execution gives you the overall execution time of your commands including running time spent by other processes on your computer. It is the time the user notices, but is not good if you want to compare different code snippets / algorithms / functions / ...More information on timeit:If you want a deeper insight into profiling:Update: I used http://pythonhosted.org/line_profiler/ a lot during the last year and find it very helpfull and recommend to use it instead of Pythons profile module.The python cProfile and pstats modules offer great support for measuring time elapsed in certain functions without having to add any code around the existing functions.For example if you have a python script timeFunctions.py:To run the profiler and generate stats for the file you can just run:What this is doing is using the cProfile module to profile all functions in timeFunctions.py and collecting the stats in the timeStats.profile file. Note that we did not have to add any code to existing module (timeFunctions.py) and this can be done with any module.Once you have the stats file you can run the pstats module as follows:This runs the interactive statistics browser which gives you a lot of nice functionality. For your particular use case you can just check the stats for your function. In our example checking stats for both functions shows us the following:The dummy example does not do much but give you an idea of what can be done. The best part about this approach is that I dont have to edit any of my existing code to get these numbers and obviously help with profiling.Here is a tiny timer class that returns "hh:mm:ss" string: Usage: Here\'s another context manager for timing code -Usage: or, if you need the time valuebenchmark.py:Adapted from http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html(With Ipython only) you can use %timeit to measure average processing time:and then:    the result is something like:I prefer this. Timeit doc is far too confusing. Note, that there isn\'t any formatting going on here, I just wrote hh:mm:ss into the printout so one can interpret timeElapsedon python3:elegant and short.Kind of a super later response, but maybe it serves a purpose for someone. This is a way to do it which I think is super clean.Keep in mind that "print" is a function in Python 3 and not Python 2.7. However, it works with any other function. Cheers!I made a library for this, if you want to measure a function you can just do it like this https://github.com/Karlheinzniebuhr/pythonbenchmark We can also convert time into human-readable time.Use profiler module. It gives a very detailed profile.it outputs something like:I\'ve found it very informative.One more way to use timeit:You can use timeit.Here is an example on how to test naive_func that takes parameter using Python REPL:You don\'t need wrapper function if function doesn\'t have any parameters.                                                                                      