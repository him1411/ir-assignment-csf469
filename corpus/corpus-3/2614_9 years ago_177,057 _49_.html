My Google-fu has failed me.In Python, are the following two tests for equality equivalent (ha!)?Does this hold true for objects where you would be comparing instances (a list say)?Okay, so this kind of answers my question:So == tests value where is tests to see if they are the same object?is will return True if two variables point to the same object, == if the objects referred to by the variables are equal.In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:The same holds true for string literals:Please see this question as well.There is a simple rule of thumb to tell you when to use == or is.In general, when you are comparing something to a simple type, you are usually checking for value equality, so you should use ==. For example, the intention of your example is probably to check whether x has a value equal to 2 (==), not whether x is literally referring to the same object as 2.Something else to note: because of the way the CPython reference implementation works, you\'ll get unexpected and inconsistent results if you mistakenly use is to compare for reference equality on integers:That\'s pretty much what we expected: a and b have the same value, but are distinct entities. But what about this?This is inconsistent with the earlier result. What\'s going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here\'s an example demonstrating this:This is another obvious reason not to use is: the behavior is left up to implementations when you\'re erroneously using it for value equality.== determines if the values are equivalent, while "is" determines if they are the exact same object. They are completely different.  is checks for object identity, while == checks for equality (a notion that depends on the two operands\' types).It is only a lucky coincidence that "is" seems to work correctly with small integers (e.g. 5 == 4+1).  That is because CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons: https://docs.python.org/2/c-api/int.html#c.PyInt_FromLonghttps://docs.python.org/library/stdtypes.html#comparisonsis tests for identity\n== tests for equalityEach (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec thoughYour answer is correct. The is operator compares the identity of two objects.  The == operator compares the values of two objects.An object\'s identity never changes once it has been created; you may think of it as the object\'s address in memory.You can control comparison behaviour of object values by defining a __cmp__ method or a rich comparison method like __eq__.Have a look at Stack Overflow question Python\'s \xe2\x80\x9cis\xe2\x80\x9d operator behaves unexpectedly with integers.What it mostly boils down to is that "is" checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I\'d just like to categorise what you would do the rest of the time:There is one and only one instance of NoneType i.e. None is a singleton. Consequently foo == None and foo is None mean the same. However the is test is faster and the Pythonic convention is to use foo is None.If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for foo is bar.True and False are also (now) singletons, but there is no use-case for foo == True and no use case for foo is True. Actually I wanted to add this as a comment but could not beautify it easily hence adding as an answer, please do not consider this as an answer. This is what I did to understand --execute following one by one and understand output on every step"==" compares values"is" compares underlying objectso1 is o2 => compares if o1 and o2 both points to same physical location in memory (in other words if they are same object)o1 == o2 => here python call the o1\'s __cmp __(o2) method, which ideally should compares the value and return True or False. (In other words it compares value)For JAVA people: In Java, to determine whether two string variables reference the same\nphysical memory location by using str1 == str2. (called object\nidentity, and it is written in Python as str1 is str2). To compare string values in Java, usestr1.equals(str2); in Python,\nuse str1 == str2.Example:Python Shell output: o = A(2)\n  o1 = oo == o1 \n  2 \n  2 \n  Trueo is o1\n  Trueo1 = A(2)o is o1\n  FalseWhile all these answers that rely on the implementation of objection pointer comparison vs value comparison are likely correct, there is a deeper syntactical reason for using is to determine if a variable value is None (in boolean logic often represented as NULL).  In relational database and other logic systems, NULL implies that the actual value is "unknown".  Thus the logical expression xx == NULL must always evaluate to NULL itself, as it is impossible to ever know if xx, whatever value it may have, is the same as the unknown value.  In programming languages that adhere more strictly to the rules of boolean logic, xx == NULL (or Pythonically xx == None) correctly evaluates to NULL, and alternative means must be provided to determine if a variable value is NULL.  Python is an outlier in this regard, due to the unitary nature of the object reference to None.  But for clarity and logical correctness, using the Python is comparison operator seems to me much sounder practice.