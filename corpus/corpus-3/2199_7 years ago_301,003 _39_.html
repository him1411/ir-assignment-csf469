I have some doubts over how Enumerators work, and LINQ. Consider these two simple selects:orI changed the names of my original objects so that this looks like a more generic example. The query itself is not that important. What I want to ask is this:I noticed that if I use IEnumerable, when I debug and inspect "sel", which in that case is the IEnumerable, it has some interesting members: "inner", "outer", "innerKeySelector" and "outerKeySelector", these last 2 appear to be delegates. The "inner" member does not have "Animal" instances in it, but rather "Species" instances, which was very strange for me. The "outer" member does contain "Animal" instances. I presume that the two delegates determine which goes in and what goes out of it?I noticed that if I use "Distinct", the "inner" contains 6 items (this is incorrect as only 2 are Distinct), but the "outer" does contain the correct values. Again, probably the delegated methods determine this but this is a bit more than I know about IEnumerable.Most importantly, which of the two options is the best performance-wise?The evil List conversion via .ToList()?Or maybe using the enumerator directly?If you can, please also explain a bit or throw some links that explain this use of IEnumerable.IEnumerable describes behavior, while List is an implementation of that behavior. When you use IEnumerable, you give the compiler a chance to defer work until later, possibly optimizing along the way. If you use ToList() you force the compiler to reify the results right away.Whenever I\'m "stacking" LINQ expressions, I use IEnumerable, because by only specifying the behavior I give LINQ a chance to defer evaluation and possibly optimize the program. Remember how LINQ doesn\'t generate the SQL to query the database until you enumerate it? Consider this:Now you have a method that selects an initial sample ("AllSpotted"), plus some filters. So now you can do this:So is it faster to use List over IEnumerable? Only if you want to prevent a query from being executed more than once. But is it better overall? Well in the above, Leopards and Hyenas get converted into single SQL queries each, and the database only returns the rows that are relevant. But if we had returned a List from AllSpotted(), then it may run slower because the database could return far more data than is actually needed, and we waste cycles doing the filtering in the client.In a program, it may be better to defer converting your query to a list until the very end, so if I\'m going to enumerate through Leopards and Hyenas more than once, I\'d do this:A class that implement IEnumerable allows you to use the foreach syntax.Basically it has a method to get the next item in the collection. It doesn\'t need the whole collection to be in memory and doesn\'t know how many items are in it, foreach just keeps getting the next item until it runs out.This can be very useful in certain circumstances, for instance in a massive database table you don\'t want to copy the entire thing into memory before you start processing the rows.Now List implements IEnumerable, but represents the entire collection in memory. If you have an IEnumerable and you call .ToList() you create a new list with the contents of the enumeration in memory.Your linq expression returns an enumeration, and by default the expression executes when you iterate through using the foreach. An IEnumerable linq statement executes when you iterate the foreach, but you can force it to iterate sooner using .ToList().Here\'s what I mean:There is a very good article written by: Claudio Bernasconi\'s TechBlog here: When to use IEnumerable, ICollection, IList and ListHere some basics points about scenarios and functions:\nThe most important thing to realize is that, using Linq, the query does not get evaluated immediately. It is only run as part of iterating through the resulting IEnumerable<T> in a foreach - that\'s what all the weird delegates are doing.So, the first example evaluates the query immediately by calling ToList and putting the query results in a list.\nThe second example returns an IEnumerable<T> that contains all the information needed to run the query later on.In terms of performance, the answer is it depends. If you need the results to be evaluated at once (say, you\'re mutating the structures you\'re querying later on, or if you don\'t want the iteration over the IEnumerable<T> to take a long time) use a list. Else use an IEnumerable<T>. The default should be to use the on-demand evaluation in the second example, as that generally uses less memory, unless there is a specific reason to store the results in a list.Nobody mentioned one crucial difference, ironically answered on a question closed as a duplicated of this. IEnumerable is read-only and List is not.See Practical difference between List and IEnumerableThe advantage of IEnumerable is deferred execution (usually with databases). The query will not get executed until you actually loop through the data. It\'s a query waiting until it\'s needed (aka lazy loading).If you call ToList, the query will be executed, or "materialized" as I like to say.There are pros and cons to both. If you call ToList, you may remove some mystery as to when the query gets executed. If you stick to IEnumerable, you get the advantage that the program doesn\'t do any work until it\'s actually required.If all you want to do is enumerate them, use the IEnumerable.Beware, though, that changing the original collection being enumerated is a dangerous operation - in this case, you will want to ToList first. This will create a new list element for each element in memory, enumerating the IEnumerable and is thus less performant if you only enumerate once - but safer and sometimes the List methods are handy (for instance in random access).I will share one misused concept that I fell into one day:As per other answers, the evaluation of the result was deferred until calling ToList or similar invocation methods for example ToArray.So I can rewrite the code in this case as:https://repl.it/E8Ki/0Here is my two cents. There are many other types other than List that implements IEnumerable such Dictionary , ArrayList etc. So if we have IEnumerable as parameter, we can pass any collection types to the function. Ie we can have method to operate on abstraction not any specific implementation.