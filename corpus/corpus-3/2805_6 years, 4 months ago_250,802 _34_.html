I have this query and I get the error in this function:Error is:There is already an open DataReader associated with this Command which must be closed first. Update:stack trace added:This can happen if you execute a query while iterating over the results from another query. It is not clear from your example where this happens because the example is not complete.One thing that can cause this is lazy loading triggered when iterating over the results of some query.This can be easily solved by allowing MARS in your connection string. Add MultipleActiveResultSets=true to the provider part of your connection string (where Data Source, Initial Catalog, etc. are specified).You can use the ToList() method before the return statement.In my case, using Include() solved this error and depending on the situation can be a lot more efficient then issuing multiple queries when it can all be queried at once with a join. Here is a working connection string for someone who needs reference. I donot know whether this is duplicate answer or not. If it is I am sorry. I just want to let the needy know how I solved my issue using ToList().In my case I got same exception for below query. I solved like belowuse the syntax .ToList() to convert object read from db to list to avoid being reread again..Hope that would work for it. Thanks.It appears that you\'re calling DateLastUpdated from within an active query using the same EF context and DateLastUpdate issues a command to the data store itself. Entity Framework only supports one active command per context at a time.You can refactor your above two queries into one like this:I also noticed you\'re calling functions like FormattedAccountNumber and FormattedRecordNumber in the queries. Unless these are stored procs or functions you\'ve imported from your database into the entity data model and mapped correct, these will also throw excepts as EF will not know how to translate those functions in to statements it can send to the data store. Also note, calling AsEnumerable doesn\'t force the query to execute. Until the query execution is deferred until enumerated. You can force enumeration with ToList or ToArray if you so desire.In addition to Ladislav Mrnka\'s answer:If you are publishing and overriding container on Settings tab, you can set  MultipleActiveResultSet to True. You can find this option by clicking Advanced... and it\'s going to be under Advanced group. I had the same error, when I tried to update some records within read loop.\nI\'ve tried the most voted\xc2\xa0answer MultipleActiveResultSets=true and found, that it\'s just workaround to get the next error\xc2\xa0New transaction is not allowed because there are other threads running\n  in the sessionThe best approach, that will work for huge ResultSets is to use chunks and open separate context for each chunk as described in\xc2\xa0\nSqlException from Entity Framework - New transaction is not allowed because there are other threads running in the sessionI solved this problem by changing\nawait _accountSessionDataModel.SaveChangesAsync();\nto\n_accountSessionDataModel.SaveChanges();\nin my Repository class.Changed it to:The problem was that I updated the Sessions in the frontend after creating a session (in code), but because SaveChangesAsync happens asynchronously, fetching the sessions caused this error because apparently the SaveChangesAsync operation was not yet ready.I am using web service in my tool, where those service fetch the stored procedure. while more number of client tool fetches the web service, this problem arises. I have fixed by specifying the Synchronized attribute for those function fetches the  stored procedure. now it is working fine, the error never showed up in my tool.This attribute allows to process one request at a time.  so this solves the Issue. For those finding this via Google;\nI was getting this error because, as suggested by the error, I failed to close a SqlDataReader prior to creating another on the same SqlCommand, mistakenly assuming that it would be garbage collected when leaving the method it was created in.  I solved the issue by calling sqlDataReader.Close(); before creating the second reader.Well for me it was my own bug.  I was trying to run an INSERT using SqlCommand.executeReader() when I should have been using SqlCommand.ExecuteNonQuery().  It was opened and never closed, causing the error.  Watch out for this oversight.This is extracted from a real world scenario:In conclusion, without forgetting about MultipleActiveResultSets, the code might have run for a long time before discovering a redundant db call that could be very costly, and I suggest not to fully depend on setting the MultipleActiveResultSets attribute but also find out why the code needs it where it failed.  