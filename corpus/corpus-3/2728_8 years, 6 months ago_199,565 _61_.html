It\'s weird that this is the first time I\'ve bumped into this problem, but:How do you define a constructor in a C# interface?Edit\nSome people wanted an example (it\'s a free time project, so yes, it\'s a game)IDrawable\n +Update\n +DrawTo be able to Update (check for edge of screen etc) and draw itself it will always need a GraphicsDeviceManager. So I want to make sure the object has a reference to it. This would belong in the constructor.Now that I wrote this down I think what I\'m implementing here is IObservable and the GraphicsDeviceManager should take the IDrawable...\nIt seems either I don\'t get the XNA framework, or the framework is not thought out very well.Edit\nThere seems to be some confusion about my definition of constructor in the context of an interface. An interface can indeed not be instantiated so doesn\'t need a constructor. What I wanted to define was a signature to a constructor. Exactly like an interface can define a signature of a certain method, the interface could define the signature of a constructor.As already well noted, you can\'t have constructors on an Interface.  But since this is such a highly ranked result in Google some 7 years later, I thought I would chip in here - specifically to show how you could use an abstract base class in tandem with your existing Interface and maybe cut down on the amount of refactoring needed in the future for similar situations.  This concept has already been hinted at in some of the comments but I thought it would be worth showing how to actually do it.So you have your main interface that looks like this so far:Now create an abstract class with the constructor you want to enforce.  Actually, since it\'s now available since the time you wrote your original question, we can get a little fancy here and use generics in this situation so that we can adapt this to other interfaces that might need the same functionality but have different constructor requirements:Now you\'ll need to create a new class that inherits from both the IDrawable interface and the MustInitialize abstract class:Then just create an instance of Drawable and you\'re good to go:The cool thing here is that the new Drawable class we created still behaves just like what we would expect from an IDrawable.If you need to pass more than one parameter to the MustInitialize constructor, you can create a class that defines properties for all of the fields you\'ll need to pass in.You can\'t. It\'s occasionally a pain, but you wouldn\'t be able to call it using normal techniques anyway.In a blog post I\'ve suggested static interfaces which would only be usable in generic type constraints - but could be really handy, IMO.One point about if you could define a constructor within an interface, you\'d have trouble deriving classes:A very late contribution demonstrating another problem with interfaced constructors. (I choose this question because it has the clearest articulation of the problem). Suppose we could have:Where by convention the implementation of the "interface constructor" is replaced by the type name.Now make an instance:Would we say that the contract ICustomer is obeyed?And what about this:You can\'t.Interfaces define contracts that other objects implement and therefore have no state that needs to be initialized.If you have some state that needs to be initialized, you should consider using an abstract base class instead.It is not possible to create an interface that defines constructors, but it is possible to define an interface that forces a type to have a paramerterless constructor, though be it a very ugly syntax that uses generics... I am actually not so sure that it is really a good coding pattern. On the other hand, if you want to test if a type has a paramerterless constructor, you can do that using reflection:Hope this helps.I was looking back at this question and I thought to myself, maybe we are aproaching this problem the wrong way. Interfaces might not be the way to go when it concerns defining a constructor with certain parameters... but an (abstract) base class is. If you create a base class with a constructor on there that accepts the parameters you need, every class that derrives from it needs to supply them. The generic factory approach still seems ideal. You would know that the factory requires a parameter, and it would just so happen that those parameters are passed along to the constructor of the object being instantiated. Note, this is just syntax verified pseudo code, there may be a run-time caveat I\'m missing here:An example of possible usage:Granted, you\'d only want the create instances via the factory to guarantee you always have an appropriately initialized object. Perhaps using a dependency injection framework like AutoFac would make sense; Update() could "ask" the IoC container for a new GraphicsDeviceManager object.One way to solve this problem i found is to seperate out the construction into a seperate factory.  For example I have an abstract class called IQueueItem, and I need a way to translate that object to and from another object (CloudQueueMessage).  So on the interface IQueueItem i have - Now, I also need a way for my actual queue class to translate a CloudQueueMessage back to a IQueueItem - ie the need for a static construction like  IQueueItem objMessage = ItemType.FromMessage.   Instead I defined another interface IQueueFactory -Now I can finally write my generic queue class without the new() constraint which in my case was the main issue.now I can create an instance that satisfies the criteria for mehopefully this helps someone else out someday, obviously a lot of internal code removed to try to show the problem and solutionYou could do this with generics trick, but it still is vulnerable to what Jon Skeet wrote:Class that implements this interface must have parameterless constructor:One way to solve this problem is to leverage generics and the new() constraint.Instead of expressing your constructor as a method/function, you can express it as a factory class/interface. If you specify the new() generic constraint on every call site that needs to create an object of your class, you will be able to pass constructor arguments accordingly.For your IDrawable example:Now when you use it:You can even concentrate all creation methods in a single class using explicit interface implementation:To use it:Another way is by using lambda expressions as initializers. At some point early in the call hierarchy, you will know which objects you will need to instantiate (i.e. when you are creating or getting a reference to your GraphicsDeviceManager object). As soon as you have it, pass the lambdato subsequent methods so they will know how to create a Triangle from then on. If you can\'t determine all possible methods that you will need, you can always create a dictionary of types that implement IDrawable using reflection and register the lambda expression shown above in a dictionary that you can either store in a shared location or pass along to further function calls.you don\'t.the constructor is part of the class that can implement an interface.  The interface is just a contract of methods the class must implement. It would be very useful if it were possible to define constructors in interfaces.Given that an interface is a contract that must be used in the specified way. The following approach might be a viable alternative for some scenarios:One way to force some sort of constructor is to declare only Getters in interface, which could then mean that the implementing class must have a method, ideally a constructor, to have the value set (privately) for it.While you can\'t define a constructor signature in an interface, I feel it\'s worth mentioning that this may be a spot to consider an abstract class. Abstract classes can define unimplemented (abstract) method signatures in the same way as an interface, but can also have implemented (concrete) methods and constructors.The downside is that, because it is a type of class, it cannot be used for any of the multiple inheritance type scenarios that an interface can.If I understood OP correctly, we want to enforce a contract where GraphicsDeviceManager is always initialised by implementing classes. I had a similar problem and I was looking for a better solution,  but this is the best I can think of:Add a SetGraphicsDeviceManager(GraphicsDeviceManager gdo) to the interface, and that way the implementing classes will be forced to write a logic which will be require a call from constructor.I lift this thread because of the JavaScript that passes it through the prototypes.I also think that a constructor can not overcome the initialization of its fields. Especially in C ++, when you are in a constructor, you can not have the "this" pointer already created. In C #, this is not the case; But this is just a lack of principles, and this overcomes what happens in the constructor of a C ++ class.Next, it is agreed that any class should ensure that all fields are properly defined and are not null. This can easily be checked with a simple private attribute or a function that checks if something is wrong for a null field or a field that is not well referenced.