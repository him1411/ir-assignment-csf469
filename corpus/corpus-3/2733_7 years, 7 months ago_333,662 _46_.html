I would like to check if a string begins with "node" e.g. "node001". Something likeHow can I do it correctly\xef\xbc\x9fI further need to combine expressions to check if HOST is either "user1" or begins with "node"How to do it correctly?This snippet on the Advanced Bash Scripting Guide says:So you had it nearly correct; you needed double brackets, not single brackets.With regards to your second question, you can write it this way:Which will echoBash\'s if syntax is hard to get used to (IMO).If you\'re using a recent bash (v3+) suggest bash regex comparison operator =~, i.e.To match this or that in a regex use |, i.e.Note - these is \'proper\' regular expression syntax.If you\'re not familiar with regular expression syntax, try referring to this resource.Note - it\'s better if you ask each new question as a new question, makes stackoverflow tidier and more useful. You can always include a link back to a previous question for reference.I prefer the other methods already posted, but some people like to use:Edit:I\'ve added your alternates to the case statement aboveIn your edited version you have too many brackets. It should look like this:You can select just the part of the string you want to check:For your follow-up question, you could use an OR:I always try to stick with POSIX sh instead of using bash extensions, since one of the major points of scripting is portability. (Besides connecting programs, not replacing them)In sh, there is an easy way to check for an "is-prefix" condition.Given how old, arcane and crufty sh is (and bash is not the cure: It\'s more complicated, less consistent and less portable), I\'d like to point out a very nice functional aspect: While some syntax elements like case are built-in, the resulting constructs are no different than any other job. They can be composed in the same way:Or even shorterOr even shorter (just to present ! as a language element -- but this is bad style now)If you like being explicit, build your own language element:Isn\'t this actually quite nice?And since sh is basically only jobs and string-lists (and internally processes, out of which jobs are composed), we can now even do some light functional programming:This is elegant. Not that I\'d advocate using sh for anything serious -- it breaks all too quickly on real world requirements (no lambdas, so must use strings. But nesting function calls with strings is not possible, pipes are not possible...)since # has a meaning in bash I got to the following solution.\nIn addition I like better to pack strings with "" to overcome spaces etc.While I find most answers here quite correct, many of them contain unnecessary bashisms. POSIX parameter expansion gives you all you need:and${var#expr} strips the smallest prefix matching expr from ${var} and returns that. Hence if ${host} does not start with user (node), ${host#user} (${host#node}) is the same as ${host}.expr allows fnmatch() wildcards, thus ${host#node??} and friends also work.@OP, for both your questions you can use case/esac second questionOR Bash 4.0doesn\'t work, because all of [, [[ and test recognize the same nonrecursive grammar.  see section CONDITIONAL EXPRESSIONS in your bash man page.As an aside, the SUSv3 saysThe KornShell-derived conditional command (double bracket [[]]) was removed from the shell command language description in an early proposal.  Objections were raised that the real problem is misuse of the test command ([), and putting it into the shell is the wrong way to fix the problem.  Instead, proper documentation and a new shell reserved word (!) are sufficient.Tests that require multiple test operations can be done at the shell level using individual invocations of the test command and shell logicals, rather than using the error-prone -o flag of test.you\'d need to write it this way, but test doesn\'t support it:test uses = for string equality, more importantly it doesn\'t support pattern matching.case / esac has good support for pattern matching:it has the added benefit that it doesn\'t depend on bash, the syntax is portable.  from the Single Unix Specification, The Shell Command Language:Another thing you can do is cat out what you are echoing and pipe with inline cut -c 1-1