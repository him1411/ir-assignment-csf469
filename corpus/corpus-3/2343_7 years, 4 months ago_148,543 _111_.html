The Java Language Specification defines a raw type as follows:A raw type is defined to be one of:The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.An array type whose element type is a raw type.A non-static member type of a raw type R that is not inherited from a superclass or superinterface of R.Here\'s an example to illustrate:Here, MyType<E> is a parameterized type (JLS 4.5). It is common to colloquially refer to this type as simply MyType for short, but technically the name is MyType<E>.mt has a raw type (and generates a compilation warning) by the first bullet point in the above definition; inn also has a raw type by the second bullet point.MyType.Nested is not a parameterized type, even though it\'s a member type of a parameterized type MyType<E>, because it\'s static.mt1, and mt2 are both declared with actual type parameters, so they\'re not raw types.Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.The above code runs just fine, but suppose you also have the following:Now we run into trouble at run-time, because names contains something that isn\'t an instanceof String.Presumably, if you want names to contain only String, you could perhaps still use a raw type and manually check every add yourself, and then manually cast to String every item from names. Even better, though is NOT to use a raw type and let the compiler do all the work for you, harnessing the power of Java generics.Of course, if you DO want names to allow a Boolean, then you can declare it as List<Object> names, and the above code would compile.The following is a quote from Effective Java 2nd Edition, Item 23: Don\'t use raw types in new code:Just what is the difference between the raw type List and the parameterized type List<Object>? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a List<String> to a parameter of type List, you can\'t pass it to a parameter of type List<Object>. There are subtyping rules for generics, and List<String> is a subtype of the raw type List, but not of the parameterized type List<Object>. As a consequence, you lose type safety if you use raw type like List, but not if you use a parameterized type like List<Object>.To illustrate the point, consider the following method which takes a List<Object> and appends a new Object().Generics in Java are invariant. A List<String> is not a List<Object>, so the following would generate a compiler warning:If you had declared appendNewObject to take a raw type List as parameter, then this would compile, and you\'d therefore lose the type safety that you get from generics.List<Object>, List<String>, etc are all List<?>, so it may be tempting to just say that they\'re just List instead. However, there is a major difference: since a List<E> defines only add(E), you can\'t add just any arbitrary object to a List<?>. On the other hand, since the raw type List does not have type safety, you can add just about anything to a List.Consider the following variation of the previous snippet:The compiler did a wonderful job of protecting you from potentially violating the type invariance of the List<?>! If you had declared the parameter as the raw type List list, then the code would compile, and you\'d violate the type invariant of List<String> names.Back to JLS 4.8:It is possible to use as a type the erasure of a parameterized type or the erasure of an array type whose element type is a parameterized type. Such a type is called a raw type.[...]The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.The type of a constructor, instance method, or non-static field of a raw type C that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to C.In simpler terms, when a raw type is used, the constructors, instance methods and non-static fields are also erased.Take the following example:When we use the raw MyType, getNames becomes erased as well, so that it returns a raw List!JLS 4.6 continues to explain the following:Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables. The erasure of a constructor or method signature s is a signature consisting of the same name as s and the erasures of all the formal parameter types given in s.The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor\'s signature is erased.The erasure of the signature of a generic method has no type parameters.The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: https://bugs.openjdk.java.net/browse/JDK-6400189. (In short, it makes the specification simpler.)Here\'s another quote from JLS 4.8:The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.Effective Java 2nd Edition also has this to add:Given that you shouldn\'t use raw types, why did the language designers allow them? To provide compatibility.The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as migration compatibility, drove the decision to support raw types.In summary, raw types should NEVER be used in new code. You should always use parameterized types.Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:What are raw types in Java, and why do I often hear that they shouldn\'t be used in new code?Raw-types are ancient history of the Java language. In the beginning there were Collections and they held Objects nothing more and nothing less. Every operation on Collections required casts from Object to the desired type.While this worked most of the time, errors did happenThe old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.\nGenerics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.For Comparison:More complex the Compareable interface:Note that it is impossible to implement the CompareAble interface with compareTo(MyCompareAble) with raw types.\nWhy you should not use them:What the compiler does:\nGenerics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.Will be compiled as:This is the same code you would write if you used the raw types directly. Thought I\'m not sure what happens with the CompareAble interface, I guess that it creates two compareTo functions, one taking a MyCompareAble and the other taking an Object and passing it to the first after casting it.What are the alternatives to raw types: Use genericsA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:To create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:If the actual type argument is omitted, you create a raw type of Box<T>:Therefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior \xe2\x80\x94 a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:But if you assign a raw type to a parameterized type, you get a warning:You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.The Type Erasure section has more information on how the Java compiler uses raw types.As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:Note: Example.java uses unchecked or unsafe operations.Note: Recompile with -Xlint:unchecked for details.This can happen when using an older API that operates on raw types, as shown in the following example:The term "unchecked" means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The "unchecked" warning is disabled, by default, though the compiler gives a hint. To see all "unchecked" warnings, recompile with -Xlint:unchecked.Recompiling the previous example with -Xlint:unchecked reveals the following additional information:To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings("unchecked") annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.Original source: Java Tutorials You should specify the type-parameter. The warning advises that types that are defined to support generics should be parameterized, rather than using their raw form.List is defined to support generics: public class List<E>. This allows many type-safe operations, that are checked compile-time.A "raw" type in Java is a class which is non-generic and deals with "raw" Objects, rather than type-safe generic type parameters.For example, before Java generics was available, you would use a collection class like this:When you add your object to the list, it doesn\'t care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.Using generics, you remove the "unknown" factor, because you must explicitly specify which type of objects can go in the list:Notice that with generics you don\'t have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.What is a raw type and why do I often hear that they shouldn\'t be used in new code?A "raw type" is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using List instead of List<String>. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a "raw type" (without specifying a type argument) allowed legacy code to still compile."Raw types" are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.What is the alternative if we can\'t use raw types, and how is it better?The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. List<String>). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.For example, for a method where the programmer wants to ensure a List variable called \'names\' contains only Strings:The compiler wants you to write this:because otherwise, you could add any type you like into list, making the instantiation as new ArrayList<String>() pointless. Java generics are a compile-time feature only, so an object created with new ArrayList<String>() will happily accept Integer or JFrame elements if assigned to a reference of the "raw type" List - the object itself knows nothing about what types it\'s supposed to contain, only the compiler does.A raw-type is the a lack of a type parameter when using a generic type.Raw-type should not be used because it could cause runtime errors, like inserting a double into what was supposed to be a Set of ints.When retrieving the stuff from the Set, you don\'t know what is coming out. Let\'s assume that you expect it to be all ints, you are casting it to Integer; exception at runtime when the double 3.45 comes along.With a type parameter added to your Set, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).Here I am Considering multiple cases  through which you can clearify  the conceptArrayList<String> arr it is a ArrayList reference variable with type String which reference to a ArralyList Object of Type String. It means it can hold only String type Object.It is a Strict to String not  a Raw Type so, It will never raise an warning .In this case ArrayList<String> arr is a strict type but your Object new ArrayList(); is a raw type. here arr is a Strict type. So, It will raise compile time error when adding a integer.Warning :- A Raw Type Object is referenced to a Strict type Referenced Variable of ArrayList.In this case ArrayList arr is a raw type but your Object new ArrayList<String>(); is a Strict type. It will add any type of Object into it because arr is a Raw Type.Warning :- A Strict Type Object is referenced to a raw type referenced Variable.What is saying is that your list is a List of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).In general is a better idea to parametrize the collections, so you don\'t have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.tutorial page.  A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:  To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:  If the actual type argument is omitted, you create a raw type of Box:  I found this page after doing some sample exercises and having the exact same puzzlement.============== I went from this code as provide by the sample ===================================== To This code =======================================================================================================It may be safer but took 4  hours to demuddle the philosophy...