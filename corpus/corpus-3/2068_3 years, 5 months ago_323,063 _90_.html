I\'m trying to do something like the following in React jsx (where ObjectRow is a separate component)I realize and understand why this isn\'t valid JSX since JSX maps to function calls, but, coming from template land and being new to JSX, am unsure how I would achieve the above (adding a component multiple times).Think of it like you\'re just calling JS functions. You can\'t put a for loop inside a function call:but you can make an array then pass that in:You can use basically the same structure when working with JSX:Incidentally, my JS example is almost exactly what that example of JSX transforms into. Play around with Babel REPL to get a feel for how JSX works.Not sure if this will work for your situation, but often map is a good answer.If this was your code with the for loop:You could write it like this with map:If you don\'t already have an array to map() like @FakeRainBrigand\'s answer, and want to inline this so the source layout corresponds to the output closer than @BenAlpert\'s answer:http://plnkr.co/edit/mfqFWODVy8dKQQOkIEGV?p=previewRe: transpiling with Babel, its caveats page says that Array.from is required for spread, but at present (v5.8.23) that does not seem to be the case when spreading an actual Array. I have a documentation issue open to clarify that. But use at your own risk or polyfill.http://plnkr.co/edit/4kQjdTzd4w69g8Suu2hT?p=previewKeep the source layout corresponding to the output, but make the inlined part more compact:With Array.prototype.fill you could do this as an alternative to using spread as illustrated above:(I think you could actually omit any argument to fill(), but I\'m not 100% on that.) Thanks to @FakeRainBrigand for correcting my mistake in an earlier version of the fill() solution (see revisions).In all cases the key attr alleviates a warning with the development build, but isn\'t accessible in the child. You can pass an extra attr if you want the index available in the child. See Lists and Keys for discussion.Simply using map Array method with ES6 syntax:Don\'t forget the key property.If you\'re already using lodash, the _.times function is handy.You can also extract outside the return block:I know this is an old thread, but you might want to checkout http://wix.github.io/react-templates/, which does let you use jsx-style templates in react, with a few directives (such as rt-repeat).Your example, if you used react-templates, would be:if numrows is a array, and it\'s very simple.Array data type in React is very better, array can back new array, and support filter, reduce etc.Using Array map function is very common way to loop trough an Array of elements and create components according them in React, this is an great way to do the loop which is pretty efficient and tidy way to do your loops in JSX, It\'s not the only way to do it, but the prefer way. \nAlso don\'t forget having a unique Key for each irritation as required. Map function create an unique indexes from 0 but it\'s not recomended using the index but if your value is unique or if there is a unique key, you can use them:Also few line from MDN if you not familiar with map function on Array:map calls a provided callback function once for each element in an\n  array, in order, and constructs a new array from the results. callback\n  is invoked only for indexes of the array which have assigned values,\n  including undefined. It is not called for missing elements of the\n  array (that is, indexes that have never been set, which have been\n  deleted or which have never been assigned a value).callback is invoked with three arguments: the value of the element,\n  the index of the element, and the Array object being traversed.If a thisArg parameter is provided to map, it will be used as\n  callback\'s this value. Otherwise, the value undefined will be used as\n  its this value. The this value ultimately observable by callback is\n  determined according to the usual rules for determining the this seen\n  by a function.map does not mutate the array on which it is called (although\n  callback, if invoked, may do so).There are several answers pointing to using map statement. Here is a complete example using a iterator within FeatureList component to list Feature components based on a JSON data structure called features.You can view the complete FeatureList code on GitHub. The features fixture is listed here.Or you can also prepare an array of object and map it to a function to have the desired output. I prefer this because it helps me to main the good practice of coding that no logic inside the return of render. let us say we have an array of items in your state:If you opt to convert this inside return( ) of render method, easiest option would be using map( ) method. Map your array into JSX syntax using map() function, as shown below (ES6 syntax is used).Inside parent component:<tbody>\n   { objectArray.map((object, index) => <ObjectRow key={index} object={object}>) }\n</tbody>Please note the key attribute added to your child component. If you didn\'t provide key attribute, you can see the following warning on your console.Warning: Each child in an array or iterator should have\n  a unique "key" prop.Now at the ObjectRow component you can access the object from it\'s properties.Inside ObjectRow componentconst { object } = this.propsor const object = this.props.objectThis should fetch you the object you passed from parent component to the variable object in ObjectRow component. Now you can spit out the values in that object according to your purpose.References : map() method in JavascriptECMA Script 6 or ES6I use this:PD: never forget the key or you will have a lot of warnings !you can of course solve with a .map as suggested by the other answer. If you already use babel, you could think about using jsx-control-statements \nThey require a little of setting, but I think it\'s worth in terms of readability (especially for non-react developer).\nIf you use a linter, there\'s also eslint-plugin-jsx-control-statementsYour JSX code will compile into pure JavaScript code, any tags will be replaced by ReactElement objects. In JavaScript, you cannot call a function multiple times to collect their returned variables.It is illegal, the only way is to use an array to store the function returned variables.Or you can use Array.prototype.map which is available since JavaScript ES5 to handle this situation.Maybe we can write other compiler to recreate a new JSX syntax to implement a repeat function just like Angular\'s ng-repeat.An ES2015 / Babel possibility is using a generator function to create an array of JSX:this can be done in multple ways .Loop inside returnMethod 1Method 2 Since you are writing a javascript syntax inside a JSX code, you need to wrap your javascript in curly braces.I tend to favor an approach where programming logic happens outside the return value of render.  This helps keep what is actually rendered easy to grok.So I\'d probably do something like:Admittedly this is such a small amount of code that inlining it might work fine.I use it likeHere\'s a simple solution to it.No mapping and complex code required.You just need to push the rows to array and return the values to render it.You can do something like:Simply use .map() and ES6 to loop through your collection and return <ObjectRow> items with props from each iteration.Here is a sample from React doc: \nhttps://facebook.github.io/react/docs/jsx-in-depth.html#javascript-expressions-as-childrenas your case, I suggest writing like this:Please notice the Key is very important, because React use Key to differ data in array.There are multiple ways to go about doing this. JSX eventually gets compiled to JavaScript, so as long as you\'re writing valid JavaScript, you\'ll be good.My answer aims to consolidate all the wonderful ways already presented here:If you do not have an array of object, simply the number of rows:within the return block, creating an Array and using Array.prototype.map:outside the return block, simply use a normal JavaScript for-loop:immediately invoked function expression:If you have an array of objectswithin the return block, .map() each object to a <ObjectRow> component:outside the return block, simply use a normal JavaScript for-loop:immediately invoked function expression:You\'ll want to add elements to an array and render the array of elements.\nThis can help reduce the time required to re-render the component.Here\'s some rough code that might help:You can use an IIFE if you really want to literally use for loop inside JSX.React elements are simple JS, so you can follow rule of javascript. So you can for loop of javascript like this:-But valid and best way is that to use .map function. Shown below:-Here one thing is necessary to define key otherwise it will through warning like this:-warning.js:36 Warning: Each child in an array or iterator should have\n  a unique "key" prop. Check the render method of ComponentName. See\n  "link" for more information.