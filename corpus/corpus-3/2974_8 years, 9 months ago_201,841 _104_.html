Can you write object-oriented code in C? Especially with regard to polymorphism.See also Stack Overflow question Object-orientation in C.Yes. In fact Axel Schreiner provides his book "Object-oriented Programming in ANSI-C" for free which covers the subject quite thoroughly. Since you\'re talking about polymorphism then yes, you can, we were doing that sort of stuff years before C++ came about.Basically you use a struct to hold both the data and a list of function pointers to point to the relevant functions for that data.So, in a communications class, you would have an open, read, write and close call which would be maintained as four function pointers in the structure, alongside the data for an object, something like:Of course, those code segments above would actually be in a "constructor" such as rs232Init().When you \'inherit\' from that class, you just change the pointers to point to your own functions. Everyone that called those functions would do it through the function pointers, giving you your polymorphism:Sort of like a manual vtable.You could even have virtual classes by setting the pointers to NULL -the behaviour would be slightly different to C++ (a core dump at run-time rather than an error at compile time).Here\'s a piece of sample code that demonstrates it. First the top-level class structure:Then we have the functions for the TCP \'subclass\':And the HTTP one as well:And finally a test program to show it in action:This produces the output:so you can see that the different functions are being called, depending on the sub-class.Namespaces are often done by doing:instead ofTo make a C struct into something like a C++ class you can turn:IntoAnd do:I didn\'t do the destructor or delete, but it follows the same pattern.this_is_here_as_an_example_only is like a static class variable -- shared among all instances of a type. All methods are really static, except that some take a this *I believe that besides being useful in its own right, implementing OOP in C is an excellent way to learn OOP and understand its inner workings. Experience of many programmers has shown that to use a technique efficiently and confidently, a programmer must understand how the underlying concepts are ultimately implemented. Emulating classes, inheritance, and polymorphism in C teaches just this. To answer the original question, here are a couple resources that teach how to do OOP in C:EmbeddedGurus.com blog post "Object-based programming in C" shows how to implement classes and single inheritance in portable C:\nhttp://embeddedgurus.com/state-space/2008/01/object-based-programming-in-c/Application Note ""C+"\xe2\x80\x94Object Oriented Programming in C" shows how to implement classes, single inheritance, and late binding (polymorphism) in C using preprocessor macros:\nhttp://www.state-machine.com/resources/cplus_3.0_manual.pdf, the example code is available from http://www.state-machine.com/resources/cplus_3.0.zipI\'ve seen it done.  I wouldn\'t recommend it.  C++ originally started this way as a preprocessor that produced C code as an intermediate step.Essentially what you end up doing is create a dispatch table for all of your methods where you store your function references.  Deriving a class would entail copying this dispatch table and replacing the entries that you wanted to override, with your new "methods" having to call the original method if it wants to invoke the base method.  Eventually, you end up rewriting C++.Sure that is possible. This is what GObject, the framework that all of GTK+ and GNOME is based on, does.The C stdio FILE sub-library is an excellent example of how to create abstraction, encapsulation, and modularity in unadulterated C. Inheritance and polymorphism - the other aspects often considered essential to OOP - do not necessarily provide the productivity gains they promise and reasonable arguments have been made that they can actually hinder development and thinking about the problem domain.Trivial example with an Animal and Dog: You mirror C++\'s vtable mechanism (largely anyway). You also separate allocation and instantiation (Animal_Alloc, Animal_New) so we don\'t call malloc() multiple times. We must also explicitly pass the this pointer around.If you were to do non-virtual functions, that\'s trival. You just don\'t add them to the vtable and static functions don\'t require a this pointer. Multiple inheritance generally requires multiple vtables to resolve ambiguities.Also, you should be able to use setjmp/longjmp to do exception handling.PS. This is tested on a C++ compiler, but it should be easy to make it work on a C compiler.This has been interesting to read. I have been pondering the same question myself, and the benefits of thinking about it are this:Trying to imagine how to implement OOP concepts in a non-OOP language helps me understand the strengths of the OOp language (in my case, C++). This helps give me better judgement about whether to use C or C++ for a given type of application -- where the benefits of one out-weighs the other.In my browsing the web for information and opinions on this I found an author who was writing code for an embedded processor and only had a C compiler available:\nhttp://www.eetimes.com/discussion/other/4024626/Object-Oriented-C-Creating-Foundation-Classes-Part-1In his case, analyzing and adapting OOP concepts in plain C was a valid pursuit. It appears he was open to sacrificing some OOP concepts due to the performance overhead hit resulting from attempting to implement them in C.The lesson I\'ve taken is, yes it can be done to a certain degree, and yes, there are some good reasons to attempt it.In the end, the machine is twiddling stack pointer bits, making the program counter jump around and calculating memory access operations.  From the efficiency standpoint, the fewer of these calculations done by your program, the better... but sometimes we have to pay this tax simply so we can organize our program in a way that makes it least susceptible to human error. The OOP language compiler strives to optimize both aspects. The programmer has to be much more careful implementing these concepts in a language like C.Check out GObject.  It\'s meant to be OO in C and one implementation of what you\'re looking for.  If you really want OO though, go with C++ or some other OOP language.  GObject can be really tough to work with at times if you\'re used to dealing with OO languages, but like anything, you\'ll get used to the conventions and flow.You may find it helpful to look at Apple\'s documentation for its Core Foundation set of APIs. It is a pure C API, but many of the types are bridged to Objective-C object equivalents.You may also find it helpful to look at the design of Objective-C itself. It\'s a bit different from C++ in that the object system is defined in terms of C functions, e.g. objc_msg_send to call a method on an object. The compiler translates the square bracket syntax into those function calls, so you don\'t have to know it, but considering your question you may find it useful to learn how it works under the hood.There are several techniques that can be used. The most important one is more how to split the project. We use an interface in our project that is declared in a .h file and the implementation of the object in a .c file. The important part is that all modules that include the .h file see only an object as a void *, and the .c file is the only module who knows the internals of the structure.Something like this for a class we name FOO as an example:In the .h fileThe C implementation file will be something like that.So I give the pointer explicitly to an object to every function of that module. A C++ compiler does it implicitly, and in C we write it explicitly out.I really use this in my programs, to make sure that my program does not compile in C++, and it has the fine property of being in another color in my syntax highlighting editor.The fields of the FOO_struct can be modified in one module and another module doesn\'t even need to be recompiled to be still usable.With that style I already handle a big part of the advantages of OOP (data encapsulation). By using function pointers, it\'s even easy to implement something like inheritance, but honestly, it\'s really only rarely useful.Object oriented C, can be done, I\'ve seen that type of code in production in Korea, and it was the most horrible monster I\'d seen in years (this was like last year(2007) that I saw the code).\nSo yes it can be done, and yes people have done it before, and still do it even in this day and age. But I\'d recommend C++ or Objective-C, both are languages born from C, with the purpose of providing object orientation with different paradigms. If you are convinced that an OOP approach is superior for the problem you are trying to solve, why would you be trying to solve it with a non-OOP language? It seems like you\'re using the wrong tool for the job. Use C++ or some other object-oriented C variant language.If you are asking because you are starting to code on an already existing large project written in C, then you shouldn\'t try to force your own (or anyone else\'s) OOP paradigms into the project\'s infrastructure. Follow the guidelines that are already present in the project. In general, clean APIs and isolated libraries and modules will go a long way towards having a clean OOP-ish design.If, after all this, you really are set on doing OOP C, read this (PDF).Yes, you can. People were writing object-oriented C before C++ or Objective-C came on the scene. Both C++ and Objective-C were, in parts, attempts to take some of the OO concepts used in C and formalize them as part of the language.Here\'s a really simple program that shows how you can make something that looks-like/is a method call (there are better ways to do this. This is just proof the language supports the concepts):Of course, it just won\'t be as pretty as using a language with built-in support. I\'ve even written "object-oriented assembler".A little OOC code to add:You can fake it using function pointers, and in fact, I think it is theoretically possible to compile C++ programs into C.However, it rarely makes sense to force a paradigm on a language rather than to pick a language that uses a paradigm.There is an example of inheritance using C in Jim Larson\'s 1996 talk given at the Section 312 Programming Lunchtime Seminar here: High and Low-Level C.Which articles or books are good to use OOP concepts in C?Dave Hanson\'s C Interfaces and Implementations is excellent on encapsulation and naming and very good on use of function pointers.   Dave does not try to simulate inheritance.OOP is only a paradigm which place datas as more important than code in programs. OOP is not a language. So, like plain C is a simple language, OOP in plain C is simple too.One thing you might want to do is look into the implementation of the Xt toolkit for X Window. Sure it is getting long in the tooth, but many of the structures used were designed to work in an OO fashion within traditional C. Generally this means adding an extra layer of indirection here and there and designing structures to lay over each other.You can really do lots in the way of OO situated in C this way, even though it feels like it some times, OO concepts did not spring fully formed from the mind of #include<favorite_OO_Guru.h>. They really constituted many of the established best practice of the time. OO languages and systems only distilled and amplified parts of the programing zeitgeist of the day.I\'ve been digging this for one year:As the GObject system is hard to use with pure C, I tried to write some nice macros to ease the OO style with C.Here is my project site (I don\'t have enough time to write en. doc,however the doc in chinese is much better).OOC-GCCThe answer to the question is \'Yes, you can\'.Object-oriented C (OOC) kit is for those who want to program in an object-oriented manner, but sticks on the good old C as well. OOC implements classes, single and multiple inheritance, exception handling.Features\xe2\x80\xa2 Uses only C macros and functions, no language extensions required! (ANSI-C)\xe2\x80\xa2 Easy-to-read source code for your application. Care was taken to make things as simple as possible.\xe2\x80\xa2 Single inheritance of classes\xe2\x80\xa2 Multiple inheritance by interfaces and mixins (since version 1.3)\xe2\x80\xa2 Implementing exceptions (in pure C!)\xe2\x80\xa2 Virtual functions for classes\xe2\x80\xa2 External tool for easy class implementationFor more details, visit http://ooc-coding.sourceforge.net/.See http://slkpg.byethost7.com/instance.html for yet another twist on OOP in C. It emphasizes instance data for reentrancy using just native C. Multiple inheritance is done manually using function wrappers. Type safety is maintained. Here is a small sample:I\'m a bit late to the party, but I want to share my experience on the topic: I work with embedded stuff these days, and the only (reliable) compiler I have is C, so that I want to apply object-oriented approach in my embedded projects written in C.Most of the solutions I\'ve seen so far use typecasts heavily, so we lose type safety: compiler won\'t help you if you make a mistake. This is completely unacceptable. Requirements that I have:I\'ve explained my approach in detail in this article: Object-oriented programming in C; plus, there is an utility for autogeneration of boilerplate code for base and derived classes.It\'s seem like people are trying emulate the C++ style using C. My take is that doing object-oriented programming C is really doing struct-oriented programming. However, you can achieve things like late binding, encapsulation, and inheritance. For inheritance you explicitly define a pointer to the base structs in your sub struct and this is obviously a form of multiple inheritance. You\'ll also need to determine if yourcompile with c_compiler main.c inherited_class_1.obj inherited_class_2.obj  private_class.obj.So the advice is to stick to a pure C style and not try to force into a C++ style. Also this way lends itself to a very clean way of building an API.I built a little library where I tried that and to me it works real nicely. So I thought I share the experience.https://github.com/thomasfuhringer/oxygenSingle inheritance can be implemented quite easily using a struct and extending it for every other child class. A simple cast to the parent structure makes it possible to use parent methods on all the descendants.\nAs long as you know that a variable points to a struct holding this kind of an object you can always cast to the root class and do introspection.As has been mentioned, virtual methods are somewhat trickier. But they are doable. To keep things simple I just use an array of functions in the class description structure which every child class copies and repopulates individual slots where required.Multiple inheritance would be rather complicated to implement and comes with a significant performance impact. So I leave it. I do consider it desirable and useful in quite a few cases to cleanly model real life circumstances, but in probably 90% of cases single inheritance covers the needs. And single inheritance is simple and costs nothing. Also I do not care about type safety. I think you should not depend on the compiler to prevent you from programming mistakes. And it shields you only from a rather small part of errors anyway.Typically, in an object oriented environment you also want to implement reference counting to automate memory management to the extent possible. So I also put a reference count into the \xe2\x80\x9cObject\xe2\x80\x9d root class and some functionality to encapsulate allocation and deallocation of heap memory.It is all very simple and lean and gives me the essentials of OO without forcing me to deal with the monster that is C++. And I retain the flexibility of staying in C land, which among other things makes it easier to integrate third party libraries.I propose to use Objective-C, which is a superset of C. While Objective-C is 30 years old, it allows to write elegant code.http://en.wikipedia.org/wiki/Objective-CYes, but I have never seen anyone attempt to implement any sort of polymorphism with C.