Here is the code compiled in dev c++ windows:I expect x to be 6 after executing note 1. However, the output is:Can anyone explain why x does not increment after note 1?From the C99 Standard (the emphasis is mine)6.5.3.4/2The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand. The result is an integer. If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant.sizeof is a compile-time operator, so at the time of compilation sizeof and its operand get replaced by the result value. The operand is not evaluated (except when it is a variable length array) at all; only the type of the result matters.Output:as short occupies 2 bytes on my machine.Changing the return type of the function to double:will give 8 as output.sizeof(foo) tries really hard to discover the size of an expression at compile time:6.5.3.4:The sizeof operator yields the size (in bytes) of its operand, which may be an\n  expression or the parenthesized name of a type. The size is determined from the type of\n  the operand. The result is an integer. If the type of the operand is a variable length array\n  type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an\n  integer constant.In short: variable length arrays, run at runtime. (Note: Variable Length Arrays are a specific feature -- not arrays allocated with malloc(3).) Otherwise, only the type of the expression is computed, and that at compile time.sizeof is a compile-time builtin operator and is not a function. This becomes very clear in the cases you can use it without the parenthesis:NoteThis answer was merged from a duplicate, which explains the late date.OriginalExcept for variable length arrays sizeof does not evaluate its arguments. We can see this from the draft C99 standard section 6.5.3.4 The sizeof operator paragraph 2 which says:The sizeof operator yields the size (in bytes) of its operand, which may be an\n  expression or the parenthesized name of a type. The size is determined from the type of\n  the operand. The result is an integer. If the type of the operand is a variable length array\n  type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an\n  integer constant.A comment(now removed) asked whether something like this would evaluate at run-time:and indeed it would, something like this would also work (See them both live):since they are both variable length arrays. Although, I don\'t see much practical use in either one.Note, variable length arrays are covered in the draft C99 standard section 6.7.5.2 Array declarators paragraph 4:[...] If the size is an integer constant expression and the element type has a known constant size, the array type is not a variable length array type; otherwise, the array type is a variable length array type.UpdateIn C11 the answer changes for the VLA case, in certain cases it is unspecified whether the size expression is evaluated or not. From section 6.7.6.2 Array declarators which says:[...]Where a size expression is part of the operand of a sizeof\n  operator and changing the value of the size expression would not\n  affect the result of the operator, it is unspecified whether or not\n  the size expression is evaluated.For example in a case like this (see it live):As the operand of sizeof operator is not evaluated, you can do this:Online demo : http://ideone.com/S8e2YThat is, you don\'t need define the function f if it is used in sizeof only. This technique is mostly used in C++ template metaprogramming, as even in C++, the operand of sizeof is not evaluated.Why does this work? It works because the sizeof operator doesn\'t operate on value, instead it operates on type of the expression. So when you write sizeof(f()), it operates on the type of the expression f(), and which is nothing but the return type of the function f. The return type is always same, no matter what value the function would return if it actually executes.In C++, you can even this:Yet it looks like, in sizeof, I\'m first creating an instance of A, by writing A(), and then calling the function f on the instance, by writing A().f(), but no such thing happens.Demo : http://ideone.com/egPMiHere is another topic which explains some other interesting properties of sizeof:The execution cannot happen during compilation. So ++i/i++ will not happen. Also sizeof(foo()) will not execute the function but return correct type.sizeof() operator gives size of the data-type only, it does not evaluate inner elements.