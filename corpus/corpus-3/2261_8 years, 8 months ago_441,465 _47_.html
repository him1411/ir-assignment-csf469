Obviously, you can use the | (pipe?) to represent OR, but is there a way to represent AND as well?Specifically, I\'d like to match paragraphs of text that contain ALL of a certain phrase, but in no particular order.Use a non-consuming regular expression.The typical (i.e. Perl/Java) notation is:(?=expr)This means "match expr but after that continue matching at the original match-point."  You can do as many of these as you want, and this will be an "and."  Example:(?=match this expression)(?=match this too)(?=oh, and this)You can even add capture groups inside the non-consuming expressions if you need to save some of the data therein.You need to use lookahead as some of the other responders have said, but the lookahead has to account for other characters between its target word and the current match position.  For example:The .* in the first lookahead lets it match however many characters it needs to before it gets to "word1".  Then the match position is reset and the second lookahead seeks out "word2".  Reset again, and the final part matches "word3"; since it\'s the last word you\'re checking for, it isn\'t necessary that it be in a lookahead, but it doesn\'t hurt.In order to match a whole paragraph, you need to anchor the regex at both ends and add a final .* to consume the remaining characters.  Using Perl-style notation, that would be:The \'m\' modifier is for multline mode; it lets the ^ and $ match at paragraph boundaries ("line boundaries" in regex-speak).  It\'s essential in this case that you not use the \'s\' modifier, which lets the dot metacharacter match newlines as well as all other characters.  Finally, you want to make sure you\'re matching whole words and not just fragments of longer words, so you need to add word boundaries:You can do that with a regular expression but probably you\'ll want to some else. For example  use several regexp and combine them in a if clause. You can enumerate all possible permutations with a standard regexp, like this (matches a, b and c in any order):However, this makes a very long and probably inefficient regexp, if you have more than couple terms.If you are using some extended regexp version, like Perl\'s or Java\'s, they have better ways to do this. Other answers have suggested using positive lookahead operation.Look at this example:We have 2 regexps A and B and we want to match both of them, so in pseudo-code it looks like this:It can be written without using the AND operator like this:in PCRE:The AND operator is implicit in the RegExp syntax.\nThe OR operator has instead to be specified with a pipe.\nThe following RegExp:means the letter a AND the letter b.\nIt also works with groups:it means the group co AND the group de.\nReplacing the (implicit) AND with an OR would require the following lines:Why not use awk?\nwith awk regex AND, OR matters is so simpleIs it not possible in your case to do the AND on several matching results? in pseudocodeIf you use Perl regular expressions, you can use positive lookahead:For examplewould be numbers greater than 100 and divisible by 5You could pipe your output to another regex.  Using grep, you could do this:grep A | grep BIn adition to the accepted answer I will provide you with some practical examples that will get thing more clear to some of You. For example let say We have those three lines of text:See demo here DEMOWhat We want to do here is to select the + sign ... but only if it is after two numbers with space and if it is before four numbers. Those are the only constraints. We would use this regular expresion to achiwe it:Note if you separe the expresion it will give you different results. Or perhaps you want to select some text between tags... but not tags! Than you could use:for this text: See demo here DEMOUse AND outside the regular expression. In PHP lookahead operator did not not seem to work for me, instead I used thisThe above regex will match if the password length is 3 characters or more and there are no spaces in the password.The simplest way to do this is probably just to use two regular expressions joined with the and logical operator provided by your language. In Perl syntax, that would look like:If you want to do the same thing in a single regular expression, you could always look for "phrase 1 followed by phrase 2" OR "phrase 2 followed by phrase 1"That would get really complicated if you start adding phrases, though, so I wouldn\'t recommend it for longer lists of words and phrases.The order is always implied in the structure of the regular expression. To accomplish what you want, you\'ll have to match the input string multiple times against different expressions.What you want to do is not possible with a single regexp.