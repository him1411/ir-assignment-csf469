Web applications that want to force a resource to be downloaded rather than directly rendered in a Web browser issue a Content-Disposition header in the HTTP response of the form:Content-Disposition: attachment; filename=FILENAMEThe filename parameter can be used to suggest a name for the file into which the resource is downloaded by the browser. RFC 2183 (Content-Disposition), however, states in section 2.3 (The Filename Parameter) that the file name can only use US-ASCII characters:Current [RFC 2045] grammar restricts\n  parameter values (and hence\n  Content-Disposition filenames) to\n  US-ASCII.  We recognize the great\n  desirability of allowing arbitrary\n  character sets in filenames, but it is\n  beyond the scope of this document to\n  define the necessary mechanisms.There is empirical evidence, nevertheless, that most popular Web browsers today seem to permit non-US-ASCII characters yet (for the lack of a standard) disagree on the encoding scheme and character set specification of the file name. Question is then, what are the various schemes and encodings employed by the popular browsers if the file name \xe2\x80\x9cna\xc3\xafvefile\xe2\x80\x9d (without quotes and where the third letter is U+00EF) needed to be encoded into the Content-Disposition header?For the purpose of this question, popular browsers being:There is discussion of this, including links to browser testing and backwards compatibility, in the proposed RFC 5987, "Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters."RFC 2183 indicates that such headers should be encoded according to RFC 2184, which was obsoleted by RFC 2231, covered by the draft RFC above.I know this is an old post but it is still very relevant. I have found that modern browsers support rfc5987, which allows utf-8 encoding, percentage encoded (url-encoded). Then Na\xc3\xafve file.txt becomes:Safari (5) does not support this. Instead you should use the Safari standard of writing the file name directly in your utf-8 encoded header:IE8 and older don\'t support it either and you need to use the IE standard of utf-8 encoding, percentage encoded:In ASP.Net I use the following code:I tested the above using IE7, IE8, IE9, Chrome 13, Opera 11, FF5, Safari 5.Update November 2013:Here is the code I currently use. I still have to support IE8, so I cannot get rid of the first part. It turns out that browsers on Android use the built in Android download manager and it cannot reliably parse file names in the standard way.The above now tested in IE7-11, Chrome 32, Opera 12, FF25, Safari 6, using this filename for download: \xe4\xbd\xa0\xe5\xa5\xbdabcABC\xc3\xa6\xc3\xb8\xc3\xa5\xc3\x86\xc3\x98\xc3\x85\xc3\xa4\xc3\xb6\xc3\xbc\xc3\xaf\xc3\xab\xc3\xaa\xc3\xae\xc3\xa2\xc3\xa9\xc3\xad\xc3\xa1\xc3\xb3\xc3\xba\xc3\xbd\xc3\xb1\xc2\xbd\xc2\xa7!#\xc2\xa4%&()=`@\xc2\xa3$\xe2\x82\xac{[]}+\xc2\xb4\xc2\xa8^~\'-_,;.txtOn IE7 it works for some characters but not all. But who cares about IE7 nowadays?This is the function I use to generate safe file names for Android. Note that I don\'t know which characters are supported on Android but that I have tested that these work for sure:@TomZ: I tested in IE7 and IE8 and it turned out that I did not need to escape apostrophe (\'). Do you have an example where it fails?@Dave Van den Eynde: Combining the two file names on one line as according to RFC6266 works except for Android and IE7+8 and I have updated the code to reflect this. Thank you for the suggestion.@Thilo: No idea about GoodReader or any other non-browser. You might have some luck using the Android approach.@Alex Zhukovskiy: I don\'t know why but as discussed on Connect it doesn\'t seem to work terribly well.There is no interoperable way to encode non-ASCII names in Content-Disposition. Browser compatibility is a mess.The theoretically correct syntax for use of UTF-8 in Content-Disposition is very weird: filename*=UTF-8\'\'foo%c3%a4 (yes, that\'s an asterisk, and no quotes except an empty single quote in the middle)This header is kinda-not-quite-standard (HTTP/1.1 spec acknowledges its existence, but doesn\'t require clients to support it).There is a simple and very robust alternative: use a URL that contains the filename you want.When the name after the last slash is the one you want, you don\'t need any extra headers!This trick works:And if your server supports URL rewriting (e.g. mod_rewrite in Apache) then you can fully hide the script part.Characters in URLs should be in UTF-8, urlencoded byte-by-byte:RFC 6266 describes the \xe2\x80\x9cUse of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)\xe2\x80\x9d. Quoting from that:6. Internationalization ConsiderationsThe \xe2\x80\x9cfilename*\xe2\x80\x9d parameter (Section 4.3), using the encoding defined\n  in [RFC5987], allows the server to transmit characters outside the\n  ISO-8859-1 character set, and also to optionally specify the language\n  in use.And in their examples section:This example is the same as the one above, but adding the "filename"\n  parameter for compatibility with user agents not implementing\n  RFC 5987:Note: Those user agents that do not support the RFC 5987 encoding\n  ignore \xe2\x80\x9cfilename*\xe2\x80\x9d when it occurs after \xe2\x80\x9cfilename\xe2\x80\x9d.In Appendix D there is also a long list of suggestions to increase interoperability. It also points at a site which compares implementations. Current all-pass tests suitable for common file names include:That RFC 5987 in turn references RFC 2231, which describes the actual format. 2231 is primarily for mail, and 5987 tells us what parts may be used for HTTP headers as well. Don\'t confuse this with MIME headers used inside a multipart/form-data HTTP body, which is governed by RFC 2388 (section 4.4 in particular) and the HTML 5 draft.The following document linked from the draft RFC mentioned by Jim in his answer further addresses the question and definitely worth a direct note here:Test Cases for HTTP Content-Disposition header and RFC 2231/2047 Encodingin asp.net mvc2 i use something like this:I guess if you don\'t use mvc(2) you could just encode the filename usingI use the following code snippets for encoding (assuming fileName contains the filename and extension of the file, i.e.: test.txt):PHP:Java:In ASP.NET Web API, I url encode the filename:\nPut you file name in double quotes. Solved the problem for me. Like this:http://kb.mozillazine.org/Filenames_with_spaces_are_truncated_upon_downloadI tested the following code in all major browsers, including older Explorers (via the compatibility mode), and it works well everywhere:If you are using a nodejs backend you can use the following code I found hereI ended up with the following code in my "download.php" script (based on this blogpost and these test cases).This uses the standard way of filename="..." as long as there are only iso-latin1 and "safe" characters used; if not, it adds the filename*=UTF-8\'\' url-encoded way. According to this specific test case, it should work from MSIE9 up, and on recent FF, Chrome, Safari; on lower MSIE version, it should offer filename containing the ISO8859-1 version of the filename, with underscores on characters not in this encoding.Final note: the max. size for each header field is 8190 bytes on apache. UTF-8 can be up to four bytes per character; after rawurlencode, it is x3 = 12 bytes per one character. Pretty inefficient, but it should still be theoretically possible to have more than 600 "smiles" %F0%9F%98%81 in the filename.In PHP this did it for me (assuming the filename is UTF8 encoded):Tested against IE8-11, Firefox and Chrome.\nIf the browser can interpret filename*=utf-8 it will use the UTF8 version of the filename, else it will use the decoded filename. If your filename contains characters that can\'t be represented in ISO-8859-1 you might want to consider using iconv instead.Most modern browsers support passing the Filename as UTF-8 now but as was the case with a File Upload solution I use that was based on FreeASPUpload.Net (site no longer exists, link points to archive.org) it wouldn\'t work as the parsing of the binary relied on reading single byte ASCII encoded strings, which worked fine when you passed UTF-8 encoded data until you get to characters ASCII doesn\'t support.However I was able to find a solution to get the code to read and parse the binary as UTF-8.Credit goes to Pure ASP File Upload by implementing the BytesToString() function from include_aspuploader.asp in my own code I was able to get UTF-8 filenames working.Multipart/form-data and UTF-8 in a ASP Classic applicationUnicode, UTF, ASCII, ANSI format differencesWe had a similar problem in a web application, and ended up by reading the filename from the HTML <input type="file">, and setting that in the url-encoded form  in a new HTML <input type="hidden">. Of course we had to remove the path like "C:\\fakepath\\" that is returned by some browsers. Of course this does not directly answer OPs question, but may be a solution for others.I normally URL-encode (with %xx) the filenames, and it seems to work in all browsers. You might want to do some tests anyway.I found out solution, that works for all my browsers (ie. all browsers I have installed - IE8, FF16, Opera 12, Chrome 22).My solution is described in other thread:\nJava servlet download filename special charactersMy solution is based on the fact, how browsers trying to read value from filename parameter. If there is no charset specified in the filename parameter (for example filename*=utf-8\'\'test.xml) browsers expect that value is encoded in browser\'s native encoding. Different browsers expect diffrent native encoding. Usually browser\'s native encoding is utf-8 (FireFox, Opera, Chrome). But IE\'s native encoding is Win-1250. (I don\'t know anything about other browsers.)Hence, if we put value into filename parametr, that is encoded by utf-8/win-1250 according to user\'s browser, it should work. At least, it works for me.In short, if we have file named om\xc3\xa1\xc4\x8dka.xml,\nfor FireFox, Opera and Chrome I response this header (encoded in utf-8):and for IE I response this header (encoded in win-1250):Java example is in my post that is mentioned above.