I tend to use before blocks to set instance variables. I then use those variables across my examples.  I recently came upon let(). According to RSpec docs, it is used to... to define a memoized helper method. The value will be cached across multiple calls in the same example but not across examples.How is this different from using instance variables in before blocks? And also when should you use let() vs before()?I always prefer let to an instance variable for a couple of reasons:The difference between using instances variables and let() is that let() is lazy-evaluated. This means that let() is not evaluated until the method that it defines is run for the first time.The difference between before and let is that let() gives you a nice way of defining a group of variables in a \'cascading\' style. By doing this, the spec looks a little better by simplifying the code.I have completely replaced all uses of instance variables in my rspec tests to use let(). I\'ve written a quickie example for a friend who used it to teach a small Rspec class: http://ruby-lambda.blogspot.com/2011/02/agile-rspec-with-let.htmlAs some of the other answers here says, let() is lazy evaluated so it will only load the ones that require loading. It DRYs up the spec and make it more readable. I\'ve in fact ported the Rspec let() code to use in my controllers, in the style of inherited_resource gem. http://ruby-lambda.blogspot.com/2010/06/stealing-let-from-rspec.htmlAlong with lazy evaluation, the other advantage is that, combined with ActiveSupport::Concern, and the load-everything-in spec/support/ behavior, you can create your very own spec mini-DSL specific to your application. I\'ve written ones for testing against Rack and RESTful resources. The strategy I use is Factory-everything (via Machinist+Forgery/Faker). However, it is possible to use it in combination with before(:each) blocks to preload factories for an entire set of example groups, allowing the specs to run faster: http://makandra.com/notes/770-taking-advantage-of-rspec-s-let-in-before-blocksIt is important to keep in mind that let is lazy evaluated and not putting side-effect methods in it otherwise you would not be able to change from let to before(:each) easily.\nYou can use let! instead of let so that it is evaluated before each scenario.In general, let() is a nicer syntax, and it saves you typing @name symbols all over the place. But, caveat emptor! I have found let() also introduces subtle bugs (or at least head scratching) because the variable doesn\'t really exist until you try to use it... Tell tale sign: if adding a puts after the let() to see that the variable is correct allows a spec to pass, but without the puts the spec fails -- you have found this subtlety.I have also found that let() doesn\'t seem to cache in all circumstances! I wrote it up in my blog: http://technicaldebt.com/?p=1242Maybe it is just me?let is functional as its essentially a Proc. Also its cached. One gotcha I found right away with let... In a Spec block that is evaluating a change. You\'ll need to be sure to call let outside of your expect block. i.e. you\'re calling FactoryGirl.create in your let block. I usually do this by verifying the object is persisted. Otherwise when the let block is called the first time a change in the database will actually happen due to the lazy instantiation.UpdateJust adding a note. Be careful playing code golf or in this case rspec golf with this answer. In this case, I just have to call some method to which the object responds. So I invoke the .persisted? method on the object as its truthy. All I\'m trying to do is instantiate the object. You could call empty? or nil? too. The point isn\'t the test but bringing the object ot life by calling it. So you can\'t refactor to beas the object hasn\'t been instantiated... its lazy. :)Update 2leverage the let! syntax for instant object creation, which should avoid this issue altogether. Note though it will defeat a lot of the purpose of the laziness of the non banged let.Also in some instances you might actually want to leverage the subject syntax instead of let as it may give you additional options.Note to Joseph -- if you are creating database objects in a before(:all) they won\'t be captured in a transaction and you\'re much more likely to leave cruft in your test database.  Use before(:each) instead.The other reason to use let and its lazy evaluation is so you can take a complicated object and test individual pieces by overriding lets in contexts, as in this very contrived example:"before" by default implies before(:each). Ref The Rspec Book, copyright 2010, page 228.I use before(:each) to seed some data for each example group without having to call the "let" method to create the data in the "it" block. Less code in the "it" block in this case.I use "let" if I want some data in some examples but not others. Both before and let are great for DRYing up the "it" blocks.To avoid any confusion, "let" is not the same as before(:all). "Let" re-evaluates its method and value for each example ("it"), but caches the value across multiple calls in the same example. You can read more about it here: https://www.relishapp.com/rspec/rspec-core/v/2-6/docs/helper-methods/let-and-let 