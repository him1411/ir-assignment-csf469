Java requires that if you call this() or super() in a constructor, it must be the first statement. Why?For example:The Sun compiler says "call to super must be first statement in constructor". The Eclipse compiler says "Constructor call must be the first statement in a constructor".However, you can get around this by re-arranging the code a little bit:Here is another example:So, it is not stopping you from executing logic before the call to super. It is just stopping you from executing logic that you can\'t fit into a single expression.There are similar rules for calling this(). The compiler says "call to this must be first statement in constructor".Why does the compiler have these restrictions? Can you give a code example where, if the compiler did not have this restriction, something bad would happen?The parent class\' constructor needs to be called before the subclass\' constructor. This will ensure that if you call any methods on the parent class in your constructor, the parent class has already been set up correctly.What you are trying to do, pass args to the super constructor is perfectly legal, you just need to construct those args inline as you are doing, or pass them in to your constructor and then pass them to super:If the compiler did not enforce this you could do this:In cases where a parent class has a default constructor the call to super is inserted for you automatically by the compiler. Since every class in Java inherits from Object, objects constructor must be called somehow and it must be executed first. The automatic insertion of super() by the compiler allows this. Enforcing super to appear first, enforces that constructor bodies are executed in the correct order which would be: Object -> Parent -> Child -> ChildOfChild -> SoOnSoForthI\'ve found a way around this by chaining constructors and static methods.  What I wanted to do looked something like this:So basically construct an object based on constructor parameters, store the object in  a member, and also pass the result of a method on that object into super\'s constructor.  Making the member final was also reasonably important as the nature of the class is that it\'s immutable.  Note that as it happens, constructing Bar actually takes a few intermediate objects, so it\'s not reducible to a one-liner in my actual use case.I ended up making it work something like this:Legal code, and it accomplishes the task of executing multiple statements before calling the super constructor.Because the JLS says so. Could the JLS be changed in a compatible manner to allow it? Yup. However, it would complicate the language spec, which is already more than complicated enough. It wouldn\'t be a highly useful thing to do and there are ways around it (call another constructor with the result of a method this(fn()) - the method is called before the other constructor, and hence also the super constructor). So the power to weight ratio of doing the change is unfavourable.I am fairly sure (those familiar with the Java Specification chime in) that it is to prevent you from (a) being allowed to use a partially-constructed object, and (b), forcing the parent class\'s constructor to construct on a "fresh" object.Some examples of a "bad" thing would be:You asked why, and the other answers, imo, don\'t really say why it\'s ok to call your super\'s constructor, but only if it\'s the very first line. The reason is that you\'re not really calling the constructor. In C++, the equivalent syntax isWhen you see the initializer clause on its own like that, before the open brace, you know it\'s special. It runs before any of the rest of the constructor runs and in fact before any of the member variables are initialized. It\'s not that different for Java. There\'s a way to get some code (other constructors) to run before the constructor really starts, before any members of the subclass are initialized. And that way is to put the "call" (eg super) on the very first line. (In a way, that super or this is kind of before the first open brace, even though you type it after, because it will be executed before you get to the point that everything is fully constructed.) Any other code after the open brace (like int c = a + b;) makes the compiler say "oh, ok, no other constructors, we can initialize everything then." So it runs off and initializes your super class and your members and whatnot and then starts executing the code after the open brace. If, a few lines later, it meets some code saying "oh yeah when you\'re constructing this object, here are the parameters I want you to pass along to the constructor for the base class", it\'s too late and it doesn\'t make any sense. So you get a compiler error.Simply because this is the inheritance philosophy. And according to the Java language specification,  this is how the constructor\'s body is defined:ConstructorBody:\n        { ExplicitConstructorInvocationopt    BlockStatementsopt }The first statement of a constructor body may be:\n-an explicit invocation of another constructor of the same class (by using the keyword "this") OR \n-of the direct superclass (by using the keyword "super")If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class Object, then the constructor body implicitly begins with a superclass constructor invocation "super();", an invocation of the constructor of its direct superclass that takes no arguments. And so on.. there will be a whole chain of constructors called all the way back to the constructor of Object; "All Classes in the Java platform are Descendants of Object". This thing is called "Constructor Chaining".Now why is this?\nAnd the reason why Java defined the ConstructorBody in this way, is that they needed to maintain the hierarchy of the object. Remember the definition of the inheritance; It\'s extending a class. With that being said, you cannot extend something that doesn\'t exist. The base (the superclass) needs to be created first, then you can derive it (the subclass). That\'s why they called them Parent and Child classes; you can\'t have a child without a parent. On a technical level, a subclass inherits all the members (fields, methods, nested classes) from its parent. And since Constructors are NOT members (They don\'t belong to objects. They are responsible of creating objects) so they are NOT inherited by subclasses, but they can be invoked. And since at the time of object creation only ONE constructor is executed. So how do we guarantee the creation of the superclass when you create the subclass object? Thus the concept of "constructor chaining"; so we have the ability to invoke other constructors (i.e. super) from within the current constructor. And Java required this invocation to be the FIRST line in the subclass constructor to maintain the hierarchy and guarantee it. They assume that if you don\'t explicitly create the parent object FIRST (like if you forgot about it), they will do it implicitly for you. This check is done during compilation. But I\'m not sure what would happen on runtime, what kind of runtime error we would get, IF Java doesn\'t throw a compile-error when we explicitly try to execute a base constructor from within a subclass\'s constructor in the middle of its body and not from the very first line ... I totally agree, the restrictions are too strong. Using a static helper method (as Tom Hawtin - tackline suggested) or shoving all "pre-super() computations" into a single expression in the parameter is not always possible, e.g.:Using an "object not yet constructed" exception, as Carson Myers suggested, would help, but checking this during each object construction would slow down execution. I would favor a Java compiler that makes a better differentiation (instead of inconsequently forbidding an if-statement but allowing the ?-operator within the parameter), even if this complicates the language spec.So, it is not stopping you from executing logic before the call to\n  super. It is just stopping you from executing logic that you can\'t fit\n  into a single expression.Actually you can execute logic with several expessions, you just have to wrap your code in a static function and call it in the super statement.Using your example:You can use anonymous initializer blocks to initialize fields in the child before calling it\'s constructor. This example will demonstrate :This will output :In parent  \n  In initializer \n  In child My guess is they did this to make life easier for people writing tools that process Java code, and to some lesser degree also people who are reading Java code.If you allow the super() or this() call to move around, there are more variations to check for.  For example if you move the super() or this() call into a conditional if() it might have to be smart enough to insert an implicit super() into the else.  It might need to know how to report an error if you call super() twice, or use super() and this() together.  It might need to disallow method calls on the receiver until super() or this() is called and figuring out when that is becomes complicated.Making everyone do this extra work probably seemed like a greater cost than benefit.I found a woraround.This won\'t compile :This works :The other answers have tackled the "why" of the question. I\'ll provide a hack around this limitation:The basic idea is to hijack the super statement with your embedded statements. This can be done by disguising your statements as expressions.Consider we want to do Statement1() to Statement9() before we call super():The compiler will of course reject our code. So instead, we can do this:The only limitation is that the parent class must have a constructor which takes in at least one argument so that we can sneak in our statement as an expression.Here is a more elaborate example:Reworked into:In fact, compilers could have automated this process for us. They\'d just chosen not to.Before you can construct child object your parent object has to be created.\nAs you know when you write class like this:it turns to the next (extend and super are just hidden):First we create an Object and then extend this object to MyClass. We can not create MyClass before the Object.\nThe simple rule is that parent\'s constructor has to be called before child constructor.\nBut we know that classes can have more that one constructor. Java allow us to choose a constructor which will be called (either it will be super() or super(yourArgs...)).\nSo, when you write super(yourArgs...) you redefine constructor which will be called to create a parent object. You can\'t execute other methods before super() because the object doesn\'t exist yet (but after super() an object will be created and you will be able to do anything you want).So why then we cannot execute this() after any method?\nAs you know this() is the constructor of the current class. Also we can have different number of constructors in our class and call them like this() or this(yourArgs...). As I said every constructor has hidden method super(). When we write our custom super(yourArgs...) we remove super() with super(yourArgs...). Also when we define this() or this(yourArgs...) we also remove our super() in current constructor because if super() were with this() in the same method, it would create more then one parent object.\nThat is why the same rules imposed for this() method. It just retransmits parent object creation to another child constructor and that constructor calls super() constructor for parent creation.\nSo, the code will be like this in fact:As others say you can execute code like this:also you can execute code like this:But you can\'t execute code like this because your method doesn\'t exists yet:Also you are obliged to have super() constructor in your chain of this() methods. You can\'t have an object creation like this:See the example if we are calling the constructor C(int x) then value of z is depend on y if we do not call C() in the first line then it will be the problem for z. z would not be able to get correct value.It makes sense that constructors complete their execution in order of\n  derivation. Because a superclass has no knowledge of any subclass, any\n  initialization it needs to perform is separate from and possibly\n  prerequisite to any initialization performed by the subclass.\n  Therefore, it must complete its execution first.A simple demonstration:The output from this program is:I know I am a little late to the party, but I\'ve used this trick a couple of times (and I know it\'s a bit unusual):I create an generic interface InfoRunnable<T> with one method:And if I need to do something before passing it to the constructor I just do this: