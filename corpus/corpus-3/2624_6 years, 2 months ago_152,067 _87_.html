This question is not for the discussion of whether or not the singleton design pattern is desirable, is an anti-pattern, or for any religious wars, but to discuss how this pattern is best implemented in Python in such a way that is most pythonic. In this instance I define \'most pythonic\' to mean that it follows the \'principle of least astonishment\'.I have multiple classes which would become singletons (my use-case is for a logger, but this is not important). I do not wish to clutter several classes with added gumph when I can simply inherit or decorate.Best methods:ProsConsProsConsProsConsProsConsI would recommend Method #2, but you\'re better off using a metaclass than a base class. Here is a sample implementation:Or in Python3If you want to run __init__ every time the class is called, addto the if statement in Singleton.__call__.A few words about metaclasses. A metaclass is the class of a class; that is, a class is an instance of its metaclass. You find the metaclass of an object in Python with type(obj). Normal new-style classes are of type type. Logger in the code above will be of type class \'your_module.Singleton\', just as the (only) instance of Logger will be of type class \'your_module.Logger\'. When you call logger with Logger(), Python first asks the metaclass of Logger, Singleton, what to do, allowing instance creation to be pre-empted. This process is the same as Python asking a class what to do by calling __getattr__ when you reference one of it\'s attributes by doing myclass.attribute.A metaclass essentially decides what the definition of a class means and how to implement that definition. See for example http://code.activestate.com/recipes/498149/, which essentially recreates C-style structs in Python using metaclasses. The thread What are your (concrete) use-cases for metaclasses in Python? also provides some examples, they generally seem to be related to declarative programming, especially as used in ORMs.In this situation, if you use your Method #2, and a subclass defines a __new__ method, it will be executed every time you call SubClassOfSingleton() -- because it is responsible for calling the method that returns the stored instance. With a metaclass, it will only be called once, when the only instance is created. You want to customize what it means to call the class, which is decided by it\'s type.In general, it makes sense to use a metaclass to implement a singleton. A singleton is special because is created only once, and a metaclass is the way you customize the creation of a class. Using a metaclass gives you more control in case you need to customize the singleton class definitions in other ways.Your singletons won\'t need multiple inheritance (because the metaclass is not a base class), but for subclasses of the created class that use multiple inheritance, you need to make sure the singleton class is the first / leftmost one with a metaclass that redefines __call__ This is very unlikely to be an issue. The instance dict is not in the instance\'s namespace so it won\'t accidentally overwrite it.You will also hear that the singleton pattern violates the "Single Responsibility Principle" -- each class should do only one thing. That way you don\'t have to worry about messing up one thing the code does if you need to change another, because they are separate and encapsulated. The metaclass implementation passes this test. The metaclass is responsible for enforcing the pattern and the created class and subclasses need not be aware that they are singletons. Method #1 fails this test, as you noted with "MyClass itself is a a function, not a class, so you cannot call class methods from it."Writing something that works in both Python2 and 3 requires using a slightly more complicated scheme. Since metaclasses are usually subclasses of type type, it\'s possible to use one to dynamically create an intermediary base class at run time with it as its metaclass and then use that as the baseclass of the public Singleton base class. It\'s harder to explain than to do, as illustrated next:An ironic aspect of this approach is that it\'s using subclassing to implement a metaclass. One possible advantage is that, unlike with a pure metaclass, isinstance(inst, Singleton) will return True.On another topic, you\'ve probably already noticed this, but the base class implementation in your original post is wrong. _instances needs to be referenced on the class, you need to use super() or you\'re recursing, and __new__ is actually a static method that you have to pass the class to, not a class method, as the actual class hasn\'t been created yet when it is called. All of these things will be true for a metaclass implementation as well.I originally was writing a comment but it was too long, so I\'ll add this here. Method #4 is better than the other decorator version, but it\'s more code than needed for a singleton, and it\'s not as clear what it does. The main problems stem from the class being it\'s own base class. First, isn\'t it weird to have a class be a subclass of a nearly identical class with the same name that exists only in its __class__ attribute? This also means that you can\'t define any methods that call the method of the same name on their base class with super() because they will recurse. This means your class can\'t customize __new__, and can\'t derive from any classes that need __init__ called on them.Your use case is one of the better examples of wanting to use a singleton. You say in one of the comments "To me logging has always seemed a natural candidate for Singletons." You\'re absolutely right.When people say singletons are bad, the most common reason is they are implicit shared state. While with global variables and top-level module imports are explicit shared state, other objects that are passed around are generally instantiated. This is a good point, with two exceptions.The first, and one that gets mentioned in various places, is when the singletons are constant. Use of global constants, especially enums, is widely accepted, and considered sane because no matter what, none of the users can mess them up for any other user. This is equally true for a constant singleton.The second exception, which get mentioned less, is the opposite -- when the singleton is only a data sink, not a data source (directly or indirectly). This is why loggers feel like a "natural" use for singletons. As the various users are not changing the loggers in ways other users will care about, there is not really shared state. This negates the primary argument against the singleton pattern, and makes them a reasonable choice because of their ease of use for the task.Here is a quote from http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html:Now, there is one kind of Singleton which is OK. That is a singleton where all of the reachable objects are immutable. If all objects are immutable than Singleton has no global state, as everything is constant. But it is so easy to turn this kind of singleton into mutable one, it is very slippery slope. Therefore, I am against these Singletons too, not because they are bad, but because it is very easy for them to go bad. (As a side note Java enumeration are just these kind of singletons. As long as you don\'t put state into your enumeration you are OK, so please don\'t.)The other kind of Singletons, which are semi-acceptable are those which don\'t effect the execution of your code, They have no "side effects". Logging is perfect example. It is loaded with Singletons and global state. It is acceptable (as in it will not hurt you) because your application does not behave any different whether or not a given logger is enabled. The information here flows one way: From your application into the logger. Even thought loggers are global state since no information flows from loggers into your application, loggers are acceptable. You should still inject your logger if you want your test to assert that something is getting logged, but in general Loggers are not harmful despite being full of state.Modules are imported only once, everything else is overthinking. Don\'t use singletons and try not to use globals.Use a module. It is imported only once. Define some global variables in it - they will be singleton\'s \'attributes\'. Add some functions - the singleton\'s \'methods\'.You probably never need a singleton in Python. Just define all your data and functions in a module and you have a de-facto singleton.If you really absolutely have to have a singleton class then I\'d go with:To use:where mysingleton.py is your filename that My_Singleton is defined in. This works because after the first time a file is imported, Python doesn\'t re-execute the code.Here\'s a one-liner for you:Here\'s how you use it:Your object gets instantiated eagerly.  This may or may not be what you want.Check out Stack Overflow question Is there a simple, elegant way to define singletons in Python? with several solutions.I\'d strongly recommend to watch Alex Martelli\'s talks on design patterns in python: part 1 and part 2. In particular, in part 1 he talks about singletons/shared state objects.Here\'s my own implementation of singletons. All you have to do is decorate the class; to get the singleton, you then have to use the Instance method. Here\'s an example:And here\'s the code:How about this:Use it as a decorator on a class that should be a singleton. Like this:This is similar to the singleton = lambda c: c() decorator in another answer. Like the other solution, the only instance has name of the class (MySingleton).  However, with this solution you can still "create" instances (actually get the only instance) from the class, by doing MySingleton(). It also prevents you from creating additional instances by doing type(MySingleton)() (that also returns the same instance).Method 3 seems to be very neat, but if you want your program to run in both Python 2 and Python 3, it doesn\'t work. Even protecting the separate variants with tests for the Python version fails, because the Python 3 version gives a syntax error in Python 2.Thanks to Mike Watkins: http://mikewatkins.ca/2008/11/29/python-2-and-3-metaclasses/. If you want the program to work in both Python 2 and Python 3, you need to do something like:I presume that \'object\' in the assignment needs to be replaced with the \'BaseClass\', but I haven\'t tried that (I have tried code as illustrated).Well, other than agreeing with the general Pythonic suggestion on having module-level global, how about this:Output is:I can\'t remember where I found this solution, but I find it to be the most \'elegant\' from my non-Python-expert point of view:Why do I like this?  No decorators, no meta classes, no multiple inheritance...and if you decide you don\'t want it to be a Singleton anymore, just delete the __new__ method.  As I am new to Python (and OOP in general) I expect someone will set me straight about why this is a terrible approach?Code based on Tolli\'s answer.Explanation:Create new class, inheriting from given cls\n(it doesn\'t modify cls in case someone wants for example singleton(list))Create instance. Before overriding __new__ it\'s so easy.The function returns instance only when it\'s what the caller expects, otherwise raises TypeError.\nThe condition is not met when someone attempts to inherit from decorated class.If __new__() returns an instance of cls, then the new instance\xe2\x80\x99s __init__() method will be invoked like __init__(self[, ...]), where self is the new instance and the remaining arguments are the same as were passed to __new__().instance is already initialized, so function replaces __init__ with function doing nothing.See it working onlineIt is slightly similar to the answer by fab but not exactly the same.The singleton contract does not require that we be able to call the constructor multiple times.  As a singleton should be created once and once only, shouldn\'t it be seen to be created just once?  "Spoofing" the constructor arguably impairs legibility.So my suggestion is just this:This does not rule out the use of the constructor or the field instance by user code:... if you know for sure that Elvis has not yet been created, and that King has.But it encourages users to use the the method universally:To make this complete you could also override __delattr__() to raise an Exception if an attempt is made to delete instance, and override __del__() so that it raises an Exception (unless we know the program is ending...)My thanks to those who have helped with comments and edits, of which more are welcome. While I use Jython, this should work more generally, and be thread-safe.Points of note:See Google Developers Day US - Python Design Patterns by Alex Martelli. Creational Patterns is at 14 min 38 secs. I\'ll toss mine into the ring. It\'s a simple decorator.Benefits I think it has over some of the other solutions:One downside does occur to me: classmethods and staticmethods of the real class are not transparently callable via the factory class hiding it. I\'ve used this rarely enough that I\'ve never happen to run into that need, but it would be easily rectified by using a custom metaclass on the factory that implements __getattr__() to delegate all-ish attribute access to the real class.A related pattern I\'ve actually found more useful (not that I\'m saying these kinds of things are required very often at all) is a "Unique" pattern where instantiating the class with the same arguments results in getting back the same instance. I.e. a "singleton per arguments". The above adapts to this well and becomes even more concise:All that said, I do agree with the general advice that if you think you need one of these things, you really should probably stop for a moment and ask yourself if you really do. 99% of the time, YAGNI.This is my preferred way of implementing singletons:This answer is likely not what you\'re looking for. I wanted a singleton in the sense that only that object had its identity, for comparison to. In my case it was being used as a Sentinel Value. To which the answer is very simple, make any object mything = object() and by python\'s nature,  only that thing will have its identity.This solution causes some namespace pollution at the module level (three definitions rather than just one), but I find it easy to follow.I\'d like to be able to write something like this (lazy initialization), but unfortunately classes are not available in the body of their own definitions.Since that isn\'t possible, we can break out the initialization and the static instance inEager Initialization:Lazy initialization:Eager Initialization: