Does it matter how many files I keep in a single directory? If so, how many files in a directory is too many, and what are the impacts of having too many files? (This is on a Linux server.)Background: I have a photo album website, and every image uploaded is renamed to an 8-hex-digit id (say, a58f375c.jpg).  This is to avoid filename conflicts (if lots of "IMG0001.JPG" files are uploaded, for example).  The original filename and any useful metadata is stored in a database.  Right now, I have somewhere around 1500 files in the images directory.  This makes listing the files in the directory (through FTP or SSH client) take a few seconds.  But I can\'t see that it has any effect other than that.  In particular, there doesn\'t seem to be any impact on how quickly an image file is served to the user.I\'ve thought about reducing the number of images by making 16 subdirectories: 0-9 and a-f.  Then I\'d move the images into the subdirectories based on what the first hex digit of the filename was.  But I\'m not sure that there\'s any reason to do so except for the occasional listing of the directory through FTP/SSH.I have had over 8 million files in a single ext3 directory.  libc readdir() which is used by find, ls and most of the other methods discussed in this thread to list large directories. The reason ls and find are slow in this case is that readdir() only reads 32K of directory entries at a time, so on slow disks it will require many many reads to list a directory. There is a solution to this speed problem. I wrote a pretty detailed article about it at: http://www.olark.com/spw/2011/08/you-can-list-a-directory-with-8-million-files-but-not-with-ls/The key take away is: use getdents() directly -- http://www.kernel.org/doc/man-pages/online/pages/man2/getdents.2.html rather than anything that\'s based on libc readdir() so you can specify the buffer size when reading directory entries from disk. It depends a bit on the specific filesystem in use on the Linux server. Nowadays the default is ext3 with dir_index, which makes searching large directories very fast.So speed shouldn\'t be an issue, other than the one you already noted, which is that listings will take longer.There is a limit to the total number of files in one directory. I seem to remember it definitely working up to 32000 files. I have a directory with 88,914 files in it. Like yourself this is used for storing thumbnails and on a Linux server.Listed files via FTP or a php function is slow yes, but there is also a performance hit on displaying the file. e.g. www.website.com/thumbdir/gh3hg4h2b4h234b3h2.jpg has a wait time of 200-400 ms. As a comparison on another site I have with a around 100 files in a directory the image is displayed after just ~40ms of waiting.I\'ve given this answer as most people have just written how directory search functions will perform, which you won\'t be using on a thumb folder - just statically displaying files, but will be interested in performance of how the files can actually be used.Keep in mind that on Linux if you have a directory with too many files, the shell may not be able to expand wildcards. I have this issue with a photo album hosted on Linux. It stores all the resized images in a single directory. While the file system can handle many files, the shell can\'t. Example:orI\'m working on a similar problem right now. We have a hierarchichal directory structure and use image ids as filenames. For example, an image with id=1234567 is placed inusing last 4 digits to determine where the file goes.With a few thousand images, you could use a one-level hierarchy. Our sysadmin suggested no more than couple of thousand files in any given directory (ext3) for efficiency / backup / whatever other reasons he had in mind.For what it\'s worth, I just created a directory on an ext4 file system with 1,000,000 files in it, then randomly accessed those files through a web server. I didn\'t notice any premium on accessing those over (say) only having 10 files there.This is radically different from my experience doing this on ntfs a few years back.The biggest issue I\'ve run into is on a 32-bit system. Once you pass a certain number, tools like \'ls\' stop working.Trying to do anything with that directory once you pass that barrier becomes a huge problem.It really depends on the filesystem used, and also some flags.For example, ext3 can have many thousands of files; but after a couple of thousands, it used to be very slow. Mostly when listing a directory, but also when opening a single file.  A few years ago, it gained the \'htree\' option, that dramatically shortened the time needed to get an inode given a filename.Personally, I use subdirectories to keep most levels under a thousand or so items. In your case, I\'d create 256 directories, with the two last hex digits of the ID. Use the last and not the first digits, so you get the load balanced.It absolutely depends on the filesystem. Many modern filesystems use decent data structures to store the contents of directories, but older filesystems often just added the entries to a list, so retrieving a file was an O(n) operation.Even if the filesystem does it right, it\'s still absolutely possible for programs that list directory contents to mess up and do an O(n^2) sort, so to be on the safe side, I\'d always limit the number of files per directory to no more than 500.The question comes down to what you\'re going to do with the files.Under Windows, any directory with more than 2k files tends to open slowly for me in Explorer. If they\'re all image files, more than 1k tend to open very slowly in thumbnail view.At one time, the system-imposed limit was 32,767. It\'s higher now, but even that is way too many files to handle at one time under most circumstances.If the time involved in implementing a directory partitioning scheme is minimal, I am in favor of it.  The first time you have to debug a problem that involves manipulating a 10000-file directory via the console you will understand.As an example, F-Spot stores photo files as YYYY\\MM\\DD\\filename.ext, which means the largest directory I have had to deal with while manually manipulating my ~20000-photo collection is about 800 files.  This also makes the files more easily browsable from a third party application.  Never assume that your software is the only thing that will be accessing your software\'s files.ext3 does in fact have directory size limits, and they depend on the block size of the filesystem.  There isn\'t a per-directory "max number" of files, but a per-directory "max number of blocks used to store file entries".  Specifically, the size of the directory itself can\'t grow beyond a b-tree of height 3, and the fanout of the tree depends on the block size.  See this link for some details.https://www.mail-archive.com/cwelug@googlegroups.com/msg01944.htmlI was bitten by this recently on a filesystem formatted with 2K blocks, which was inexplicably getting directory-full kernel messages warning: ext3_dx_add_entry: Directory index full! when I was copying from another ext3 filesystem.  In my case, a directory with a mere 480,000 files was unable to be copied to the destination.I recall running a program that was creating a huge amount of files at the output. The files were sorted at 30000 per directory. I do not recall having any read problems when I had to reuse the produced output. It was on an 32-bit Ubuntu Linux laptop, and even Nautilus displayed the directory contents, albeit after a few seconds.ext3 filesystem: Similar code on a 64-bit system dealt well with 64000 files per directory.I respect this doesn\'t totally answer your question as to how many is too many, but an idea for solving the long term problem is that in addition to storing the original file metadata, also store which folder on disk it is stored in - normalize out that piece of metadata. Once a folder grows beyond some limit you are comfortable with for performance, aesthetic or whatever reason, you just create a second folder and start dropping files there...I ran into a similar issue. I was trying to access a directory with over 10,000 files in it. It was taking too long to build the file list and run any type of commands on any of the files.I thought up a little php script to do this for myself and tried to figure a way to prevent it from time out in the browser.The following is the php script I wrote to resolve the issue.Listing Files in a Directory with too many files for FTPHow it helps someoneI prefer the same way as @armandino. For that I use this little function in PHP to convert IDs into a filepath that results 1000 files per directory:or you could use the second version if you want to use alpha-numeric:results:As you can see for the $int-version every folder contains up to 1000 files and up to 99 directories containing 1000 files and 99 directories ...But do not forget that to many directories can speed down your backup process. Feel free to test 1000 to 10000 files per directory, but do not add much more as you will have very long access times if you like to read the directory file by file (ftp clients, file reading functions, etc.).Finally you should think about how to reduce the amount of files in total. Depending on your target you can use CSS sprites to combine multiple tiny images like avatars, icons, smilies, etc. or if you use many small non-media files consider combining them e.g. in JSON format. In my case I had thousands of mini-caches and finally I decided to combine them in packs of 10.Not an answer, but just some suggestions.Select a more suitable FS (file system). Since from a historic point of view, all your issues were wise enough, to be once central to FSs evolving over decades. I mean more modern FS better support your issues. First make a comparison decision table based on your ultimate purpose from FS list.I think its time to shift your paradigms. So I personally suggest using a distributed system aware FS, which means no limits at all regarding size, number of files and etc. Otherwise you will sooner or later challenged by new unanticipated problems.I\'m not sure to work, but if you don\'t mention some experimentation, give AUFS over your current file system a try. I guess it has facilities to mimic multiple folders as a single virtual folder.To overcome hardware limits you can use RAID-0.There is no single figure that is "too many", as long as it doesn\'t exceed the limits of the OS. However, the more files in a directory, regardless of the OS, the longer it takes to access any individual file, and on most OS\'s, the performance is non-linear, so to find one file out of 10,000 takes more then 10 times longer then to find a file in 1,000. Secondary problems associated with having a lot of files in a directory include wild card expansion failures. To reduce the risks, you might consider ordering your directories by date of upload, or some other useful piece of metadata. What most of the answers above fail to show is that there is no "One Size Fits All" answer to the original question.In today\'s environment we have a large conglomerate of different hardware and software -- some is 32 bit, some is 64 bit, some is cutting edge and some is tried and true - reliable and never changing.\nAdded to that is a variety of older and newer hardware, older and newer OSes, different vendors (Windows, Unixes, Apple, etc.) and a myriad of utilities and servers that go along.\nAs hardware has improved and software is converted to 64 bit compatibility, there has necessarily been considerable delay in getting all the pieces of this very large and complex world to play nicely with the rapid pace of changes.IMHO there is no one way to fix a problem.  The solution is to research the possibilities and then by trial and error find what works best for your particular needs.  Each user must determine what works for their system rather than using a cookie cutter approach.I for example have a media server with a few very large files.  The result is only about 400 files filling a 3 TB drive. Only 1% of the inodes are used but 95% of the total space is used. Someone else, with a lot of smaller files may run out of inodes before they come near to filling the space. (On ext4 filesystems as a rule of thumb, 1 inode is used for each file/directory.)\nWhile theoretically the total number of files that may be contained within a directory is nearly infinite, practicality determines that the overall usage determine realistic units, not just filesystem capabilities.I hope that all the different answers above have promoted thought and problem solving rather than presenting an insurmountable barrier to progress.