LINQ is one of the greatest improvements to .NET since generics and it saves me tons of time, and lines of code.  However, the fluent syntax seems to come much more natural to me than the query expression syntax.Is there any difference between the two or is there any particular benefit of one over other?Neither is better: they serve different needs. Query syntax comes into its own when you want to leverage multiple range variables. This happens in three situations:Here\'s an example (from the LINQPad samples):Now compare this to the same thing in method syntax:Method syntax, on the other hand, exposes the full gamut of query operators and is more concise with simple queries. You can get the best of both worlds by mixing query and method syntax. This is often done in LINQ to SQL queries:I prefer to use the latter (sometimes called "query comprehension syntax") when I can write the whole expression that way.  As soon as I have to add (parentheses) and .MethodCalls(), I change.When I use the former, I usually put one clause per line, like this:I find that a little easier to read.Each style has their pros and cons. Query syntax is nicer when it comes to joins and it has the useful let keyword that makes creating temporary variables inside a query easy.Fluent syntax on the other hand has a lot more methods and operations that aren\'t exposed through the query syntax. Also since they are just extension methods you can write your own.I have found that every time I start writing a LINQ statement using the query syntax I end up having to put it in parenthesis and fall back to using fluent LINQ extension methods. Query syntax just doesn\'t have enough features to use by itself.In VB.NET i very much prefer query syntax. I hate to repeat the ugly Function-keyword: This neat query is much more readable and maintainable in my opinion:VB.NET\'s query syntax is also more powerful and less verbose than in C#: https://stackoverflow.com/a/6515130/284240For example this LINQ to DataSet(Objects) queryVB.NET:C#:I don\'t get the query syntax at all. There\'s just no reason for it in my mind. let can be acheived with .Select and anonymous types. I just think things look much more organized with the "punctuation" in there.The fluent interface if there\'s just a where.  If I need a select or orderby, I generally use the Query syntax.Fluent syntax does seem more powerful indeed, it should also work better for organizing code into small reusable methods.I know this question is tagged with C#, but the Fluent syntax is painfully verbose with VB.NET.I really like the Fluent syntax and I try to use it where I can, but in certain cases, for example where I use joins, I usually prefer the Query syntax, in those cases I find it easier to read, and I think some people are more familiar to Query (SQL-like) syntax, than lambdas.While I do understand and like the fluent format , I\'ve stuck to Query for the time being for readability reasons. People just being introduced to LINQ will find Query much more comfortable to read.I prefer the query syntax as I came from traditional web programming using SQL.  It is much easier for me to wrap my head around.  However, it think I will start to utilize the .Where(lambda) as it is definitely much shorter.I\'ve been using Linq for about 6 months now. When I first started using it I preferred the query syntax as it\'s very similar to T-SQL.But, I\'m gradually coming round to the former now, as it\'s easy to write reusable chunks of code as extension methods and just chain them together. Although I do find putting each  clause on its own line helps a lot with readability.I have just set up our company\'s standards and we enforce the use of the Extension methods. I think it\'s a good idea to choose one over the other and don\'t mix them up in code. Extension methods read more like the other code.The comprehension syntax does not have all operators and using parentheses around the query and add extension methods after all just begs me for using extension methods from the start.But for the most part it is just personal preference with a few exceptions.