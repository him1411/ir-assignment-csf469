This question is covered here in great detail.How do you measure the memory usage of an application or process in Linux?From the blog article of Understanding memory usage on Linux, ps is not an accurate tool to use for this intent.Why ps is "wrong"Depending on how you look at it, ps is not reporting the real memory usage of processes. What it is really doing is showing how much real memory each process would take up if it were the only process running. Of course, a typical Linux machine has several dozen processes running at any given time, which means that the VSZ and RSS numbers reported by ps are almost definitely wrong.With ps or similar tools you will only get the amount of memory pages allocated by that process. This number is correct, but:does not reflect the actual amount of memory used by the application, only the amount of memory reserved for itcan be misleading if pages are shared, for example by several threads or by using dynamically linked librariesIf you really want to know what amount of memory your application actually uses, you need to run it within a profiler. For example, valgrind can give you insights about the amount of memory used, and, more importantly, about possible memory leaks in your program. The heap profiler tool of valgrind is called \'massif\':Massif is a heap profiler. It performs detailed heap profiling by taking regular snapshots of a program\'s heap. It produces a graph showing heap usage over time, including information about which parts of the program are responsible for the most memory allocations. The graph is supplemented by a text or HTML file that includes more information for determining where the most memory is being allocated. Massif runs programs about 20x slower than normal.As explained in the valgrind documentation, you need to run the program through valgrind:Massif writes a dump of memory usage snapshots (e.g. massif.out.12345). These provide, (1) a timeline of memory usage, (2) for each snapshot, a record of where in your program memory was allocated.\nA great graphical tool for analyzing these files is massif-visualizer. But I found ms_print, a simple text-based tool shipped with valgrind, to be of great help already.To find memory leaks, use the (default) memcheck tool of valgrind.Try the pmap command:Hard to tell for sure, but here are two "close" things that can help.will give you Virtual Size (VSZ)You can also get detailed stats from /proc file-system by going to /proc/$pid/statusThe most important is the VmSize, which should be close to what ps aux gives.In recent versions of linux, use the smaps subsystem. For example, for a process with a PID of 1234:It will tell you exactly how much memory it is using at that time. More importantly, it will divide the memory into private and shared, so you can tell how much memory your instance of the program is using, without including memory shared between multiple instances of the program.There is no easy way to calculate this. But some people have tried to get some good answers:Use smem, which is an alternative to ps which calculates the USS and PSS per process.  What you want is probably the PSS.USS - Unique Set Size.  This is the amount of unshared memory unique to that process (think of it as U for unique memory).  It does not include shared memory.  Thus this will under-report the amount of memory a process uses, but is helpful when you want to ignore shared memory.PSS - Proportional Set Size.  This is what you want.  It adds together the unique memory (USS), along with a proportion of its shared memory divided by the number of other processes sharing that memory.  Thus it will give you an accurate representation of how much actual physical memory is being used per process - with shared memory truly represented as shared.  Think of the P being for physical memory.How this compares to RSS as reported by ps and other utilties:Notice: smem can also (optionally) output graphs such as pie charts and the like.  IMO you don\'t need any of that.  If you just want to use it from the command line like you might use ps -A v, then you don\'t need to install the python-matplotlib recommended dependency.This is an excellent summary of the tools and problems: archive.org linkI\'ll quote it, so that more devs will actually read it.If you want to analyse memory usage of the whole system or to thoroughly analyse memory usage of one application (not just its heap usage), use exmap. For whole system analysis, find processes with the highest effective usage, they take the most memory in practice, find processes with the highest writable usage, they create the most data (and therefore possibly leak or are very ineffective in their data usage). Select such application and analyse its mappings in the second listview. See exmap section for more details. Also use xrestop to check high usage of X resources, especially if the process of the X server takes a lot of memory. See xrestop section for details.If you want to detect leaks, use valgrind or possibly kmtrace.If you want to analyse heap (malloc etc.) usage of an application, either run it in memprof or with kmtrace, profile the application and search the function call tree for biggest allocations. See their sections for more details.What about time ?Not the Bash builtin time but the one you can find with which time, for example /usr/bin/timeHere\'s what it covers, on a simple ls :Beside the solutions listed in thy answers, you can use the Linux command "top"; It provides a dynamic real-time view of the running system, it gives the CPU and Memory usage, for the whole system along with for every program, in percentage:to filter by a program pid:to filter by a program name:"top" provides also some fields such as:VIRT -- Virtual Image (kb) :The total amount of virtual memory used by the taskRES -- Resident size (kb): The non-swapped physical memory a task has used ; RES = CODE + DATA.DATA -- Data+Stack size (kb): The amount of physical memory devoted to other than executable code, also known as the \'data resident set\' size or DRS.SHR -- Shared Mem size (kb): The amount of shared memory used by a task. It simply reflects memory that could be potentially shared with other processes.Reference here. There isn\'t a single answer for this because you can\'t pin point precisely the amount of memory a process uses. Most processes under linux use shared libraries. For instance, let\'s say you want to calculate memory usage for the \'ls\' process. Do you count only the memory used by the executable \'ls\' ( if you could isolate it) ? How about libc? Or all these other libs that are required to run \'ls\'?You could argue that they are shared by other processes, but \'ls\' can\'t be run on the system without them being loaded.Also, if you need to know how much memory a process needs in order to do capacity planning, you have to calculate how much each additional copy of the process uses. I think  /proc/PID/status might give you enough info of the memory usage AT a single time. On the other hand, valgrind will give you a better profile of the memory usage throughout the lifetime of the programIf your code is in C or C++ you might be able to use getrusage() which returns you various statistics about memory and time usage of your process.Not all platforms support this though and will return 0 values for the memory-use options.Instead you can look at the virtual file created in /proc/[pid]/statm (where [pid] is replaced by your process id. You can obtain this from getpid()).This file will look like a text file with 7 integers. You are probably most interested in the first (all memory use) and sixth (data memory use) numbers in this file.Valgrind can show detailed information but it slows down the target application significantly, and most of the time it changes the behavior of the app.\nExmap was something I didn\'t know yet, but it seems that you need a kernel module to get the information, which can be an obstacle.I assume what everyone wants to know WRT "memory usage" is the following...\nIn linux, the amount of physical memory a single process might use can be roughly divided into following categories.M.a anonymous mapped memoryM.n named mapped memoryUtility included in Android called showmap is quite usefulI\'m using htop; it\'s a very good console program similar to Windows Task Manager.Valgrind is amazing if you have the time to run it. valgrind --tool=massif is The Right Solution.However, I\'m starting to run larger examples, and using valgrind is no longer practical. Is there a way to tell the maximum memory usage (modulo page size and shared pages) of a program?On a real unix system, /usr/bin/time -v works. On Linux, however, this does not work.A good test of the more "real world" usage is to open the application, then run vmstat -s and check the "active memory" statistic.  Close the application, wait a few seconds and run vmstat -s again.  However much active memory was freed was in evidently in use by the app.Below command line will give you the total memory used by the various process running on the Linux machine in MBGet valgrind.  give it your program to run, and it\'ll tell you plenty about its memory usage.  This would apply only for the case of a program that runs for some time and stops. I don\'t know if valgrind can get its hands on an already-running process or shouldn\'t-stop processes such as daemons.If the process is not using up too much memory (either because you expect this to be the case, or some other command has given this initial indication), and the process can withstand being stopped for a short period of time, you can try to use the gcore command.  Check the size of the generated core file to get a good idea how much memory a particular process is using.This won\'t work too well if process is using hundreds of megs, or gigs, as the core generation could take several seconds or minutes to be created depending on I/O performance.  During the core creation the process is stopped (or "frozen") to prevent memory changes.  So be careful.Also make sure the mount point where the core is generated has plenty of disk space and that the system will not react negatively to the core file being created in that particular directory.If you want something quicker than profiling with Valgrind and your kernel is older and you can\'t use smaps, a ps with the options to show the resident set of the process (with ps -o rss,command) can give you a quick and reasonable _aproximation_ of the real amount of non-swapped memory being used.Three more methods to try:(Extracted from here)Check shell script to check memory usage by application in linux.\nAlso available on github and in a version without paste and bc.Edit: this works 100% well only when memory consumption increasesIf you want to monitor memory usage by given process (or group of processed sharing common name, e.g. google-chrome, you can use my bash-script: this will continously look for changes and print them. Another vote for valgrind here, but I would like to add that you can use a tool like Alleyoop to help you interpret the results generated by valgrind.I use the two tools all the time and always have lean, non-leaky code to proudly show for it ;)While this question seems to be about examining currently running processes, I wanted to see the peak memory used by an application from start to finish. Besides valgrind, you can use tstime, which is much simpler. It measures the "highwater" memory usage (RSS and virtual). From this answer.I would suggest that you use atop. You can find everything about it on this page. It is capable of providing all the necessary KPI for your processes and it can also capture to a file.Use the in-built \'system monitor\' GUI tool available in ubuntuBased on answer to a related question.You may use SNMP to get the memory and cpu usage of a process in a particular device in network :)Requirements:Notes:HOST-RESOURCES-MIB::hrSWRunPerfCPU is the number of centi-seconds of the total system\'s CPU resources consumed by this process.  Note that on a multi-processor system, this value may increment by more than one centi-second in one centi-second of real (wall clock) time.HOST-RESOURCES-MIB::hrSWRunPerfMem is the total amount of real system memory allocated to this process.**Process monitoring script:**/prox/xxx/numa_maps gives some info there: N0=??? N1=???. But this result might be lower than the actual result, as it only count those which have been touched.