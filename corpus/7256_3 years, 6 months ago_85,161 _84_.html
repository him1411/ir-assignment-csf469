Is it possible to create private properties in ES6 classes?Here\'s an example.\nHow can I prevent access to instance.property?Short answer, no, there is no native support for private properties with JS6 classes.But you could mimic that behaviour by not attaching the new properties to the object, but keeping them inside a class constructor, and use getters and setters to reach the hidden properties. Note that the getters and setters gets redefine on each new instance of the class.Javascript 6Javascript < 6Update: A proposal with nicer syntax is on its way. Contributions welcome.Yes, there is - for scoped access in objects - ES6 introduces Symbols.Symbols are unique, you can\'t gain access to one from the outside except with reflection (like privates in Java/C#) but anyone who has access to a symbol on the inside can use it for key access:To expand on @loganfsmyth\'s answer:The only truly private data in JavaScript is still scoped variables. You can\'t have private properties in the sense of properties accessed internally the same way as public properties, but you can use scoped variables to store private data.The approach here is to use the scope of the constructor function, which is private, to store private data. For methods to have access to this private data they must be created within the constructor as well, meaning you\'re recreating them with every instance. This is a performance and memory penalty, but some believe the penalty is acceptable. The penalty can be avoided for methods that do not need access to private data, by adding them to the prototype as usual.Example:A WeakMap can be used to avoid the previous approach\'s performance and memory penalty. WeakMaps associate data with Objects (here, instances) in such a way that it can only be accessed using that WeakMap. So, we use the scoped variables method to create a private WeakMap, then use that WeakMap to retrieve private data associated with this. This is faster than the scoped variables method because all your instances can share a single WeakMap, so you don\'t need to recreate methods just so that they\'re all accessing their own WeakMap.Example:This example uses an Object to use one WeakMap for multiple private properties; you could also use multiple WeakMaps and use them like age.set(this, 20), or write a small wrapper and use it another way, like privateProps.set(this, \'age\', 0).(This method could also be done with Map, but WeakMap is better because Map will create memory leaks unless you\'re very careful, and for this purpose the two aren\'t otherwise different.)JavaScript is, unfortunately, a language where half-answers are often more accessible than real ones.The WeakMap approach is technically a half-answer because somebody could have tampered with the global WeakMap object, but I consider it less so than other half-answers because all JavaScript code can be broken by mangled globals. It\'s just something we need to assume trusted code won\'t do.A Symbol is a type of primitive value that can serve as a property name. You can use the scoped variable method to create a private Symbol, then store private data at this[mySymbol]. This is a half-answer because an Object\'s Symbol keys can be listed by external code. Despite that, here\'s how you would use Symbols:The old default, just use a public property with an underscore prefix. While not a private property by any stretch of the imagination, this is easily the simplest, most readable, and fastest approach. Thanks to the convention\'s prevalence it does a good job of communicating that the property should be private, and that often gets the job done.Example:The short of it is that private properties aren\'t something ES2015 fixed, but rather just fiddled around with. So, the state of things is that there are a list of options, none wholly superior, each with pros and cons. I\'m sorry.The answer is "No". But you can create private access to properties like this:(The suggestion that Symbols could be used to ensure privacy was true in an earlier version of the ES6 spec but is no longer the case:https://mail.mozilla.org/pipermail/es-discuss/2014-January/035604.html and https://stackoverflow.com/a/22280202/1282216. For a longer discussion about Symbols and privacy see: https://curiosity-driven.org/private-properties-in-javascript)The only way to get true privacy in JS is through scoping, so there is no way to have a property that is a member of this that will be accessible only inside the component. The best way to store truly private data in ES6 is with a WeakMap.Obviously this is a probably slow, and definitely ugly, but it does provide privacy.Keep in mind that EVEN THIS isn\'t perfect, because Javascript is so dynamic. Someone could still doto catch values as they are stored, so if you wanted to be extra careful, you\'d need to capture a local reference to .set and .get to use explicitly instead of relying on the overridable prototype.For future reference of other on lookers, I\'m hearing now that the recommendation is to use WeakMaps to hold private data.Here is a more clear, working example:Depends on whom you ask :-)No private property modifier is included in the Maximally minimal classes proposal which seems to have made it into the current draft.However, there might be support for private names, which does allow private properties - and they probably could be used in class definitions as well.Completing @d13 and the comments by @johnny-oshika and @DanyalAytekin:I guess in the example provided by @johnny-oshika we could use normal functions instead of arrow functions and then .bind them with the current object plus a _privates object as a curried parameter:something.jsmain.jsBenefits I can think of: Some drawbacks I can think of: A running snippet can be found here: http://www.webpackbin.com/NJgI5J8lZYes - you can create encapsulated property, but it\'s not been done with access modifiers (public|private) at least not with ES6.Here is a simple example how it can be done with ES6:1 Create class using class word2 Inside it\'s constructor declare block-scoped variable using let OR const reserved words -> since they are block-scope they cannot be accessed from outside (encapsulated)3 To allow some access control (setters|getters) to those variables you can declare instance method inside it\'s constructor using: this.methodName=function(){} syntax Now lets check it:Using ES6 modules (initially proposed by @d13) works well for me. It doesn\'t mimic private properties perfectly, but at least you can be confident that properties that should be private won\'t leak outside of your class. Here\'s an example:Then the consuming code can look like this:As @DanyalAytekin outlined in the comments, these private properties are static, so therefore global in scope.  They will work well when working with Singletons, but care must be taken for Transient objects.  Extending the example above:I think Benjamin\'s answer is probably the best for most cases until the language natively supports explicitly private variables.However, if for some reason you need to prevent access with Object.getOwnPropertySymbols(), a method I\'ve considered using is attaching a unique, non-configurable, non-enumerable, non-writable property that can be used as a property identifier to each object on construction (such as a unique Symbol, if you don\'t already have some other unique property like an id). Then just keep a map of each object\'s \'private\' variables using that identifier.I believe it is possible to get \'best of both worlds\' using closures inside constructors. There are two variations:All data members are privateSome members are privateNOTE: This is admittedly ugly. If you know a better solution, please edit this response.In fact it is possible using Symbols and Proxies. You use the symbols in the class scope and set two traps in a proxy: one for the class prototype so that the Reflect.ownKeys(instance) or Object.getOwnPropertySymbols doesn\'t give your symbols away, the other one is for the constructor itself so when new ClassName(attrs) is called, the instance returned will be intercepted and have the own properties symbols blocked.\nHere\'s the code:Reflect.ownKeys() works like so: Object.getOwnPropertyNames(myObj).concat(Object.getOwnPropertySymbols(myObj)) that\'s why we need a trap for these objects.Personally I like the proposal of the bind operator :: and would then combine it with the solution @d13 mentioned but for now stick with @d13 \'s answer where you use the export keyword for your class and put the private functions in the module.there is one more solution tough which hasn\'t been mentioned here that follows are more functional approach and would allow it to have all the private props/methods within the class.Private.jsTest.jscomments on it would be appreciated.Even Typescript can\'t do it. From their documentation: When a member is marked private, it cannot be accessed from outside of its containing class. For example:But transpiled on their playground this gives:So their "private" keyword is ineffective.SymbolClosureWeakMapFirst, define a function to wrap WeakMap:Then, construct a reference outside your class:Note: class isn\'t supported by IE11, but it looks cleaner in the example.Coming very late to this party but I hit the OP question in a search so...\nYes, you can have private properties by wrapping the class declaration in a closureThere is an example of how I have private methods in this codepen. In the snippet below, the Subscribable class has two \'private\' functions process and processCallbacks. Any properties can be added in this manner and they are kept private through the use of the closure. IMO Privacy is a rare need if concerns are well separated and Javascript does not need to become bloated by adding more syntax when a closure neatly does the job.I like this approach because it separates concerns nicely and keeps things truly private. The only downside is the need to use \'self\' (or something similar) to refer to \'this\' in the private content.See this answer for a a clean & simple \'class\' solution with a private and public interface and support for compositionMost answers either say it\'s impossible, or require you to use a WeakMap or Symbol, which are ES6 features that would probably require polyfills. There\'s however another way! Check out this out:I call this method accessor pattern. The essential idea is that we have a closure, a key inside the closure, and we create a private object (in the constructor) that can only be accessed if you have the key.If you are interested, you can read more about this in my article. Using this method, you can create per object properties that cannot be accessed outside of the closure. Therefore, you can use them in constructor or prototype, but not anywhere else. I haven\'t seen this method used anywhere, but I think it\'s really powerful.