I\'d like to compare two arrays... ideally, efficiently. Nothing fancy, just true if they are identical, and false if not. Not surprisingly, the comparison operator doesn\'t seem to work.JSON encoding each array does, but is there a faster or "better" way to simply compare arrays without having to iterate through each value?I can\'t really believe that so many people want to compare arrays as strings. So, though this is old question, I will add the right way to compare arrays - loop through them and compare every value:  You may say "But it is much faster to compare strings - no loops..." well, then you should note there ARE loops. First recursive loop that converts Array to string and second, that compares two strings. So this method is faster than use of string.I believe that larger amounts of data should be always stored in arrays, not in objects. However if you use objects, they can be partially compared too.\nHere\'s how:I\'ve stated above, that two object instances will never be equal, even if they contain same data at the moment:This has a reason, since there may be, for example private variables within objects.However, if you just use object structure to contain data, comparing is still possible:However, remember that this one is to serve in comparing JSON like data, not class instances and other stuff. If you want to compare mor complicated objects, look at this answer and it\'s superlong function.\nTo make this work with Array.equals you must edit the original function a little bit:I made a little test tool for both of the functions.Samy Bencherif has prepared useful functions for the case you\'re searching for a specific object in nested arrays, which are available here: https://jsfiddle.net/SamyBencherif/8352y6yw/while this only works for scalar arrays, it is short & sweet:or, in ECMAScript 6/CoffeeScript/TypeScript with Arrow Functions:I like to use the underscore library for array/object heavy coding projects ... in underscore whether you\'re doing arrays or objects it just looks like this returns a booleanSee documentationIt\'s unclear what you mean by "identical". For example, are the arrays a and b below identical (note the nested arrays)?Here\'s an optimized array comparison function that compares corresponding elements of each array in turn using strict equality and does not do recursive comparison of array elements that are themselves arrays, meaning that for the above example, arraysIdentical(a, b) would return false. It works in the general case, which JSON- and join()-based solutions will not:This I think is the simplest way to do it using JSON stringify, and it may be the best solution in some situations:This converts the objects a1 and a2 into strings so they can be compared. The order is important in most cases, for that can sort the object using a sort algorithm shown in one of the above answers.Please do note that you are no longer comparing the object but the string representation of the object. It may not be exactly what you want.Building off Tom\xc3\xa1\xc5\xa1 Zato\'s answer, I agree that just iterating through the arrays is the fastest.  Additionally (like others have already stated), the function should be called equals/equal, not compare.  In light of this, I modified the function to handle comparing arrays for similarity - i.e. they have the same elements, but out of order - for personal use, and thought I\'d throw it on here for everyone to see.This function takes an additional parameter of strict that defaults to true.  This strict parameter defines if the arrays need to be wholly equal in both contents and the order of those contents, or simply just contain the same contents.Example:I\'ve also written up a quick jsfiddle with the function and this example:\nhttp://jsfiddle.net/Roundaround/DLkxX/I think it\'s wrong to say a particular implementation is "The Right Way\xe2\x84\xa2" if it\'s only "right" ("correct") in contrast to a "wrong" solution. Tom\xc3\xa1\xc5\xa1\'s solution is a clear improvement over string-based array comparison, but that doesn\'t mean it\'s objectively "right". What is right anyway? Is it the fastest? Is it the most flexible? Is it the easiest to comprehend? Is it the quickest to debug? Does it use the least operations? Does it have any side effects? No one solution can have the best of all the things.Tom\xc3\xa1\xc5\xa1\'s could say his solution is fast but I would also say it is needlessly complicated. It tries to be an all-in-one solution that works for all arrays, nested or not. In fact, it even accepts more than just arrays as an input and still attempts to give a "valid" answer.My answer will approach the problem differently. I\'ll start with a generic arrayCompare procedure that is only concerned with stepping through the arrays. From there, we\'ll build our other basic comparison functions like arrayEqual and arrayDeepEqual, etcIn my opinion, the best kind of code doesn\'t even need comments, and this is no exception. There\'s so little happening here that you can understand the behaviour of this procedure with almost no effort at all. Sure, some of the ES6 syntax might seem foreign to you now, but that\'s only because ES6 is relatively new. As the type suggests, arrayCompare takes comparison function, f, and two input arrays, xs and ys. For the most part, all we do is call f (x) (y) for each element in the input arrays. We return an early false if the user-defined f returns false. So yes, this means the comparator can stop iteration early and prevent looping through the rest of the input array when unnecessary.Next, using our arrayCompare function, we can easily create other functions we might need. We\'ll start with the elementary arrayEqual …Simple as that. arrayEqual can be defined with arrayCompare and a comparator function that compares a to b using === (for strict equality).Notice that we also define equal as it\'s own function. This highlights the role of arrayCompare as a higher-order function to utilize our first order comparator in the context of another data type (Array).We could just as easily defined arrayLooseEqual using a == instead. Now when comparing 1 (Number) to \'1\' (String), the result will be true …You\'ve probably noticed that this is only shallow comparison tho. Surely Tom\xc3\xa1\xc5\xa1\'s solution is "The Right Way\xe2\x84\xa2" because it does implicit deep comparison, right ?Well our arrayCompare procedure is versatile enough to use in a way that makes a deep equality test a breeze …Simple as that. We build a deep comparator using another higher-order function. This time we\'re wrapping arrayCompare using a custom comparator that will check if a and b are arrays. If so, reapply arrayDeepCompare otherwise compare a and b to the user-specified comparator (f). This allows us to keep the deep comparison behavior separate from how we actually compare the individual elements. Ie, like the example above shows, we can deep compare using equal, looseEqual, or any other comparator we make.Because arrayDeepCompare is curried, we can partially apply it like we did in the previous examples tooTo me, this already a clear improvement over Tom\xc3\xa1\xc5\xa1\'s solution because I can explicitly choose a shallow or deep comparison for my arrays, as needed.Now what if you have an array of objects or something ? Maybe you want to consider those arrays as "equal" if each object has the same id value …Simple as that. Here I\'ve used vanilla JS objects, but this type of comparator could work for any object type; even your custom objects. Tom\xc3\xa1\xc5\xa1\'s solution would need to be completely reworked to support this kind of equality testDeep array with objects? Not a problem. We built highly versatile, generic functions, so they\'ll work in a wide variety of use cases.Or what if you wanted to do some other kind of kind of completely arbitrary comparison ? Maybe I want to know if each x is greater than each y …You can see we\'re actually doing more with less code. There\'s nothing complicated about arrayCompare itself and each of the custom comparators we\'ve made have a very simple implementation.With ease, we can define exactly how we wish for two arrays to be compared — shallow, deep, strict, loose, some object property, or some arbitrary computation, or any combination of these — all using one procedure, arrayCompare. Maybe even dream up a RegExp comparator ! I know how kids love those regexps …Is it the fastest? Nope. But it probably doesn\'t need to be either. If speed is the only metric used to measure the quality of our code, a lot of really great code would get thrown away — That\'s why I\'m calling this approach The Practical Way. Or maybe to be more fair, A Practical Way. This description is suitable for this answer because I\'m not saying this answer is only practical in comparison to some other answer; it is objectively true. We\'ve attained a high degree of practicality with very little code that\'s very easy to reason about. No other code can say we haven\'t earned this description.Does that make it the "right" solution for you ? That\'s up for you to decide. And no one else can do that for you; only you know what your needs are. In almost all cases, I value straightforward, practical, and versatile code over clever and fast kind. What you value might differ, so pick what works for you.My old answer was more focused on decomposing arrayEqual into tiny procedures. It\'s an interesting exercise, but not really the best (most practical) way to approach this problem. If you\'re interested, you can see this revision history.In the spirit of the original question:I\'d like to compare two arrays... ideally, efficiently. Nothing\n  fancy, just true if they are identical, and false if not.I have been running performance tests on some of the more simple suggestions proposed here with the following results (fast to slow):while (67%) by Tim Downevery (69%) by user2782196reduce (74%) by DEIsjoin & toString (78%) by Gaizka Allende & vivekhalf toString (90%) by Victor Palomostringify (100%) by radtekNote the examples below assumes the arrays are sorted, single-dimensional arrays. .length comparison has been removed for a common benchmark (add a1.length === a2.length to any of the suggestions and you will get a ~10% performance boost). Choose whatever solutions that works best for you knowing the speed and limitation of each.Unrelated note: it is interesting to see people getting all trigger-happy John Waynes on the down vote button on perfectly legitimate answers to this question. On the same lines as JSON.encode is to use join().Only problem is if you care about types which the last comparison tests.\nIf you care about types, you will have to loop.If the order should remain the same, than it is just a loop, no sort is needed.for single dimension array you can simply use:arr1.sort().toString() == arr2.sort().toString()this will also take care of array with mismatched index.If you are using a testing framework like Mocha with the Chai assertion library, you can use deep equality to compare arrays.This should return true only if the arrays have equal elements at corresponding indices.Herer\'s my solution:Works with any nested data structure, and obviously ignores objects\' methods. Don\'t even think of extending Object.prototype with this method, when I tried this once, jQuery broke ;)For most arrays it\'s still faster than most of serialization solutions. It\'s probably the fastest compare method for arrays of object records.We could do this the functional way, using every (https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/every)This compares 2 unsorted arrays:If they are two arrays of numbers or strings only, this is a quick one-line onethis script compares Object, Arrays and multidimensional arrayfirst line checks whether it\'s a primitive type. if so it compares the two parameters.if they are Objects. it iterates over the Object and check every element recursivly. Usage:This function compares two arrays of arbitrary shape and dimesionality:The reason is that identity or strict operator (===), it compares with no type conversion, that means if both values doesn\xe2\x80\x99t have the same value and the same type, they won\xe2\x80\x99t be considered equal.take a look this link, it takes you out of doubt\neasy way to understand how identity operator worksIn my case compared arrays contain only numbers and strings. This function will show you if arrays contain same elements.Let\'s test it!////// OR  ///////Choose each from [a] and loop through all from [b]:\nResult: 1, 5Extending Tom\xc3\xa1\xc5\xa1 Zato idea. Tomas\'s Array.prototype.compare should be infact called  Array.prototype.compareIdentical.It passes on:But fails on:Here is better (in my opinion) version:http://jsfiddle.net/igos/bcfCY/My solution compares Objects, not Arrays. This would work in the same way as Tom\xc3\xa1\xc5\xa1\'s as Arrays are Objects, but without the Warning:Hope this helps you or anyone else searching for an answer.If the array is plain and the order is matter so this two lines may helpReduce walks through one of array and returns \'false\' if at least one element of \'a\' is nor equial to element of \'b\'\nJust wrap this into function Here\'s a CoffeeScript version, for those who prefer that:All credits goes to @tomas-zato.While the top answer to this question is correct and good, the code provided could use some improvement.Below is my own code for comparing arrays and objects.  The code is short and simple:This code supports arrays nested in objects and objects nested in arrays.You can see a full suite of tests and test the code yourself at this repl: https://repl.it/Esfz/3tried deep-equal and it workedAnother approach with very few code (using Array reduce and Array includes):If you want to compare also the equality of order:The length check ensures that the set of elements in one array isn\'t just a subset of the other one.The reducer is used to walk through one array and search for each item in other array. If one item isn\'t found the reduce function returns false. I have used : to join array and create a string to compare.\nfor scenarios complex than this example you can use some other separator.