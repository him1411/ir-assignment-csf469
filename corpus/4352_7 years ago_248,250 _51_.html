I want to execute test methods which are annotated by @Test in specific order.For example:I want to ensure to run test1() before test2() each time I run MyTest, but I couldn\'t find annotation like @Test(order=xx).I think it\'s quite important feature for JUnit, if author of JUnit doesn\'t want the order feature, why?I think it\'s quite important feature for JUnit, if author of JUnit doesn\'t want the order feature, why? I\'m not sure there is a clean way to do this with JUnit, to my knowledge JUnit assumes that all tests can be performed in an arbitrary order. From the FAQ:(...) The ordering of test-method invocations is not guaranteed, so testOneItemCollection() might be executed before testEmptyCollection(). (...)Why is it so? Well, I believe that making tests order dependent is a practice that the authors don\'t want to promote. Tests should be independent, they shouldn\'t be coupled and violating this will make things harder to maintain, will break the ability to run tests individually (obviously), etc.That being said, if you really want to go in this direction, consider using  TestNG since it supports running tests methods in any arbitrary order natively (and things like specifying that methods depends on groups of methods). Cedric Beust explains how to do this in order of execution of tests in testng.Junit 4.11 comes with @FixMethodOrder annotation. Instead of using custom solutions just upgrade your junit version and annotate test class with FixMethodOrder(MethodSorters.NAME_ASCENDING). Check the release notes for the details.Here is a sample:If you get rid of your existing instance of Junit, and download JUnit 4.11 or greater in the build path, the following code will execute the test methods in the order of their names, sorted  in ascending order:If the order is important, you should make the order yourself. In particular, you should list some or all possible order permutations to test, if necessary. For example, Or, a full test of all permutations: Here, permute() is a simple function which iterates all possible permuations into a Collection of array.Migration to TestNG seems the best way, but I see no clear solution here for jUnit. Here is most readable solution / formatting I found for jUnit:This ensures stage2 methods are called after stage1 ones and before stage3 ones. The (as yet unreleased) change https://github.com/junit-team/junit/pull/386 introduces a @SortMethodsWith. https://github.com/junit-team/junit/pull/293 at least made the order predictable without that (in Java 7 it can be quite random).Look at a JUnit report.  JUnit is already organized by package.  Each package has (or can have) TestSuite classes, each of which in turn run multiple TestCases.  Each TestCase can have multiple test methods of the form public void test*(), each of which will actually become an instance of the TestCase class to which they belong.  Each test method (TestCase instance) has a name and a pass/fail criteria.What my management requires is the concept of individual TestStep items, each of which reports their own pass/fail criteria.  Failure of any test step must not prevent the execution of subsequent test steps.In the past, test developers in my position organized TestCase classes into packages that correspond to the part(s) of the product under test, created a TestCase class for each test, and made each test method a separate "step" in the test, complete with its own pass/fail criteria in the JUnit output.  Each TestCase is a standalone "test", but the individual methods, or test "steps" within the TestCase, must occur in a specific order.The TestCase methods were the steps of the TestCase, and test designers got a separate pass/fail criterion per test step.  Now the test steps are jumbled, and the tests (of course) fail.For example:Each test method asserts and reports its own separate pass/fail criteria.\nCollapsing this into "one big test method" for the sake of ordering loses the pass/fail criteria granularity of each "step" in the JUnit summary report.  ...and that upsets my managers.  They are currently demanding another alternative.Can anyone explain how a JUnit with scrambled test method ordering would support separate pass/fail criteria of each sequential test step, as exemplified above and required by my management?Regardless of the documentation, I see this as a serious regression in the JUnit framework that is making life difficult for lots of test developers.Its one of the main issue which I faced when I worked on Junit and I came up with following solution which works fine for me:also create a interface like below:Now suppose you have class A where you have written several test cases like below:So execution will start from method named "method()".\nThanks!What you want is perfectly reasonable when test cases are being run as a suite.Unfortunately no time to give a complete solution right now, but have a look at class: Which allows you to call test cases (from any test class) in a specific order.These might be used to create functional, integration or system tests.This leaves your unit tests as they are without specific order (as recommended), whether you run them like that or not, and then re-use the tests as part of a bigger picture.We re-use/inherit the same code for unit, integration and system tests, sometimes data driven, sometimes commit driven, and sometimes run as a suite.Not sure I agree, If I want to test \'File Upload\' and then test \'Data Inserted by File Upload\' why would I not want these to be independent from each other? Perfectly reasonable I think to be able to run them separately rather than having both in a Goliath test case.    See my solution here:\n"Junit and java 7."In this article I describe how to run junit tests in order - "just as in your source code".\nTests will be run, in order as your test methods appears in class file.http://intellijava.blogspot.com/2012/05/junit-and-java-7.htmlBut as Pascal Thivent said, this is not a good practise.I\'ve read a few answers and agree its not best practice, but the easiest way to order your tests - and the way that JUnit runs tests by default is by alphabetic name ascending. So just name your tests in the alphabetic order that you want. Also note the test name must begin\nwith the word test. Just watch out for numberstest12 will run before test2so:testA_MyFirstTest\ntestC_ThirdTest\ntestB_ATestThatRunsSecondPlease check out this one: https://github.com/TransparentMarket/junit. It runs the test in the order they are specified (defined within the compiled class file). Also it features a AllTests suite to run tests defined by sub package first. Using the AllTests implementation one can extend the solution in also filtering for properties (we used to use @Fast annotations but those were not published yet).Here is an extension to JUnit that can produce the desired behavior: https://github.com/aafuks/aaf-junitI know that this is against the authors of JUnit philosophy, but when using JUnit in environments that are not strict unit testing (as practiced in Java) this can be very helpful. 