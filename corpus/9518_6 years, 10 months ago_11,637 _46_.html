After my previous question on finding toes within each paw, I started loading up other measurements to see how it would hold up. Unfortunately, I quickly ran into a problem with one of the preceding steps: recognizing the paws.You see, my proof of concept basically took the maximal pressure of each sensor over time and would start looking for the sum of each row, until it finds on that != 0.0. Then it does the same for the columns and as soon as it finds more than 2 rows with that are zero again. It stores the minimal and maximal row and column values to some index.As you can see in the figure, this works quite well in most cases. However, there are a lot of downsides to this approach (other than being very primitive):Humans can have \'hollow feet\' which means there are several empty rows within the footprint itself. Since I feared this could happen with (large) dogs too, I waited for at least 2 or 3 empty rows before cutting off the paw. This creates a problem if another contact made in a different column before it reaches several empty rows, thus expanding the area. I figure I could compare the columns and see if they exceed a certain value, they must be separate paws.The problem gets worse when the dog is very small or walks at a higher pace. What happens is that the front paw\'s toes are still making contact, while the hind paw\'s toes just start to make contact within the same area as the front paw!With my simple script, it won\'t be able to split these two, because it would have to determine which frames of that area belong to which paw, while currently I would only have to look at the maximal values over all frames.Examples of where it starts going wrong:\nSo now I\'m looking for a better way of recognizing and separating the paws (after which I\'ll get to the problem of deciding which paw it is!).Update:I\'ve been tinkering to get Joe\'s (awesome!) answer implemented, but I\'m having difficulties extracting the actual paw data from my files.The coded_paws shows me all the different paws, when applied to the maximal pressure image (see above). However, the solution goes over each frame (to separate overlapping paws) and sets the four Rectangle attributes, such as coordinates or height/width. I can\'t figure out how to take these attributes and store them in some variable that I can apply to the measurement data. Since I need to know for each paw, what its location is during which frames and couple this to which paw it is (front/hind, left/right).So how can I use the Rectangles attributes to extract these values for each paw?I have the measurements I used in the question setup in my public Dropbox folder (example 1, example 2, example 3). For anyone interested I also set up a blog to keep you up to date :-)If you\'re just wanting (semi) contiguous regions, there\'s already an easy implementation in Python: SciPy\'s ndimage.morphology module.  This is a fairly common image morphology operation. Basically, you have 5 steps:Blur the input data a bit to make sure the paws have a continuous footprint.  (It would be more efficient to just use a larger kernel (the structure kwarg to the various scipy.ndimage.morphology functions) but this isn\'t quite working properly for some reason...) Threshold the array so that you have a boolean array of places where the pressure is over some threshold value (i.e. thresh = data > value)Fill any internal holes, so that you have cleaner regions (filled = sp.ndimage.morphology.binary_fill_holes(thresh))Find the separate contiguous regions (coded_paws, num_paws = sp.ndimage.label(filled)). This returns an array with the regions coded by number (each region is a contiguous area of a unique integer (1 up to the number of paws) with zeros everywhere else)).Isolate the contiguous regions using data_slices = sp.ndimage.find_objects(coded_paws).  This returns a list of tuples of slice objects, so you could get the region of the data for each paw with [data[x] for x in data_slices]. Instead, we\'ll draw a rectangle based on these slices, which takes slightly more work.The two animations below show your "Overlapping Paws" and "Grouped Paws" example data.  This method seems to be working perfectly. (And for whatever it\'s worth, this runs much more smoothly than the GIF images below on my machine, so the paw detection algorithm is fairly fast...)\nHere\'s a full example (now with much more detailed explanations). The vast majority of this is reading the input and making an animation.  The actual paw detection is only 5 lines of code.Update: As far as identifying which paw is in contact with the sensor at what times, the simplest solution is to just do the same analysis, but use all of the data at once. (i.e. stack the input into a 3D array, and work with it, instead of the individual time frames.)  Because SciPy\'s ndimage functions are meant to work with n-dimensional arrays, we don\'t have to modify the original paw-finding function at all.I\'m no expert in image detection, and I don\'t know Python, but I\'ll give it a whack...To detect individual paws, you should first only select everything with a pressure greater than some small threshold, very close to no pressure at all.  Every pixel/point that is above this should be "marked."  Then, every pixel adjacent to all "marked" pixels becomes marked, and this process is repeated a few times.  Masses that are totally connected would be formed, so you have distinct objects.  Then, each "object" has a minimum and maximum x and y value, so bounding boxes can be packed neatly around them.Pseudocode:(MARK) ALL PIXELS ABOVE (0.5)(MARK) ALL PIXELS (ADJACENT) TO (MARK) PIXELSREPEAT (STEP 2) (5) TIMESSEPARATE EACH TOTALLY CONNECTED MASS INTO A SINGLE OBJECTMARK THE EDGES OF EACH OBJECT, AND CUT APART TO FORM SLICES.That should about do it.  Note: I say pixel, but this could be regions using an average of the pixels. Optimization is another issue...Sounds like you need to analyze a function (pressure over time) for each pixel and determine where the function turns (when it changes > X in the other direction it is considered a turn to counter errors).If you know at what frames it turns, you will know the frame where the pressure was the most hard and you will know where it was the least hard between the two paws. In theory, you then would know the two frames where the paws pressed the most hard and can calculate an average of those intervals.after which I\'ll get to the problem of deciding which paw it is!This is the same tour as before, knowing when each paw applies the most pressure helps you decide.