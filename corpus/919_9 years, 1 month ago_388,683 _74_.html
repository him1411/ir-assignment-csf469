How do I call shell commands from inside of a Ruby program? How do I then get output from these commands back into Ruby?This explanation is based on a commented Ruby script from a friend of mine. If you want to improve the script, feel free to update it at the link.First, note that when Ruby calls out to a shell, it typically calls /bin/sh, not Bash. Some Bash syntax is not supported by /bin/sh on all systems.Here are ways to execute a shell script:Kernel#` , commonly called backticks \xe2\x80\x93 `cmd`This is like many other languages, including Bash, PHP, and Perl.Returns the result of the shell command.Docs: http://ruby-doc.org/core/Kernel.html#method-i-60Built-in syntax, %x( cmd )Following the x character is a delimiter, which can be any character.\nIf the delimiter is one of the characters (, [, {, or <,\nthe literal consists of the characters up to the matching closing delimiter,\ntaking account of nested delimiter pairs. For all other delimiters, the\nliteral comprises the characters up to the next occurrence of the\ndelimiter character.  String interpolation #{ ... } is allowed.Returns the result of the shell command, just like the backticks.Docs: http://www.ruby-doc.org/docs/ProgrammingRuby/html/language.htmlKernel#systemExecutes the given command in a subshell. Returns true if the command was found and ran successfully, false otherwise.Docs: http://ruby-doc.org/core/Kernel.html#method-i-systemKernel#execReplaces the current process by running the given external command.Returns none, the current process is replaced and never continues.Docs: http://ruby-doc.org/core/Kernel.html#method-i-execHere\'s some extra advice:\n$?, which is the same as $CHILD_STATUS, accesses the status of the last system executed command if you use the backticks, system() or %x{}.\nYou can then access the exitstatus and pid properties:For more reading see:The way I like to do this is using the %x literal, which makes it easy (and readable!) to use quotes in a command, like so:Which, in this case, will populate file list with all test files under the current directory, which you can process as expected:Here\'s a flowchart based on this answer.  See also, using script to emulate a terminal.Here\'s the best article in my opinion about running shell scripts in Ruby: "6 Ways to Run Shell Commands in Ruby".If you only need to get the output use backticks.I needed more advanced stuff like STDOUT and STDERR so I used the Open4 gem. You have all the methods explained there.My favourite is Open3Some things to think about when choosing between these mechanisms are:You may need anything from simple backticks (``), system(), and IO.popen to full-blown Kernel.fork/Kernel.exec with IO.pipe and IO.select.You may also want to throw timeouts into the mix if a subprocess takes too long to execute.Unfortunately, it very much depends.One more option:When you:You can use shell redirection:The 2>&1 syntax works across Linux, Mac and Windows since the early days of MS-DOS.I\'m definitely not a Ruby expert, but I\'ll give it a shot:You should also be able to do things like:The answers above are already quite great, but I really want to share the following summary article: "6 Ways to Run Shell Commands in Ruby"Basically, it tells us:Kernel#exec:system and $?:Backticks (`):IO#popen:Open3#popen3 -- stdlib:Open4#popen4 -- a gem:You can also use the backtick operators (`), similar to Perl:Handy if you need something simple.Which method you want to use depends on exactly what you\'re trying to accomplish; check the docs for more details about the different methods.Using the answers here and linked in Mihai\'s answer, I put together a function that meets these requirements:As a bonus, this one will also return STDOUT in cases where the shell command exits successfully (0) and puts anything on STDOUT. In this manner, it differs from system, which simply returns true in such cases. Code follows. The specific function is system_quietly:We can achieve it in multiple ways.Using Kernel#exec, nothing after this command is executed:Using backticks or %xUsing Kernel#system command, returns true if successful, false if unsuccessful and returns nil if command execution fails:Don\'t forget the spawn command to create a background process to execute the specified command. You can even wait for its completion using the Process class and the returned pid:The doc says: This method is similar to #system but it doesn\'t wait for the command to finish.If you really need Bash, per the note in the "best" answer.First, note that when Ruby calls out to a shell, it typically calls /bin/sh, not Bash. Some Bash syntax is not supported by /bin/sh on all systems. If you need to use Bash, insert bash -c "your Bash-only command" inside of your desired calling method.quick_output = system("ls -la")quick_bash = system("bash -c \'ls -la\'")To test:\nsystem("echo $SHELL")\nsystem(\'bash -c "echo $SHELL"\')\nOr if you are running an existing script file (eg script_output = system("./my_script.sh")) Ruby should honor the shebang, but you could always use system("bash ./my_script.sh") to make sure (though there may be a slight overhead from /bin/sh running /bin/bash, you probably won\'t notice.If you have a more complex case than the common case (that can not be handled with ``) then check out Kernel.spawn() here. This seems to be the most generic/full-featured provided by stock Ruby to execute external commands.E.g. you can use it to:Official ruby documentation has good enough examples.backticks ` method is the easiest one to call shell commands from ruby. It returns the result of the shell command.easiest way is, for example:Here\'s a cool one that I use in a ruby script on OS X (so that I can start a script and get an update even after toggling away from the window):