How would you check if a String was a number before parsing it?With Apache Commons Lang 3.5 and above: NumberUtils.isCreatable or StringUtils.isNumeric.With Apache Commons Lang 3.4 and below: NumberUtils.isNumber or StringUtils.isNumeric.You can also use StringUtils.isNumericSpace which returns true for empty strings  and ignores internal spaces in the string. (The linked javadocs contain detailed examples for each method.)This is generally done with a simple user-defined function (i.e. Roll-your-own "isNumeric" function).Something like:However, if you\'re calling this function a lot, and you expect many of the checks to fail due to not being a number then performance of this mechanism will not be great, since you\'re relying upon exceptions being thrown for each failure, which is a fairly expensive operation.An alternative approach may be to use a regular expression to check for validity of being a number:Be careful with the above RegEx mechanism, though, as it\'ll fail if you\'re using non-arabic digits (i.e. numerals other than 0 through to 9).  This is because the "\\d" part of the RegEx will only match [0-9] and effectively isn\'t internationally numerically aware.  (Thanks to OregonGhost for pointing this out!)Or even another alternative is to use Java\'s built-in java.text.NumberFormat object to see if, after parsing the string the parser position is at the end of the string.  If it is, we can assume the entire string is numeric:if you are on android, then you should use:documentation can be found herekeep it simple. mostly everybody can "re-program" (the same thing).As @CraigTP had mentioned in his excellent answer, I also have similar performance concerns on using Exceptions to test whether the string is numerical or not. So I end up splitting the string and use java.lang.Character.isDigit().According to the Javadoc, Character.isDigit(char) will correctly recognizes non-Latin digits. Performance-wise, I think a simple N number of comparisons where N is the number of characters in the string would be more computationally efficient than doing a regex matching.UPDATE: As pointed by Jean-Fran\xc3\xa7ois Corbett in the comment, the above code would only validate positive integers, which covers the majority of my use case. Below is the updated code that correctly validates decimal numbers according to the default locale used in your system, with the assumption that decimal separator only occur once in the string.Java 8 lambda expressions.Google\'s Guava library provides a nice helper method to do this: Ints.tryParse. You use it like Integer.parseInt but it returns null rather than throw an Exception if the string does not parse to a valid integer. Note that it returns Integer, not int, so you have to convert/autobox it back to int.Example:However, as of the current release -- Guava r11 -- it is still marked @Beta. I haven\'t benchmarked it. Looking at the source code there is some overhead from a lot of sanity checking but in the end they use Character.digit(string.charAt(idx)), similar, but slightly different from, the answer from @Ibrahim above. There is no exception handling overhead under the covers in their implementation.Do not use Exceptions to validate your values.\nUse Util libs instead like apache NumberUtils:Why is everyone pushing for exception/regex solutions?While I can understand most people are fine with using try/catch, if you want to do it frequently... it can be extremely taxing.What I did here was take the regex, the parseNumber() methods, and the array searching method to see which was the most efficient. This time, I only looked at integer numbers.The results in speed I got were:Disclaimer: I\'m not claiming these methods are 100% optimized, they\'re just for demonstration of the dataExceptions won if and only if the number is 4 characters or less, and every string is always a number... in which case, why even have a check?    In short, it is extremely painful if you run into invalid numbers frequently with the try/catch, which makes sense. An important rule I always follow is NEVER use try/catch for program flow. This is an example why.Interestingly, the simple if char <0 || >9 was extremely simple to write, easy to remember (and should work in multiple languages) and wins almost all the test scenarios.The only downside is that I\'m guessing Integer.parseInt() might handle non ASCII numbers, whereas the array searching method does not.For those wondering why I said it\'s easy to remember the character array one, if you know there\'s no negative signs, you can easily get away with something condensed as this:Lastly as a final note, I was curious about the assigment operator in the accepted example with all the votes up. Adding in the assignment ofis not only useless since you don\'t even use the value, but it wastes processing time and increased the runtime by a few nanoseconds (which led to a 100-200 ms increase in the tests). I can\'t see why anyone would do that since it actually is extra work to reduce performance.You\'d think that would be optimized out... though maybe I should check the bytecode and see what the compiler is doing. That doesn\'t explain why it always showed up as lengthier for me though if it somehow is optimized out... therefore I wonder what\'s going on. As a note: By lengthier, I mean running the test for 10000000 iterations, and running that program multiple times (10x+) always showed it to be slower.EDIT: Updated a test for Character.isDigit()CraigTP\'s regular expression (shown above) produces some false positives.  E.g. "23y4" will be counted as a number because \'.\' matches any character not the decimal point.Also it will reject any number with a leading \'+\'An alternative which avoids these two minor problems is If you using java to develop Android app, you could using TextUtils.isDigitsOnly function.You can use NumberFormat#parse:Here was my answer to the problem.A catch all convenience method which you can use to parse any String with any type of parser: isParsable(Object parser, String str). The parser can be a Class or an object. This will also allows you to use custom parsers you\'ve written and should work for ever scenario, eg:Here\'s my code complete with method descriptions.To match only positive base-ten integers, that contains only ASCII digits, use:Here is my class for checking if a string is numeric. It also fixes numerical strings:Here you go...A well-performing approach avoiding try-catch and handling negative numbers and scientific notation.Regex MatchingHere is another example upgraded "CraigTP" regex matching with more validations.Regex TestExceptions are expensive, but in this case the RegEx takes much longer. The code below shows a simple test of two functions -- one using exceptions and one using regex. On my machine the RegEx version is 10 times slower than the exception.That\'s why I like the Try* approach in .NET. In addition to the traditional Parse method that\'s like the Java one, you also have a TryParse method. I\'m not good in Java syntax (out parameters?), so please treat the following as some kind of pseudo-code. It should make the concept clear though.Usage:This a simple example for this check:Parse it (i.e. with Integer#parseInt ) and simply catch the exception. =)To clarify: The parseInt function checks if it can parse the number in any case (obviously) and if you want to parse it anyway, you are not going to take any performance hit by actually doing the parsing.If you would not want to parse it (or parse it very, very rarely) you might wish to do it differently of course.Here are two methods that might work. (Without using Exceptions).\nNote : Java is a pass-by-value by default and a String\'s value is the address of the String\'s object data.\nSo , when you are doing You have changed the input value to have no spaces.\nYou can remove that line if you want.Here is another method in case you want to allow floats\nThis method allegedly allows numbers in the form to pass\n1,123,123,123,123,123.123\ni have just made it , and i think it needs further testing to ensure it is working.I modified CraigTP\'s solution to accept scientific notation and both dot and comma as decimal separators as wellexampleYou can use the java.util.Scanner object.// please check below codeYou can use NumberUtils.isCreatable() from Apache Commons Lang.Since NumberUtils.isNumber will be deprecated in 4.0, so use  NumberUtils.isCreatable() instead.This is the fastest way i know to check if String is Number or not:I think the only way to reliably tell if a string is a number, is to parse it. So I would just parse it, and if it\'s a number, you get the number in an int for free!You could use BigDecimal if the string may contain decimals:If you want to do the check using a regex you should create a final static Pattern object, that way the regex only needs to be compiled once. Compiling the regex takes about as long as performing the match so by taking this precaution you\'ll cut the execution time of the method in half.I\'m assuming a number is a string with nothing but decimal digits in it, possibly a + or - sign at the start and at most one decimal point (not at the end) and no other characters (including commas, spaces, numbers in other counting systems, Roman numerals, hieroglyphs).This solution is succinct and pretty fast but you can shave a couple of milliseconds per million invocations by doing it like this