I\'m learning the Python programming language and I\'ve came across something I don\'t fully understand. In a method like:What does self do?  What is it meant to be?  Is it mandatory?What does the __init__ method do?  Why is it necessary? (etc.)I think they might be OOP constructs, but I don\'t know very much.In this code:... the self variable represents the instance of the object itself.  Most object-oriented languages pass this as a hidden parameter to the methods defined on an object; Python does not.  You have to declare it explicitly.  When you create an instance of the A class and call its methods, it will be passed automatically, as in ...The __init__ method is roughly what represents a constructor in Python.  When you call A() Python creates an object for you, and passes it as the first parameter to the __init__ method.  Any additional parameters (e.g., A(24, \'Hello\')) will also get passed as arguments--in this case causing an exception to be raised, since the constructor isn\'t expecting them.Yep, you are right, these are oop constructs.__init__ is the constructor for a class.  The self parameter refers to the instance of the object (like this in C++).The __init__ method gets called when memory for the object is allocated:It is important to use the self parameter inside an object\'s method if you want to persist the value with the object.  If, for instance, you implement the __init__ method like this:Your x and y parameters would be stored in variables on the stack and would be discarded when the init method goes out of scope.  Setting those variables as self._x and self._y sets those variables as members of the Point object (accessible for the lifetime of the object).In the hope it might help a little, here\'s a simple example I used to understand the difference between a variable declared inside a class, and a variable declared inside an __init__ function:In short:__init__ does act like a constructor. You\'ll need to pass "self" to any class functions as the first argument if you want them to behave as non-static methods. "self" are instance variables for your class.Try out this code. Hope it helps many C programmers like me to Learn Py.Output:JaySum =  5Doc - Inside ClassDoc - __init__ ConstructorDoc - Inside ShowDestructor Deleting object -  JayHad trouble undestanding this myself. Even after reading the answers here. To properly understand the __init__ method you need to understand self. The self ParameterThe arguments accepted by the __init__ method are :But we only actually pass it two arguments :Where has the extra argument come from ?When we access attributes of an object we do it by name (or by reference). Here instance is a reference to our new object. We access the printargs method of the instance object using instance.printargs.In order to access object attributes from within the __init__ method we need a reference to the object.Whenever a method is called, a reference to the main object is passed as the first argument. By convention you always call this first argument to your methods self.This means in the __init__ method we can do :Here we are setting attributes on the object. You can verify this by doing the following :values like this are known as object attributes. Here the __init__ method sets the arg1 and arg2 attributes of the instance.source: http://www.voidspace.org.uk/python/articles/OOP.shtml#the-init-methodnote that self could actually be any valid python identifier.  For example, we could just as easily write, from Chris B\'s example:and it would work exactly the same.  It is however recommended to use self because other pythoners will recognize it more easily.Basically, you need to use the \'self\' keyword when using a variable in multiple functions within the same class. As for init, it\'s used to setup default values incase no other functions from within that class are called.The \'self\' is a reference to the class instanceNow we can create an instance of foo and call the method on it, the self parameter is added by Python in this case:But it can be passed in as well if the method call isn\'t in the context of an instance of the class, the code below does the same thingInterestingly the variable name \'self\' is just a convention. The below definition will work exactly the same.. Having said that it is very strong convention which should be followed always, but it does say something about flexible nature of the languageYou would be correct, they are object-oriented constructs. Basically self is a reference (kind of like a pointer, but self is a special reference which you can\'t assign to) to an object, and __init__ is a function which is called to initialize the object - that is, set the values of variables etc. - just after memory is allocated for it.In this code:class Cat:\n    def __init__(self, name):\n        self.name = name\n    def info(self):\n        print \'I am a cat and I am called\', self.nameHere __init__ acts as a constructor for the class and when an object is instantiated, this function is called. self represents the instantiating object.c = Cat(\'Kitty\')\nc.info()The result of the above statements will be as follows:I am a cat and I am called KittyHere, the guy has written pretty well and simple: https://www.jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/Read above link  as a reference to this:self? So what\'s with that self parameter to all of the Customer\n  methods? What is it? Why, it\'s the instance, of course! Put another\n  way, a method like withdraw defines the instructions for withdrawing\n  money from some abstract customer\'s account. Calling\n  jeff.withdraw(100.0) puts those instructions to use on the jeff\n  instance.So when we say def withdraw(self, amount):, we\'re saying, "here\'s how\n  you withdraw money from a Customer object (which we\'ll call self) and\n  a dollar figure (which we\'ll call amount). self is the instance of the\n  Customer that withdraw is being called on. That\'s not me making\n  analogies, either. jeff.withdraw(100.0) is just shorthand for\n  Customer.withdraw(jeff, 100.0), which is perfectly valid (if not often\n  seen) code.init self may make sense for other methods, but what about init? When we call init, we\'re in the process of creating an object, so how can there already be a self? Python allows us to extend\n  the self pattern to when objects are constructed as well, even though\n  it doesn\'t exactly fit. Just imagine that jeff = Customer(\'Jeff\n  Knupp\', 1000.0) is the same as calling jeff = Customer(jeff, \'Jeff\n  Knupp\', 1000.0); the jeff that\'s passed in is also made the result.This is why when we call init, we initialize objects by saying\n  things like self.name = name. Remember, since self is the instance,\n  this is equivalent to saying jeff.name = name, which is the same as\n  jeff.name = \'Jeff Knupp. Similarly, self.balance = balance is the same\n  as jeff.balance = 1000.0. After these two lines, we consider the\n  Customer object "initialized" and ready for use.Be careful what you __init__After init has finished, the caller can rightly assume that the\n  object is ready to use. That is, after jeff = Customer(\'Jeff Knupp\',\n  1000.0), we can start making deposit and withdraw calls on jeff; jeff is a fully-initialized object.Section 9.3 in this Python tutorial gives a short introduction to the basic elements of a Python class: class variables, class methods and the roles of__init__ and __self__.