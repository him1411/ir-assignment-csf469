Consider the below code:So, I want to copy the \'dum\' to \'dumtwo\' and I want to change \'dum\' without affecting the \'dumtwo\'. But the above code is not doing that. When I change something in \'dum\', the same change is happening in \'dumtwo\' also.I guess, when I say dumtwo = dum, Java copies the reference only. So, is there any way to create a fresh copy of \'dum\' and assign it to \'dumtwo\'?Create a copy constructor:Every object has also a clone method which can be used to copy the object, but don\'t use it. It\'s way too easy to create a class and do improper clone method. If you are going to do that, read at least what Joshua Bloch has to say about it in Effective Java.Basic: Object Copying in Java.Let us Assume an object- obj1, that contains two objects, containedObj1 and containedObj2. \nshallow copying:\nshallow copying creates a new instance of the same class and copies all the fields to the new instance and returns it. Object class provides a clone method and provides support for the shallow copying. \nDeep copying:\nA deep copy occurs when an object is copied along with the objects to which it refers. Below image shows obj1 after a deep copy has been performed on it. Not only has obj1 been copied, but the objects contained within it have been copied as well. We can use Java Object Serialization to make a deep copy. Unfortunately, this approach has some problems too(detailed examples). \nPossible Problems:\nclone is tricky to implement correctly.\nIt\'s better to use Defensive copying, copy constructors(as @egaga reply) or static factory methods.For example org.apache.commons.lang.SerializationUtils will have method for Deep clone using serialization(Source). If we need to clone Bean then there are couple of utility methods in org.apache.commons.beanutils (Source).Just follow as below:and wherever you want to get another object, simple perform cloning.\ne.g: In the package import org.apache.commons.lang.SerializationUtils; there is a method:Example:Why is there no answer for using Reflection API?It\'s really simple.EDIT: Include child object via recursionYes, you are just making a reference to the object. You can clone the object if it implements Cloneable.Check out this wiki article about copying objects.Refer here: Object copyingI use Google\'s JSON library to serialize it then create a new instance of the serialized object. It does deep copy with a few restrictions:there can\'t be any recursive referencesit won\'t copy arrays of disparate typesarrays and lists should be typed or it won\'t find the class to instantiateyou may need to encapsulate strings in a class you declare yourselfI also use this class to save user preferences, windows and whatnot to be reloaded at runtime. It is very easy to use and effective.Yes. You need to Deep Copy your object.Add Cloneable and below code to your classUse this  clonedObject = (YourClass) yourClassObject.clone();To do that you have to clone the object in some way. Although Java has a cloning mechanism, don\'t use it if you don\'t have to. Create a copy method that does the copy work for you, and then do:Here is some more advice on different techniques for accomplishing a copy.Here\'s a decent explanation of clone() if you end up needing it...Here: clone (Java method)Use a deep cloning utility: This will deep copy any java object, check it out at https://github.com/kostaskougios/cloningOther than explicitly copying, another approach is to make the object immutable (no set or other mutator methods). In this way the question never arises. Immutability becomes more difficult with larger objects, but that other side of that is that it pushes you in the direction of splitting into coherent small objects and composites.Deep Cloning is your answer, which requires implementing the Cloneable interface and overriding the clone() method.You will call it like this\nDummyBean dumtwo = dum.clone();This works too. Assuming modelFirst add\ncompile \'com.google.code.gson:gson:2.8.1\' to your app>gradle & sync. ThenYou can exclude using a field by using transient keyword after access modifier.Note: This is bad practice. Also don\'t recommend to use Cloneable or JavaSerialization It\'s slow and broken. Write copy constructor for best performance ref.Something likeTest stats of 90000 iteration:\nLine UserAccount clone = gson.fromJson(gson.toJson(aO), UserAccount.class); takes 808msLine UserAccount clone = new UserAccount(aO); takes less than 1msConclusion: Use gson if your boss is crazy and you prefer speed. Use second copy constructor if you prefer quality.You can also use copy constructor code generator plugin in Android Studio.You can deep copy automatically with XStream, from http://x-stream.github.io/:XStream is a simple library to serialize objects to XML and back\n  again.Add it to your project (if using maven)ThenWith this you have a copy without the need to implement any cloning interface.Pass the object whcih you wants to copy and get the object which you wants ,Now parse the objDest to desigered object.Happy CodingYou can try to implement Cloneable and use the clone() method; however, if you use the clone method you should - by standard - ALWAYS override Object\'s public Object clone() method.If you can add an annotation to the source file, an annotation processor or code generator like this one can be used.A class DummyBeanBuilders will be generates, which has a static method dummyBeanUpdater to create shallow copies, the same way as you would do it manually.