Java has a convenient split method:Is there an easy way to do this in C++?Your simple case can easily be built using the std::string::find method. However, take a look at Boost.Tokenizer. It\'s great. Boost generally has some very cool string tools.The Boost tokenizer class can make this sort of thing quite simple:Updated for C++11:Here\'s a real simple one:Use strtok.  In my opinion, there isn\'t a need to build a class around tokenizing unless strtok doesn\'t provide you with what you need.  It might not, but in 15+ years of writing various parsing code in C and C++, I\'ve always used strtok.  Here is an exampleA few caveats (which might not suit your needs).  The string is "destroyed" in the process, meaning that EOS characters are placed inline in the delimter spots.  Correct usage might require you to make a non-const version of the string.  You can also change the list of delimiters mid parse.In my own opinion, the above code is far simpler and easier to use than writing a separate class for it.  To me, this is one of those functions that the language provides and it does it well and cleanly.  It\'s simply a "C based" solution.  It\'s appropriate, it\'s easy, and you don\'t have to write a lot of extra code :-)Another quick way is to use getline. Something like:If you want, you can make a simple split() method returning a vector<string>, which is \nreally useful. You can use streams, iterators, and the copy algorithm to do this fairly directly.No offense folks, but for such a simple problem, you are making things way too complicated. There are a lot of reasons to use Boost. But for something this simple, it\'s like hitting a fly with a 20# sledge.For example (for Doug\'s case),And yes, we could have split() return a new vector rather than passing one in. It\'s trivial to wrap and overload. But depending on what I\'m doing, I often find it better to re-use pre-existing objects rather than always creating new ones. (Just as long as I don\'t forget to empty the vector in between!)Reference: http://www.cplusplus.com/reference/string/string/.(I was originally writing a response to Doug\'s question: C++ Strings Modifying and Extracting based on Separators (closed). But since Martin York closed that question with a pointer over here... I\'ll just generalize my code.)Boost has a strong split function: boost::algorithm::split.Sample program:Output:I know you asked for a C++ solution, but you might consider this helpful:QtThe advantage over Boost in this example is that it\'s a direct one to one mapping to your post\'s code.See more at Qt documentationHere is a sample tokenizer class that might do what you want Example:pystring is a small library which implements a bunch of Python\'s string functions, including the split method:This is a simple STL-only solution (~5 lines!) using std::find and std::find_first_not_of that handles repetitions of the delimiter (like spaces or periods for instance), as well leading and trailing delimiters:Try it out live!I posted this answer for similar question.\nDon\'t reinvent the wheel.  I\'ve used a number of libraries and the fastest and most flexible I have come across is:  C++ String Toolkit Library.  Here is an example of how to use it that I\'ve posted else where on the stackoverflow.Check this example. It might help you..You can simply use a regular expression library and solve that using regular expressions.Use expression (\\w+) and the variable in \\1 (or $1 depending on the library implementation of regular expressions).A solution using regex_token_iterators:If you\'re willing to use C, you can use the strtok function. You should pay attention to multi-threading issues when using it.For simple stuff I just use the following:Cowardly disclaimer: I write real-time data processing software where the data comes in through binary files, sockets, or some API call (I/O cards, camera\'s). I never use this function for something more complicated or time-critical than reading external configuration files on startup.MFC/ATL has a very nice tokenizer.  From MSDN:Many overly complicated suggestions here.  Try this simple std::string solution:I thought that was what the >> operator on string streams was for:Adam Pierce\'s answer provides an hand-spun tokenizer taking in a const char*. It\'s a bit more problematic to do with iterators because incrementing a string\'s end iterator is undefined. That said, given string str{ "The quick brown fox" } we can certainly accomplish this:Live ExampleIf you\'re looking to abstract complexity by using standard functionality, as On Freund suggests strtok is a simple option: If you don\'t have access to C++17 you\'ll need to substitute data(str) as in this example: http://ideone.com/8kAGoaThough not demonstrated in the example, strtok need not use the same delimiter for each token. Along with this advantage though, there are several drawbacks:Both the previous methods cannot generate a tokenized vector in-place, meaning without abstracting them into a helper function they cannot initialize const vector<string> tokens. That functionality and the ability to accept any white-space delimiter can be harnessed using an istream_iterator. For example given: const string str{ "The  quick \\tbrown \\nfox" } we can do this:Live ExampleThe required construction of an istringstream for this option has far greater cost than the previous 2 options, however this cost is typically hidden in the expense of string allocation.If none of the above options are flexable enough for your tokenization needs, the most flexible option is using a regex_token_iterator of course with this flexibility comes greater expense, but again this is likely hidden in the string allocation cost. Say for example we want to tokenize based on non-escaped commas, also eating white-space, given the following input: const string str{ "The ,qu\\\\,ick ,\\tbrown, fox" } we can do this:Live ExampleHere\'s an approach that allows you control over whether empty tokens are included (like strsep) or excluded (like strtok). Seems odd to me that with all us speed conscious nerds here on SO no one has presented a version that uses a compile time generated look up table for the delimiter (example implementation further down). Using a look up table and iterators should beat std::regex in efficiency, if you don\'t need to beat regex, just use it, its standard as of C++11 and super flexible.Some have suggested regex already but for the noobs here is a packaged example that should do exactly what the OP expects:If we need to be faster and accept the constraint that all chars must be 8 bits we can make a look up table at compile time using metaprogramming:With that in place making a getNextToken function is easy:Using it is also easy:Here is a live example: http://ideone.com/GKtkLQ There is no direct way to do this. Refer this code project source code to find out how to build a class for this.you can take advantage of boost::make_find_iterator. Something similar to this:If the maximum length of the input string to be tokenized is known, one can exploit this and implement a very fast version. I am sketching the basic idea below, which was inspired by both strtok() and the "suffix array"-data structure described Jon Bentley\'s "Programming Perls" 2nd edition, chapter 15. The C++ class in this case only gives some organization and convenience of use. The implementation shown can be easily extended for removing leading and trailing whitespace characters in the tokens.Basically one can replace the separator characters with string-terminating \'\\0\'-characters and set pointers to the tokens withing the modified string. In the extreme case when the string consists only of separators, one gets string-length plus 1 resulting empty tokens. It is practical to duplicate the string to be modified.Header file:Implementattion file:A scenario of usage would be:output:boost::tokenizer is your friend, but consider making your code portable with reference to internationalization (i18n) issues by using wstring/wchar_t instead of the legacy string/char types.Simple C++ code (standard C++98), accepts multiple delimiters (specified in a std::string), uses only vectors, strings and iterators.The boost library is good, but they are not always available. Doing this sort of things by hand is also a good brain exercise. Here we just use the std::search() algorithm from the STL, see the above code.