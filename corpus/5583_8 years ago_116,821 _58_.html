What\'s the simplest way to get the most recent tag in Git?output:Should I write a script to get each tag\'s datetime and compare them?You could take a look at git describe, which does something close to what you\'re asking.This one worked:Will output the tag of the latest tagged commit across all branchesHow about this?TAG=$(git describe $(git rev-list --tags --max-count=1))Technically, won\'t necessarily get you the latest tag, but the latest commit which is tagged, which may or may not be the thing you\'re looking for.git describe --tagsreturns the last tag able to be seen by current branchTo get the most recent tag, you can do:Of course, you can change the count argument or the sort field as desired.  It appears\nthat you may have meant to ask a slightly different question, but this does answer the question as I interpret it."Most recent" could have two meanings in terms of git.You could mean, "which tag has the creation date latest in time", and most of the answers here are for that question.  In terms of your question, you would want to return tag c. Or you could mean "which tag is the closest in development history to some named branch", usually the branch you are on, HEAD.  In your question, this would return tag a.These might be different of course:Imagine the developer tag\'ed Z as v0.2 on Monday, and then tag\'ed Q as v0.1 on Tuesday.  v0.1 is the more recent, but v0.2 is closer in development history to HEAD, in the sense that the path it is on starts at a point closer to HEAD.I think you usually want this second answer, closer in development history.  You can find that out by using git log v0.2..HEAD etc for each tag. This gives you the number of commits on HEAD since the path ending at v0.2 diverged from the path followed by HEAD.Here\'s a Python script that does that by iterating through all the tags running this check, and then printing out the tag with fewest commits on HEAD since the tag path diverged:https://github.com/MacPython/terryfy/blob/master/git-closest-taggit describe does something slightly different, in that it tracks back from (e.g.) HEAD to find the first tag that is on a path back in the history from HEAD.  In git terms, git describe looks for tags that are "reachable" from HEAD.   It will therefore not find tags like v0.2 that are not on the path back from HEAD, but a path that diverged from there.IF YOU NEED MORE THAN ONE LAST TAG(git describe --tags sometimes gives wrong hashes, i dont know why, but for me --max-count 2 doesnt work)this is how you can get list with latest 2 tag names in reverse chronological order, works perfectly on git 1.8.4. \nFor earlier versions of git(like 1.7.*), there is no "tag: " string in output - just delete last sed callIf you want more than 2 latest tags - change this "sed 2q" to "sed 5q" or whatever you needThen you can easily parse every tag name to variable or so.Get the last tag with prefix "ac". For example, tag named with ac1.0.0, or ac1.0.5. Other tags named 1.0.0, 1.1.0 will be ignored.Get the last tag, whose first char is 0-9. So, those tags with first char a-z will be ignored.List tags with names that match the given pattern (or all if no\n             pattern is given). Running "git tag" without arguments also lists\n             all tags. The pattern is a shell wildcard (i.e., matched using\n             fnmatch(3)). Multiple patterns may be given; if any of them\n             matches, the tag is shown.With git tag --help, about the sort argument. It will use lexicorgraphic order by default, if tag.sort property doesn\'t exist.Sort order\n             defaults to the value configured for the tag.sort variable if it\n             exists, or lexicographic order otherwise. See git-config(1).After google, someone said git 2.8.0 support following syntax.git describe --abbrev=0 --tagsIf you don\'t see latest tag, make sure of fetching origin before running that:git remote updateThe following works for me in case you need last two tags (for example, in order to generate change log between current tag and the previous tag). I\'ve tested it only in situation where the latest tag was the HEAD.It suits my needs, but as I\'m no git wizard, I\'m sure it could be further improved. I also suspect it will break in case the commit history moves forward. I\'m just sharing in case it helps someone.What is wrong  with all suggestions (except Matthew Brett explanation, up to date of this answer post)?Just run any command supplied by other on jQuery Git history when you at different point of history and check result with visual tagging history representation (I did that is why you see this post):Todays many project perform releases (and so tagging) in separate branch from mainline.There are strong reason for this. Just look to any well established JS/CSS projects. For user conventions they carry binary/minified release files in DVCS. Naturally as project maintainer you don\'t want to garbage your mainline diff history with useless binary blobs and perform commit of build artifacts out of mainline.Because Git uses DAG and not linear history - it is hard to define distance metric  so we can say - oh that rev is most nearest to my HEAD!I start my own journey in (look inside, I didn\'t copy fancy proof images to this long post):What is nearest tag in the past with respect to branching in Git?Currently I have 4 reasonable definition of distance between tag and revision with decreasing of usefulness:I don\'t know how to calculate length of shortest path.Script that sort tags according to  date of merge base between HEAD and tag:It usable on most of projects.Script that sort tags according to number of revs that reachable from HEAD but not reachable from tag:If your project history have strange dates on commits (because of rebases or another history rewriting or some moron forget to replace BIOS battery or other magics that you do on history) use above script.For last option (date of tag regardless merge base) to get list of tags sorted by date use:To get known current revision date use:Note that git describe --tags have usage on its own cases but not for finding human expected nearest tag in project history.NOTE You can use above recipes on any revision, just replace HEAD with what you want!My first thought is you could use git rev-list HEAD, which lists all the revs in reverse chronological order, in combination with git tag --contains. When you find a ref where git tag --contains produces a nonempty list, you have found the most recent tag(s).This is an old thread, but it seems a lot of people are missing the simplest, easiest, and most correct answer to OP\'s question: to get the latest tag for the current branch, you use git describe HEAD. Done.Edit: you can also supply any valid refname, even remotes; i.e., git describe origin/master will tell you the latest tag that can be reached from origin/master.