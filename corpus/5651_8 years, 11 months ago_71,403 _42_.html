It is much more convenient and cleaner to use a single statement likethan to import a bunch of individual classesWhat is wrong with using a wildcard in the import statement?The only problem with it is that it clutters your local namespace.  For example, let\'s say that you\'re writing a Swing app, and so need java.awt.Event, and are also interfacing with the company\'s calendaring system, which has com.mycompany.calendar.Event.  If you import both using the wildcard method, one of these three things happens:The advantage of explicitly listing all imports is that I can tell at a glance which class you meant to use, which simply makes reading the code that much easier. If you\'re just doing a quick one-off thing, there\'s nothing explicitly wrong, but future maintainers will thank you for your clarity otherwise.Here\'s a vote for star imports.  An import statement is intended to import a package, not a class.  It is much cleaner to import entire packages; the issues identified here (e.g. java.sql.Date vs java.util.Date) are easily remedied by other means, not really addressed by specific imports and certainly do not justify insanely pedantic imports on all classes.  There is nothing more disconcerting than opening a source file and having to page through 100 import statements.Doing specific imports makes refactoring more difficult; if you remove/rename a class, you need to remove all of its specific imports.  If you switch an implementation to a different class in the same package, you have to go fix the imports.  While these extra steps can be automated, they are really productivity hits for no real gain.If Eclipse didn\'t do class imports by default, everyone would still be doing star imports.  I\'m sorry, but there\'s really no rational justification for doing specific imports. Here\'s how to deal with class conflicts:please see my article Import on Demand is EvilIn short, the biggest problem is that your code can break when a class is added to a package you import. For example:In Java 1.1, this was fine; List was found in java.awt and there was no conflict.Now suppose you check in your perfectly working code, and a year later someone else brings it out to edit it, and is using Java 1.2.Java 1.2 added an interface named List to java.util. BOOM! Conflict. The perfectly working code no longer works.This is an EVIL language feature. There is NO reason that code should stop compiling just because a type is added to a package...In addition, it makes it difficult for a reader to determine which "Foo" you\'re using.It\'s not bad to use a wild card with a Java import statement.In Clean Code, Robert C. Martin actually recommends using them to avoid long import lists.Here is the recommendation:J1: Avoid Long Import Lists by Using\n  WildcardsIf you use two or more classes from a\n  package, then import the whole package\n  withimport package.*;Long lists of imports are daunting to\n  the reader. We don\xe2\x80\x99t want to clutter\n  up the tops of our modules with 80\n  lines of imports. Rather we want the\n  imports to be a concise statement\n  about which packages we collaborate\n  with.Specific imports are hard\n  dependencies, whereas wildcard imports\n  are not. If you specifically import a\n  class, then that class must exist. But\n  if you import a package with a\n  wildcard, no particular classes need\n  to exist. The import statement simply\n  adds the package to the search path\n  when hunting for names. So no true\n  dependency is created by such imports,\n  and they therefore serve to keep our\n  modules less coupled.There are times when the long list of\n  specific imports can be useful. For\n  example, if you are dealing with\n  legacy code and you want to find out\n  what classes you need to build mocks\n  and stubs for, you can walk down the\n  list of specific imports to find out\n  the true qualified names of all those\n  classes and then put the appropriate\n  stubs in place. However, this use for\n  specific imports is very rare.\n  Furthermore, most modern IDEs will\n  allow you to convert the wildcarded\n  imports to a list of specific imports\n  with a single command. So even in the\n  legacy case it\xe2\x80\x99s better to import\n  wildcards.Wildcard imports can sometimes cause\n  name conflicts and ambiguities. Two\n  classes with the same name, but in\n  different packages, will need to be\n  specifically imported, or at least\n  specifically qualified when used. This\n  can be a nuisance but is rare enough\n  that using wildcard imports is still\n  generally better than specific\n  imports.It clutters your namespace, requiring you to fully specify any classnames that are ambiguous. The most common occurence of this is with:It also helps make your dependencies concrete, as all of your dependencies are listed at the top of the file.Performance: No impact on performance as byte code is same.\nthough it will lead to some compile overheads.Compilation: on my personal machine, Compiling a blank class without importing anything takes 100 ms but same class when import java.* takes 170 ms.Most places I\'ve worked that use any significant amount of Java make explicit imports part of the coding standard.  I sometimes still use * for quick prototyping and then expand the import lists (some IDEs will do this for you as well) when productizing the code.I prefer specific imports, because it allows me to see all the external references used in the file without looking at the whole file.  (Yes, I know it won\'t necessarily show fully qualified references.  But I avoid them whenever possible.)In a previous project I found that changing from *-imports to specific imports reduced compilation time by half (from about 10 minutes to about 5 minutes). The *-import makes the compiler search each of the packages listed for a class matching the one you used. While this time can be small, it adds up for large projects.A side affect of the *-import was that developers would copy and paste common import lines rather than think about what they needed.In DDD bookIn whatever development technology the implementation will be based on, look for ways of minimizing the\n  work of refactoring MODULES . In Java, there is no escape from importing into individual classes, but you\n  can at least import entire packages at a time, reflecting the intention that packages are highly cohesive units\n  while simultaneously reducing the effort of changing package names.And if it clutters local namespace its not your fault - blame the size of the package.The most important one is that importing java.awt.* can make your program incompatible with a future Java version: Suppose that you have a class named "ABC", you\'re using JDK 8 and you import java.util.*. Now, suppose that Java 9 comes out, and it has a new class in package java.util that by coincidence also happens to be called "ABC". Your program now will not compile on Java 9, because the compiler doesn\'t know if with the name "ABC" you mean your own class or the new class in java.awt. You won\'t have that problem when you import only those classes explicitly from java.awt that you actually use. Resources:Java Imports