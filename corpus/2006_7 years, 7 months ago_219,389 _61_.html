I would like to rename/move a project subtree in Git moving it fromto If I use a plain git mv project components then all the file history for the xyz project gets lost.Is there a way to move this such that the history is maintained? Git detects renames rather than persisting the operation with the commit, so whether you use git mv or just a plain mv doesn\'t matter.The log command, however, takes a --follow argument that continues history before a rename operation (that is, it searches for similar content using the heuristics):http://git-scm.com/docs/git-logTo lookup the full history use the following command:It is possible to rename a file and keep the history intact, although it causes the file to be renamed throughout the entire history of the repository. This is probably only for the obsessive git-log-lovers, and has some serious implications, including these:Now, since you\'re still with me, you\'re a probably solo developer renaming a completely isolated file. Let\'s move a file using filter-tree!Assume you\'re going to move a file old into a folder dir and give it the name newThis could be done with git mv old dir/new && git add -u dir/new, but that breaks history.Instead:will redo every commit in the branch, executing the command in the ticks for each iteration. Plenty of stuff can go wrong when you do this. I normally test to see if the file is present (otherwise it\'s not there yet to move) and then perform the necessary steps to shoehorn the tree to my liking. Here you might sed through files to alter references to the file and so on. Knock yourself out! :)When completed, the file is moved and the log is intact. You feel like a ninja pirate.Also; The mkdir dir is only necessary if you move the file to a new folder, of course. The if will avoid the creation of this folder earlier in history than your file exists.The short answer is NO, it is not possible to rename a file in Git and remember the history.  And it is a pain.Rumor has it that git log --follow--find-copies-harder will work but it does not work for me, even if there are zero changes to the file contents, and the moves have been made with git mv.(Initially I used Eclipse to rename and update packages in one operation, which may have confused git.  But that is a very common thing to do. --follow does seem to work if only a mv is performed and then a commit and the mv is not too far.)Linus says that you are supposed to understand the entire contents of a software project holistically, not needing to track individual files.  Well, sadly, my small brain cannot do that.It is really annoying that so many people have mindlessly repeated the statement that git automatically track moves.  They have wasted my time.  Git does no such thing. By design(!) Git does not track moves at all.My solution is to rename the files back to their original locations.  Change the software to fit the source control.  With git you just seem to need to git it right the first time.Unfortunately, that breaks Eclipse, which seems to use --follow.\n  git log --follow\nSometimes does not show the full history of files with complicated rename histories even though \n  git log\ndoes.  (I do not know why.)(There are some too clever hacks that go back and recommit old work, but they are rather frightening. See GitHub-Gist: emiller/git-mv-with-history.)will show you the history through renames.I do:  This answer is based on git am inspired from Smar\'s answer borrowed from Exherbo\xe2\x80\x99s docs.Example: Extract history of file3, file4 and file5Set/clean the destinationExtract history of each file in email formatUnfortunately option --follow or --find-copies-harder cannot be combined with --reverse. This is why history is cut when file is renamed (or when a parent directory is renamed).Temporary history in email format:Dan Bonachea suggests to invert the loops of the git log generation command in this first step: rather than running git log once per file, run it exactly once with a list of files on the command line and generate a single unified log. This way commits that modify multiple files remain a single commit in the result, and all the new commits maintain their original relative order. Note this also requires changes in second step below when rewriting filenames in the (now unified) log. Suppose you want to move these three files in this other repo (can be the same repo).Therefore reorganize your files:Your temporary history is now:Change also filenames within the history:Your other repo is:Apply commits from temporary history files:--committer-date-is-author-date preserves the original commit time-stamps (Dan Bonachea\'s comment).Your other repo is now:Use git status to see amount of commits ready to be pushed :-)To list the files having been renamed:More customizations: You can complete the command git log using options --find-copies-harder or --reverse. You can also remove the first two columns using cut -f3- and grepping complete pattern \'{.* => .*}\'.While the core of git, the git plumbing doesn\'t keep track of renames, the history you display with the git log "porcelain" can detect them if you like.For a given git log use the -M option:git log -p -MWith a current version of git.This works for other commands like git diff as well.There are options to make the comparisons more or less rigorous. If you rename a file without making significant changes to the file at the same time it makes it easier for git log and friends to detect the rename. For this reason some people rename files in one commit and change them in another.There\'s a cost in cpu use whenever you ask git to find where files have been renamed, so whether you use it or not, and when, is up to you.If you would like to always have your history reported with rename detection  in a particular repository you can use:git config diff.renames 1Files moving from one directory to another is detected. Here\'s an example:Please note that this works whenever you are using diff, not just with git log. For example:As a trial I made a small change in one file in a feature branch and committed it and then in the master branch I renamed the file, committed, and then made a small change in another part of the file and commited that. When I went to feature branch and merged from master the merge renamed the file and merged the changes. Here\'s the output from the merge:The result was a working directory with the file renamed and both text changes made. So it\'s possible for git to do the right thing despite the fact that it doesn\'t explicitly track renames.This is an late answer to an old question so the other answers may have been correct for the git version at the time.I make moving the files and then dowhich put in the sataging area all deleted/new files. Here git realizes that the file is moved. I do not know why but this works for me.