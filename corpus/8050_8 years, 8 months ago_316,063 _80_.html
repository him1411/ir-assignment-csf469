I need a simple floating point rounding function, thus: I can find ceil() and floor() in the math.h - but not round().Is it present in the standard C++ library under another name, or is it missing??There\'s no round() in the C++98 standard library. You can write one yourself though:The probable reason there is no round function in the C++98 standard library is that it can in fact be implemented in different ways. The above is one common way but there are others such as round-to-even, which is less biased and generally better if you\'re going to do a lot of rounding; it\'s a bit more complex to implement though.Boost offers a simple set of rounding functions.For more information, see the Boost documentation.Edit: Since C++11, there are std::round, std::lround, and std::llround.It may be worth noting that if you wanted an integer result from the rounding you don\'t need to pass it through either ceil or floor.  I.e.,The C++03 standard relies on the C90 standard for what the standard calls the Standard C Library which is covered in the draft C++03 standard (closest publicly available draft standard to C++03 is N1804) section 1.2 Normative references:The library described in clause 7 of ISO/IEC 9899:1990 and clause 7 of\n  ISO/IEC 9899/Amd.1:1995 is hereinafter called the Standard C\n  Library.1)If we go to the C documentation for round, lround, llround on cppreference we can see that round and related functions are part of C99 and thus won\'t be available in C++03 or prior. In C++11 this changes since C++11 relies on the C99 draft standard for C standard library and therefore provides std::round and for integral return types std::lround, std::llround :Another option also from C99 would be std::trunc which:Computes nearest integer not greater in magnitude than arg.If you need to support non C++11 applications your best bet would be to use boost round, iround, lround, llround or boost trunc.Rolling your own version of round is hardRolling your own is probably not worth the effort as Harder than it looks: rounding float to nearest integer, part 1, Rounding float to nearest integer, part 2 and Rounding float to nearest integer, part 3 explain:For example a common roll your implementation using std::floor and adding 0.5 does not work for all inputs:One input this will fail for is 0.49999999999999994, (see it live).Another common implementation involves casting a floating point type to an integral type, which can invoke undefined behavior in the case where the integral part can not be represented in the destination type. We can see this from the draft C++ standard section 4.9 Floating-integral conversions which says (emphasis mine):A prvalue of a floating point type can be converted to a prvalue of an\n  integer type. The conversion truncates; that is, the fractional part\n  is discarded. The behavior is undefined if the truncated value cannot\n  be represented in the destination type.[...]For example:Given std::numeric_limits<unsigned int>::max() is 4294967295 then the following call:will cause overflow, (see it live).We can see how difficult this really is by looking at this answer to Concise way to implement round() in C? which referencing newlibs version of single precision float round. It is a very long function for something which seems simple. It seems unlikely that anyone without intimate knowledge of floating point implementations could correctly implement this function:On the other hand if none of the other solutions are usable newlib could potentially be an option since it is a well tested implementation.It\'s available since C++11 in cmath (according to http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf)Output:It\'s usually implemented as floor(value + 0.5).Edit: and it\'s probably not called round since there are at least three rounding algorithms I know of: round to zero, round to closest integer, and banker\'s rounding. You are asking for round to closest integer.There are 2 problems we are looking at:Rounding conversions mean rounding \xc2\xb1 float/double to nearest floor/ceil float/double.\nMay be your problem ends here.\nBut if you are expected to return Int/Long, you need to perform type conversion, and thus "Overflow" problem might hit your solution. SO, do a check for error in your functionfrom : http://www.cs.tut.fi/~jkorpela/round.htmlA certain type of rounding is also implemented in Boost:Note that this works only if you do a to-integer conversion.You could round to n digits precision with:If you ultimately want to convert the double output of your round() function to an int, then the accepted solutions of this question will look something like:This clocks in at around 8.88ns on my machine when passed in uniformly random values.The below is functionally equivalent, as far as I can tell, but clocks in at 2.48ns on my machine, for a significant performance advantage:Among the reasons for the better performance is the skipped branching.Beware of floor(x+0.5), here is what can happen for odd numbers in range [2^52,2^53]:This is http://bugs.squeak.org/view.php?id=7134\nUse a solution like the one of @konikEDIT: my own robust version would be something likeEDIT 2: Another reason to avoid floor(x+0.5) is given hereThere is no need to implement anything, so I\'m not sure why so many answers involve defines, functions, or methods.In C99We have the following and and header <tgmath.h> for type-generic macros.If you cannot compile this, you have probably left out the math library.  A command similar to this works on every C compiler I have (several).In C++11We have the following and additional overloads in #include <cmath> that rely on IEEE double precision floating point.There are equivalents in the std namespace too.If you cannot compile this, you may be using C compilation instead of C++.  The following basic command produces neither errors nor warnings with g++ 6.3.1, x86_64-w64-mingw32-g++ 6.3.0, clang-x86_64++ 3.8.0, and Visual C++ 2015 Community.With Ordinal DivisionWhen dividing two ordinal numbers, where T is short, int, long, or another ordinal, the rounding expression is this.AccuracyThere is no doubt that odd looking inaccuracies appear in floating point operations, but this is only when the numbers appear, and has little to do with rounding.The source is not just the number of significant digits in the mantissa of the IEEE representation of a floating point number, it is related to our decimal thinking as humans.Ten is the product of five and two, and 5 and 2 are relatively prime.  Therefore the IEEE floating point standards cannot possibly be represented perfectly as decimal numbers for all binary digital representations.This is not an issue with the rounding algorithms.  It is mathematical reality that should be considered during the selection of types and the design of computations, data entry, and display of numbers.  If an application displays the digits that show these decimal-binary conversion issues, then the application is visually expressing accuracy that does not exist in digital reality and should be changed.function double round(double) with the use of modf function.To be compile clean, includes "math.h" and "limits" are necessary. The function works according to a following rounding schema:If you need to be able to compile code in environments that support the C++11 standard, but also need to be able to compile that same code in environments that don\'t support it, you could use a function macro to choose between std::round() and a custom function for each system.  Just pass -DCPP11 or /DCPP11 to the C++11-compliant compiler (or use its built-in version macros), and make a header like this:For a quick example, see http://ideone.com/zal709 .This approximates std::round() in environments that aren\'t C++11-compliant, including preservation of the sign bit for -0.0.  It may cause a slight performance hit, however, and will likely have issues with rounding certain known "problem" floating-point values such as 0.49999999999999994 or similar values.Alternatively, if you have access to a C++11-compliant compiler, you could just grab std::round() from its <cmath> header, and use it to make your own header that defines the function if it\'s not already defined.  Note that this may not be an optimal solution, however, especially if you need to compile for multiple platforms.Based on Kalaxy\'s response, the following is a templated solution that rounds any floating point number to the nearest integer type based on natural rounding. It also throws an error in debug mode if the value is out of range of the integer type, thereby serving roughly as a viable library function.I did this:And it seems to be working.I use the following implementation of round in asm for x86 architecture and MS VS specific C++:UPD: to return double valueOutput:One more solution with handling of negative values:It might be an inefficent dirty way of conversion but heck, it works lol. And its good because it applies to the actual float. Not just affecting the output visually.what i did wasThe accepted answer is wrong. For example, round(-3.7) = -4, but it will give you -3 instead of -4.Do this (suppose x is double):or if you want to cast since you are round a number.