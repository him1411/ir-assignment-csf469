Which of the following is better?orThe only difference that I know of is, when \'a\' is null, the first returns false, while the second throws an exception. Other than that, do they always give the same result?When using instanceof, you need to know the class of B at compile time.  When using isAssignableFrom() it can be dynamic and change during runtime.instanceof can only be used with reference types, not primitive types.  isAssignableFrom() can be used with any class objects:See http://java.sun.com/javase/6/docs/api/java/lang/Class.html#isAssignableFrom(java.lang.Class).Talking in terms of performance :TL;DRUse isInstance or instanceof which have similar performance. isAssignableFrom is slightly slower.Sorted by performance:Based on a benchmark of 2000 iterations on JAVA 8 Windows x64, with 20 warmup iterations.In theoryUsing a soft like bytecode viewer we can translate each operator into bytecode.In the context of:JAVA:Bytecode:JAVA:Bytecode:JAVA:Bytecode:Measuring how many bytecode instructions is used by each operator, we could expect instanceof and isInstance to be faster than isAssignableFrom. However, the actual performance is NOT determined by the bytecode but by the machine code (which is platform dependent). Let\'s do a micro benchmark for each of the operator.The benchmarkCredit: As advised by @aleksandr-dubinsky, and thanks to @yura for providing the base code, here is a JMH benchmark (see this tuning guide):Gave the following results (score is a number of operations in a time unit, so the higher the score the better):WarningTo give you an example, take the following loop:Thanks to the JIT, the code is optimized at some point and we get:NoteOriginally this post was doing its own benchmark using a for loop in raw JAVA, which gave unreliable results as some optimization like Just In Time can eliminate the loop. So it was mostly measuring how long did the JIT compiler take to optimize the loop: see Performance test independent of the number of iterations for more detailsRelated questionsA more direct equivalent to a instanceof B isThis works (returns false) when a is null too.Apart from basic differences mentioned above, there is a core subtle difference between instanceof operator and isAssignableFrom method in Class.Read instanceof as \xe2\x80\x9cis this (the left part) the instance of this or any subclass of this (the right part)\xe2\x80\x9d and read x.getClass().isAssignableFrom(Y.class) as \xe2\x80\x9cCan I write X x = new Y()\xe2\x80\x9d. In other words, instanceof operator checks if the left object is same or subclass of right class, while isAssignableFrom checks if we can assign object of the parameter class (from) to the reference of the class on which the method is called.\nNote that both of these consider the actual instance not the reference type.Consider an example of 3 classes A, B and C where C extends B and B extends A.There is also another difference:null instanceof X is false no matter what X isnull.getClass().isAssignableFrom(X) will throw a NullPointerExceptionThere is yet another difference. If the type (Class) to test against is dynamic, e.g. passed as a method parameter, then instanceof won\'t cut it for you.but you can do:Oops, I see this answer is already covered. Maybe this example is helpful to someone.This thread provided me some insight into how instanceof differed from isAssignableFrom, so I thought I\'d share something of my own.I have found that using isAssignableFrom to be the only (probably not the only, but possibly the easiest) way to ask one\'s self if a reference of one class can take instances of another, when one has instances of neither class to do the comparison.Hence, I didn\'t find using the instanceof operator to compare assignability to be a good idea when all I had were classes, unless I contemplated creating an instance from one of the classes; I thought this would be sloppy.Consider following situation. Suppose you want to check whether type A is a super class of the type of obj, you can go either...\nA.class.isAssignableFrom(obj.getClass())\n...OR...\nobj instanceof A\n...But the isAssignableFrom solution requires that the type of obj be visible here. If this is not the case (e.g., the type of obj might be of a private inner class), this option is out. However, the instanceof solution would always work.instanceof cannot be used with primitive types or generic types either.  As in the following code:The error is: Cannot perform instanceof check against type parameter T.  Use it\'s erasure Object instead since further generic type information will be erased at runtime.Does not compile due to type erasure removing the runtime reference.  However, the code below will compile:The pseudo code above is a definition of, if references of type/class A is assignable from references of type/class B. It is a recursive definition. To some it may be helpful, for others it may be confusing. I add it in case somebody should find it useful. This is just an attempt to capture my understanding, it is not the official definition. It is used in a certain Java VM implementation and works for many example programs, so while I cannot guarentee that it captures all aspects of isAssignableFrom, it is not completely off.Talking in terms of performance "2" (with JMH):It gives:So that we can conclude: instanceof as fast as isInstance() and isAssignableFrom() not far away (+0.9% executon time). So no real difference whatever you choosesome tests we did in our team show that A.class.isAssignableFrom(B.getClass()) works faster than B instanceof A. this can be very useful if you need to check this on large number of elements.