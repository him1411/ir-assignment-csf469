What is the purpose of __slots__ in Python \xe2\x80\x94 especially with respect to when would I want to use it and when not?The special attribute __slots__ allows you to explicitly state which instance attributes you expect your object instances to have, with the expected results:The space savings is from The biggest caveat is for multiple inheritance - multiple "parent classes with nonempty slots" cannot be combined. To accomodate this restriction, follow best practices: Factor out all but one or all parents\' abstraction which their concrete class respectively and your new concrete class collectively will inherit from - giving the abstraction(s) empty slots (just like abstract base classes in the standard library).To have attributes named in __slots__ to actually be stored in slots instead of a __dict__, a class must inherit from object.To prevent the creation of a __dict__, you must inherit from object and all classes in the inheritance must declare __slots__ and none of them can have a \'__dict__\' entry. There are a lot of details if you wish to keep reading.The creator of Python, Guido van Rossum, states that he actually created __slots__ for faster attribute access.  It is trivial to demonstrate measurably significant faster access:andThe slotted access is almost 30% faster in Python 3.5 on Ubuntu.In Python 2 on Windows I have measured it about 15% faster.Another purpose of __slots__ is to reduce the space in memory that each object instance takes up.  My own contribution to the documentation clearly states the reasons behind this: The space saved over using __dict__ can be significant.SQLAlchemy attributes a lot of memory savings to __slots__.To verify this, using the Anaconda distribution of Python 2.7 on Ubuntu Linux, with guppy.hpy (aka heapy) and sys.getsizeof, the size of a class instance without __slots__ declared, and nothing else, is 64 bytes. That does not include the __dict__. Thank you Python for lazy evaluation again, the __dict__ is apparently not called into existence until it is referenced, but classes without data are usually useless. When called into existence, the __dict__ attribute is a minimum of 280 bytes additionally. In contrast, a class instance with __slots__ declared to be () (no data) is only 16 bytes, and 56 total bytes with one item in slots, 64 with two.I tested when my particular implementation of dicts size up by enumerating alphabet characters into a dict, and on the sixth item it climbs to 1048, 22 to 3352, then 85 to 12568 (rather impractical to put that many attributes on a single class, probably violating the single responsibility principle there.)So we see how nicely __slots__ scale for instances to save us memory, and that is the reason you would want to use __slots__. To deny the creation of a __dict__, you must subclass object:now:Or subclass another class that defines __slots__and now:To allow __dict__ creation while subclassing slotted objects, just add \'__dict__\' to the __slots__ (note that slots are ordered, and you shouldn\'t repeat slots that are already in parent classes):Or you don\'t even need to declare __slots__ in your subclass, and you will still use slots from the parents, but not restrict the creation of a __dict__:However, __slots__ may cause problems for multiple inheritance:If you run into this problem, just remove __slots__, and put it back in where you have a lot of instances.and now:So with \'__dict__\' in slots we lose some of the size benefits with the upside of having dynamic assignment and still having slots for the names we do expect.When you inherit from an object that isn\'t slotted, you get the same sort of semantics when you use __slots__ - names that are in __slots__ point to  slotted values, while any other values are put in the instance\'s __dict__.Avoiding __slots__ because you want to be able to add attributes on the fly is actually not a good reason - just add "__dict__" to your __slots__ if this is required.You can similarly add __weakref__ to __slots__ explicitly if you need that feature.The namedtuple builtin make immutable instances that are very lightweight (essentially, the size of tuples) but to get the benefits, you need to do it yourself if you subclass them:usage:And trying to assign an unexpected attribute raises an AttributeError because we have prevented the creation of __dict__:You can allow __dict__ creation by leaving off __slots__ = (), but you can\'t use non-empty __slots__ with subtypes of tuple.Even when non-empty slots are the same for multiple parents, they cannot be used together:Using an empty __slots__ in the parent seems to provide the most flexibility, allowing the child to choose to prevent or allow (by adding \'__dict__\' to get dynamic assignment, see section above) the creation of a __dict__:You don\'t have to have slots - so if you add them, and remove them later, it shouldn\'t cause any problems.Going out on a limb here: If you\'re composing mixins or using abstract base classes, which aren\'t intended to be instantiated, an empty __slots__ in those parents seems to be the best way to go in terms of flexibility for subclassers.You may be able to tease out further caveats from the rest of the __slots__ documentation (the 3.7 dev docs are the most current), which I have made significant recent contributions to.The current top answers cite outdated information and are quite hand-wavy and miss the mark in some important ways.I quote:"You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class." Abstract Base Classes, for example, from the collections module, are not instantiated, yet __slots__ are declared for them. Why?If a user wishes to deny __dict__ or __weakref__ creation, those things must not be available in the parent classes.__slots__ contributes to reusability when creating interfaces or mixins.It is true that many Python users aren\'t writing for reusability, but when you are, having the option to deny unnecessary space usage is valuable.When pickling a slotted object, you may find it complains with a misleading TypeError: This is actually incorrect. This message comes from the oldest protocol, which is the default. You can select the latest protocol with the -1 argument. In Python 2.7 this would be 2 (which was introduced in 2.3), and in 3.6 it is 4.in Python 2.7:in Python 3.6So I would keep this in mind, as it is a solved problem.The first paragraph is half short explanation, half predictive. Here\'s the only part that actually answers the questionThe proper use of __slots__ is to save space in objects. Instead of having a dynamic dict that allows adding attributes to objects at anytime, there is a static structure which does not allow additions after creation. This saves the overhead of one dict for every object that uses slotsThe second half is wishful thinking, and off the mark:While this is sometimes a useful optimization, it would be completely unnecessary if the Python interpreter was dynamic enough so that it would only require the dict when there actually were additions to the object.Python actually does something similar to this, only creating the __dict__ when it is accessed, but creating lots of objects with no data is fairly ridiculous.The second paragraph oversimplifies and misses actual reasons to avoid __slots__. The below is not a real reason to avoid slots (for actual reasons, see the rest of my answer above.):They change the behavior of the objects that have slots in a way that can be abused by control freaks and static typing weenies.It then goes on to discuss other ways of accomplishing that perverse goal with Python, not discussing anything to do with __slots__.The third paragraph is more wishful thinking. Together it is mostly off-the-mark content that the answerer didn\'t even author and contributes to ammunition for critics of the site.Create some normal objects and slotted objects:Instantiate a million of them:Inspect with guppy.hpy().heap():Access the regular objects and their __dict__ and inspect again:This is consistent with the history of Python, from Unifying types and classes in Python 2.2If you subclass a built-in type, extra space is automatically added to the instances to accomodate __dict__ and __weakrefs__. (The __dict__ is not initialized until you use it though, so you shouldn\'t worry about the space occupied by an empty dictionary for each instance you create.) If you don\'t need this extra space, you can add the phrase "__slots__ = []" to your class.Quoting Jacob Hallen:The proper use of __slots__ is to save space in objects. Instead of having\n  a dynamic dict that allows adding attributes to objects at anytime,\n  there is a static structure which does not allow additions after creation.\n  [This use of __slots__ eliminates the overhead of one dict for every object.] While this is sometimes a useful optimization, it would be completely\n  unnecessary if the Python interpreter was dynamic enough so that it would\n  only require the dict when there actually were additions to the object.Unfortunately there is a side effect to slots. They change the behavior of\n  the objects that have slots in a way that can be abused by control freaks\n  and static typing weenies. This is bad, because the control freaks should\n  be abusing the metaclasses and the static typing weenies should be abusing\n  decorators, since in Python, there should be only one obvious way of doing something.Making CPython smart enough to handle saving space without __slots__ is a major\n  undertaking, which is probably why it is not on the list of changes for P3k (yet).You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class. __slots__ only exists as a memory optimization tool.It\'s highly discouraged to use __slots__ for constraining attribute creation, and in general you want to avoid it because it breaks pickle, along with some other introspection features of python.Each python object has a __dict__ atttribute which is a dictionary containing all other attributes. e.g. when you type self.attr python is actually doing self.__dict__[\'attr\']. As you can imagine using a dictionary to store attribute takes some extra space & time for accessing it.However, when you use __slots__, any object created for that class won\'t have a __dict__ attribute. Instead, all attribute access is done directly via pointers.So if want a C style structure rather than a full fledged class you can use __slots__ for compacting size of the objects & reducing attribute access time. A good example is a Point class containing attributes x & y. If you are going to have a lot of points, you can try using __slots__ in order to conserve some memory.In addition to the other answers, here is an example of using __slots__:So, to implement __slots__, it only takes an extra line (and making your class a new-style class if it isn\'t already). This way you can reduce the memory footprint of those classes 5-fold, at the expense of having to write custom pickle code, if and when that becomes necessary.Slots are very useful for library calls to eliminate the "named method dispatch" when making function calls.  This is mentioned in the SWIG documentation.  For high performance libraries that want to reduce function overhead for commonly called functions using slots is much faster.Now this may not be directly related to the OPs question.  It is related more to building extensions than it does to using the slots syntax on an object.  But it does help complete the picture for the usage of slots and some of the reasoning behind them.An attribute of a class instance has 3 properties: the instance, the name of the attribute, and the value of the attribute.In regular attribute access, the instance acts as a dictionary and the name of the attribute acts as the key in that dictionary looking up value.instance(attribute) --> valueIn __slots__ access, the name of the attribute acts as the dictionary and the instance acts as the key in the dictionary looking up value.attribute(instance) --> valueIn flyweight pattern, the name of the attribute acts as the dictionary and the value acts as the key in that dictionary looking up the instance.attribute(value) --> instanceAnother somewhat obscure use of __slots__ is to add attributes to an object proxy from the ProxyTypes package, formerly part of the PEAK project. Its ObjectWrapper allows you to proxy another object, but intercept all interactions with the proxied object. It is not very commonly used (and no Python 3 support), but we have used it to implement a thread-safe blocking wrapper around an async implementation based on tornado that bounces all access to the proxied object through the ioloop, using thread-safe concurrent.Future objects to synchronise and return results.By default any attribute access to the proxy object will give you the result from the proxied object. If you need to add an attribute on the proxy object, __slots__ can be used.You have \xe2\x80\x94 essentially \xe2\x80\x94 no use for __slots__.  For the time when you think you might need __slots__, you actually want to use Lightweight or Flyweight design patterns. These are cases when you no longer want to use purely Python objects. Instead, you want a Python object-like wrapper around an array, struct, or numpy array.The class-like wrapper has no attributes \xe2\x80\x94 it just provides methods that act on the underlying data. The methods can be reduced to class methods. Indeed, it could be reduced to just functions operating on the underlying array of data.A very simple example of __slot__ attribute.If I don\'t have __slot__ attribute  in my class, I can add new attributes to  my objects. If you look at example above, you can see that obj1 and obj2 have their own x and y attributes and python has also created  a dict attribute for each object (obj1 and obj2).Suppose if my class Test has thousands of such objects? Creating an additional attribute dict for each object will cause lot of overhead (memory, computing power etc.) in my code. Now in the following example my class Test contains __slots__ attribute. Now I can\'t add new attributes to my objects (except attribute x) and python doesn\'t create a dict attribute anymore. This eliminates overhead for each object, which can become significant if you have many objects.The original question was about general use cases not only about memory.\nSo it should be mentioned here that you also get better performance when instantiating large amounts of objects - interesting e.g. when parsing large documents into objects or from a database.Here is a comparison of creating object trees with a million entries, using slots and without slots. As a reference also the performance when using plain dicts for the trees (Py2.7.10 on OSX):Test classes (ident, appart from slots):testcode, verbose mode: