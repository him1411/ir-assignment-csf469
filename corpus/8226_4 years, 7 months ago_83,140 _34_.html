There are many blogs and discussions about websocket and HTTP, and many developers and sites strongly advocate websockets, but i still can not understand why.for example (arguments of websocket lovers):HTML5 Web Sockets represents the next evolution of web communications\xe2\x80\x94a full-duplex, bidirectional communications channel that operates through a single socket over the Web.\n    ( http://www.websocket.org/quantum.html )HTTP supports streaming: request body streaming(you are using it while uploading large files) and response body streaming.During making connection with WebSocket, client and server exchange data per frame which is 2 bytes each, compared to 8 kilo bytes of http header when you do continuous polling.Why does that 2 bytes not include tcp and under tcp protocols overhead?This is ~48 bytes http header.http chunked encoding - http://ru.wikipedia.org/wiki/Chunked_transfer_encoding :Also both protocol works over TCP, so all TCP issues with long-live connections are still there.Question:1) Why is the WebSockets protocol better?WebSockets is better for situations that involve low-latency communication especially for low latency for client to server messages. For server to client data you can get fairly low latency using long-held connections and chunked transfer. However, this doesn\'t help with client to server latency which requires a new connection to be established for each client to server message.Your 48 byte HTTP handshake is not realistic for real-world HTTP browser connections where there is often several kilobytes of data sent as part of the request (in both directions) including many headers and cookie data. Here is an example of a request/response to using Chrome:Example request (2800 bytes including cookie data, 490 bytes without cookie data):Example response (355 bytes):Both HTTP and WebSockets have equivalent sized initial connection handshakes, but with a WebSocket connection the initial handshake is performed once and then small messages only have 6 bytes of overhead (2 for the header and 4 for the mask value). The latency overhead is not so much from the size of the headers, but from the logic to parse/handle/store those headers. In addition, the TCP connection setup latency is probably a bigger factor than the size or processing time for each request.2) Why was it implemented instead of updating HTTP protocol?There are efforts to re-engineer the HTTP protocol to achieve better performance and lower latency such as SPDY, HTTP 2.0 and QUIC. This will improve the situation for normal HTTP requests, but it is likely that WebSockets and/or WebRTC DataChannel will still have lower latency for client to server data transfer than HTTP protocol (or it will be used in a mode that looks a lot like WebSockets anyways).Update: Here is a framework for thinking about web protocols:References:You seem to assume that WebSocket is a replacement for HTTP. It is not. It\'s an extension.The main use-case of WebSockets are Javascript applications which run in the web browser and receive real-time data from a server. Games are a good example.Before WebSockets, the only method for Javascript applications to interact with a server was through XmlHttpRequest. But these have a major disadvantage: The server can\'t send data unless the client has explicitly requested it.But the new WebSocket feature allows the server to send data whenever it wants. This allows to implement browser-based games with a much lower latency and without having to use ugly hacks like AJAX long-polling or browser plugins.So why not use normal HTTP with streamed requests and responsesIn a comment to another answer you suggested to just stream the client request and response body asynchronously.In fact, WebSockets are basically that. An attempt to open a WebSocket connection from the client looks like a HTTP request at first, but a special directive in the header (Upgrade: websocket) tells the server to start communicating in this asynchronous mode. First drafts of the WebSocket protocol weren\'t much more than that and some handshaking to ensure that the server actually understands that the client wants to communicate asynchronously. But then it was realized that proxy servers would be confused by that, because they are used to the usual request/response model of HTTP. A potential attack scenario against proxy servers was discovered. To prevent this it was necessary to make WebSocket traffic look unlike any normal HTTP traffic. That\'s why the masking keys were introduced in the final version of the protocol.For the TL;DR, here are 2 cents and a simpler version for your questions:WebSockets provides these benefits over HTTP:WebSocket and HTTP protocol have been designed to solve different problems, I.E. WebSocket was designed to improve bi-directional communication whereas HTTP was designed to be stateless, distributed using a request/response model. Other than the sharing the ports for legacy reasons (firewall/proxy penetration), there isn\'t much of a common ground to combine them into one protocol.The other answers do not seem to touch on a key aspect here, and that is you make no mention of requiring supporting a web browser as a client. Most of the limitations of plain HTTP above are assuming you would be working with browser/ JS implementations.The HTTP protocol is fully capable of full-duplex communication; it is legal to have a client perform a POST with chunked encoding transfer, and a server to return a response with a chunked-encoding body. This would remove the header overhead to just at init time.So if all you\'re looking for is full-duplex, control both client and server, and are not interested in extra framing/features of websockets, then I would argue that HTTP is a simpler approach with lower latency/CPU (although the latency would really only differ in microseconds or less for either).