Are there good reasons why it\'s a better practice to have only one return statement in a function? Or is it okay to return from a function as soon as it is logically correct to do so, meaning there may be many return statements in the function?I often have several statements at the start of a method to return for "easy" situations. For example, this:... can be made more readable (IMHO) like this:So yes, I think it\'s fine to have multiple "exit points" from a function/method.Nobody has mentioned or quoted Code Complete so I\'ll do it.Minimize the number of returns in each routine. It\'s harder to understand a routine if, reading it at the bottom, you\'re unaware of the possibility that it returned somewhere above.Use a return when it enhances readability. In certain routines, once you know the answer, you want to return it to the calling routine immediately. If the routine is defined in such a way that it doesn\'t require any cleanup, not returning immediately means that you have to write more code.I would say it would be incredibly unwise to decide arbitrarily against multiple exit points as I have found the technique to be useful in practice over and over again, in fact I have often refactored existing code to multiple exit points for clarity. We can compare the two approaches thus:-Compare this to the code where multiple exit points are permitted:-I think the latter is considerably clearer. As far as I can tell the criticism of multiple exit points is a rather archaic point of view these days.I currently am working on a codebase where two of the people working on it blindly subscribe to the "single point of exit" theory and I can tell you that from experience, it\'s a horrible horrible practice.  It makes code extremely difficult to maintain and I\'ll show you why.With the "single point of exit" theory, you inevitably wind up with code that looks like this:Not only does this make the code very hard to follow, but now say later on you need to go back and add an operation in between 1 and 2.  You have to indent just about the entire freaking function, and good luck making sure all of your if/else conditions and braces are matched up properly.This method makes code maintenance extremely difficult and error prone.Structured programming says you should only ever have one return statement per function. This is to limit the complexity. Many people such as Martin Fowler argue that it is simpler to write functions with multiple return statements. He presents this argument in the classic refactoring book he wrote. This works well if you follow his other advice and write small functions. I agree with this point of view and only strict structured programming purists adhere to single return statements per function.As Kent Beck notes when discussing guard clauses in Implementation Patterns making a routine have a single entry and exit point ..."was to prevent the confusion possible\n  when jumping into and out of many\n  locations in the same routine. It made\n  good sense when applied to FORTRAN or\n  assembly language programs written\n  with lots of global data where even\n  understanding which statements were\n  executed was hard work ... with small methods and mostly local data, it is needlessly conservative."I find a function written with guard clauses much easier to follow than one long nested bunch of if then else statements.In a function that has no side-effects, there\'s no good reason to have more than a single return and you should write them in a functional style. In a method with side-effects, things are more sequential (time-indexed), so you write in an imperative style, using the return statement as a command to stop executing.In other words, when possible, favor this styleover thisIf you find yourself writing several layers of nested conditions, there\'s probably a way you can refactor that, using predicate list for example. If you find that your ifs and elses are far apart syntactically, you might want to break that down into smaller functions. A conditional block that spans more than a screenful of text is hard to read.There\'s no hard and fast rule that applies to every language. Something like having a single return statement won\'t make your code good. But good code will tend to allow you to write your functions that way.I\'ve seen it in coding standards for C++ that were a hang-over from C, as if you don\'t have RAII or other automatic memory management then you have to clean up for each return, which either means cut-and-paste of the clean-up or a goto (logically the same as \'finally\' in managed languages), both of which are considered bad form. If your practices are to use smart pointers and collections in C++ or another automatic memory system, then there isn\'t a strong reason for it, and it become all about readability, and more of a judgement call. I lean to the idea that return statements in the middle of the function are bad. You can use returns to build a few guard clauses at the top of the function, and of course tell the compiler what to return at the end of the function without issue, but returns in the middle of the function can be easy to miss and can make the function harder to interpret.Are there good reasons why it\'s a better practice to have only one return statement in a function?Yes, there are:The question is often posed as a false dichotomy between multiple returns or deeply nested if statements.  There\'s almost always a third solution which is very linear (no deep nesting) with only a single exit point.Update: Apparently MISRA guidelines promote single exit, too.To be clear, I\'m not saying it\'s always wrong to have multiple returns.  But given otherwise equivalent solutions, there are lots of good reasons to prefer the one with a single return.Having a single exit point does provide an advantage in debugging, because it allows you to set a single breakpoint at the end of a function to see what value is actually going to be returned.In general I try to have only a single exit point from a function. There are times, however, that doing so actually ends up creating a more complex function body than is necessary, in which case it\'s better to have multiple exit points. It really has to be a "judgement call" based on the resulting complexity, but the goal should be as few exit points as possible without sacrificing complexity and understandability.No, because we don\'t live in the 1970s any more.  If your function is long enough that multiple returns are a problem, it\'s too long.(Quite apart from the fact that any multi-line function in a language with exceptions will have multiple exit points anyway.)My preference would be for single exit unless it really complicates things.  I have found that in some cases, multiple exist points can mask other more significant design problems:On seeing this code, I would immediately ask: Depending on the answers to these questions it might be that In both of the above cases the code can probably be reworked with an assertion to ensure that \'foo\' is never null and the relevant callers changed.There are two other reasons (specific I think to C++ code) where multiple exists can actually have a negative affect.  They are code size, and compiler optimizations.A non-POD C++ object in scope at the exit of a function will have its destructor called.    Where there are several return statements, it may be the case that there are different objects in scope and so the list of destructors to call will be different.  The compiler therefore needs to generate code for each return statement:If code size is an issue - then this may be something worth avoiding.The other issue relates to "Named Return Value OptimiZation" (aka Copy Elision, ISO C++ \'03 12.8/15).  C++ allows an implementation to skip calling the copy constructor if it can:Just taking the code as is, the object \'a1\' is constructed in \'foo\' and then its copy construct will be called to construct \'a2\'.  However, copy elision allows the compiler to construct \'a1\' in the same place on the stack as \'a2\'.  There is therefore no need to "copy" the object when the function returns.Multiple exit points complicates the work of the compiler in trying to detect this, and at least for a relatively recent version of VC++ the optimization did not take place where the function body had multiple returns.  See Named Return Value Optimization in Visual C++ 2005 for more details.Having a single exit point reduces Cyclomatic Complexity and therefore, in theory, reduces the probability that you will introduce bugs into your code when you change it.  Practice however, tends to suggest that a more pragmatic approach is needed.  I therefore tend to aim to have a single exit point, but allow my code to have several if that is more readable.I force myself to use only one return statement, as it will in a sense generate code smell. Let me explain:(The conditions are arbritary...)The more conditions, the larger the function gets, the more difficult it is to read. So if you\'re attuned to the code smell, you\'ll realise it, and want to refactor the code. Two possible solutions are:Multiple ReturnsSeparate FunctionsGranted, it is longer and a bit messy, but in the process of refactoring the function this way, we\'veI would say you should have as many as required, or any that make the code cleaner (such as guard clauses).I have personally never heard/seen any "best practices" say that you should have only one return statement.For the most part, I tend to exit a function as soon as possible based on a logic path (guard clauses are an excellent example of this).I believe that multiple returns are usually good (in the code that I write in C#). The single-return style is a holdover from C. But you probably aren\'t coding in C.There is no law requiring only one exit point for a method in all programming languages. Some people insist on the superiority of this style, and sometimes they elevate it to a "rule" or "law" but this belief is not backed up by any evidence or research. More than one return style may be a bad habit in C code, where resources have to be explicitly de-allocated, but languages such as Java, C#, Python or JavaScript that have constructs such as automatic garbage collection and try..finally blocks (and using blocks in C#), and this argument does not apply - in these languages, it is very uncommon to need centralised manual resource deallocation. There are cases where a single return is more readable, and cases where it isn\'t. See if it reduces the number of lines of code, makes the logic clearer or reduces the number of braces and indents or temporary variables.Therefore, use as many returns as suits your artistic sensibilities, because it is a layout and readability issue, not a technical one.I have talked about this at greater length on my blog.There are good things to say about having a single exit-point, just as there are bad things to say about the inevitable "arrow" programming that results.If using multiple exit points during input validation or resource allocation, I try to put all the \'error-exits\' very visibly at the top of the function.Both the Spartan Programming article of the "SSDSLPedia" and the single function exit point article of the "Portland Pattern Repository\'s Wiki" have some insightful arguments around this. Also, of course, there is this post to consider.If you really want a single exit-point (in any non-exception-enabled language) for example in order to release resources in one single place, I find the careful application of goto to be good; see for example this rather contrived example (compressed to save screen real-estate):Personally I, in general, dislike arrow programming more than I dislike multiple exit-points, although both are useful when applied correctly. The best, of course, is to structure your program to require neither. Breaking down your function into multiple chunks usually help :)Although when doing so, I find I end up with multiple exit points anyway as in this example, where some larger function has been broken down into several smaller functions:Depending on the project or coding guidelines, most of the boiler-plate code could be replaced by macros. As a side note, breaking it down this way makes the functions g0, g1 ,g2 very easy to test individually.Obviously, in an OO and exception-enabled language, I wouldn\'t use if-statements like that (or at all, if I could get away with it with little enough effort), and the code would be much more plain. And non-arrowy. And most of the non-final returns would probably be exceptions.In short;You know the adage - beauty is in the eyes of the beholder.Some people swear by NetBeans and some by IntelliJ IDEA, some by Python and some by PHP.In some shops you could lose your job if you insist on doing this:The question is all about visibility and maintainability.I am addicted to using boolean algebra to reduce and simplify logic and use of state machines. However, there were past colleagues who believed my employ of "mathematical techniques" in coding is unsuitable, because it would not be visible and maintainable. And that would be a bad practice. Sorry people, the techniques I employ is very visible and maintainable to me - because when I return to the code six months later, I would understand the code clearly rather seeing a mess of proverbial spaghetti.Hey buddy (like a former client used to say) do what you want as long as you know how to fix it when I need you to fix it.I remember 20 years ago, a colleague of mine was fired for employing what today would be called agile development strategy. He had a meticulous incremental plan. But his manager was yelling at him "You can\'t incrementally release features to users! You must stick with the waterfall." His response to the manager was that incremental development would be more precise to customer\'s needs. He believed in developing for the customers needs, but the manager believed in coding to "customer\'s requirement".We are frequently guilty for breaking data normalization, MVP and MVC boundaries. We inline instead of constructing a function. We take shortcuts.Personally, I believe that PHP is bad practice, but what do I know. All the theoretical arguments boils down to trying fulfill one set of rulesquality = precision, maintainability\n  and profitability.All other rules fade into the background. And of course this rule never fades:Laziness is the virtue of a good\n  programmer.I lean towards using guard clauses to return early and otherwise exit at the end of a method. The single entry and exit rule has historical significance and was particularly helpful when dealing with legacy code that ran to 10 A4 pages for a single C++ method with multiple returns (and many defects). More recently, accepted good practice is to keep methods small which makes multiple exits less of an impedance to understanding. In the following Kronoz example copied from above, the question is what occurs in //Rest of code...?:I realise the example is somewhat contrived but I would be tempted to refactor the foreach loop into a LINQ statement that could then be considered a guard clause. Again, in a contrived example the intent of the code isn\'t apparent and someFunction() may have some other side effect or the result may be used in the // Rest of code....Giving the following refactored function:One good reason I can think of is for code maintenance: you have a single point of exit. If you want to change the format of the result,..., it\'s just much simpler to implement. Also, for debugging, you can just stick a breakpoint there :)Having said that, I once had to work in a library where the coding standards imposed \'one return statement per function\', and I found it pretty tough. I write lots of numerical computations code, and there often are \'special cases\', so the code ended up being quite hard to follow...Multiple exit points are fine for small enough functions -- that is, a function that can be viewed on one screen length on its entirety. If a lengthy function likewise includes multiple exit points, it\'s a sign that the function can be chopped up further.That said I avoid multiple-exit functions unless absolutely necessary. I have felt pain of bugs that are due to some stray return in some obscure line in more complex functions.I\'ve worked with terrible coding standards that forced a single exit path on you and the result is nearly always unstructured spaghetti if the function is anything but trivial -- you end up with lots of breaks and continues that just get in the way.Single exit point - all other things equal - makes code significantly more readable.\nBut there\'s a catch: popular construction is a fake, "res=" is not much better than "return". It has single return statement, but multiple points where function actually ends.If you have function with multiple returns (or "res="s), it\'s often a good idea to break it into several smaller functions with single exit point.My usual policy is to have only one return statement at the end of a function unless the complexity of the code is greatly reduced by adding more. In fact, I\'m rather a fan of Eiffel, which enforces the only one return rule by having no return statement (there\'s just a auto-created \'result\' variable to put your result in).There certainly are cases where code can be made clearer with multiple returns than the obvious version without them would be. One could argue that more rework is needed if you have a function that is too complex to be understandable without multiple return statements, but sometimes it\'s good to be pragmatic about such things.If you end up with more than a few returns there may be something wrong with your code. Otherwise I would agree that sometimes it is nice to be able to return from multiple places in a subroutine, especially when it make the code cleaner.would be better written like thisNote this is was just a quick exampleI vote for Single return at the end as a guideline. This helps a common code clean-up handling ... For example, take a look at the following code ...This is probably an unusual perspective, but I think that anyone who believes that multiple return statements are to be favoured has never had to use a debugger on a microprocessor that supports only 4 hardware breakpoints. ;-)While the issues of "arrow code" are completely correct, one issue that seems to go away when using multiple return statements is in the situation where you are using a debugger. You have no convenient catch-all position to put a breakpoint to guarantee that you\'re going to see the exit and hence the return condition.The more return statements you have in a function, the higher complexity in that one method. If you find yourself wondering if you have too many return statements, you might want to ask yourself if you have too many lines of code in that function.But, not, there is nothing wrong with one/many return statements. In some languages, it is a better practice (C++) than in others (C).