I am trying to do authorization using JavaScript by connecting to the RESTful API built in Flask. However, when I make the request, I get the following error:XMLHttpRequest cannot load http://myApiUrl/login. No \'Access-Control-Allow-Origin\' header is present on the requested resource. Origin \'null\' is therefore not allowed access.I know that the API or remote resource must set the header, but why did it work when I made the request via the Chrome extension Postman?This is the request code:If I understood it right you are doing an XMLHttpRequest to a different domain than your page is on. So the browser is blocking it as it usually allows a request in the same origin for security reasons. You need to do something different when you want to do a cross-domain request. A tutorial about how to achieve that is Using CORS.When you are using postman they are not restricted by this policy. Quoted from Cross-Origin XMLHttpRequest:Regular web pages can use the XMLHttpRequest object to send and receive data from remote servers, but they\'re limited by the same origin policy. Extensions aren\'t so limited. An extension can talk to remote servers outside of its origin, as long as it first requests cross-origin permissions.This is not a fix for production or when application has to be shown to the client, this is only helpful when UI and Backend development  are on different servers and in production they are actually on same server. For example: While developing UI for any application if there is a need to test it locally pointing it to backend server, in that scenario this is the perfect fix. For production fix, CORS headers has to be added to the backend server to allow cross origin access.The easy way is to just add the extension in google chrome to allow access using CORS.(https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en-US)Just enable this extension whenever you want allow access to no \'access-control-allow-origin\' header request.Or In Windows, paste this command in run window this will open a new chrome browser which allow access to no \'access-control-allow-origin\' header request.If you can deal with JSON in return, then try using JSONP (note the P at the end) for speaking between domains:Learn more about working with JSONP here:The advent of JSONP \xe2\x80\x94 essentially a consensual cross-site scripting hack \xe2\x80\x94 has opened the door to powerful mashups of content. Many prominent sites provide JSONP services, allowing you access to their content via a predefined API.It\'s very simple to solve if you are using PHP. Just add the following script in the beginning of your PHP page which handles the request:Warning : This contains a security issue for your PHP file that it could be called by attackers. you have to use sessions and cookies for authentication to prevent your file/service against this attack. Your service is vulnerable to cross-site request forgery (CSRF).If you are using Node-red you have to allow CROS in the node-red/settings.js file by un-commenting the following lines:I wish someone shared this site with me long ago http://cors.io/ it would have saved a ton of time compared to building and relying on my own proxy. However, as you move to production, having your own proxy is the best bet since you still control all aspects of your data.All you need:http://cors.io/?http://HTTP_YOUR_LINK_HEREThere\'s a cross-domain issue using Ajax. You must be sure you are accessing your files on the same http:// path without www. (or access from http://www. and post to the same path including www.) which the browser considers as another domain when accessing via a www. path, so you see where the problem is. You are posting to a different domain and the browser blocks the flow because of the origin issue.If the API is not placed on the same host that you are requesting from, the flow is blocked, and you will need to find another way to communicate with the API.If you are using Node.js, try it:More information: CORS on ExpressJSFor c# web services - webapi Please add the following code in your web.config file under <system.webServer> tag. This will workPlease make sure you are not doing any mistake in the ajax calljQueryAngular 4 issue please refer : http://www.hubfly.com/blog/solutions/how-to-fix-angular-4-api-call-issues/Try XDomain,Summary: A pure JavaScript CORS alternative/polyfill. No server configuration required - just add a proxy.html on the domain you wish to communicate with. This library uses XHook to hook all XHR, so XDomain should work in conjunction with any library.If you do NOTand you are sure that your server has CORS enabled then (test CORS here: http://test-cors.org/)Then you need to pass in origin parameter with your request.\nThis origin MUST match the origin that your browser sends with your request.You can see it in action here:\nhttp://www.wikibackpacker.com/app/detail/Campgrounds/3591The edit functionality sends a GET & POST request to a different domain for fetching data. I set the origin parameter which resolves the issue.\nThe backend is a mediaWiki engine.tldr: Add "origin" parameter to your calls which must be the Origin parameter that your browser sends (you cannot spoof the origin parameter)I had a problem with this when I used AngularJS to access my API. The same request worked in SoapUI 5.0 and ColdFusion. My GET method already had Access-Control-Allow-Origin header.I found out that AngularJS makes a "trial" OPTIONS request. ColdFusion, by default, generates OPTIONS method, but it doesn\xe2\x80\x99t have much, these headers specifically. The error was generated in response to that OPTIONS call, and not to my intentional call to GET. After I added OPTIONS method below to my API, the problem has been resolved.I had the following configuration, resulting in the same error, when requesting responses from the server.Server-side: SparkJava --> provides the REST-API\nClient-side: ExtJs6 --> provides Browser rendering  On the server-side I had to add this to the response:  On the client-side I had to add this to the request:  Based on shruti\'s answer, I\'ve created a shortcut of Chrome browser with needed arguments:\n\nIf you are using Entity Framework, it seems that this error will sometimes be thrown even if you have CORS enabled. I figured out that the error occurred because of a missing finalization of the query. I\'m hoping this will help others in the same situation.The following code can throw the XMLHttpRequest cannot load http://myApiUrl/login. No \'Access-Control-Allow-Origin\' header is present on the requested resource. error:To fix it, a finalization call like .ToList() or .FirstOrDefault() at the end of the query is required, like so:In my case I was using JEE7 JAX-RS application and following tricks worked perfectly for me:You can bypass the problem by using YQL to proxy the request through Yahoo\'s servers. It is just a few lines of code:Here\'s the link with an explanation: https://vverma.net/fetch-any-json-using-jsonp-and-yql.htmlA lot of times this happens to me from javascript to my php api, because one of a few reasons. \nI forget to put the <?php header(\'Access-Control-Allow-Origin: *\'); ? is one. This is helpful for cross sub domain access. Another reason, is because in jQuery ajax request I am specifying a specific dataType and returning a different dataType, so it throws an error. The Last and most prominent reasoning for this error is there is a parse error on the page you are requesting. If you hit that page url in your browser than more than likely you will see a parse error and you will have a line number to address the issue. I hope this helps someone. It took me a while each time to debug this and I wish I had a checklist of things to verify.https://github.com/Rob--W/cors-anywhere/ provides (Node.js) code you can use to set up and run your own CORS proxy. It\xe2\x80\x99s actively maintained and provides a number of features for controlling the proxy behavior beyond just the basic sending of the correct Access-Control-* response headers.https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS has details to explain how browsers handle cross-origin requests that client-side web applications make from JavaScript and what headers you must configure sending of by the server the request is made to, if you can.In the case where a site you need to make a request to and get a response from doesn\xe2\x80\x99t return the Access-Control-Allow-Origin response header, browsers are always going to block cross-origin requests made to it directly by your client-side JavaScript code from working. And so if the site is not one you control and can configure behavior for, the only thing that will work in that case is proxying the requests\xe2\x80\x94either through your own proxy you run yourself or through an open proxy.As mentioned in other comments here, there are good reasons for not trusting an open proxy with your requests. That said, if you know what you\xe2\x80\x99re doing and you decide an open proxy works for your needs, https://cors-anywhere.herokuapp.com/ is one that\xe2\x80\x99s reliably available, actively maintained, and that runs an instance of the https://github.com/Rob--W/cors-anywhere/ code.As with other open proxies mentioned here (a couple of which at least don\xe2\x80\x99t seem to be available any longer), the way it works is that instead of having your client code send a request directly to, e.g., http://foo.com you send it to https://cors-anywhere.herokuapp.com/http://foo.com and the proxy adds the necessary Access-Control-* headers to the response the browser sees.I was successfully able to solve (in my case for fonts) using htaccess but obviously, OP is asking little different. But you can use FileMatch pattern and add any sort of extension so that it won\'t give cros error.https://httpd.apache.org/docs/2.4/mod/core.html#filesmatchI got this error with $http.get in Angular. I needed to use $http.jsonp instead.Popular question -- Another thing to look at if you\'ve read this far and nothing else has helped.  If you have a CDN such as Akamai, Limelight or similar, you might want to check the cache key you have for the URI of the resource.  If it does not include the Origin header value you may be returning a response cached when requested from another Origin.  We just spent half a day debugging this.  The CDN configuration was updated to only include the Origin value for a few select domains that are ours and set it to null for all others.  This seems to work and allows browsers from our known domains to view our resources.  Certainly all the other answers are prerequisites to getting here but the if the CDN is the first hop from your browser this is something to review.  In our case we could see some requests making it to our service but not nearly the volume the site was sending.  That pointed us to the CDN.  We were able to go back and see the original request was served from a direct request, not part of a browser AJAX call and the response header Access-Control-Allow-Origin was not included.  Apparently the CDN cached this value.  The CDN configuration tweak to consider the Origin request header value seems to have made it work.CORS is for you.\nCORS is "Cross Origin Resource Sharing", is a way to send cross domain request. Now the XMLHttpRequest2 and Fetch API both support CORS.But it has its limits. Server need to specific claim the Access-Control-Allow-Origin, and it can not be set to \'*\'.And if you want any origin can send request to you, you need JSONP (also need to set Access-Control-Allow-Origin, but can be \'*\')For lots of request way if you don\'t know what to choose, I think you need a fully functional component to do that. Let me introduce a simple component cattaIf you are using a modern browser (> IE9, Chrome, FF, Edge, etc.), Very Recommend you to use a simple but beauty component https://github.com/Joker-Jelly/catta. It has no dependence, less than 3KB, and it supports Fetch, AJAX and JSONP with same dead simple syntax and options.It also supports all the way to import to your project, like ES6 module, CommonJS and even <script> in HTML.For rails server in application_controller.rb,\nadd this:On my website (based on .NET) I\'ve just added this:Big thanks to this video.Please add dataType: \'jsonp\' in the Ajax function and it works. (:For Opera (it works the same as Chrome), I started the browser with this command:The problem is solved! Now I can work on a local HTML file (on my hard disk drive) and call Ajax requests to remote origins in the same file.Note 1: You can give any folder in your home directory as --user-data-dir.Note 2: Tested on Debian 8 (Jessie)/Opera 39When you start normally (without the parameters above), the same request falls into the error code block.Just to mention another way of "bypassing" it - AJAX proxy. Send request to your server to fetch the data from another origin and send the request back to you.I prefer this approach over JSONP because it has some potential security issues.I have resolved this by enabling CORS for the client URL accessing the web API, and it worked successfully.For example:I tried the following solution. This method work only when your server is running locally.Put following line in file web.xml.Open a browser to allow access control with following code in terminal (Mac)