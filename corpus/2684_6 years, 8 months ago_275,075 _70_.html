This question already has an answer here:I have a bash script that needs to know its full path. I\'m trying to find a broadly-compatible way of doing that without ending up with relative or funky-looking paths. I only need to support bash, not sh, csh, etc.What I\'ve found so far:The accepted answer to "Getting the source directory of a Bash script from within" addresses getting the path of the script via dirname $0, which is fine, but that may return a relative path (like .), which is a problem if you want to change directories in the script and have the path still point to the script\'s directory. Still, dirname will be part of the puzzle.The accepted answer to "Bash script absolute path with OSX" (OS X specific, but the answer works regardless) gives a function that will test to see if $0 looks relative and if so will pre-pend $PWD to it. But the result can still have relative bits in it (although overall it\'s absolute) — for instance, if the script is t in the directory /usr/bin and you\'re in /usr and you type bin/../bin/t to run it (yes, that\'s convoluted), you end up with /usr/bin/../bin as the script\'s directory path. Which works, but...The readlink solution on this page, which looks like this:But readlink isn\'t POSIX and apparently the solution relies on GNU\'s readlink where BSD\'s won\'t work for some reason (I don\'t have access to a BSD-like system to check).So, various ways of doing it, but they all have their caveats.What would be a better way? Where "better" means:Answering my own question (per the FAQ)...Here\'s what I\'ve come up with that seems to mostly fit my "better" criteria:...but it seems roundabout and clunky. I\'m hoping someone else will have a better answer.Note also that esoteric situations, such as executing a script that isn\'t coming from a file in an accessible file system at all (which is perfectly possible), is not catered to there (or in any of the other answers I\'ve seen).Edit: Change the second line to:...if you want to resolve symlinks. (I don\'t, but others may.) I don\'t know how widely-supported the -P flag is, though.Dennis Williamson tells us below that -P is reliable as of, well, a long time ago. :-)I\'m surprised that the realpath command hasn\'t been mentioned here. My understanding is that it is widely portable / ported.Your initial solution becomes:And to leave symbolic links unresolved per your preference:The simplest way that I have found to get a full canonical path in bash is to use cd and pwd: Using ${BASH_SOURCE[0]} instead of $0 produces the same behavior regardless of whether the script is invoked as <name> or source <name>I just had to revisit this issue today and found https://stackoverflow.com/a/246128/1034080. It elaborates on a solution that I\'ve used in the past as well.There\'s more variants at the linked answer, e.g. for the case where the script itself is a symlink.Does not use -f option in readlink, therefore should work in bsd/mac-osxI am looking for corner cases where this code does not work. Please let me know.Script must be on disk somewhere, let it be over a network.\nIf you try to run this script from a PIPE it will not workTechnically speaking, it is undefined.\nPractically speaking, there is no sane way to detect this. (co-process can not access env of parent)What about using:which prints to stdout the full path of the executable that would have been executed when the passed argument had been entered at the shell prompt (which is what $0 contains)dirname strips the non-directory suffix from file nameHence what you end up with is the full path to the script, no matter if the path was specified or not.As realpath is not installed per default on my Linux System the following works for me:$SCRIPT will contain the real file path to the script and $SCRIPTPATH the real path of the directory containing the script.Before using this read the comments of this answer.Answering this question very late, but I use:We have placed our own product realpath-lib on GitHub for free and unencumbered community use.Shameless plug but with this Bash library you can:  This function is the core of the library:It doesn\'t require any external dependencies, just Bash 4+.  Also contains functions to get_dirname, get_filename, get_stemname and validate_path validate_realpath.  It\'s free, clean, simple and well documented, so it can be used for learning purposes too, and no doubt can be improved.  Try it across platforms.Update:  After some review and testing we have replaced the above function with something that achieves the same result (without using dirname, only pure Bash) but with better efficiency:This also includes an environment setting no_symlinks that provides the ability to resolve symlinks to the physical system.  By default it keeps symlinks intact.sh compliant way:You may try to define the following variable:or you can try the following function in bash:This function takes 1 argument. If argument has already absolute path, print it as it is, otherwise print $PWD variable + filename argument (without ./ prefix).Related:Bash script absolute path with OSXGetting the source directory of a Bash script from withinConsidering this issue again:  there is a very popular solution that is referenced within this thread that has its origin here:I have stayed away from this solution because of the use of dirname - it can present cross-platform difficulties, particularly if a script needs to be locked down for security reasons.  But as a pure Bash alternative, how about using:Would this be an option?Perhaps the accepted answer to the following question may be of help.How can I get the behavior of GNU's readlink -f on a Mac?Given that you just want to canonicalize the name you get from concatenating $PWD and $0 (assuming that $0 is not absolute to begin with) Just use a series of regex replacements along the line of abs_dir=${abs_dir//\\/.\\//\\/} and such.Yes, I know it looks horrible but it\'ll work and is pure bash.The accepted solution has the inconvenient (for me) to not be "source-able":\nif you call it from a "source ../../yourScript", $0 would be "bash"!The following function (for bash >= 3.0) gives me the right path, however the script might be called (directly or through source, with an absolute or a relative path):\n(by "right path", I mean the full absolute path of the script being called, even when called from another path, directly or with "source")The key is to detect the "source" case and to use ${BASH_SOURCE[0]} to get back the actual script.simply: BASEDIR=$(readlink -f $0 | xargs dirname)no fancy operatorsHIH.If we use Bash I believe this is the most convenient way as it doesn\'t require calls to any external commands:Try this:Easy to read? alternative. Ignores symlinksJust for the hell of it I\'ve done a bit of hacking on a script that does things purely textually, purely in bash. I hope I caught all the edge cases. Note that the ${var//pat/repl} that I mentioned in the other answer doesn\'t work since you can\'t make it replace only the shortest possible match, which is a problem for replacing /foo/../ as e.g. /*/../ will take everything before it, not just a single entry. And since these patterns aren\'t really regexes I don\'t see how that can be made to work. So here\'s the nicely convoluted solution I came up with, enjoy. ;)By the way, let me know if you find any unhandled edge cases.I have used the following approach successfully for a while (not on OSX though) and it only uses shell built-in and handles the \'source foobar.sh\' case as far as I have seen.One issue with the (hastly put together) example code below is that the function uses $PWD which may or may not be correct at the time of the function call. So that needs to be handled.Yet another way to do this:   One linerMore simply, this is what works for me: