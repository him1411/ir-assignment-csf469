What is an efficient way to implement a singleton pattern in Java?Use an enum:Joshua Bloch explained this approach in his Effective Java Reloaded talk at Google I/O 2008: link to video. Also see slides 30-32 of his presentation (effective_java_reloaded.pdf):Edit: An online portion of "Effective Java" says: "This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, a single-element enum type is the best way to implement a singleton."Depending on the usage, there are several "correct" answers.Since java5 the best way to do it is to use an enum:Pre java5, the most simple case is:Let\'s go over the code. First, you want the class to be final. In this case, I\'ve used the final keyword to let the users know it is final. Then you need to make the constructor private to prevent users to create their own Foo. Throwing an exception from the constructor prevents users to use reflection to create a second Foo. Then you create a private static final Foo field to hold the only instance, and a public static Foo getInstance() method to return it. The Java specification makes sure that the constructor is only called when the class is first used.When you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.You can use a private static class to load the instance. The code would then look like:Since the line private static final Foo INSTANCE = new Foo(); is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread safe.When you also want to be able to serialize your object you need to make sure that deserialization won\'t create a copy.The method readResolve() will make sure the only instance will be returned, even when the object was serialized in a previous run of your program.The solution posted by Stu Thompson is valid in Java5.0 and later. But I would prefer not to use it because I think it is error prone.It\'s easy to forget the volatile statement and difficult to understand why it is necessary. Without the volatile this code would not be thread safe anymore due to the double-checked locking antipattern. See more about this in paragraph 16.2.4 of Java Concurrency in Practice. In short: This pattern (prior to Java5.0 or without the volatile statement) could return a reference to the Bar object that is (still) in an incorrect state.This pattern was invented for performance optimization. But this is really not a real concern anymore. The following lazy initialization code is fast and -more importantly- easier to read.Disclaimer: I have just summarized all of the awesome answers and wrote it in my words.While implementing Singleton we have 2 options\n1. Lazy loading\n2. Early loadingLazy loading adds bit overhead(lots of to be honest) so use it only when you have a very large object or heavy construction code AND also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization.Otherwise choosing early loading is a good choice.Most simple way of implementing Singleton is Everything is good except its early loaded singleton. Lets try lazy loaded singletonSo far so good but our hero will not survive while fighting alone with multiple evil threads who want many many instance of our hero.\nSo lets protect it from evil multi threadingbut it is not enough to protect out hero, Really!!! This is the best we can/should do to help our hero  This is called "Double-Checked Locking idiom". It\'s easy to forget the volatile statement and difficult to understand why it is necessary.\nFor details :  http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.htmlNow we are sure about evil thread but what about the cruel serialization? We have to make sure even while de-serialiaztion no new object is createdThe method readResolve() will make sure the only instance will be returned, even when the object was serialized in a previous run of our program.Finally we have added enough protection  against threads and serialization but our code is looking bulky and ugly. Lets give our hero a make overYes this is our very same hero :)\nSince the line private static final Foo INSTANCE = new Foo(); is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread safe.And we have came so far, here is the best way to achieve everything we did is best possible way Which internally will be treated like  That\'s it no more fear of serialization, threads and ugly code. Also ENUMS singleton are lazily initialized. This approach is functionally equivalent to the public field approach,\n  except that it is more concise, provides the serialization machinery\n  for free, and provides an  ironclad guarantee against multiple\n  instantiation, even in the face of sophisticated serialization or\n  reflection attacks. While this approach has yet to be widely  adopted,\n  a single-element enum type is the best way to implement a singleton.-Joshua Bloch in "Effective Java"      Now you might have realized why ENUMS are considered as best way to implement Singleton and thanks for your patience :)\nUpdated it on my blog. Thread safe in Java 5+:EDIT: Pay attention to the volatile modifier here.  :)  It is important because without it, other threads are not guaranteed by the JMM (Java Memory Model) to see changes to its value.  The synchronization does not take care of that--it only serializes access to that block of code.EDIT 2: \n@Bno \'s answer details the approach recommended by Bill Pugh (FindBugs) and is arguable better.  Go read and vote up his answer too.Forget lazy initialization, it\'s too problematic. This is the simplest solution:Make sure that you really need it. Do a google for "singleton anti-pattern" to see some arguments against it. There\'s nothing inherently wrong with it I suppose but it\'s just a mechanism for exposing some global resource/data so make sure that this is the best way. In particular I\'ve found dependency injection more useful particularly if you are also using unit tests because DI allows you to use mocked resources for testing purposes.Don\'t forget the Singleton is only a Singleton for the Classloader that loaded it. If you are using multiple loaders (Containers) each COULD have its own version of the Singleton.I\'m mystified by some of the answers that suggest DI as an alternative to using singletons; these are unrelated concepts. You can use DI to inject either singleton or non-singleton (e.g. per-thread) instances. At least this is true if you use Spring 2.x, I can\'t speak for other DI frameworks.So my answer to the OP would be (in all but the most trivial sample code) to:This approach gives you a nice decoupled (and therefore flexible and testable) architecture where whether to use a singleton is an easily reversible implementation detail (provided any singletons you use are threadsafe, of course).Really consider why you need a singleton before writing it. There is a quasi-religious debate about using them which you can quite easily stumble over if you google singletons in Java.Personally I try to avoid singletons as often as possible for many reasons, again most of which can be found by googling singletons. I feel that quite often singletons are abused because they\'re easy to understand by everybody, they\'re used as a mechanism for getting "global" data into an OO design and they are used because it is easy to circumvent object lifecycle management (or really thinking about how you can do A from inside B). Look at things like Inversion of Control (IoC) or Dependency Injection (DI) for a nice middleground.If you really need one then wikipedia has a good example of a proper implementation of a singleton.Following are 3 different approaches1) Enum2) Double checked Locking /Lazy loading3) Static factory methodI use the Spring Framework to manage my singletons.  It doesn\'t enforce the "singleton-ness" of the class (which you can\'t really do anyway if there are multiple class loaders involved) but provides a really easy way to build and configure different factories for creating different types of objects.Version 1:Lazy loading, thread safe with blocking, low performance because of synchronized.Version 2:Lazy loading, thread safe with non-blocking, high performance.Wikipedia has some examples of singletons, also in Java. The Java 5 implementation looks pretty complete, and is thread-safe (double-checked locking applied).If you do not need lazy loading then simply tryIf you want lazy loading and you want your Singleton to be thread-safe, try the double-checking pattern As the double checking pattern is not guaranteed to work (due to some issue with compilers, I don\'t know anything more about that.), you could also try to synchronize the whole getInstance-method or create a registry for all your Singletons. I would say Enum singleton Singleton using enum in Java is generally way to declare enum singleton. Enum singleton may contain instance variable and instance method. For simplicity\'s sake, also note that if you are using any instance method than you need to ensure thread safety of that method if at all it affect the state of object.The use of an enum is very easy to implement and has no drawbacks regarding serializable objects, which have to be circumvented in the other ways.You can access it by Singleton.INSTANCE, much easier than calling getInstance() method on Singleton.1.12    Serialization of Enum ConstantsEnum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant\'s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant\'s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixed serialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.Quoted from Oracle docsAnother problem with conventional Singletons are that once you implement Serializable interface, they no longer remain Singleton because readObject() method always return a new instance  like constructor in Java. This can be avoided by using readResolve() and discarding newly created instance by replacing with singleton like below This can become even more complex if your Singleton Class maintain state, as you need to make them transient, but with in Enum Singleton, Serialization is guaranteed by JVM.Good ReadYou need double-checking idiom if you need to load the instance variable of a class lazily. \nIf you need to load a static variable or a singleton lazily, you need initilization on demand holder idiom. In addition, if the singleton needs to be seriliazble, all other fields needs to be transient and readResolve() method needs to be implemented in order to maintain the singleton object invariant. Otherwise, each time the object is deserialized, a new instance of the object will be created. What readResolve() does is replace the new object read by readObject(), which forced that new object to be garbage collected as there is no variable referring to it.Various ways to make singleton object:As per Joshua Bloch - Enum would be the best.you can use double check locking also.Even inner static class can be used.Enum singletonThe simplest way to implement a Singleton that is thread-safe is using an EnumThis code works since the introduction of Enum in Java 1.5Double checked lockingIf you want to code a \xe2\x80\x9cclassic\xe2\x80\x9d singleton that works in a multithreaded environment (starting from Java 1.5) you should use this one.This is not thread-safe before 1.5 because the implementation of the volatile keyword was different.Early loading Singleton (works even before Java 1.5)This implementation instantiates the singleton when the class is loaded and provides thread safety.This is how to implement a simple singleton:This is how to properly lazy create your singleton:For JSE 5.0 and above take the Enum approach, otherwise use static singleton holder approach ( (a lazy loading approach described by Bill Pugh). Latter solution is also thread-safe without requiring special language constructs (i.e. volatile or synchronized).Another argument often used against Singletons are their testability problems. Singletons are not easily mockable for testing purposes. If this turns out to be a problem, I like to make the following slight modification:The added setInstance method allows setting a mockup implementation of the singleton class during testing:This also works with early initialization approaches:This has the drawback of exposing this functionality to the normal application too. Other developers working on that code could be tempted to use the \xc2\xb4setInstance\xc2\xb4 method to alter alter a specific function and thus changing the whole application behaviour, therefore this method should contain at least a good warning in it\'s javadoc.Still, for the possibility of mockup-testing (when needed), this code exposure may be an acceptable price to pay.simplest singleton classI still think after java 1.5, enum is the best available singleton implementation available as it also ensures that even in the multi threaded environments - only one instance is created.public enum Singleton{\n  INSTANCE;\n}and you are done !!!Have a look at this post.Examples of GoF Design Patterns in Java's core librariesFrom the best answer\'s "Singleton" section,You can also learn the example of Singleton from Java native classes themselves.To achieve this ( TRUE Singleton) ,Useful links: All answers in this post +Singleton_pattern : Initialization-on-demand holder idiom from wikipediajournaldev articleDemonstration of various methods of achieving Singletonoutput:Might be a little late to the game on this, but there is a lot of nuance around implementing a singleton. The holder pattern can not be used in many situations. And IMO when using a volatile - you should also use a local variable. Let\'s start at the beginning and iterate on the problem. You\'ll see what I mean.The first attempt might look something like this:Here we have the MySingleton class which has a private static member called INSTANCE, and a public static method called getInstance(). The first time getInstance() is called, the INSTANCE member is null. The flow will then fall into the creation condition and create a new instance of the MySingleton class. Subsequent calls to getInstance() will find that the INSTANCE variable is already set, and therefore not create another MySingleton instance. This ensures there is only one instance of MySingleton which is shared among all callers of getInstance().But this implementation has a problem. Multi-threaded applications will have a race condition on the creation of the single instance. If multiple threads of execution hit the getInstance() method at (or around) the same time, they will each see the INSTANCE member as null. This will result in each thread creating a new MySingleton instance and subsequently setting the INSTANCE member.Here we\xe2\x80\x99ve used the synchronized keyword in the method signature to synchronize the getInstance() method. This will certainly fix our race condition. Threads will now block and enter the method one at a time. But it also creates a performance problem. Not only does this implementation synchronize the creation of the single instance, it synchronizes all calls to getInstance(), including reads. Reads do not need to be synchronized as they simply return the value of INSTANCE. Since reads will make up the bulk of our calls (remember, instantiation only happens on the first call), we will incur an unnecessary performance hit by synchronizing the entire method.Here we\xe2\x80\x99ve moved synchronization from the method signature, to a synchronized block that wraps the creation of the MySingleton instance. But does this solve our problem? Well, we are no longer blocking on reads, but we\xe2\x80\x99ve also taken a step backward. Multiple threads will hit the getInstance() method at or around the same time and they will all see the INSTANCE member as null. They will then hit the synchronized block where one will obtain the lock and create the instance. When that thread exits the block, the other threads will contend for the lock, and one by one each thread will fall through the block and create a new instance of our class. So we are right back where we started.Here we issue another check from INSIDE the block. If the INSTANCE member has already been set, we\xe2\x80\x99ll skip initialization. This is called double-checked locking.This solves our problem of multiple instantiation. But once again, our solution has presented another challenge. Other threads might not \xe2\x80\x9csee\xe2\x80\x9d that the INSTANCE member has been updated. This is because of how Java optimizes memory operations. Threads copy the original values of variables from main memory into the CPU\xe2\x80\x99s cache. Changes to values are then written to, and read from, that cache. This is a feature of Java designed to optimize performance. But this creates a problem for our singleton implementation. A second thread\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8abeing processed by a different CPU or core, using a different cache\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8awill not see the changes made by the first. This will cause the second thread to see the INSTANCE member as null forcing a new instance of our singleton to be created.We solve this by using the volatile keyword on the declaration of the INSTANCE member. This will tell the compiler to always read from, and write to, main memory, and not the CPU cache.But this simple change comes at a cost. Because we are bypassing the CPU cache, we will take a performance hit each time we operate on the volatile INSTANCE member\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8awhich we do 4 times. We double-check existence (1 and 2), set the value (3), and then return the value (4). One could argue that this path is the fringe case as we only create the instance during the first call of the method. Perhaps a performance hit on creation is tolerable. But even our main use-case, reads, will operate on the volatile member twice. Once to check existence, and again to return its value.Since the performance hit is due to operating directly on the volatile member, let\xe2\x80\x99s set a local variable to the value of the volatile and operate on the local variable instead. This will decrease the number of times we operate on the volatile, thereby reclaiming some of our lost performance. Note that we have to set our local variable again when we enter the synchronized block. This ensures it is up to date with any changes that occured while we were waiting for the lock.I wrote an article about this recently. Deconstructing The Singleton. You can find more info on these examples and an example of the "holder" pattern there. There is also a real-world example showcasing the double-checked volatile approach. Hope this helps.Sometimes a simple "static Foo foo = new Foo();" is not enough. Just think of some basic data insertion you want to do.On the other hand you would have to synchronize any method that instantiates the singleton variable as such. Synchronisation is not bad as such, but it can lead to performance issues or locking (in very very rare situations using this example. The solution isNow what happens? The class is loaded via the class loader. Directly after the class was interpreted from a byte Array, the VM executes the static { } - block. that\'s the whole secret: The static-block is only called once, the time the given class (name) of the given package is loaded by this one class loader.As we have added the Synchronized keyword before getInstance, we have avoided the race condition in the case when two threads call the getInstance at the same time.