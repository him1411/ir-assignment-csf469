What is the most efficient way to write the old-school:...in LINQ?Use aggregate queries like this:This outputs:An aggregate is a function that takes a collection of values and returns a scalar value. Examples from T-SQL include min, max, and sum. Both VB and C# have support for aggregates. Both VB and C# support aggregates as extension methods. Using the dot-notation, one simply calls a method on an IEnumerable object.Remember that aggregate queries are executed immediately.http://msdn.microsoft.com/en-us/library/bb386914.aspxBecause this does not use a StringBuilder it will have horrible performance for very long sequences.In .Net 4, there\'s a new overload for string.Join that accepts IEnumerable<string>.  The code would then look like:Why use Linq?That works perfectly and accepts any IEnumerable<string> as far as I remember.  No need Aggregate anything here which is a lot slower.Have you looked at the Aggregate extension method?Real example from my code:A query is an object that has a Name property which is a string, and I want the names of all the queries on the selected list, separated by commas.You can use StringBuilder in Aggregate:(The Select is in there just to show you can do more LINQ stuff.)quick performance data for the stingbuilder vs Select case over 3000 elements:unit test                  Duration (seconds)\nLINQ_SELECT     00:00:01.8012535\nLINQ_StringBuilder      00:00:00.0036644    Since this question had some activity a couple weeks ago, I decided it was okay for me to throw out the combined Join/Linq approach I settled on after looking at the above answers and the issues addressed in the answer to a similar question (namely that Aggregate and Concatenate fail with 0 elements).string Result = String.Join(",", split.Select(s => s.Name));or (if s is not a string)string Result = String.Join(",", split.Select(s => s.ToString()));And of course Join takes care of the pesky final comma that sometimes sneaks into other approaches (for, foreach), which is why I was looking for a Linq-y solution in the first place.Of course, if anyone sees any problems with this approach, I\'d love to adopt any suggestions or improvements they may have.I always use the extension method:By \'super-cool LINQ way\' you might be talking about the way that LINQ makes functional programming a lot more palatable with the use of extension methods. I mean, the syntactic sugar that allows functions to be chained in a visually linear way (one after the other) instead of nesting (one inside the other). For example:can be written like this:You can see how the second example is easier to read. You can also see how more functions can be added with less of the indentation problems or the Lispy closing parens appearing at the end of the expression.A lot of the other answers state that the String.Join is the way to go because it is the fastest or simplest to read. But if you take my interpretation of \'super-cool LINQ way\' then the answer is to use String.Join but have it wrapped in a LINQ style extension method that will allow you to chain your functions in a visually pleasing way. So if you want to write sa.Concatenate(", ") you just need to create something like this:This will provide code that is as performant as the direct call (at least in terms of algorithm complexity) and in some cases may make the code more readable (depending on the context) especially if other code in the block is using the chained function style.There are various alternative answers at this previous question - which admittedly was targeting an integer array as the source, but received generalised answers.Here it is using pure LINQ as a single expression: And its pretty damn fast!I\'m going to cheat a little and throw out a new answer to this that seems to sum up the best of everything on here instead of sticking it inside of a comment. So you can one line this:Edit: You\'ll either want to check for an empty enumerable first or add an .Replace("\\a",string.Empty); to the end of the expression. Guess I might have been trying to get a little too smart.The answer from @a.friend might be slightly more performant, I\'m not sure what Replace does under the hood compared to Remove. The only other caveat if some reason you wanted to concat strings that ended in \\a\'s you would lose your separators... I find that unlikely. If that is the case you do have other fancy characters to choose from.You can combine LINQ and string.join() quite effectively. Here I am removing an item from a string. There are better ways of doing this too but here it is:Lots of choices here. You can use LINQ and a StringBuilder so you get the performance too like so:I did the following quick and dirty when parsing an IIS log file using linq, it worked @ 1 million lines pretty well (15 seconds), although got an out of memory error when trying 2 millions lines.  The real reason I used linq was for a Distinct() I neede previously:I blogged about this a while ago, what I did seams to be exactly what you\'re looking for:http://ondevelopment.blogspot.com/2009/02/string-concatenation-made-easy.htmlIn the blog post describe how to implement extension methods that works on IEnumerable and are named Concatenate, this will let you write things like:Or more elaborate things like: