I\'m using the ViewPager from the compatibility library. I have succussfully got it displaying several views which I can page through.However, I\'m having a hard time figuring out how to update the ViewPager with a new set of Views.I\'ve tried all sorts of things like calling mAdapter.notifyDataSetChanged(), mViewPager.invalidate() even creating a brand new adapter each time I want to use a new List of data.Nothing has helped, the textviews remain unchanged from the original data.Update: \nI made a little test project and I\'ve almost been able to update the views. I\'ll paste the class below.What doesn\'t appear to update however is the 2nd view, the \'B\' remains, it should display \'Y\' after pressing the update button.There are several ways to achieve this.The first option is easier, but bit more inefficient.Override getItemPosition in your PagerAdapter like this:This way, when you call notifyDataSetChanged(), the view pager will remove all views and reload them all. As so the reload effect is obtained.The second option, suggested by Alvaro Luis Bustamante (previously alvarolb), is to setTag() method in instantiateItem() when instantiating a new view. Then instead of using notifyDataSetChanged(), you can use findViewWithTag() to find the view you want to update. The second approach is very flexible and high performant. Kudos to alvarolb for the original research.I don\'t think there is any kind of bug in the PagerAdapter. The problem is that understanding how it works is a little complex. Looking at the solutions explained here, there is a misunderstanding and therefore a poor usage of instantiated views from my point of view.The last few days I have been working with PagerAdapter and ViewPager, and I found the following:The notifyDataSetChanged() method on the PagerAdapter will only notify the ViewPager that the underlying pages have changed. For example, if you have created/deleted pages dynamically (adding or removing items from your list) the ViewPager should take care of that. In this case I think that the ViewPager determines if a new view should be deleted or instantiated using the getItemPosition() and getCount() methods.I think that ViewPager, after a notifyDataSetChanged() call takes it\'s child views and checks their position with the getItemPosition(). If for a child view this method returns POSITION_NONE, the ViewPager understands that the view has been deleted, calling the destroyItem(), and removing this view.In this way, overriding getItemPosition() to always return POSITION_NONE is completely wrong if you only want to update the content of the pages, because the previously created views will be destroyed and new ones will be created every time you call notifyDatasetChanged(). It may seem to be not so wrong just for a few TextViews, but when you have complex views, like ListViews populated from a database, this can be a real problem and a waste of resources.So there are several approaches to efficiently change the content of a view without having to remove and instantiate the view again. It depends on the problem you want to solve. My approach is to use the setTag() method for any instantiated view in the instantiateItem() method. So when you want to change the data or invalidate the view that you need, you can call the findViewWithTag() method on the ViewPager to retrieve the previously instantiated view and  modify/use it as you want without having to delete/create a new view each time you want to update some value. Imagine for example that you have 100 pages with 100 TextViews and you only want to update one value periodically. With the approaches explained before, this means you are removing and instantiating 100 TextViews on each update. It does not make sense...Change the FragmentPagerAdapter to FragmentStatePagerAdapter.Override getItemPosition() method and return POSITION_NONE.Eventually, it will listen to the notifyDataSetChanged() on view pager.The answer given by alvarolb is definitely the best way to do it.  Building upon his answer, an easy way to implement this is to simply store out the active views by position:Then once by overriding the notifyDataSetChanged method you can refresh the views...You can actually use similar code in instantiateItem and notifyDataSetChanged to refresh your view.  In my code I use the exact same method.After hours of frustration while trying all the above solutions to overcome this problem and also trying many solutions on other similar questions like this, this and this which all FAILED with me to solve this problem and to make the ViewPager to destroy the old Fragment and fill the pager with the new Fragments. I have solved the problem as following:1) Make the ViewPager class to extends FragmentPagerAdapter as following:2) Create an Item for the ViewPager that store the title and the fragment as following:3) Make the constructor of the ViewPager take my FragmentManager instance to store it in my class as following:4) Create a method to re-set the adapter data with the new data by deleting all the previous fragment from the fragmentManager itself directly to make the adapter to set the new fragment from the new list again as following:5) From the container Activity or Fragment do not re-initialize the adapter with the new data. Set the new data through the method setPagerItems with the new data as following:I hope it helps.Had the same problem. For me it worked to override FragmentStatePagerAdapterThis work for me.Two and half years after the OP posed his question, this issue is still, well, still an issue. It\'s obvious Google\'s priority on this isn\'t particularly high, so rather than find a fix, I found a workaround. The big breakthrough for me was finding out what the real cause of the problem was (see the accepted answer in this post ). Once it was apparent that the issue was that any active pages are not properly refreshed, my workaround was obvious:In my Fragment (the pages):In my Activity, where I do the loading of the pages: After this, when you reload a second set of pages, the bug will still cause some to display the old data. However, they will now be refreshed and you will see the new data - your users won\'t know the page was ever incorrect because this refreshing will happen before they see the page.Hope this helps someone!A much easier way: use a FragmentPagerAdapter, and wrap your paged views onto fragments. They do get updatedAfter a lot of searching for this problem, I found a really good solution that I think is the right way to go about this.  Essentially, instantiateItem only gets called when the view is instantiated and never again unless the view is destroyed (this is what happens when you override the getItemPosition function to return POSITION_NONE).  Instead, what you want to do is save the created views and either update them in the adapter, generate a get function so someone else can update it, or a set function which updates the adapter (my favorite).So, in your MyViewPagerAdapter add a variable like:an in your instantiateItem:so, this way, you can create a function that will update your view:Hope this helps!I had a similar problem in which I had four pages and one of the pages updated views on the other three. I was able to updated the widgets(SeekBars, TextViews, etc.) on the page adjacent to the current page. The last two pages would have uninitialized widgets when calling mTabsAdapter.getItem(position). To solve my issue, I used setSelectedPage(index) before calling getItem(position). This would instantiate the page, allowing me to be able to alter values and widgets on each page. After all of the updating I would use setSelectedPage(position) followed by notifyDataSetChanged().You can see a slight flicker in the ListView on the main updating page, but nothing noticeable. I haven\'t tested it throughly, but it does solve my immediate problem. Just in case anyone are using FragmentStatePagerAdapter based adapter(which will let ViewPager create minimum pages needed for display purpose, at most 2 for my case), @rui.araujo\'s answer of overwriting getItemPosition in your adapter will not cause significant waste, but it still can be improved.In pseudo code:I am just posting this answer in case anyone else finds it useful. For doing the exact same thing, I simply took the source code of the ViewPager and PagerAdapter from the compatibility library and compiled it within my code (You need to sort out all the errors and imports yourself, but it definitely can be done).Then, in the CustomViewPager, create a method called updateViewAt(int position). The view itself can be gotten from ArrayList mItems defined in the ViewPager class (you need to set an Id for the views at instantiate item and compare this id with position in the updateViewAt() method). Then you can update the view as necessary.All these solution did not help me. thus i found a working solution:\nYou can setAdapter every time, but it isn\'t enough.\nyou should do these before changing adapter:and after this:what worked for me was going viewPager.getAdapter().notifyDataSetChanged();and in the adapter putting your code for updating the view inside getItemPosition like somight not be the most correct way of going about it but it worked (the return POSITION_NONE trick caused a crash for me so wasnt an option)You can update dynamically all fragments, you can see in three steps.In your adapter:Now in your activity:Finally in your fragment, something like that:You can see complete code here.Thanks Alvaro Luis Bustamante.Always returning POSITION_NONE is simple but a little inefficient way because that evoke instantiation of all page that have already instantiated.I\'ve created a library ArrayPagerAdapter to change items in PagerAdapters dynamically.Internally, this library\'s adapters return POSITION_NONE on getItemPosiition() only when necessary.You can change items dynamically like following by using this library.Thils library also support pages created by Fragments.This is a horrible problem and I\'m happy to present an excellent solution; simple, efficient, and effective !See below, the code shows using a flag to indicate when to return POSITION_NONEThank rui.araujo and Alvaro Luis Bustamante. At first, I try to use rui.araujo\'s way, because it\'s easy. It works but when the data change, the page will redraw obviously. It is bad so I try to use Alvaro Luis Bustamante\'s way. It\'s perfect. Here is the code:And when data change:I had the same issue and my solution is overriding of ViewPagerAdapter#getItemId(int position):By default, this method returns item\'s position. I suppose that ViewPager checks if itemId was changed and recreates page only if it was. But not-overriden version returns the same position as itemId even if page is actually different, and ViewPager doesn\'t define that page is replaced one and needs to be recreated.To use this, long id is needed for each page. Normally it is expected to be unique, but i suggest, for this case, that it just should be different from the previous value for the same page. So, It is possible to use continuous counter in adapter or random integers (with wide distribution) here.I think that it is more consistent way rather using of Tags of view mentioned as a solution in this topic. But probably not for all cases.I have tried all this solutions did not work for me because all my views are complex. So it is difficult to save the View and update the View. If you have a simple View that contains only a few TextView or something like this, it\'s easy and the solutions posted here works.\nBut if you have complex View like mine, and need to change the entire Fragment, I think that\'s impossible to do. I have investigating the ViewPager code, and it seems that the ViewPager keeps the old fragments. It\'s easy to realize it : Search for some native application from your device that implements swipe and do the test changing the language from English to Arabic. In this case, it should change the order of fragments, because Arabic is a RTL language. But it did not work this way.Instead of returning POSITION_NONE and creating all fragments again, you can do as I suggested here: Update ViewPager dynamically?1.First you have to set the getItemposition method in your Pageradapter class \n2.You have to read the Exact position of your View Pager\n3.then send that position as data location of your new one \n4.Write update button onclick listener inside the setonPageChange listenerthat program code is little bit i modified to set the particular position element only I think I\'ve made a simple way to notify of data set changes:First, change a bit the way the instantiateItem function works:for "updateView" , fill the view with all the data you wish to fill (setText,setBitmapImage,...) .verify that destroyView works like this:Now, suppose you need to change the data, do it, and then call the next function on the PagerAdapter :For example if you wish to notify all of the views that are being shown by the viewPager that something has changed, you can call:That\'s it.For what it\'s worth, on KitKat+ it seems that adapter.notifyDataSetChanged() is enough to cause the new views to show up, provided that you\'ve setOffscreenPageLimit sufficiently high. I\'m able to get desired behavior by doing viewPager.setOffscreenPageLimit(2).I actually use notifyDataSetChanged() on ViewPager and CirclePageIndicator and after that I call destroyDrawingCache() on ViewPager and it works.. None of the other solutions worked for me.if you want to solve Viewpager update problem check this project, it  will solve your problem.and more understand check that; happy coding...In my case every time that Fragment entered to @override onCreateView(...) i was restarting values so handle null or empty values like:Fragment class could enter to onCreateView every time we change and get back to the view from the UI at runtime.I m using Tablayout with ViewPagerAdapter. For passing data between fragments or for communicating between fragments use below code which works perfectly fine and refresh the fragment when ever it appears. Inside button click of second fragment write below code.below is the code which has to be written in first fragment (in my case) i-e in receiving Fragment.I leave here my own solution, which is a workaround because seems as the problem is the FragmentPagerAdapter doesn\'t clean the previous fragments, you can be added to the ViewPager, in the Fragment Manager. So, I create a method to execute before add the FragmentPagerAdapter:(In my case I never add more than 3 fragments, but you can use for example getFragmentManager().getBackStackEntryCount() and check all the fragments.I know it is a workaround because it will stop work if the way the framework is creating the tags change. (currently "android:switcher:" + containerId + ":" + i)Then the way to use it is after getting the container:I found very interesting decision of this problem.\nInstead of using FragmentPagerAdapter, which keep in memory all fragments, we can use FragmentStatePagerAdapter (android.support.v4.app.FragmentStatePagerAdapter), that reload fragment each time, when we select it.Realisations of both adapters are identical. So, we need just change "extend FragmentPagerAdapter" on "extend FragmentStatePagerAdapter"