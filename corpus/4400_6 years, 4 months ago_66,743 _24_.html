I am using shared preference in my android app. I am using both commit() and apply() method from shared preference. When I use AVD 2.3 it shows no error, but when I run the code in AVD 2.1, apply() method shows error. \nSO what\'s the difference between these two? And by using only commit() can I store the preference value without any problem?apply() was added in 2.3, it commits without returning a boolean indicating success or failure.commit() returns true if the save works, false otherwise. apply() was added as the Android dev team noticed that almost no one took notice of the return value, so apply is faster as it is asynchronous.http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#apply()tl;dr:More in-depth information from the SharedPreferences.Editor Documentation:Unlike commit(), which writes its\n  preferences out to persistent storage\n  synchronously, apply() commits its\n  changes to the in-memory\n  SharedPreferences immediately but\n  starts an asynchronous commit to disk\n  and you won\'t be notified of any\n  failures. If another editor on this\n  SharedPreferences does a regular\n  commit() while a apply() is still\n  outstanding, the commit() will block\n  until all async commits are completed\n  as well as the commit itself.As SharedPreferences instances are\n  singletons within a process, it\'s safe\n  to replace any instance of commit()\n  with apply() if you were already\n  ignoring the return value.The SharedPreferences.Editor interface\n  isn\'t expected to be implemented\n  directly. However, if you previously\n  did implement it and are now getting\n  errors about missing apply(), you can\n  simply call commit() from apply().I\'m experiencing some problems using apply() instead commit(). As stated before in other responses, the apply() is asynchronous. I\'m getting the problem that the changes formed to a "string set" preference are never written to the persistent memory.It happens if you "force detention" of the program or, in the ROM that I have installed on my device with Android 4.1, when the process is killed by the system due to memory necessities.I recommend to use "commit()" instead "apply()" if you want your preferences alive.The docs give a pretty good explanation of the difference between apply() and commit():Unlike commit(), which writes its preferences out to persistent\n  storage synchronously, apply() commits its changes to the in-memory\n  SharedPreferences immediately but starts an asynchronous commit to\n  disk and you won\'t be notified of any failures. If another editor on\n  this SharedPreferences does a regular commit() while a apply() is\n  still outstanding, the commit() will block until all async commits are\n  completed as well as the commit itself. As SharedPreferences instances\n  are singletons within a process, it\'s safe to replace any instance of\n  commit() with apply() if you were already ignoring the return value.Use apply(). It writes the changes to the RAM immediately and waits and writes it to the internal storage(the actual preference file) after. Commit writes the changes synchronously and directly to the file. From javadoc:Unlike commit(), which writes its\n  preferences out to persistent storage\n  synchronously, apply() commits its\n  changes to the in-memory\n  SharedPreferences immediately but\n  starts an asynchronous commit to disk\n  and you won\'t be notified of any\n  failures. If another editor on this SharedPreferences does a regular commit() while a > apply() is still outstanding, the commit() will block until all async commits are completed as well as the commit itselfcommit() is synchronously, apply() is asynchronousapply() is void function. commit() returns true if the new values were successfully written to persistent storage. apply() guarantees  complete before switching states , you don\'t need to worry about Android component lifecyclesIf you dont use  value returned from commit() and you\'re using commit() from main thread, use apply() instead of  commit()