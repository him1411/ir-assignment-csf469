For the most part, you just take whatever Visual Studio sets it for you as a default... I\'m referring to the BuildAction property for each file selected in Solution Explorer. There are a number of options and it\'s difficult to know what each one of them will do.None: The file is not included in the project output group and is not compiled in the build process. An example is a text file that contains documentation, such as a Readme file.Compile: The file is compiled into the build output. This setting is used for code files.Content: Allows you to retrieve a file (in same directory as the assembly) as a stream via Application.GetContentStream(URI). For this method to work, it needs a AssemblyAssociatedContentFile custom attribute which Visual Studio graciously adds when you mark a file as "Content"Embedded resource: embeds the file in an exclusive assembly manifest resource.Resource (WPF only): embeds the file in a shared (by all files in the assembly with similar setting) assembly manifest resource named AppName.g.resources.Page (WPF only): Used to compile a xaml file into baml. The baml is then embedded with the same technique as Resource (i.e. available as `AppName.g.resources)ApplicationDefinition (WPF only): Mark the XAML/class file that defines your application. You specify the code-behind with the x:Class="Namespace.ClassName" and set the startup form/page with StartupUri="Window1.xaml"SplashScreen (WPF only): An image that is marked as SplashScreen is shown automatically when an WPF application loads, and then fadesDesignData: Compiles XAML viewmodels so that usercontrols can be previewed with sample data in Visual Studio (uses mock types)DesignDataWithDesignTimeCreatableTypes: Compiles XAML viewmodels so that usercontrols can be previewed with sample data in Visual Studio (uses actual types)EntityDeploy: (Entity Framework): used to deploy the Entity Framework artifactsCodeAnalysisDictionary: A XML file containing custom word dictionary for spelling rulesFrom the documentation:The BuildAction property indicates\n  what Visual Studio does with a file\n  when a build is executed. BuildAction\n  can have one of several values:None - The file is not included in the\n  project output group and is not\n  compiled in the build process. An\n  example is a text file that contains\n  documentation, such as a Readme file.Compile - The file is compiled into\n  the build output. This setting is used\n  for code files.Content - The file is not compiled,\n  but is included in the Content output\n  group. For example, this setting is\n  the default value for an .htm or other\n  kind of Web file.Embedded Resource - This file is\n  embedded in the main project build\n  output as a DLL or executable. It is\n  typically used for resource files.Page -- Takes the specified XAML file, and compiles into BAML, and embeds that output into the managed resource stream for your assembly (specifically AssemblyName.g.resources), Additionally, if you have the appropriate attributes on the root XAML element in the file, it will create a blah.g.cs file, which will contain a partial class of the "codebehind" for that page; this basically involves a call to the BAML goop to re-hydrate the file into memory, and to set any of the member variables of your class to the now-created items (e.g. if you put x:Name="foo" on an item, you\'ll be able to do this.foo.Background = Purple; or similar.ApplicationDefinition -- similar to Page, except it goes onestep furthur, and defines the entry point for your application that will instantiate your app object, call run on it, which will then instantiate the type set by the StartupUri property, and will give your mainwindow.Also, to be clear, this question overall is infinate in it\'s results set; anyone can define additional BuildActions just by building an MSBuild Task. If you look in the %systemroot%\\Microsoft.net\\framework\\v{version}\\ directory, and look at the Microsoft.Common.targets file, you should be able to decipher many more (example, with VS Pro and above, there is a "Shadow" action that allows you generate private accessors to help with unit testing private classes.VS2010 has a property for \'Build Action\', and also for \'Copy to Output Directory\'.  So an action of \'None\' will still copy over to the build directory if the copy property is set to \'Copy if Newer\' or \'Copy Always\'.So a Build Action of \'Content\' should be reserved to indicate content you will access via \'Application.GetContentStream\'I used the \'Build Action\' setting of \'None\' and the \'Copy to Output Direcotry\' setting of \'Copy if Newer\' for some externally linked .config includes.G.In VS2008, the doc entry that seems the most useful is:Windows Presentation Foundation  Building a WPF Application (WPF)ms-help://MS.VSCC.v90/MS.MSDNQTR.v90.en/wpf_conceptual/html/a58696fd-bdad-4b55-9759-136dfdf8b91c.htmApplicationDefinition\n Identifies the XAML markup file that contains the application definition (a XAML markup file whose root element is Application). ApplicationDefinition is mandatory when Install is true and OutputType is winexe. A WPF application and, consequently, an MSBuild project can only have one ApplicationDefinition.Page\n Identifies a XAML markup file whose content is converted to a binary format and compiled into an assembly. Page items are typically implemented in conjunction with a code-behind class.The most common Page items are XAML files whose top-level elements are one of the following:Resource\n Identifies a resource file that is compiled into an application assembly. As mentioned earlier, UICulture processes Resource items.Content\n Identifies a content file that is distributed with an application. Metadata that describes the content file is compiled into the application (using AssemblyAssociatedContentFileAttribute).How about this page from Microsoft Connect (explaining the DesignData and DesignDataWithDesignTimeCreatableTypes) types. Quoting:The following describes the two Build Actions for Sample Data files.Sample data .xaml files must be assigned one of the below Build Actions:DesignData: Sample data types will be created as faux types. Use this Build Action when the sample data types are not creatable or have read-only properties that you want to defined sample data values for.DesignDataWithDesignTimeCreatableTypes: Sample data types will be created using the types defined in the sample data file. Use this Build Action when the sample data types are creatable using their default empty constructor.Not so incredibly exhaustive, but it at least gives a hint. This MSDN walkthrough also gives some ideas. I don\'t know whether these Build Actions are applicable for non-Silverlight projects also.