I have a class with a private static final field that, unfortunately, I need to change at run-time.Using reflection I get this error: java.lang.IllegalAccessException: Can not set static final boolean fieldIs there any way to change the value?Assuming no SecurityManager is preventing you from doing this, you can use setAccessible to get around private and resetting the modifier to get rid of final, and actually modify a private static final field.Here\'s an example:Assuming no SecurityException is thrown, the above code prints "Everything is true".What\'s actually done here is as follows:Extreme care should be taken whenever you do something like this. It may not work because a SecurityManager may be present, but even if it doesn\'t, depending on usage pattern, it may or may not work.JLS 17.5.3 Subsequent Modification of Final FieldsIn some cases, such as deserialization, the system will need to change the final fields of an object after construction. final fields can be changed via reflection and other implementation dependent means. The only pattern in which this has reasonable semantics is one in which an object is constructed and then the final fields of the object are updated. The object should not be made visible to other threads, nor should the final fields be read, until all updates to the final fields of the object are complete. Freezes of a final field occur both at the end of the constructor in which the final field is set, and immediately after each modification of a final field via reflection or other special mechanism.Even then, there are a number of complications. If a final field is initialized to a compile-time constant in the field declaration, changes to the final field may not be observed, since uses of that final field are replaced at compile time with the compile-time constant.Another problem is that the specification allows aggressive optimization of final fields. Within a thread, it is permissible to reorder reads of a final field with those modifications of a final field that do not take place in the constructor.Essentially,turns off the bit corresponding to Modifier.FINAL from field.getModifiers(). & is the bitwise-and, and ~ is the bitwise-complement.If the value assigned to a static final boolean field is known at compile-time, it is a constant. Fields of primitive or \nString type can be compile-time constants. A constant will be inlined in any code that references the field. Since the field is not actually read at runtime, changing it then will have no effect.The Java language specification says this:If a field is a constant variable\n  (\xc2\xa74.12.4), then deleting the keyword\n  final or changing its value will not\n  break compatibility with pre-existing\n  binaries by causing them not to run,\n  but they will not see any new value\n  for the usage of the field unless they\n  are recompiled. This is true even if\n  the usage itself is not a compile-time\n  constant expression (\xc2\xa715.28)Here\'s an example:If you decompile Checker, you\'ll see that instead of referencing Flag.FLAG, the code simply pushes a value of 1 (true) onto the stack (instruction #3).A little curiosity from the Java Language Specification, chapter 17, section 17.5.4 "Write-protected Fields":Normally, a field that is final and static may not be modified.\n  However, System.in, System.out, and System.err are static final fields\n  that, for legacy reasons, must be allowed to be changed by the methods\n  System.setIn, System.setOut, and System.setErr. We refer to these\n  fields as being write-protected to distinguish them from ordinary\n  final fields.Source: http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5.4I also integrated it with joor libraryJust use Also I fixed an issue with override which the previous solutions seem to miss.\nHowever use this very carefully, only when there\'s no other good solution.In case of presence of a Security Manager, one can make use of AccessController.doPrivileged Taking the same example from accepted answer above:In lambda expression, AccessController.doPrivileged, can be simplified to:Along with top ranked answer you may use a bit simpliest approach. Apache commons FieldUtils class already has particular method that can do the stuff. Please, take a look at FieldUtils.removeFinalModifier method. You should specify target field instance and accessibility forcing flag (if you play with non-public fields). More info you can find here.The accepted answer worked for me until deployed on JDK 1.8u91.\nThen I realized it failed at field.set(null, newValue); line when I had read the value via reflection before calling of setFinalStatic method.Probably the read caused somehow different setup of Java reflection internals (namely sun.reflect.UnsafeQualifiedStaticObjectFieldAccessorImpl in failing case instead of sun.reflect.UnsafeStaticObjectFieldAccessorImpl in success case) but I didn\'t elaborate it further.Since I needed to temporarily set new value based on old value and later set old value back, I changed signature little bit to provide computation function externally and also return old value:However for general case this would not be sufficient.The whole point of a final field is that it cannot be reassigned once set. The JVM uses this guarentee to maintain consistency in various places (eg inner classes referencing outer variables). So no. Being able to do so would break the JVM!The solution is not to declare it final in the first place.Just saw that question on one of the interview question, if possible to change final variable with reflection or in runtime. \nGot really interested, so that what I became with:Some simple class with final String variable. So in the main class \nimport java.lang.reflect.Field;The output will be as follows:According to documentation \nhttps://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html