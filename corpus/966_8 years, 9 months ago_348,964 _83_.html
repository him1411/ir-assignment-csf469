I have the name of a function in JavaScript as a string. How do I convert that into a function pointer so I can call it later?Depending on the circumstances, I may need to pass various arguments into the method too.Some of the functions may take the form of namespace.namespace.function(args[...]).Don\'t use eval unless you absolutely, positively have no other choice.As has been mentioned, using something like this would be the best way to do it:That, however, will not work with a namespace\'d function:This is how you would do that:In order to make that easier and provide some flexibility, here is a convenience function:You would call it like so:Note, you can pass in whatever context you want, so this would do the same as above:Just thought I\'d post a slightly altered version of Jason Bunting\'s very helpful function.First, I have simplified the first statement by supplying a second parameter to slice(). The original version was working fine in all browsers except IE.Second, I have replaced this with context in the return statement; otherwise, this was always pointing to window when the target function was being executed.The answer to this other question shows you how to do that: Javascript equivalent of Python's locals()?Basically, you can sayor as many others have suggested, you can just use eval:although this is extremely unsafe unless you\'re absolutely sure about what you\'re eval-ing.Could you not just do this:You can also execute any other JavaScript using this method.I think an elegant way of doing this is by defining your functions in a hash object. Then you can have a reference to those functions from the hash using the string. e.g.Then you can call:Where customFunction will be a string matching a function defined in your object.Two things: avoid eval, it\'s terribly dangerous and slowsecondly it doesn\'t matter where your function exists, "global" -ness is irrelevant. x.y.foo() can be enabled through x.y[\'foo\']() or x[\'y\'][\'foo\']() or even window[\'x\'][\'y\'][\'foo\'](). You can chain indefinitely like this.You just need convert your string to a pointer by window[<method name>].\nexample:and now you can use it like a pointer.All the answers assume that the functions can be accessed through global scope (aka window). However, the OP did not make this assumption.If the functions live in a local scope (aka closure) and are not referenced by some other local object, bad luck: You have to use eval() AFAIK, see\ndynamically call local function in javascriptWith ES6 you could to access class methods by name:the output would be:If you want to call a function of an object instead of a global function with window["functionName"]. You can do it like;Example:BE CAREFUL!!!One should try to avoid calling a function by string in JavaScript for two reasons:Reason 1: Some code obfuscators will wreck your code as they will change the function names, making the string invalid.Reason 2: It is much harder to maintain code that uses this methodology as it is much harder to locate usages of the methods called by a string.Here is my contribution to Jason Bunting\'s / Alex Nazarov\'s excellent answers, where I include error checking requested by Crashalot.Given this (contrived) preamble:then the following function:will allow you to call a javascript function by name stored in a string, either namespaced or global, with or without arguments (including Array objects), providing feedback on any errors encountered (hopefully catching them).The sample output shows how it works:Surprised to see no mention of setTimeout.To run a function without arguments:To run function with arguments:To run deeply namespaced function:One more detail on Jason and Alex\'s posts. I found it helpful to add a default value to context. Just put context = context == undefined? window:context; at the beginning of the function. You can change window to whatever your preferred context is, and then you won\'t need to pass in the same variable each time you call this in your default context.There\'s a very similar thing in my code.\nI have a server-generated string which contains a function name which I need to pass as a callback for a 3rd party library. So I have a code that takes the string and returns a "pointer" to the function, or null if it isn\'t found.My solution was very similar to "Jason Bunting\'s very helpful function" *, although it doesn\'t auto-execute, and the context is always on the window. But this can be easily modified.Hopefully this will be helpful to someone.There too some very helpful way.http://devlicio.us/blogs/sergio_pereira/archive/2009/02/09/javascript-5-ways-to-call-a-function.aspxSo, like others said, definitely the best option is:And like Jason Bunting said, it won\'t work if the name of your function includes an object:So here\'s my version of a function that will execute all functions by name (including an object or not):I can\'t resist mentioning another trick, which helps if you have an unknown number of arguments that are also being passed as part of the string containing the function name. For example:var annoyingstring = \'call_my_func(123, true, "blah")\';If your Javascript is running on a HTML page, all you need is an invisible link; you can pass a string into the onclick attribute, and the call the click method.<a href="#" id="link_secret"><!-- invisible --></a>Or create the <a> element at runtime.Easiest way is to access it like has element is same as This is working for me.To add to Jason Bunting\'s answer, if you\'re using nodejs or something (and this works in dom js, too), you could use this instead of window (and remember: eval is evil:Without using eval(\'function()\') you could to create a new function using new Function(strName). The below code was tested using FF, Chrome, IE.Look basic:Exist other type function is class and look example nils petersohnThanks for the very helpful answer. I\'m using Jason Bunting\'s function in my projects. I extended it to use it with an optional timeout, because the normal way to set a timeout wont work. See abhishekisnot\'s questionThere are several executeByName functions here which works fine, unless name contains square brackets - issue I ran into - as I have dynamically generated names. So above functions will fail on names likeapp.widget[\'872LfCHc\'][\'toggleFolders\']As a remedy, I\'ve made function to take this into account too, maybe someone will find it usefull:Generated from CoffeeScript:For better readability check also CoffeeScript version:You can call javascript function within the eval("functionname as string") either. Like below: (eval is pure javascript function)Working example: https://jsfiddle.net/suatatan/24ms0fna/4/A more OOP solution ...all you have to do is use a context or define a new context where you function(s) reside. \nyou are not limited to window["f"]();here is an example of how I use some dynamic invocation for some REST services.If you want to generate the entire function from a string, that\'s a different answer.\nalso please notice that you are not limited to a single name space,  if you name space exists as   my.name.space.for.functions.etc.etc.etc the last branch of your name space contains the function as my.name.space.for.functions.etc.etc["function"]();Hope it helps.\nH.