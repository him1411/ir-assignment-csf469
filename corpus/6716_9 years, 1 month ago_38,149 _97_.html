I know the so-called textbook definition of unit tests and integration tests.  What I am curious about is when it is time to write unit tests... I will write them to cover as many sets of classes as possible.For example, if I have a Word class, I will write some unit tests for the Word class.  Then, I begin writing my Sentence class, and when it needs to interact with the Word class, I will often write my unit tests such that they test both Sentence and Word... at least in the places where they interact.Have these tests essentially become integration tests because they now test the integration of these 2 classes, or is it just a unit test that spans 2 classes?In general, because of this uncertain line, I will rarely actually write integration tests... or is my using the finished product to see if all the pieces work properly the actual integration tests, even though they are manual and rarely repeated beyond the scope of each individual feature?Am I misunderstanding integration tests, or is there really just very little difference between integration and unit tests?Thanks for all the great responses everyone!  I think from the varied answers it\'s clear that the line between unit and integration tests is definitely a blurry line, and perhaps it\'s a bit pedantic to try and figure out which are which and the true focus should stay on the code (Thanks @Rob Cooper).  Also, sorry but I\'m not going to accept any answer because too many are too good, and it really seems quite subjective.The key difference, to me, is that integration tests reveal if a feature is working or is broken, since they stress the code in a scenario close to reality. They invoke one or more software methods or features and test if they act as expected.On the opposite, a Unit test testing a single method relies on the often wrong assumption that the rest of the software is correctly working, because it explicitly mocks every dependencies.Hence, when a unit test for a method implementing some feature is green, it does not mean the feature is working.Say you have a method somewhere like thisDoSomething is very important to your customer: it\'s a feature, the only thing that matters. That\'s why you usually write a Cucumber specification asserting it: you wish to verify and communicate the feature is working or not.No doubt: if the test passes, you can assert you are delivering a working feature. This is what you can call Business Value.If you want to write a unit test for DoSomething you should pretend (using some mocks) that the rest of the classes and methods are working (that is: that, all dependencies the method is using are correctly working), and assert your method is working.In practice, you do something likeYou can do this with Dependency Injection, or some Factory Method or any Mock Framework or just extending the class under test.Suppose there\'s a bug in Log.DoSomething().\nFortunately, the Gherkin spec will find it and your end-to-end tests will fail.The feature won\'t work, because Log is broken, not because [Do your job with someInput] is not doing it\'s job. And, by the way, [Do your job with someInput] is the sole responsibility for that method.Also, suppose Log is used in 100 other features, in 100 other methods of 100 other classes.Yep, 100 features will fail. But, fortunately, 100 end-to-end tests are failing as well and revealing the problem. And, yes: they are telling the truth.It\'s a very useful information: I know I have a broken product. It\'s also a very confusing information: it tells me nothing about where the problem is. It communicates me the symptom, not the root cause.Yet, DoSomething\'s unit test is green, because it\'s using a fake Log, built to never break. And, yes: it\'s clearly lying. It\'s communicating a broken feature is working. How can it be useful?(If DoSomething()\'s unit test fails, be sure: [Do your job with someInput] has some bugs.)Suppose this is a system with a broken class\nA single bug will break several features, and several integration tests will failOn the other hand, the same bug will break just one unit testNow, compare the two scenarios.The same bug will break just one unit testActually, unit tests for all modules using a broken feature are green because, by using mocks, they removed dependencies. In other words, they run in an ideal, completely fictional world. And this is the only way to isolate bugs and seek them. Unit testing means mocking. If you aren\'t mocking, you aren\'t unit testing.Integration tests tell what\'s not working. But they are of no use in guessing where the problem could be.Unit tests are the sole tests that tell you where exactly the bug is. To draw this information, they must run the method in a mocked environment, where all other dependencies are supposed to correctly work.That\'s why I think that your sentence "Or is it just a unit test that spans 2 classes" is somehow displaced. A unit test should never span 2 classes.This reply is basically a summary of what I wrote here: Unit tests lie, that\'s why I love them.When I write unit tests I limit the scope of the code being tested to the class I am currently writing by mocking dependencies.  If I am writing a Sentence class, and Sentence has a dependency on Word, I will use a mock Word.  By mocking Word I can focus only on its interface and test the various behaviors of my Sentence class as it interacts with Word\'s interface.  This way I am only testing the behavior and implementation of Sentence and not at the same time testing the implentation of Word.Once I\'ve written the unit tests to ensure Sentence behaves correctly when it ineteracts with Word based on Word\'s interface I write the integration test to make sure that my assumptions about the interactions were correct.  For this I supply the actual objects and write a test that excercises a feature that will end up using both Sentence and Word.My 10 bits :DI was always told that Unit Tests is the testing of an individual component - which should be exercised to its fullest. Now, this tends to have many levels, since most components are made of smaller parts. For me, a unit is a functional part of the system. So it has to provide something of value (i.e. not a method for string parsing, but a HtmlSanitizer perhaps).Integration Tests is the next step up, its taking one or more components and making sure they work together as they should.. You are then above the intricacies of worry about how the components work individually, but when you enter html into your HtmlEditControl , it somehow magically knows wether its valid or not..Its a real movable line though.. I\'d rather focus more on getting the damn code to work full stop ^_^Unit tests use mocksThe thing you\'re talking about are integration tests that actually test the whole integration of your system. But when you do unit testing you should actually test each unit separately. Everything else should be mocked. So in your case of Sentence class, if it uses Word class, then your Word class should be mocked. This way, you\'ll only test your Sentence class functionality.I think when you start thinking about integration tests, you are speaking more of a cross between physical layers rather than logical layers.For example, if your tests concern itself with generating content, it\'s a unit test: if your test concerns itself with just writing to disk, it\'s still a unit test, but once you test for both I/O AND the content of the file, then you have yourself an integration test. When you test the output of a function within a service, it\'s a unit-test, but once you make a service call and see if the function result is the same, then that\'s an integration test.Technically you cannot unit test just-one-class anyway. What if your class is composed with several other classes? Does that automatically make it an integration test? I don\'t think so.Unit Testing: The testing done to a unit or to a smallest piece of software. Done to verify if it satisfies its functional specification or its intended design structure.Integration Testing: Testing the related modules together for its combined functionality.using Single responsibility design, its black and white. More than 1 responsibility, its an integration test. By the duck test (looks, quacks, waddles, its a duck), its just a unit test with more than 1 newed object in it.When you get into mvc and testing it, controller tests are always integration, because the controller contains both a model unit and a view unit. Testing logic in that model, I would call a unit test.In my opinion the answer is "Why does it matter?"Is it because unit tests are something you do and integration tests are something you don\'t? Or vice versa? Of course not, you should try to do both.Is it because unit tests need to be Fast, Isolated, Repeatable, Self-Validating and Timely and integration tests should not? Of course not, all tests should be these.It is because you use mocks in unit tests but you don\'t use them in integration tests? Of course not. This would imply that if I have a useful integration test I am not allowed to add a mock for some part, fear I would have to rename my test to "unit test" or hand it over to another programmer to work on.Is it because unit tests test one unit and integration tests test a number of units? Of course not. Of what practical importance is that? The theoretical discussion on the scope of tests breaks down in practice anyway because the term "unit" is entirely context dependent. At the class level, a unit might be a method. At an assembly level, a unit might be a class, and at the service level, a unit might be a component.\nAnd even classes use other classes, so which is the unit?It is of no importance.Testing is important, F.I.R.S.T is important, splitting hairs about definitions is a waste of time which only confuses newcomers to testing.Think of the nature of your tests in the following terms:Remember that an integration test may still stub/fake/mock away some of its dependencies.\nThis provides plenty of middle ground between unit tests and system tests (the most comprehensive integration tests, testing all of the system).So a pragmatic approach would be: Flexibly rely on integration tests as much as you sensibly can and use unit tests where this would be too risky or inconvenient.\nThis manner of thinking may be more useful than some dogmatic discrimination of unit tests and integration tests.I think I would still call a couple of interacting classes a unit test provided that the unit tests for class1 are testing class1\'s features, and the unit tests for class2 are testing its features, and also that they are not hitting the database.I call a test an integration test when it runs through most of my stack and even hits the database.I really like this question, because TDD discussion sometimes feels a bit too purist to me, and it\'s good for me to see some concrete examples.I do the same - I call them all unit tests, but at some point I have a "unit test" that covers so much I often rename it to "..IntegrationTest" - just a name change only, nothing else changes. I think there is a continuation from "atomic tests" (testing one tiny class, or a method) to unit tests (class level) and integration tests - and then functional test (which are normally covering a lot more stuff from the top down) - there doesn\'t seem to be a clean cut off. If your test sets up data, and perhaps loads a database/file etc, then perhaps its more of an integration test (integration tests I find use less mocks and more real classes, but that doesn\'t mean you can\'t mock out some of the system).Unit Testing is a method of testing that verifies the individual units of source code are working properly.Integration Testing is the phase of software testing in which individual software modules are combined and tested as a group. Wikipedia defines a unit as the smallest testable part of an application, which in Java/C# is a method. But in your example of Word and Sentence class I would probably just write the tests for sentence since I would likely find it overkill to use a mock word class in order to test the sentence class. So sentence would be my unit and word is an implementation detail of that unit.Unit testing is testing against a unit of work or a block of code if you like. Usually performed by a single developer.Integration testing refers to the test that is performed, preferably on an integration server, when a developer commits their code to a source control repository. Integration testing might be performed by utilities such as Cruise Control.So you do your unit testing to validate that the unit of work you have built is working and then the integration test validates that whatever you have added to the repository didn\'t break something else.A little bit academic this question, isn\'t it? ;-)\nMy point of view:\nFor me an integration test is the test of the whole part, not if two parts out of ten are going together.\nOur integration test shows, if the master build (containing 40 projects) will succeed.\nFor the projects we have tons of unit tests.\nThe most important thing concerning unit tests for me is, that one unit test must not be dependent on another unit test. So for me both test you describe above are unit tests, if they are independent. For integration tests this need not to be important.I call unit tests those tests that white box test a class. Any dependencies that class requires is replaced with fake ones (mocks).Integration tests are those tests where multiple classes and their interactions are tested at the same time. Only some dependencies in these cases are faked/mocked.I wouldn\'t call Controller\'s integration tests unless one of their dependencies is a real one (i.e. not faked) (e.g. IFormsAuthentication).Separating the two types of tests is useful for testing the system at different levels. Also, integration tests tend to be long lived, and unit tests are supposed to be quick. The execution speed distinction means they\'re executed differently. In our dev processes, unit tests are run at check-in (which is fine cos they\'re super quick), and integration tests are run once/twice per day. I try and run integration tests as often as possible, but usually hitting the database/writing to files/making rpc\'s/etc slows.That raises another important point, unit tests should avoid hitting IO (e.g. disk, network, db). Otherwise they slow down alot. It takes a bit of effort to design these IO dependencies out - i can\'t admit I\'ve been faithful to the "unit tests must be fast" rule, but if you are, the benefits on a much larger system become apparent very quickly.Integration tests: Database persistence is tested.\nUnit tests: Database access is mocked. Code methods are tested.Have these tests essentially become integration tests because they now test the integration of these 2 classes? Or is it just a unit test that spans 2 classes?I think Yes and Yes. Your unit test that spans 2 classes became an integration test. You could avoid it by testing Sentence class with mock implementation - MockWord class, which is important when those parts of system are large enough to be implemented by different developers. In that case Word is unit tested alone, Sentence is unit tested with help of MockWord, and then Sentence is integration-tested with Word.Exaple of real difference can be following\n1) Array of 1,000,000 elements is easily unit tested and works fine.\n2) BubbleSort is easily unit tested on mock array of 10 elements and also works fine\n3) Integration testing shows that something is not so fine.If these parts are developed by single person, most likely problem will be found while unit testing BubbleSoft just because developer already has real array and he does not need mock implementation.In addition, it\'s important to remember that both unit tests and integration tests can be automated and written using, for example, JUnit. \nIn JUnit integration tests, one can use the org.junit.Assume class to test the availability of environment elements (e.g., database connection) or other conditions. The above examples do very well and I needn\'t repeat them. So I\'ll focus on using examples to help you understand. Integration TestsIntegration tests check if everything is working together. Imagine a series of cogs working together in a watch. An integration test would be: is the watch telling the correct time? Is it still telling the correct time in 3 days?All it tells you is whether the overall piece is working. If it fails: it doesn\xe2\x80\x99t tell you exactly where it is failing.Unit TestsThese are really specific types of test. They tell you whether one specific thing is working or failing. The key to this type of test is that it tests only one specific thing while assuming that everything else is working just fine. That\xe2\x80\x99s the key point. Example:\nLet\xe2\x80\x99s elaborate on this point using an example:The consequences of mixing your integration and unit tests:Suppose your car integration test fails. It doesn\xe2\x80\x99t drive successfully to Echuca. Where is the problem?You look in your engine test. But in this particular case, the engine test uses external dependencies: is uses a special fuel system. Let us suppose the engine unit test has also failed. Where then is the problem? (Give yourself 10 seconds to get the answer.)\n\xe2\x80\xa2   Did the engine fail, or was it the fuel system that caused the engine to fail?You see the problem here? You don\xe2\x80\x99t know what exactly is failing. If you use 10 dependencies, then every single one of those 10 could have caused the problem \xe2\x80\x93 and you won\xe2\x80\x99t know where to start. That\xe2\x80\x99s why unit tests mocks to assume that everything else is working just fine.I hope this helps.