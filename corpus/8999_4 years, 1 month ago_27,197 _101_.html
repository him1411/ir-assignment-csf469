I am trying to get the sum of 1 + 2 + ... + 1000000000, but I\'m getting funny results in PHP and Node.js.PHPNode.jsThe correct answer can be calculated usingCorrect answer = 500000000500000000, so I decided to try another language.GOBut it works fine! So what is wrong with my PHP and Node.js code?Perhaps this a problem of interpreted languages, and that\'s why it works in a compiled language like Go? If so, would other interpreted languages such as Python and Perl have the same problem?Python works:Or:Python\'s int auto promotes to a Python long which supports arbitrary precision. It will produce the correct answer on 32 or 64 bit platforms. This can be seen by raising 2 to a power far greater than the bit width of the platform:You can demonstrate (with Python) that the erroneous values you are getting in PHP is because PHP is promoting to a float when the values are greater than 2**32-1:Your Go code uses integer arithmetic with enough bits to give an exact answer. Never touched PHP or Node.js, but from the results I suspect the math is done using floating point numbers and should be thus expected not to be exact for numbers of this magnitude.The reason is that the value of your integer variable sum exceeds the maximum value. And the sum you get is result of float-point arithmetic which involves rounding off. Since other answers did not mention the exact limits, I decided to post it.The max integer value for PHP for:So it means either you are using 32 bit CPU or 32 bit OS or 32 bit compiled version of PHP. It can be found using PHP_INT_MAX. The sum would be calculated correctly if you do it on a 64 bit machine.The max integer value in JavaScript is 9007199254740992. The largest exact integral value you can work with is 253 (taken from this question). The sum exceeds this limit.If the integer value does not exceed these limits, then you are good. Otherwise you will have to look for arbitrary precision integer libraries.Here is the answer in C, for completeness:The key in this case is using C99\'s long long data type. It provides the biggest primitive storage C can manage and it runs really, really fast. The long long type will also work on most any 32 or 64-bit machine. There is one caveat: compilers provided by Microsoft explicitly do not support the 14 year-old C99 standard, so getting this to run in Visual Studio is a crapshot.My guess is that when the sum exceeds the capacity of a native int (232-1 = 2,147,483,647), Node.js and PHP switch to a floating point representation and you start getting round-off errors. A language like Go will probably try to stick with an integer form (e.g., 64-bit integers) as long as possible (if, indeed, it didn\'t start with that). Since the answer fits in a 64-bit integer, the computation is exact.Perl script give us the expected result:The Answer to this is "surprisingly" simple:First - as most of you might know - a 32-bit integer ranges from \xe2\x88\x922,147,483,648 to 2,147,483,647. So, what happens if PHP gets a result, that is LARGER than this?Usually, one would expect a immediate "Overflow", causing 2,147,483,647 + 1 to turn into \xe2\x88\x922,147,483,648. However, that is NOT the case. IF PHP Encounters a larger number, it Returns FLOAT instead of INT.If PHP encounters a number beyond the bounds of the integer type, it will be interpreted as a float instead. Also, an operation which results in a number beyond the bounds of the integer type will return a float instead.http://php.net/manual/en/language.types.integer.phpThis said, and knowing that PHP FLOAT implementation is following the IEEE 754 double precision Format, means, that PHP is able to deal with numbers upto 52 bit, without loosing precision. (On a 32-bit System)So, at the Point, where your Sum hits 9,007,199,254,740,992 (which is 2^53) The Float value returned by the PHP Maths will no longer be precise enough. 9,007,199,254,740,9929,007,199,254,740,9929,007,199,254,740,994This example Shows the Point, where PHP is loosing precision. First, the last significatn bit will be dropped, causing the first 2 expressions to result in an equal number - which they aren\'t.From NOW ON, the whole math will go wrong, when working with default data-types.\xe2\x80\xa2Is it the same problem for other interpreted language such as Python or Perl?I don\'t think so. I think this is a problem of languages that have no type-safety. While a Integer Overflow as mentioned above WILL happen in every language that uses fixed data types, the languages without type-safety might try to catch this with other datatypes. However, once they hit their "natural" (System-given) Border - they might return anything, but the right result.However, each language may have different threadings for such a Scenario. The other answers already explained what is happening here (floating point precision as usual).One solution is to use an integer type big enough, or to hope the language will chose one if needed.The other solution is to use a summation algorithm that knows about the precision problem and works around it. Below you find the same summation, first with with 64 bit integer, then with 64 bit floating point and then using floating point again, but with the Kahan summation algorithm.Written in C#, but the same holds for other languages, too.The Kahan summation gives a beautiful result. It does of course take a lot longer to compute. Whether you want to use it depends a) on your performance vs. precision needs, and b) how your language handles integer vs. floating point data types.If you have 32-Bit PHP, you can calculate it with bc:In Javascript you have to use arbitrary number library, for example BigInteger:Even with languages like Go and Java you will eventually have to use arbitrary number library, your number just happened to be small enough for 64-bit but too high for 32-bit.In Ruby:Prints 500000000500000000, but takes a good 4 minutes on my 2.6 GHz Intel i7.Magnuss and Jaunty have a much more Ruby solution:To run a benchmark:I use node-bigint for big integer stuff:\nhttps://github.com/substack/node-bigintIt\'s not as quick as something that can use native 64-bit stuff for this exact test, but if you get into bigger numbers than 64-bit, it uses libgmp under the hood, which is one of the faster arbitrary precision libraries out there.took ages in ruby, but gives the correct answer:To get the correct result in php I think you\'d need to use the BC math operators: http://php.net/manual/en/ref.bc.phpHere is the correct answer in Scala.  You have to use Longs otherwise you overflow the number:There\'s actually a cool trick to this problem.Assume it was 1-100 instead.1       +     2      +    3    +      4     +   ...   +   50  +100     +    99      +   98    +     97     +   ...   +   51=  (101 +    101     +   101   +    101     +   ...   +   101) = 101*50Formula: For N= 100:\nOutput = N/2*(N+1)For N = 1e9:\nOutput = N/2*(N+1)This is much faster than looping through all of that data.  Your processor will thank you for it.  And here is an interesting story regarding this very problem:http://www.jimloy.com/algebra/gauss.htmCommon Lisp is one of the fastest interpreted* languages and handles arbitrarily large integers correctly by default. This takes about 3 second with SBCL:I don\'t have enough reputation to comment on @postfuturist\'s Common Lisp answer, but it can be optimized to complete in ~500ms with SBCL 1.1.8 on my machine:Category other interpreted language:If using Tcl 8.4 or older it depends if it was compiled with 32 or 64 bit. (8.4 is end of life).If using Tcl 8.5 or newer which has arbitrary big integers, it will display the correct result.I put the test inside a proc to get it byte-compiled.This gives the proper result in PHP by forcing the integer cast.Racket v 5.3.4 (MBP; time in ms):Erlang gives the expected result too. sum.erl:And using it:Works fine in Rebol:This was using Rebol 3 which despite being 32 bit compiled it uses 64-bit integers (unlike Rebol 2 which used 32 bit integers)I wanted to see what happened in CF ScriptI got 5.00000000067E+017This was a pretty neat experiment. I\'m fairly sure I could have coded this a bit better with more effort. ActivePerl v5.10.1 on 32bit windows, intel core2duo 2.6:result: 5.00000000067109e+017 in 5 minutes.With "use bigint" script worked for two hours, and would worked more, but I stopped it. Too slow.Smalltalk:For the sake of completeness, in Clojure (beautiful but not very efficient):AWK:produces the same wrong result as PHP:It seems AWK uses floating point when the numbers are really big, so at least the answer is the right order-of-magnitude.Test runs:For the PHP code, the answer is here:The size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that\'s 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18. PHP does not support unsigned integers. Integer size can be determined using the constant PHP_INT_SIZE, and maximum value using the constant PHP_INT_MAX since PHP 4.4.0 and PHP 5.0.5.Harbour:Results in 500000000500000000.\n(on both windows/mingw/x86 and osx/clang/x64)Erlang works:Results: 41> useless:from_sum(1,1000000000). \n  500000000500000000Funny thing, PHP 5.5.1 gives 499999999500000000 (in ~ 30s), while Dart2Js gives 500000000067109000 (which is to be expected, since it\'s JS that gets executed). CLI Dart gives the right answer ... instantly.