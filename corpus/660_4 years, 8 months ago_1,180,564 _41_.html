In an HTTP GET request, parameters are sent as a query string:In an HTTP POST request, the parameters are not sent along with the URI.Where are the values? In the request header? In the request body? What does it look like?The values are sent in the request body, in the format that the content type specifies.Usually the content type is application/x-www-form-urlencoded, so the request body uses the same format as the query string:When you use a file upload in the form, you use the multipart/form-data encoding instead, which has a different format. It\'s more complicated, but you usually don\'t need to care what it looks like, so I won\'t show an example, but it can be good to know that it exists.The content is put after the HTTP headers.  The format of an HTTP POST is to have the HTTP headers, followed by a blank line, followed by the request body.  The POST variables are stored as key-value pairs in the body.You can see this in the raw content of an HTTP Post, shown below:You can see this using a tool like Fiddler, which you can use to watch the raw HTTP request and response payloads being sent across the wire.Short answer: in POST requests, values are sent in the "body" of the request. With web-forms they are most likely sent with a media type of application/x-www-form-urlencoded or multipart/form-data. Programming languages or frameworks which have been designed to handle web-requests usually do "The Right Thing\xe2\x84\xa2" with such requests and provide you with easy access to the readily decoded values (like $_REQUEST or $_POST in PHP, or cgi.FieldStorage(), flask.request.form in Python).Now let\'s digress a bit, which may help understand the difference ;)The difference between GET and POST requests are largely semantic. They are also "used" differently, which explains the difference in how values are passed.When executing a GET request, you ask the server for one, or a set of entities. To allow the client to filter the result, it can use the so called "query string" of the URL. The query string is the part after the ?. This is part of the URI syntax.So, from the point of view of your application code (the part which receives the request), you will need to inspect the URI query part to gain access to these values.Note that the keys and values are part of the URI. Browsers may impose a limit on URI length. The HTTP standard states that there is no limit. But at the time of this writing, most browsers do limit the URIs (I don\'t have specific values). GET requests should never be used to submit new information to the server. Especially not larger documents. That\'s where you should use POST or PUT.When executing a POST request, the client is actually submitting a new document to the remote host. So, a query string does not (semantically) make sense. Which is why you don\'t have access to them in your application code.POST is a little bit more complex (and way more flexible):When receiving a POST request, you should always expect a "payload", or, in HTTP terms: a message body. The message body in itself is pretty useless, as there is no standard (as far as I can tell. Maybe application/octet-stream?) format. The body format is defined by the Content-Type header. When using a HTML FORM element with method="POST", this is usually application/x-www-form-urlencoded. Another very common type is multipart/form-data if you use file uploads. But is could be anything, ranging from text/plain, over application/json or even a custom application/octet-stream.In any case, if a POST request is made with a Content-Type which cannot be handled by the application, it should return a 415 status-code.Most programming languages (and/or web-frameworks) offer a way to de/encode the message body from/to the most common types (like application/x-www-form-urlencoded, multipart/form-data or application/json). So that\'s easy. Custom types require potentially a bit more work.Using a standard HTML form encoded document as example, the application should perform the following steps:Again, languages like PHP, or web-frameworks for other popular languages will probably handle this for you. The exception to this is the 415 error. No framework can predict which content-types your application chooses to support and/or not support. This is up to you.A PUT request is pretty much handled in the exact same way as a POST request. The big difference is that a POST request is supposed to let the server decide how to (and if at all) create a new resource. Historically (from the now obsolete RFC2616 it was to create a new resource as a "subordinate" (child) of the URI where the request was sent to).A PUT request in contrast is supposed to "deposit" a resource exactly at that URI, and with exactly that content. No more, no less. The idea is that the client is responsible to craft the complete resource before "PUTting" it. The server should accept it as-is on the given URL.As a consequence, a POST request is usually not used to replace an existing resource. A PUT request can do both create and replace.There are also "path parameters" which can be used to send additional data to the remote, but they are so uncommon, that I won\'t go into too much detail here. But, for reference, here is an excerpt from the RFC:Aside from dot-segments in hierarchical paths, a path segment is considered\n  opaque by the generic syntax.  URI producing applications often use the\n  reserved characters allowed in a segment to delimit scheme-specific or\n  dereference-handler-specific subcomponents.  For example, the semicolon (";")\n  and equals ("=") reserved characters are often used to delimit parameters and\n  parameter values applicable to that segment.  The comma (",") reserved\n  character is often used for similar purposes.  For example, one URI producer\n  might use a segment such as "name;v=1.1" to indicate a reference to version\n  1.1 of "name", whereas another might use a segment such as "name,1.1" to\n  indicate the same.  Parameter types may be defined by scheme-specific\n  semantics, but in most cases the syntax of a parameter is specific to the\n  implementation of the URIs dereferencing algorithm.You cannot type it directly on the browser URL bar.You can see how POST data is sent on the Internet with Live HTTP Headers for example.\nResult will be something like thatWhere it says will be the post values.The default media type in a POST request is application/x-www-form-urlencoded. This is a format for encoding key-value pairs. The keys can be duplicate. Each key-value pair is separated by an & character, and each key is separated from its value by an = character.For example:Is encoded as:This is placed in the request body after the HTTP headers.Form values in HTTP POSTs are sent in the request body, in the same format as the querystring.For more information, see the spec.Some of the webservices require you to place request data and metadata separately. For example a remote function may expect that the signed metadata string is included in a URI, while the data is posted in a HTTP-body.The POST request may semantically look like this:This approach logically combines QueryString and Body-Post using a single Content-Type which is a "parsing-instruction" for a web-server.Please note: HTTP/1.1 is wrapped with the #32 (space) on the left and with #10 (Line feed) on the right.