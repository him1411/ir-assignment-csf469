In my model I have :Which works great for the first time the remote_image changes. How can I fetch a new image when someone has modified the remote_image on the alias? And secondly, is there a better way to cache a remote image?Though it\'s a bit late, let me throw out this solution for others that come across this post.  Essentially, you want to override the __init__ method of models.Model so that you keep a copy of the original value.  This makes it so that you don\'t have to do another DB lookup (which is always a good thing).I use following mixin:Usage:Please note that this solution works well in context of current request only. Thus it\'s suitable primarily for simple cases. In concurrent environment where multiple requests can manipulate the same model instance at the same time, you definitely need a different approach.And now for direct answer: one way to check if the value for the field has changed is to fetch original data from database before saving instance. Consider this example:The same thing applies when working with a form. You can detect it at the clean or save method of a ModelForm:Best way is with a pre_save signal. May not have been an option back in \'09 when this question was asked and answered, but anyone seeing this today should do it this way:Since Django 1.8 released, you can use from_db classmethod to cache old value of remote_image. Then in save method you can compare old and new value of field to check if the value has changed.Note that field change tracking is available in django-model-utils.https://django-model-utils.readthedocs.org/en/latest/index.htmlIf you are using a form, you can use Form\'s changed_data (docs):As of Django 1.8, there\'s the from_db method, as Serge mentions. In fact, the Django docs include this specific use case as an example:https://docs.djangoproject.com/en/dev/ref/models/instances/#customizing-model-loadingBelow is an example showing how to record the initial values of fields that are loaded from the databaseWhile this doesn\'t actually answer your question, I\'d go about this in a different way.Simply clear the remote_image field after successfully saving the local copy. Then in your save method you can always update the image whenever remote_image isn\'t empty.If you\'d like to keep a reference to the url, you could use an non-editable boolean field to handle the caching flag rather than remote_image field itself.I had this situation before my solution was to override the pre_save() method of the target field class it will be called only if the field has been changed \nuseful with FileField\nexample: \ndisadvantage:\nnot useful if you want to do any (post_save) operation like using the created object in some job (if certain field has changed)You can use django-model-changes to do this without an additional database lookup:improving @josh answer for all fields:just to clarify, the getattr works to get fields like person.name with strings (i.e. getattr(person, "name")The optimal solution is probably one that does not include an additional database read operation prior to saving the model instance, nor any further django-library. This is why laffuste\'s solutions is preferable. In the context of an admin site, one can simply override the save_model-method, and invoke the form\'s has_changed method there, just as in Sion\'s answer above. You arrive at something like this, drawing on Sion\'s example setting but using "changed_data" to get every possible change:https://docs.djangoproject.com/en/1.10/ref/contrib/admin/#django.contrib.admin.ModelAdmin.save_modelhttps://docs.djangoproject.com/en/1.10/ref/forms/api/#django.forms.Form.changed_dataAnother late answer, but if you\'re just trying to see if a new file has been uploaded to a file field, try this: (adapted from Christopher Adams\'s comment on the link http://zmsmith.com/2010/05/django-check-if-a-field-has-changed/ in zach\'s comment here)Updated link: https://web.archive.org/web/20130101010327/http://zmsmith.com:80/2010/05/django-check-if-a-field-has-changed/I have extended the mixin of @livskiy as follows:and the DictField is:it can be used by extending it in your models\na _dict field will be added when you sync/migrate and that field will store the state of your objectsThis works for me in Django 1.8I am a bit late to the party but I found this solution also:\nDjango Dirty FieldsUse the has_changed() method to check if the form data has been changed from the initial data.Ex:When the form is submitted, Django reconstruct it so that the comparison can be done.has_changed() will be True if the data from request.POST differs from what was provided in initial or False otherwise. The result is computed by calling Field.has_changed() for each field in the form.The attribute Form.changed_data will show which fields has been changed from initial and request.POST.You can also use instance=YourModel instead of inital=data if you already have an object.You can see more about here.as an extension of SmileyChris\' answer, you can add a datetime field to the model for last_updated, and set some sort of limit for the max age you\'ll let it get to before checking for a changeThe mixin from @ivanlivski is great. I\'ve extended it toThe updated code is available here:\nhttps://github.com/sknutsonsf/python-contrib/blob/master/src/django/utils/ModelDiffMixin.pyTo help people new to Python or Django, I\'ll give a more complete example.\nThis particular usage is to take a file from a data provider and ensure the records in the database reflect the file.  My model object:The class that loads the file has these methods:How about using David Cramer\'s solution:http://cramer.io/2010/12/06/tracking-changes-to-fields-in-django/I\'ve had success using it like this:A modification to @ivanperelivskiy\'s answer:This uses django 1.10\'s public method get_fields instead. This makes the code more future proof, but more importantly also includes foreign keys and fields where editable=False.For reference, here is the implementation of .fields