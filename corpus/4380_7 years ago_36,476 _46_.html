In perfect forwarding, std::forward is used to convert the named rvalue references t1 and t2 to unnamed rvalue references. What is the purpose of doing that? How would that affect the called function inner if we leave t1 & t2 as lvalues?You have to understand the forwarding problem. You can read the entire problem in detail, but I\'ll summarize.Basically, given the expression E(a, b, ... , c), we want the expression f(a, b, ... , c) to be equivalent. In C++03, this is impossible. There are many attempts, but they all fail in some regard.The simplest is to use an lvalue-reference:But this fails to handle temporary values: f(1, 2, 3);, as those cannot be bound to an lvalue-reference.The next attempt might be:Which fixes the above problem, but flips flops. It now fails to allow E to have non-const arguments:The third attempt accepts const-references, but then const_cast\'s the const away:This accepts all values, can pass on all values, but potentially leads to undefined behavior:A final solution handles everything correctly...at the cost of being impossible to maintain. You provide overloads of f, with all combinations of const and non-const:N arguments require 2N combinations, a nightmare. We\'d like to do this automatically.(This is effectively what we get the compiler to do for us in C++11.)In C++11, we get a chance to fix this. One solution modifies template deduction rules on existing types, but this potentially breaks a great deal of code. So we have to find another way.The solution is to instead use the newly added rvalue-references; we can introduce new rules when deducing rvalue-reference types and create any desired result. After all, we cannot possibly break code now.If given a reference to a reference (note reference is an encompassing term meaning both T& and T&&), we use the following rule to figure out the resulting type:"[given] a type TR that is a reference to a type T, an attempt to create the type \xe2\x80\x9clvalue reference to cv TR\xe2\x80\x9d creates the type \xe2\x80\x9clvalue reference to T\xe2\x80\x9d, while an attempt to create the type \xe2\x80\x9crvalue reference to cv TR\xe2\x80\x9d creates the type TR."Or in tabular form:Next, with template argument deduction: if an argument is an lvalue A, we supply the template argument with an lvalue reference to A. Otherwise, we deduce normally. This gives so-called universal references (the term forwarding reference is now the official one).Why is this useful? Because combined we maintain the ability to keep track of the value category of a type: if it was an lvalue, we have an lvalue-reference parameter, otherwise we have an rvalue-reference parameter.In code:The last thing is to "forward" the value category of the variable. Keep in mind, once inside the function the parameter could be passed as an lvalue to anything:That\'s no good. E needs to get the same kind of value-category that we got! The solution is this:What does this do? Consider we\'re inside the deduce function, and we\'ve been passed an lvalue. This means T is a A&, and so the target type for the static cast is A& &&, or just A&. Since x is already an A&, we do nothing and are left with an lvalue reference.When we\'ve been passed an rvalue, T is A, so the target type for the static cast is A&&. The cast results in an rvalue expression, which can no longer be passed to an lvalue reference. We\'ve maintained the value category of the parameter.Putting these together gives us "perfect forwarding": When f receives an lvalue, E gets an lvalue. When f receives an rvalue, E gets an rvalue. Perfect.And of course, we want to get rid of the ugly. static_cast<T&&> is cryptic and weird to remember; let\'s instead make a utility function called forward, which does the same thing:I think having a conceptual code implementing std::forward can add to the discussion. This is a slide from Scott Meyers talk An Effective C++11/14 SamplerFunction move in the code is std::move. There is a (working) implementation for it earlier in that talk. I found actual implementation of std::forward in libstdc++, in file move.h, but it is not at all instructive.From users perspective the meaning of it is that std::forward is a conditional cast to an rvalue. It can be useful if I am writing a function which expects either an lvalue or rvalue in a parameter and wants to pass it to another function as an rvalue only if it was passed in as an rvalue. If I did not wrap the parameter in std::forward, it would be always passed as a normal reference.Sure enough, it printsCode is based on an example from the previously mentioned talk. Slide 10, at about 15:00 from the start.In perfect forwarding, std::forward is used to convert the named rvalue reference t1 and t2 to unnamed rvalue reference. What is the purpose of doing that? How would that effect the called function inner if we leave t1 & t2 as lvalue?If you use a named rvalue reference in an expression it is actually an lvalue (because you refer to the object by name). Consider the following example:Now, if we call outer like thiswe would like 17 and 29 to be forwarded to #2 because 17 and 29 are integer literals and as such rvalues. But since t1 and t2 in the expression inner(t1,t2); are lvalues, you\'d be invoking #1 instead of #2. That\'s why we need to turn the references back into unnamed references with std::forward. So, t1 in outer is always an lvalue expression while forward<T1>(t1) may be an rvalue expression depending on T1. The latter is only an lvalue expression if T1 is an lvalue reference. And T1 is only deduced to be an lvalue reference in case the first argument to outer was an lvalue expression.How would that affect the called function inner if we leave t1 & t2 as lvalue?If, after instantiating, T1 is of type char, and T2 is of a class, you want to pass t1 per copy and t2 per const reference. Well, unless inner() takes them per non-const reference, that is, in which case you want to do so, too. Try to write a set of outer() functions which implement this without rvalue references, deducing the right way to pass the arguments from inner()\'s type. I think you\'ll need something 2^2 of them, pretty hefty template-meta stuff to deduce the arguments, and a lot of time to get this right for all cases.  And then someone comes along with an inner() that takes arguments per pointer. I think that now makes 3^2. (Or 4^2. Hell, I can\'t be bothered to try to think whether const pointer would make a difference.)  And then imagine you want to do this for a five parameters. Or seven. Now you know why some bright minds came up with "perfect forwarding": It makes the compiler do all this for you. A point that hasn\'t been made crystal clear is that static_cast<T&&> handles const T& properly too.\nProgram:Produces:Note that \'f\' has to be a template function.  If it\'s just defined as \'void f(int&& a)\' this doesn\'t work.