I\'m curious about this code:gives me an output of 1952805748. My question: Is the output an address in memory or something?It\'s a multi-character literal. 1952805748 is 0x74657374, which decomposes asEdit:C++ standard, \xc2\xa72.14.3/1 - Character literals(...) An ordinary character literal that contains more than\n  one c-char is a multicharacter literal . A multicharacter literal has type int and implementation-de\xef\xac\x81ned\n  value.No, it\'s not an address. It\'s the so-called multibyte character.Typically, it\'s the ASCII values of the four characters combined.So 0x74657374 is 1952805748.But it can also be 0x74736574 on some other compiler. The C and C++ standards both say the value of multibyte characters is implementation defined. So generally its use is strongly discouraged.An ordinary character literal that contains more than one c-char is a multicharacter literal. A multicharacter literal has type int and implementation-de\xef\xac\x81ned value.Implementation defined behavior is required to be documented by\nthe implementation. for example in gcc you can find it here The compiler values a multi-character character constant\na character at a time, shifting the previous value left\nby the number of bits per target character, and then\nor-ing in the bit-pattern of the new character truncated\nto the width of a target character. The final\nbit-pattern is given type int, and is therefore signed,\nregardless of whether single characters are signed or\nnot. Check the explanation in this page for more details They\'re really just ints.  They\'re used extensively in the Core Audio API enum\'s for example, in the CoreAudioTypes.h header file,There\'s a lot of chatter about this not being "platform independent", but when you\'re using an api that\'s made for a specific platform, who cares about portability.  Checking for equality on the same platform will never fail.  These enum\'d values are easier to read and they actually contain their identity in their value, which is pretty nice.What I\'ve tried to do below is wrap a multibyte character literal up so it can be printed (on Mac this works).  The strange thing is, if you don\'t use up all 4 characters, the result becomes wrong below..This kind of feature is really good when you are building parsers.\nConsider this:This code will likely only work on specific endianess and might break across different compilers