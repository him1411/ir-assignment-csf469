This documentation answers my question very poorly. I didn\'t understand those explanations. Can someone say in simpler words? Maybe with examples if it\'s hard to choose simple words?EDIT also added peerDependencies, which is closely related and might cause confusion.Summary of important behavior differences:dependencies are installed on both:devDependencies are:peerDependencies:Transitivity (mentioned by Ben Hutchison):dependencies are installed transitively: if A requires B, and B requires C, then C gets installed, otherwise B could not work, and neither would A. devDependencies are not installed transitively. E.g. we don\'t need to test B to test A, so B\'s testing dependencies can be left out.Related options not discussed here:dependencies are required to run, devDependencies only to develop, e.g.: unit tests, Coffeescript to Javascript transpilation, minification, ...If you are going to develop a package, you download it (e.g. via git clone), go to its root which contains package.json, and run:Since you have the actual source, it is clear that you want to develop it, so by default both dependencies (since you must of course run to develop) and devDependency dependencies are also installed.If however you are only an end user who just wants to install a package to use it, you will do from any directory:In that case, you normally don\'t want the development dependencies, so you just get what is needed to use the package: dependencies.If you really want to install development packages in that case, you can set the dev config option to true, possibly from the command line as:The option is false by default since this is a much less common case. (tested before 3.0)Source: https://nodejs.org/en/blog/npm/peer-dependencies/ -http://blog.nodejs.org/2013/02/07/peer-dependencies/With regular dependencies, you can have multiple versions of the dependency: it\'s simply installed inside the node_modules of the dependency.E.g. if dependency1 and dependency2 both depend on dependency3 at different versions the project tree will look like:Plugins however are packages that normally don\'t require the other package, which is called the host in this context. Instead:E.g. if dependency1 and dependency2 peer depend on dependency3, the project tree will look like:This happens even though you never mention dependency3 in your package.json file.I think this is an instance of the Inversion of Control design pattern.A prototypical example of peer dependencies is Grunt, the host, and its plugins.For example, on a Grunt plugin like https://github.com/gruntjs/grunt-contrib-uglify, you will see that:Then, when the user will use a plugin, he will implicitly require the plugin from the Gruntfile by adding a grunt.loadNpmTasks(\'grunt-contrib-uglify\') line, but it\'s grunt that the user will call directly.This would not work then if each plugin required a different Grunt version.I think the doc answers the question quite well, maybe you are not just familiar enough with node / other package managers. I probably only understand it because I know a bit about Ruby bundler.The key line is:These things will be installed when doing npm link or npm install from the root of a package, and can be managed like any other npm configuration param. See npm-config(7) for more on the topic.And then under npm-config(7) find dev:If you do not want to install devDependencies you simply can use npm install --production As an example, mocha would normally be a devDependency, since testing isn\'t necessary in production, while express would be a dependency. To save a package to package.json as dev dependencies: When you run npm install it will install both devDependencies and dependencies, to avoid install devDependencies run:There are some modules and packages only necessary for development, which are not needed in production. Like it says it in the documentation:If someone is planning on downloading and using your module in their program, then they probably don\'t want or need to download and build the external test or documentation framework that you use. In this case, it\'s best to list these additional items in a devDependencies hash.dependencies\nDependencies that your project needs to run, like a library that provides functions that you call from your code.\nThey are installed transitively (if A depends on B depends on C, npm install on A will install B and C).\nExample: lodash: your project calls some lodash functions.devDependencies\nDependencies you only need during development or releasing, like compilers that take your code and compile it into javascript, test frameworks or documentation generators.\nThey are not installed transitively (if A depends on B dev-depends on C, npm install on A will install B only).\nExample: grunt: your project uses grunt to build itself.peerDependencies\nDependencies that your project hooks into, or modifies, in the parent project, usually a plugin for some other library or tool. It is just intended to be a check, making sure that the parent project (project that will depend on your project) has a dependency on the project you hook into. So if you make a plugin C that adds functionality to library B, then someone making a project A will need to have a dependency on B if they have a dependency on C.\nThey are not installed (unless npm < 3), they are only checked for.\nExample: grunt: your project adds functionality to grunt and can only be used on projects that use grunt.This documentation explains peer dependencies really well: https://nodejs.org/en/blog/npm/peer-dependencies/ Also, the npm documentation has been improved over time, and now has better explanations of the different types of dependencies: https://github.com/npm/npm/blob/master/doc/files/package.json.md#devdependencies