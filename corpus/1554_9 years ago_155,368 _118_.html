I have heard that the Liskov Substitution  Principle (LSP) is a fundamental principle of object oriented design. What is it and what are some examples of its use?A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn\'t quite work in code.In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The "is a" makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behavior. Imagine you had SetWidth and SetHeight methods on your Rectangle base class; this seems perfectly logical. However if your Rectangle reference pointed to a Square, then SetWidth and SetHeight doesn\'t make sense because setting one would change the other to match it. In this case Square fails the Liskov Substitution Test with Rectangle and the abstraction of having Square inherit from Rectangle is a bad one.Y\'all should check out the other priceless SOLID Principles Motivational Posters.The Liskov Substitution Principle (LSP, lsp) is a concept in Object Oriented Programming that states:Functions that use pointers or\n  references to base classes must be\n  able to use objects of derived classes\n  without knowing it.At its heart LSP is about interfaces and contracts as well as how to decide when to extend a class vs. use another strategy such as composition to achieve your goal.The most effective way I have seen to illustrate this point was in Head First OOA&D. They present a scenario where you are a developer on a project to build a framework for strategy games.They present a class that represents a board that looks like this:All of the methods take X and Y coordinates as parameters to locate the tile position in the two-dimensional array of Tiles. This will allow a game developer to manage units in the board during the course of the game.The book goes on to change the requirements to say that the game frame work must also support 3D game boards to accommodate games that have flight. So a ThreeDBoard class is introduced that extends Board.At first glance this seems like a good decision. Board provides both the Height and Width properties and ThreeDBoard provides the Z axis.Where it breaks down is when you look at all the other members inherited from Board. The methods for AddUnit, GetTile, GetUnits and so on, all take both X and Y parameters in the Board class but the ThreeDBoard needs a Z parameter as well.So you must implement those methods again with a Z parameter. The Z parameter has no context to the Board class and the inherited methods from the Board class lose their meaning. A unit of code attempting to use the ThreeDBoard class as its base class Board would be very out of luck.Maybe we should find another approach. Instead of extending Board, ThreeDBoard should be composed of Board objects. One Board object per unit of the Z axis.This allows us to use good object oriented principles like encapsulation and reuse and doesn\xe2\x80\x99t violate LSP.LSP concerns invariants. Your board example is broken at the outset because the interfaces simply don\'t match.A better example would be the following (implementations omitted):Now we have a problem although the interface matches. The reason is that we have violated invariants stemming from the mathematical definition of squares and rectangles. The way getters and setters work, a Rectangle should satisfy the following invariant:However, this invariant must be violated by a correct implementation of Square, therefore it is not a valid substitute of Rectangle.Robert Martin has an excellent paper on the Liskov Substitution Principle. It discusses subtle and not-so-subtle ways in which the principle may be violated.Some relevant parts of the paper (note that the second example is heavily condensed):One of the most glaring violations of this principle is the use of C++\n  Run-Time Type Information (RTTI) to select a function based upon the\n  type of an object. i.e.:Clearly the DrawShape function is badly formed. It must know about\n  every possible derivative of the Shape class, and it must be changed\n  whenever new derivatives of Shape are created. Indeed, many view the structure of this function as anathema to Object Oriented Design.However, there are other, far more subtle, ways of violating the LSP.\n  Consider an application which uses the Rectangle class as described\n  below:[...] Imagine that one day the users demand the ability to manipulate\n  squares in addition to rectangles. [...]Clearly, a square is a rectangle for all normal intents and purposes.\n  Since the ISA relationship holds, it is logical to model the Square\n  class as being derived from Rectangle. [...]Square will inherit the SetWidth and SetHeight functions. These\n  functions are utterly inappropriate for a Square, since the width and\n  height of a square are identical. This should be a significant clue\n  that there is a problem with the design. However, there is a way to\n  sidestep the problem. We could override SetWidth and SetHeight [...]But consider the following function:If we pass a reference to a Square object into this function, the\n  Square object will be corrupted because the height won\xe2\x80\x99t be changed.\n  This is a clear violation of LSP. The function does not work for\n  derivatives of its arguments. [...]LSP is necessary where some code thinks it is calling the methods of a type T, and may unknowingly call the methods of a type S, where S extends T (i.e. S inherits, derives from, or is a subtype of, the supertype T).For example, this occurs where a function with an input parameter of type T, is called (i.e. invoked) with an argument value of type S. Or, where an identifier of type T, is  assigned a value of type S.LSP requires the expectations (i.e. invariants) for methods of type T (e.g. Rectangle), not be violated when the methods of type S (e.g. Square) are called instead.Even a type with immutable fields still has invariants, e.g. the immutable Rectangle setters expect dimensions to be independently modified, but the immutable Square setters violate this expectation.LSP requires that each method of the subtype S must have contravariant input parameter(s) and a covariant output.Contravariant means the variance is contrary to the direction of the inheritance, i.e. the type Si, of each input parameter of each method of the subtype S, must be the same or a supertype of the type Ti of the corresponding input parameter of the corresponding method of the supertype T.Covariance means the variance is in the same direction of the inheritance, i.e. the type So, of the output of each method of the subtype S, must be the same or a subtype of the type To of the corresponding output of the corresponding method of the supertype T.This is because if the caller thinks it has a type T, thinks it is calling a method of T, then it supplies argument(s) of type Ti and assigns the output to the type To. When it is actually calling the corresponding method of S, then each Ti input argument is assigned to a Si input parameter, and the So output is assigned to the type To. Thus if Si were not contravariant w.r.t. to Ti, then a subtype Xi\xe2\x80\x94which would not be a subtype of Si\xe2\x80\x94could be assigned to Ti.Additionally, for languages (e.g. Scala or Ceylon) which have definition-site variance annotations on type polymorphism parameters (i.e. generics), the co- or contra- direction of the variance annotation for each type parameter of the type T must be opposite or same direction respectively to every input parameter or output (of every method of T) that has the type of the type parameter.Additionally, for each input parameter or output that has a function type, the variance direction required is reversed. This rule is applied recursively.Subtyping is appropriate where the invariants can be enumerated.There is much ongoing research on how to model invariants, so that they are enforced by the compiler.Typestate (see page 3) declares and enforces state invariants orthogonal to type. Alternatively, invariants can be enforced by converting assertions to types. For example, to assert that a file is open before closing it, then File.open() could return an OpenFile type, which contains a close() method that is not available in File. A tic-tac-toe API can be another example of employing typing to enforce invariants at compile-time. The type system may even be Turing-complete, e.g. Scala. Dependently-typed languages and theorem provers formalize the models of higher-order typing. Because of the need for semantics to abstract over extension, I expect that employing typing to model invariants, i.e. unified higher-order denotational semantics, is superior to the Typestate. \xe2\x80\x98Extension\xe2\x80\x99 means the unbounded, permuted composition of uncoordinated, modular development. Because it seems to me to be the antithesis of unification and thus degrees-of-freedom, to have two mutually-dependent models (e.g. types and Typestate) for expressing the shared semantics, which can\'t be unified with each other for extensible composition. For example, Expression Problem-like extension was unified in the subtyping, function overloading, and parametric typing domains.My theoretical position is that for knowledge to exist (see section \xe2\x80\x9cCentralization is blind and unfit\xe2\x80\x9d), there will never be a general model that can enforce 100% coverage of all possible invariants in a Turing-complete computer language. For knowledge to exist, unexpected possibilities much exist, i.e. disorder and entropy must always be increasing. This is the entropic force. To prove all possible computations of a potential extension, is to compute a priori all possible extension.This is why the Halting Theorem exists, i.e. it is undecidable whether every possible program in a Turing-complete programming language terminates. It can be proven that some specific program terminates (one which all possibilities have been defined and computed). But it is impossible to prove that all possible extension of that program terminates, unless the possibilities for extension of that program is not Turing complete (e.g. via dependent-typing). Since the fundamental requirement for Turing-completeness is unbounded recursion, it is intuitive to understand how G\xc3\xb6del\'s incompleteness theorems and Russell\'s paradox apply to extension.An interpretation of these theorems incorporates them in a generalized conceptual understanding of the entropic force:Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.When I first read about LSP, I assumed that this was meant in a very strict sense, essentially equating it to interface implementation and type-safe casting.  Which would mean that LSP is either ensured or not by the language itself.  For example, in this strict sense, ThreeDBoard is certainly substitutable for Board, as far as the compiler is concerned.After reading up more on the concept though I found that LSP is generally interpreted more broadly than that.In short, what it means for client code to "know" that the object behind the pointer is of a derived type rather than the pointer type is not restricted to type-safety.  Adherence to LSP is also testable through probing the objects actual behavior.  That is, examining the impact of an object\'s state and method arguments on the results of the method calls, or the types of exceptions thrown from the object.Going back to the example again, in theory the Board methods can be made to work just fine on ThreeDBoard.  In practice however, it will be very difficult to prevent differences in behavior that client may not handle properly, without hobbling the functionality that ThreeDBoard is intended to add.With this knowledge in hand, evaluating LSP adherence can be a great tool in determining when composition is the more appropriate mechanism for extending existing functionality, rather than inheritance.The LSP is a rule about the contract of the clases: if a base class satisfies a contract, then by the LSP derived classes must also satisfy that contract.In Pseudo-pythonsatisfies LSP if every time you call Foo on a Derived object, it gives exactly the same results as calling Foo on a Base object, as long as arg is the same.Strangely, no one has posted the original paper that described lsp. It is not an easy read as Robert Martin\'s one, but worth it.An important example of the use of LSP is in software testing.If I have a class A that is an LSP-compliant subclass of B, then I can reuse the test suite of B to test A.To fully test subclass A, I probably need to add a few more test cases, but at the minimum I can reuse all of superclass B\'s test cases. A way to realize is this by building what McGregor calls a "Parallel hierarchy for testing": My ATest class will inherit from BTest. Some form of injection is then needed to ensure the test case works with objects of type A rather than of type B (a simple template method pattern will do).Note that reusing the super-test suite for all subclass implementations is in fact a way to test that these subclass implementations are LSP-compliant. Thus, one can also argue that one should run the superclass test suite in the context of any subclass.See also the answer to the Stackoverflow question "Can I implement a series of reusable tests to test an interface\'s implementation?"There is a check list to determine whether or not you are violating Liskov. Check list:History Constraint: When overriding a method you are not allowed to modify an un-modifiable property in the base class. Take a look at these code and you can see Name is defined to be un-modifiable (private set) but SubType introduces new method that allows modifying it (through reflection):There are 2 others items: Contravariance of method arguments and Covariance of return types. But it is not possible in C# (I\'m a C# developer) so I dont care about them.Reference: I guess everyone kind of covered what LSP is technically: You basically want to be able to abstract away from subtype details and use supertypes safely. So Liskov has 3 underlying rules: Signature Rule : There should be a valid implementation of every operation of the supertype in the subtype syntactically. Something a compiler will be able to check for you. There is a little rule about throwing fewer exceptions and being at least as accessible as the supertype methods. Methods Rule: The implementation of those operations is semantically sound.Properties Rule : This goes beyond individual function calls. All these properties need to be preserved and the extra subtype functionality shouldn\'t violate supertype properties. If these three things are taken care of , you have abstracted away from the underlying stuff and you are writing loosely coupled code. Source: Program Development in Java - Barbara Liskov Substitutability is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type Slet\'s do a simple example in Java:The duck can fly because of its a bird, But what about this:Ostrich is a bird, But it can\'t fly, Ostrich class is a subtype of class Bird, But it can\'t use the fly method, that means that we breaking LSP principle.This formulation of the LSP is way too strong:If for each object o1 of type S there is an object o2 of type T such that for all programs P de\xef\xac\x81ned in terms of T, the behavior of P is unchanged when o1 is substituted for o2, then S is a subtype of T.Which basically means that S is another, completely encapsulated implementation of the exact same thing as T. And I could be bold and decide that performance is part of the behavior of P...So, basically, any use of late-binding violates the LSP. It\'s the whole point of OO to to obtain a different behavior when we substitute an object of one kind for one of another kind!The formulation cited by wikipedia is better since the property depends on the context and does not necessarily include the whole behavior of the program.Some addendum: I wonder why didn\'t anybody write about the Invariant , preconditions and post conditions of the base class that must be obeyed by the derived classes.\nFor a derived class D to be completely sustitutable by the Base class B, class D must obey certain conditions:So the derived must be aware of the above three conditions imposed by the base class. Hence, the rules of subtyping are pre-decided. Which means, \'IS A\' relationship shall be obeyed only when certain rules are obeyed by the subtype. These rules, in the form of invariants, precoditions and postcondition, should be decided by a formal \'design contract\'.Further discussions on this available at my blog: Liskov Substitution principleA square is a rectangle where the width equals the height. If the square sets two different sizes for the width and height it violates the square invariant. This is worked around by introducing side effects. But if the rectangle had a setSize(height, width) with precondition 0 < height and 0 < width. The derived subtype method requires height == width; a stronger precondition (and that violates lsp). This shows that though square is a rectangle it is not a valid subtype because the precondition is strengthened. The work around (in general a bad thing) cause a side effect and this weakens the post condition (which violates lsp). setWidth on the base has post condition 0 < width. The derived weakens it with height == width.Therefore a resizable square is not a resizable rectangle.Would implementing ThreeDBoard in terms of an array of Board be that useful?Perhaps you may want to treat slices of ThreeDBoard in various planes as a Board. In that case you may want to abstract out an interface (or abstract class) for Board to allow for multiple implementations.In terms of external interface, you might want to factor out a Board interface for both TwoDBoard and ThreeDBoard (although none of the above methods fit).I encourage you to read the article: Violating Liskov Substitution Principle (LSP).You can find there an explanation what is the Liskov Substitution Principle, general clues helping you to guess if you have already violated it and an example of approach that will help you to make your class hierarchy be more safe.The clearest explanation for LSP I found so far has been "The Liskov Substitution Principle says that the object of a derived class should be able to replace an object of the base class without bringing any errors in the system or modifying the behavior of the base class" from here. The article gives code example for violating LSP and fixing it.LISKOV SUBSTITUTION PRINCIPLE (From Mark Seemann book) states that we should be able to replace one implementation of an interface with another without breaking either client or implementation.It\xe2\x80\x99s this principle that enables to address requirements that         occur in the future, even if we can\xe2\x80\x99t foresee them today.If we unplug the computer from the wall (Implementation), neither the wall outlet (Interface) nor the computer (Client) breaks down (in fact, if it\xe2\x80\x99s a laptop computer, it can even run on its batteries for a period of time). With software, however, a client often expects a service to be available.         If the service was removed, we get a NullReferenceException. To deal with this type of situation, we can create an implementation of an interface that does \xe2\x80\x9cnothing.\xe2\x80\x9d This is a design pattern known as Null Object,[4] and it corresponds roughly to unplugging the computer from the wall. Because we\xe2\x80\x99re using loose coupling, we can replace a real implementation with something that does         nothing without causing trouble.The Liskov Substitution Principal states that Subtypes must be substitutable for their base types.Child class must not:I would like to add code example to solve Liskov Substitution PrincipalThe Problem isIn mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The "is a" makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behavior. Imagine you had SetWidth and SetHeight methods on your Rectangle base class; this seems perfectly logical. However if your Rectangle reference pointed to a Square, then SetWidth and SetHeight doesn\'t make sense because setting one would change the other to match it. In this case Square fails the Liskov Substitution Test with Rectangle and the abstraction of having Square inherit from Rectangle is a bad one.In Order to solve it we have two approachesFirst approach using If conditionThis approach solves Liskov Substitution Principal but violates Open closed principle Second and best approach by using abstract and overrideThe benefit of following Liskov Substitution Principal is it allows for proper use of polymorphism and produces more maintainable code.In a very simple sentence, we can say:The child class must not violate its base class characteristics. It must be capable with it. We can say it\'s same as subtyping.Likov\'s Substitution Principle states that if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module.Intent - Derived types must be completely substitute able for their base types.Example - Co-variant return types in java.