I have a file, foo.txt, containing the following lines:I want a simple command that results in the contents of foo.txt being:Using GNU sed:The -i option does not exist in GNU sed versions older than 3.95, so you have to use it as a filter with a temporary file:Of course, in that case you could also use head -n -1 instead of sed.This is by far the fastest and simplest solution, especially on big files: if You want to delete the top line use this:which means output lines starting at line 2.Do not use sed for deleting lines from the top or bottom of a file -- it\'s very very slow if the file is large. I had trouble with all the answers here because I was working with a HUGE file (~300Gb) and none of the solutions scaled. Here\'s my solution:In words: Find out the length of the file you want to end up with (length of file minus length of length of its last line, using bc) and, set that position to be the end of the file (by dding one byte of  /dev/null onto it). This is fast because tail starts reading from the end, and dd will overwrite the file in place rather than copy (and parse) every line of the file, which is what the other solutions do.NOTE: This removes the line from the file in place! Make a backup or test on a dummy file before trying it out on your own file!To remove the last line from a file without reading the whole file or rewriting anything, you can useTo remove the last line and also print it on stdout ("pop" it), you can combine that command with tee:These commands can efficiently process a very large file.  This is similar to, and inspired by, Yossi\'s answer, but it avoids using a few extra functions.  If you\'re going to use these repeatedly and want error handling and some other features, you can use the poptail command here:\nhttps://github.com/donm/evenmoreutilsMac Usersif you only want the last line deleted output without changing the file itself dosed -e \'$ d\' foo.txtif you want to delete the last line of the input file itself dosed -i \'\' -e \'$ d\' foo.txtEssentially, this code says the following:For each line after the first, print the buffered linefor each line, reset the bufferThe buffer is lagged by one line, hence you end up printing lines 1 to n-1On Mac, head -n -1 wont work. And, I was trying to find a simple solution [ without worrying about processing time ] to solve this problem only using "head" and/or "tail" commands.I tried the following sequence of commands and was happy that I could solve it just using "tail" command [ with the options available on Mac ]. So, if you are on Mac, and want to use only "tail" to solve this problem, you can use this command :cat file.txt | tail -r | tail -n +2 | tail -r1> tail -r : simply reverses the order of lines in its input2> tail -n +2 : this prints all the lines starting from the second line in its inputThis snippet does the trick.Ruby(1.9+)