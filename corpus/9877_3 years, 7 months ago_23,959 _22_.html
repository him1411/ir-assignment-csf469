As you may know they are planning to include new Symbol primitive type in ECMAScript 6 (not to mention some other crazy stuff). I always thought that the :symbol notion in Ruby is needless; we could easily use plain strings instead, like we do in JavaScript. And now they decide to complicate things in JS with that. I don\'t understand the motivation. Could someone explain to me whether we really need symbols in JavaScript?UPDATE: Recently a brilliant article from Mozilla came up. Read it if you\'re curious.Enabling private properties, like kangax describes in his answer, was indeed the original motivation for introducing symbols into JavaScript.Unfortunately, however, they ended up being severely downgraded, and not private after all, because you can find them via reflection. Specifically, via the Object.getOwnPropertySymbols method and through proxies.They are now known as unique symbols, and their only use is to avoid name clashes between properties. For example, EcmaScript itself can now introduce extension hooks via certain methods you can put on objects (e.g. to define their iteration protocol) without running the risk of clashing with user names.Whether that is strong enough a motivation to add symbols to the language is debatable.Symbols do not guarantee true privacy but can be used to separate public and internal properties of objects. Let\'s take an example where we can use Symbol for having private properties.Let\'s take an example where a property of an object is not private.Above, the Pet class property type is not private. To make it private we have to create a closure. The below example illustrates how we can make type private using a closure.Disadvantage of above approach: We are introducing an extra closure for each Pet instance created, which can harm performance.Now we introduce Symbol. This can help us make a property private without using extra unnecessary closures. Code example below:Here is how I see it. Symbols provide \'an extra level of privacy\', by preventing the keys/properties of an object from being exposed through some popular methods such as Object.keys() and JSON.stringify().Although given an object per se, such properties can still be exposed through reflection, proxy, Object.getOwnPropertySymbols() etc., there is no natural means to access them through a few direct methods, which may be sufficient sometimes from an OOP perspective.Symbols are a new, special kind of object that can be used as a unique property name in objects. Using symbols instead of strings allows different modules to create properties that don\'t conflict with one another. Symbols can also be made private, so that their properties can\'t be accessed by anyone who doesn\'t already have direct access to the symbol.Symbols are a new primitive. Just like the Number, String, and Boolean primitives, Symbols have a Symbol function which can be used to create them. Unlike the other primitives, Symbols do not have a literal syntax (e.g how Strings have \'\') - the only way to create them is with the Symbol constructor in the following way:In reality, Symbols are just a slightly different way to attach properties to an Object - you could easily provide the well-known symbols as standard methods, just like Object.prototype.hasOwnProperty which appears in everything that inherits from Object.Here are some of the benefits of the Symbol primitive type.Symbols can be given a description, which is really just used for debugging to make life a little easier when logging them to a console.This is where Symbols get really interesting. They are heavily intertwined with Objects. Symbols can be assigned as keys to Objects (kind of like String keys), meaning you can assign an unlimited number of unique Symbols to an object and be guaranteed that these will never conflict with String keys, or other unique Symbols.Let\xe2\x80\x99s assume you have a logging library, which includes multiple log levels such as logger.levels.DEBUG, logger.levels.INFO, logger.levels.WARN and so on. In ES5 code you\xe2\x80\x99d like make these Strings (so logger.levels.DEBUG === \'debug\'), or numbers (logger.levels.DEBUG === 10). Both of these aren\xe2\x80\x99t ideal as those values aren\xe2\x80\x99t unique values, but Symbols are! So logger.levels simply becomes:Read more in this great article.