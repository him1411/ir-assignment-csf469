This is what I normally do in order to ascertain that the input is a list/tuple - but not a str. Because many times I stumbled upon bugs where a function passes a str object by mistake, and the target function does for x in lst assuming that lst is actually a list or tuple.My question is: is there a better way of achieving this?I thinkIs actually what you want, otherwise you\'ll miss out on a lot of things which act like lists, but aren\'t subclasses of list or tuple.Remember that in Python we want to use "duck typing".  So, anything that acts like a list can be treated as a list.  So, don\'t check for the type of a list, just see if it acts like a list.But strings act like a list too, and often that is not what we want.  There are times when it is even a problem!  So, check explicitly for a string, but then use duck typing.Here is a function I wrote for fun.  It is a special version of repr() that prints any sequence in angle brackets (\'<\', \'>\').This is clean and elegant, overall.  But what\'s that isinstance() check doing there?  That\'s kind of a hack.  But it is essential.This function calls itself recursively on anything that acts like a list.  If we didn\'t handle the string specially, then it would be treated like a list, and split up one character at a time.  But then the recursive call would try to treat each character as a list -- and it would work!  Even a one-character string works as a list!  The function would keep on calling itself recursively until stack overflow.Functions like this one, that depend on each recursive call breaking down the work to be done, have to special-case strings--because you can\'t break down a string below the level of a one-character string, and even a one-character string acts like a list.Note: the try/except is the cleanest way to express our intentions.  But if this code were somehow time-critical, we might want to replace it with some sort of test to see if arg is a sequence.  Rather than testing the type, we should probably test behaviors.  If it has a .strip() method, it\'s a string, so don\'t consider it a sequence; otherwise, if it is indexable or iterable, it\'s a sequence:EDIT: I originally wrote the above with a check for __getslice__() but I noticed that in the collections module documentation, the interesting method is __getitem__(); this makes sense, that\'s how you index an object.  That seems more fundamental than __getslice__() so I changed the above.For Python 3, note per the docs:Changed in version 3.3: Moved Collections Abstract Base Classes to the collections.abc module. For backwards compatibility, they continue to be visible in this module as well.Python with PHP flavor:Generally speaking, the fact that a function which iterates over an object works on strings as well as tuples and lists is more feature than bug.  You certainly can use isinstance or duck typing to check an argument, but why should you?That sounds like a rhetorical question, but it isn\'t.  The answer to "why should I check the argument\'s type?" is probably going to suggest a solution to the real problem, not the perceived problem.  Why is it a bug when a string is passed to the function?  Also:  if it\'s a bug when a string is passed to this function, is it also a bug if some other non-list/tuple iterable is passed to it?  Why, or why not?I think that the most common answer to the question is likely to be that developers who write f("abc") are expecting the function to behave as though they\'d written f(["abc"]).  There are probably circumstances where it makes more sense to protect developers from themselves than it does to support the use case of iterating across the characters in a string.  But I\'d think long and hard about it first.The str object doesn\'t have an __iter__ attributeso you can do a checkand this will also raise a nice AssertionError for any other non-iterable object too.Edit:\nAs Tim mentions in the comments, this will only work in python 2.x, not 3.xThis is not intended to directly answer the OP, but I wanted to share some related ideas.I was very interested in @steveha answer above, which seemed to give an example where duck typing seems to break. On second thought, however, his example suggests that duck typing is hard to conform to, but it does not suggest that str deserves any special handling.After all, a non-str type (e.g., a user-defined type that maintains some complicated recursive structures) may cause @steveha srepr function to cause an infinite recursion. While this is admittedly rather unlikely, we can\'t ignore this possibility. Therefore, rather than special-casing str in srepr, we should clarify what we want srepr to do when an infinite recursion results.It may seem that one reasonable approach is to simply break the recursion in srepr the moment list(arg) == [arg]. This would, in fact, completely solve the problem with str, without any isinstance.However, a really complicated recursive structure may cause an infinite loop where list(arg) == [arg] never happens. Therefore, while the above check is useful, it\'s not sufficient. We need something like a hard limit on the recursion depth.My point is that if you plan to handle arbitrary argument types, handling str via duck typing is far, far easier than handling the more general types you may (theoretically) encounter. So if you feel the need to exclude str instances, you should instead demand that the argument is an instance of one of the few types that you explicitly specify.I do this in my testcases.Untested on generators, I think you are left at the next \'yield\' if passed in a generator, which may screw things up downstream.  But then again, this is a \'unittest\'I find such a function named is_sequence in tensorflow. And I have verified that it meets your needs. Just do thisI tend to do this (if I really, really had to):If you have pandas already available you can just do this:This is what I do to ensure a list.