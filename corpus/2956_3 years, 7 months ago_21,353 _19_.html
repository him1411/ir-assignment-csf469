From the docs for GHC 7.6:[Y]ou often don\'t even need the SPECIALIZE pragma in the first place. When compiling a module M, GHC\'s optimiser (with -O) automatically considers each top-level overloaded function declared in M, and specialises it for the different types at which it is called in M. The optimiser also considers each imported INLINABLE overloaded function, and specialises it for the different types at which it is called in M.andMoreover, given a SPECIALIZE pragma for a function f, GHC will automatically create specialisations for any type-class-overloaded functions called by f, if they are in the same module as the SPECIALIZE pragma, or if they are INLINABLE; and so on, transitively.So GHC should automatically specialize some/most/all(?) functions marked INLINABLE without a pragma, and if I use an explicit pragma, the specialization is transitive. My question is: \nis the auto-specialization transitive?Specifically, here\'s a small example:Main.hs:Foo.hs:GHC specializes the call to plus, but does not specialize (+) in the Qux Num instance which kills performance. However, an explicit pragma results in transitive specialization as the docs indicate, so (+) is specialized and the code is 30x faster (both compiled with -O2). Is this expected behavior? Should I only expect (+) to be specialized transitively with an explicit pragma?UPDATEThe docs for 7.8.2 haven\'t changed, and the behavior is the same, so this question is still relevant.The question\'s key points, as I understand them, are the following: AFAIK, the answers are No, mostly yes but there are other means,  and No. Code inlining and type application specialization is a trade-off between speed (execution time) and code size. The default level gets some speedup without bloating the code. Choosing a more exhaustive level is left to the programmer\'s discretion via  SPECIALISE pragma.The optimiser also considers each imported INLINABLE overloaded function, and specialises it for the different types at which it is called in M.Suppose f is a function whose type includes a type variable a constrained by a type class C a. GHC by default specializes f with respect to a type application (substituting a for t) if f is called with that type application in the source code of (a) any function in the same module, or (b) if f is marked INLINABLE, then any other module that  imports f from B. Thus, auto-specialization is not transitive, it only touches INLINABLE functions imported and called for in the source code of A.In your example, if you rewrite the instance of Num as follows: 