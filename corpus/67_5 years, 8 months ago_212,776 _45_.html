Until today, I thought that for example:is just a shortcut for:But what if we try this:Then i = i + j; will not compile but i += j; will compile fine.Does it mean that in fact i += j; is a shortcut for something like this\ni = (type of i) (i + j)?As always with these questions, the JLS holds the answer. In this case \xc2\xa715.26.2 Compound Assignment Operators. An extract:A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T)((E1) op (E2)), where T is the type of E1, except that E1 is evaluated only once.An example cited from \xc2\xa715.26.2[...] the following code is correct:and results in x having the value 7 because it is equivalent to:In other words, your assumption is correct.A good example of this casting is using *= or /=orororVery good question. The Java Language specification confirms your suggestion.For example, the following code is correct:and results in x having the value 7 because it is equivalent to:Yes,basically when we writethe compiler converts this to I just checked the .class file code.Really a good thing to knowyou need to cast from long to int explicitly in case of i = i + l  then it will compile and give correct output. like orbut in case of += it just works fine because the operator implicitly does the type casting from type of right variable to type of left variable so need not cast explicitly.The problem here involves type casting.When you add int and long, But += is coded in such a way that it does type casting. i=(int)(i+m)In Java type conversions are performed automatically when the type of the expression on the right hand side of an assignment operation can be safely promoted to the type of the variable on the left hand side of the assignment. Thus we can safely assign:  The same will not work the other way round. For example we cannot automatically convert a long to an int because the first requires more storage than the second and consequently information may be lost. To force such a conversion we must carry out an explicit conversion.\nType - ConversionSometimes, such a question can be asked at an interview.For example, when you write:there is no automatic typecasting. In C++ there will not be any error compiling the above code, but in Java you will get something like Incompatible type exception.So to avoid it, you must write your code like this:The main difference is that with a = a + b, there is no typecasting going on, and so the compiler gets angry at you for not typecasting. But with a += b, what it\'s really doing is typecasting b to a type compatible with a. So if you do What you\'re really doing is: Subtle point here...There is an implicit typecast for \'i+j\' when \'j\' is a double and \'i\' is an int.\nJava ALWAYS converts an integer into a double when there is an operation between them.To clarify \'i+=j\' where i is an integer and j is a double can be described asSee: this description of implicit castingYou might want to typecast j to (int) in this case for clarity.Very late to the party though it might help someone!!!In the case of compound assignment operator internal type casting will be performed automaticallyAnd in some case, you will lose some values