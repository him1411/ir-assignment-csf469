When running scripts in bash, I have to write ./ in the beginning:If I don\'t, I get an error message:What is the reason for this? I thought . is an alias for current folder, and therefore these two calls should be equivalent.I also don\'t understand why I don\'t need ./ when running applications, such as:(which runs without ./)Because on Unix, usually, the current directory is not in $PATH.When you type a command the shell looks up a list of directories, as specified by the PATH variable. The current directory is not in that list.The reason for not having the current directory on that list is security.Let\'s say you\'re root and go into another user\'s directory and type sl instead of ls. If the current directory is in PATH, the shell will try to execute the sl program in that directory (since there is no other sl program). That sl program might be malicious.It works with ./ because POSIX specifies that a command name that contain a / will be used as a filename directly, suppressing a search in $PATH. You could have used full path for the exact same effect, but ./ is shorter and easier to write.EDITThat sl part was just an example. The directories in PATH are searched sequentially and when a match is made that program is executed. So, depending on how PATH looks, typing a normal command may or may not be enough to run the program in the current directory.When bash interprets the command line, it looks for commands in locations described in the environment variable $PATH.  To see it type: You will have some paths separated by colons. As you will see the current path . is usually not in $PATH. So Bash cannot find your command if it is in the current directory. You can change it by having:This line adds the current directory in $PATH so you can do:It is not recommended as it has security issue, plus you can have weird behaviours, as . varies upon the directory you are in :)Avoid:As you can \xe2\x80\x9cmask\xe2\x80\x9d some standard command and open the door to security breach :)    Just my two cents.Your script, when in your home directory will not be found when the shell looks at the $PATH environment variable to find your script.The ./ says \'look in the current directory for my script rather than looking at all the directories specified in $PATH\'.When you include the \'.\' you are essentially giving the "full path" to the executable bash script, so your shell does not need to check your PATH variable.  Without the \'.\' your shell will look in your PATH variable (which you can see by running echo $PATH to see if the command you typed lives in any of the folders on your PATH.  If it doesn\'t (as is the case with manage.py) it says it can\'t find the file.  It is considered bad practice to include the current directory on your PATH, which is explained reasonably well here: http://www.faqs.org/faqs/unix-faq/faq/part2/section-13.htmlWhen the script is not in the Path its required to do so. For more  info read http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.htmlOn *nix, unlike Windows, the current directory is usually not in your $PATH variable. So the current directory is not searched when executing commands. You don\'t need ./ for running applications because these applications are in your $PATH; most likely they are in /bin or /usr/bin.This question already has some awesome answers, but I wanted to add that, if your executable is on the PATH, and you get very different outputs when you run to the ones you get if you run (let\'s say you run into error messages with the one and not the other), then the problem could be that you have two different versions of the executable on your machine: one on the path, and the other not.Check this by runningwhich  executableand It fixed my issues...I had three versions of the executable, only one of which was compiled correctly for the environment.There is difference between Current Directory and Working Directory you might find it on google easily. That is the reason your manage.py syncdb din\'t execute as expected.Current Directory : It\'s the directory from where your shell or parent process is being executed.In UNIX based system if you have your file at /data/myfile.out then you are traversing to your file through component names which are separated by forward slash "/" so if "." is your current directory then if you want to access(execute in your case) file that is inside your current directory you will have to say ./myexecutableFile.o. If you had your executable file in another folder of your current directory then you would do something like this ./myFiles/myexecutableFile.o. Hope you got what I am trying to explain.