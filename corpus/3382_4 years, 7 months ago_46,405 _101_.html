I often hear claims that C++ is a context-sensitive language. Take the following example:Is this a variable definition or a function declaration? That depends on the meaning of the symbol c. If c is a variable, then a b(c); defines a variable named b of type a. It is directly initialized with c. But if c is a type, then a b(c); declares a function named b that takes a c and returns an a.If you look up the definition of context-free languages, it will basically tell you that all grammar rules must have left-hand sides that consist of exactly one non-terminal symbol. Context-sensitive grammars, on the other hand, allow arbitrary strings of terminal and non-terminal symbols on the left-hand side.Browsing through Appendix A of "The C++ Programming Language", I couldn\'t find a single grammar rule that had anything else besides a single non-terminal symbol on its left-hand side. That would imply that C++ is context-free. (Of course, every context-free language is also context-sensitive in the sense that the context-free languages form a subset of the context-sensitive languages, but that is not the point.)So, is C++ context-free or context-sensitive?Below is my (current) favorite demonstration of why parsing C++ is (probably) Turing-complete, since it shows a program which is syntactically correct if and only if a given integer is prime.So I assert that C++ is neither context-free nor context-sensitive.If you allow arbitrary symbol sequences on both sides of any production, you produce an Type-0 grammar ("unrestricted") in the Chomsky hierarchy, which is more powerful than a context-sensitive grammar; unrestricted grammars are Turing-complete. A context-sensitive (Type-1) grammar allows multiple symbols of context on the left hand side of a production, but the same context must appear on the right hand side of the production (hence the name "context-sensitive"). [1] Context-sensitive grammars are equivalent to linear-bounded Turing machines.In the example program, the prime computation could be performed by a linear-bounded Turing machine, so it does not quite prove Turing equivalence, but the important part is that the parser needs to perform the computation in order to perform syntactic analysis. It could have been any computation expressible as a template instantiation and there is every reason to believe that C++ template instantiation is Turing-complete. See, for example, Todd L. Veldhuizen\'s 2003 paper.Regardless, C++ can be parsed by a computer, so it could certainly be parsed by a Turing machine. Consequently, an unrestricted grammar could recognize it. Actually writing such a grammar would be impractical, which is why the standard doesn\'t try to do so. (See below.)The issue with "ambiguity" of certain expressions is mostly a red herring. To start with, ambiguity is a feature of a particular grammar, not a language. Even if a language can be proven to have no unambiguous grammars, if it can be recognized by a context-free grammar, it\'s context-free. Similarly, if it cannot be recognized by a context-free grammar but it can be recognized by a context-sensitive grammar, it\'s context-sensitive. Ambiguity is not relevant.But in any event, like line 21 (i.e. auto b = foo<IsPrime<234799>>::typen<1>();) in the program below, the expressions are not ambiguous at all; they are simply parsed differently depending on context. In the simplest expression of the issue, the syntactic category of certain identifiers is dependent on how they have been declared (types and functions, for example), which means that the formal language would have to recognize the fact that two arbitrary-length strings in the same program are identical (declaration and use). This can be modelled by the "copy" grammar, which is the grammar which recognizes two consecutive exact copies of the same word. It\'s easy to prove with the pumping lemma that this language is not context-free. A context-sensitive grammar for this language is possible, and a Type-0 grammar is provided in the answer to this question: https://math.stackexchange.com/questions/163830/context-sensitive-grammar-for-the-copy-language .If one were to attempt to write a context-sensitive (or unrestricted) grammar to parse C++, it would quite possibly fill the universe with scribblings. Writing a Turing machine to parse C++ would be an equally impossible undertaking. Even writing a C++ program is difficult, and as far as I know none have been proven correct. This is why the standard does not attempt to provide a complete formal grammar, and why it chooses to write some of the parsing rules in technical English.What looks like a formal grammar in the C++ standard is not the complete formal definition of the syntax of the C++ language. It\'s not even the complete formal definition of the language after preprocessing, which might be easier to formalize. (That wouldn\'t be the language, though: the C++ language as defined by the standard includes the preprocessor, and the operation of the preprocessor is described algorithmically since it would be extremely hard to describe in any grammatical formalism. It is in that section of the standard where lexical decomposition is described, including the rules where it must be applied more than once.)The various grammars (two overlapping grammars for lexical analysis, one which takes place before preprocessing and the other, if necessary, afterwards, plus the "syntactic" grammar) are collected in Appendix A, with this important note (emphasis added):This summary of C++ syntax is intended to be an aid to comprehension. It is not an exact statement of the language. In particular, the grammar described here accepts a superset of valid C++ constructs. Disambiguation rules (6.8, 7.1, 10.2) must be applied to distinguish expressions from declarations. Further, access control, ambiguity, and type rules must be used to weed out syntactically valid but meaningless constructs.Finally, here\'s the promised program. Line 21 is syntactically correct if and only if the N in IsPrime<N> is prime. Otherwise, typen is an integer, not a template, so typen<1>() is parsed as (typen<1)>() which is syntactically incorrect because () is not a syntactically valid expression.[1] To put it more technically, every production in a context-sensitive grammar must be of the form:αAβ &rightarrow; αγβwhere A is a non-terminal and α, β are possibly empty sequences of grammar symbols, and γ is a non-empty sequence. (Grammar symbols may be either terminals or non-terminals). This can be read as A &rightarrow; γ only in the context [α, β]. In a context-free (Type 2) grammar, α and β must be empty.It turns out that you can also restrict grammars with the "monotonic" restriction, where every production must be of the form:α &rightarrow; β where |α| ≥ |β| > 0  (|α| means "the length of α")It\'s possible to prove that the set of languages recognized by monotonic grammars is exactly the same as the set of languages recognized by context-sensitive grammars, and it\'s often the case that it\'s easier to base proofs on monotonic grammars. Consequently, it\'s pretty common to see "context-sensitive" used as though it meant "monotonic".First, you rightly observed there are no context sensitive rules in the grammar at the end of the C++ standard, so that grammar is context-free.However, that grammar doesn\'t precisely describe the C++ language, because it produces non-C++ programs such asorThe C++ language defined as "the set of well-formed C++ programs" is not context-free (it\'s possible to show that merely demanding variables to be declared makes it so). Given you can theoretically write Turing-complete programs in templates and make a program ill-formed based on their result, it\'s not even context-sensitive.Now, (ignorant) people (usually not language theorists, but parser designers) typically use "not context-free" in some of the following meaningsThe grammar at the back of the standard doesn\'t satisfy these categories (i.e. it is ambiguous, not LL(k)...) so C++ grammar is "not context-free" for them. And in a sense, they\'re right it\'s damn well hard to produce a working C++ parser.Note that the properties here used are only weakly connected to context-free languages - ambiguity doesn\'t have anything to do with context-sensitivity (in fact, context-sensitive rules typically help disambiguate productions), the other two are merely subsets of context-free languages. And parsing context-free languages is not a linear process (although parsing deterministic ones is).Yes. The following expression has a different order of operations depending on type resolved context:Edit: When the actual order of operation varies, it makes it incredibly difficult to use a "regular" compiler that parses to an undecorated AST before decorating it (propagating type information). Other context sensitive things mentioned are "rather easy" compared to this (not that template evaluation is at all easy).Followed by:To answer your question, you need to distinguish two different questions.The mere syntax of almost every programming language is context-free. Typically, it is given as an extended Backus-Naur form or context-free gramar.However, even if a program conforms with the context-free gramar defined by the programming language, it is not necessarily a valid program. There are many non-context-free poperties that a program has to satisfy in order to be a valid program. E.g., the most simple such property is the scope of variables.To conclude, whether or not C++ is context-free depends on the question you ask.C++ is parsed with GLR parser. That means during parsing the source code, the parser may encounter ambiguity but it should continue and decide which grammar rule to use later.look also,Why C++ cannot be parsed with a LR(1) parser?Remember that context-free grammar can not describe ALL the rules of a programming language syntax. For example, Attribute grammar is used to check the validity of an expression type.You can not describe the following rule with context-free grammar :\nThe Right Side of the assignment should be of the same type of the Left Hand side.Yeah C++ is context sensitive, very context sensitive. You cannot build the syntax tree by simply parsing through the file using a context free parser because in some cases  you need to know the symbol from previous knowledge to decide (ie. build a symbol table while parsing). First example: Is this a multiplication expression?ORIs this a declaration of B variable to be a pointer of type A?If A is a variable, then it\'s an expression, if A is type, it\'s a pointer declaration.Second example:Is this a function prototype taking an argument of bar type?ORIs this declare variable B of type A and calls A\'s constructor with bar constant as an initializer?You need to know again whether bar is a variable or a type from symbol table. Third example:This is the case when building symbol table while parsing does not help because the declaration of x and y comes after the function definition. So you need to scan through the class definition first, and look at the method definitions in a second pass, to tell x*y is an expression, and not a pointer declaration or whatever.You might want to take a look at The Design & Evolution of C++, by Bjarne Stroustrup. In it he describes his problems trying to use yacc (or similar) to parse an early version of C++, and wishing he had used recursive descent instead.I have a feeling that there\'s some confusion between the formal definition of "context-sensitive" and the informal use of "context-sensitive". The former has a well-defined meaning. The latter is used for saying "you need context in order to parse the input".This is also asked here:\nContext-sensitivity vs Ambiguity.Here\'s a context-free grammar:It\'s ambiguous, so in order to parse the input "x" you need some context (or live with the ambiguity, or emit "Warning: E8271 - Input is ambiguous in line 115"). But it\'s certainly not a context-sensitive grammar.No Algol-like language is context-free, because they have rules that constrain expressions and statements that identifiers can appear in based on their type, and because there\'s no limit on the number of statements that can occur between declaration and use.The usual solution is to write a context-free parser that actually accepts a superset of valid programs and put the context-sensitive portions in ad hoc "semantic" code attached to rules.C++ goes well beyond this, thanks to its Turing-complete template system. See Stack Overflow Question 794015.The simplest case of non-context-free grammar involves parsing expressions involving templates.This can parse as eitherOr The two ASTs can only be disambiguated by examining the declaration of \'a\' -- the former AST if \'a\' is a template, or the latter if not.True :) J. Stanley Warford. Computer systems. Pages 341-346.It is context-sensitive, as a b(c); has two valid parses- declaration and variable. When you say "If c is a type", that\'s context, right there, and you\'ve described exactly how C++ is sensitive to it. If you didn\'t have that context of "What is c?" you could not parse this unambiguously.Here, the context is expressed in the choice of tokens- the parser reads an identifier as a typename token if it names a type. This is the simplest resolution, and avoids much of the complexity of being context-sensitive (in this case).Edit: There are, of course, more issues of context sensitivity, I have merely focused on the one you\'ve shown. Templates are especially nasty for this.The productions in the C++ standard are written context-free, but as we all know don\'t really define the language precisely. Some of what most people see as ambiguity in the current language could (I believe) be resolved unambiguously with a context sensitive grammar.For the most obvious example, let\'s consider the Most Vexing Parse: int f(X);. If X is a value, then this defines f as a variable that will be initialized with X. If X is a type, it defines f as a function taking a single parameter of type X.Looking at that from a grammatical viewpoint, we could view it like this:Of course, to be entirely correct we\'d need to add some extra "stuff" to account for the possibility of intervening declarations of other types (i.e., A and B should both really be "declarations including declaration of X as...", or something on that order).This is still rather different from a typical CSG though (or at least what I recall of them). This depends on a symbol table being constructed -- the part that specifically recognizes X as a type or value, not just some type of statement preceding this, but the correct type of statement for the right symbol/identifier.As such, I\'d have to do some looking to be sure, but my immediate guess is that this doesn\'t really qualify as a CSG, at least as the term is normally used.Sometimes it\'s worse: What do people mean when they say C++ has "undecidable grammar"?C++ templates have been shown to be Turing Powerful. Although not a formal reference, here\'s a place to look in that regard:http://cpptruths.blogspot.com/2005/11/c-templates-are-turing-complete.htmlI will venture a guess (as old as a folkoric and concise CACM proof showing that ALGOL in the 60\'s could not be reprsented by a CFG) and say that C++ cannot therefore be correctly parsed only by a CFG. CFGs, in conjunction with various TP mechanisms in either a tree pass or during reduction events -- this is another story. In a general sense, due to the Halting Problem, there exists some C++ program that cannot be shown to be correct/incorrect but is nonetheless correct/incorrect.{PS- As the author of Meta-S (mentioned by several people above) -- I can most assuredly say that Thothic is neither defunct, nor is the software available for free. Perhaps I have worded this version of my response such that I do not get deleted or voted down to -3.}C++ is not context free. I learned it some time ago in compilers lecture. A quick search gave this link, where the "Syntax or semantics" section explains why C and C++ are not context free:Wikipedia Talk: Context-Free grammarRegards,\nOvanesObviously, if you take the question verbatim, nearly all languages with identifiers are context sensitive.  One need to know if an identifier is a type name (a class name, a name introduced by typedef, a typename template parameter), a template name or some other name to be able to correctly some of the use of identifier.    For instance:is a cast if name is a type name and a function call if name is a function name.  Another case is the so called "most vexing parse" where it isn\'t possible to differentiate variable definition and function declaration (there is a rule saying it is a function declaration).That difficulty has introduced the need of typename and template with dependent names.  The rest of C++ isn\'t context sensitive as far as I know (i.e. it is possible to write a context free grammar for it).Meta-S" is a context-sensitive parsing engine by Quinn Tyler Jackson. I\'ve not used it, but he tells an impressive story. Check out his comments in comp.compilers, and see rnaparse.com/MetaS%20defined.htm  \xe2\x80\x93 Ira Baxter Jul 25 at 10:42The correct link is parsing eniginesMeta-S was the property of a defunct company called Thothic. I can send a free copy of the Meta-S to anyone interested and I\'ve used it in rna parsing research. Please note the "pseudoknot grammar" included in the examples folders was written by an non-bioinformatics, amature programmer and basically doesn\'t work. My grammars take a different approach and work quite well. This answer says C++ is not context-free... there\'s an implication (not by the answerer) that it can\'t be parsed, and the answer offers a difficult code example which produces an invalid C++ program if a certain constant is not a prime number.As others have observed, the question about whether the language is context-sensitive/free is different than the same question about a specific grammar.To set the question about parseability to rest, I offer empirical evidence that there are context-free grammars for C++, that can be used\nto produce an AST for a context-free parse of the source text\nby in fact parsing it with an existing GLR-parser-based tool that is driven by an explicit grammar.Yes, it succeeds by "accepting too much"; not everything it accepts is a valid C++ program, which is why it\'s followed up with additional checks (type checks).  And yes, the type checker may run into computability problems.  In practice tools don\'t have this problem; if people wrote programs like that, none of them would compile.  (I think the standard actually puts a limit on the amount of computation you can do unfolding a template, so in fact the computation is actually finite but probably pretty big).If what you mean is, determine if the source program is a member\nof the set of valid C++ source programs, then I will agree the\nproblem is a lot harder.   But it isn\'t parsing that is the problem.The tool resolves this issue by isolating parsing from type-checking\nthe parsed program.  (Where there are multiple interpretations\nin the absence of context, it records an ambiguity node\nin the parse tree with several possible parses; the type\nchecking decides which one is correct and eliminates the invalid\nsubtrees).  You can see a (partial) parse tree in the example below; the whole tree is too large to fit in an SO answer.  Note you get a parse tree whether the value 234797 or 234799 is used.Running the tool\'s name/type resolver over the AST with the original value 234799 succeeds. With the value 234797 the name resolver fails (as expected) with the error message, "typen is not a type." and thus that version is not a valid C++ program.