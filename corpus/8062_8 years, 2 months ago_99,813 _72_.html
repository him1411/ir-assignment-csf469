My app has a certain piece of functionality that will only work on a device where root is available. Rather than having this feature fail when it is used (and then show an appropriate error message to the user), I\'d prefer an ability to silently check if root is available first, and if not,hide the respective options in the first place.Is there a way to do this?Here is a class that will check for Root one of three ways. The RootTools library offers simple methods to check for root:https://github.com/Stericson/RootToolsIn my application I was checking if device is rooted or not by executing "su" command. But today I\'ve removed this part of my code. Why? Because my application became a memory killer. How? Let me tell you my story.There were some complaints that my application was slowing down devices(Of course I thought that can not be true). I tried to figure out why. So I used MAT to get heap dumps and analyze, and everything seemed perfect. But after relaunching my app many times I realized that device is really getting slower and stopping my application didn\'t make it faster (unless I restart device). I analyzed dump files again while device is very slow. But everything was still perfect for dump file.\nThen I did what must be done at first. I listed processes.Surprize; there were many processes for my application (with my application\'s process tag at manifest). Some of them was zombie some of them not.With a sample application which has a single Activity and executes just "su" command, I realized that a zombie process is being created on every launch of application. At first these zombies allocate 0KB but than something happens and zombie processes are holding nearly same KBs as my application\'s main process and they became standart processes.There is a bug report for same issue on bugs.sun.com: http://bugs.sun.com/view_bug.do?bug_id=6474073 this explains if command is not found zombies are going to be created with exec() method. But I still don\'t understand why and how can they become standart processes and hold significant KBs. (This is not happening all the time)You can try if you want with code sample below;Simple command execution method;To sum up; I have no advice for you to determine if device is rooted or not. But if I were you I would not use Runtime.getRuntime().exec().By the way; RootTools.isRootAvailable() causes same problem.Many of the answers listed here have inherent issues:The RootTools library from Stericson seems to be checking for root more legitimately. It also has lots of extra tools and utilities so I highly recommend it. However, there\'s no explanation of how it specifically checks for root, and it may be a bit heavier than most apps really need.I\'ve made a couple of utility methods that are loosely based on the RootTools library. If you simply want to check if the "su" executable is on the device you can use the following method:This method simply loops through the directories listed in the "PATH" environment variable and checks if a "su" file exists in one of them.In order to truly check for root access the "su" command must actually be run. If an app like SuperUser is installed, then at this point it may ask for root access, or if its already been granted/denied a toast may be shown indicating whether access was granted/denied. A good command to run is "id" so that you can verify that the user id is in fact 0 (root).Here\'s a sample method to determine whether root access has been granted:It\'s important to actually test running the "su" command because some emulators have the "su" executable pre-installed, but only allow certain users to access it like the adb shell. It\'s also important to check for the existence of the "su" executable before trying to run it, because android has been known to not properly dispose of processes that try to run missing commands. These ghost processes can run up memory consumption over time.Root check at Java level is not a safe solution. If your app has Security Concerns to run on a Rooted device , then please use this solution. Kevin\'s answer works unless the phone also has an app like RootCloak . Such apps have a Handle over Java APIs once phone is rooted and they mock these APIs to return phone is not rooted.I have written a native level code based on Kevin\'s answer , it works even with RootCloak ! Also it does not cause any memory leak issues.In your Java code , you need to create wrapper class RootUtils to make the native callshttp://code.google.com/p/roottools/If you do not want to use the jar file just use the code:Program will try to find su folder:Example:Instead of using isRootAvailable() you can use isAccessGiven(). Direct from RootTools wiki:RootTools.isAccessGiven() not only checks that a device is rooted, it\n  also calls su for your app, requests permission, and returns true if\n  your app was successfully granted root permissions. This can be used\n  as the first check in your app to make sure that you will be granted\n  access when you need it.https://code.google.com/p/roottools/Some modified builds used to set the system property ro.modversion for this purpose. Things seem to have moved on; my build from TheDude a few months ago has this:The emulator from the 1.5 SDK on the other hand, running the 1.5 image, also has root, is probably similar to the Android Dev Phone 1 (which you presumably want to allow) and has this:As for the retail builds, I don\'t have one to hand, but various searches under site:xda-developers.com are informative. Here is a G1 in the Netherlands, you can see that ro.build.tags does not have test-keys, and I think that\'s probably the most reliable property to use.If you are already using Fabric/Crashlytics you callThis is the current implementation of that method:Update 2017You can do it now with Google Safetynet API. The SafetyNet  API provides  Attestation API which  helps you assess the security and compatibility of the Android environments in which your apps run. This attestation can helps to determine whether or not the particular device has been tampered with or otherwise modified.The Attestation API returns a JWS response like thisParsing this response can help you determine if device is rooted or notRooted devices seem to cause ctsProfileMatch=false.You can do it on client side but parsing response on  server side is recommend. \nA basic client server archtecture with safety net API will look like this:- Here is my code based on some answers here:Further to @Kevins answer, I\'ve recently found while using his system, that the Nexus 7.1 was returning false for all three methods - No which command, no test-keys and SuperSU was not installed in /system/app.I added this:This is slightly less useful in some situations (if you need guaranteed root access) as it\'s completely possible for SuperSU to be installed on devices which don\'t have SU access.However, since it\'s possible to have SuperSU installed and working but not in the /system/app directory, this extra case will root (haha) out such cases.RootBeer is a root checking Android library by Scott and Matthew.\nIt uses various checks to indicate whether device is rooted or not.Java checksCheckRootManagementAppsCheckPotentiallyDangerousAppssCheckRootCloakingAppsCheckTestKeyscheckForDangerousPropscheckForBusyBoxBinarycheckForSuBinarycheckSuExistscheckForRWSystemNative checksWe call through to our native root checker to run some of it\'s own\n  checks. Native checks are typically harder to cloak, so some root\n  cloak apps just block the loading of native libraries that contain\n  certain key words.Two additional ideas, if you want to check if a device is root capable from your app:Indeed it is interesting question and so far nobody has deserved award. I use the following code:The code is certainly not bulletproof, because network can be not available so you get an exception. If this method returns true then 99% you can be sure, otherwise just 50% that not. Networking permission can also spoil the solution.Using C++ with the ndk is the best approach to detect root even if the user is using applications that hide his root such as RootCloak. I tested this code with RootCloak and I was able to detect the root even if the user is trying to hide it. \nSo your cpp file would like:And you will call the function from your java code as followsI suggest using native code for root detection.\nHere is an example. Using my library at rootbox, it is pretty easy. Check the required code below: