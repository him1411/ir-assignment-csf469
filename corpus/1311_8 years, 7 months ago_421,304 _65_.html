I am doing something where I realised I wanted to count how many /s I could find in a string, and then it struck me, that there were several ways to do it, but couldn\'t decide on what the best (or easiest) was.At the moment I\'m going with something like:But I don\'t like it at all, any takers?I don\'t really want to dig out RegEx for this, do I?I know my string is going to have the term I\'m searching for, so you can assume that...Of course for strings where length > 1,If you\'re using .NET 3.5 you can do this in a one-liner with LINQ:If you don\'t want to use LINQ you can do it with:You might be surprised to learn that your original technique seems to be about 30% faster than either of these! I\'ve just done a quick benchmark with "/once/upon/a/time/" and the results are as follows:Your original = 12s\n  source.Count = 19s\n  source.Split = 17s\n  foreach (from bobwienholt\'s answer) = 10s (The times are for 50,000,000 iterations so you\'re unlikely to notice much difference in the real world.)Has to be faster than the source.Replace() by itself.If you want to be able to search for whole strings, and not just characters:Read as "for each character in the string, take the rest of the string starting from that character as a substring; count it if it starts with the target string."I\'ve made some research and found that Richard Watson\'s solution is fastest in most cases. That\'s the table with results of every solution in the post (except those use Regex because it throws exceptions while parsing string like "test{test")You can see that in case of finding number of occurences of short substrings (1-5 characters) in short string(10-50 characters) the original algorithm is preferred.Also, for multicharacter substring you should use the following code (based on Richard Watson\'s solution)LINQ works on all collections, and since strings are just a collection of characters, how about this nice little one-liner:Make sure you have using System.Linq; at the top of your code file, as .Count is an extension method from that namespace.These both only work for single-character search terms...may turn out to be better for longer needles...But there has to be a more elegant way. :)On my computer it\'s about 2 seconds faster than the for-every-character solution for 50 million iterations.2013 revision:Change the string to a char[] and iterate through that. Cuts a further second or two off the total time for 50m iterations!This is quicker still:For good measure, iterating from the end of the array to 0 seems to be the fastest, by about 5%.I was wondering why this could be and was Googling around (I recall something about reverse iterating being quicker), and came upon this SO question which annoyingly uses the string to char[] technique already. I think the reversal trick is new in this context, though.What is the fastest way to iterate through individual characters in a string in C#?Edit:Because the original solution, was the fastest for chars, I suppose it will also be for strings. So here is my contribution.For the context: I was looking for words like \'failed\' and \'succeeded\' in a log file.Gr,\nBenIn C#, a nice String SubString counter is this unexpectedly tricky fellow:For anyone wanting a ready to use String extension method,here is what I use which was based on the best of the posted answers:I think the easiest way to do this is to use the Regular Expressions. This way you can get the same split count as you could using myVar.Split(\'x\') but in a multiple character setting.A generic function for occurrences of strings:A variation on Richard Watson\'s answer, slightly faster with improving efficiency the more times the char occurs in the string, and less code!Though I must say, without extensively testing every scenario, I did see a very significant speed improvement by using:String in string:Find "etc" in " .. JD JD JD JD etc. and etc. JDJDJDJDJDJDJDJD and etc."Check performance before discarding this one as unsound/clumsy... Needed to do something similar to test conditional statements from a string. Replaced what i was looking for with a single character and counted the instances of the single character. Obviously the single character you\'re using will need to be checked to not exist in the string before this happens to avoid incorrect counts.It just checks every character in the string, if the character is the character you are searching for, add one to count.If you check out this webpage, 15 different ways of doing this are benchmarked, including using parallel loops.The fastest way appears to be using either a single threaded for-loop (if you have .Net version < 4.0) or a parallel.for loop (if using .Net > 4.0 with thousands of checks).Assuming "ss" is your Search String, "ch" is your character array (if you have more than one char you\'re looking for), here\'s the basic gist of the code that had the fastest run time single threaded:The benchmark source code is provided too so you can run your own tests.Thought I would throw my extension method into the ring (see comments for more info). I have not done any formal bench marking, but I think it has to be very fast for most scenarios.EDIT: OK - so this SO question got me to wondering how the performance of our current implementation would stack up against some of the solutions presented here. I decided to do a little bench marking and found that our solution was very much in line with the performance of the solution provided by Richard Watson up until you are doing aggressive searching with large strings (100 Kb +), large substrings (32 Kb +) and many embedded repetitions (10K +). At that point our solution was around 2X to 4X slower. Given this and the fact that we really like the solution presented by Richard Watson, we have refactored our solution accordingly. I just wanted to make this available for anyone that might benefit from it. Our original solution:And here is our revised solution:My initial take gave me something like:The needle in a haystack approach using replace and division yields 21+ seconds whereas this takes about 15.2.Edit after adding a bit which would add substring.Length - 1 to the charIndex (like it should), it\'s at 11.6 seconds.Edit 2: I used a string which had 26 two-character strings, here are the times updated to the same sample texts:Needle in a haystack (OP\'s version): 7.8 SecondsSuggested mechanism: 4.6 seconds.Edit 3: Adding the single character corner-case, it went to 1.2 seconds.Edit 4: For context: 50 million iterations were used.This is for counting the character occurance. For this example output will be "a4b4j3"This will count each time the program finds "/s" exactly (case sensitive) and\nthe number of occurrences of this will be stored in the variable "occurrences"