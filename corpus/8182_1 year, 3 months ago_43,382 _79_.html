What is the best practice for uses Subscription.unsubscribe() in Angular apps?When should I store Subscriptions and call unsubscribe() on destroy event and when can I ignore them. Saving all subscription introduces a lot of mess into component code.HTTP Client Guide ignore subscriptions like this:In the same time Route & Navigation Guide says that:Eventually, we\'ll navigate somewhere else. The router will remove this component from the DOM and destroy it. We need to clean up after ourselves before that happens. Specifically, we must unsubscribe before Angular destroys the component. Failure to do so could create a memory leak.We unsubscribe from our Observable in the ngOnDestroy method.I spoke with Ward Bell about this question at NGConf (I even showed him this answer which he said was correct) but he told me the docs team for Angular had a solution to this question that is unpublished (though they are working on getting it approved). He also told me I could update my SO answer with the forthcoming official recommendation.The solution we should all use going forward is to add a private ngUnsubscribe: Subject<void> = new Subject<void>(); field to all components that have .subscribe() calls to Observables within their class code.We then call this.ngUnsubscribe.next(); this.ngUnsubscribe.complete(); in our ngOnDestroy() methods.The secret sauce (as noted already by @metamaker) is to call .takeUntil(this.ngUnsubscribe) before each of our .subscribe() calls which will guarantee all subscriptions will be cleaned up when the component is destroyed.Example:Source 5The Angular tutorial, the Routing chapter now states the following: "The Router manages the observables it provides and localizes the subscriptions. The subscriptions are cleaned up when the component is destroyed, protecting against memory leaks, so we don\'t need to unsubscribe from the route params Observable." - Mark RajcokHere\'s a discussion on the Github issues for the Angular docs regarding Router Observables where Ward Bell mentions that clarification for all of this is in the works.Source 4In this video from NgEurope Rob Wormald also says you do not need to unsubscribe from Router Observables. He also mentions the http service and ActivatedRoute.params in this video from November 2016.TLDR:For this question there are (2) kinds of Observables - finite value and infinite value.http Observables produce finite (1) values and something like a DOM event listener Observables produce infinite values.If you manually call subscribe (not using async pipe), then unsubscribe from infinite Observables.Don\'t worry about finite ones, RxJs will take care of them.Source 1I tracked down an answer from Rob Wormald in Angular\'s Gitter here.He states (i reorganized for clarity and emphasis is mine)if its a single-value-sequence (like an http request)\n  the manual cleanup is unnecessary (assuming you subscribe in the controller manually)i should say "if its a sequence that completes" (of which single value sequences, a la http, are one)if its an infinite sequence, you should unsubscribe which the async pipe does for youAlso he mentions in this youtube video on Observables that they clean up after themselves... in the context of Observables that complete (like Promises, which always complete because they are always producing 1 value and ending - we never worried about unsubscribing from Promises to make sure they clean up xhr event listeners, right?).Source 2Also in the Rangle guide to Angular 2 it readsIn most cases we will not need to explicitly call the unsubscribe method unless we want to cancel early or our Observable has a longer lifespan than our subscription. The default behavior of Observable operators is to dispose of the subscription as soon as .complete() or .error() messages are published. Keep in mind that RxJS was designed to be used in a "fire and forget" fashion most of the time.When does the phrase our Observable has a longer lifespan than our subscription apply?It applies when a subscription is created inside a component which is destroyed before (or not \'long\' before) the Observable completes.I read this as meaning if we subscribe to an http request or an observable that emits 10 values and our component is destroyed before that http request returns or the 10 values have been emitted, we are still ok!When the request does return or the 10th value is finally emitted the Observable will complete and all resources will be cleaned up.Source 3If we look at this example from the same Rangle guide we can see that the Subscription to route.params does require an unsubscribe() because we don\'t know when those params will stop changing (emitting new values).The component could be destroyed by navigating away in which case the route params will likely still be changing (they could technically change until the app ends) and the resources allocated in subscription would still be allocated because there hasn\'t been a completion.Original approach: You don\'t need to have bunch of subscriptions and unsubscribe manually. Use RxJS.Subject and takeUntil combo to handle subscriptions like a boss:Alternative approach, which was proposed by @acumartini in comments, uses takeWhile instead of takeUntil. You may prefer it, but mind that this way your Observable execution will not be cancelled on ngDestroy of your component (e.g. when you make time consuming calculations or wait for data from server). Method, which is based on takeUntil, doesn\'t have this drawback at leads to immediate cancellation of request. Thanks to @AlexChe for detailed explanation in comments.So here is the code:The Subscription class has an interesting property:Represents a disposable resource, such as the execution of an Observable. A Subscription has one important method, unsubscribe, that takes no argument and just disposes the resource held by the subscription.\n  Additionally, subscriptions may be grouped together through the add() method, which will attach a child Subscription to the current Subscription. When a Subscription is unsubscribed, all its children (and its grandchildren) will be unsubscribed as well.You can create an aggregate Subscription object that groups all your subscriptions.\nYou do this by creating an empty Subscription and adding subscriptions to it using its add() method. When your component is destroyed, you only need to unsubscribe the aggregate subscription.It depends. If by calling someObservable.subscribe(), you start holding up some resource that must be manually freed-up when the lifecycle of your component is over, then you should call theSubscription.unsubscribe() to prevent memory leak.Let\'s take a closer look at your examples:getHero() returns the result of http.get(). If you look into the angular 2 source code, http.get() creates two event listeners:and by calling unsubscribe(), you can cancel the request as well as the listeners:Note that _xhr is platform specific but I think it\'s safe to assume that it is an XMLHttpRequest() in your case.Normally, this is enough evidence to warrant a manual unsubscribe() call. But according this WHATWG spec, the XMLHttpRequest() is subject to garbage collection once it is "done", even if there are event listeners attached to it. So I guess that\'s why angular 2 official guide omits unsubscribe() and lets GC clean up the listeners.As for your second example, it depends on the implementation of params. As of today, the angular official guide no longer shows unsubscribing from params. I looked into src again and found that params is a just a BehaviorSubject. Since no event listeners or timers were used, and no global variables were created, it should be safe to omit unsubscribe().The bottom line to your question is that always call unsubscribe() as a guard against memory leak, unless you are certain that the execution of the observable doesn\'t create global variables, add event listeners, set timers, or do anything else that results in memory leaks.When in doubt, look into the implementation of that observable. If the observable has written some clean up logic into its unsubscribe(), which is usually the function that is returned by the constructor, then you have good reason to seriously consider calling unsubscribe().Angular 2 official documentation provides an explanation for when to unsubscribe and when it can be safely ignored. Have a look at this link: https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#bidirectional-serviceLook for the paragraph with the heading Parent and children communicate via a service and then the blue box: Notice that we capture the subscription and unsubscribe when the AstronautComponent is destroyed. This is a memory-leak guard step. There is no actual risk in this app because the lifetime of a AstronautComponent is the same as the lifetime of the app itself. That would not always be true in a more complex application.We do not add this guard to the MissionControlComponent because, as the parent, it controls the lifetime of the MissionService.I hope this helps you. Based on : Using Class inheritance to hook to Angular 2 component lifecycleAnother generic approach:And use :I like the last two answers, but I experienced an issue if the the subclass referenced "this" in ngOnDestroy.I modified it to be this, and it looks like it resolved that issue.  The official Edit #3 answer (and variations) works well, but the thing that gets me is the \'muddying\' of the business logic around the observable subscription.Here\'s another approach using wrappers.Warining: experimental codeFile subscribeAndGuard.ts is used to create a new Observable extension to wrap .subscribe() and within it to wrap ngOnDestroy().\nUsage is the same as .subscribe(), except for an additional first parameter referencing the component.  Here is a component with two subscriptions, one with the wrapper and one without. The only caveat is it must implement OnDestroy (with empty body if desired), otherwise Angular does not know to call the wrapped version.A demo plunker is hereAn additional note:\nRe Edit 3 - The \'Official\' Solution, this can be simplified by using takeWhile() instead of takeUntil() before subscriptions, and a simple boolean rather than another Observable in ngOnDestroy.I tried seangwright\'s solution (Edit 3)That is not working for Observable that created by timer or interval.However, i got it working by using another approach:Since seangwright\'s solution (Edit 3) appears to be very useful, I also found it a pain to pack this feature into base component, and hint other project teammates to remember to call super() on ngOnDestroy to activate this feature.This answer provide a way to set free from super call, and make "componentDestroyed$" a core of base component.And then you can use this feature freely for example: