I need to parse RFC 3339 strings like "2008-09-03T20:56:35.450686Z" into Python\'s datetime type.I have found strptime in the Python standard library, but it is not very convenient.What is the best way to do this?The python-dateutil package can parse not only RFC 3339 datetime strings like the one in the question, but also other ISO 8601 date and time strings  that don\'t comply with RFC 3339 (such as ones with no UTC offset, or ones that represent only a date).Be warned that the dateutil.parser is intentionally hacky: it tries to guess the format and makes inevitable assumptions (customizable by hand only) in ambiguous cases. So ONLY use it if you need to parse input of unknown format and are okay to tolerate occasional misreads. (thanks ivan_pozdeev)The Pypi name is python-dateutil, not dateutil (thanks code3monk3y):Note in Python 2.6+ and Py3K, the %f character catches microseconds.See issue hereSeveral answers here suggest using datetime.datetime.strptime to parse RFC 3339 or ISO 8601 datetimes with timezones, like the one exhibited in the question:This is a bad idea.Assuming that you want to support the full RFC 3339 format, including support for UTC offsets other than zero, then the code these answers suggest does not work. Indeed, it cannot work, because parsing RFC 3339 syntax using strptime is impossible. The format strings used by Python\'s datetime module are incapable of describing RFC 3339 syntax.The problem is UTC offsets. The RFC 3339 Internet Date/Time Format requires that every date-time includes a UTC offset, and that those offsets can either be Z (short for "Zulu time") or in +HH:MM or -HH:MM format, like +05:00 or -10:30.Consequently, these are all valid RFC 3339 datetimes:Alas, the format strings used by strptime and strftime have no directive that corresponds to UTC offsets in RFC 3339 format. A complete list of the directives they support can be found at https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior, and the only UTC offset directive included in the list is %z:UTC offset in the form +HHMM or -HHMM (empty string if the the object is naive).Example: (empty), +0000, -0400, +1030This doesn\'t match the format of an RFC 3339 offset, and indeed if we try to use %z in the format string and parse an RFC 3339 date, we\'ll fail:(Actually, the above is just what you\'ll see in Python 3. In Python 2 we\'ll fail for an even simpler reason, which is that strptime does not implement the %z directive at all in Python 2.)The multiple answers here that recommend strptime all work around this by including a literal Z in their format string, which matches the Z from the question asker\'s example datetime string (and discards it, producing a datetime object without a timezone):Since this discards timezone information that was included in the original datetime string, it\'s questionable whether we should regard even this result as correct. But more importantly, because this approach involves hard-coding a particular UTC offset into the format string, it will choke the moment it tries to parse any RFC 3339 datetime with a different UTC offset:Unless you\'re certain that you only need to support RFC 3339 datetimes in Zulu time, and not ones with other timezone offsets, don\'t use strptime. Use one of the many other approaches described in answers here instead.Try the iso8601 module; it does exactly this.There are several other options mentioned on the WorkingWithTime page on the python.org wiki.What is the exact error you get? Is it like the following:If yes, you can split your input string on ".", and then add the microseconds to the datetime you got.Try this:Nobody has mentioned it yet. In these days, Arrow also can be used as a third party solution.If you don\'t want to use dateutil, you can try this function:Test:Result:If you are working with Django, it provides the dateparse module that accepts a bunch of formats similar to ISO format, including the time zone.If you are not using Django and you don\'t want to use one of the other libraries mentioned here, you could probably adapt the Django source code for dateparse to your project.So much simpler than you all are making it.If you want to get the seconds since epoch, you can use python-dateutil to convert it to a datetime object and then convert it so seconds using the strftime method. Like so:SourceNote: This will convert the given datetime into epoch time. But you can use the strftime() function to convert that datetime into any format. The parsed_t object here is of type datetime at this point.I\'ve coded up a parser for the ISO 8601 standard and put it on github: https://github.com/boxed/iso8601 This implementation supports everything in the spec except for durations, intervals and periodic intervals and dates outside the supported date range of pythons datetime module.Tests included! :PI\'m the author of iso8601utils. It can be found on github or on PyPI. Here\'s how you can parse your example:Hope this helps!Django\'s parse_datetime() function supports dates with UTC offsets:So it could be used for parsing iso-8601 dates in fields within entire project:For something that works with the 2.X standard library try:calendar.timegm is the missing gm version of time.mktime.The python-dateutil will throw an exception if parsing invalid date strings, so you may want to catch the exception.This works for stdlib on Python 3.2 onwards (edit: assuming all the timestamps are UTC):e.g.One straightforward way to convert an ISO 8601-like date string to a UNIX timestamp or datetime.datetime object in all supported Python versions without installing third-party modules is to use the date parser of SQLite.Output:Because RFC 3339 allows many variations of optional colons and dashes being present, basically CCYY-MM-DDThh:mm:ss[Z|(+|-)hh:mm]. If you want to use strptime, you need to strip out those variations first.\n\nThe goal is to generate a utc datetime object.\nI have found ciso8601 to be the fastest way to parse ISO 8601 timestamps. As the name suggests, it is implemented in C.The GitHub Repo README shows their >10x speedup versus all of the other libraries listed in the other answers.My personal project involved a lot of ISO 8601 parsing. It was nice to be able to just switch the call and go 10x faster. :)Thanks to great Mark Amery\'s answer I devised function to account for all possible ISO formats of datetime:Note that we should look if the string doesn\'t ends with Z, we could parse using %z.