Why is null considered an object in JavaScript?Is checking the same as ?And also:What is the difference between null and undefined?You: What is name? (*)\nJavaScript: name? What\'s a name? I don\'t know what you\'re talking about. You haven\'t ever mentioned any name before. Are you seeing some other scripting language on the (client-)side?You: What is name?\nJavaScript: I don\'t know.In short; undefined is where no notion of the thing exists; it has no type, and it\'s never been referenced before in that scope; null is where the thing is known to exist, but it\'s not known what the value is.One thing to remember is that null is not, conceptually, the same as false or "" or such, even if they equate after type casting, i.e.You: What is name?\nJavaScript: Boolean false.You: What is name?\nJavaScript: Empty string*: name in this context is meant as a variable which has never been defined. It could be be any undefined variable. However, name is a property of just about any HTML form element. It goes way, way back and was instituted well before id. It is useful because ids must be unique but names to not have to be. \nThe difference can be summarized into this snippet:Checkingobject == null is different to check if ( !object ).The latter is equal to ! Boolean(object), because the unary ! operator automatically cast the right operand into a Boolean.Since Boolean(null) equals false then !false === true.So if your object is not null, but false or 0 or "", the check will pass\nbecause:null is not an object, it is a primitive value. For example, you cannot add properties to it. Sometimes people wrongly assume that it is an object, because typeof null returns "object". But that is actually a bug (that might even be fixed in ECMAScript 6).The difference between null and undefined is as follows:undefined: used by JavaScript and means \xe2\x80\x9cno value\xe2\x80\x9d. Uninitialized variables, missing parameters and unknown variables have that value.Accessing unknown variables, however, produces an exception:null: used by programmers to indicate \xe2\x80\x9cno value\xe2\x80\x9d, e.g. as a parameter to a function.Examining a variable:As a general rule, you should always use === and never == in JavaScript (== performs all kinds of conversions that can produce unexpected results). The check x == null is an edge case, because it works for both null and undefined:A common way of checking whether a variable has a value is to convert it to boolean and see whether it is true. That conversion is performed by the if statement and the boolean operator ! (\xe2\x80\x9cnot\xe2\x80\x9d).Drawback of this approach: All of the following values evaluate to false, so you have to be careful (e.g., the above checks can\xe2\x80\x99t distinguish between undefined and 0).You can test the conversion to boolean by using Boolean as a function (normally it is a constructor, to be used with new):What is the difference between null and undefined??A property when it has no definition, is undefined. null is an object. Its type is object. null is a special value meaning "no value. undefined is not an object, it\'s type is undefined.You can declare a variable, set it to null, and the behavior is identical except that you\'ll see "null" printed out versus "undefined". You can even compare a variable that is undefined to null or vice versa, and the condition will be true:Refer to JavaScript Difference between null and undefined for more detail.and with your new edit yeswhen testing if object is false, they both only meet the condition when testing if false, but not when trueCheck here: Javascript gotchaFirst part of the question:Why is null considered an object in JavaScript?It is a JavaScript design error they can\'t fix now. It should have been type null, not type object, or not have it at all. It necessitates an extra check (sometimes forgotten) when detecting real objects and is source of bugs. Second part of the question:Is checking \n  \n  if (object == null) \n  Do something \n  \n  the same as \n  \n  if (!object) \n  Do something The two checks are always both false except for:object is undefined or null: both true.object is primitive, and 0, "", or false:  first check false, second true.If the object is not a primitive, but a real Object, like new Number(0), new String(""), or new Boolean(false), then both checks are false.So if \'object\' is interpreted to mean a real Object then both checks are always the same. If primitives are allowed then the checks are different for 0, "", and false.In cases like object==null, the unobvious results could be a source of bugs. Use of == is not recommended ever, use === instead. Third part of the question:And also: \n  \n  What is the difference between null and undefined? In JavaScript, one difference is that null is of type object and undefined is of type undefined.In JavaScript, null==undefined is true, and considered equal if type is ignored. Why they decided that, but 0, "" and false aren\'t equal, I don\'t know. It seems to be an arbitrary opinion.In JavaScript, null===undefined is not true since the type must be the same in ===.In reality, null and undefined are identical, since they both represent non-existence. So do 0, and "" for that matter too, and maybe the empty containers [] and {}. So many types of the same nothing are a recipe for bugs. One type or none at all is better. I would try to use as few as possible.\'false\', \'true\', and \'!\' are another bag of worms that could be simplified, for example, if(!x) and if(x) alone are sufficient, you don\'t need true and false. A declared var x is type undefined if no value is given, but it should be the same as if x was never declared at all. Another bug source is an empty nothing container. So it is best to declare and define it together, like var x=1.People are going round and round in circles trying to figure out all these various types of nothing, but it\'s all just the same thing in complicated different clothes. The reality isAnd maybe all should throw exceptions.x is defined as nully is not defined; // because I did not define itnull is evaluated as falseOne way to make sense of null and undefined is to understand where each occurs.Expect a null return value in the following situations:Methods that query the DOMJSON responses received from an Ajax requestRegEx.exec.New functionality that is in a state of flux. The following returns null:All other cases of non-existence are denoted by undefined (as noted by @Axel). Each of the following prints "undefined":Of course if you decide to write var unitialised = null; or return null from a method yourself then you have null occurring in other situations. But that should be pretty obvious.A third case is when you want to access a variable but you don\'t even know if it has been declared. For that case use typeof to avoid a reference error:In summary check for null when you are manipulating the DOM, dealing with Ajax, or using certain ECMAScript 5 features. For all other cases it is safe to check for undefined with strict equality:Comparison of many different null checks in JavaScript:http://jsfiddle.net/aaronhoffman/DdRHB/5/http://aaron-hoffman.blogspot.com/2013/04/javascript-null-checking-undefined-and.htmlnull and undefined are both false for value equality (null==undefined): they both collapse to boolean false. They are not the same object (null!==undefined).undefined is a property of the global object ("window" in browsers), but is a primitive type and not an object itself. It\'s the default value for uninitialized variables and functions ending without a return statement.null is an instance of Object. null is used for DOM methods that return collection objects to indicate an empty result, which provides a false value without indicating an error.null is an object. Its type is null. undefined is not an object; its type is undefined.Some precisions:null and undefined are two different values. One is representing the absence of a value for a name and the other is representing the absence of a name.What happens in an if goes as follows for if( o ):The expression in the parentheses o is evaluated, and then the if kicks in type-coercing the value of the expression in the parentheses - in our case o.Falsy (that will get coerced to false) values in JavaScript are: \'\', null, undefined, 0, and false. To add to the answer of What is the differrence between undefined and null, from JavaScript Definitive Guide on this page:You might consider undefined to represent system-level, unexpected,\n  or error-like absense of value and null to represent program-level,\n  normal, or expected absence of value.  If you need to assign one of\n  these values to a variable or property or pass one of these values to\n  a function, null is almost always the right choice.The following function shows why and is capable for working out the difference:If you callYou\'re gettingundefinednullThe first console.log(...) tries to get myProperty from myObj while it is not yet defined - so it gets back "undefined". After assigning null to it, the second console.log(...) returns obviously "null" because myProperty exists, but it has the value null assigned to it.In order to be able to query this difference, JavaScript has null and undefined: While null is - just like in other languages an object, undefined cannot be an object because there is no instance (even not a null instance) available.For example window.someWeirdProperty is undefined, so"window.someWeirdProperty === null" evaluates to false while"window.someWeirdProperty === undefined" evaluates to true.Moreover checkif if (!o) is not the same as checking if (o == null) for o being false.The other fun thing about null, compared to undefined, is that it can be incremented.\nThis is useful for setting default numerical values for counters. How many times have you set a variable to -1 in its declaration?From "The Principles of Object-Oriented Javascript" by Nicholas C. Zakas But why an object when the type is null? (In fact, this has been acknowledged as an error by TC39, the committee that designs and maintains JavaScript. You could reason that null is an empty object pointer, making "object" a logical return value, but that\xe2\x80\x99s still confusing.)Zakas, Nicholas C. (2014-02-07). The Principles of Object-Oriented JavaScript (Kindle Locations 226-227). No Starch Press. Kindle Edition. That said:Undefined case:The best way to think about \'null\' is to recall how the similar concept is used in databases, where it indicates that a field contains "no value at all."This is a very useful technique for writing programs that are more-easily debugged.  An \'undefined\' variable might be the result of a bug ... (how would you know?) ... but if the variable contains the value \'null,\' you know that "someone, somewhere in this program, set it to \'null.\'"  Therefore, I suggest that, when you need to get rid of the value of a variable, don\'t "delete" ... set it to \'null.\'  The old value will be orphaned and soon will be garbage-collected; the new value is, "there is no value (now)."  In both cases, the variable\'s state is certain: "it obviously, deliberately, got that way."2.Undefined is a type itself while Null is an object.3.Javascript can itself initialize any unassigned variable to undefined but it can never set value of a variable to null. This has to be done programatically.In Javascript null is not an object type it is a primitave type.What is the difference?\nUndefined refers to a pointer that has not been set.\nNull refers to the null pointer for example something has manually set a variable to be of type nullLook at this: