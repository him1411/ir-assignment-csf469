What function does the ^ (caret) operator serve in Java?When I try this:...it gives me:for n = 5, returns 0\n  for n = 4, returns 1\n  for n = 6, returns 3  ...so I guess it doesn\'t perform exponentiation. But what is it then?^ in Java is the exclusive-or ("xor") operator.Let\'s take 5^6 as example:This the truth table for bitwise (JLS 15.22.1) and logical (JLS 15.22.2) xor:More simply, you can also think of xor as "this or that, but not both!".As for integer exponentiation, unfortunately Java does not have such an operator. You can use double Math.pow(double, double) (casting the result to int if necessary).You can also use the traditional bit-shifting trick to compute some powers of two. That is, (1L << k) is two to the k-th power for k=0..63.Merge note: this answer was merged from another question where the intention was to use exponentiation to convert a string "8675309" to int without using Integer.parseInt as a programming exercise  (^ denotes exponentiation from now on). The OP\'s intention was to compute 8*10^6 + 6*10^5 + 7*10^4 + 5*10^3 + 3*10^2 + 0*10^1 + 9*10^0 = 8675309; the next part of this answer addresses that exponentiation is not necessary for this task.Addressing your specific need, you actually don\'t need to compute various powers of 10. You can use what is called the Horner\'s scheme, which is not only simple but also efficient.Since you\'re doing this as a personal exercise, I won\'t give the Java code, but here\'s the main idea:It may look complicated at first, but it really isn\'t. You basically read the digits left to right, and you multiply your result so far by 10 before adding the next digit.In table form:As many people have already pointed out, it\'s the XOR operator. Many people have also already pointed out that if you want exponentiation then you need to use Math.pow.But I think it\'s also useful to note that ^ is just one of a family of operators that are collectively known as bitwise operators:From here.These operators can come in handy when you need to read and write to integers where the individual bits should be interpreted as flags, or when a specific range of bits in an integer have a special meaning and you want to extract only those. You can do a lot of every day programming without ever needing to use these operators, but if you ever have to work with data at the bit level, a good knowledge of these operators is invaluable.It\'s bitwise XOR, Java does not have an exponentiation operator, you would have to use Math.pow() instead.It is the XOR bitwise operator.As others have said, it\'s bitwise XOR. If you want to raise a number to a given power, use Math.pow(a , b), where a is a number and b is the power.Lot many people have already explained about what it is and how it can be used but apart from the obvious you can use this operator to do a lot of programming tricks likeLot many such tricks can be done using bit wise operators, interesting topic to explore.use Math.pow instead:http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Math.html#pow%28double,%20double%29As already stated by the other answer(s), it\'s the "exclusive or" (XOR) operator. For more information on bit-operators in Java, see: http://java.sun.com/docs/books/tutorial/java/nutsandbolts/op3.htmlAraK\'s link points to the definition of exclusive-or, which explains how this function works for two boolean values.The missing piece of information is how this applies to two integers (or integer-type values). Bitwise exclusive-or is applied to pairs of corresponding binary digits in two numbers, and the results are re-assembled into an integer result.To use your example:A simple way to define bitwise XOR is to say the result has a 1 in every place where the two input numbers differ.With 4 and 5, the only difference is in the last place; so0101 ^ 0100 = 0001 (5 ^ 4 = 1) .That is because you are using the xor operator.In java, or just about any other language, ^ is bitwise xor,\nso of course,10 ^ 1 = 11.\nmore info about bitwise operatorsIt\'s interesting how Java and C# don\'t have a power operator.It is the Bitwise xor operator in java which results 1 for different value of bit (ie 1 ^ 0 = 1) and 0 for same value of bit (ie 0 ^ 0 = 0) when a number is written in binary form.ex :- To use your example:The binary representation of 5 is 0101.\nThe binary representation of 4 is 0100.A simple way to define Bitwise XOR is to say the result has a 1 in every place where the two input numbers differ.0101 ^ 0100 = 0001 (5 ^ 4 = 1) .It is the bitwise xor operator in java which results 1 for different value (ie 1 ^ 0 = 1) and 0 for same value (ie 0 ^ 0 = 0).^ is binary (as in base-2) xor, not exponentiation (which is not available as a Java operator). For exponentiation, see java.lang.Math.pow().In other languages like Python you can do 10**2=100, try it.It is XOR operator. It is use to do bit operations on numbers. It has the behavior such that when you do a xor operation on same bits say 0 XOR 0 / 1 XOR 1 the result is 0. But if any of the bits is different then result is 1. \nSo when you did 5^3 then you can look at these numbers 5, 6 in their binary forms and thus the expression becomes (101) XOR (110) which gives the result (011) whose decimal representation is 3.Meanwhile, in Groovy:Running the above using groovyShellfor example gives: