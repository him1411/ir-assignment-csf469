I\'ve been told not to use for...in with arrays in JavaScript. Why not?The reason is that one construct:can sometimes be totally different from the other:Also consider that JavaScript libraries might do things like this, which will affect any array you create:The for-in statement by itself is not a "bad practice", however it can be mis-used, for example, to iterate over arrays or array-like objects.The purpose of the for-in statement is to enumerate over object properties. This statement will go up in the prototype chain, also enumerating over inherited properties, a thing that sometimes is not desired.Also, the order of iteration is not guaranteed by the spec., meaning that if you want to "iterate" an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.For example, in JScript (IE <= 8), the order of enumeration even on Array objects is defined as the properties were created:Also, speaking about inherited properties, if you, for example, extend the Array.prototype object (like some libraries as MooTools do), that properties will be also enumerated:As I said before to iterate over arrays or array-like objects, the best thing is to use a sequential loop, such as a plain-old for/while loop.When you want to enumerate only the own properties of an object (the ones that aren\'t inherited), you can use the hasOwnProperty method:And some people even recommend calling the method directly from Object.prototype to avoid having problems if somebody adds a property named hasOwnProperty to our object:There are three reasons why you shouldn\'t use for..in to iterate over array elements:for..in will loop over all own and inherited properties of the array object which aren\'t DontEnum; that means if someone adds properties to the specific array object (there are valid reasons for this - I\'ve done so myself) or changed Array.prototype (which is considered bad practice in code which is supposed to work well with other scripts), these properties will be iterated over as well; inherited properties can be excluded by checking hasOwnProperty(), but that won\'t help you with properties set in the array object itselffor..in isn\'t guaranteed to preserve element orderingit\'s slow because you have to walk all properties of the array object and its whole prototype chain and will still only get the property\'s name, ie to get the value, an additional lookup will be requiredBecause for...in enumerates through the object that holds the array, not the array itself. If I add a function to the arrays prototype chain, that will also be included. I.e.This will write:And since you can never be sure that nothing will be added to the prototype chain just use a for loop to enumerate the array:This will write:In isolation, there is nothing wrong with using for-in on arrays. For-in iterates over the property names of an object, and in the case of an "out-of-the-box" array, the properties corresponds to the array indexes. (The built-in propertes like length, toString and so on are not included in the iteration.)However, if your code (or the framework you are using) add custom properties to arrays or to the array prototype, then these properties will be included in the iteration, which is probably not what you want.Some  JS frameworks, like Prototype modifies the Array prototype. Other frameworks like JQuery doesn\'t, so with JQuery you can safely use for-in.If you are in doubt, you probably shouldn\'t use for-in. An alternative way of iterating through an array is using a for-loop:However, this have a different issue. The issue is that a JavaScript array can have "holes". If you define arr as:Then the array have two items, but a length of 101. Using for-in will yield two indexes, while the for-loop will yield 101 indexes, where the 99 has a value of undefined.In addition to the reasons given in other answers, you may not want to use the "for...in" structure if you need to do math with the counter variable because the loop iterates through the names of the object\'s properties and so the variable is a string.For example,will write whereas,will writeOf course, this can easily be overcome by includingin the loop, but the first structure is more direct.Short answer: It\'s just not worth it.Longer answer: It\'s just not worth it, even if sequential element order and optimal performance aren\'t required.Long answer: It\'s just not worth it, for reasons following:For these reasons an acceptable trade-off between performance and convenience doesn\'t even exist. Really, there\'s no benefit unless the intent is to treat the array as a pure object and performs operations on the array object\'s properties.As of 2016 (ES6) we may use for\xe2\x80\xa6of for array iteration, as John Slegers already noticed. I would just like to add this simple demonstration code, to make things clearer:The console shows:In other words:for...of counts from 0 to 5, and also ignores Array.prototype.foo. It shows array values.for...in lists only the 5, ignoring undefined array indexes, but adding foo. It shows array property names.Aside from the fact that for...in loops over all enumerable properties (which is not the same as "all array elements"!), see http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf, section 12.6.4 (5th edition) or 13.7.5.15 (7th edition):The mechanics and order of enumerating the properties ... is not specified...(Emphasis mine.)That means if a browser wanted to, it could go through the properties in the order in which they were inserted.  Or in numerical order.  Or in lexical order (where "30" comes before "4"!  Keep in mind all object keys -- and thus, all array indexes -- are actually strings, so that makes total sense).  It could go through them by bucket, if it implemented objects as hash tables.  Or take any of that and add "backwards".  A browser could even iterate randomly and be ECMA-262 compliant, as long as it visited each property exactly once.In practice, most browsers currently like to iterate in roughly the same order.  But there\'s nothing saying they have to.  That\'s implementation specific, and could change at any time if another way was found to be far more efficient.Either way, for...in carries with it no connotation of order.  If you care about order, be explicit about it and use a regular for loop with an index.Mainly two reasons:OneLike others have said, You might get keys which aren\'t in your array or that are inherited from the prototype. So if, let\'s say, a library adds a property to the Array or Object prototypes:You\'ll get it as part of every array:you could solve this with the hasOwnProperty method:but this is true for iterating over any object with a for-in loop.TwoUsually the order of the items in an array is important, but the for-in loop won\'t necessarily iterate in the right order, that\'s because it treats the array as an object, which is the way it is implemented in JS, and not as an array.\nThis seems like a small thing, but it can really screw up applications and is hard to debug.The problem with for ... in ... — and this only becomes a problem when a programmer doesn\'t really understand the language; it\'s not really a bug or anything — is that it iterates over all members of an object (well, all enumerable members, but that\'s a detail for now).  When you want to iterate over just the indexed properties of an array, the only guaranteed way to keep things semantically consistent is to use an integer index (that is, a for (var i = 0; i < array.length; ++i) style loop).Any object can have arbitrary properties associated with it. There would be nothing terrible about loading additional properties onto an array instance, in particular. Code that wants to see only indexed array-like properties therefore must stick to an integer index. Code that is fully aware of what for ... in does and really need to see all properties, well then that\'s ok too.Because it enumerates through object fields, not indexes. You can get value with index "length" and I doubt you want this.In addition to the other problems, the "for..in" syntax is probably slower, because the index is a string, not an integer.The for/in works with two types of variables: hashtables (associative arrays) and array (non-associative).JavaScript will automatically determine the way its passes through the items. So if you know that your array is really non-associative you can use for (var i=0; i<=arrayLen; i++), and skip the auto-detection iteration.But in my opinion, it\'s better to use for/in, the process required for that auto-detection is very small. A real answer for this will depend on how the browser parsers/interpret the JavaScript code. It can change between browsers.I can\'t think of other purposes to not using for/in;Because it will iterate over properties belonging to objects up the prototype chain if you\'re not careful.You can use for.. in, just be sure to check each property with hasOwnProperty.An important aspect is that for...in only iterates over properties contained in an object which have their enumerable property attribute set to true. So if one attempts to iterate over an object using for...in then arbitrary properties may be missed if their enumerable property attribute is false. It is quite possible to alter the enumerable property attribute for normal Array objects so that certain elements are not enumerated. Though in general the property attributes tend to apply to function properties within an object.One can check the value of a properties\' enumerable property attribute by:Or to obtain all four property attributes:This is a feature available in ECMAScript 5 - in earlier versions it was not possible to alter the value of the enumerable property attribute (it was always set to true).Also, due to semantics, the way for, in treats arrays (i.e. the same as any other JavaScript object) is not aligned with other popular languages.I don\'t think I have much to add to eg. Triptych\'s answer or CMS\'s answer on why using for-in should be avoided in some cases.I do, however, would like to add that in modern browsers there is an alternative to for-in that can be used in those cases where for-in can\'t be used. That alternative is for-of :Unfortunately, no version of Internet Explorer supports this feature (Edge 12+ does), so you\'ll have to wait a bit longer until you can use it in your client side production code. However, it should be safe to use in your server side JS code (if you use Node.js).It\'s not necessarily bad (based on what you\'re doing), but in the case of arrays, if something has been added to Array.prototype, then you\'re going to get strange results.  Where you\'d expect this loop to run three times:If a function called helpfulUtilityMethod has been added to Array\'s prototype, then your loop would end up running four times: key would be 0, 1, 2, and helpfulUtilityMethod.  If you were only expecting integers, oops.You should use the for(var x in y) only on property lists, not on objects (as explained above).TL&DR: Using the for in loop in arrays is not evil, in fact quite the opposite.I think the for in loop is a gem of JS if used correctly in arrays. You are expected to have full control over your software and know what you are doing. Let\'s see the mentioned drawbacks and disprove them one by one.So you see.. for in loop is now safe since you cared about your code.Using the for...in loop for an array is not wrong, although I can guess why someone told you that:1.) There is already a higher order function, or method, that has that purpose for an array, but has more functionality and leaner syntax, called \'forEach\': Array.prototype.forEach(function(element, index, array) {} );2.) Arrays always have a length, but for...in and forEach do not execute a function for any value that is \'undefined\', only for the indexes that have a value defined. So if you only assign one value, these loops will only execute a function once, but since an array is enumerated, it will always have a length up to the highest index that has a defined value, but that length could go unnoticed when using these loops.3.) The standard for loop will execute a function as many times as you define in the parameters, and since an array is numbered, it makes more sense to define how many times you want to execute a function. Unlike the other loops, the for loop can then execute a function for every index in the array, whether the value is defined or not.In essence, you can use any loop, but you should remember exactly how they work. Understand the conditions upon which the different loops reiterate, their separate functionalities, and realize they will be more or less appropriate for differing scenarios. Also, it may be considered better practice to use the forEach method than the for...in loop in general, because it is easier to write and has more functionality, so you may want to get in the habit of only using this method and standard for, but your call.See below that the first two loops only execute the console.log statements once, while the standard for loop executes the function as many times as specified, in this case array.length = 6.