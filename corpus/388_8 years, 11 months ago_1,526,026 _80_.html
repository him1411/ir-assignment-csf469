Consider a database table holding names, with three rows:Is there an easy way to turn this into a single string of Peter, Paul, Mary?I had a similar issue when I was trying to join two tables with one-to-many relationships. In SQL 2005 I found that XML PATH method can handle the concatenation of the rows very easily.If there is a table called STUDENTSResult I expected was:I used the following T-SQL:You can do the same thing in a more compact way if you can concat the commas at the beginning and use substring to skip the first one so you don\'t need to do a subquery:Use COALESCE:Just some explanation (since this answer seems to get relatively regular views):1) No need to initialize @Names with an empty string value. 2) No need to strip off an extra separator at the end.or:Depending on what behavior you want (the first option just filters NULLs out, the second option keeps them in the list with a marker message [replace \'N/A\' with whatever is appropriate for you]).One method not yet shown via the XML data() command in MS SQL Server is:Assume table called NameList with one column called FName,returns: Only the extra comma must be dealt with.Edit: As adopted from @NReilingh\'s comment, you can use the following method to remove the trailing comma.  Assuming the same table and column names:In SQL Server 2005 ...In MySQL there is a function, GROUP_CONCAT(), which allows you to concatenate the values from multiple rows. Example:Starting with the next version of SQL Server, we can finally concatenate across rows without having to resort to any variable or XML witchery.Without groupingWith grouping :With grouping and sub-sortingOracle 11g Release 2 supports the LISTAGG function.  Documentation here.Be careful implementing this function if there is possibility of the resulting string going over 4000 characters.  It will throw an exception.  If that\'s the case then you need to either handle the exception or roll your own function that prevents the joined string from going over 4000 characters.Postgres arrays are awesome. Example:Create some test data:Aggregate them in an array:Convert the array to a comma delimited string:DONESince PostgreSQL 9.0 it is even easier.Use COALESCE - Learn more from hereFor an example:102 103104Then write below code in sql server,Output would be:In SQL Server 2005 and later, use the query below to concatenate the rows.Starting with PostgreSQL 9.0 this is quite simple:In versions before 9.0 array_agg() can be used as shown by hgmnzI don\'t have access to a SQL Server at home, so I\'m guess at the syntax here, but it\'s more or less:A recursive CTE solution was suggested, but no code provided.  The code below is an example of a recursive CTE -- note that although the results match the question, the data doesn\'t quite match the given description, as I assume that you really want to be doing this on groups of rows, not all rows in the table.  Changing it to match all rows in the table is left as an exercise for the reader.You need to create a variable that will hold your final result and select into it, like so.In SQL Server vNext this will be built in with the STRING_AGG function, read more about it here:\nhttps://msdn.microsoft.com/en-us/library/mt790580.aspxUsing XML helped me in getting rows separated with commas. For the extra comma we can use the replace function of SQLÂ Server. Instead of adding a comma, use of the AS \'data()\' will concatenate the rows with spaces, which later can be replaced with commas as the syntax written below.A ready-to-use solution, with no extra commas:An empty list will result in NULL value.\nUsually you will insert the list into a table column or program variable: adjust the 255 max length to your need.(Diwakar and Jens Frandsen provided good answers, but need improvement.)This puts the stray comma at the beginning.However, if you need other columns, or to CSV a child table you need to wrap this in a scalar user defined field (UDF).You can use XML path as a correlated subquery in the SELECT clause too (but I\'d have to wait until I go back to work because Google doesn\'t do work stuff at home :-)To avoid null values you can use CONCAT()This answer will require some privilege in server to work.Assemblies are a good option for you. There are a lot of sites that explain how to create it. The one I think is very well explained is this oneIf you want, I have already created the assembly, and it is possible to download the DLL here.Once you have downloaded it, you will need to run the following script in your SQL Server:Observe that the path to assembly may be accessible to server. Since you have successfully done all the steps, you can use the function like:Hope it helps!!!MySQL complete Example:We have Users which can have many Data\'s and we want to have an output, where we can see all users Datas in a list:Result:Table Setup:Query: For Oracle DBs, see this question: How can multiple rows be concatenated into one in Oracle without creating a stored procedure?The best answer appears to be by @Emmanuel, using the built-in LISTAGG() function, available in Oracle 11g Release 2 and later.as @user762952 pointed out, and according to Oracle\'s documentation http://www.oracle-base.com/articles/misc/string-aggregation-techniques.php, the WM_CONCAT() function is also an option. It seems stable, but Oracle explicitly recommends against using it for any application SQL, so use at your own risk.Other than that, you will have to write your own function; the Oracle document above has a guide on how to do that.With the other answers, the person reading the answer must be aware of a specific domain table such as vehicle or student. The table must be created and populated with data to test a solution.Below is an example that uses SQL Server "Information_Schema.Columns" table. By using this solution, no tables need to be created or data added. This example creates a comma separated list of column names for all tables in the database.I usually use select like this to concatenate strings in SQL Server:This can be useful tooreturnsI really liked elegancy of Dana\'s answer. Just wanted to make it complete.If you want to deal with nulls you can do it by adding a where clause or add another COALESCE around the first one.In Oracle, it is wm_concat. I believe this function is available in the 10g release and higher.--SQL Server 2005+Not that I have done any analysis on performance as my list had less than 10 items but I was amazed after looking thru the 30 odd answers I still had a twist on a similar answer already given similar to using COALESCE for a single group list and didn\'t even have to set my variable (defaults to NULL anyhow) and it assumes all entries in my source data table are non blank:I am sure COALESCE internally uses the same idea.\nLets hope MS don\'t change this on me.