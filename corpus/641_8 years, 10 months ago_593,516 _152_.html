How can you convert a byte array to a hexadecimal string, and vice versa?Either:or:There are even more variants of doing it, for example here.The reverse conversion would go like this:Using Substring is the best option in combination with Convert.ToByte. See this answer for more information. If you need better performance, you must avoid Convert.ToByte before you can drop SubString.Note: new leader as of 2015-08-20.I ran each of the various conversion methods through some crude Stopwatch performance testing, a run with a random sentence (n=61, 1000 iterations) and a run with a Project Gutenburg text (n=1,238,957, 150 iterations). Here are the results, roughly from fastest to slowest. All measurements are in ticks (10,000 ticks = 1 ms) and all relative notes are compared to the [slowest] StringBuilder implementation. For the code used, see below or the test framework repo where I now maintain the code for running this.WARNING: Do not rely on these stats for anything concrete; they are simply a sample run of sample data. If you really need top-notch performance, please test these methods in an environment representative of your production needs with data representative of what you will use.Lookup tables have taken the lead over byte manipulation. Basically, there is some form of precomputing what any given nibble or byte will be in hex. Then, as you rip through the data, you simply look up the next portion to see what hex string it would be. That value is then added to the resulting string output in some fashion. For a long time byte manipulation, potentially harder to read by some developers, was the top-performing approach.Your best bet is still going to be finding some representative data and trying it out in a production-like environment. If you have different memory constraints, you may prefer a method with fewer allocations to one that would be faster but consume more memory.Feel free to play with the testing code I used. A version is included here but feel free to clone the repo and add your own methods. Please submit a pull request if you find anything interesting or want to help improve the testing framework it uses.Added Waleed\'s answer to analysis. Quite fast.Added string.Concat Array.ConvertAll variant for completeness (requires .NET 4.0). On par with string.Join version.Test repo includes more variants such as StringBuilder.Append(b.ToString("X2")). None upset the results any. foreach is faster than {IEnumerable}.Aggregate, for instance, but BitConverter still wins.Added Mykroft\'s SoapHexBinary answer to analysis, which took over third place.Added CodesInChaos\'s byte manipulation answer, which took over first place (by a large margin on large blocks of text).Added Nathan Moinvaziri\'s lookup answer and the variant from Brian Lambert\'s blog. Both rather fast, but not taking the lead on the test machine I used (AMD Phenom 9750).Added @CodesInChaos\'s new byte-based lookup answer. It appears to have taken the lead on both the sentence tests and the full-text tests.Added airbreather\'s optimizations and unsafe variant to this answer\'s repo. If you want to play in the unsafe game, you can get some huge performance gains over any of the prior top winners on both short strings and large texts.There\'s a class called SoapHexBinary that does exactly what you want.When writing crypto code it\'s common to avoid data dependent branches and table lookups to ensure the runtime doesn\'t depend on the data, since data dependent timing can lead to side-channel attacks.It\'s also pretty fast.Ph\'nglui mglw\'nafh Cthulhu R\'lyeh wgah\'nagl fhtagnAbandon all hope, ye who enter hereAn explanation of the weird bit fiddling:Some further considerations:If you want more flexibility than BitConverter, but don\'t want those clunky 1990s-style explicit loops, then you can do:Or, if you\'re using .NET 4.0:(The latter from a comment on the original post.)You can use the BitConverter.ToString method:Output:00-01-02-04-08-10-20-40-80-FFMore information: BitConverter.ToString Method (Byte[])I just encountered the very same problem today, and I came across this code:Source: Forum post byte[] Array to Hex String (see the post by PZahra). I modified the code a little to remove the 0x prefix.I did some performance testing to the code and it was almost eight times faster than using BitConverter.ToString() (the fastest according to patridge\'s post).Another lookup table based approach. This one uses only one lookup table for each byte, instead of a lookup table per nibble.I also tested variants of this using ushort, struct{char X1, X2}, struct{byte X1, X2} in the lookup table.Depending on the compilation target (x86, X64) those either had the approximately same performance or were slightly slower than this variant.And for even higher performance, its unsafe sibling:Or if you consider it acceptable to write into the string directly:This problem could also be solved using a look-up table. This would require a small amount of static memory for both the encoder and decoder. This method will however be fast:My solution uses 1024 bytes for the encoding table, and 256 bytes for decoding.* this solutionDuring decoding IOException and IndexOutOfRangeException could occur (if a character has a too high value > 256). Methods for de/encoding streams or arrays should be implemented, this is just a proof of concept.This is an answer to revision 4 of Tomalak\'s highly popular answer (and subsequent edits).I\'ll make the case that this edit is wrong, and explain why it could be reverted. Along the way, you might learn a thing or two about some internals, and see yet another example of what premature optimization really is and how it can bite you.tl;dr: Just use Convert.ToByte and String.Substring if you\'re in a hurry ("Original code" below), it\'s the best combination if you don\'t want to re-implement Convert.ToByte. Use something more advanced (see other answers) that doesn\'t use Convert.ToByte if you need performance. Do not use anything else other than String.Substring in combination with Convert.ToByte, unless someone has something interesting to say about this in the comments of this answer.warning: This answer may become obsolete if a Convert.ToByte(char[], Int32) overload is implemented in the framework. This is unlikely to happen soon.As a general rule, I don\'t much like to say "don\'t optimize prematurely", because nobody knows when "premature" is. The only thing you must consider when deciding whether to optimize or not is: "Do I have the time and resources to investigate optimization approaches properly?". If you don\'t, then it\'s too soon, wait until your project is more mature or until you need the performance (if there is a real need, then you will make the time). In the meantime, do the simplest thing that could possibly work instead.Original code:Revision 4:The revision avoids String.Substring and uses a StringReader instead. The given reason is:Edit: you can improve performance for long strings by using a single\n  pass parser, like so:Well, looking at the reference code for String.Substring, it\'s clearly "single-pass" already; and why shouldn\'t it be? It operates at byte-level, not on surrogate pairs.It does allocate a new string however, but then you need to allocate one to pass to Convert.ToByte anyway. Furthermore, the solution provided in the revision allocates yet another object on every iteration (the two-char array); you can safely put that allocation outside the loop and reuse the array to avoid that.Each hexadecimal numeral represents a single octet using two digits (symbols).But then, why call StringReader.Read twice? Just call its second overload and ask it to read two characters in the two-char array at once; and reduce the amount of calls by two.What you\'re left with is a string reader whose only added "value" is a parallel index (internal _pos) which you could have declared yourself (as j for example), a redundant length variable (internal _length), and a redundant reference to the input string (internal _s). In other words, it\'s useless.If you wonder how Read "reads", just look at the code, all it does is call String.CopyTo on the input string. The rest is just book-keeping overhead to maintain values we don\'t need.So, remove the string reader already, and call CopyTo yourself; it\'s simpler, clearer, and more efficient.Do you really need a j index that increments in steps of two parallel to i? Of course not, just multiply i by two (which the compiler should be able to optimize to an addition).What does the solution look like now? Exactly like it was at the beginning, only instead of using String.Substring to allocate the string and copy the data to it, you\'re using an intermediary array to which you copy the hexadecimal numerals to, then allocate the string yourself and copy the data again from the array and into the string (when you pass it in the string constructor). The second copy might be optimized-out if the string is already in the intern pool, but then String.Substring will also be able to avoid it in these cases.In fact, if you look at String.Substring again, you see that it uses some low-level internal knowledge of how strings are constructed to allocate the string faster than you could normally do it, and it inlines the same code used by CopyTo directly in there to avoid the call overhead.String.SubstringManual methodConclusion? If you want to use Convert.ToByte(String, Int32) (because you don\'t want to re-implement that functionality yourself), there doesn\'t seem to be a way to beat String.Substring; all you do is run in circles, re-inventing the wheel (only with sub-optimal materials).Note that using Convert.ToByte and String.Substring is a perfectly valid choice if you don\'t need extreme performance. Remember: only opt for an alternative if you have the time and resources to investigate how it works properly.If there was a Convert.ToByte(char[], Int32), things would be different of course (it would be possible to do what I described above and completely avoid String).I suspect that people who report better performance by "avoiding String.Substring" also avoid Convert.ToByte(String, Int32), which you should really be doing if you need the performance anyway. Look at the countless other answers to discover all the different approaches to do that.Disclaimer: I haven\'t decompiled the latest version of the framework to verify that the reference source is up-to-date, I assume it is.Now, it all sounds good and logical, hopefully even obvious if you\'ve managed to get so far.  But is it true?Yes!Props to Partridge for the bench framework, it\'s easy to hack. The input used is the following SHA-1 hash repeated 5000 times to make a 100,000 bytes long string.Have fun! (But optimize with moderation.)This is a great post. I like Waleed\'s solution. I haven\'t run it through patridge\'s test but it seems to be quite fast. I also needed the reverse process, converting a hex string to a byte array, so I wrote it as a reversal of Waleed\'s solution. Not sure if it\'s any faster than Tomalak\'s original solution. Again, I did not run the reverse process through patridge\'s test either.Complement to answer by @CodesInChaos (reversed method)Explanation:& 0x0f is to support  also lower case lettershi = hi + 10 + ((hi >> 31) & 7); is the same as:hi = ch-65 + 10 + (((ch-65) >> 31) & 7);For \'0\'..\'9\' it is the same as hi = ch - 65 + 10 + 7; which is hi = ch - 48 (this is because of 0xffffffff & 7).For \'A\'..\'F\' it is hi = ch - 65 + 10; (this is because of 0x00000000 & 7).For \'a\'..\'f\' we have to big numbers so we must subtract 32 from default version by making some bits 0 by using & 0x0f.65 is code for \'A\'48 is code for \'0\'7 is the number of letters between \'9\' and \'A\' in the ASCII table (...456789:;<=>?@ABCD...).Not to pile on to the many answers here, but I found a fairly optimal (~4.5x better than accepted), straightforward implementation of the hex string parser. First, output from my tests (the first batch is my implementation):The base64 and \'BitConverter\'d\' lines are there to test for correctness. Note that they are equal.The implementation:I tried some stuff with unsafe and moving the (clearly redundant) character-to-nibble if sequence to another method, but this was the fastest it got.(I concede that this answers half the question. I felt that the string->byte[] conversion was underrepresented, while the byte[]->string angle seems to be well covered. Thus, this answer.)Safe versions:Unsafe versions For those who prefer performance and do not afraid of unsafeness. About 35% faster ToHex and 10% faster FromHex.BTW\nFor benchmark testing initializing alphabet every time convert function called is wrong, alphabet must be const (for string) or static readonly (for char[]). Then alphabet-based conversion of byte[] to string becomes as fast as byte manipulation versions.And of course test must be compiled in Release (with optimization) and with debug option "Suppress JIT optimization" turned off (same for "Enable Just My Code" if code must be debuggable).Why make it complex? This is simple in Visual Studio 2008:C#:VB:Inverse function for Waleed Eissa code (Hex String To Byte Array):Waleed Eissa function with lower case support:Extension methods (disclaimer: completely untested code, BTW...):etc.. Use either of Tomalak\'s three solutions (with the last one being an extension method on a string).In terms of speed, this seems to be better than anything here:I did not get the code you suggested to work, Olipro. hex[i] + hex[i+1] apparently returned an int.I did, however have some success by taking some hints from Waleeds code and hammering this together. It\'s ugly as hell but it seems to work and performs at 1/3 of the time compared to the others according to my tests (using patridges testing mechanism). Depending on input size. Switching around the ?:s to separate out 0-9 first would probably yield a slightly faster result since there are more numbers than letters.This version of ByteArrayToHexViaByteManipulation could be faster.From my reports:...And I think this one is an optimization:I\'ll enter this bit fiddling competition as I have an answer that also uses bit-fiddling to decode hexadecimals. Note that using character arrays may be even faster as calling StringBuilder methods will take time as well.Converted from Java code.From Microsoft\'s developers, a nice, simple conversion:While the above is clean an compact, performance junkies will scream about it using enumerators. You can get peak performance with an improved version of Tomolak\'s original answer:This is the fastest of all the routines I\'ve seen posted here so far. Don\'t just take my word for it... performance test each routine and inspect its CIL code for yourself.And for inserting into an SQL string (if you\'re not using command parameters):Yet another variation for diversity:Not optimized for speed, but more LINQy than most answers (.NET 4.0):Two mashups which folds the two nibble operations into one.Probably pretty efficient version:Decadent linq-with-bit-hacking version:And reverse:Another way is by using stackalloc to reduce GC memory pressure:Here\'s my shot at it. I\'ve created a pair of extension classes to extend string and byte. On the large file test, the performance is comparable to Byte Manipulation 2.The code below for ToHexString is an optimized implementation of the lookup and shift algorithm. It is almost identical to the one by Behrooz, but it turns out using a foreach to iterate and a counter is faster than an explicitly indexing for.It comes in 2nd place behind Byte Manipulation 2 on my machine and is very readable code. The following test results are also of interest:ToHexStringCharArrayWithCharArrayLookup: 41,589.69 average ticks (over 1000 runs), 1.5X\nToHexStringCharArrayWithStringLookup: 50,764.06 average ticks (over 1000 runs), 1.2X\nToHexStringStringBuilderWithCharArrayLookup: 62,812.87 average ticks (over 1000 runs), 1.0XBased on the above results it seems safe to conclude that:Here\'s the code:Below are the test results that I got when I put my code in @patridge\'s testing project on my machine. I also added a test for converting to a byte array from hexadecimal. The test runs that exercised my code are ByteArrayToHexViaOptimizedLookupAndShift and HexToByteArrayViaByteManipulation. The HexToByteArrayViaConvertToByte was taken from XXXX. The HexToByteArrayViaSoapHexBinary is the one from @Mykroft\'s answer.Intel Pentium III Xeon processorConverting array of bytes into hexadecimal string representationByteArrayToHexViaByteManipulation2: 39,366.64 average ticks (over 1000 runs), 22.4XByteArrayToHexViaOptimizedLookupAndShift: 41,588.64 average ticks\n  (over 1000 runs), 21.2XByteArrayToHexViaLookup: 55,509.56 average ticks (over 1000 runs), 15.9XByteArrayToHexViaByteManipulation: 65,349.12 average ticks (over 1000 runs), 13.5XByteArrayToHexViaLookupAndShift: 86,926.87 average ticks (over 1000\n  runs), 10.2XByteArrayToHexStringViaBitConverter: 139,353.73 average\n  ticks (over 1000 runs),6.3XByteArrayToHexViaSoapHexBinary: 314,598.77 average ticks (over 1000 runs), 2.8XByteArrayToHexStringViaStringBuilderForEachByteToString: 344,264.63\n  average ticks (over 1000 runs), 2.6XByteArrayToHexStringViaStringBuilderAggregateByteToString: 382,623.44\n  average ticks (over 1000 runs), 2.3XByteArrayToHexStringViaStringBuilderForEachAppendFormat: 818,111.95\n  average ticks (over 1000 runs), 1.1XByteArrayToHexStringViaStringConcatArrayConvertAll: 839,244.84 average\n  ticks (over 1000 runs), 1.1XByteArrayToHexStringViaStringBuilderAggregateAppendFormat: 867,303.98\n  average ticks (over 1000 runs), 1.0XByteArrayToHexStringViaStringJoinArrayConvertAll: 882,710.28 average\n  ticks (over 1000 runs), 1.0XFor performance I would go with drphrozens solution. A tiny optimization for the decoder could be to use a table for either char to get rid of the "<< 4".Clearly the two method calls are costly. If some kind of check is made either on input or output data (could be CRC, checksum or whatever) the if (b == 255)... could be skipped and thereby also the method calls altogether.Using offset++ and offset instead of offset and offset + 1 might give some theoretical benefit but I suspect the compiler handles this better than me.This is just off the top of my head and has not been tested or benchmarked.If performance matters, here\'s an optimized solution:It\'s about 2.5 times faster that BitConverter.ToString, and about 7 times faster that BitConverter.ToString + removal of the \'-\' chars.