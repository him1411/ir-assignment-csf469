When my c++ app crashes I would like to generate a stacktrace.I already asked this but I guess I needed to clarify my needs.My app is being run by many different users and it also runs on Linux, Windows and Macintosh ( all versions are compiled using gcc ).I would like my program to be able to generate a stack trace when it crashes and the next time the user runs it, it will ask them if it is ok to send the stack trace to me so I can track down the problem. I can handle the sending the info to me but I don\'t know how to generate the trace string. Any ideas?For Linux and I believe Mac OS X, if you\'re using gcc, or any compiler that uses glibc, you can use the backtrace() functions in execinfo.h to print a stacktrace and exit gracefully when you get a segmentation fault.  Documentation can be found in the libc manual.Here\'s an example program that installs a SIGSEGV handler and prints a stacktrace to stderr when it segfaults.  The baz() function here causes the segfault that triggers the handler:Compiling with -g -rdynamic gets you symbol info in your output, which glibc can use to make a nice stacktrace:Executing this gets you this output:This shows the load module, offset, and function that each frame in the stack came from.  Here you can see the signal handler on top of the stack, and the libc functions before main in addition to main, foo, bar, and baz.While the use of the backtrace() functions in execinfo.h to print a stacktrace and exit gracefully when you get a segmentation fault has already been suggested, I see no mention of the intricacies necessary to ensure the resulting backtrace points to the actual location of the fault (at least for some architectures - x86 & ARM).The first two entries in the stack frame chain when you get into the signal handler contain a return address inside the signal handler and one inside sigaction() in libc. The stack frame of the last function called before the signal (which is the location of the fault) is lost.All the hazards of calling the backtrace() functions in a signal handler still exist and should not be overlooked, but I find the functionality I described here quite helpful in debugging crashes.It is important to note that the example I provided is developed/tested on Linux for x86.  I have also successfully implemented this on ARM using uc_mcontext.arm_pc instead of uc_mcontext.eip.  Here\'s a link to the article where I learned the details for this implementation:\nhttp://www.linuxjournal.com/article/6391It\'s even easier than "man backtrace", there\'s a little-documented library (GNU specific) distributed with glibc as libSegFault.so, which was I believe was written by Ulrich Drepper to support the program catchsegv (see "man catchsegv").This gives us 3 possibilities. Instead of running "program -o hai":Run within catchsegv:Link with libSegFault at runtime:Link with libSegFault at compile time:In all 3 cases, you will get clearer backtraces with less optimization (gcc -O0 or -O1) and debugging symbols (gcc -g). Otherwise, you may just end up with a pile of memory addresses.You can also catch more signals for stack traces with something like:The output will look something like this (notice the backtrace at the bottom):If you want to know the gory details, the best source is unfortunately the source: See http://sourceware.org/git/?p=glibc.git;a=blob;f=debug/segfault.c and its parent directory http://sourceware.org/git/?p=glibc.git;a=tree;f=debug Even though a correct answer has been provided that describes how to use the GNU libc backtrace() function1 and I provided my own answer that describes how to ensure a backtrace from a signal handler points to the actual location of the fault2, I don\'t see any mention of demangling C++ symbols output from the backtrace.When obtaining backtraces from a C++ program, the output can be run through c++filt1 to demangle the symbols or by using abi::__cxa_demangle1 directly.The following C++ Linux example uses the same signal handler as my other answer and demonstrates how c++filt can be used to demangle the symbols.Code:Output (./test):Demangled Output (./test 2>&1 | c++filt):The following builds on the signal handler from my original answer and can replace the signal handler in the above example to demonstrate how abi::__cxa_demangle can be used to demangle the symbols.  This signal handler produces the same demangled output as the above example.Code:Might be worth looking at Google Breakpad, a cross-platform crash dump generator and tools to process the dumps.You did not specify your operating system, so this is difficult to answer. If you are using a system based on gnu libc, you might be able to use the libc function backtrace().GCC also has two builtins that can assist you, but which may or may not be implemented fully on your architecture, and those are __builtin_frame_address and __builtin_return_address. Both of which want an immediate integer level (by immediate, I mean it can\'t be a variable). If __builtin_frame_address for a given level is non-zero, it should be safe to grab the return address of the same level.ulimit -c <value> sets the core file size limit on unix.  By default, the core file size limit is 0.  You can see your ulimit values with ulimit -a.also, if you run your program from within gdb, it will halt your program on "segmentation violations" (SIGSEGV, generally when you accessed a piece of memory that you hadn\'t allocated) or you can set breakpoints.ddd and nemiver are front-ends for gdb which make working with it much easier for the novice.is a system variable, wich will allow to create a core dump after your application crashes. In this case an unlimited amount. Look for a file called core in the very same directory. Make sure you compiled your code with debugging informations enabled!regardsIve been looking at this problem for a while.And buried deep in the Google Performance Tools READMEhttp://code.google.com/p/google-perftools/source/browse/trunk/READMEtalks about libunwindhttp://www.nongnu.org/libunwind/Would love to hear opinions of this library.The problem with -rdynamic is that it can increase the size of the binary relatively significantly in some casesSome versions of libc contain functions that deal with stack traces; you might be able to use them:http://www.gnu.org/software/libc/manual/html_node/Backtraces.htmlI remember using libunwind a long time ago to get stack traces, but it may not be supported on your platform.It\'s important to note that once you generate a core file you\'ll need to use the gdb tool to look at it.  For gdb to make sense of your core file, you must tell gcc to instrument the binary with debugging symbols: to do this, you compile with the -g flag:Then, you can either set "ulimit -c unlimited" to let it dump a core, or just run your program inside gdb.  I like the second approach more: I hope this helps.  Thank you to enthusiasticgeek for drawing my attention to the addr2line utility.I\'ve written a quick and dirty script to process the output of the answer provided here:\n(much thanks to jschmier!) using the addr2line utility.The script accepts a single argument: The name of the file containing the output from jschmier\'s utility.The output should print something like the following for each level of the trace:Code:win: How about StackWalk64 http://msdn.microsoft.com/en-us/library/ms680650.aspxForget about changing your sources and do some hacks with backtrace() function or macroses - these are just poor solutions.As a properly working solution, I would advice:This will print proper readable backtrace of your program in human readable way (with source file names and line numbers).\nMoreover this approach will give you freedom to automatize your system:\nhave a short script that checks if process created a core dump, and then send backtraces by email to developers, or log this into some logging system.You can use DeathHandler - small C++ class which does everything for you, reliable.Look at:man 3 backtraceAnd:These are GNU extensions.See the Stack Trace facility in ACE (ADAPTIVE Communication Environment).  It\'s already written to cover all major platforms (and more).  The library is BSD-style licensed so you can even copy/paste the code if you don\'t want to use ACE.I can help with the Linux version: the function backtrace, backtrace_symbols and backtrace_symbols_fd can be used. See the corresponding manual pages.*nix: \nyou can intercept SIGSEGV (usualy this signal is raised before crashing) and keep the info into a file. (besides the core file which you can use to debug using gdb for example).win:\nCheck this from msdn.You can also look at the google\'s chrome code to see how it handles crashes. It has a nice exception handling mechanism.Note that C++ symbol names are sometimes pretty garbled and the backtrace will probably be somewhat incomprehensible.More helpful backtraces will probably need evil trickery (one solution I\'ve heard of requires that you add a special macro to the beginning of all methods that you write).I would use the code that generates a stack trace for leaked memory in Visual Leak Detector. This only works on Win32, though.I have seen a lot of answers here performing a signal handler and then exiting.\nThat\'s the way to go, but remember a very important fact: If you want to get the core dump for the generated error, you can\'t call exit(status). Call abort() instead!I found that @tgamblin solution is not complete.\nIt cannot handle with stackoverflow.\nI think because by default signal handler is called with the same stack and\nSIGSEGV is thrown twice. To protect you need register an independent stack for the signal handler.You can check this with code below. By default the handler fails. With defined macro STACK_OVERFLOW it\'s all right.In addition to above answers, here how you make Debian Linux OS generate core dump The new king in town has arrived\nhttps://github.com/bombela/backward-cpp1 header place in your code and 1 library to install.Personally I call it using this functionIf your program crashes, it\'s the operating system itself that generates crash dump information. If you\'re using a *nix OS, you simply need to not prevent it from doing so (check out the ulimit command\'s \'coredump\' options).On Linux/unix/MacOSX use core files (you can enable them with ulimit or compatible system call). On Windows use Microsoft error reporting (you can become a partner and get access to your application crash data).I forgot about the GNOME tech of "apport", but I don\'t know much about using it.  It is used to generate stacktraces and other diagnostics for processing and can automatically file bugs.  It\'s certainly worth checking in to.