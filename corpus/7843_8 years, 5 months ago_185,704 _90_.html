What is the best algorithm to achieve the following:0010 0000 => 0000 0100The conversion is from MSB->LSB to LSB->MSB.  All bits must be reversed; that is, this is not endianness-swapping.NOTE: All algorithms below are in C, but should be portable to your language of choice (just don\'t look at me when they\'re not as fast :)Low Memory (32-bit int, 32-bit machine)(from here):From the famous Bit Twiddling Hacks page:Fastest (lookup table):You can extend this idea to 64-bit ints, or trade off memory for speed (assuming your L1 Data Cache is large enough), and reverse 16-bits at a time with a 64K-entry lookup table.SimpleFaster (32-bit processor)Faster (64-bit processor)If you want to do this on a 32-bit int, just reverse the bits in each bytes, and reverse the order of the bytes.  That is:I benchmarked the two most promising solutions, the lookup table, and bitwise-AND (the first one).  The test machine is a laptop w/ 4GB of DDR2-800 and a Core 2 Duo T7500 @ 2.4GHz, 4MB L2 Cache; YMMV.  I used gcc 4.3.2 on 64-bit Linux.  OpenMP (and the GCC bindings) were used for high-resolution timers.reverse.creverse_lookup.cI tried both approaches at several different optimizations, ran 3 trials at each level, and each trial reversed 100 million random unsigned ints.  For the lookup table option, I tried both schemes (options 1 and 2) given on the bitwise hacks page.  Results are shown below.Bitwise ANDLookup Table (option 1)Lookup Table (option 2)Use the lookup table, with option 1 (byte addressing is unsurprisingly slow) if you\'re concerned about performance.  If you need to squeeze every last byte of memory out of your system (and you might, if you care about the performance of bit reversal), the optimized versions of the bitwise-AND approach aren\'t too shabby either.Yes, I know the benchmark code is a complete hack.  Suggestions on how to improve it are more than welcome.  Things I know about:32-bitEDIT: I also tried using uint64_t\'s on my machine to see if there was any performance boost.  Performance was about 10% faster than 32-bit, and was nearly identical whether you were just using 64-bit types to reverse bits on two 32-bit ints at a time, or whether you were actually reversing bits in half as many 64-bit values.  The assembly code is shown below (for the former case, reversing bits for 2 32-bit ints at a time):This thread caught my attention since it deals with a simple problem that requires a lot of work (CPU cycles) even for a modern CPU. And one day I also stood there with the same \xc2\xa4#%"#" problem. I had to flip millions of bytes. However I know all my target systems are modern Intel based so lets start optimizing to the extreme!!!So I used Matt J\'s lookup code as the base. the system I\'m benchmarking on is a i7 haswell 4700eq.Matt J\'s lookup bitflipping 400 000 000 bytes: Around 0.272 seconds.I then went ahead and tried to see if Intels ISPC compiler could vectorise the arithmetics in the reverse.c.I\'m not going to bore you with my findings here since I tried a lot to help the compiler find stuff, anyhow I ended up with performance of around 0.15 seconds to bitflipp 400 000 000 bytes. it\'s a great reduction but for my application that\'s still way way to slow..So people let me present the fastest intel based bitflipper in the world. Clocked at:Time to bitflip 400000000 bytes: 0.050082 seconds !!!!! The pritf\'s for debuging..Here is the workhorse:The code takes 32 bytes then masks out the nibbles. The high nibble gets shifted right by 4. then I use vpshufb and ymm4 / ymm3 as lookup tables. I could use a single lookup table but then I would have to shift left before oring the nibbles together again.There are even faster ways of flipping the bits. But I\'m bound to single thread and CPU so this was the fastest I could achieve. Can you make a faster version?Please make no comments about using the Intel C/C++ Compiler Intrinsic Equivalent commands...This is another solution for folks who love recursion.The idea is simple. \nDivide up input by half and swap the two halves, continue till it it reaches single bit.Here is a recursive function to solve it. (Note I have used unsigned ints, so it can work for inputs upto sizeof(unsigned int)*8 bits.The recursive function takes 2 parameters - The value whose bits need\n  to be reversed and the number of bits in the value.This is the output:Presuming that you have an array of bits, how about this:\n 1. Starting from MSB, push bits into a stack one by one.\n 2. Pop bits from this stack into another array (or the same array if you want to save space), placing the first popped bit into MSB and going on to less significant bits from there.Well this certainly won\'t be an answer like Matt J\'s but hopefully it will still be useful.This is exactly the same idea as Matt\'s best algorithm except that there\'s this little instruction called BSWAP which swaps the bytes (not the bits) of a 64-bit number.  So b7,b6,b5,b4,b3,b2,b1,b0 becomes b0,b1,b2,b3,b4,b5,b6,b7.  Since we are working with a 32-bit number we need to shift our byte-swapped number down 32 bits.  This just leaves us with the task of swapping the 8 bits of each byte which is done and voila! we\'re done.Timing: on my machine, Matt\'s algorithm ran in ~0.52 seconds per trial.  Mine ran in about 0.42 seconds per trial.  20% faster is not bad I think.If you\'re worried about the availability of the instruction BSWAP Wikipedia lists the instruction BSWAP as being added with 80846 which came out in 1989.  It should be noted that Wikipedia also states that this instruction only works on 32 bit registers which is clearly not the case on my machine, it very much works only on 64-bit registers.This method will work equally well for any integral datatype so the method can be generalized trivially by passing the number of bytes desired:which can then be called like:The compiler should be able to optimize the extra parameter away (assuming the compiler inlines the function) and for the sizeof(size_t) case the right-shift would be removed completely.  Note that GCC at least is not able to remove the BSWAP and right-shift if passed sizeof(char).Anders Cedronius\'s answer provides a great solution for people that have an x86 CPU with AVX2 support. For x86 platforms without AVX support or non-x86 platforms, either of the following implementations should work well.The first code is a variant of the classic binary partitioning method, coded to maximize the use of the shift-plus-logic idiom useful on various ARM processors. In addition, it uses on-the-fly mask generation which could be beneficial for RISC processors that otherwise require multiple instructions to load each 32-bit mask value. Compilers for x86 platforms should use constant propagation to compute all masks at compile time rather than run time.In volume 4A of "The Art of Computer Programming", D. Knuth shows clever ways of reversing bits that somewhat surprisingly require fewer operations than the classical binary partitioning algorithms. One such algorithm for 32-bit operands, that I cannot find in TAOCP, is shown in this document on the Hacker\'s Delight website.Using the Intel compiler C/C++ compiler 13.1.3.198, both of the above functions auto-vectorize nicely targetting XMM registers. They could also be vectorized manually without a lot of effort.On my IvyBridge Xeon E3 1270v2, using the auto-vectorized code, 100 million uin32_t words were bit-reversed in 0.070 seconds using brev_classic(), and 0.068 seconds using brev_knuth(). I took care to ensure that my benchmark was not limited by system memory bandwidth.Of course the obvious source of bit-twiddling hacks is here:\nhttp://graphics.stanford.edu/~seander/bithacks.html#BitReverseObviousI know it isn\'t C but asm:This works with the carry bit, so you may save flags tooImplementation with low memory and fastest.     You might want to use the standard template library. It might be slower than the above mentioned code. However, it seems to me clearer and easier to understand. GenericC code. Using 1 byte input data num as example.How about the following:Small and easy (though, 32 bit only).I was curious how fast would be the obvious raw rotation.\nOn my machine (i7@2600), the average for 1,500,150,000 iterations was 27.28 ns (over a a random set of 131,071 64-bit integers).Advantages: the amount of memory needed is little and the code is simple. I would say it is not that large, either. The time required is predictable and constant for any input (128 arithmetic SHIFT operations + 64 logical AND operations + 64 logical OR operations).I compared to the best time obtained by @Matt J - who has the accepted answer. If I read his answer correctly, the best he has got was 0.631739 seconds for 1,000,000 iterations, which leads to an average of 631 ns per rotation.The code snippet I used is this one below:This ain\'t no job for a human! ... but perfect for a machineThis is 2015, 6 years from when this question was first asked. Compilers have since become our masters, and our job as humans is only to help them. So what\'s the best way to give our intentions to the machine?Bit-reversal is so common that you have to wonder why the x86\'s ever growing ISA doesn\'t include an instruction to do it one go.The reason: if you give your true concise intent to the compiler, bit reversal should only take ~20 CPU cycles. Let me show you how to craft reverse() and use it:Compiling this sample program with Clang version >= 3.6, -O3, -march=native (tested with Haswell), gives artwork-quality code using the new AVX2 instructions, with a runtime of 11 seconds processing ~1 billion reverse()s. That\'s ~10 ns per reverse(), with .5 ns CPU cycle assuming 2 GHz puts us at the sweet 20 CPU cycles.Caveat: this sample code should hold as a decent benchmark for a few years, but it will eventually start to show its age once compilers are smart enough to optimize main() to just printf the final result instead of really computing anything. But for now it works in showcasing reverse().Native ARM instruction "rbit" can do it with 1 cpu cycle and 1 extra cpu register, impossible to beat.Well, this is basically the same as the first "reverse()" but it is 64 bit and only needs one immediate mask to be loaded from the instruction stream. GCC creates code without jumps, so this should be pretty fast.I thought this is one of the simplest way to reverse the bit. \nplease let me know if there is any flaw in this logic. \nbasically in this logic, we check the value of the bit in position.\nset the bit if value is 1 on reversed position.Bit reversal in pseudo codesource -> byte to be reversed b00101100\n destination -> reversed, also needs to be of unsigned type so sign bit is not propogated downcopy into temp so original is unaffected, also needs to be of unsigned type so that sign bit is not shifted in automaticalyLOOP8:  //do this 8 times\n    test if bytecopy is < 0 (negative)The Question asked is for reversing a byte (8 Bits of data)I think the simplest method I know follows. MSB is input and LSB is \'reversed\' output:// reading the input integer "num" in LSB->MSB order and storing in num_reverse in MSB->LSB order.Another loop-based solution that exits quickly when the number is low (in C++ for multiple types)or in C for an unsigned intIt seems that many other posts are concerned about speed (i.e best = fastest).\nWhat about simplicity? Consider:and hope that clever compiler will optimise for you.If you want to reverse a longer list of bits (containing sizeof(char) * n bits), you can use this function to get:This would reverse [10000000, 10101010] into [01010101, 00000001].My simple solution  