See code: Newer Edit: Lots of things have changed since this question was initially posted - there\'s a lot of really good information in wallacer\'s revised answer as well as VisioN\'s excellent breakdownEdit: Just because this is the accepted answer; wallacer\'s answer is indeed much better:My old answer:Should do it.Edit: In response to PhiLho\'s comment, use something like:Keep it simple  :) Edit:This is another non-regex solution that I believe is more efficient:There are some corner cases that are better handled by VisioN\'s answer below, particularly files with no extension (.htaccess etc included).It\'s very performant, and handles corner cases in an arguably better way by returning "" instead of the full string when there\'s no dot or no string before the dot.  It\'s a very well crafted solution, albeit tough to read.  Stick it in your helpers lib and just use it.Old Edit:A safer implementation if you\'re going to run into files with no extension, or hidden files with no extension (see VisioN\'s comment to Tom\'s answer above) would be something along these linesIf a.length is one, it\'s a visible file with no extension ie. fileIf a[0] === "" and a.length === 2 it\'s a hidden file with no extension ie. .htaccessHope this helps to clear up issues with the slightly more complex cases.  In terms of performance, I believe this solution is a little slower than regex in most browsers.  However, for most common purposes this code should be perfectly usable.The following solution is fast and short enough to use in bulk operations and save extra bytes:Here is another one-line non-regexp universal solution:Both work correctly with names having no extension (e.g. myfile) or starting with . dot (e.g. .htaccess):If you care about the speed you may run the benchmark and check that the provided solutions are the fastest, while the short one is tremendously fast:How the short one works:If you want more clear solution which will work in the same way (plus with extra support of full path), check the following extended version. This solution will be slower than previous one-liners but is much easier to understand.All three variants should work in any web browser on the client side and can be used in the server side NodeJS code as well.Tested with Also CodeTestNotice that in the absence of a query, the fragment might still be present.JSLint0 Warnings.Try this:i just wanted to share this.although this has a downfall that files with no extension will return last string.\nbut if you do so this will fix every thing :Fast and works correctly with pathsSome edge casesSolutions using split are slow and solutions with lastIndexOf don\'t handle edge cases.edit: Strangely (or maybe it\'s not) the $1 in the second argument of the replace method doesn\'t seem to work... Sorry.I just realized that it\'s not enough to put a comment on p4bl0\'s answer, though Tom\'s answer clearly solves the problem:For most applications, a simple script such as would work just fine (as provided by Tom). However this is not fool proof. It does not work if the following file name is provided:It may be a bit overkill but I would suggest using a url parser such as this one to avoid failure due to unpredictable filenames.Using that particular function, you could get the file name like this:This will output "image.jpg" without the url vars. Then you are free to grab the file extension.//usageextension(\'file.jpeg\')always returns the extension lower cas so you can check it on field change\nworks for:file.JpEgfile         (no extension)file.        (noextension)I\'m many moons late to the party but for simplicity I use something like thisA one line solution that will also account for query params and any characters in url.If you are looking for a specific extension and know its length, you can use substr:JavaScript reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substrIn node.js, this can be achieved by the following code:Wallacer\'s answer is nice, but one more checking is needed.If file has no extension, it will use filename as extension which is not good.Try this one:Don\'t forget that some files can have no extension, so:This is a better approach imo. 