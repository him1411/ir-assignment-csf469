I have;Is there a (easy) way to retrieve the generic type of the list?If those are actually fields of a certain class, then you can get them with a little help of reflection:You can also do that for parameter types and return type of methods.But if they\'re inside the same scope of the class/method where you need to know about them, then there\'s no point of knowing them, because you already have declared them yourself.Short answer: no.This is probably a duplicate, can\'t find an appropriate one right now.Java uses something called type erasure, which means at runtime both objects are equivalent. The compiler knows the lists contain integers or strings, and as such can maintain a type safe environment. This information is lost (on an object instance basis) at runtime, and the list only contain \'Objects\'.You CAN find out a little about the class, what types it might be parametrized by, but normally this is just anything that extends "Object", i.e. anything. If you define a type asAClass.class will only contain the fact that the parameter A is bounded by MyClass, but more than that, there\'s no way to tell.You can do the same for method parameters as well:If you need to get the generic type of a returned type, I used this approach when I needed to find methods in a class which returned a Collection and then access their generic types:This outputs:Generic type is class java.lang.StringExpanding on Steve K\'s answer:At runtime, no, you can\'t.However via reflection the type parameters are accessible. TryThe method getGenericType() returns a Type object. In this case, it will be an instance of ParametrizedType, which in turn has methods getRawType() (which will contain List.class, in this case) and getActualTypeArguments(), which will return an array (in this case, of length one, containing either String.class or Integer.class).The generic type of a collection should only matter if it actually has objects in it, right? So isn\'t it easier to just do:There\'s no such thing as a generic type in runtime, but the objects inside at runtime are guaranteed to be the same type as the declared generic, so it\'s easy enough just to test the item\'s class before we process it.For finding generic type of one field:As others have said, the only correct answer is no, the type has been erased.If the list has a non-zero number of elements, you could investigate the type of the first element ( using it\'s getClass method, for instance ). That won\'t tell you the generic type of the list, but it would be reasonable to assume that the generic type was some superclass of the types in the list.I wouldn\'t advocate the approach, but in a bind it might be useful.Generally impossible, because List<String> and List<Integer> share the same runtime class.You might be able to reflect on the declared type of the field holding the list, though (if the declared type does not itself refer to a type parameter whose value you don\'t know).The type is erased so you will not be able to. See http://en.wikipedia.org/wiki/Type_erasure and http://en.wikipedia.org/wiki/Generics_in_Java#Type_erasureHad the same problem, but I used instanceof instead. Did it this way:This involves using unchecked casts so only do this when you know it is a list, and what type it can be. 