I have the branch master which tracks the remote branch origin/master.I want to rename them to master-old both locally and on the remote. Is that possible? For other users who tracked origin/master (and who always updated their local master branch via git pull), what would happen after I renamed the remote branch? Would their git pull still work or would it throw an error that it couldn\'t find origin/master anymore?Then, further on, I want to create a new master branch (both locally and remote). Again, after I did this, what would happen now if the other users do git pull?I guess all this would result in a lot of trouble. Is there a clean way to get what I want? Or should I just leave master as it is and create a new branch master-new and just work there further on?The closest thing to renaming is deleting and then re-creating on the remote. For example:However this has a lot of caveats. First, no existing checkouts will know about the rename - git does not attempt to track branch renames. If the new master doesn\'t exist yet, git pull will error out. If the new master has been created. the pull will attempt to merge master and master-old. So it\'s generally a bad idea unless you have the cooperation of everyone who has checked out the repository previously.Note: Newer versions of git will not allow you to delete the master branch remotely by default. You can override this by setting the receive.denyDeleteCurrent configuration value to warn or ignore on the remote repository. Otherwise, if you\'re ready to create a new master right away, skip the git push remote :master step, and pass --force to the git push remote master step. Note that if you\'re not able to change the remote\'s configuration, you won\'t be able to completely delete the master branch!This caveat only applies to the current branch (usually the master branch); any other branch can be deleted and recreated as above.Assuming you are currently on master:(If you do it in any other way, you need at least one more step to ensure that master-old is properly set up to track origin/master-old. None of the other solutions posted at the time of this writing include that.)With Git v1.7, I think this has changed slightly. Updating your local branch\'s tracking reference to the new remote is now very easy.You may have to manually switch to new-branch-name before deleting old-branch-nameThere are many ways to rename the branch, but I am going to focus on the bigger problem: "how to allow clients to fast-forward and not have to mess with their branches locally".First a quick picture:\nThis is something actually easy to do; but don\'t abuse it.\nThe whole idea hinges on merge commits; as they allow fast-forward, and link histories of a branch with another.This works because creating a merge commit allows fast-forwarding the branch to a new revision.I\'m assuming you\'re still asking about the same situation as in your previous question. That is, master-new will not contain master-old in its history.* If you call master-new "master", you will effectively have rewritten history. It does not matter how you get into a state in which master is not a descendant of a previous position of master, simply that it is in that state. Other users attempting to pull while master does not exist will simply have their pulls fail (no such ref on remote), and once it exists again in a new place, their pulls will have to attempt to merge their master with the new remote master, just as if you merged master-old and master-new in your repository. Given what you\'re trying to do here, the merge would have conflicts. (If they were resolved, and the result was pushed back into the repository, you\'d be in an even worse state - both versions of history there.)To answer your question simply: you should accept that sometimes there will be mistakes in your history. This is okay. It happens to everyone. There are reverted commits in the git.git repository. The important thing is that once we publish history, it is something everyone can trust.*If it did, this would be equivalent to pushing some changes onto master, and then creating a new branch where it used to be. No problem.The selected answer failed when I tried it. It throws an error: refusing to delete the current branch: refs/heads/master. I guess I\'ll post what works for me:The trick is to checkout to the placeholder right before pushing it to remote repository. The rest is self explanatory, deleting the master branch and push it to the remote repository should works now. Excerpted from here.Good. My 2 cents. How about loggin in at the server, going to the git directory and renaming the branch in the bare repository. This does not have all the problems associated with reuploading the same branch. Actually, the \'clients\' will automatically recognize the modified name and change their remote reference. Afterwards (or before) you can also modify the local name of the branch.What about:OK, renaming a branch both locally and on the remote is pretty easy!...If you on the branch, you can do:git branch -m <branch>or if not, you need to do:git branch -m <your_old_branch> <your_new_branch>Then, push deletion to the remote like this:git push origin <your_old_branch>Now you done, if you get upstream error while you trying to push, simply do:git push --set-upstream origin <your_new_branch>I also create the image below to show the steps in real command line, just follow the steps and you would be good:You may do the following:But force pushing is a bad idea if other people are sharing this repository. Force push will cause their revision history to conflict with the new one.I believe the key is the realization that you are performing a double rename: master to master-old and also master-new to master.From all the other answers I have synthesized this:where we first have to define the doublerename Bash function:This is similar to a history-changing git rebase in that the branch contents is quite different, but it differs in that the clients can still safely fast-forward with git pull master.