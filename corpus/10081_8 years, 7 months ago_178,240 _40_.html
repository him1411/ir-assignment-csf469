My question is about when a function should be referenced with the extern keyword in C.I am failing to see when this should be used in practice.  As I am writing a program all of the functions that I use are made available through the header files I have included.  So why would it be useful to extern to get access to something that was not exposed in the header file?I could be thinking about how extern works incorrectly, and if so please correct me.Edit: Should you extern something when it is the default declaration without the keyword in a header file?"extern" changes the linkage. With the keyword, the function / variable is assumed to be available somewhere else and the resolving is deferred to the linker.There\'s a difference between "extern" on functions and on variables: on variables it doesn\'t instantiate the variable itself, i.e. doesn\'t allocate any memory. This needs to be done somewhere else. Thus it\'s important if you want to import the variable from somewhere else. For functions, this only tells the compiler that linkage is extern. As this is the default (you use the keyword "static" to indicate that a function is not bound using extern linkage) you don\'t need to use it explicitly.extern tells the compiler that this data is defined somewhere and will be connected with the linker.With the help of the responses here and talking to a few friends here is the practical example of a use of extern.Example 1 - to show a pitfall:If myCFile1.o and myCFile2.o are linked, each of the c files have separate copies of errno.  This is a problem as errno is suppose to be constant over all linked files.Example 2 - The fix.Now if both myCFile1.o and MyCFile2.o are linked by the linker they will both point to the same errno.  Thus, solving the implementation with extern.It has already been stated that the extern keyword is redundant for functions.As for variables shared across compilation units, you should declare them in a header file with the extern keyword, then define them in a single source file, without the extern keyword. The single source file should be the one sharing the header file\'s name, for best practice.In C, \'extern\' is implied for function prototypes, as a prototype declares a function which is defined somewhere else. In other words, a function prototype has external linkage by default; using \'extern\' is fine, but is redundant.(If static linkage is required, the function must be declared as \'static\' both in its prototype and function header, and these should normally both be in the same .c file).A very good article that I came about the extern keyword, along with the examples: http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/Though I do not agree that using extern in function declarations is redundant. This is supposed to be a compiler setting. So I recommend using the extern in the function declarations when it is needed. If each file in your program is first compiled to an object file, then the object files are linked together, you need extern. It tells the compiler "This function exists, but the code for it is somewhere else. Don\'t panic."Many years later, I discover this question. After reading every answers and comments, I though I could clarify a few details ... This could be useful for people who get here thru goggle search.The question is specifically about using "extern" functions, so I will ignore the use of "extern" with global variables. Let\'s define 3 function prototypesThe header file can be used by the main source code as followIn order to compile and link, we must define "function_2" in the same source code file where we call that function. The two other functions could be defined in a different source code ".C" or they may be located in any binary file (.OBJ, *.LIB, *.DLL), for which we may not have the source code.Lets include again the header "my_project.H" in a different "*.C" file to understand better the difference.\nIn the same project, we add the following file\n//--------------------------------------Important features to notice:\nWhen a function is defined as "static" in a header file, the compiler / linker must find an instance of a function with that name in each module which use that include file.A function which is part of the C library can be replaced in only one module by redefining a prototype with "static" only in that module. For example, replace any call to "malloc" and "free" to add memory leak detection feature.The specifier "extern" is not really needed for functions. When "static" is not found, a function is always assumed to be "extern\'.However, "extern" is not the default for variables. Normally, any header file that define variables to be visible across many modules need to use "extern". The only exception would be if a header file is guaranteed to be included from one and only one module.Many project manager would then require that such variable be placed at the beginning of the module, not inside any header file. Some large projects, such as the video game emulator "Mame" even require that such variable appear only above the first function using them.All declarations of functions and variables in header files should be extern.Exceptions to this rule are inline functions defined in the header and variables which - although defined in the header - will have to be local to the translation unit (the source file the header gets included into): these should be static.In source files, extern shouldn\'t be used for functions and variables defined in the file. Just prefix local definitions with static and do nothing for shared definitions - they\'ll be external symbols by default.The only reason to use extern at all in a source file is to declare functions and variables which are defined in other source files and for which no header file is provided.Declaring function prototypes extern is actually unnecessary. Some people dislike it because it will just waste space and function declarations already have a tendency to overflow line limits. Others like it because this way, functions and variables can be treated the same way.When you have that function defined on a different dll or lib, so that the compiler defers to the linker to find it. Typical case is when you are calling functions from the OS API.Functions actually defined in other source files should only be declared in headers. In this case, you should use extern when declaring the prototype in a header.Most of the time, your functions will be one of the following (more like a best practice):Extern: \n"extern keyword by default it presents before any variable declaration. The compiler hides it.  When you want to declare a function and it defined in somewhere of the project file, in such conditions extern play a good role. For example, just consider a socket program, you are using the #include. If you are a Linux user, locate a file socket.h in your machine and open it. You can in lots of extern function declarations. It means, your header "socket.h" declared all the required functions, that will get load when you starts the compilation. Those extern functions are defined somewhere in socket binaries. You need to just include the header file. It\'s a linker responsibility to load the binary for execution. All above-mentioned examples tell about the usage, I just extended into OS level. 