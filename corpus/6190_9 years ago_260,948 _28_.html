What would be your preferred way to concatenate strings from a sequence such that between each two consecutive pair a comma is added. That is, how do you map, for instance, [ \'a\', \'b\', \'c\' ] to \'a,b,c\'? (The cases [ s ] and [] should be mapped to s and \'\', respectively.)I usually end up using something like \'\'.join(map(lambda x: x+\',\',l))[:-1], but also feeling somewhat unsatisfied.Edit: I\'m both ashamed and happy that the solution is so simple. Obviously I have hardly a clue as to what I\'m doing. (I probably needed "simple" concatenation in the past and somehow memorised s.join([e1,e2,...]) as a shorthand for s+e1+e2+....)This won\'t work if the list contains numbers.As Ricardo Reyes suggested, if it contains non-string types (such as integers, floats, bools, None) then do:Why the map/lambda magic? Doesn\'t this work?Edit: @mark-biek points out the case for numbers.\nPerhaps the list comprehension:is more "pythonic".Edit2:\nThanks for the suggestions. I\'ll use the generator rather than the list comprehension in the future.Don\'t you just want:Obviously it gets more complicated if you need to quote/escape commas etc in the values. In that case I would suggest looking at the csv module in the standard library:https://docs.python.org/library/csv.html@Peter HoffmannUsing generator expressions has the benefit of also producing an iterator but saves importing itertools. Furthermore, list comprehensions are generally preferred to map, thus, I\'d expect generator expressions to be preferred to imap.Here is a alternative solution in Python 3.0 which allows non-string list items:a standard waythe alternative solutionNOTE: The space after comma is intentional.",".join(l) will not work for all cases. I\'d suggest using the csv module with StringIO@jmanning2k using a list comprehension has the downside of creating a new temporary list. The better solution would be using itertools.imap which returns an iteratorfor converting list containing numbers do the following:Unless I\'m missing something, \',\'.join(foo) should do what you\'re asking for.(edit:  and as jmanning2k points out, is safer and quite Pythonic, though the resulting string will be difficult to parse if the elements can contain commas -- at that point, you need the full power of the csv module, as Douglas points out in his answer.)my_list may contain any type of variables. This avoid the result \'A,,,D,E\'.Here is an example with listMore Accurate:-Example 2:-