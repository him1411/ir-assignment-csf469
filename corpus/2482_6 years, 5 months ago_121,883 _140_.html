I\'m using the ExpressJS web framework for NodeJS.People using ExpressJS put their environments (development, production, test...), their routes etc on the app.js. I think that it\'s not a beautiful way because when you have a big application, app.js is too big!I would like to have this directory structure:Here\'s my code:app.jsconfig/environment.jsconfig/routes.jsMy code works well and I think that the structure of the directories is beautiful. However, the code had to be adapted and I\'m not sure that it\'s good/beautiful.Is it better to use my structure of directories and adapt the code or simply use one file (app.js)?Thanks for your advices!OK, it\'s been a while and this is a popular question, so I\'ve gone ahead and created a scaffolding github repository with JavaScript code and a long README about how I like to structure a medium-sized express.js application.focusaurus/express_code_structure is the repo with the latest code for this. Pull requests welcome.Here\'s a snapshot of the README since stackoverflow doesn\'t like just-a-link answers. I\'ll make some updates as this is a new project that I\'ll continue updating, but ultimately the github repo will be the up-to-date place for this information.This project is an example of how to organize a medium-sized express.js web application.Current to at least express v4.14 December 2016Web applications are not all the same, and there\'s not, in my opinion, a single code structure that should be applied to all express.js applications.If your application is small, you don\'t need such a deep directory structure as exemplified here. Just keep it simple and stick a handful of .js files in the root of your repository and you\'re done. Voil\xc3\xa0.If your application is huge, at some point you need to break it up into distinct npm packages. In general the node.js approach seems to favor many small packages, at least for libraries, and you should build your application up by using several npm packages as that starts to make sense and justify the overhead. So as your application grows and some portion of the code becomes clearly reusable outside of your application or is a clear subsystem, move it to it\'s own git repository and make it into a standalone npm package.So the focus of this project is to illustrate a workable structure for a medium-sized application.There are many approaches to building a web application, such asEach of these fits nicely into a different directory structure. For the purposes of this example, it\'s just scaffolding and not a fully working app, but I\'m assuming the following key architecture points:It will be a theme throughout this project that many of the ideas embodied in Ruby on Rails and the "Convention over Configuration" decisions they have adopted, though widely accepted and used, are not actually very helpful and sometimes are the opposite of what this repository recommends.My main point here is that there are underlying principles to organizing code, and based on those principles, the Ruby on Rails conventions make sense (mostly) for the Ruby on Rails community. However, just thoughtlessly aping those conventions misses the point. Once you grok the basic principles, ALL of your projects will be well-organized and clear: shell scripts, games, mobile apps, enterprise projects, even your home directory.For the Rails community, they want to be able to have a single Rails developer switch from app to app to app and be familiar and comfortable with it each time. This makes great sense if you are 37 signals or Pivotal Labs, and has benefits. In the server-side JavaScript world, the overall ethos is just way more wild west anything goes and we don\'t really have a problem with that. That\'s how we roll. We\'re used to it. Even within express.js, it\'s a close kin of Sinatra, not Rails, and taking conventions from Rails is usually not helping anything. I\'d even say Principles over Convention over Configuration.Use lower-kebab-case filenamesDon\'t use app.configure. It\'s almost entirely useless and you just don\'t need it. It is in lots of boilerplate due to mindless copypasta.There are many approaches outlined and discussed at length by the community in the great gist Better local require() paths for Node.js. I may soon decide to prefer either "just deal with lots of ../../../.." or use the requireFrom modlue. However, at the moment, I\'ve been using the symlink trick detailed below.So one way to avoid intra-project requires with annoying relative paths like require("../../../config") is to use the following trick:Generally code modules and classes to expect only a basic JavaScript options object passed in. Only app/server.js should load the app/config.js module. From there it can synthesize small options objects to configure subsystems as needed, but coupling every subsystem to a big global config module full of extra information is bad coupling.Try to centralize creation of DB connections and pass those into subsystems as opposed to passing connection parameters and having subsystems make outgoing connections themselves.This is another enticing but terrible idea carried over from Rails. There should be exactly 1 place in your app, app/config.js that looks at the NODE_ENV environment variable. Everything else should take an explicit option as a class constructor argument or module configuration parameter.If the email module has an option as to how to deliver emails (SMTP, log to stdout, put in queue etc), it should take an option like {deliver: \'stdout\'} but it should absolutely not check NODE_ENV.I now keep my test files in the same directory as their corresponding code and use filename extension naming conventions to distinguish tests from production code.I use filesystem globs and the find . -name \'*.tape.js\' command to get access to all my tests as necessary.This project\'s scope is mostly about where files and directories go, and I don\'t want to add much other scope, but I\'ll just mention that I organize my code into 3 distinct sections.UPDATE (2013-10-29): Please see my other answer as well which has JavaScript instead of CoffeeScript by popular demand as well as a boilerplate github repo and an extensive README detailing my latest recommendations on this topic.ConfigWhat you are doing is fine.  I like to have my own config namespace set up in a top-level config.coffee file with a nested namespace like this.This is friendly for sysadmin editing.  Then when I need something, like the DB connection info, it`sRoutes/ControllersI like to leave my routes with my controllers and organize them in an app/controllers subdirectory.  Then I can load them up and let them add whatever routes they need.In my app/server.coffee coffeescript file I do:So I have files like:And for example in my domains controller, I have a setup function like this.ViewsPutting views in app/views is becoming the customary place.  I lay it out like this.Static FilesGo in a public subdirectory.Github/Semver/NPMPut a README.md markdown file at your git repo root for github.Put a package.json file with a semantic version number in your git repo root for NPM.The following is Peter Lyons\' answer verbatim, ported over to vanilla JS from Coffeescript, as requested by several others. Peter\'s answer is very able, and anyone voting on my answer should vote on his as well.ConfigWhat you are doing is fine.  I like to have my own config namespace set up in a top-level config.js file with a nested namespace like this.This is friendly for sysadmin editing.  Then when I need something, like the DB connection info, it`sRoutes/ControllersI like to leave my routes with my controllers and organize them in an app/controllers subdirectory.  Then I can load them up and let them add whatever routes they need.In my app/server.js javascript file I do:So I have files like:And for example in my domains controller, I have a setup function like this.ViewsPutting views in app/views is becoming the customary place.  I lay it out like this.Static FilesGo in a public subdirectory.Github/Semver/NPMPut a README.md markdown file at your git repo root for github.Put a package.json file with a semantic version number in your git repo root for NPM.My question was introduced in April 2011, it\'s quiet old. During this time, I could improve my experience with Express.js and how to architecture an application written using this library. So, I share here my experience.Here\'s my directory structure:App.jsThe goal of the app.js file is to bootstrap the expressjs application. It loads the configuration module, the logger module, wait for database connection, ..., and run the express server.routes/The routes directory has a index.js file. Its goal is to introduce a kind of magic to load  all other files inside the routes/ directory. Here\'s the implementation:With that module, creating a new route definition and implementation is really easy. For examples, hello.js:Each route module is standalone.I like to use a global "app", rather than exporting a function etcI think it\'s a great way to do it. Not limited to express but I\'ve seen quite a number of node.js projects on github doing the same thing. They take out the configuration parameters + smaller modules (in some cases every URI) are factored in separate files.I would recommend going through express-specific projects on github to get an idea. IMO the way you are doing is correct.it is now End of 2015 and after developing my structure for 3 years and in small and large projects. Conclusion?Do not do one large MVC, but separate it in modulesSo...Why?Usually one works on one module (e.g. Products), which you can change independently. You are able to reuse modulesYou are able to test it separatlyYou are able to replace it separatlyThey have clear (stable) interfaces-At latest, if there were multiple developers working, module separation helpsThe nodebootstrap project has a similar approach to my final structure. (github)How does this structure look like?Small, capsulated modules, each with separate MVCEach module has a package.jsonTesting as a part of the structure (in each module)Global configuration, libraries and ServicesIntegrated Docker, Cluster, foreverFolderoverview (see lib folder for modules):I don\'t think it\'s a good approach to add routes to config. A better structure could be smth like that: So products.js and users.js will contain all your routes will all logic within.It\'s been quite a while since the last answer to this question and Express has also recently released version 4, which added a few useful things for organising your app structure.Below is a long up to date blog post about best practices on how to structure your Express app.\nhttp://www.terlici.com/2014/08/25/best-practices-express-structure.htmlThere is also a GitHub repository applying the advice in the article. It is always up to date with the latest Express version.\nhttps://github.com/terlici/base-expressWell I put my routes as a json file, that I read at the beginning, and in a for-loop in app.js set up the routes. The route.json includes which view that should be called, and the key for the values that will be sent into the route.\nThis works for many simple cases, but I had to manually create some routes for special cases.This may be of interest:https://github.com/flatiron/nconfHierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.I came across this MVC structure http://www.travisglines.com/web-coding/a-simple-mvc-setup-in-node-js1) Your Express project filesystem maybe like:app.js - you global app container2) Module main file (lib/mymodule/index.js):3) Connect module in main app.js4) Sample logic  tj says/show on Vimeo interesting idea how modularize express application - \nModular web applications with Node.js and Express. Powerful and simple.http://locomotivejs.org/ provides a way to structure an app built with Node.js and Express.From the website:"Locomotive is a web framework for Node.js. Locomotive supports MVC\n  patterns, RESTful routes, and convention over configuration, while\n  integrating seamlessly with any database and template engine.\n  Locomotive builds on Express, preserving the power and simplicity\n  you\'ve come to expect from Node."I have written a post exactly about this matter. It basically makes use of a routeRegistrar that iterates through files in the folder /controllers calling its function init. Function init takes the express app variable as a parameter so you can register your routes the way you want.I am giving MVC style folder structure please find bellow .We used bellow folder structure for our big and medium web applications .I have created one npm module for generation express mvc folder structurer.Please find the bellow   https://www.npmjs.com/package/express-mvc-generatorJust simple steps to generate and use this modules .i) install module npm install express-mvc-generator -g ii) check options express -hiii) Generate express mvc structure express myappiv) Install dependencies: npm install:v)Open your config/database.js , Please configure your mongo db.vi)Run the application node app or nodemon app vii)Check URL http://localhost:8042/signup OR http://yourip:8042/signupThis is how most of my express project directory structure looks.I usually do a express dirname to initialise the project, forgive my laziness, but it\'s very flexible and extendable. PS - you need to get express-generator for that (for those who\'re looking for it sudo npm install -g express-generator, sudo because you\'re installing it globally)You must be wondering why .env files? Because they work! I use dotenv module in my projects (a lot recently) and it works! Pop in these 2 statements in app.js or wwwAnd another line to quickly set /bower_components to serve static content under the resource /extIt probably can be a fit for people who\'re looking to use Express and Angular together, or just express without that javascripts hierarchy of course.I recently embraced modules as independent mini-apps.Now for any module routing (#.js), views (*.ejs), js, css and assets are next to each other.\nsubmodule routing is set up in the parent #.js with two additional linesThis way even subsubmodules are possible.Don\'t forget to set view to the src directory