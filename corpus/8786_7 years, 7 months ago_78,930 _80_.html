What\'s the best way to parse command-line parameters in Scala?\nI personally prefer something lightweight that does not require external jar.Related:For most cases you do not need an external parser. Scala\'s pattern matching allows consuming args in a functional style. For example:will print, for example:This version only takes one infile. Easy to improve on (by using a List).Note also that this approach allows for concatenation of multiple command line arguments - even more than two!The above generates the following usage text:This is what I currently use. Clean usage without too much baggage.\n(Disclaimer: I now maintain this project)I realize that the question was asked some time ago, but I thought it might help some people, who are googling around (like me), and hit this page.Scallop looks quite promising as well.Features (quote from the linked github page):And some example code (also from that Github page):I like sliding over arguments for relatively simple configurations.This is largely a shameless clone of my answer to the Java question of the same topic.  It turns out that JewelCLI is Scala-friendly in that it doesn\'t require JavaBean style methods to get automatic argument naming.JewelCLI is a Scala-friendly Java library for command-line parsing that yields clean code.  It uses Proxied Interfaces Configured with Annotations to dynamically build a type-safe API for your command-line parameters.An example parameter interface Person.scala:An example usage of the parameter interface Hello.scala:Save copies of the files above to a single directory and download the JewelCLI 0.6 JAR to that directory as well.Compile and run the example in Bash on Linux/Mac OS X/etc.:Compile and run the example in the Windows Command Prompt:Running the example should yield the following output:here is mine too! (a bit late in the game though)https://github.com/backuity/clistAs opposed to scopt it is entirely mutable... but wait! That gives us a pretty nice syntax:And a simple way to run it:You can do a lot more of course (multi-commands, many configuration options, ...) and has no dependency.I\'ll finish with a kind of distinctive feature, the default usage (quite often neglected for multi commands):\nI think scala-optparse-applicative is the most functional command line parser library in Scala.https://github.com/bmjames/scala-optparse-applicativeThere\'s also JCommander (disclaimer: I created it):I am from Java world, I like args4j because its simple, specification is more readable( thanks to annotations) and produces nicely formatted output.Here is my example snippet:I liked the slide() approach of joslinm just not the mutable vars ;) So here\'s an immutable way to that approach:I\'ve just found an extensive command line parsing library in scalac\'s scala.tools.cmd package.See http://www.assembla.com/code/scala-eclipse-toolchain/git/nodes/src/compiler/scala/tools/cmd?rev=f59940622e32384b1e08939effd24e924a8ba8dbI\'ve attempted generalize @pjotrp\'s solution by taking in a list of required positional key symbols, a map of flag -> key symbol and default options:I based my approach on the top answer (from dave4420), and tried to improve it by making it more general-purpose. It returns a Map[String,String] of all command line parameters\nYou can query this for the specific parameters you want (eg using .contains) or convert the values into the types you want (eg using toInt).Example:Gives:another library: scargHere\'s a scala command line parser that is easy to use.  It automatically formats help text, and it converts switch arguments to your desired type. Both short POSIX, and long GNU style switches are supported. Supports switches with required arguments, optional arguments, and multiple value arguments. You can even specify the finite list of acceptable values for a particular switch.  Long switch names can be abbreviated on the command line for convenience.  Similar to the option parser in the Ruby standard library.I just created my simple enumerationI understand that solution has two major flaws that may distract you: It eliminates the freedom (i.e. the dependence on other libraries, that you value so much) and redundancy (the DRY principle, you do type the option name only once, as Scala program variable and eliminate it second time typed as command line text).I\'d suggest to use http://docopt.org/. There\'s a scala-port but the Java implementation https://github.com/docopt/docopt.java works just fine and seems to be better maintained. Here\'s an example:How to parse parameters without an external dependency. Great question! You may be interested in picocli. Picocli is specifically designed to solve the problem asked in the question: it is a command line parsing framework in a single file, so you can include it in source form. This lets users run picocli-based applications without requiring picocli as an external dependency. It works by annotating fields so you write very little code. Quick summary:The usage help message is easy to customize with annotations (without programming). For example: (source)I couldn\'t resist adding one more screenshot to show what kind of usage help messages are possible. Usage help is the face of your application, so be creative and have fun!Disclaimer: I created picocli. Feedback or questions very welcome. It is written in java, but let me know if there is any issue using it in scala and I\'ll try to address it.I like the clean look of this code... gleaned from a discussion here:\nhttp://www.scala-lang.org/old/node/4380I have never liked ruby like option parsers. Most developers that used them never write a proper man page for their scripts and end up with pages long options not organized in a proper way because of their parser.I have always preferred Perl\'s way of doing things with Perl\'s Getopt::Long.I am working on a scala implementation of it. The early API looks something like this:So calling script like this:Would print:And return:The project is hosted in github scala-getoptions.As everyone posted it\'s own solution here is mine, cause I wanted something easier to write for the user : https://gist.github.com/gwenzek/78355526e476e08bb34dThe gist contains a code file, plus a test file and a short example copied here:There is not fancy options to force a variable to be in some bounds, cause I don\'t feel that the parser is the best place to do so.Note : you can have as much alias as you want for a given variable.I\'m going to pile on.  I solved this with a simple line of code.  My command line arguments look like this:This creates an array via Scala\'s native command line functionality (from either App or a main method):I can then use this line to parse out the default args array:Which creates a map with names associated with the command line values:I can then access the values of named parameters in my code and the order they appear on the command line is no longer relevant.  I realize this is fairly simple and doesn\'t have all the advanced functionality mentioned above but seems to be sufficient in most cases, only needs one line of code, and doesn\'t involve external dependencies.Here is mine 1-linerIt drops 3 mandatory arguments and gives out the options. Integers are specified like notorious -Xmx<size> java option, jointly with the prefix. You can parse binaries and integers as simple asNo need to import anything.This is what I cooked. It returns a tuple of a map and a list. List is for input, like input file names. Map is for switches/options.will returnSwitches can be "--t" which x will be set to true, or "--x 10" which x will be set to "10". Everything else will end up in list.freecliThis will generate the following usage:UsagePoor man\'s quick-and-dirty one-liner for parsing key=value pairs: