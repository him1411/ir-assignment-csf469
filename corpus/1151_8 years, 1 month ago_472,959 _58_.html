I have a limited exposure to DB and have only used DB as an application programmer. I want to know about Clustered and Non clustered indexes.\nI googled and what I found was :A clustered index is a special type of index that reorders  the way\n  records in the table are physically\n  stored.  Therefore table can have only\n  one clustered index. The leaf  nodes\n  of a clustered index contain the data\n  pages. A nonclustered index is a\n  special type of index in which  the\n  logical order of the index does not\n  match the physical  stored order of\n  the rows on disk. The leaf node of a \n  nonclustered index does not consist of\n  the data pages.  Instead, the leaf\n  nodes contain index rows.What I found in SO was What are the differences between a clustered and a non-clustered index?.Can someone explain this in plain English?With a clustered index the rows are stored physically on the disk in the same order as the index. Therefore, there can be only one clustered index.With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indexes, although each new index will increase the time it takes to write new records. It is generally faster to read from a clustered index if you want to get back all the columns. You do not have to go first to the index and then to the table.Writing to a table with a clustered index can be slower, if there is a need to rearrange the data.A clustered index means you are telling the database to store close values actually close to one another on the disk. This has the benefit of rapid scan / retrieval of records falling into some range of clustered index values.For example, you have two tables, Customer and Order:If you wish to quickly retrieve all orders of one particular customer, you may wish to create a clustered index on the "CustomerID" column of the Order table. This way the records with the same CustomerID will be physically stored close to each other on disk (clustered) which speeds up their retrieval.P.S. The index on CustomerID will obviously be not unique, so you either need to add a second field to "uniquify" the index or let the database handle that for you but that\'s another story.Regarding multiple indexes. You can have only one clustered index per table because this defines how the data is physically arranged. If you wish an analogy, imagine a big room with many tables in it. You can either put these tables to form several rows or pull them all together to form a big conference table, but not both ways at the same time. A table can have other indexes, they will then point to the entries in the clustered index which in its turn will finally say where to find the actual data.In SQL Server row oriented storage both clustered and nonclustered indexes are organized as B trees.(Image Source)The key difference between clustered indexes and non clustered indexes is that the leaf level of the clustered index is the table. This has two implications.Non clustered indexes can also do point 1 by using the INCLUDE clause (Since SQL Server 2005) to explicitly include all non key columns but they are secondary representations and there is always another copy of the data around (the table itself).The two indexes above will be nearly identical. With the upper level index pages containing values for the key columns A,B and the leaf level pages containing A,B,C,DThere can be only one clustered index per table, because the data rows\n  themselves can be sorted in only one order.The above quote from SQL Server books online causes much confusion (as it is frankly misleading). In my opinion it would be much better phrased as.There can be only one clustered index per table, because the leaf level rows of the clustered index are the table rows. It is trivially correct that the CI rows and the table rows are ordered the same way as they are the same thing (In the same way as the kittens in the picture above are ordered the same as the baby cats are) however the commonly held belief that with a clustered index the rows are always stored physically on the disk in the same order as the index key is false. This would be an absurd implementation. For example if a row is inserted into the middle of a 4GB table SQL Server does not have to copy 2GB of data up in the file to make room for the newly inserted row .Instead a page split occurs. Each page at the leaf level of both clustered and non clustered indexes has the address (File:Page) of the next and previous page in logical key order. These pages need not be either contiguous or in key order.e.g. the linked page chain might be 1:2000 <-> 1:157 <-> 1:7053When a page split happens a new page is allocated from anywhere in the filegroup (from either a mixed extent, for small tables, or a non empty uniform extent belonging to that object or a newly allocated uniform extent). This might not even be in the same file if the file group contains more than one.The degree to which the logical order and contiguity differs from the idealised physical version is the degree of logical fragmentation. In a newly created database with a single file I ran the following.Then checked the page layout withResults were all over the place. The first row in key order (with value 1 - highlighted with arrow below) was on nearly the last physical page.Fragmentation can be reduced or removed by rebuilding or reorganising an index to increase the correlation between logical order and physical order.After runningI got the followingIf the table has no clustered index it is called a heap.Non clustered indexes can be built on either a heap or a clustered index. They always contain a row locator back to the base table. In the case of a heap this is a physical row identifier (rid) and consists of three components (File:Page:Slot). In the case of a Clustered index the row locator is logical (the clustered index key). For the latter case if the non clustered index already naturally includes the CI key column(s) either as NCI key columns or INCLUDE-d columns then nothing is added. Otherwise the missing CI key column(s) silently get added in to the NCI.SQL Server always ensures that the key columns are unique for both types of index. The mechanism in which this is enforced for indexes not declared as unique differs between the two index types however.Clustered indexes get a uniquifier added for any rows with key values that duplicate an existing row. This is just an ascending integer. For non clustered indexes not declared as unique SQL Server silently adds the row locator in to the non clustered index key. This applies to all rows, not just those that are actually duplicates.The clustered vs non clustered nomenclature is also used for column store indexes. The paper Enhancements to SQL Server Column Stores statesAlthough column store data is not really "clustered" on any key, we\n  decided to retain the traditional SQL Server convention of referring\n  to the primary index as a clustered index.Find below some characteristics of clustered and non-clustered indexes:A very simple, non-technical rule-of-thumb would be that clustered indexes are usually used for your primary key (or, at least, a unique column) and that non-clustered are used for other situations (maybe a foreign key). Indeed, SQL Server will by default create a clustered index on your primary key column(s). As you will have learnt, the clustered index relates to the way data is physically sorted on disk, which means it\'s a good all-round choice for most situations.I realize this is a very old question, but I thought I would offer an analogy to help illustrate the fine answers above.If you walk into a public library, you will find that the books are all arranged in a particular order (most likely the Dewey Decimal System, or DDS). This corresponds to the "clustered index" of the books. If the DDS# for the book you want was 005.7565 F736s, you would start by locating the row of bookshelves that is labeled 001-099 or something like that. (This endcap sign at the end of the stack corresponds to an "intermediate node" in the index.) Eventually you would drill down to the specific shelf labelled 005.7450 - 005.7600, then you would scan until you found the book with the specified DDS#, and at that point you have found your book.But if you didn\'t come into the library with the DDS# of your book memorized, then you would need a second index to assist you. In the olden days you would find at the front of the library a wonderful bureau of drawers known as the "Card Catalog". In it were thousands of 3x5 cards -- one for each book, sorted in alphabetical order (by title, perhaps). This corresponds to the "non-clustered index". These card catalogs were organized in a hierarchical structure, so that each drawer would be labeled with the range of cards it contained (Ka - Kl, for example; i.e., the "intermediate node"). Once again, you would drill in until you found your book, but in this case, once you have found it (i.e, the "leaf node"), you don\'t have the book itself, but just a card with an index number (the DDS#) with which you could find the actual book in the clustered index.Of course, nothing would stop the librarian from photocopying all the cards and sorting them in a different order in a separate card catalog. (Typically there were at least two such catalogs: one sorted by author name, and one by title.) In principle, you could have as many of these "non-clustered" indexes as you want. Clustered IndexClustered indexes sort and store the data rows in the table or view based on their key values. These are the columns included in the index definition. There can be only one clustered index per table, because the data rows themselves can be sorted in only one order.The only time the data rows in a table are stored in sorted order is when the table contains a clustered index. When a table has a clustered index, the table is called a clustered table. If a table has no clustered index, its data rows are stored in an unordered structure called a heap.NonclusteredNonclustered indexes have a structure separate from the data rows. A nonclustered index contains the nonclustered index key values and each key value entry has a pointer to the data row that contains the key value.\nThe pointer from an index row in a nonclustered index to a data row is called a row locator. The structure of the row locator depends on whether the data pages are stored in a heap or a clustered table. For a heap, a row locator is a pointer to the row. For a clustered table, the row locator is the clustered index key.You can add nonkey columns to the leaf level of the nonclustered index to by-pass existing index key limits, and execute fully covered, indexed, queries. For more information, see Create Indexes with Included Columns. For details about index key limits see Maximum Capacity Specifications for SQL Server.Reference: https://docs.microsoft.com/en-us/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described 