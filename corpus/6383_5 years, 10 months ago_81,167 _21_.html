In my code in need to use an IEnumerable<> several times thus get the Resharper error of "Possible multiple enumeration of IEnumerable".Sample code:But this is just awkward.What would you do in this scenario?The problem with taking IEnumerable as a parameter is that it tells callers "I wish to enumerate this". It doesn\'t tell them how many times you wish to enumerate. I can change the objects parameter to be List and then avoid the possible multiple enumeration but then I don\'t get the highest object that I can handle.The goal of taking the highest object is noble, but it leaves room for too many assumptions. Do you really want someone to pass a LINQ to SQL query to this method, only for you to enumerate it twice (getting potentially different results each time?)The semantic missing here is that a caller, who perhaps doesn\'t take time to read the details of the method, may assume you only iterate once - so they pass you an expensive object. Your method signature doesn\'t indicate either way. By changing the method signature to IList/ICollection, you will at least make it clearer to the caller what your expectations are, and they can avoid costly mistakes. Otherwise, most developers looking at the method might assume you only iterate once. If taking an IEnumerable is so important, you should consider doing the .ToList() at the start of the method. It\'s a shame .NET doesn\'t have an interface that is IEnumerable + Count + Indexer, without Add/Remove etc. methods, which is what I suspect would solve this problem. If your data is always going to be repeatable, perhaps don\'t worry about it. However, you can unroll it too - this is especially useful if the incoming data could be large (for example, reading from disk/network):Note I changed the semantic of DoSomethingElse a bit, but this is mainly to show unrolled usage. You could re-wrap the iterator, for example. You could make it an iterator block too, which could be nice; then there is no list - and you would yield return the items as you get them, rather than add to a list to be returned.I usually overload my method with IEnumerable and IList in this situation. I take care to explain in the summary comments of the methods that calling IEnumerable will perform a .ToList().The programmer can choose to .ToList() at a higher level if multiple operations are being concatenated and then call the IList overload or let my IEnumerable overload take care of that.If the aim is really to prevent multiple enumerations than the answer by Marc Gravell is the one to read, but maintaining the same semantics you could simple remove the redundant Any and First calls and go with:Note, that this assumes that you IEnumerable is not generic or at least is constrained to be a reference type.First off, that warning does not always mean so much. I usually disabled it after making sure it\'s not a performance bottle neck. It just means the IEnumerable is evaluated twice, wich is usually not a problem unless the evaluation itself takes a long time. Even if it does take a long time, in this case your only using one element the first time around.In this scenario you could also exploit the powerful linq extension methods even more.It is possible to only evaluate the IEnumerable once in this case with some hassle, but profile first and see if it\'s really a problem.