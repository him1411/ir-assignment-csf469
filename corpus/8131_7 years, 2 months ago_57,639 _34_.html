I am creating a small application with a JavaScript client (run in the browser) and a Node.js server, communicating using WebSocket.I would like to share code between the client and the server. I have only just started with Node.js and my knowledge of modern JavaScript is a little rusty, to say the least. So I am still getting my head around the CommonJS require() function. If I am creating my packages by using the \'export\' object, then I cannot see how I could use the same JavaScript files in the browser.I want to create a set of methods and classes that are used on both ends to facilitate encoding and decoding messages, and other mirrored tasks. However, the Node.js/CommonJS packaging systems seems to preclude me from creating JavaScript files that can be used on both sides.I also tried using JS.Class to get a tighter OO model, but I gave up because I couldn\'t figure out how to get the provided JavaScript files to work with require(). Is there something am I missing here?If you want to write a module that can be used both client side and server side, I have a short blog post on a quick and easy method: Writing for Node.js and the browser, essentially the following (where this is the same as window):Alternatively there are some projects aiming to implement the Node.js API on the client side, such as Marak\'s gemini.You might also be interested in DNode, which lets you expose a JavaScript function so that it can be called from another machine using a simple JSON-based network protocol.Epeli has a nice solution here http://epeli.github.com/piler/ that even works without the library, just put this in a file called share.jsOn the server side just use:And on the client side just load the js file and then useDon\'t forget that the string representation of a JavaScript function represents the source code for that function. You could simply write your functions and constructors in an encapsulated way so they can be toString()\'d and sent to the client.Another way to do it is use a build system, put the common code in separate files, and then include them in both the server and client scripts. I\'m using that approach for a simple client/server game via WebSockets where the server and client both run essentially the same game loop and the client synchronises up with the server every tick to make sure nobody\'s cheating.My build system for the game is a simple Bash script that runs the files through the C preprocessor and then through sed to clean up some junk cpp leaves behind, so I can use all the normal preprocessor stuff like #include, #define, #ifdef, etc.I would recommend looking into the RequireJS adapter for Node.js. The problem is that the CommonJS module pattern Node.js uses by default isn\'t asynchronous, which blocks loading in the web browser. RequireJS uses the AMD pattern, which is both asynchronous and compatible with both server and client, as long as you use the r.js adapter.Checkout the jQuery source code that makes this work in the Node.js module pattern, AMD module pattern, and global in the browser:Maybe this is not entirely in line with the question, but I thought I\'d share this.I wanted to make a couple of simple string utility functions, declared on String.prototype, available to both node and the browser. I simply keep these functions in a file called utilities.js (in a subfolder) and can easily reference it both from a script-tag in my browser code, and by using require (omitting the .js extension) in my Node.js script:I hope this is useful information to someone other than me.The server can simply send JavaScript source files to the client (browser) but the trick is that the client will have to provide a mini "exports" environment before it can exec the code and store it as a module.A simple way to make such an environment is to use a closure.  For example, say your server provides source files via HTTP like http://example.com/js/foo.js.  The browser can load the required files via an XMLHttpRequest and load the code like so:The key is that client can wrap the foreign code into an anonymous function to be run immediately (a closure) which creates the "exports" object and returns it so you can assign it where you\'d like, rather than polluting the global namespace.  In this example, it is assigned to the window attribute fooModule which will contain the code exported by the file foo.js.None of the previous solutions bring the CommonJS module system to the browser.As mentioned in the other answers, there are asset manager/packager solutions like Browserify or Piler and there are RPC solutions like dnode or nowjs.But I couldn\'t find an implementation of CommonJS for the browser (including a require() function and exports / module.exports objects, etc.). So I wrote my own, only to discover afterwards that someone else had written it better than I had: https://github.com/weepy/brequire. It\'s called Brequire (short for Browser require).Judging by popularity, asset managers fit the needs of most developers. However, if you need a browser implementation of CommonJS, Brequire will probably fit the bill.2015 Update: I no longer use Brequire (it hasn\'t been updated in a few years). If I\'m just writing a small, open-source module and I want anyone to be able to easily use, then I\'ll follow a pattern similar to Caolan\'s answer (above) -- I wrote a blog post about it a couple years ago.However, if I\'m writing modules for private use or for a community that is standardized on CommonJS (like the Ampersand community) then I\'ll just write them in CommonJS format and use Browserify.now.js is also worth a look. It allows you to call server-side from the client-side, and client-side functions from the server-sideIf you want to write your browser in Node.js-like style you can try dualify.There is no browser code compilation, so you can write your application without limitations.Write your code as RequireJS modules and your tests as Jasmine tests.This way code can be loaded everywhere with RequireJS and the tests be run in the browser with jasmine-html and with jasmine-node in Node.js without the need to modify the code or the tests.Here is a working example for this.I wrote this, it is simple to use if you want to set all variables to the global scope: