This question already has an answer here:Is there a simple way or method to convert an Stream into a byte[] in C#?Call next function like  Function:The shortest solution I know:In .NET Framework 4 and later, the Stream class has a built-in CopyTo method that you can use.For earlier versions of the framework, the handy helper function to have is:Then use one of the above methods to copy to a MemoryStream and call GetBuffer on it:Edit: originally I suggested using Jason\'s answer for a Stream that supports the Length property. But it had a flaw because it assumed that the Stream would return all its contents in a single Read, which is not necessarily true (not for a Socket, for example.) I don\'t know if there is an example of a Stream implementation in the BCL that does support Length but might return the data in shorter chunks than you request, but as anyone can inherit Stream this could easily be the case.It\'s probably simpler for most cases to use the above general solution, but supposing you did want to read directly into an array that is bigEnough:That is, repeatedly call Read and move the position you will be storing the data at.I use this extension class:Just copy the class to your solution and you can use it on every stream:Works great for all my streams and saves a lot of code!\nOf course you can modify this method to use some of the other approaches here to improve performance if needed, but I like to keep it simple.Ok, maybe I\'m missing something here, but this is the way I do it:Quick and dirty technique: Test:I would ask, why do you want to read a stream into a byte[], if you are wishing to copy the contents of a stream, may I suggest using MemoryStream and writing your input stream into a memory stream. if you post a file from mobile device or otherA slightly more complicated solution is necesary is s.Length exceeds Int32.MaxValue. But if you need to read a stream that large into memory, you might want to think about a different approach to your problem.Edit: If your stream does not support the Length property, modify using Earwicker\'s workaround.You could also try just reading in parts at a time and expanding the byte array being returned:"bigEnough" array is a bit of a stretch. Sure, buffer needs to be "big ebough" but proper design of an application should include transactions and delimiters. In this configuration each transaction would have a preset length thus your array would anticipate certain number of bytes and insert it into correctly sized buffer. Delimiters would ensure transaction integrity and would be supplied within each transaction. To make your application even better, you could use 2 channels (2 sockets). One would communicate fixed length control message transactions that would include information about size and sequence number of data transaction to be transferred using data channel. Receiver would acknowledge buffer creation and only then data would be sent.\nIf you have no control over stream sender than you need multidimensional array as a buffer. Component arrays would be small enough to be manageable and big enough to be practical based on your estimate of expected data. Process logic would seek known start delimiters and then ending delimiter in subsequent element arrays. Once ending delimiter is found, new buffer would be created to store relevant data between delimiters and initial buffer would have to be restructured to allow data disposal.As far as a code to convert stream into byte array is one below.