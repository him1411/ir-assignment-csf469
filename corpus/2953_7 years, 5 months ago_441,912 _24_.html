I often see JavaScript code which checks for undefined parameters etc. this way:This seems kind of wasteful, since it involves both a type lookup and a string comparison, not to mention its verbosity. It\'s needed because \'undefined\' could be renamed, though. My question is: How is that code any better than this approach:As far as I know, you can\'t redefine null, so it\'s not going to break unexpectedly. And, because of the type-coercion of the != operator, this checks for both undefined and null... which is often exactly what you want (e.g. for optional function parameters). Yet this form does not seem widespread, and it even causes JSLint to yell at you for using the evil != operator. Why is this considered bad style?typeof allows the identifier to never have been declared before. So it\'s safer in that regard:If the variable is declared (either with the var keyword, as a function argument, or as a global variable), I think the best way to do it is:jQuery does it, so it\'s good enough for me :-)Otherwise, you\'ll have to use typeof to avoid a ReferenceError.If you expect undefined to be redefined, you could wrap your code like this:good way:But the best looking way is to check via :You shouldn\'t really worry about undefined being renamed. If someone renames undefined, you will be in a lot more trouble than just a few if checks failing. If you really want to protect your code, wrap it in an IFFE (immediately invoked function expression) like this:If you\'re working with global variables (which is wrong already) in a browser enviroment, I\'d check for undefined like this:Since global variables are a part of the window object, you can simply check against undefined instead of casting to a string and comparing strings. On top of that, why are your variables not defined? I\'ve seen a lot of code where they check a variables existence and perform some action based on that. Not once have I seen where this approach has been correct. If you are really worried about undefined being redefined, you can protect against this with some helper method like this:This works because when someone writes undefined = "foo" he only lets the name undefined reference to a new value, but he doesn\'t change the actual value of undefined.You can also use the void operator to obtain an undefined value:(And yes, as noted in another answer, this will throw an error if the variable was not declared, but this case can often be ruled out either by code inspection, or by code refactoring, e.g. using window.input !== void 0 for testing global variables or adding var input.)works just fine. It is of course not a null comparison, but I usually find that if I need to distinguish between undefined and null, I actually rather need to distinguish between undefined and just any false value, sodoes it.If a program redefines undefined it is really braindead anyway.The only reason I can think of was for IE4 compatibility, it did not understand the undefined keyword (which is not actually a keyword, unfortunately), but of course values could be undefined, so you had to have this:and the comparison above would work just fine.In your second example, you probably need double parentheses to make lint happy?