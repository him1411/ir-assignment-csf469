While executing an INSERT statement with many rows, I want to skip duplicate entries that would otherwise cause failure. After some research, my options appear to be the use of either:  Am I right in these assumptions? What\'s the best way to simply skip the rows that might cause duplicates and just continue on to the other rows?I would recommend using INSERT...ON DUPLICATE KEY UPDATE.If you use INSERT IGNORE, then the row won\'t actually be inserted if it results in a duplicate key.  But the statement won\'t generate an error.  It generates a warning instead.  These cases include:If you use REPLACE, MySQL actually does a DELETE followed by an INSERT internally, which has some unexpected side effects:  correction: both REPLACE and INSERT...ON DUPLICATE KEY UPDATE are non-standard,  proprietary inventions specific to MySQL.  ANSI SQL 2003 defines a MERGE statement that can solve the same need (and more), but MySQL does not support the MERGE statement.A user tried to edit this post (the edit was rejected by moderators).  The edit tried to add a claim that INSERT...ON DUPLICATE KEY UPDATE causes a new auto-increment id to be allocated.  It\'s true that the new id is generated, but it is not used in the changed row.See demonstration below, tested with Percona Server 5.5.28.  The configuration variable innodb_autoinc_lock_mode=1 (the default):The above demonstrates that the IODKU statement detects the duplicate, and invokes the update to change the value of u.  Note the AUTO_INCREMENT=3 indicates an id was generated, but not used in the row.Whereas REPLACE does delete the original row and inserts a new row, generating and storing a new auto-increment id:In case you want to see what this all means, here is a blow-by-blow of everything:Primary key is based on both columns of this quick reference table.  A Primary key requires unique values.Let\'s begin:note, the above saved too much extra work by setting the column equal to itself, no update actually neededand now some multiple row tests:no other messages were generated in console, and it now has those 4 values in the table data.  I deleted everything except (1,1) so I could test from the same playing fieldSo there you have it.  Since this was all performed on a fresh table with nearly no data and not in production, the times for execution were microscopic and irrelevant.  Anyone with real-world data would be more than welcome to contribute it.Something important to add: When using INSERT IGNORE and you do have key violations, MySQL does NOT raise a warning!If you try for instance to insert 100 records at a time, with one faulty one, you would get in interactive mode:Query OK, 99 rows affected (0.04 sec)Records: 100  Duplicates: 1  Warnings: 0As you see: No Warnings! This behavior is even wrongly described in the official Mysql Documentation.If your script needs to be informed, if some records have not been added (due to key violations) you have to call mysql_info() and parse it for the "Duplicates" value.I know this is old, but I\'ll add this note in case anyone else (like me) arrives at this page while trying to find information on INSERT..IGNORE.As mentioned above, if you use INSERT..IGNORE, errors that occur while executing the INSERT statement are treated as warnings instead.One thing which is not explicitly mentioned is that INSERT..IGNORE will cause invalid values will be adjusted to the closest values when inserted (whereas invalid values would cause the query to abort if the IGNORE keyword was not used).I routinely use INSERT IGNORE, and it sounds like exactly the kind of behavior you\'re looking for as well. As long as you know that rows which would cause index conflicts will not be inserted and you plan your program accordingly, it shouldn\'t cause any trouble.ON DUPLICATE KEY UPDATE is not really in the standard.  It\'s about as standard as REPLACE is.  See SQL MERGE.Essentially both commands are alternative-syntax versions of standard commands.Replace Into seems like an option. Or you can check withThis will insert or delete then insert. I tend to go for a IF NOT EXISTS check first.If using insert ignore having a SHOW WARNINGS; statement at the end of your query set will show a table with all the warnings, including which IDs were the duplicates.