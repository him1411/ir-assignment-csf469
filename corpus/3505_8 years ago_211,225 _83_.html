I have the following dummy test script:This will print the result 0.020000000000000004 while it should just print 0.02 (if you use your calculator). As far as I understood this is due to errors in the floating point multiplication precision.Does anyone have a good solution so that in such case I get the correct result 0.02? I know there are functions like toFixed or rounding would be another possibility, but I\'d like is to really have the whole number printed without any cutting and rounding. Just wanted to know whether one of you has some nice, elegant solution.Of course, otherwise I\'ll round to some 10 digits or so.From the Floating-Point Guide:What can I do to avoid this problem?That depends on what kind of\n  calculations you\xe2\x80\x99re doing.Note that the first point only applies if you really need specific precise decimal behaviour. Most people don\'t need that, they\'re just irritated that their programs don\'t work correctly with numbers like 1/10 without realizing that they wouldn\'t even blink at the same error if it occurred with 1/3.If the first point really applies to you, use BigDecimal for JavaScript, which is not elegant at all, but actually solves the problem rather than providing an imperfect workaround.I like Pedro Ladaria\'s solution and use something similar.Unlike Pedros solution this will round up 0.999...repeating and is accurate to plus/minus one on the least significant digit.Note: When dealing with 32 or 64 bit floats, you should use toPrecision(7) and toPrecision(15) for best results.  See this question for info as to why.For the mathematically inclined: http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.htmlThe recommended approach is to use correction factors (multiply by a suitable power of 10 so that the arithmetic happens between integers).  For example, in the case of 0.1 * 0.2, the correction factor is 10, and you are performing the calculation:A (very quick) solution looks something like:In this case:I definitely recommend using a tested library like SinfulJSAre you only performing multiplication?  If so then you can use to your advantage a neat secret about decimal arithmetic.  That is that NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals. That is to say that if we have 0.123 * 0.12 then we know that there will be 5 decimal places because 0.123 has 3 decimal places and 0.12 has two. Thus if JavaScript gave us a number like 0.014760000002 we can safely round to the 5th decimal place without fear of losing precision.You are looking for an sprintf implementation for JavaScript, so that you can write out floats with small errors in them (since they are stored in binary format) in a format that you expect.Try javascript-sprintf, you would call it like this:to print out your number as a float with two decimal places.You may also use  Number.toFixed()  for display purposes, if you\'d rather not include  more files merely for floating point rounding to a given precision.  This function will determine the needed precision from the multiplication of two floating point numbers and return a result with the appropriate precision. Elegant though it is not.To multiply a * b, where a = 5 and b = 0.0001:Shift decimal point of result left by same number of places: 0.0005---or------also------ as in ---You just have to make up your mind on how many decimal digits you actually want - can\'t have the cake and eat it too :-)Numerical errors accumulate with every further operation and if you don\'t cut it off early it\'s just going to grow. Numerical libraries which present results that look clean simply cut off the last 2 digits at every step, numerical co-processors also have a "normal" and "full" lenght for the same reason. Cuf-offs are cheap for a processor but very expensive for you in a script (multiplying and dividing and using pov(...)). Good math lib would provide floor(x,n) to do the cut-off for you.So at the very least you should make global var/constant with pov(10,n) - meaning that you decided on the precision you need :-) Then do:You could also keep doing math and only cut-off at the end - assuming that you are only displaying and not doing if-s with results. If you can do that, then .toFixed(...) might be more efficient.If you are doing if-s/comparisons and don\'t want to cut of then you also need a small constant, usually called eps, which is one decimal place higher than max expected error. Say that your cut-off is last two decimals - then your eps has 1 at the 3rd place from the last (3rd least significant) and you can use it to compare whether the result is within eps range of expected (0.02 -eps < 0.1*0.2 < 0.02 +eps).The round() function at phpjs.org works nicely: http://phpjs.org/functions/round I\'m finding BigNumber.js meets my needs.A JavaScript library for arbitrary-precision decimal and non-decimal arithmetic.It has good documentation and the author is very diligent responding to feedback.The same author has 2 other similar libraries:Big.jsA small, fast JavaScript library for arbitrary-precision decimal arithmetic. The little sister to bignumber.js.and Decimal.jsAn arbitrary-precision Decimal type for JavaScript.Here\'s some code using BigNumber:The result you\'ve got is correct and fairly consistent across floating point implementations in different languages, processors and operating systems - the only thing that changes is the level of the inaccuracy when the float is actually a double (or higher).0.1 in binary floating points is like 1/3 in decimal (i.e. 0.3333333333333... forever), there\'s just no accurate way to handle it. If you\'re dealing with floats always expect small rounding errors, so you\'ll also always have to round the displayed result to something sensible. In return you get very very fast and powerful arithmetic because all the computations are in the native binary of the processor.Most of the time the solution is not to switch to fixed-point arithmetic, mainly because it\'s much slower and 99% of the time you just don\'t need the accuracy. If you\'re dealing with stuff that does need that level of accuracy (for instance financial transactions) Javascript probably isn\'t the best tool to use anyway (as you\'ve want to enforce the fixed-point types a static language is probably better).You\'re looking for the elegant solution then I\'m afraid this is it: floats are quick but have small rounding errors - always round to something sensible when displaying their results.To avoid this you should work with integer values instead of floating points. So when you want to have 2 positions precision work with the values * 100, for 3 positions use 1000. When displaying you use a formatter to put in the separator.Many systems omit working with decimals this way. That is the reason why many systems work with cents (as integer) instead of dollars/euro\'s (as floating point).0.6 * 3 it\'s awesome!))\nFor me this works fine:Very very simple))You can use parseFloat() and toFixed() if you want to bypass this issue for a small operation:Have a look at Fixed-point arithmetic. It will probably solve your problem, if the range of numbers you want to operate on is small (eg, currency). I would round it off to a few decimal values, which is the simplest solution. Try my chiliadic arithmetic library, which you can see here.\nIf you want a later version, I can get you one.You can\'t represent most decimal fractions exactly with binary floating point types (which is what ECMAScript uses to represent floating point values). So there isn\'t an elegant solution unless you use arbitrary precision arithmetic types or a decimal based floating point type. For example, the Calculator app that ships with Windows now uses arbitrary precision arithmetic to solve this problem.You are right, the reason for that is limited precision of floating point numbers. Store your rational numbers as a division of two integer numbers and in most situations you\'ll be able to store numbers without any precision loss. When it comes to printing, you may want to display the result as fraction. With representation I proposed, it becomes trivial.Of course that won\'t help much with irrational numbers. But you may want to optimize your computations in the way they will cause the least problem (e.g. detecting situations like sqrt(3)^2).Use Number(1.234443).toFixed(2); it will print 1.23I had a nasty rounding error problem with mod 3. Sometimes when I should get 0 I would get .000...01. That\'s easy enough to handle, just test for <= .01. But then sometimes I would get 2.99999999999998. OUCH!BigNumbers solved the problem, but introduced another, somewhat ironic, problem. When trying to load 8.5 into BigNumbers I was informed that it was really 8.4999\xe2\x80\xa6 and had more than 15 significant digits. This meant BigNumbers could not accept it (I believe I mentioned this problem was somewhat ironic).Simple solution to ironic problem: Use not elegant but does the job (removes trailing zeros)This works for me:Output using the following function:Pay attention to the output toFixedCurrency(x).There is a better method which keeps precision and also strips the zeros. This takes an input number and through some magic of casting will pull off any trailing zeros. I\'ve found 16 to be the precision limit for me which is pretty good should you not be putting a satellite on pluto.while adding two  float value its never give the precise values so we need to fixed this to certain number that will help us to compare.I am not that much good at programming, but was really interested in this topic so I tried to understand how to solve that without using any libraries or scriptsI wrote this on scratchpadyou might need refactor this code, because I am not good at programming :)ProblemFloating point can\'t store all decimal values exactly. So when using floating point formats there will always be rounding errors on the input values.\nThe errors on the inputs of course results on errors on the output.\nIn case of a discrete function or operator there can be big differences on the output around the point where the function or operator is discrete.Input and output for floating point valuesSo, when using floating point variables, you should always be aware of this. And whatever output you want from a calculation with floating points should always be formatted/conditioned before displaying with this in mind.\nWhen only continuous functions and operators are used, rounding to the desired precision often will do (don\'t truncate).  Standard formatting features used to convert floats to string will usually do this for you.\nBecause the rounding adds an error which can cause the total error to be more then half of the desired precision, the output should be corrected based on expected precision of inputs and desired precision of output. You shouldThese 2 things are usually not done and in most cases the differences caused by not doing them are too small to be important for most users, but I already had a project where output wasn\'t accepted by the users without those corrections.Discrete functions or operators (like modula)When discrete operators or functions are involved, extra corrections might be required to make sure the output is as expected. Rounding and adding small corrections before rounding can\'t solve the problem.\nA special check/correction on intermediate calculation results, immediately after applying the discrete function or operator might be required.\nFor a specific case (modula operator), see my answer on question: Why does modulus operator return fractional number in javascript?Better avoid having the problemIt is often more efficient to avoid these problems by using data types (integer or fixed point formats) for calculations like this which can store the expected input without rounding errors.\nAn example of that is that you should never use floating point values for financial calculations.