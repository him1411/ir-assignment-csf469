The \'algebraic\' expression for algebraic data types looks very suggestive to someone with a background in mathematics. Let me try to explain what I mean.Having defined the basic typesand using the shorthand X\xc2\xb2 for X\xe2\x80\xa2X and 2X for X+X et cetera, we can then define algebraic expressions for e.g. linked listsdata List a = Nil | Cons a (List a) \xe2\x86\x94 L = 1 + X \xe2\x80\xa2 Land binary trees:data Tree a = Nil | Branch a (Tree a) (Tree a) \xe2\x86\x94 T = 1 + X \xe2\x80\xa2 T\xc2\xb2Now, my first instinct as a mathematician is to go nuts with these expressions, and try to solve for L and T. I could do this through repeated substitution, but it seems much easier to abuse the notation horrifically and pretend I can rearrange it at will. For example, for a linked list:L = 1 + X \xe2\x80\xa2 L(1 - X) \xe2\x80\xa2 L = 1L = 1 / (1 - X) = 1 + X + X\xc2\xb2 + X\xc2\xb3 + ...where I\'ve used the power series expansion of 1 / (1 - X) in a totally unjustified way to derive an interesting result, namely that an L type is either Nil, or it contains 1 element, or it contains 2 elements, or 3, etc.It gets more interesting if we do it for binary trees:T = 1 + X \xe2\x80\xa2 T\xc2\xb2X \xe2\x80\xa2 T\xc2\xb2 - T + 1 = 0T = (1 - \xe2\x88\x9a(1 - 4 \xe2\x80\xa2 X)) / (2 \xe2\x80\xa2 X)T = 1 + X + 2 \xe2\x80\xa2 X\xc2\xb2 + 5 \xe2\x80\xa2 X\xc2\xb3 + 14 \xe2\x80\xa2 X\xe2\x81\xb4 + ...again, using the power series expansion (done with Wolfram Alpha). This expresses the non-obvious (to me) fact that there is only one binary tree with 1 element, 2 binary trees with two elements (the second element can be on the left or the right branch), 5 binary trees with three elements etc.So my question is - what am I doing here? These operations seem unjustified (what exactly is the square root of an algebraic data type anyway?) but they lead to sensible results. does the quotient of two algebraic data types have any meaning in computer science, or is it just notational trickery?And, perhaps more interestingly, is it possible to extend these ideas? Is there a theory of the algebra of types that allows, for example, arbitrary functions on types, or do types require a power series representation? If you can define a class of functions, then does composition of functions have any meaning?Disclaimer: A lot of this doesn\'t really work quite right when you account for \xe2\x8a\xa5, so I\'m going to blatantly disregard that for the sake of simplicity. A few initial points:Note that "union" is probably not the best term for A+B here--that\'s specifically a disjoint union of the two types, because the two sides are distinguished even if their types are the same. For what it\'s worth, the more common term is simply "sum type".Singleton types are, effectively, all unit types. They behave identically under algebraic manipulations and, more importantly, the amount of information present is still preserved.You probably want a zero type as well. There isn\'t a standard one, but the most common name is Void. There are no values whose type is zero, just as there is one value whose type is one.There\'s still one major operation missing here but I\'ll get back to that in a moment.As you\'ve probably noticed, Haskell tends to borrow concepts from Category Theory, and all of the above has a very straightforward interpretation as such:Given objects A and B in Hask, their product A\xc3\x97B is the unique (up to isomorphism) type that allows two projections fst : A\xc3\x97B \xe2\x86\x92 A and snd : A\xc3\x97B \xe2\x86\x92 B, where given any type C and functions f : C \xe2\x86\x92 A, g : C \xe2\x86\x92 B you can define the pairing f &&& g : C \xe2\x86\x92 A\xc3\x97B such that fst \xe2\x88\x98 (f &&& g) = f and likewise for g. Parametricity guarantees the universal properties automatically and my less-than-subtle choice of names should give you the idea. The (&&&) operator is defined in Control.Arrow, by the way.The dual of the above is the coproduct A+B with injections inl : A \xe2\x86\x92 A+B and inr : B \xe2\x86\x92 A+B, where given any type C and functions f : A \xe2\x86\x92 C, g : B \xe2\x86\x92 C, you can define the copairing f ||| g : A+B \xe2\x86\x92 C such that the obvious equivalences hold. Again, parametricity guarantees most of the tricky parts automatically. In this case, the standard injections are simply Left and Right and the copairing is the function either.Many of the properties of product and sum types can be derived from the above. Note that any singleton type is a terminal object of Hask and any empty type is an initial object.Returning to the aforementioned missing operation, in a cartesian closed category you have exponential objects that correspond to arrows of the category. Our arrows are functions, our objects are types with kind *, and the type A -> B indeed behaves as BA in the context of algebraic manipulation of types. If it\'s not obvious why this should hold, consider the type Bool -> A. With only two possible inputs, a function of that type is isomorphic to two values of type A, i.e. (A, A). For Maybe Bool -> A we have three possible inputs, and so on. Also, observe that if we rephrase the copairing definition above to use algebraic notation, we get the identity CA \xc3\x97 CB = CA+B.As for why this all makes sense--and in particular why your use of the power series expansion is justified--note that much of the above refers to the "inhabitants" of a type (i.e., distinct values having that type) in order to demonstrate the algebraic behavior. To make that perspective explicit:The product type (A, B) represents a value each from A and B, taken independently. So for any fixed value a :: A, there is one value of type (A, B) for each inhabitant of B. This is of course the cartesian product, and the number of inhabitants of the product type is the product of the number of inhabitants of the factors.The sum type Either A B represents a value from either A or B, with the left and right branches distinguished. As mentioned earlier, this is a disjoint union, and the number of inhabitants of the sum type is the sum of the number of inhabitants of the summands.The exponential type B -> A represents a mapping from values of type B to values of type A. For any fixed argument b :: B, any value of A can be assigned to it; a value of type B -> A picks one such mapping for each input, which is equivalent to a product of as many copies of A as B has inhabitants, hence the exponentiation.While it\'s tempting at first to treat types as sets, that doesn\'t actually work very well in this context--we have disjoint union rather than the standard union of sets, there\'s no obvious interpretation of intersection or many other set operations, and we don\'t usually care about set membership (leaving that to the type checker). On the other hand, the constructions above spend a lot of time talking about counting inhabitants, and enumerating the possible values of a type is a useful concept here. That quickly leads us to enumerative combinatorics, and if you consult the linked Wikipedia article you\'ll find that one of the first things it does is define "pairs" and "unions" in exactly the same sense as product and sum types by way of generating functions, then does the same for "sequences" that are identical to Haskell\'s lists using exactly the same technique you did.Edit: Oh, and here\'s a quick bonus that I think demonstrates the point strikingly. You mentioned in a comment that for a tree type T = 1 + T^2 you can derive the identity T^6 = 1, which is clearly wrong. However, T^7 = T does hold, and a bijection between trees and seven-tuples of trees can be constructed directly, cf. Andreas Blass\'s "Seven Trees in One".Edit\xc3\x972: On the subject of the "derivative of a type" construction mentioned in other answers, you might also enjoy this paper from the same author which builds on the idea further, including notions of division and other interesting whatnot.Binary trees are defined by the equation T=1+XT^2 in the semiring of types. By construction, T=(1-sqrt(1-4X))/(2X) is defined by the same equation in the semiring of complex numbers. So given that we\'re solving the same equation in the same class of algebraic structure it actually shouldn\'t be surprising that we see some similarities.The catch is that when we reason about polynomials in the semiring of complex numbers we typically use the fact that the complex numbers form a ring or even a field so we find ourselves using operations such as subtraction that don\'t apply to semirings. But we can often eliminate subtractions from our arguments if we have a rule that allows us to cancel from both sides of an equation. This is the kind of thing proved by Fiore and Leinster showing that many arguments about rings can be transferred to semirings.This means that lots of your mathematical knowledge about rings can be reliably transferred to types. As a result, some arguments involving complex numbers or power series (in the ring of formal power series) can carry over to types in a completely rigorous way.However there\'s more to the story than this. It\'s one thing to prove two types are equal (say) by showing two power series are equal. But you can also deduce information about types by inspecting the terms in the power series. I\'m not sure of what the formal statement here should be. (I recommend Brent Yorgey\'s paper on combinatorial species for some work that\'s closely related but species are not the same as types.)What I find utterly mind blowing is that what you\'ve discovered can be extended to calculus. Theorems about calculus can be transferred over to the semiring of types. In fact, even arguments about finite differences can be transferred over and you find that classical theorems from numerical analysis have interpretations in type theory.Have fun!It seems that all you\'re doing is expanding the recurrence relation.And since the rules for the operations on the types work like the rules for arithmetic operations, you can use algebraic means to help you figure out how to expand the recurrence relation (since it is not obvious).I don\'t have a complete answer, but these manipulations tend to \'just work\'. A relevant paper might be Objects of Categories as Complex Numbers by Fiore and Leinster - I came across that one while reading sigfpe\'s blog on a related subject ; the rest of that blog is a goldmine for similar ideas and is worth checking out!You can also differentiate datatypes, by the way - that will get you the appropriate Zipper for the datatype!The Algebra of Communicating Processes (ACP) deals with similar kinds of expressions for processes.\nIt offers addition and multiplication as operators for choice and sequence, with associated neutral elements.\nBased on these there are operators for other constructs, such as parallelism and disruption.\nSee http://en.wikipedia.org/wiki/Algebra_of_Communicating_Processes. There is also a paper online named "A Brief History of Process Algebra".I am working on extending programming languages with ACP. Last April I presented a research paper at Scala Days 2012, available at http://code.google.com/p/subscript/At the conference I demonstrated a debugger running a parallel recursive specification of a bag:Bag = A; (Bag&a)where A and a stand for input and output actions; the semicolon and ampersand stand for sequence and parallelism. See the video at SkillsMatter, reachable from the previous link.A bag specification more comparable to L = 1 + X\xe2\x80\xa2Lwould be B = 1 + X&BACP defines parallelism in terms of choice and sequence using axioms; see the Wikipedia article. I wonder what the bag analogy would be forL = 1 / (1-X)ACP style programming is handy for text parsers and GUI controllers. Specifications such assearchCommand = clicked(searchButton) + key(Enter)cancelCommand = clicked(cancelButton) + key(Escape)may be written down more concisely by making the two refinements "clicked" and "key" implicit (like what Scala allows with functions). Hence we can write:searchCommand = searchButton + EntercancelCommand = cancelButton + EscapeThe right hand sides now contains operands that are data, rather than processes. At this level it is not necessary needed to know what implicit refinements will turn these operands into processes; they would not necessarily refine into input actions; output actions would also apply, e.g. in the specification of a test robot.Processes get this way data as companions; thus I coin the term "item algebra".Here is another minor addition - a combinatorial insight into why the coefficients in a series expansion should \'work\', in particular focusing on series which can be derived using the Taylor-Maclaurin approach from calculus. NB: the example series expansion you give of the manipulated list type is a Maclaurin series.Since other answers and comments deal with the behaviour of algebraic type expressions (sums, products and exponents), this answer will elide that detail and focus on type \'calculus\'.You may notice inverted commas doing some heavy lifting in this answer. There are two reasons:The Maclaurin series of a function f : \xe2\x84\x9d \xe2\x86\x92 \xe2\x84\x9d is defined aswhere f\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbe means the nth derivative of f.To be able to make sense of the Maclaurin series as interpreted with types, we need to understand how we can interpret three things in a type context:and it turns out that these concepts from analysis have suitable counterparts in the type world.What do I mean by a \'suitable counterpart\'? It should have the flavour of an isomorphism - if we can preserve truth in both directions, facts derivable in one context can be transferred to the other.So what does the derivative of a type expression mean? It turns out that for a large and well-behaved (\'differentiable\') class of type expressions and functors, there is a natural operation which behaves similarly enough to be a suitable interpretation!To spoil the punchline, the operation analogous to differentiation is that of making \'one-hole contexts\'. This is an excellent place to expand on this particular point further but the basic concept of a one-hole context (da/dx) is that it represents the result of extracting a single subitem of a particular type (x) from a term (of type a), preserving all other information, including that necessary to determine the original location of the subitem. For example, one way to represent a one-hole context for a list is with two lists: one for items which came before the extracted one, and one for items which came after.The motivation for identifying this operation with differentiation comes from the following observations. We write da/dx to mean the type of one-hole contexts for type a with hole of type x.Here, 1 and 0 represent types with exactly one and exactly zero inhabitants, respectively, and + and \xc3\x97 represent sum and product types as usual. f and g are used to represent type functions, or type expression formers, and [f(x)/a] means the operation of substituting f(x) for every a in the preceding expression.This may be written in a point-free style, writing f\' to mean the derivative function of type function f, thus:which may be preferable.NB the equalities can be made rigorous and exact if we define derivatives using isomorphism classes of types and functors.Now, we notice in particular that the rules in calculus pertaining to the algebraic operations of addition, multiplication and composition (often called the Sum, Product and Chain rules) are reflected exactly by the operation of \'making a hole\'. Further, the base cases of \'making a hole\' in a constant expression or the termx itself also behave as differentiation, so by induction we get differentiation-like behaviour for all algebraic type expressions.Now we can interpret differentiation, what does the nth \'derivative\' of a type expression, d\xe2\x81\xbfe/dx\xe2\x81\xbf mean? It is a type representing n-place contexts: terms which, when \'filled\' with n terms of type x yield an e. There is another key observation related to \'(1/n!)\' coming later.We already have an interpretation for 0 in the type world: an empty type with no members. What does it mean, from a combinatorial point of view, to apply a type function to it? In more concrete terms, supposing f is a type function, what does f(0) look like? Well, we certainly don\'t have access to anything of type 0, so any constructions of f(x) which require an x are unavailable. What is left is those terms which are accessible in their absence, which we can call the \'invariant\' or \'constant\' part of the type.For an explicit example, take the Maybe functor, which can be represented algebraically as x \xe2\x86\xa6 1 + x. When we apply this to 0, we get 1 + 0 - it\'s just like 1: the only possible value is the None value. For a list, similarly, we get just the term corresponding to the empty list.When we bring it back and interpret the type f(0) as a number it can be thought of as the count of how many terms of type f(x) (for any x) can be obtained without access to an x: that is, the number of \'empty-like\' terms.I\'m afraid I can\'t think of an appropriate direct interpretation of (1/n!) as a type.If we consider, though, the type f\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbe(0) in light of the above, we see that it can be interpreted as the type of n-place contexts for a term of type f(x) which do not already contain an x - that is, when we \'integrate\' them n times, the resulting term has exactly n xs, no more, no less. Then the interpretation of the type f\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbe(0) as a number (as in the coefficients of the Maclaurin series of f) is simply a count of how many such empty n-place contexts there are. We are nearly there!But where does (1/n!) end up? Examining the process of type \'differentiation\' shows us that, when applied multiple times, it preserves the \'order\' in which subterms are extracted. For example, consider the term (x\xe2\x82\x80, x\xe2\x82\x81) of type x \xc3\x97 x and the operation of \'making a hole\' in it twice. We get both sequenceseven though both come from the same term, because there are 2! = 2 ways to take two elements from two, preserving order. In general, there are n! ways to take n elements from n. So in order to get a count of the number of configurations of a functor type which have n elements, we have to count the type f\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbe(0) and divide by n!, exactly as in the coefficients of the Maclaurin series.So dividing by n! turns out to be interpretable simply as itself.First, some observations:Since we have the chain rule, we can use implicit differentiation, if we formalise type derivatives as isomorphism classes. But implicit differentiation doesn\'t require any alien manoeuvres like subtraction or division! So we can use it to analyse recursive type definitions. To take your list example, we haveand then we can evaluateto obtain the coefficient of X\xc2\xb9 in the Maclaurin series.But since we are confident that these expressions are indeed strictly \'differentiable\', if only implicitly, and since we have the correspondence with functions \xe2\x84\x9d \xe2\x86\x92 \xe2\x84\x9d, where derivatives are certainly unique, we can rest assured that even if we obtain the values using \'illegal\' operations, the result is valid.Now, similarly, to use the second observation, due to the correspondence (is it a homomorphism?) with functions \xe2\x84\x9d \xe2\x86\x92 \xe2\x84\x9d, we know that, provided we are satisfied that a function has a Maclaurin series, if we can find any series at all, the principles outlined above can be applied to make it rigorous.As for your question about composition of functions, I suppose the chain rule provides a partial answer.I\'m not certain how many Haskell-style ADTs this applies to, but I suspect it is many if not all. I have discovered a truly marvellous proof of this fact, but this margin is too small to contain it...Now, certainly this is only one way to work out what is going on here and there are probably many other ways.My first answer to this question was high on concepts and low on details and reflected on the subquestion, \'what is going on?\'; this answer will be the same but focused on the subquestion, \'can we get arbitrary type functions?\'.One extension to the algebraic operations of sum and product are the so called \'large operators\', which represent the sum and product of a sequence (or more generally, the sum and product of a function over a domain) usually written \xce\xa3 and \xce\xa0 respectively. See Sigma Notation.So the summight be writtenwhere a is some sequence of real numbers, for example. The product would be represented similarly with \xce\xa0 instead of \xce\xa3.When you look from a distance, this kind of expression looks a lot like an \'arbitrary\' function in X; we are limited of course to expressible series, and their associated analytic functions. Is this a candidate for a representation in a type theory? Definitely!The class of type theories which have immediate representations of these expressions is the class of \'dependent\' type theories: theories with dependent types. Naturally we have terms dependent on terms, and in languages like Haskell with type functions and type quantification, terms and types depending on types. In a dependent setting, we additionally have types depending on terms. Haskell is not a dependently typed language, although many features of dependent types can be simulated by torturing the language a bit.The \'Curry-Howard isomorphism\' started life as an observation that the terms and type-judging rules of simply-typed lambda calculus correspond exactly to natural deduction (as formulated by Gentzen) applied to intuitionistic propositional logic, with types taking the place of propositions, and terms taking the place of proofs, despite the two being independently invented/discovered. Since then, it has been a huge source of inspiration for type theorists. One of the most obvious things to consider is whether, and how, this correspondence for propositional logic can be extended to predicate or higher order logics. Dependent type theories initially arose from this avenue of exploration.For an introduction to the Curry-Howard isomorphism for simply-typed lambda calculus, see here. As an example, if we want to prove A \xe2\x88\xa7 B we must prove A and prove B; a combined proof is simply a pair of proofs: one for each conjunct.In natural deduction:and in simply-typed lambda calculus:Similar correspondences exist for \xe2\x88\xa8 and sum types, \xe2\x86\x92 and function types, and the various elimination rules.An unprovable (intuitionistically false) proposition corresponds to an uninhabited type.With the analogy of types as logical propositions in mind, we can start to consider how to model predicates in the type-world. There are many ways in which this has been formalised (see this introduction to Martin-L\xc3\xb6f\'s Intuitionistic Type Theory for a widely-used standard) but the abstract approach usually observes that a predicate is like a proposition with free term variables, or, alternatively, a function taking terms to propositions. If we allow type expressions to contain terms, then a treatment in lambda calculus style immediately presents itself as a possibility!Considering only constructive proofs, what constitutes a proof of \xe2\x88\x80x \xe2\x88\x88 X.P(x)? We can think of it as a proof function, taking terms (x) to proofs of their corresponding propositions (P(x)). So members (proofs) of the type (proposition) \xe2\x88\x80x : X.P(x) are \'dependent functions\', which for each x in X give a term of type P(x).What about \xe2\x88\x83x \xe2\x88\x88 X.P(x)? We need any member of X, x, together with a proof of P(x). So members (proofs) of the type (proposition) \xe2\x88\x83x : X.P(x) are \'dependent pairs\': a distinguished term x in X, together with a term of type P(x).Notation:\nI will usefor actual statements about members of the class X, andfor type expressions corresponding to universal quantification over type X. Likewise for \xe2\x88\x83.As well as the Curry-Howard correspondence of types with propositions, we have the combinatorial correspondence of algebraic types with numbers and functions, which is the main point of this question. Happily, this can be extended to the dependent types outlined above!I will use the modulus notationto represent the \'size\' of a type A, to make explicit the correspondence outlined in the question, between types and numbers. Note that this is a concept outside of the theory; I do not claim that there need be any such operator within the language.Let us count the possible (fully reduced, canonical) members of typewhich is the type of dependent functions taking terms x of type X to terms of type P(x). Each such function must have an output for every term of X, and this output must be of a particular type. For each x in X, then, this gives |P(x)| \'choices\' of output.The punchline iswhich of course doesn\'t make huge deal of sense if X is IO (), but is applicable to algebraic types.Similarly, a term of typeis the type of pairs (x, p) with p : P(x), so given any x in X we can construct an appropriate pair with any member of P(x), giving |P(x)| \'choices\'.Hence,with the same caveats.This justifies the common notation for dependent types in theories using the symbols \xce\xa0 and \xce\xa3, and indeed many theories blur the distinction between \'for all\' and \'product\' and between \'there is\' and \'sum\', due to the above-mentioned correspondences.We are getting close!Can we now encode numerical expressions likeas type expressions?Not quite. While we can informally consider the meaning of expressions like X\xe2\x81\xbf in Haskell, where X is a type and n a natural number, it\'s an abuse of notation; this is a type expression containing a number: distinctly not a valid expression.On the other hand, with dependent types in the picture, types containing numbers is precisely the point; in fact, dependent tuples or \'vectors\' are a very commonly-cited example of how dependent types can provide pragmatic type-level safety for operations like list access. A vector is just a list along with type-level information regarding its length: precisely what we are after for type expressions like X\xe2\x81\xbf.For the duration of this answer, letbe the type of length-n vectors of X-type values.Technically n here is, rather than an actual natural number, a representation in the system of a natural number. We can represent natural numbers (Nat) in Peano style as either zero (0) or the successor (S) of another natural number, and for n \xe2\x88\x88 \xe2\x84\x95 I write \xcb\xbbn\xcb\xbc to mean the term in Nat which represents n. For example, \xcb\xbb3\xcb\xbc is S (S (S 0)).Then we havefor any n \xe2\x88\x88 \xe2\x84\x95.Now we can encode expressions likeas types. This particular expression would give rise to a type which is of course isomorphic to the type of lists of X, as identified in the question. (Not only that, but from a category-theoretic point of view, the type function - which is a functor - taking X to the above type is naturally isomorphic to the List functor.)One final piece of the puzzle for \'arbitrary\' functions is how to encode, forexpressions likeso that we can apply arbitrary coefficients to a power series.We already understand the correspondence of algebraic types with numbers, allowing us to map from types to numbers and type functions to numerical functions. We can also go the other way! - taking a natural number, there is obviously a definable algebraic type with that many term members, whether or not we have dependent types. We can easily prove this outside of the type theory by induction. What we need is a way to map from natural numbers to types, inside the system.A pleasing realisation is that, once we have dependent types, proof by induction and construction by recursion become intimately similar - indeed they are the very same thing in many theories. Since we can prove by induction that types exist which fulfil our needs, should we not be able to construct them?There are several ways to represent types at the term level. I will use here an imaginary Haskellish notation with * for the universe of types, itself usually considered a type in a dependent setting.1Likewise, there are also at least as many ways to notate \'\xe2\x84\x95-elimination\' as there are dependent type theories. I will use a Haskellish pattern-matching notation.We need a mapping, \xce\xb1 from Nat to *, with the propertyThe following pseudodefinition suffices.So we see that the action of \xce\xb1 mirrors the behaviour of the successor S, making it a kind of homomorphism. Successor is a type function which \'adds one\' to the number of members of a type; that is, |Successor a| = 1 + |a| for any a with a defined size.For example \xce\xb1 \xcb\xbb4\xcb\xbc (which is \xce\xb1 (S (S (S (S 0))))), isand the terms of this type aregiving us exactly four elements: |\xce\xb1 \xcb\xbb4\xcb\xbc| = 4.Likewise, for any n \xe2\x88\x88 \xe2\x84\x95, we haveas required.Now we have the apparatus to express a fully general power series as a type!The seriesbecomes the typewhere \xcb\xbbf\xcb\xbc : Nat \xe2\x86\x92 Nat is some suitable representation within the language of the function f. We can see this as follows.Just how \'arbitrary\' is this? We are limited not only to integer coefficients by this method, but to natural numbers. Apart from that, f can be anything at all, given a Turing Complete language with dependent types, we can represent any analytic function with natural number coefficients.I haven\'t investigated the interaction of this with, for example, the case provided in the question of List X \xe2\x89\x85 1/(1 - X) or what possible sense such negative and non-integer \'types\' might have in this context.Hopefully this answer goes some way to exploring how far we can go with arbitrary type functions.