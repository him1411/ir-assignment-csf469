I understand the differences between DFS (Depth First Search) and BFS (Breadth First Search), but I\'m interested to know when it\'s more practical to use one over the other? Could anyone give any examples of how DFS would trump BFS and vice versa?That heavily depends on the structure of the search tree and the number and location of solutions (aka searched-for items). If you know a solution is not far from the root of the tree, a breadth first search (BFS) might be better. If the tree is very deep and solutions are rare, depth first search (DFS) might take an extremely long time, but BFS could be faster. If the tree is very wide, a BFS might need too much memory, so it might be completely impractical. If solutions are frequent but located deep in the tree, BFS could be impractical. If the search tree is very deep you will need to restrict the search depth for depth first search (DFS), anyway (for example with iterative deepening). But these are just rules of thumb; you\'ll probably need to experiment. Nice Explanation from \nhttp://www.programmerinterview.com/index.php/data-structures/dfs-vs-bfs/An example of BFSHere\xe2\x80\x99s an example of what a BFS would look like. This is something like Level Order Tree Traversal where we will use QUEUE with ITERATIVE approach (Mostly RECURSION will end up with DFS). The numbers represent the order in which the nodes are accessed in a BFS:In a depth first search, you start at the root, and follow one of the branches of the tree as far as possible until either the node you are looking for is found or you hit a leaf node ( a node with no children). If you hit a leaf node, then you continue the search at the nearest ancestor with unexplored children.An example of DFSHere\xe2\x80\x99s an example of what a DFS would look like. I think post order traversal in binary tree will start work from the Leaf level first. The numbers represent the order in which the nodes are accessed in a DFS:Differences between DFS and BFSComparing BFS and DFS, the big advantage of DFS is that it has much lower memory requirements than BFS, because it\xe2\x80\x99s not necessary to store all of the child pointers at each level. Depending on the data and what you are looking for, either DFS or BFS could be advantageous.For example, given a family tree if one were looking for someone on the tree who\xe2\x80\x99s still alive, then it would be safe to assume that person would be on the bottom of the tree. This means that a BFS would take a very long time to reach that last level. A DFS, however, would find the goal faster. But, if one were looking for a family member who died a very long time ago, then that person would be closer to the top of the tree. Then, a BFS would usually be faster than a DFS. So, the advantages of either vary depending on the data and what you\xe2\x80\x99re looking for.One more example is Facebook; Suggestion on Friends of Friends. We need immediate friends for suggestion where we can use BFS. May be finding the shortest path or detecting the cycle (using recursion) we can use DFS. Depth-first searches are often used in simulations of games (and game-like situations in the real world). In a typical game you can choose one of several possible actions. Each choice leads to further choices, each of which leads to further choices, and so on into an ever-expanding tree-shaped graph of possibilities.For example in games like Chess, tic-tac-toe when you are deciding what move to make, you can mentally imagine a move, then your opponent\xe2\x80\x99s possible responses, then your responses, and so on. You can decide what to do by seeing which move leads to the best outcome.Only some paths in a game tree lead to your win. Some lead to a win by your opponent, when you reach such an ending, you must back up, or backtrack, to a previous node and try a different path. In this way you explore the tree until you find a path with a successful conclusion. Then you make the first move along this path.The breadth-first search has an interesting property: It first finds all the vertices that are one edge away from the starting point, then all the vertices that are two edges away, and so on. This is useful if you\xe2\x80\x99re trying to find the shortest path from the starting vertex to a given vertex. You start a BFS, and when you find the specified vertex, you know the path you\xe2\x80\x99ve traced so far is the shortest path to the node. If there were a shorter path, the BFS would have found it already.Breadth-first search can be used for finding the neighbour nodes in peer to peer networks like BitTorrent, GPS systems to find nearby locations, social networking sites to find people in the specified distance and things like that.Breadth First Search is generally the best approach when the depth of the tree can vary, and you only need to search part of the tree for a solution. For example, finding the shortest path from a starting value to a final value is a good place to use BFS.Depth First Search is commonly used when you need to search the entire tree. It\'s easier to implement (using recursion) than BFS, and requires less state: While BFS requires you store the entire \'frontier\', DFS only requires you store the list of parent nodes of the current element.DFS is more space-efficient than BFS, but may go to unnecessary depths.Their names are revealing: if there\'s a big breadth (i.e. big branching factor), but very limited depth (e.g. limited number of "moves"), then DFS can be more preferrable to BFS.It should be mentioned that there\'s a less-known variant that combines the space efficiency of DFS, but (cummulatively) the level-order visitation of BFS, is the iterative deepening depth-first search. This algorithm revisits some nodes, but it only contributes a constant factor of asymptotic difference.When you approach this question as a programmer, one factor stands out: if you\'re using recursion, then depth-first search is simpler to implement, because you don\'t need to maintain an additional data structure containing the nodes yet to explore.Here\'s depth-first search for a non-oriented graph if you\'re storing \xe2\x80\x9calready visited\xe2\x80\x9d information in the nodes:If storing \xe2\x80\x9calready visited\xe2\x80\x9d information in a separate data structure:Contrast this with breadth-first search where you need to maintain a separate data structure for the list of nodes yet to visit, no matter what.One important advantage of BFS would be that it can be used to find the shortest path between any two nodes in an unweighted graph.\nWhereas, we cannot use DFS for the same.Some algorithms depend on particular properties of DFS (or BFS) to work. For example the Hopcroft and Tarjan algorithm for finding 2-connected components takes advantage of the fact that each already visited node encountered by DFS is on the path from root to the currently explored node.For BFS, we can consider Facebook example. We receive suggestion to add friends from the FB profile from other other friends profile. Suppose A->B, while B->E and B->F, so A will get suggestion for E And F. They must be using BFS to read till second level.\nDFS is more based on scenarios where we want to forecast something based on data we have from source to destination. As mentioned already about chess or sudoku.\nOnce thing I have different here is, I believe DFS should be used for shortest path because DFS will cover the whole path first then we can decide the best. But as BFS will use greedy\'s approach so might be it looks like its the shortest path, but the final result might differ. \nLet me know whether my understanding is wrong.According to the properties of DFS and BFS.\nFor example,when we want to find the shortest path.\nwe usually use bfs,it can guarantee the \'shortest\'.\nbut dfs only can guarantee that we can come from this point can achieve that point ,can not guarantee the \'shortest\'.Because Depth-First Searches use a stack as the nodes are processed, backtracking is provided with DFS.  Because Breadth-First Searches use a queue, not a stack, to keep track of what nodes are processed, backtracking is not provided with BFS.This is a good example to demonstrate that BFS is better than DFS in certain case. https://leetcode.com/problems/01-matrix/When correctly implemented, both solutions should visit cells that have farther distance than the current cell +1. \nBut DFS is inefficient and repeatedly visited the same cell resulting O(n*n) complexity.For example,