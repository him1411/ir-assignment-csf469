I want to use space as a delimiter with the cut command.What syntax can I use for this?Where 2 is the field number of the space-delimited field you want.Usually if you use space as delimiter, you want to treat multiple spaces as one, because you parse the output of a command aligning some columns with spaces. (and the google search for that lead me here)In this case a single cut command is not sufficient, and you need to use:Or You can also saynote that there are two spaces after the backslash.To complement the existing, helpful answers; tip of the hat to QZ Support for encouraging me to post a separate answer:Two distinct mechanisms come into play here:(a) whether cut itself requires the delimiter (space, in this case) passed to the -d option to be a separate argument or whether it\'s acceptable to append it directly to -d.(b) how the shell generally parses arguments before passing them to the command being invoked.(a) is answered by a quote from the POSIX guidelines for utilities (emphasis mine)If the SYNOPSIS of a standard utility shows an option with a mandatory option-argument [...] a conforming application shall use separate arguments for that option and its option-argument. However, a conforming implementation shall also permit applications to specify the option and option-argument in the same argument string without intervening  characters.In other words: In this case, because -d\'s option-argument is mandatory, you can choose whether to specify the delimiter as:Once you\'ve chosen (s) or (d), it is the shell\'s string-literal parsing - (b) - that matters:With approach (s), all of the following forms are EQUIVALENT:With approach (d), all of the following forms are EQUIVALENT:The  equivalence is explained by the shell\'s string-literal processing:All solutions above result in the exact same string (in each group) by the time cut sees them: (s): cut sees -d, as its own argument, followed by a separate argument that contains a space char - without quotes or \\ prefix!.(d): cut sees -d plus a space char - without quotes or \\ prefix! - as part of the same argument.The reason the forms in the respective groups are ultimately identical is twofold, based on how the shell parses string literals:I just discovered that you can also use "-d ":scut, a cut-like utility (smarter but slower I made) that can use any perl regex as a breaking token. Breaking on whitespace is the default, but you can also break on multi-char regexes, alternative regexes, etc.so the above command would break columns on whitespace and extract the (0-based) cols 6 2 8 7 in that order. You can\'t do it easily with cut if the data have for example multiple spaces. I have found sometimes useful to normalize input for easier processing. One trick is to use sed for normalization as below.