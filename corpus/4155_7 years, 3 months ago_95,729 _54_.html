License Keys are the defacto-standard as an anti-piracy measure. To be honest this strikes me as (in)Security Through Obscurity, although I really have no idea how License Keys are generated. What is a good (secure) example of License Key generation? What cryptographic primitive (if any) are they using? Is it a message digest? If so what data would they be hashing? What methods do developers employ to make it difficult for crackers to build their own key generators? How are key generators made?For old-school CD keys, it was just a matter of making up an algorithm for which CD keys (which could be any string) are easy to generate and easy to verify, but the ratio of valid-CD-keys to invalid-CD-keys is so small that randomly guessing CD keys is unlikely to get you a valid one.Starcraft and Half-life both used the same checksum, where the 13th digit verified the first 12.  Thus, you could enter anything for the first 12 digits, and guess the 13th (there\'s only 10 possibilities), leading to the infamous 1234-56789-1234The algorithm for verifying is public, and looks something like this:Windows XP takes quite a bit of information, encrypts it, and puts the letter/number encoding on a sticker.  This allowed MS to both verify your key and obtain the product-type (Home, Professional, etc.) at the same time.  Additionally, it requires online activation.\nThe full algorithm is rather complex, but outlined nicely in this (completely legal!) paper, published in Germany.Of course, no matter what you do, unless you are offering an online service (like World of Warcraft), any type of copy protection is just a stall:  unfortunately, if it\'s any game worth value, someone will break (or at least circumvent) the CD-key algorithm, and all other copyright protections.For online-services, life is a bit simpler, since even with the binary file you need to authenticate with their servers to make any use of it (eg. have a WoW account).  The CD-key algorithm for World of Warcraft - used, for instance, when buying playtime cards - probably looks something like this:For online services, there is no reason not to use the above scheme; using anything else can lead to problems.When I originally wrote this answer it was under an assumption that the question was regarding \'offline\' validation of licence keys.  Most of the other answers address online verification, which is significantly easier to handle (most of the logic can be done server side).With offline verification the most difficult thing is ensuring that you can generate a huge number of unique licence keys, and still maintain a strong algorithm that isnt easily compromised (such as a simple check digit)I\'m not very well versed in mathematics, but it struck me that one way to do this is to use a mathematical function that plots a graphThe plotted line can have (if you use a fine enough frequency) thousands of unique points, so you can generate keys by picking random points on that graph and encoding the values in some wayAs an example, we\'ll plot this graph, pick four points and encode into a string as "0,-500;100,-300;200,-100;100,600"We\'ll encrypt the string with a known and fixed key (horribly weak, but it serves a purpose), then convert the resulting bytes through Base32 to generate the final keyThe application can then reverse this process (base32 to real number, decrypt, decode the points) and then check each of those points is on our secret graph.Its a fairly small amount of code which would allow for a huge number of unique and valid keys to be generatedIt is however very much security by obscurity. Anyone taking the time to disassemble the code would be able to find the graphing function and encryption keys, then mock up a key generator, but its probably quite useful for slowing down casual piracy.Check tis article on Partial Key Verification which covers the following requirements:License keys must be easy enough to type in.We must be able to blacklist (revoke) a license key in the case of chargebacks or purchases with stolen credit cards.No \xe2\x80\x9cphoning home\xe2\x80\x9d to test keys.  Although this practice is becoming more and more prevalent, I still do not appreciate it as a user, so will not ask my users to put up with it.It should not be possible for a cracker to disassemble our released application and produce a working \xe2\x80\x9ckeygen\xe2\x80\x9d from it. This means that our application will not fully test a key for verification. Only some of the key is to be tested. Further, each release of the application should test a different portion of the key, so that a phony key based on an earlier release will not work on a later release of our software.Important: it should not be possible for a legitimate user to accidentally type in an invalid key that will appear to work but fail on a future version due to a typographical error.I\'ve not got any experience with what people actually do to generate CD keys, but (assuming you\'re not wanting to go down the road of online activation) here are a few ways one could make a key:Require that the number be divisible by (say) 17.  Trivial to guess, if you have access to many keys, but the majority of potential strings will be invalid.  Similar would be requiring that the checksum of the key match a known value.Require that the first half of the key, when concatenated with a known value, hashes down to the second half of the key.  Better, but the program still contains all the information needed to generate keys as well as to validate them.Generate keys by encrypting (with a private key) a known value + nonce.  This can be verified by decrypting using the corresponding public key and verifying the known value.  The program now has enough information to verify the key without being able to generate keys.These are still all open to attack: the program is still there and can be patched to bypass the check.  Cleverer might be to encrypt part of the program using the known value from my third method, rather than storing the value in the program.  That way you\'d have to find a copy of the key before you could decrypt the program, but it\'s still vulnerable to being copied once decrypted and to having one person take their legit copy and use it to enable everyone else to access the software.CD-Keys aren\'t much of a security for any non-networked stuff, so technically they don\'t need to be securely generated. If you\'re on .net, you can almost go with Guid.NewGuid().Their main use nowadays is for the Multiplayer component, where a server can verify the CD Key. For that, it\'s unimportant how securely it was generated as it boils down to "Lookup whatever is passed in and check if someone else is already using it".That being said, you may want to use an algorhithm to achieve two goals:That being said, you still want a large distribution and some randomness to avoid a pirate simply guessing a valid key (that\'s valid in your database but still in a box on a store shelf) and screwing over a legitimate customer who happens to buy that box.If you aren\'t particularly concerned with the length of the key, a pretty tried and true method is the use of public and private key encryption.Essentially have some kind of nonce and a fixed signature.For example:\n0001-123456789Where 0001 is your nonce and 123456789 is your fixed signature.Then encrypt this using your private key to get your CD key which is something like:\nABCDEF9876543210Then distribute the public key with your application. The public key can be used to decrypt the CD key "ABCDEF9876543210", which you then verify the fixed signature portion of.This then prevents someone from guessing what the CD key is for the nonce 0002 because they don\'t have the private key.The only major down side is that your CD keys will be quite long when using private / public keys 1024-bit in size. You also need to choose a nonce long enough so you aren\'t encrypting a trivial amount of information.The up side is that this method will work without "activation" and you can use things like an email address or licensee name as the nonce.The key system must have several properties:One solution that should give you these would be to use a public key signing scheme. Start with a "system hash" (say grab the macs on any NICs, sorted, and the CPU-ID info, plus some other stuff, concatenate it all together and take an MD5 of the result (you really don\'t want to be handling personally identifiable information if you don\'t have to)) append the CD\'s serial number and refuse to boot unless some registry key (or some datafile) has a valid signature for the blob. The user activates the program by shipping the blob to you and you ship back the signature.Potential issues include that you are offering to sign practically anything so you need to assume someone will run a chosen plain text and/or chosen ciphertext attacks. That can be mitigated by checking the serial number provided and refusing to handle request from invalid ones as well as refusing to handle more than a given number of queries from a given s/n in an interval (say 2 per year)I should point out a few things: First, a skilled and determined attacker will be able to bypass any and all security in the parts that they have unrestricted access to (i.e. everything on the CD), the best you can do on that account is make it harder to get illegitimate access than it is to get legitimate access. Second, I\'m no expert so there could be serious flaws in this proposed scheme. All of the CD only copy protection algorithms inconvience honest users while providing no protection against piracy whatsoever.The "pirate" only need to have access to one legitimate cd and its access code, he can then make n copies and distribute them.It does not matter how cryptographically secure you make the code, you need to supply this with the CD in plain text or an legitimate user cannot activite the software.Most secure schemes involve either the user providing the software supplier with some details of the machine which will run the software (cpu serial numbers, mac addresses, Ip address etc.), or, require online access to register the software on the suppliers website and in return receive an activitation token. The first option requires a lot of manual administration and is only worth it for very high value software, the, second option can be spoofed and is absolutly infuriating if you have limited network access or you are stuck behind a firewall.On the whole its much easier to establish a trust relationship with your customers!There are also DRM behaviors that incorporate multiple steps to the process.  One of the most well known examples is one of Adobe\'s methods for verifying an installation of their Creative Suite.  The traditional CD Key method discussed here is used, then Adobe\'s support line is called.  The CD key is given to the Adobe representative and they give back an activation number to be used by the user.However, despite being broken up into steps, this falls prey to the same methods of cracking used for the normal process.  The process used to create an activation key that is checked against the original CD key was quickly discovered, and generators that incorporate both of the keys were made.However, this method still exists as a way for users with no internet connection to verify the product.  Going forward, it\'s easy to see how these methods would be eliminated as internet access becomes ubiquitous.