Most of the tutorials that I\'ve read on arrays in JavaScript (including w3schools and devguru) suggest that you can initialize an array with a certain length by passing an integer to the Array constructor using the var test = new Array(4); syntax.After using this syntax liberally in my js files, I ran one of the files through jsLint, and it freaked out:Error: Problem at line 1 character 22: Expected \')\' and instead saw \'4\'.\n  var test = new Array(4);\n  Problem at line 1 character 23: Expected \';\' and instead saw \')\'.\n  var test = new Array(4);\n  Problem at line 1 character 23: Expected an identifier and instead saw \')\'.After reading through jsLint\'s explanation of its behavior, it looks like jsLint doesn\'t really like the new Array() syntax, and instead prefers [] when declaring arrays.So I have a couple questions.  First, why?  Am I running any risk by using the new Array() syntax instead?  Are there browser incompatibilities that I should be aware of?  And second, if I switch to the square bracket syntax, is there any way to declare an array and set its length all on one line, or do I have to do something like this:Why do you want to initialize the length? Theoretically there is no need for this. It can even result in confusing behavior, because all tests that use the length to find out whether an array is empty or not will report that the array is not empty.\nSome tests show that setting the initial length of large arrays can be more efficient if the array is filled afterwards, but the performance gain (if any) seem to differ from browser to browser.jsLint does not like new Array() because the constructer is ambiguous.creates an empty array of length 4. Butcreates an array containing the value \'4\'.Regarding your comment: In JS you don\'t need to initialize the length of the array. It grows dynamically. You can just store the length in some variable, e.g.Array(5) gives you an array with length 5 but no values, hence you can\'t iterate over it.Array.apply(null, Array(5)).map(function () {}) gives you an array with length 5 and undefined as values, now it can be iterated over.Array.apply(null, Array(5)).map(function (x, i) { return i; }) gives you an array with length 5 and values 0,1,2,3,4.Array(5).forEach(alert) does nothing, Array.apply(null, Array(5)).forEach(alert) gives you 5 alertsES6 gives us Array.from so now you can also use Array.from(Array(5)).forEach(alert)If you want to initialize with a certain string value, Array.from(\'abcde\') or Array.from(\'x\'.repeat(5)) are good to knows...With ES2015 .fill() you can now simply do:Which is a lot more concise than Array.apply(0, new Array(n)).map(i => 0)This will initialize the length property to 4:I\'m surprised there hasn\'t been a functional solution suggested that allows you to set the length in one line. The following is based on UnderscoreJS:For reasons mentioned above, I\'d avoid doing this unless I wanted to initialize the array to a specific value. It\'s interesting to note there are other libraries that implement range including Lo-dash and Lazy, which may have different performance characteristics.(this was probably better as a comment, but got too long)So, after reading this I was curious if pre-allocating was actually faster, because in theory it should be. However, this blog gave some tips advising against it http://www.html5rocks.com/en/tutorials/speed/v8/.So still being unsure, I put it to the test. And as it turns out it seems to in fact be slower.This code yields the following after a few casual runs:The reason you shouldn\'t use new Array is demonstrated by this code:Some other code could mess with the Array variable. I know it\'s a bit far fetched that anyone would write such code, but still...Also, as Felix King said, the interface is a little inconsistent, and could lead to some very difficult-to-track-down bugs.If you wanted an array with length = x, filled with undefined (as new Array(x) would do), you could do this:The array constructor has an ambiguous syntax, and JSLint just hurts your feelings after all.Also, your example code is broken, the second var statement will raise a SyntaxError. You\'re setting the property length of the array test, so there\'s no need for another var.As far as your options go, array.length is the only "clean" one. Question is, why do you need to set the size in the first place? Try to refactor your code to get rid of that dependency. Please people don\'t give up your old habits just yet.\nThere is a large difference in complexity between allocating memory once then working with the entries in that array (as of old), and allocating it many times as an array grows (which is inevitably what the system does under the hood with other suggested methods).None of this matters of course, until you want to do something cool with larger arrays. Then it does.Seeing as there still seems to be no option in JS at the moment to set the initial capacity of an array, I use the following...There are tradeoffs involved:But if it fits with what you\'re doing there can be a payoff.\nInformal timing putsat pretty speedy (about 50ms for the 10000 given that with n=1000000 it took about 5 seconds), andat well over a minute (about 90 sec for the 10000 on the same chrome console, or about 2000 times slower).\nThat won\'t just be the allocation, but also the 10000 pushes, for loop, etc..Here is another solution The first argument of apply() is a this object binding, which we don\'t care about here, so we set it to null. Array.apply(..) is calling the Array(..) function and spreading out the { length: 3 } object value as its arguments.As explained above, using new Array(size) is somewhat dangerous. Instead of using it directly, place it inside an "array creator function". You can easily make sure that this function is bug-free and you avoid the danger of calling new Array(size) directly. Also, you can give it an optional default initial value. This createArray function does exactly that:You can set the array length by using array.length = youValueSo it would be