I can print with printf as a hex or octal number.  Is there a format tag to print as binary, or arbitrary base?  I am running gcc.Hacky but works for me:For multi-byte types You need all the extra quotes unfortunately. This approach has the efficiency risks of macros (don\'t pass a function as the argument to BYTE_TO_BINARY) but avoids the memory issues and multiple invocations of strcat in some of the other proposals here.Print Binary for Any DatatypetestHere is a quick hack to demonstrate techniques to do what you want.  There isn\'t a binary conversion specifier in glibc normally.It is possible to add custom conversion types to the printf() family of functions in glibc. See  register_printf_function for details. You could add a custom %b conversion for your own use, if it simplifies the application code to have it available.Here is an example of how to implement a custom printf formats in glibc.Here\'s a version of the function that does not suffer from reentrancy issues or limits on the size/type of the argument:Note that this code would work just as well for any base between 2 and 10 if you just replace the 2\'s by the desired base. Usage is:Where x is any integral expression.Surprised that no one said this, but you could use a small table to improve speed1. Similar techniques are useful in the embedded world for example to invert a byte:1 I\'m mostly referring to embedded applications where optimizers are not so aggressive and the speed difference is visible.Print the least significant bit and shift it out on the right. Doing this until the integer becomes zero prints the binary representation without leading zeros but in reversed order. Using recursion, the order can be corrected quite easily.To me, this is one of the cleanest solutions to the problem. If you like 0b prefix and a trailing new line character, I suggest wrapping the function.Online demoNone of the above is exactly what I was looking for, so I wrote one. super simple to use %B in the printf!Based on @William Whyte\'s answer, this is a macro that provides int8,16,32 & 64 versions, reusing the INT8 macro to avoid repetition.This outputs:For readability you may want to add a separator for eg:Some runtimes support "%b" although that is not a standard.Also see here for an interesting discussion:http://bytes.com/forum/thread591027.htmlHTHThis code should handle your needs up to 64 bits.\nI created 2 functions pBin & pBinFill.  Both do the same thing, but pBinFill fills in the leading spaces with the fillChar.\nThe test function generates some test data, then prints it out using the function.There is no formating function in the C standard library to output binary like that. All the format operation the printf family supports are towards human readable text.I optimized the top solution for size and C++-ness, and got to this solution:Maybe a bit OT, but if you need this only for debuging to understand or retrace some binary operations you are doing, you might take a look on wcalc (a simple console calculator). With the -b options you get binary output.e.g.the following recursive function might be usefulThe printf() family is only able to print in base 8, 10, and 16 using the standard specifiers directly.  Suggest creating a function that converts the number to a string per code\'s particular needs.All other answers so far have at least one of these limitations.Use static memory for the return buffer.  This limits the number of times the function may be used as a argument to printf().Allocate memory requiring the calling code to free pointers.Require the calling code to explicitly provide a suitable buffer.Call printf() directly.  This obliges a new function for to fprintf(), sprintf(), vsprintf(), etc.Use a reduced range of integers.The following has none of the above  limitation.  It does require C99 or later and use of "%s".  It uses a compound literal to provide the buffer space.  It has no trouble with multiple calls in a printf().OutputNo standard and portable way.Some implementations provide itoa(), but it\'s not going to be in most, and it has a somewhat crummy interface.  But the code is behind the link and should let you implement your own formatter pretty easily.My solution:should work - untested.I liked the code by paniq, the static buffer is a good idea. However it fails if you want multiple binary formats in a single printf() because it always returns the same pointer and overwrites the array. Here\'s a C style drop-in that rotates pointer on a split buffer.Next will show to you memory layout:for more ref. how to print binary number via printfHere is a small variation of paniq\'s solution that uses templates to allow printing of 32 and 64 bit integers:And can be used like:Here is the result:I just want to post my solution. It\'s used to get zeroes and ones of one byte, but calling this function few times can be used for larger data blocks. I use it for 128 bit or larger structs. You can also modify it to use size_t as input parameter and pointer to data you want to print, so it can be size independent. But it works for me quit well as it is.Here\'s how I did it for an unsigned intA small utility function in C to do this while solving a bit manipulation problem. This goes over the string checking each set bit using a mask (1<\n\nYet another approach to print in binary: Convert the integer first.To print 6 in binary, change 6 to 110, then print "110".Bypasses char buf[] issues.\nprintf() format specifiers, flags, & fields like "%08lu", "%*lX" still readily usable.\nNot only binary (base 2), this method expandable to other bases up to 16.\nLimited to smallish integer values.  