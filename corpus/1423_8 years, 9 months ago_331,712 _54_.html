I\'m wondering if there is a "best" choice for collation in MySQL for a general website where you aren\'t 100% sure of what will be entered? I understand that all the encodings should be the same, such as MySQL, Apache, the HTML and anything inside PHP.In the past I have set PHP to output in "UTF-8", but which collation does this match in MySQL? I\'m thinking it\'s one of the UTF-8 ones, but I have used utf8_unicode_ci, utf8_general_ci, and utf8_bin before.The main difference is sorting accuracy (when comparing characters in the language) and performance. The only special one is utf8_bin which is for comparing characters in binary format.utf8_general_ci is somewhat faster than utf8_unicode_ci, but less accurate (for sorting). The specific language utf8 encoding (such as utf8_swedish_ci) contain additional language rules that make them the most accurate to sort for those languages. Most of the time I use utf8_unicode_ci (I prefer accuracy to small performance improvements), unless I have a good reason to prefer a specific language.You can read more on specific unicode character sets on the MySQL manual - http://dev.mysql.com/doc/refman/5.0/en/charset-unicode-sets.htmlBe very, very aware of this problem that can occur when using utf8_general_ci.MySQL will not distinguish between some characters in select statements, if the utf8_general_ci collation is used. This can lead to very nasty bugs - especially for example, where usernames are involved. Depending on the implementation that uses the database tables, this problem could allow malicious users to create a username matching an administrator account.This problem exposes itself at the very least in early 5.x versions - I\'m not sure if this behaviour as changed later.I\'m no DBA, but to avoid this problem, I always go with utf8-bin instead of a case-insensitive one.The script below describes the problem by example.Actually, you probably want to use utf8_unicode_ci or utf8_general_ci.However, if you are only using this to store English text, these shouldn\'t differ.It is best to use character set utf8mb4 with the collation utf8mb4_unicode_ci.The character set, utf8, only supports a small amount of UTF-8 code points, about 6% of possible characters. utf8 only supports the Basic Multilingual Plane (BMP). There 16 other planes. Each plane contains 65,536 characters. utf8mb4 supports all 17 planes.MySQL will truncate 4 byte UTF-8 characters resulting in corrupted data.The utf8mb4 character set was introduced in MySQL 5.5.3 on 2010-03-24.Some of the required changes to use the new character set are not trivial:NOTE: Switching to Barracuda from Antelope, may require restarting the MySQL service more than once. innodb_file_format_max does not change until after the MySQL service has been restarted to: innodb_file_format = barracuda.MySQL uses the old Antelope InnoDB file format. Barracuda supports dynamic row formats, which you will need if you do not want to hit the SQL errors for creating indexes and keys after you switch to the charset: utf8mb4The following scenario has been tested on MySQL 5.6.17:\nBy default, MySQL is configured like this:Stop your MySQL service and add the options to your existing my.cnf:Example SQL CREATE statement:NOTE: Changing the index to limit to the first 128 characters on contacteliminates the requirement for using Barracuda with ROW_FORMAT=DYNAMIC Also note: when it says the size of the field is VARCHAR(128), that is not 128 bytes. You can use have 128, 4 byte characters or 128, 1 byte characters.This INSERT statement should contain the 4 byte \'poo\' character in the 2 row:You can see the amount of space used by the last column:In your database adapter, you may want to set the charset and collation for your connection:In PHP, this would be set for: \\PDO::MYSQL_ATTR_INIT_COMMANDReferences:Collations affect how data is sorted and how strings are compared to each other. That means you should use the collation that most of your users expect.Example from the documentation:utf8_general_ci also is satisfactory\n  for both German and French, except\n  that \xe2\x80\x98\xc3\x9f\xe2\x80\x99 is equal to \xe2\x80\x98s\xe2\x80\x99, and not to\n  \xe2\x80\x98ss\xe2\x80\x99. If this is acceptable for your\n  application, then you should use\n  utf8_general_ci because it is faster.\n  Otherwise, use utf8_unicode_ci because\n  it is more accurate.So - it depends on your expected user base and on how much you need correct sorting. For an English user base, utf8_general_ci should suffice, for other languages, like Swedish, special collations have been created.Essentially, it depends on how you think of a string.I always use utf8_bin because of the problem highlighted by Guus.  In my opinion, as far as the database should be concerned, a string is still just a string.  A string is a number of UTF-8 characters.  A character has a binary representation so why does it need to know the language you\'re using?  Usually, people will be constructing databases for systems with the scope for multilingual sites.  This is the whole point of using UTF-8 as a character set.  I\'m a bit of a pureist but I think the bug risks heavily outweigh the slight advantage you may get on indexing.  Any language related rules should be done at a much higher level than the DBMS.In my books "value" should never in a million years be equal to "val\xc3\xbae".If I want to store a text field and do a case insensitive search, I will use MYSQL string functions with PHP functions such as LOWER() and the php function strtolower().For UTF-8 textual information, you should use utf8_general_ci because...utf8_bin: compare strings by the\nbinary value of each character in\nthe stringutf8_general_ci: compare strings\nusing general language rules and\nusing case-insensitive comparisonsa.k.a. it will should making searching and indexing the data faster/more efficient/more useful.The accepted answer fairly definitively suggests using utf8_unicode_ci, and whilst for new projects that\'s great, I wanted to relate my recent contrary experience just in case it saves anyone some time.Because utf8_general_ci is the default collation for Unicode in MySQL, if you want to use utf8_unicode_ci then you end up having to specify it in a lot of places.For example, all client connections not only have a default charset (makes sense to me) but also a default collation (i.e. the collation will always default to utf8_general_ci for unicode).Likely, if you use utf8_unicode_ci for your fields, your scripts that connect to the database will need to be updated to mention the desired collation explicitly -- otherwise queries using text strings can fail when your connection is using the default collation.The upshot is that when converting an existing system of any size to Unicode/utf8, you may end up being forced to use utf8_general_ci because of the way MySQL handles defaults.For the case highlighted by Guus, I would strongly suggest using either utf8_unicode_cs (case sensitive, strict matching, ordering correctly for the most part) instead of utf8_bin (strict matching, incorrect ordering).If the field is intended to be searched, as opposed to matched for a user, then use utf8_general_ci or utf8_unicode_ci. Both are case-insensitive, one will losely match (\xe2\x80\x98\xc3\x9f\xe2\x80\x99 is equal to \xe2\x80\x98s\xe2\x80\x99, and not to \xe2\x80\x98ss\xe2\x80\x99). There are also language specific versions, like utf8_german_ci where the lose matching is more suitable for the language specified.I found these collation charts helpful. http://collation-charts.org/mysql60/. I\'m no sure which is the used utf8_general_ci though.For example here is the chart for utf8_swedish_ci. It shows which characters it interprets as the same. http://collation-charts.org/mysql60/mysql604.utf8_swedish_ci.htmlIn your database upload file, add the followin line before any line:And your problem should be solved.For the casee field is intended to be searched, as opposed to matched for a user, then use utf8_general_ce field is intended to be searched, as opposed to matched for a user, then use utf8_general_ci or utf8_unicode_ci. Both are case-insensitive, one will losely match (\xe2\x80\x98\xc3\x9f\xe2\x80\x99 is equal to \xe2\x80\x98s\xe2\x80\x99, and not to \xe2\x80\x98ss\xe2\x80\x99). There are also language specific versions, like utf8_german_ci where the lose matching is more suitable for the language specified.i or utf8_unicode_ci. Both are case-insensitive, one will losely match (\xe2\x80\x98\xc3\x9f\xe2\x80\x99 is equal to \xe2\x80\x98s\xe2\x80\x99, and not to \xe2\x80\x98ss\xe2\x80\x99). There are also language specific versions, like utf8_german_ci where the lose matching is more suitable for the language specified. highlighted by Guus, I would strongly suggest using either utf8_unicode_cs (case sensitive, strict matching, ordering ce field is intended to be searched, as opposed to matched for a user, then use utf8_general_ci or utf8_unicode_ci. Both are case-insensitive, one will losely match (\xe2\x80\x98\xc3\x9f\xe2\x80\x99 is equal to \xe2\x80\x98s\xe2\x80\x99, and not to \xe2\x80\x98ss\xe2\x80\x99). There are also language specific versions, like utf8_german_ci where the lose matching is more suitable for the language specified.orrectly for the most part) instead of utf8_bin (strict matching, incorrect ordering).If the field is intended to be searched, as opposed to matched for a user, then use utf8_general_ci or utf8_unicode_ci. Both are case-insensitive, one will losely match (\xe2\x80\x98\xc3\x9f\xe2\x80\x99 is equal to \xe2\x80\x98s\xe2\x80\x99, and not to \xe2\x80\x98ss\xe2\x80\x99). There are also language specific versions, like utf8_german_ci where the lose matching is more suitable for the language specified.