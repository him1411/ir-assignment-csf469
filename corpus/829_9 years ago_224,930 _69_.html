What is the difference between const and readonly and do you use one over the other?Apart from the apparent difference of There is a subtle difference. Consider a class defined in AssemblyA.AssemblyB references AssemblyA and uses these values in code. When this is compiled, So if you are confident that the value of the constant won\'t change use a const. But if you have a constant that may change (e.g. w.r.t. precision).. or when in doubt, use a readonly. Update: Aku needs to get a mention coz he pointed this out first. Also I need to plug where I learned this.. Effective C# - Bill WagnerThere is a gotcha with consts! If you reference a constant from another assembly, its value will be compiled right into the calling assembly. That way when you update the constant in the referenced assembly it won\'t change in the calling assembly!Just to add, ReadOnly for reference types only makes the reference readonly not the values. For example:This explains it. Summary: const must be initialized at declaration time, readonly can be initialized on the constructor (and thus have a different value depending on the constructor used).EDIT: See Gishu\'s gotcha above for the subtle differenceThere is a small gotcha with readonly. A readonly field can be set multiple times within the constructor(s). Even if the value is set in two different chained constructors it is still allowed.const: Can\'t be changed anywhere.readonly: This value can only be changed in the constructor. Can\'t be changed in normal functions.A const is a compile-time constant whereas readonly allows a value to be calculated at run-time and set in the constructor or field initializer. So, a \'const\' is always constant but \'readonly\' is read-only once it is assigned.Eric Lippert of the C# team has more information on different types of immutabilityHere\'s another link demonstrating how const isn\'t version safe, or relevant for reference types.Summary:A constant member is defined at compile time and cannot be changed at runtime. Constants are declared as a field, using the const keyword and must be initialized as they are declared.A readonly member is like a constant in that it represents an unchanging value. The difference is that a readonly member can be initialized at runtime, in a constructor, as well being able to be initialized as they are declared.constreadonlyYet another gotcha: readonly values can be changed by "devious" code via reflection.Can I change a private readonly inherited field in C# using reflection?I believe a const value is the same for all objects (and must be initialized with a literal expression), whereas readonly can be different for each instantiation...Variables marked const are little more than strongly typed #define macros, at compile time const variable references are replaced with inline literal values. As a consequence only certain built-in primitive value types can be used in this way. Variables marked readonly can be set, in a constructor, at run-time and their read-only-ness is enforced during run-time as well. There is some minor performance cost associated with this but it means you can use readonly with any type (even reference types).Also, const variables are inherently static, whereas readonly variables can be instance specific if desired.The readonly keyword is different from the const keyword. A const field can only be initialized at the declaration of the field. A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields can have different values depending on the constructor used. Also, while a const field is a compile-time constant, the readonly field can be used for runtime constants as in the following example:Another gotcha.\nSince const really only works with basic data types, if you want to work with a class, you may feel "forced" to use ReadOnly.  However, beware of the trap!  ReadOnly means that you can not replace the object with another object (you can\'t make it refer to another object).  But any process that has a reference to the object is free to modify the values inside the object!\nSo don\'t be confused into thinking that ReadOnly implies a user can\'t change things.  There is no simple syntax in C# to prevent an instantiation of a class from having its internal values changed (as far as I know).One of the team members in our office provided the following guidance on when to use const, static, and readonly:One final note: a const field is static, but the inverse is not true.They are both constant, but a const is available also at compile time. This means that one aspect of the difference is that you can use const variables as input to attribute constructors, but not readonly variables.Example:There is notable difference between const and readonly fields in C#.Netconst is by default static and needs to be initialized with constant value, which can not be modified later on. Change of value is not allowed in constructors, too. It can not be used with all datatypes. For ex- DateTime. It can not be used with DateTime datatype.readonly can be declared as static, but not necessary. No need to initialize at the time of declaration. Its value can be assigned or changed using constructor. So, it gives advantage when used as instance class member. Two different instantiation may have different value of readonly field. For ex -Then readonly field can be initialised with instant specific values, as follows:Here, instance objOne will have value of readonly field as 5 and objTwo has 10. Which is not possible using const.ConstantWe need to provide the value to the const field when it is defined. The compiler then saves the constant\xe2\x80\x99s value in the assembly\xe2\x80\x99s metadata. This means that a constant can be defined only for the primitive type like boolean, char, byte and so on. Constants are always considered static members, not instance members. ReadonlyReadonly fields can only be resolved at runtime. That means we can define a value for a value using the constructor for the type in which the field is declared. The verification is done by the compiler that readonly fields are not written to by any method other than the constructor.More about both explained here in this articleThe readonly keyword is different from the const keyword. A const field can only be initialized at the declaration of the field. A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields can have different values depending on the constructor used. Also, while a const field is a compile-time constant, the readonly field can be used for runtime constants as in the following example:Read Only : \nValue can be changed through Ctor at runtime. But not through member FunctionConstant : \nBy defult static. Value cannot be changed from anywhere ( Ctor, Function, runtime etc no-where)Principally; you can assign a value to a static readonly field to a non-constant value at runtime, whereas a const has to be assigned a constant value.A constant will be compiled into the consumer as a literal value while the static string will serve as a reference to the value defined.As an exercise, try creating an external library and consume it in a console application, then alter the values in the library and recompile it (without recompiling the consumer program), drop the DLL into the directory and run the EXE manually, you should find that the constant string does not change.A const has to be hard-coded, where as readonly can be set in the constructor of the class.Const and readonly are similar, but they are not exactly the same. A const field is a compile-time constant, meaning that that value can be computed at compile-time. A readonly field enables additional scenarios in which some code must be run during construction of the type. After construction, a readonly field cannot be changed.For instance, const members can be used to define members like:since values like 3.14 and 0 are compile-time constants. However, consider the case where you define a type and want to provide some pre-fab instances of it. E.g., you might want to define a Color class and provide "constants" for common colors like Black, White, etc. It isn\'t possible to do this with const members, as the right hand sides are not compile-time constants. One could do this with regular static members:but then there is nothing to keep a client of Color from mucking with it, perhaps by swapping the Black and White values. Needless to say, this would cause consternation for other clients of the Color class. The "readonly" feature addresses this scenario. By simply introducing the readonly keyword in the declarations, we preserve the flexible initialization while preventing client code from mucking around.It is interesting to note that const members are always static, whereas a readonly member can be either static or not, just like a regular field.It is possible to use a single keyword for these two purposes, but this leads to either versioning problems or performance problems. Assume for a moment that we used a single keyword for this (const) and a developer wrote:and a different developer wrote code that relied on A:Now, can the code that is generated rely on the fact that A.C is a compile-time constant? I.e., can the use of A.C simply be replaced by the value 0? If you say "yes" to this, then that means that the developer of A cannot change the way that A.C is initialized -- this ties the hands of the developer of A without permission. If you say "no" to this question then an important optimization is missed. Perhaps the author of A is positive that A.C will always be zero. The use of both const and readonly allows the developer of A to specify the intent. This makes for better versioning behavior and also better performance.ReadOnly :The value will be initialized only once from the constructor of the class.\nconst: can be initialized in any function but only onceThe difference is that the value of a static readonly field is set at run time, so it can have a different value for different executions of the program. However, the value of a const field is set to a compile time constant.  Remember:\nFor reference types, in both cases (static and instance), the readonly modifier only prevents you from assigning a new reference to the field. It specifically does not make immutable the object pointed to by the reference.For details, please refer to C# Frequently Asked Questions on this topic:\nhttp://blogs.msdn.com/csharpfaq/archive/2004/12/03/274791.aspxConstant variables are declared and initialized at compile time. The value can\xe2\x80\x99t be changed after wards. Read-only variables will be initialized only from the Static constructor of the class. Read only is used only when we want to assign the value at run time.A const field can only be initialized at the declaration of the field. A readonly field can be initialized either at the declaration or in a constructor.One thing to add to what people have said above. If you have an assembly containing a readonly value (e.g. readonly MaxFooCount = 4; ), you can change the value that calling assemblies see by shipping a new version of that assembly with a different value (e.g.  readonly MaxFooCount = 5;)But with a const, it would be folded into the caller\'s code when the caller was compiled.If you\'ve reached this level of C# proficiency, you are ready for Bill Wagner\'s book, Effective C#: 50 Specific Ways to Improve Your C#\nWhich answers this question in detail, (and 49 other things).