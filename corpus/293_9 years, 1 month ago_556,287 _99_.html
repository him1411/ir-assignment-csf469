This came to my mind after I learned the following from this question:We, C# developers, all know the basics of C#. I mean declarations, conditionals, loops, operators, etc.Some of us even mastered the stuff like Generics, anonymous types, lambdas, LINQ, ...But what are the most hidden features or tricks of C# that even C# fans, addicts, experts barely know?This isn\'t C# per se, but I haven\'t seen anyone who really uses System.IO.Path.Combine() to the extent that they should. In fact, the whole Path class is really useful, but no one uses it!I\'m willing to bet that every production app has the following code, even though it shouldn\'t:lambdas and type inferrence are underrated. Lambdas can have multiple statements and they double as a compatible delegate object automatically (just make sure the signature match) as in:Note that I don\'t have a new CancellationEventHandler nor do I have to specify types of sender and e, they\'re inferable from the event. Which is why this is less cumbersome to writing the whole delegate (blah blah) which also requires you to specify types of parameters.Lambdas don\'t need to return anything and type inference is extremely powerful in context like this.And BTW, you can always return Lambdas that make Lambdas in the functional programming sense. For example, here\'s a lambda that makes a lambda that handles a Button.Click event:Note the chaining: (dx, dy) => (sender, e) =>Now that\'s why I\'m happy to have taken the functional programming class :-)Other than the pointers in C, I think it\'s the other fundamental thing you should learn :-)From Rick Strahl:You can chain the ?? operator so that you can do a bunch of null comparisons.Aliased generics:It allows you to use ASimpleName, instead of Dictionary<string, Dictionary<string, List<string>>>.Use it when you would use the same generic big long complex thing in a lot of places.From CLR via C#:When normalizing strings, it is highly\n  recommended that you use\n  ToUpperInvariant instead of\n  ToLowerInvariant because Microsoft has\n  optimized the code for performing\n  uppercase comparisons.I remember one time my coworker always changed strings to uppercase before comparing. I\'ve always wondered why he does that because I feel it\'s more "natural" to convert to lowercase first. After reading the book now I know why.My favorite trick is using the null coalesce operator and parentheses to automagically instantiate collections for me.Avoid checking for null event handlersAdding an empty delegate to events at declaration, suppressing the need to always check the event for null before calling it is awesome. Example:Let you do thisInstead of thisPlease also see this related discussion and this blog post by Eric Lippert on this topic (and possible downsides).Everything else, plus 1) implicit generics (why only on methods and not on classes?)2) simple lambdas with one parameter:3) anonymous types and initialisers:Another one:4) Auto properties can have different scopes:Thanks @pzycoman for reminding me:5) Namespace aliases (not that you\'re likely to need this particular distinction):I didn\'t know the "as" keyword for quite a while.vsThe second will return null if obj isn\'t a MyClass, rather than throw a class cast exception.Two things I like are Automatic properties so you can collapse your code down even further:becomesAlso object initializers:becomesThe \'default\' keyword in generic types:results in a \'null\' if T is a reference type, and 0 if it is an int, false if it is a boolean,\netcetera.Attributes in general, but most of all DebuggerDisplay. Saves you years.The @ tells the compiler to ignore any\n  escape characters in a string.Just wanted to clarify this one... it doesn\'t tell it to ignore the escape characters, it actually tells the compiler to interpret the string as a literal.If you have it will actually print out as (note that it even includes the whitespace used for indentation):I think one of the most under-appreciated and lesser-known features of C# (.NET 3.5) are Expression Trees, especially when combined with Generics and Lambdas. This is an approach to API creation that newer libraries like NInject and Moq are using.For example, let\'s say that I want to register a method with an API and that API needs to get the method nameGiven this class:Before, it was very common to see developers do this with strings and types (or something else largely string-based):Well, that sucks because of the lack of strong-typing. What if I rename "SomeMethod"? Now, in 3.5 however, I can do this in a strongly-typed fashion:In which the RegisterMethod class uses Expression<Action<T>> like this:This is one big reason that I\'m in love with Lambdas and Expression Trees right now."yield" would come to my mind. Some of the attributes like [DefaultValue()] are also among my favorites.The "var" keyword is a bit more known, but that you can use it in .NET 2.0 applications as well (as long as you use the .NET 3.5 compiler and set it to output 2.0 code) does not seem to be known very well.Edit: kokos, thanks for pointing out the ?? operator, that\'s indeed really useful. Since it\'s a bit hard to google for it (as ?? is just ignored), here is the MSDN documentation page for that operator: ?? Operator (C# Reference)I tend to find that most C# developers don\'t know about \'nullable\' types. Basically, primitives that can have a null value.Set a nullable double, num1, to null, then set a regular double, num2, to num1 or -100 if num1 was null.http://msdn.microsoft.com/en-us/library/1t3y8s4s(VS.80).aspxone more thing about Nullable type:it is return String.Empty. Check this link for more detailsHere are some interesting hidden C# features, in the form of undocumented C# keywords:These are undocumented C# keywords (even Visual Studio recognizes them!) that were added to for a more efficient boxing/unboxing prior to generics. They work in coordination with the System.TypedReference struct.There\'s also __arglist, which is used for variable length parameter lists.One thing folks don\'t know much about is System.WeakReference -- a very useful class that keeps track of an object but still allows the garbage collector to collect it.The most useful "hidden" feature would be the yield return keyword. It\'s not really hidden, but a lot of folks don\'t know about it. LINQ is built atop this; it allows for delay-executed queries by generating a state machine under the hood. Raymond Chen recently posted about the internal, gritty details.Unions (the C++ shared memory kind) in pure, safe C#Without resorting to unsafe mode and pointers, you can have class members share memory space in a class/struct.  Given the following class:You can modify the values of the byte fields by manipulating the Int32 field and vice-versa.  For example, this program:Outputs this:just add\nusing System.Runtime.InteropServices;Using @ for variable names that are keywords.If you want to exit your program without calling any finally blocks or finalizers use FailFast:Returning anonymous types from a method and accessing members without reflection.Here\'s a useful one for regular expressions and file paths:The @ tells the compiler to ignore any escape characters in a string.Mixins. Basically, if you want to add a feature to several classes, but cannot use one base class for all of them, get each class to implement an interface (with no members). Then, write an extension method for the interface, i.e.Of course, some clarity is sacrificed. But it works!Not sure why anyone would ever want to use Nullable<bool> though. :-)True, False, FileNotFound?This one is not "hidden" so much as it is misnamed.A lot of attention is paid to the algorithms "map", "reduce", and "filter". What most people don\'t realize is that .NET 3.5 added all three of these algorithms, but it gave them very SQL-ish names, based on the fact that they\'re part of LINQ."map" => Select Transforms data\n  from one form into another"reduce" => Aggregate Aggregates\n  values into a single result"filter" => Where Filters data\n  based on a criteriaThe ability to use LINQ to do inline work on collections that used to take iteration and conditionals can be incredibly valuable. It\'s worth learning how all the LINQ extension methods can help make your code much more compact and maintainable.for system independent newlines.If you\'re trying to use curly brackets inside a String.Format expression...@Ed, I\'m a bit reticent about posting this as it\'s little more than nitpicking. However, I would point out that in your code sample:If you\'re going to use \'is\', why follow it up with a safe cast using \'as\'? If you\'ve ascertained that obj is indeed MyClass, a bog-standard cast:...is never going to fail.Similarly, you could just say:I don\'t know enough about .NET\'s innards to be sure, but my instincts tell me that this would cut a maximum of two type casts operations down to a maximum of one. It\'s hardly likely to break the processing bank either way; personally, I think the latter form looks cleaner too.Maybe not an advanced technique, but one I see all the time that drives me crazy:can be condensed to: