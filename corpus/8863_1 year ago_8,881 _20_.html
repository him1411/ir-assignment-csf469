I\'m reading this but I\'m confused by what is written in the parseInt with a radix argument chapterWhy is it that parseInt(8, 3) \xe2\x86\x92 NaN and parseInt(16, 3) \xe2\x86\x92 1?AFAIK 8 and 16 are not base-3 numbers, so parseInt(16, 3) should return NaN tooThis is something people trip over all the time, even when they know about it. :-) You\'re seeing this for the same reason parseInt("1abc") returns 1: parseInt stops at the first invalid character and returns whatever it has at that point. If there are no valid characters to parse, it returns NaN.parseInt(8, 3) means "parse "8" in base 3" (note that it converts the number 8 to a string; details in the spec). But in base 3, the single-digit numbers are just 0, 1, and 2. It\'s like asking it to parse "9" in octal. Since there were no valid characters, you got NaN.parseInt(16, 3) is asking it to parse "16" in base 3. Since it can parse the 1, it does, and then it stops at the 6 because it can\'t parse it. So it returns 1.Since this question is getting a lot of attention and might rank highly in search results, here\'s a rundown of options for converting strings to numbers in JavaScript, with their various idiosyncracies and applications (lifted from another answer of mine here on SO):parseInt(str[, radix]) - Converts as much of the beginning of the string as it can into a whole (integer) number, ignoring extra characters at the end. So parseInt("10x") is 10; the x is ignored. Supports an optional radix (number base) argument, so parseInt("15", 16) is 21 (15 in hex). If there\'s no radix, assumes decimal unless the string starts with 0x (or 0X), in which case it skips those and assumes hex. (Some browsers used to treat strings starting with 0 as octal; that behavior was never specified, and was specifically disallowed in the ES5 specification.) Returns NaN if no parseable digits are found.parseFloat(str) - Like parseInt, but does floating-point numbers and only supports decimal. Again extra characters on the string are ignored, so parseFloat("10.5x") is 10.5 (the x is ignored). As only decimal is supported, parseFloat("0x15") is 0 (because parsing ends at the x). Returns NaN if no parseable digits are found.Unary +, e.g. +str - (E.g., implicit conversion) Converts the entire string to a number using floating point and JavaScript\'s standard number notation (just digits and a decimal point = decimal; 0x prefix = hex; 0o prefix = octal [ES2015+]; some implementations extend it to treat a leading 0 as octal, but not in strict mode). +"10x" is NaN because the x is not ignored. +"10" is 10, +"10.5" is 10.5, +"0x15" is 21, +"0o10" is 8 [ES2015+]. Has a gotcha: +"" is 0, not NaN as you might expect.Number(str) - Exactly like implicit conversion (e.g., like the unary + above), but slower on some implementations. (Not that it\'s likely to matter.)For the same reason thatIn the doc, parseInt takes a string. AndIf string is not a string, then it is converted to a stringSo 16, 8, or \'1foobar\' is first converted to string.ThenIf parseInt encounters a character that is not a numeral in the specified radix, it ignores it and all succeeding charactersMeaning it converts up to where it can. The 6, 8, and foobar are ignored, and only what is before is converted. If there is nothing, NaN is returned.