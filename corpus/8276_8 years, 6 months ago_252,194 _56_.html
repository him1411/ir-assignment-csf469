How do I generate random floats in C++?I thought I could take the integer rand and divide it by something, would that be adequate enough?rand() can be used to generate pseudo-random numbers in C++.  In combination with RAND_MAX and a little math, you can generate random numbers in any arbitrary interval you choose.  This is sufficient for learning purposes and toy programs.  If you need truly random numbers with normal distribution, you\'ll need to employ a more advanced method.This will generate a number from 0.0 to 1.0, inclusive.This will generate a number from 0.0 to some arbitrary float, X:This will generate a number from some arbitrary LO to some arbitrary HI:Note that the rand() function will often not be sufficient if you need truly random numbers.Before calling rand(), you must first "seed" the random number generator by calling srand().  This should be done once during your program\'s run -- not once every time you call rand().  This is often done like this:In order to call rand or srand you must #include <cstdlib>.In order to call time, you must #include <ctime>.C++11 gives you a lot of new options with random. The canonical paper on this topic would be N3551, Random Number Generation in C++11To see why using rand() can be problematic see the rand() Considered Harmful presentation material by Stephan T. Lavavej given during the GoingNative 2013 event. The slides are in the comments but here is a direct link.I also cover boost as well as using rand since legacy code may still require its support.The example below is distilled from the cppreference site and uses the std::mersenne_twister_engine engine and the std::uniform_real_distribution which generates numbers in the [0,10) interval, with other engines and distributions commented out (see it live):output will be similar to the following:The output will vary depending on which distribution you choose, so if we decided to go with std::normal_distribution with a value of 2 for both mean and stddev e.g. dist(2, 2) instead the output would be similar to this (see it live):The following is a modified version of some of the code presented in N3551 (see it live) :Results will look similar to:5H 5S AS 9S 4D 6H TH 6D KH 2S QS 9H 8H 3D KC TD 7H 2D KS 3C TC 7D 4C QH QC QD JD AH JC AC KD 9D 5C 2H 4H 9C 8C JH 5D 4S 7C AD 3S 8S TS 2C 8D 3H 6C JS 7S 6SBoostOf course Boost.Random is always an option as well, here I am using boost::random::uniform_real_distribution:rand()If you must use rand() then we can go to the C FAQ for a guides on How can I generate floating-point random numbers? , which basically gives an example similar to this for generating an on the interval [0,1):and to generate a random number in the range from [M,N):Take a look at Boost.Random. You could do something like this:Play around, you might do better passing the same mt19937 object around instead of constructing a new one every time, but hopefully you get the idea.Call the code with two float values, the code works in any range.If you are using C++ and not C, then remember that in technical report 1 (TR1) and in the C++0x draft they have added facilities for a random number generator in the  header file, I believe it is identical to the Boost.Random library and definitely more flexible and "modern" than the C library function, rand.This syntax offers the ability to choose a generator (like the mersenne twister mt19937) and then choose a distribution (normal, bernoulli, binomial etc.).Syntax is as follows (shameless borrowed from this site):In modern c++ you may use the <random> header that came with c++11.\nTo get random float\'s you can use std::uniform_real_distribution<>.You can use a function to generate the numbers and if you don\'t want the numbers to be the same all the time, set the engine and distribution to be  static.\nExample:It\'s ideal to place the float\'s in a container such as std::vector:Example output:On some systems (Windows with VC springs to mind, currently), RAND_MAX is ridiculously small, i.\xc2\xa0e. only 15 bit. When dividing by RAND_MAX you are only generating a mantissa of 15 bit instead of the 23 possible bits. This may or may not be a problem for you, but you\'re missing out some values in that case.Oh, just noticed that there was already a comment for that problem. Anyway, here\'s some code that might solve this for you:Untested, but might work :-)drand48(3) is the POSIX standard way. GLibC also provides a reentrant version, drand48_r(3).The function was declared obsolete in SVID 3 but no adequate alternative was provided so IEEE Std 1003.1-2013 still includes it and has no notes that it\'s going anywhere anytime soon.In Windows, the standard way is CryptGenRandom().I wasn\'t satisfied by any of the answers so far so I wrote a new random float function.  It makes bitwise assumptions about the float data type.  It still needs a rand() function with at least 15 random bits.If you know that your floating point format is IEEE 754 (almost all modern CPUs including Intel and ARM) then you can build a random floating point number from a random integer using bit-wise methods. This should only be considered if you do not have access to C++11\'s random or Boost.Random which are both much better.This will give a better distribution than one using division.In my opinion the above answer do give some \'random\' float, but none of them is truly a random float (i.e. they miss a part of the float representation). Before I will rush into my implementation lets first have a look at the ANSI/IEEE standard format for floats:|sign (1-bit)|  e (8-bits)  |  f (23-bit)  |the number represented by this word is\n(-1 * sign) * 2^e * 1.fnote the the \'e\' number is a biased (with a bias of 127) number thus ranging from -127 to 126. The most simple (and actually most random) function is to just write the data of a random int into a float, thusnote that if you do float f = (float)rand(); it will convert the integer into a float (thus 10 will become 10.0).\nSo now if you want to limit the maximum value you can do something like (not sure if this works)but if you look at the structure of the float you can see that the maximum value of a float is (approx) 2^127 which is way larger as the maximum value of an int (2^32) thus ruling out a significant part of the numbers that can be represented by a float.\nThis is my final implementation:using this function randf(0, 8, 0) will return a random number between 0.0 and 255.0For C++, it can generate real float numbers within the range specified by dist variablerand() return a int between 0 and RAND_MAX.   To get a random number between 0.0 and 1.0, first cast the int return by rand() to a float, then divide by RAND_MAX.Completely random valid float number is generated in the following way:\nRandom sign, random exponent and random mantissa. Here is an example of generating random numbers from 0..MAXFLOAT with uniform distribution:Important Note: RAND_MAX is by default equal to 2^16 (on 32bits systems) so rand() can generate at most 15 random bits. Since floating point has total of 32 bits we must activate the rand() at least 3 times to generate random 32 bits. I used 8 bits of rand() to generate Exponent and another 2 calls to rand() to generate 23 bits of mantissa.Common mistake to avoid: If you use (float)rand()/MAX_RAND to obtain a floating point in range [0..1], You will still get random numbers in uniform distribution but of low precision. For example your random generator can generate 0.00001 and 0.00002 but cannot generate 0.000017. Such random is 256 times less precise than the actual floating point representation.Optimization: My function is not optimized for speed. You can improve it by replacing \'%\' division with bitwise logical operations. For example Instead of %256 use &0xFF