As Joel points out in Stack Overflow podcast #34, in C Programming Language (aka: K & R), there is mention of this property of arrays in C: a[5] == 5[a]Joel says that it\'s because of pointer arithmetic but I still don\'t understand. Why does a[5] == 5[a]?The C standard defines the [] operator as follows:a[b] == *(a + b)Therefore a[5] will evaluate to:and 5[a] will evaluate to:a is a pointer to the first element of the array. a[5] is the value that\'s 5 elements further from a, which is the same as *(a + 5), and from elementary school math we know those are equal (addition is commutative).Because array access is defined in terms of pointers.  a[i] is defined to mean *(a + i), which is commutative.And, of courseThe main reason for this was that back in the 70\'s when C was designed, computers didn\'t have much memory (64KB was a lot), so the C compiler didn\'t do much syntax checking.  Hence "X[Y]" was rather blindly translated into "*(X+Y)"  This also explains the "+=" and "++" syntaxes.  Everything in the form "A = B + C" had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn\'t bright enough to recognize it, so the developer had to (A += C).   Similarly, if C was 1, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn\'t recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)I think something is being missed by the other answers.Yes, p[i] is by definition equivalent to *(p+i), which (because addition is commutative) is equivalent to *(i+p), which (again, by the definition of the [] operator) is equivalent to i[p].(And in array[i], the array name is implicitly converted to a pointer to the array\'s first element.)But the commutativity of addition is not all that obvious in this case.When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: x + y == y + x.But in this case we\'re talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)The C standard\'s description of the + operator (N1570 6.5.6) says:For addition, either both operands shall have arithmetic type, or one\n  operand shall be a pointer to a complete object type and the other\n  shall have integer type.It could just as easily have said:For addition, either both operands shall have arithmetic type, or the left\n  operand shall be a pointer to a complete object type and the right operand\n  shall have integer type.in which case both i + p and i[p] would be illegal.In C++ terms, we really have two sets of overloaded + operators, which can be loosely described as:andof which only the first is really necessary.So why is it this way?C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 Users\' Reference to B), which got it from BCPL (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C\'s ancestor languages.Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the unsigned keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn\'t have occurred to the designers of those languages. If a user wanted to add two "things", whether those "things" are integers, pointers, or something else, it wasn\'t up to the language to prevent it.And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.So now we have arr[3] and 3[arr] meaning exactly the same thing, though the latter form should never appear outside the IOCCC.One thing no-one seems to have mentioned about Dinah\'s problem with sizeof:You can only add an integer to a pointer, you can\'t add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.To answer the question literally. It is not always true that x == xprintsNice question/answers.Just want to point out that C pointers and arrays are not the same, although in this case the difference is not essential. Consider the following declarations:In a.out, the symbol a is at an address that\'s the beginning of the array, and symbol p is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array. I just find out this ugly syntax could be "useful", or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable ! Of course, I\'m quite sure that there is no use case for that in real code, but I found it interesting anyway :)For pointers in C, we haveand alsoHence it is true that a[5] == 5[a].Not an answer, but just some food for thought.\nIf class is having overloaded index/subscript operator, the expression 0[x] will not work:Since we dont have access to int class, this cannot be done:It has very good explanation in A TUTORIAL ON POINTERS AND ARRAYS IN C\nby Ted Jensen.Ted Jensen explained it as:In fact, this is true, i.e wherever one writes a[i] it can be\n  replaced with *(a + i)  without any problems. In fact, the compiler\n  will create the same code in either case. Thus we see that pointer\n  arithmetic is the same thing as array indexing. Either syntax produces\n  the same result.This is NOT saying that pointers and arrays\n  are the same thing, they are not. We are only saying that to identify\n  a given element of an array we have the choice of two syntaxes, one\n  using array indexing and the other using pointer arithmetic, which\n  yield identical results.Now, looking at this last\n  expression, part of it.. (a + i), is a simple addition using the +\n  operator and the rules of C state that such an expression is\n  commutative. That is (a + i) is identical to (i + a). Thus we could\n  write *(i + a) just as easily as *(a + i).\n  But *(i + a) could have come from i[a] ! From all of this comes the curious\n  truth that if:writingis the same as writingI know the question is answered, but I couldn\'t resist sharing this explanation.I remember Principles of Compiler design,\nLet\'s assume a is an int array and size of int is 2 bytes,\n& Base address for a is 1000.How a[5] will work ->So, Similarly when the c code is broken down into 3-address code, \n5[a] will become ->So basically both the statements are pointing to the same location in memory and hence, a[5] = 5[a].This explanation is also the reason why negative indexes in arrays work in C.i.e. if I access a[-5] it will give meIt will return me object at location 990.In C arrays, arr[3] and 3[arr] are the same, and their equivalent pointer notations are *(arr + 3) to *(3 + arr). But on the contrary [arr]3 or [3]arr is not correct and will result into syntax error, as (arr + 3)* and (3 + arr)* are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.in c compiler are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)In C pointer is a "variable"  array name is a "mnemonic" or "synonym"p++; is valid but a++ is invalida[2] is equals to 2[a] because the internal operation on both of this\n  is "Pointer Arithmetic" internally calculated as*(a+3) equals *(3+a)