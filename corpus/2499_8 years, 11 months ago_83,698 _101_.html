Assume you have a flat table that stores an ordered tree hierarchy:Here\'s a diagram, where we have [id] Name.  Root node 0 is fictional.What minimalistic approach would you use to output that to HTML (or text, for that matter) as a correctly ordered, correctly indented tree? Assume further you only have basic data structures (arrays and hashmaps), no fancy objects with parent/children references, no ORM, no framework, just your two hands. The table is represented as a result set, which can be accessed randomly. Pseudo code or plain English is okay, this is purely a conceptional question.Bonus question: Is there a fundamentally better way to store a tree structure like this in a RDBMS?EDITS AND ADDITIONSTo answer one commenter\'s (Mark Bessey\'s) question: A root node is not necessary, because it is never going to be displayed anyway. ParentId = 0 is the convention to express "these are top level". The Order column defines how nodes with the same parent are going to be sorted.The "result set" I spoke of can be pictured as an array of hashmaps (to stay in that terminology). For my example was meant to be already there. Some answers go the extra mile and construct it first, but thats okay.The tree can be arbitrarily deep. Each node can have N children. I did not exactly have a "millions of entries" tree in mind, though.Don\'t mistake my choice of node naming (\'Node 1.1.1\') for something to rely on. The nodes could equally well be called \'Frank\' or \'Bob\', no naming structure is implied, this was merely to make it readable.I have posted my own solution so you guys can pull it to pieces.There are several ways to store tree-structured data in a relational database.  What you show in your example uses two methods:  Another solution is called Nested Sets, and it can be stored in the same table too.  Read "Trees and Hierarchies in SQL for Smarties" by Joe Celko for a lot more information on these designs.I usually prefer a design called Closure Table (aka "Adjacency Relation") for storing tree-structured data.  It requires another table, but then querying trees is pretty easy.I cover Closure Table in my presentation Models for Hierarchical Data with SQL and PHP and in my book SQL Antipatterns: Avoiding the Pitfalls of Database Programming.Store all paths in the Closure Table, where there is a direct ancestry from one node to another.  Include a row for each node to reference itself.  For example, using the data set you showed in your question:Now you can get a tree starting at node 1 like this:The output (in MySQL client) looks like the following:In other words, nodes 3 and 5 are excluded, because they\'re part of a separate hierarchy, not descending from node 1.Re: comment from e-satis about immediate children (or immediate parent).  You can add a "path_length" column to the ClosureTable to make it easier to query specifically for an immediate child or parent (or any other distance).Then you can add a term in your search for querying the immediate children of a given node.  These are descendants whose path_length is 1.Re comment from @ashraf: "How about sorting the whole tree [by name]?"Here\'s an example query to return all nodes that are descendants of node 1, join them to the FlatTable that contains other node attributes such as name, and sort by the name.Re comment from @Nate:A user suggested an edit today. SO moderators approved the edit, but I am reversing it.The edit suggested that the ORDER BY in the last query above should be ORDER BY b.path_length, f.name, presumably to make sure the ordering matches the hierarchy. But this doesn\'t work, because it would order "Node 1.1.1" after "Node 1.2".If you want the ordering to match the hierarchy in a sensible way, that is possible, but not simply by ordering by the path length. For example, see my answer to MySQL Closure Table hierarchical database - How to pull information out in the correct order.If you use nested sets (sometimes referred to as Modified Pre-order Tree Traversal) you can extract the entire tree structure or any subtree within it in tree order with a single query, at the cost of inserts being more expensive, as you need to manage columns which describe an in-order path through thee tree structure.For django-mptt, I used a structure like this:Which describes a tree which looks like this (with id representing each item):Or, as a nested set diagram which makes it more obvious how the lft and rght values work:As you can see, to get the entire subtree for a given node, in tree order, you simply have to select all rows which have lft and rght values between its lft and rght values. It\'s also simple to retrieve the tree of ancestors for a given node.The level column is a bit of denormalisation for convenience more than anything and the tree_id column allows you to restart the lft and rght numbering for each top-level node, which reduces the number of columns affected by inserts, moves and deletions, as the lft and rght columns have to be adjusted accordingly when these operations take place in order to create or close gaps. I made some development notes at the time when I was trying to wrap my head around the queries required for each operation.In terms of actually working with this data to display a tree, I created a tree_item_iterator utility function which, for each node, should give you sufficient information to generate whatever kind of display you want.More info about MPTT:As of Oracle 9i, you can use CONNECT BY.As of SQL Server 2005, you can use a recursive common table expression (CTE).Both will output the following results.It\'s a quite old question, but as it\'s got many views I think it\'s worth to present an alternative, and in my opinion very elegant, solution.In order to read a tree structure you can use recursive Common Table Expressions (CTEs). It gives a possibility to fetch whole tree structure at once, have the information about the level of the node, its parent node and order within children of the parent node.Let me show you how this would work in PostgreSQL 9.1.Create a structureWrite a queryHere are the results:The tree nodes are ordered by a level of depth. In the final output we would present them in the subsequent lines.For each level, they are ordered by parent_id and node_order within the parent. This tells us how to present them in the output - link node to the parent in this order.Having such a structure it wouldn\'t be difficult to make a really nice presentation in HTML.Recursive CTEs are available in PostgreSQL, IBM DB2, MS SQL Server and Oracle.If you\'d like to read more on recursive SQL queries, you can either check the documentation of your favourite DBMS or read my two articles covering this topic:Bill\'s answer is pretty gosh-darned good, this answer adds some things to it which makes me wish SO supported threaded answers.Anyway I wanted to support the tree structure and the Order property.  I included a single property in each Node called leftSibling that does the same thing Order is meant to do in the original question (maintain left-to-right order).More detail and SQL code on my blog.Thanks Bill your answer was helpful in getting started!Well given the choice, I\'d be using objects. I\'d create an object for each record where each object has a children collection and store them all in an assoc array (/hashtable) where the Id is the key. And blitz through the collection once, adding the children to the relevant children fields. Simple.But because you\'re being no fun by restricting use of some good OOP, I\'d probably iterate based on:Edit: this is similar to a couple of other entries, but I think it\'s slightly cleaner. One thing I\'ll add: this is extremely SQL-intensive. It\'s nasty. If you have the choice, go the OOP route.This was written quickly, and is neither pretty nor efficient (plus it autoboxes alot, converting between int and Integer is annoying!), but it works.It probably breaks the rules since I\'m creating my own objects but hey I\'m doing this as a diversion from real work :)This also assumes that the resultSet/table is completely read into some sort of structure before you start building Nodes, which wouldn\'t be the best solution if you have hundreds of thousands of rows.Assuming that you know that the root elements are zero, here\'s the pseudocode to output to text:You can emulate any other data structure with a hashmap, so that\'s not a terrible limitation.  Scanning from the top to the bottom, you create a hashmap for each row of the database, with an entry for each column. Add each of these hashmaps to a "master" hashmap, keyed on the id. If any node has a "parent" that you haven\'t seen yet, create an placeholder entry for it in the master hashmap, and fill it in when you see the actual node.To print it out, do a simple depth-first pass through the data, keeping track of indent level along the way. You can make this easier by keeping a "children" entry for each row, and populating it as you scan the data.As for whether there\'s a "better" way to store a tree in a database, that depends on how you\'re going to use the data. I\'ve seen systems that had a known maximum depth that used a different table for each level in the hierarchy. That makes a lot of sense if the levels in the tree aren\'t quite equivalent after all (top level categories being different than the leaves).There are really good solutions which exploit the internal btree representation of sql indices. This is based on some great research done back around 1998.Here is an example table (in mysql). The only fields necessary for the tree representation are:Here is an example 24 node population, ordered by tw:Every tree result can be done non-recursively.\nFor instance, to get a list of ancestors of node at tw=\'22\'AncestorsSiblings and children are trivial - just use pa field ordering by tw.DescendantsFor example the set (branch) of nodes that are rooted at tw = 17.Additional NotesThis methodology is extremely useful for when there are a far greater number of reads than there are inserts or updates.  Because the insertion, movement, or updating of a node in the tree requires the tree to be adjusted, it is necessary to lock the table before commencing with the action.The insertion/deletion cost is high because the tw index and sz (branch size) values will need to be updated on all the nodes after the insertion point, and for all ancestors respectively.Branch moving involves moving the tw value of the branch out of range, so it is also necessary to disable foreign key constraints when moving a branch.  There are, essentially four queries required to move a branch:Adjust Tree QueriesThe opening/closing of gaps in the tree is an important sub-function used by create/update/delete methods, so I include it here.We need two parameters - a flag representing whether or not we are downsizing or upsizing, and the node\'s tw index. So, for example tw=18 (which has a branch size of 5). Let\'s assume that we are downsizing (removing tw) - this means that we are using \'-\' instead of \'+\' in the updates of the following example.We first use a (slightly altered) ancestor function to update the sz value.Then we need to adjust the tw for those whose tw is higher than the branch to be removed.Then we need to adjust the parent for those whose pa\'s tw is higher than the branch to be removed.If nested hash maps or arrays can be created, then I can simply go down the table from the beginning and add each item to the nested array. I must trace each line to the root node in order to know which level in the nested array to insert into. I can employ memoization so that I do not need to look up the same parent over and over again.Edit: I would read the entire table into an array first, so it will not query the DB repeatedly. Of course this won\'t be practical if your table is very large.After the structure is built, I must do a depth first traverse through it and print out the HTML.There\'s no better fundamental way to store this information using one table (I could be wrong though ;), and would love to see a better solution ). However, if you create a scheme to employ dynamically created db tables, then you opened up a whole new world at the sacrifice of simplicity, and the risk of SQL hell ;).If elements are in tree order, as shown in your example, you can use something like the following Python example:What this does is maintain a stack representing the current position in the tree. For each element in the table, it pops stack elements (closing the matching divs) until it finds the parent of the current item. Then it outputs the start of that node and pushes it to the stack.If you want to output the tree using indenting rather than nested elements, you can simply skip the print statements to print the divs, and print a number of spaces equal to some multiple of the size of the stack before each item. For example, in Python:You could also easily use this method to construct a set of nested lists or dictionaries.Edit: I see from your clarification that the names were not intended to be node paths. That suggests an alternate approach:This constructs a tree of arrays of tuples(!). idx[0] represents the root(s) of the tree. Each element in an array is a 2-tuple consisting of the node itself and a list of all its children. Once constructed, you can hold on to idx[0] and discard idx, unless you want to access nodes by their ID.To Extend Bill\'s SQL solution you can basically do the same using a flat array.  Further more if your strings all have the same lenght and your maximum number of children are known (say in a binary tree) you can do it using a single string (character array).  If you have arbitrary number of children this complicates things a bit...  I would have to check my old notes to see what can be done.Then, sacrificing a bit of memory, especially if your tree is sparse and/or unballanced, you can, with a bit of index math, access all the strings randomly by storing your tree, width first in the array like so (for a binary tree):yo know your string length, you know it\n\nI\'m at work now so cannot spend much time on it but with interest I can fetch a bit of code to do this.  We use to do it to search in binary trees made of DNA codons, a process built the tree, then we flattened it to search text patterns and when found, though index math (revers from above) we get the node back...  very fast and efficient, tough our tree rarely had empty nodes, but we could searh gigabytes of data in a jiffy.Think about using nosql tools like neo4j for hierarchial structures. \ne.g a networked application like linkedin uses couchbase (another nosql solution)But use nosql only for data-mart level queries and not to store / maintain transactions