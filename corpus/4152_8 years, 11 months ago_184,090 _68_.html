I see in C++ there are multiple ways to allocate and free data and I understand that when you call malloc you should call free and when you use the new operator you should pair with delete and it is a mistake to mix the two (e.g. Calling free() on something that was created with the new operator), but I\'m not clear on when I should use malloc/ free and when I should use new/ delete in my real world programs.If you\'re a C++ expert, please let me know any rules of thumb or conventions you follow in this regard.Unless you are forced to use C, you should never use malloc.  Always use new. \nIf you need a big chunk of data just do something like:Be careful though this is not correct:Instead you should do this when deleting an array of data:The new keyword is the C++ way of doing it, and it will ensure that your type will have their constructor called.  The new keyword is also more type safe whereas malloc is not typesafe at all. The only way I could think that would be beneficial to use malloc would be if you needed to change the size of your buffer of data.  The new keyword does not have an analogous way like realloc.  The realloc function might be able to extend the size of a chunk of memory for you more efficiently. It is worth mentioning that you cannot mix new/free and malloc/delete.Note, some answers in this question are invalid. The short answer is: don\'t use malloc for C++ without a really good reason for doing so. malloc has a number of deficiencies when used with C++, which new was defined to overcome.malloc is not typesafe in any meaningful way. In C++ you are required to cast the return from void*. This potentially introduces a lot of problems:It\'s worse than that though. If the type in question is POD (plain old data) then you can semi-sensibly use malloc to allocate memory for it, as f2 does in the first example.It\'s not so obvious though if a type is POD. The fact that it\'s possible for a given type to change from POD to non-POD with no resulting compiler error and potentially very hard to debug problems is a significant factor. For example if someone (possibly another programmer, during maintenance, much later on were to make a change that caused foo to no longer be POD then no obvious error would appear at compile time as you\'d hope, e.g.:would make the malloc of f2 also become bad, without any obvious diagnostics. The   example here is trivial, but it\'s possible to accidentally introduce non-PODness much further away (e.g. in a base class, by adding a non-POD member). If you have C++11/boost you can use is_pod to check that this assumption is correct and produce an error if it\'s not:Although boost is unable to determine if a type is POD without C++11 or some other compiler extensions.malloc returns NULL if allocation fails. new will throw std::bad_alloc. The behaviour of later using a NULL pointer is undefined. An exception has clean semantics when it is thrown and it is thrown from the source of the error. Wrapping malloc with an appropriate test at every call seems tedious and error prone. (You only have to forget once to undo all that good work). An exception can be allowed to propagate to a level where a caller is able to sensibly process it, where as NULL is much harder to pass back meaningfully. We could extend our safe_foo_malloc function to throw an exception or exit the program or call some handler:Fundamentally malloc is a C feature and new is a C++ feature. As a result malloc does not play nicely with constructors, it only looks at allocating a chunk of bytes. We could extend our safe_foo_malloc further to use placement new:Our safe_foo_malloc function isn\'t very generic - ideally we\'d want something that can handle any type, not just foo. We can achieve this with templates and variadic templates for non-default constructors:Now though in fixing all the issues we identified so far we\'ve practically reinvented the default new operator. If you\'re going to use malloc and placement new then you might as well just use new to begin with!From the C++ FQA Lite:[16.4] Why should I use new instead of\n  trustworthy old malloc()?FAQ: new/delete call the\n  constructor/destructor; new is type\n  safe, malloc is not; new can be\n  overridden by a class.FQA: The virtues of new mentioned by\n  the FAQ are not virtues, because\n  constructors, destructors, and\n  operator overloading are garbage (see\n  what happens when you have no garbage\n  collection?), and the type safety\n  issue is really tiny here (normally\n  you have to cast the void* returned by\n  malloc to the right pointer type to\n  assign it to a typed pointer variable,\n  which may be annoying, but far from\n  "unsafe").Oh, and using trustworthy old malloc\n  makes it possible to use the equally\n  trustworthy & old realloc. Too bad we\n  don\'t have a shiny new operator renew or something.Still, new is not bad enough to\n  justify a deviation from the common\n  style used throughout a language, even\n  when the language is C++. In\n  particular, classes with non-trivial\n  constructors will misbehave in fatal\n  ways if you simply malloc the objects.\n  So why not use new throughout the\n  code? People rarely overload operator\n  new, so it probably won\'t get in your\n  way too much. And if they do overload\n  new, you can always ask them to stop.Sorry, I just couldn\'t resist. :)Always use new in C++. If you need a block of untyped memory, you can use operator new directly:Use malloc and free only for allocating memory that is going to be managed by c-centric libraries and APIs. Use new and delete (and the [] variants) for everything that you control.new vs malloc()1) new is an operator, while malloc() is a function.2) new calls constructors, while malloc() does not.3) new returns exact data type, while malloc() returns void *.4) new never returns a NULL (will throw on failure) while malloc() returns NULL5) Reallocation of memory not handled by new while malloc() canThere is one big difference between malloc and new. malloc allocates memory. This is fine for C, because in C, a lump of memory is an object.In C++, if you\'re not dealing with POD types (which are similar to C types) you must call a constructor on a memory location to actually have an object there. Non-POD types are very common in C++, as many C++ features make an object automatically non-POD.new allocates memory and creates an object on that memory location. For non-POD types this means calling a constructor.If you do something like this:The pointer you obtain cannot be dereferenced because it does not point to an object. You\'d need to call a constructor on it before you can use it (and this is done using placement new).If, on the other hand, you do:You get a pointer that is always valid, because new created an object.Even for POD types, there\'s a significant difference between the two:This piece of code would print an unspecified value, because the POD objects created by malloc are not initialised.With new, you could specify a constructor to call, and thus get a well defined value.If you really want it, you can use use new to obtain uninitialised POD objects. See this other answer for more information on that.Another difference is the behaviour upon failure. When it fails to allocate memory, malloc returns a null pointer, while new throws an exception.The former requires you to test every pointer returned before using it, while the later will always produce valid pointers.For these reasons, in C++ code you should use new, and not malloc. But even then, you should not use new "in the open", because it acquires resources you need to release later on. When you use new you should pass its result immediately into a resource managing class:There are a few things which new does that malloc doesn\xe2\x80\x99t:So, if you use malloc, then you need to do above things explicitly, which is not always practical. Additionally, new can be overloaded but malloc can\xe2\x80\x99t be.if you are using c++ then try to use new/delete instead of malloc/calloc as they are operator its self compared to malloc/calloc for them you used to include another header for that.so don\'t mix two different languages in single coding.their work is similar in every manner both allocates the memory dynamically from heap segment in hash table. To answer your question, you should know the difference between malloc and new. The difference is simple:malloc allocates memory, while new allocates memory AND calls the constructor of the object you\'re allocating memory for.So, unless you\'re restricted to C, you should never use malloc, especially when dealing with C++ objects. That would be a recipe for breaking your program.Also the difference between free and delete is quite the same. The difference is that delete will call the destructor of your object in addition to freeing memory.If you have C code you want to port over to C++, you might leave any malloc() calls in it.  For any new C++ code, I\'d recommend using new instead.If you work with data that doesn\'t need construction/destruction and requires reallocations (e.g., a large array of ints), then I believe malloc/free is a good choice as it gives you realloc, which is way faster than new-memcpy-delete (it is on my Linux box, but I guess this may be platform dependent). If you work with C++ objects that are not POD and require construction/destruction, then you must use the new and delete operators.Anyway, I don\'t see why you shouldn\'t use both (provided that you free your malloced memory and delete objects allocated with new) if can take advantage of the speed boost (sometimes a significant one, if you\'re reallocing large arrays of POD) that realloc can give you.Unless you need it though, you should stick to new/delete in C++.From a lower perspective, new will initialize all the memory before giving the memory whereas malloc will keep the original content of the memory.new will initialise the default values of the struct and correctly links the references in it to itself.E.g.So new struct test_s will return an initialised structure with a working reference, while the malloc\'ed version has no default values and the intern references aren\'t initialised.The new and delete operators can operate on classes and structures, whereas malloc and free only work with blocks of memory that need to be cast.Using new/delete will help to improve your code as you will not need to cast allocated memory to the required data structure.Rare case to consider using malloc/free instead of new/delete is when your allocating and then reallocating (simple pod types, not objects) using realloc as there is no similar function to realloc in c++ (although this can be done using a more c++ approach)In the following scenario, we can\'t use new since it calls constructor. malloc() is used to dynamically assign memory in C\nwhile the same work is done by new() in c++.\nSo you cannot mix coding conventions of 2 languages.\nIt would be good if you asked for difference between calloc and malloc()