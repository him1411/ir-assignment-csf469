Please treat this question as strictly educational. I\'m still interested in hearing new answers and ideas to implement thisHow would I implement bi-directional data-binding with JavaScript?By data binding to the DOM I mean  for example, having a JavaScript object a with a property b. Then having an <input> DOM element (for example), when the DOM element changes, a changes and vice versa (that is, I mean bidirectional data binding). Here is a diagram from AngularJS on what this looks like:So basically I have JavaScript similar to:Then an input (or other form) element like:I\'d like the input\'s value to be a.b\'s value (for example), and when the input text changes, I\'d like a.b to change too. When a.b changes in JavaScript, the input changes.What are some basic techniques to accomplish this in plain JavaScript?In specific, I\'d like a good answer to refer to:I\'m a big fan of Mustache so I tried using it for templating. However, I ran into issues when trying to perform the data binding itself since Mustache processes HTML as a string so after I get its result I have no reference to where the objects in my viewmodel are. The only workaround I could think for this was modifying the HTML string (or created DOM tree) itself with attributes. I don\'t mind using a different templating engine.Basically, I got a strong feeling that I was complicating the issue at hand and there is a simple solution.Note: Please do not provide answers that use external libraries, especially ones that are thousands of lines of code. I\'ve used (and like!) AngularJS and KnockoutJS. I really don\'t want answers in the form \'use framework x\'. Optimally, I\'d like a future reader who doesn\'t know how to use many frameworks to grasp how to implement bi-directional data-binding herself. I do not expect a complete answer, but one that gets the idea across.I suppose there are other techniques, but ultimately I\'d have an object that holds reference to a related DOM element, and provides an interface that coordinates updates to its own data and its related element.The .addEventListener() provides a very nice interface for this. You can give it an object that implements the eventListener interface, and it\'ll invoke its handlers with that object as the this value.This gives you automatic access to both the element and its related data.Prototypal inheritance is a nice way to implement this, though not required of course. First you\'d create a constructor that receives your element and some initial data.So here the constructor stores the element and data on properties of the new object. It also binds a change event to the given element. The interesting thing is that it passes the new object instead of a function as the second argument. But this alone won\'t work. To make this work, your object needs to implement the eventListener interface. All that\'s needed to accomplish this is to give the object a handleEvent() method. That\'s where the inheritance comes in.There are many different ways in which this could be structured, but for your example of coordinating updates, I decided to make the change() method only accept a value, and have the handleEvent pass that value instead of the event object. This way the change() can be invoked without an event as well.So now, when the change event happens, it\'ll update both the element and the .data property. And the same will happen when you call .change() in your JavaScript program.Now you\'d just create the new object, and let it perform updates. Updates in JS code will appear on the input, and change events on the input will be visible to the JS code.DEMO: http://jsfiddle.net/RkTMD/So, I decided to throw my own solution in the pot. Here is a working fiddle. Note this only runs on very modern browsers.This implementation is very modern - it requires a (very) modern browser and users two new technologies:Here is the dataBind function, note it\'s just 20 lines of code and could be shorter:Here is some usage:HTML: JavaScript: Here is a working fiddle. Note that this solution is pretty generic. Object.observe and mutation observer shimming is available.I\'d like to add to my preposter. I suggest a slightly different approach that will allow you to simply assign a new value to your object without using a method. It must be noted though that this is not supported by especially older browsers and IE9 still requires use of a different interface.Most notably is that my approach does not make use of events.My proposal makes use of the relatively young feature of getters and setters, particularly setters only. Generally speaking, mutators allow us to "customize" the behavior of how certain properties are assigned a value and retrieved.One implementation I\'ll be using here is the Object.defineProperty method. It works in FireFox, GoogleChrome and - I think - IE9. Haven\'t tested other browsers, but since this is theory only...Anyways, it accepts three parameters. The first parameter being the object that you wish to define a new property for, the second a string resembling the the name of the new property and the last a "descriptor object" providing information on the behavior of the new property.Two particularly interesting descriptors are get and set. An example would look something like the following. Note that using these two prohibits the use of the other 4 descriptors.Now making use of this becomes slightly different:I want to emphasize that this only works for modern browsers.Working fiddle: http://jsfiddle.net/Derija93/RkTMD/1/I think my answer will be more technical, but not different as the others present the same thing using different techniques.\nSo, first things first, the solution to this problem is the use of a design pattern known as "observer", it let\'s you decouple your data from your presentation, making the change in one thing be broadcasted to their listeners, but in this case it\'s made two-way.To bind the data from the DOM to the js object you may add markup in the form of data attributes (or classes if you need compatibility), like this:\nThis way it can be accessed via js using querySelectorAll (or the old friend getElementsByClassName for compatibility).Now you can bind the event listening to the changes in to ways: one listener per object or one big listener to the container/document. Binding to the document/container will trigger the event for every change made in it or it\'s child, it willhave a smaller memory footprint but will spawn event calls.\nThe code will look something like this:\nYou will need two things: one meta-object that will hold the references of witch DOM element is binded to each js object/attribute and a way to listen to changes in objects. It is basically the same way: you have to have a way to listen to changes in the object and then bind it to the DOM node, as your object "can\'t have" metadata you will need another object that holds metadata in a way that the property name maps to the metadata object\'s properties.\nThe code will be something like this:\nI hope that i was of help.There is a very simple barebones implementation of 2-way data-binding in this link "Easy Two-Way Data Binding in JavaScript"The previous link along with ideas from knockoutjs, backbone.js and agility.js, led to this light-weight and fast MVVM framework, ModelView.js based on jQuery which plays nicely with jQuery and  of which i am the humble (or maybe not so humble) author.Reproducing sample code below (from blog post link):Sample code for DataBinderFor what concerns the JavaScript object, a minimal implementation of a\n  User model for the sake of this experiment could be the following:Now, whenever we want to bind a model\xe2\x80\x99s property to a piece of UI we\n  just have to set an appropriate data attribute on the corresponding\n  HTML element:Yesterday I started to wrote my own way to bind data.It\'s very funny to play with it.I think it\'s beautiful and very useful. At least on my tests using firefox and chrome, Edge must works too. Not sure about others, but if support Proxy, I think it will work.https://jsfiddle.net/2ozoovne/1/Here is the code:Then, to set, just:For now I just add the HTMLInputElement value bind.Let\'me know if you know how to improve it.Bind any html input define two functions:use the functions:Changing an element\'s value can trigger a DOM event. Listeners that respond to events can be used to implement data binding in JavaScript.For example:Here is code and a demo that shows how DOM elements can be bound with each other or with a JavaScript object.I have gone through some basic javascript example using onkeypress and onchange event handlers for making binding view to our js and js to viewHere example plunker http://plnkr.co/edit/7hSOIFRTvqLAvdZT4Bcc?p=preview