Which annotation, @Resource (jsr250) or @Autowired (Spring specific) should I be using when using DI?I have successfully used both in the past, @Resource(name="blah") and @Autowired @Qualifier("blah")My instinct is to stick with the @Resource tag since it\'s been ratified by the jsr people.  Anyone have strong thoughts on this?In spring pre-3.0 it doesn\'t matter which one.In spring 3.0 there\'s support for the standard (JSR-330) annotation @javax.inject.Inject - use it, with a combination of @Qualifier. Note that spring now also supports the @javax.inject.Qualifier meta-annotation:So you can haveorAnd then:This makes less use of String-names, which can be misspelled and are harder to maintain.As for the original question: both, without specifying any attributes of the annotation, perform injection by type. The difference is:Both @Autowired (or @Inject) and @Resource work equally well. But there is a conceptual difference or a difference in the meaningSo, basically these are two quite distinct concepts. Unfortunately the Spring-Implementation of @Resource has a built-in fallback, which kicks in when resolution by-name fails. In this case, it falls back to the @Autowired-kind resolution by-type. While this fallback is convenient, IMHO it causes a lot of confusion, because people are unaware of the conceptual difference and tend to use @Resource for type-based autowiring.The primary difference is, @Autowired is a spring annotation. Whereas @Resource is specified by the JSR-250, as you pointed out yourself. So the latter is part of Java whereas the former is Spring specific.Hence, you are right in suggesting that, in a sense. I found folks use @Autowired with @Qualifier because it is more powerful. Moving from some framework to some other is considered very unlikely, if not myth, especially in the case of Spring.I would like to emphasize one comment from @Jules on this answer to this question. The comment brings a useful link: Spring Injection with @Resource, @Autowired and @Inject. I encourage you to read it entirely, however here is a quick summary of its usefulness:@Autowired and @Inject@ResourceExplicitly name your component [@Component("beanName")]Use @Resource with the name attribute [@Resource(name="beanName")]Avoid @Qualifier annotations unless you want to create a list of similar beans. For example you may want to mark a set of rules with a specific @Qualifier annotation. This approach makes it simple to inject a group of rule classes into a list that can be used for processing data.Scan specific packages for components [context:component-scan base-package="com.sourceallies.person"]. While this will result in more component-scan configurations it reduces the chance that you\xe2\x80\x99ll add unnecessary components to your Spring context.Reference: Spring Injection with @Resource, @Autowired and @InjectThis is what I got from the Spring 3.0.x Reference Manual :-Tip If you intend to express annotation-driven injection by name, do\n  not primarily use @Autowired, even if is technically capable of\n  referring to a bean name through @Qualifier values. Instead, use the\n  JSR-250 @Resource annotation, which is semantically defined to\n  identify a specific target component by its unique name, with the\n  declared type being irrelevant for the matching process.As a specific consequence of this semantic difference, beans that are\n  themselves defined as a collection or map type cannot be injected\n  through @Autowired, because type matching is not properly applicable\n  to them. Use @Resource for such beans, referring to the specific\n  collection or map bean by unique name.@Autowired applies to fields, constructors, and multi-argument\n  methods, allowing for narrowing through qualifier annotations at the\n  parameter level. By contrast, @Resource is supported only for fields\n  and bean property setter methods with a single argument. As a\n  consequence, stick with qualifiers if your injection target is a\n  constructor or a multi-argument method.Both of them are equally good. The advantage of using Resource is in future if you want to another DI framework other than spring, your code changes will be much simpler. Using Autowired your code is tightly coupled with springs DI.@Autowired + @Qualifier will work only with spring DI, if you want to use some other DI in future @Resource is good option.other difference which I found very significant is @Qualifier does not support dynamic bean wiring, as @Qualifier does not support placeholder, while @Resource does it very well.For example:\nif you have an interface with multiple implementations like thiswith @Autowired & @Qualifier you need to set specific child implementation \nlike which does not provide placeholder while with @Resource you can put placeholder and use property file to inject specific child implementation likewhere service.name is set in property file as  Hope that helps someone :)@Resource is often used by high-level objects, defined via JNDI. @Autowired or @Inject will be used by more common beans.As far as I know, it\'s not a specification, nor even a convention. It\'s more the logical way standard code will use these annotations.As a note here:\nSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext and SpringBeanAutowiringSupport.processInjectionBasedOnServletContext DOES NOT work with @Resource  annotation. So, there are difference.With @Resource you can do bean self-injection, it might be needed in order to run all extra logic added by bean post processors like transactional or security related stuff.With Spring 4.3+ @Autowired is also capable of doing this.