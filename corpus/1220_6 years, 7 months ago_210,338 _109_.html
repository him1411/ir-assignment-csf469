I\'m looking to make my code more readable as well as use tooling like IDE code inspection and/or static code analysis (FindBugs and Sonar) to avoid NullPointerExceptions.  Many of the tools seem incompatible with each others\' @NotNull/@NonNull/@Nonnull annotation and listing all of them in my code would be terrible to read.  Any suggestions of which one is the \'best\'?  Here is the list of equivalent annotations I\'ve found:javax.validation.constraints.NotNull\nCreated for runtime validation, not static analysis.\ndocumentationedu.umd.cs.findbugs.annotations.NonNull\nUsed by Findbugs static analysis and therefore Sonar (now Sonarqube)\ndocumentationjavax.annotation.Nonnull\nThis might work with Findbugs too, but JSR-305 is inactive. (See also: What is the status of JSR 305?)\nsourceorg.jetbrains.annotations.NotNull\nUsed by IntelliJ IDEA IDE for static analysis.\ndocumentationlombok.NonNull\nUsed to control code generation in Project Lombok.\nPlaceholder annotation since there is no standard.\nsource, \ndocumentationandroid.support.annotation.NonNull\nMarker annotation available in Android, provided by support-annotations package\ndocumentationorg.eclipse.jdt.annotation.NonNull\nUsed by Eclipse for static code analysis\ndocumentationI very much like the Checker Framework, which is an implementation of type annotations (JSR-308) which is used to implement defect checkers like a nullness checker.  I haven\'t really tried any others to offer any comparison, but I\'ve been happy with this implementation.I\'m not affiliated with the group that offers the software, but I am a fan.Four things I like about this system:It has a defect checkers for nullness (@Nullable), but also has ones for immutability and interning (and others).  I use the first one (nullness) and I\'m trying to get into using the second one (immutability/IGJ).  I\'m trying out the third one, but I\'m not certain about using it long term yet.  I\'m not convinced of the general usefulness of the other checkers yet, but its nice to know that the framework itself is a system for implementing a variety of additional annotations and checkers.The default setting for nullness checking works well: Non-null except locals (NNEL).  Basically this means that by default the checker treats everyhing (instance variables, method parameters, generic types, etc) except local variables as if they have a @NonNull type by default.  Per the documentation:The NNEL default leads to the smallest number of explicit annotations in your code.You can set a different default for a class or for a method if NNEL doesn\'t work for you.This framework allows you to use with without creating a dependency on the framework by enclosing your annotations in a comment: e.g. /*@Nullable*/.  This is nice because you can annotate and check a library or shared code, but still be able to use that library/shared coded in another project that doesn\'t use the framework.  This is a nice feature.  I\'ve grown accustom to using it, even though I tend to enable the Checker Framework on all my projects now. The framework has a way to annotate APIs you use that aren\'t already annotated for nullness by using stub files.I use the IntelliJ one, because I\'m mostly concerned with IntelliJ flagging things that might produce a NPE. I agree that it\'s frustrating not having a standard annotation in the JDK. There\'s talk of adding it, it might make it into Java 7. In which case there will be one more to choose from!According to the Java 7 features list JSR-308 type annotations are deferred to Java 8.  JSR-305 annotations are not even mentioned.  There is a bit of info on the state of JSR-305 in an appendix of the latest JSR-308 draft.  This includes the observation that JSR-305 annotations seem to be abandoned.  The JSR-305 page also shows it as "inactive".In the mean time, the pragmatic answer is to use the annotation types that are supported by the most widely used tools ... and be prepared to change them if the situation changes.In fact, JSR-308 does not define any annotation types/classes, and it looks like they think it is out of scope.  (And they are right, given the existence of JSR-305).However, if JSR-308 really looks like making it into Java 8, it wouldn\'t surprise me if interest in JSR-305 revived.  AFAIK, the JSR-305 team hasn\'t formally abandoned their work.  They have just been quiet for 2+ years.It is interesting that Bill Pugh (the tech lead for JSR-305) is one of the guy behind FindBugs.For Android projects you should use android.support.annotation.NonNull and android.support.annotation.Nullable. These and other helpful Android-specific annotations are available in the Support Library.From http://tools.android.com/tech-docs/support-annotations:The support library itself has also been annotated with these\n  annotations, so as a user of the support library, Android Studio will\n  already check your code and flag potential problems based on these\n  annotations.Since Oracle decided not to standardize @NonNull (and @Nullable) for the moment, I\'m afraid there is no good answer. All we can do is to find a pragmatic solution and mine is as follows:From a purely stylistic standpoint I would like to avoid any reference to IDE, framework or any toolkit except Java itself.This rules out:Which leaves us with either javax.validation.constraints or javax.annotation.\nThe former comes with JEE. If this is better than javax.annotation, which  might come eventually with JSE or never at all, is a matter of debate.\nI personally prefer javax.annotation because I wouldn\'t like the JEE dependency.This leaves us withjavax.annotationwhich is also the shortest one.There is only one syntax which would even be better: java.annotation.Nullable. As other packages graduated\nfrom javax to java in the past, the javax.annotation would\nbe a step in the right direction.I was hoping that they all have basically the same trivial implementation,\nbut a detailed analysis showed that this is not true.First for the similarities:The @NonNull annotations all have the line except for The @Nullable annotations all have the lineexcept for (again) the org.jetbrains.annotations with their trivial implementation.For the differences:A striking one is thatall have runtime annotations  (@Retention(RUNTIME), whileare only compile time (@Retention(CLASS)).As described in this SO answer the impact of runtime annotations\nis smaller than one might think, but they have the benefit\nof enabling tools to do runtime checks in addition to the\ncompile time ones. Another important difference is where in the code the annotations can be used.\nThere are two different approaches. Some packages use JLS 9.6.4.1 style contexts. The following table gives an overview:org.eclipse.jdt.annotation, javax.annotation and org.checkerframework.checker.nullness.qual use the contexts defined in \nJLS 4.11, which is in my opinion the right way to do it.This leaves us with in this round.To help you to compare further details yourself I list the code of every annotation below.\nTo make comparison easier I removed comments, imports and the @Documented annotation.\n(they all had @Documented except for the classes from the Android package).\nI reordered the lines and @Target fields and normalized the qualifications.For completeness, here are the @Nullable implementations:The following two packages have no @Nullable, so I list them separately\nlombok has a pretty boring @NonNull.\nIn javax.validation.constraints the @NonNull is actually a @NotNull\nand it has a longish implementation.Form my experience javax.annotation is at least supported by Eclipse and the Checker Framework out of the box.My ideal annotation would be the java.annotation syntax with the Checker Framework implementation.If you don\'t intend to use the Checker Framework  the javax.annotation (JSR-305) is still your best bet for the time being.If you are willing to buy into the Checker Framework just use\ntheir org.checkerframework.checker.nullness.qual.JSR305 and FindBugs are authored by the same person. Both are poorly maintained but are as standard as it gets and are supported by all major IDEs. The good news is that they work well as-is.Here is how to apply @Nonnull to all classes, methods and fields by default.\nSee https://stackoverflow.com/a/13319541/14731 and https://stackoverflow.com/a/9256595/147312. Add the annotation to each package: package-info.javaUPDATE: As of December 12th, 2012 JSR 305 is listed as "Dormant". According to the documentation:A JSR that was voted as "dormant" by the Executive Committee, or one that has reached the end of its natural lifespan.It looks like JSR 308 is making it into JDK 8 and although the JSR does not define @NotNull, the accompanying Checkers Framework does. At the time of this writing, the Maven plugin is unusable due to this bug: https://github.com/typetools/checker-framework/issues/183If anyone is just looking for the IntelliJ classes: you can get them from the maven repository withJust pointing out that the Java Validation API (javax.validation.constraints.*) doesn\'t come with a @Nullable annotation, which is very valuable in a static analysis context. It makes sense for runtime bean validation as this is the default for any non-primitive field in Java (i.e. nothing to validate/enforce). For the purposes stated that should weigh towards the alternatives.Eclipse has also its own annotations.See at http://wiki.eclipse.org/JDT_Core/Null_Analysis for details.Unfortunately, JSR 308 will not add more values than this project local Not Null suggestion hereJava 8 will not come with a single default annotation or its own Checker framework.\nSimilar to Find-bugs or JSR 305, this JSR is poorly maintained by a small bunch of mostly academic teams. No commercial power behind it, thus JSR 308 launches EDR 3 (Early Draft Review at JCP) NOW, while Java 8 is supposed to ship in less than 6 months:-O\nSimilar to 310 btw. but unlike 308 Oracle has taken charge of that now away from its founders to minimize harm it\'ll do to the Java Platform.Every project, vendor and academic class like the ones behind the Checker Framework and JSR 308 will create its own proprietary checker annotation.Making source code incompatible for years to come, until a few popular compromises could be found and maybe added to Java 9 or 10, or via frameworks like Apache Commons or Google Guava;-)While waiting for this to be sorted out upstream (Java 8?), you could also just define your own project-local @NotNull and @Nullable annotations. This can be useful also in case you\'re working with Java SE, where javax.validation.constraints isn\'t available by default.This would admittedly largely be for decorative or future-proofing purposes, since the above obviously doesn\'t in and of itself add any support for the static analysis of these annotations.If you\'re developing for android, you\'re somewhat tied to Eclipse (edit: at time of writing, not anymore), which has its own annotations.  It\'s included in Eclipse 3.8+ (Juno), but disabled by default.You can enable it at Preferences > Java > Compiler > Errors/Warnings > Null analysis (collapsable section at the bottom).Check "Enable annotation-based null analysis"http://wiki.eclipse.org/JDT_Core/Null_Analysis#Usage has recommendations on settings.  However, if you have external projects in your workspace (like the facebook SDK), they may not satisfy those recommendations, and you probably don\'t want to fix them with each SDK update ;-)I use:This answer is Android specific. Android has support package called support-annotations. This provides dozens of Android specific annotations and also provides common ones like NonNull, Nullable etc.To add support-annotations package, add the following dependency in your build.gradle:and then use:There is another way to do this in Java 8.\nI am doing 2 things to accomplish what I needed:Example:So my question is, do we even need to annotate when using java 8? Edit: I found out later that some consider a bad practice to use Optional in arguments, there is a good discussion with pros and cons here Why should Java 8's Optional not be used in argumentsIf you are working on a big project, you may be better of creating your own @Nullable and/or @NotNull annotations.For example:If you use the correct retention policy, then the annotations won\'t be available at runtime. From that point of view, it is just an internal thing. Even though this is not a strict science, I think it makes most sense to use an internal class for it.If you are building your application using Spring Framework I would suggest using javax.validation.constraints.NotNull comming from Beans Validation  packaged in following dependency:The main advantage of this annotation is that Spring provides support for both method parameters and class fields annotated with javax.validation.constraints.NotNull. All you need to do to enable support is:supply the api jar for beans validation and jar with implementation of validator of jsr-303/jsr-349 annotations (which comes with Hibernate Validator 5.x dependency):provide MethodValidationPostProcessor to spring\'s contextfinally you annotate your classes with Spring\'s org.springframework.validation.annotation.Validated and validation will be automatically handled by Spring.Example:When you try calling method doSomething and pass null as the parameter value, spring (by means of HibernateValidator) will throw ConstraintViolationException. No need for manuall work here.You can also validate return values.Another important benefit of javax.validation.constraints.NotNull comming for Beans Validation Framework is that at the moment it is still developed and new features are planned for new version 2.0.What about @Nullable? There is nothing like that in Beans Validation 1.1. Well, I could arguee that if you decide to use @NotNull than everything which is NOT annotated with @NonNull is effectively "nullable", so the @Nullable annotation is useless.Doesn\'t sun have their own now? What\'s this:\nhttp://www.java2s.com/Open-Source/Java-Document/6.0-JDK-Modules-com.sun/istack/com.sun.istack.internal.htmThis seems to be packaged with all the versions of Java I\'ve used within the last few years.Edit: As mentioned in the comments below, you probably don\'t want to use these. In that case, my vote is for the IntelliJ jetbrains annotations!Another option is the annotations provided with ANTLR 4. Following Pull Request #434, the artifact containing the @NotNull and @Nullable annotations includes an annotation processor that produces compile-time errors and/or warnings in the event one of these attributes is misused (for example, if both are applied to the same item, or if @Nullable is applied to item with a primitive type). The annotation processor provides additional assurance during the software development process that the information conveyed by the application of these annotations is accurate, including in cases of method inheritance.Distinguish between static analysis and runtime analysis. Use static analysis for internal stuff, and runtime analysis for the public boundaries of your code.For things that should not be null:For things that may be null (No runtime check required):This should give the best result: warnings in the IDE, errors by Findbugs and checkerframework, meaningful runtime exceptions.Some explanations: