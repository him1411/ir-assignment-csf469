This question already has an answer here:I want to run a Python script from another Python script. I want to pass variables like I would using the command line.For example, I would run my first script that would iterate through a list of values (0,1,2,3) and pass those to the 2nd script script2.py 0 then  script2.py 1, etc.I found SO 1186789 which is a similar question but ars\'s answer calls a function, where as I want to run the whole script not just a function, and balpha\'s answer calls the script but with no args. I altered this to something like the below as a test: But it is not accepting variables properly.  When I print out the sys.argv in script2.py it is the original command call to first script "[\'C:\\script1.py\'].I don\'t really want to change the original script (i.e. script2.py in my example) since I don\'t own it.I figure there must be a way to do this, I am just confused how you do it.  Try using os.system:execfile is different because it is designed to run a sequence of Python statements in the current execution context. That\'s why sys.argv didn\'t change for you.This is inherently the wrong thing to do. If you are running a Python script from another Python script, you should communicate through Python instead of through the OS:In an ideal world, you will be able to call a function inside script1 directly:If necessary, you can hack sys.argv. There\'s a neat way of doing this using a context manager to ensure that you don\'t make any permanent changes.I think this is preferable to passing all your data to the OS and back; that\'s just silly.Ideally, the Python script you want to run will be set up with code like this near the end:In other words, if the module is called from the command line, it parses the command line options and then calls another function, main(), to do the actual work. (The actual arguments will vary, and the parsing may be more involved.)If you want to call such a script from another Python script, however, you can simply import it and call modulename.main() directly, rather than going through the operating system.os.system will work, but it is the roundabout (read "slow") way to do it, as you are starting a whole new Python interpreter process each time for no raisin.SubProcess module:\nhttp://docs.python.org/dev/library/subprocess.html#using-the-subprocess-moduleWith this, you can also redirect stdin, stdout, and stderr.I think the good practice may be something like this; according to documentation \nThe subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. This module intends to replace several older modules and functions:Use communicate() rather than .stdin.write, .stdout.read or .stderr.read to avoid deadlocks due to any of the other OS pipe buffers filling up and blocking the child process.\nRead HereIf os.system isn\'t powerful enough for you, there\'s the subprocess module.