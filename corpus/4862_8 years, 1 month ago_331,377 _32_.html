My question as title above. For example, but after all it only has 1 item inside.Can we have a method like items.Add(item)?like the List<T>You cannot, because IEnumerable<T> does not necessarily represent a collection to which items can be added. In fact, it does not necessarily represent a collection at all! For example:What you can do, however, is create a new IEnumerable object (of unspecified type), which, when enumerated, will provide all items of the old one, plus some of your own. You use Enumerable.Concat for that:This will not change the array object (you cannot insert items into to arrays, anyway). But it will create a new object that will list all items in the array, and then "Foo". Furthermore, that new object will keep track of changes in the array (i.e. whenever you enumerate it, you\'ll see the current values of items).The type IEnumerable<T> does not support such operations.  The purpose of the IEnumerable<T> interface is to allow a consumer to view the contents of a collection.  Not to modify the values.  When you do operations like .ToList().Add() you are creating a new List<T> and adding a value to that list.  It has no connection to the original list.What you can do is use the Add extension method to create a new IEnumerable<T> with the added value.Even in this case it won\'t modify the original IEnumerable<T> object.  This can be verified by holding a reference to it.  For exampleAfter this set of operations the variable temp will still only reference an enumerable with a single element "foo" in the set of values while items will reference a different enumerable with values "foo" and "bar".  EDITI contstantly forget that Add is not a typical extension method on IEnumerable<T> because it\'s one of the first ones that I end up defining.  Here it isHave you considered using ICollection<T>  or IList<T> interfaces instead, they exist for the very reason that you want to have an \'Add\' method on an IEnumerable<T>.\nIEnumerable<T> is used to \'mark\' a type as being ...well.. enumerable or just a sequence of items without necessarily making any guarantees of whether the real underlying object supports adding/removing of items. Also remember that these interfaces implements IEnumerable<T> so you get all the extensions methods that you get with IEnumerable<T> as well.A couple short, sweet extension methods on IEnumerable and IEnumerable<T> do it for me:Elegant (well, except for the non-generic versions).  Too bad these methods are not in the BCL.No the IEnumerable doens\'t support adding items to it.An \'alternative\' you have is.Not only can you not add items like you state, but if you add an item to a List<T> (or pretty much any other non-read only collection) that you have an existing enumerator for, the enumerator is invalidated (throws InvalidOperationException from then on).If you are aggregating results from some type of data query, you can use the Concat extension method:Edit: I originally used the Union extension in the example, which is not really correct. My application uses it extensively to make sure overlapping queries don\'t duplicate results.To add second message you need to - Others have already given great explanations regarding why you can not (and should not!) be able to add items to an IEnumerable. I will only add that if you are looking to continue coding to an interface that represents a collection and want an add method, you should code to ICollection or IList. As an added bonanza, these interfaces implement IEnumerable.I just come here to say that, aside from Enumerable.Concat extension method, there seems to be another method named Enumerable.Append in .NET Core 1.1.1. The latter allows you to concatenate a single item to an existing sequence. So Aamol\'s answer can also be written asStill, please note that this function will not change the input sequence, it just return a wrapper that put the given sequence and the appended item together.In .net Core, there is a method Enumerable.Append that does exactly that.The source code of the method is available on GitHub..... The implementation (more sophisticated than the suggestions in other answers) is worth a look :). you can do this.Easyest way to do that is simplyThen you can return list as IEnumerable also because it implements IEnumerable interfaceSure, you can (I am leaving your T-business aside):