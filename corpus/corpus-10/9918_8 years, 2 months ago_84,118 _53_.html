Having a list of points, how do I find if they are in clockwise order?For example:would say that it is anti-clockwise (counter-clockwise for some people).Some of the suggested methods will fail in the case of a non-convex polygon, such as a crescent. Here\'s a simple one that will work with non-convex polygons (it\'ll even work with a self-intersecting polygon like a figure-eight, telling you whether it\'s mostly clockwise).Sum over the edges, (x2 \xe2\x88\x92 x1)(y2 + y1). If the result is positive the curve is clockwise, if it\'s negative the curve is counter-clockwise. (The result is twice the enclosed area, with a +/- convention.)Because the cross product measures the degree of perpindicularness of two vectors... If you imagine that each edge of your polygon is a vector in the x-y plane of a 3-d xyz space, then the cross product of two successive edges would be a vector in the z-direction (if the second segment is clockwise) or in the minus z-direction (for counter-clockwise), whose magnitude is proportional to the sine of the angle between the two original edges (which reaches a maximum when they are perpindicular)so for each vertex (point) of the polygon, calculate the cross-product magnitude of the two adjoining edges... Say vertex A(point[0]) is between then it\'s cross product is the determinent of following matrix or...  since all cross-products are perpendicular to the plane of two vectors being multiplied, this will only have a k(z-axis)-component, and it\'s value is \na1*b2 - a2*b1 = -4* 4 - 0* 1  = -16 The magnitude of this value is a measure of the sine of the angle between the 2 original vectors, times the product of the magnitudes of the 2 vectors.. So you need to divide it by the product of the magnitudes of the two vectors(no need to take arcsine all we will care about is whether sign turns out positive or negative)do this for each of the other 4 points, and add up the values. If final sum is positive, you went clockwise, negative, counterclockwise.I guess this is a pretty old question, but I\'m going to throw out another solution anyway, because it\'s straightforward and not mathematically intensive - it just uses basic algebra. Calculate the signed area of the polygon. If it\'s negative the points are in clockwise order, if it\'s positive they are counterclockwise. (This is very similar to Beta\'s solution.)Calculate the signed area:\nA = 1/2 * (x1*y2 - x2*y1 + x2*y3 - x3*y2 + ... + xn*y1 - x1*yn)Or in pseudo-code:Note that if you are only checking the ordering, you don\'t need to bother dividing by 2.Sources: http://mathworld.wolfram.com/PolygonArea.htmlHere is a simple C# implementation of the algorithm described by Beta:Let\'s assume that we have a Vector type having X and Y properties of type double.Find the vertex with smallest y (and largest x if there are ties). Let the vertex be A and the next vertices in the list be B and C. Now compute the sign of the cross product of AB and AC.References:How do I find the orientation of a simple polygon? in \nFrequently Asked Questions: comp.graphics.algorithms.Curve orientation at Wikipedia.Start at one of the vertices, and compute the angle subtended by each side.  The first and the last will be zero (so skip those); for the rest, the sine of the angle will be given by the cross product of the normalizations to unit length of (point[n]-point[0]) and (point[n-1]-point[0]).If the sum of the values is positive, then your polygon is drawn in the anti-clockwise sense.BTW: If doing this in MATLAB, you can use ispolycw.I did the answer presented here first and then my labmate showed me the ispolycw function so that I could know how much time I wasted. :(For what it is worth, I used this mixin to calculate the winding order for Google Maps API v3 apps.The code leverages the side effect of polygon areas: a clockwise winding order of vertexes yields a positive area, while a counter-clockwise winding order of the same vertexes produces the same area as a negative value.  The code also uses a sort of private API in the Google Maps geometry library.  I felt comfortable using it - use at your own risk.Sample usage:Full example with unit tests @ http://jsfiddle.net/stevejansen/bq2ec/For 3 points  of 2 lines in the plane, use this:This a function function that specialized for OpenLayers. As You Can See The Condition Of Clockwise Polygon Is area<0 This Reference Confirm It. this is my solution using the above suggestionsI think in order for some points to be given clockwise all edges need to be positive not only the sum of edges. If one edge is negative than at least 3 points are given counter-clockwise.My C# / LINQ solution is based on the cross product advice of @charlesbretana is below. You can specify a reference normal for the winding. It should work as long as  the curve is mostly in the plane defined by the up vector.with a unit testFor anybody, just trying to implement this solution in Python: After testing several unreliable implementations, the algorithm that provided satisfactory results regarding the cw/ccw orientation out of the box was the one, posted by OP in this thread (shoelace_formula_3). As always: positive number is CW, negative number CCW.find the center of mass of these points. suppose there are lines from this point to your points.find the angle between two lines for line0 line1than do it for line1 and line2......if this angle is monotonically increasing than it is counterclockwise ,else if monotonically decreasing it is clockwiseelse (it is not monotonical)you cant decide, so it is not wise