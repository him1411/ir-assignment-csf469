I\'ve been looking for ways of making my site load faster and one way that I\'d like to explore is making greater use of Cloudfront.Because Cloudfront was originally not designed as a custom-origin CDN and because it didn\'t support gzipping, I have so far been using it to host all my images, which are referenced by their Cloudfront cname in my site code, and optimized with far-futures headers.CSS and javascript files, on the other hand, are hosted on my own server, because until now I was under the impression that they couldn\'t be served gzipped from Cloudfront, and that the gain from gzipping (about 75 per cent) outweighs that from using a CDN (about 50 per cent): Amazon S3 (and thus Cloudfront) did not support serving gzipped content in a standard manner by using the HTTP Accept-Encoding header that is sent by browsers to indicate their support for gzip compression, and so they were not able to Gzip and serve components on the fly.Thus I was under the impression, until now, that one had to choose between two alternatives:move all assets to the Amazon CloudFront and forget about GZipping;keep components self-hosted and configure our server to detect incoming requests and perform on-the-fly GZipping as appropriate, which is what I chose to do so far.There were workarounds to solve this issue, but essentially these didn\'t work. [link].Now, it seems Amazon Cloudfront supports custom origin, and that it is now possible to use the standard HTTP Accept-Encoding method for serving gzipped content if you are using a Custom Origin  [link].I haven\'t so far been able to implement the new feature on my server.  The blog post I linked to above, which is the only one I found detailing the change, seems to imply that you can only enable gzipping (bar workarounds, which I don\'t want to use), if you opt for custom origin, which I\'d rather not: I find it simpler to host the coresponding fileds on my Cloudfront server, and link to them from there. Despite carefully reading the documentation, I don\'t know:whether the new feature means the files should be hosted on my own domain server via custom origin, and if so, what code setup will achieve this;how to configure the css and javascript headers to make sure they are served gzipped from Cloudfront.The answer is to gzip the CSS and JavaScript files. Yes, you read that right.This will produce production.min.css.gz. Remove the .gz, upload to S3 (or whatever origin server you\'re using) and explicitly set the Content-Encoding header for the file to gzip.It\'s not on-the-fly gzipping, but you could very easily wrap it up into your build/deployment scripts. The advantages are:Assuming that your CSS/JavaScript files are (a) minified and (b) large enough to justify the CPU required to decompress on the user\'s machine, you can get significant performance gains here.Just remember: If you make a change to a file that is cached in CloudFront, make sure you invalidate the cache after making this type of change.My answer is a take off on this: http://blog.kenweiner.com/2009/08/serving-gzipped-javascript-files-from.htmlBuilding off skyler\'s answer you can upload a gzip and non-gzip version of the css and js.  Be careful naming and test in Safari. Because safari won\'t handle .css.gz or .js.gz files.site.js and site.js.jgz and\nsite.css and site.gz.css      (you\'ll need to set the content-encoding header to the correct MIME type to get these to serve right)Then in your page  put.  gzipcheck.js.jgz is just sr_gzipEnabled = true;  This tests to make sure the browser can handle the gzipped code and provide a backup if they can\'t.Then do something similar in the footer assuming all of your js is in one file and can go in the footer.UPDATE:  Amazon now supports gzip compression.  Announcement, so this is no longer needed.  Amazon AnnouncementCloudfront supports gzipping. Cloudfront connects to your server via HTTP 1.0. By default some webservers, including nginx, dosn\'t serve gzipped content to HTTP 1.0 connections, but you can tell it to do by adding:to your nginx config. The equivalent config could be set for whichever web server you\'re using.This does have a side effect of making keep-alive connections not work for HTTP 1.0 connections, but as the benefits of compression are huge, it\'s definitely worth the trade off.Taken from http://www.cdnplanet.com/blog/gzip-nginx-cloudfront/EditServing content that is gzipped on the fly through Amazon cloud front is dangerous and probably shouldn\'t be done. Basically if your webserver is gzipping the content, it will not set a Content-Length and instead send the data as chunked.If the connection between Cloudfront and your server is interrupted and prematurely severed, Cloudfront still caches the partial result and serves that as the cached version until it expires.The accepted answer of gzipping it first on disk and then serving the gzipped version is a better idea as Nginx will be able to set the Content-Length header, and so Cloudfront will discard truncated versions.We\'ve made a few optimisations for uSwitch.com recently to compress some of the static assets on our site. Although we setup a whole nginx proxy to do this, I\'ve also put together a little Heroku app that proxies between CloudFront and S3 to compress content: http://dfl8.coGiven publicly accessible S3 objects can be accessed using a simple URL structure, http://dfl8.co just uses the same structure. I.e. the following URLs are equivalent:Yesterday amazon announced new feature, you can now enable gzip on your distribution. It works with s3 without added .gz files yourself, I tried the new feature today and it works great. (need to invalidate you\'re current objects though)More infoYou can configure CloudFront to automatically compress files of certain types and serve the compressed files.See AWS Developer Guide