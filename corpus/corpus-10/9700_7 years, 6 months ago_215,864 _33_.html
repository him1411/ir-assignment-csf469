Why are interface variables static and final by default in Java?From the Java interface design FAQ by Philip Shaw:Interface variables are static because Java interfaces cannot be instantiated in their own right; the value of the variable must be assigned in a static context in which no instance exists. The final modifier ensures the value assigned to the interface variable is a true constant that cannot be re-assigned by program code. sourceSince interface doesn\'t have a direct object, the only way to access them is by using a class/interface and hence that is why if interface variable exists, it should be static otherwise it wont be accessible at all to outside world. Now since it is static, it can hold only one value and any classes that implements it can change it and hence it will be all mess.Hence if at all there is an interface variable, it will be implicitly static, final and obviously public!!!public: for the accessibility across all the classes, just like the methods present in the interfacestatic: as interface cannot have an object, the interfaceName.variableName can be used to reference it or directly the variableName in the class implementing it.final: to make them constants. If 2 classes implement the same interface and you give both of them the right to change the value, conflict will occur in the current value of the var, which is why only one time initialization is permitted.Also all these modifiers are implicit for an interface, you dont really need to specify any of them.Because anything else is part of the implementation, and interfaces cannot contain any implementation.static - because Interface cannot have any instance. and final - because we do not need to change it.Java does not allow abstract variables and/or constructor definitions in interfaces. Solution: Simply hang an abstract class between your interface and your implementation which only extends the abstract class like so:You can also use an abstract class without any interface if you are SURE that you don\'t want to implement it along with other interfaces later. Please note that you can\'t create an instance of an abstract class you MUST extend it first.(The "protected" keyword means that only extended classes can access these methods and variables.)spyroAn Interface is contract between two parties that is invariant, carved in the stone, hence final. See Design by Contract.Here is the solution.I think it is the one reason why interface variable are static.Don\'t declare variables inside Interface.(This is not a philosophical answer but more of a practical one). The requirement for static modifier is obvious which has been answered by others. Basically, since the interfaces cannot be instantiated, the only way to access its fields are to make them a class field -- static.The reason behind the interface fields automatically becoming final (constant) is to prevent different implementations accidentally changing the value of interface variable which can inadvertently affect the behavior of the other implementations. Imagine the scenario below where an interface property did not explicitly become final by Java:Now, just think what would happen if another class that implements Actionable alters the state of the interface variable:If these classes are loaded within a single JVM by a classloader, then the behavior of NuclearAction can be affected by another class, CleanAction, when its performAction() is invoke after CleanAction\'s is executed (in the same thread or otherwise), which in this case can be disastrous (semantically that is).Since we do not know how each implementation of an interface is going to use these variables, they must implicitly be final.  In Java, interface doesn\'t allow you to declare any instance variables. Using a variable declared in an interface as an instance variable will return a compile time error. You can declare a constant variable, using static final which is different from an instance variable. Interface can be implemented by any classes and what if that value got changed by one of there implementing class then there will be mislead for other implementing classes. Interface is basically a reference to combine two corelated but different entity.so for that reason the declaring variable inside the interface will implicitly be final and also static because interface can not be instantiate. Think of a web application where you have interface defined and other classes implement it. As you cannot create an instance of interface to access the variables you need to have a static keyword. Since its static any change in the value will reflect to other instances which has implemented it. So in order to prevent it we define them as final.Just tried in Eclipse, the variable in interface is default to be final, so you can\'t change it. Compared with parent class, the variables are definitely changeable. Why? From my point, variable in class is an attribute which will be inherited by children, and children can change it according to their actual need. On the contrary, interface only define behavior, not attribute. The only reason to put in variables in interface is to use them as consts which related to that interface. Though, this is not a good practice according to following excerpt:"Placing constants in an interface was a popular technique in the early days of Java, but now many consider it a distasteful use of interfaces, since interfaces should deal with the services provided by an object, not its data. As well, the constants used by a class are typically an implementation detail, but placing them in an interface promotes them to the public API of the class." I also tried either put static or not makes no difference at all. The code is as below:I think it\'s because interfaces can\'t be instantiated, so all variables are declared as static.\nUse of the final keyword means it doesn\'t have a body.             