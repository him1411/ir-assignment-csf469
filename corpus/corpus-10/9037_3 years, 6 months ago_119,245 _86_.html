Is there not a simple way to pass a child\'s props to its parent using events, in React.js?I know you can use controlled components to pass an input\'s value but it\'d be nice to pass the whole kit n\' kaboodle. Sometimes the child component contains a set of information you\'d rather not have to look up.Perhaps there\'s a way to bind the component to the event?After using React for over a year, and spurred on by Sebastien Lorber\'s answer, I\'ve concluded passing child components as arguments to functions in parents is not in fact the React way, nor was it ever a good idea. I\'ve switched the answer.Edit: see the end examples for ES6 updated examples.This answer simply handle the case of direct parent-child relationship. When parent and child have potentially a lot of intermediaries, check this answer.While they still work fine, other answers are missing something very important.Is there not a simple way to pass a child\'s props to its parent using events, in React.js?The parent already has that child prop!: if the child has a prop, then it is because its parent provided that prop to the child! Why do you want the child to pass back the prop to the parent, while the parent obviously already has that prop?Child: it really does not have to be more complicated than that.Parent with single child: using the value it passes to the childJsFiddleParent with list of children: you still have everything you need on the parent and don\'t need to make the child more complicated.JsFiddleIt is also possible to use this.handleChildClick.bind(null,childIndex) and then use this.state.childrenData[childIndex]Note we are binding with a null context because otherwise React issues a warning related to its autobinding system. Using null means you don\'t want to change the function context. See also.This is for me a bad idea in term of coupling and encapsulation:Using props:\nAs I explained above, you already have the props in the parent so it\'s useless to pass the whole child component to access props.Using refs: \nYou already have the click target in the event, and in most case this is enough. \nAdditionnally, you could have used a ref directly on the child:And access the DOM node in the parent withFor more advanced cases where you want to access multiple refs of the child in the parent, the child could pass all the dom nodes directly in the callback.The component has an interface (props) and the parent should not assume anything about the inner working of the child, including its inner DOM structure or which DOM nodes it declares refs for. A parent using a ref of a child means that you tightly couple the 2 components.To illustrate the issue, I\'ll take this quote about the Shadow DOM, that is used inside browsers to render things like sliders, scrollbars, video players...:They created a boundary between what you, the Web developer can reach\n  and what\xe2\x80\x99s considered implementation details, thus inaccessible to\n  you. The browser however, can traipse across this boundary at will.\n  With this boundary in place, they were able to build all HTML elements\n  using the same good-old Web technologies, out of the divs and spans\n  just like you would.The problem is that if you let the child implementation details leak into the parent, you make it very hard to refactor the child without affecting the parent. This means as a library author (or as a browser editor with Shadow DOM) this is very dangerous because you let the client access too much, making it very hard to upgrade code without breaking retrocompatibility.If Chrome had implemented its scrollbar letting the client access the inner dom nodes of that scrollbar, this means that the client may have the possibility to simply break that scrollbar, and that apps would break more easily when Chrome perform its auto-update after refactoring the scrollbar... Instead, they only give access to some safe things like customizing some parts of the scrollbar with CSS.About using anything elsePassing the whole component in the callback is dangerous and may lead novice developers to do very weird things like calling childComponent.setState(...) or childComponent.forceUpdate(), or assigning it new variables, inside the parent, making the whole app much harder to reason about.Edit: ES6 examplesAs many people now use ES6, here are the same examples for ES6 syntaxThe child can be very simple:The parent can be either a class (and it can eventually manage the state itself, but I\'m passing it as props here:But it can also be simplified if it does not need to manage state:JsFiddlePERF WARNING (apply to ES5/ES6): if you are using PureComponent or shouldComponentUpdate, the above implementations will not be optimized by default because using onClick={e => doSomething()}, or binding directly during the render phase, because it will create a new function everytime the parent renders. If this is a perf bottleneck in your app, you can pass the data to the children, and reinject it inside "stable" callback (set on the parent class, and binded to this in class constructor) so that PureComponent optimization can kick in, or you can implement your own shouldComponentUpdate and ignore the callback in the props comparison check.You can also use Recompose library, which provide higher order components to achieve fine-tuned optimisations:In this case you could optimize the Child component by using:Update (9/1/15): The OP has made this question a bit of a moving target. It\xe2\x80\x99s been updated again. So, I feel responsible to update my reply.Yes, this is possible.You can solve this by updating Child\xe2\x80\x99s onClick to be this.props.onClick.bind(null, this):The event handler in your Parent can then access the component and event like so:JSBin snapshotParent already knows Child\xe2\x80\x99s props.This isn\xe2\x80\x99t clear in the provided example because no props are actually being provided. This sample code might better support the question being asked:It becomes much clearer in this example that you already know what the props of Child are.JSBin snapshotIf it\xe2\x80\x99s truly about using a Child\xe2\x80\x99s props, you can avoid any hookup with Child altogether.JSX has a spread attributes API I often use on components like Child. It takes all the props and applies them to a component. Child would look like this:Allowing you to use the values directly in the Parent:JSBin snapshot\nAnd there\'s no additional configuration required as you hookup additional Child componentsJSBin snapshotBut I suspect that\xe2\x80\x99s not your actual use case. So let\xe2\x80\x99s dig further\xe2\x80\xa6The generic nature of the provided example is a hard to talk about. I\xe2\x80\x99ve created a component that demonstrations a practical use for the question above, implemented in a very Reacty way:DTServiceCalculator working example\nDTServiceCalculator repoThis component is a simple service calculator. You provide it with a list of services (with names and prices) and it will calculate a total the selected prices.ServiceItem is the child-component in this example. It doesn\xe2\x80\x99t have many opinions about the outside world. It requires a few props, one of which is a function to be called when clicked.<div onClick={this.props.handleClick.bind(this.props.index)} />It does nothing but to call the provided handleClick callback with the provided index[source].DTServicesCalculator is the parent-component is this example. It\xe2\x80\x99s also a child. Let\xe2\x80\x99s look.DTServiceCalculator creates a list of child-component (ServiceItems) and provides them with props [source]. It\xe2\x80\x99s the parent-component of ServiceItem but it`s the child-component of the component passing it the list. It doesn\'t own the data. So it again delegates handling of the component to its parent-component source<ServiceItem chosen={chosen} index={i} key={id} price={price} name={name} onSelect={this.props.handleServiceItem} />handleServiceItem captures the index, passed from the child, and provides it to its parent [source]The concept of \xe2\x80\x9cOwnership\xe2\x80\x9d is an important one in React. I recommend reading more about it here.In the example I\xe2\x80\x99ve shown, I keep delegating handling of an event up the component tree until we get to the component that owns the state.When we finally get there, we handle the state selection/deselection like so [source]:Try keeping your outer-most components as opaque as possible. Strive to make sure that they have very few preferences about how a parent-component might choose to implement them.Keep aware of who owns the data you are manipulating. In most cases, you will need to delegate event handling up the tree to the component that owns that state.Aside: The Flux pattern is a good way to reduce this type of necessary hookup in apps.It appears there\'s a simple answer. Consider this:The key is calling bind(null, this) on the this.props.onClick event, passed from the parent. Now, the onClick function accepts arguments component, AND event. I think that\'s the best of all worlds.This was a bad idea: letting child implementation details leak in to the parent was never a good path. See Sebastien Lorber\'s answer.Basically you use props to send information to and from Child and Parent. Adding to all the wonderful answers, let me give a simple example that explains passing values from child to parent component in ReactApp.jsHeader.jsMain.jsThats it , now you can pass values from your client to the server.Take a look at the Change function in the Header.jsThis is how you push values into the props from client to the serverThe question is how to pass argument from child to parent component. This example is easy to use and tested:Look at JSFIDDLE