Where are MIN and MAX defined in C, if at all?What is the best way to implement these, as generically and type safely as possible? (Compiler extensions/builtins for mainstream compilers preferred.)Where are MIN and MAX defined in C, if at all?They aren\'t.What is the best way to implement these, as generically and type safe as possible (compiler extensions/builtins for mainstream compilers preferred).As functions. I wouldn\'t use macros like #define MIN(X, Y) (((X) < (Y)) ? (X) : (Y)), especially if you plan to deploy your code. Either write your own, use something like standard fmax or fmin, or fix the macro using GCC\'s typeof (you get typesafety bonus too):Everyone says "oh I know about double evaluation, it\'s no problem" and a few months down the road, you\'ll be debugging the silliest problems for hours on end.Note the use of __typeof__ instead of typeof:If you are writing a header file that\n  must work when included in ISO C\n  programs, write __typeof__ instead of\n  typeof.It\'s also provided in the GNU libc (Linux) and FreeBSD versions of sys/param.h, and has the definition provided by dreamlax.On Debian:On FreeBSD:The source repositories are here:There\'s a std::min and std::max in C++, but AFAIK, there\'s no equivalent in the C standard library.  You can define them yourself with macros likeBut this causes problems if you write something like MAX(++a, ++b).I don\'t think that they are standardised macros. There are standardised functions for floating point already, fmax and fmin (and fmaxf for floats, and fmaxl for long doubles).You can implement them as macros as long as you are aware of the issues of side-effects/double-evaluation.In most cases, you can leave it to the compiler to determine what you\'re trying to do and optimise it as best it can. While this causes problems when used like MAX(i++, j++), I doubt there is ever much need in checking the maximum of incremented values in one go. Increment first, then check.I wrote this version that works for MSVC, GCC, C, and C++.Avoid non-standard compiler extensions and implement it as a completely type-safe macro in pure standard C (ISO 9899:2011).SolutionUsage ExplanationThe macro MAX creates another macro based on the type parameter. This control macro, if implemented for the given type, is used to check that both parameters are of the correct type. If the type is not supported, there will be a compiler error.If either x or y is not of the correct type, there will be a compiler error in the ENSURE_ macros. More such macros can be added if more types are supported. I\'ve assumed that only arithmetic types (integers, floats, pointers etc) will be used and not structs or arrays etc.If all types are correct, the GENERIC_MAX macro will be called. Extra parenthesis are needed around each macro parameter, as the usual standard precaution when writing C macros.Then there\'s the usual problems with implicit type promotions in C. The ?:operator balances the 2nd and 3rd operand against each other. For example, the result of GENERIC_MAX(my_char1, my_char2) would be an int. To prevent the macro from doing such potentially dangerous type promotions, a final type cast to the intended type was used.RationaleWe want both parameters to the macro to be of the same type. If one of them is of a different type, the macro is no longer type safe, because an operator like ?: will yield implicit type promotions. And because it does, we also always need to cast the final result back to the intended type as explained above.A macro with just one parameter could have been written in a much simpler way. But with 2 or more parameters, there is a need to include an extra type parameter. Because something like this is unfortunately impossible:The problem is that if the above macro is called as MAX(1, 2) with two int, it will still try to macro-expand all possible scenarios of the _Generic association list. So the ENSURE_float macro will get expanded too, even though it isn\'t relevant for int. And since that macro intentionally only contains the float type, the code won\'t compile.To solve this, I created the macro name during the pre-processor phase instead, with the ## operator, so that no macro gets accidentally expanded.ExamplesThis is a late answer, due to a fairly recent development. Since the OP accepted the answer that relies on a non-portable GCC (and clang) extension typeof - or __typeof__ for \'clean\' ISO C - there\'s a better solution available as of gcc-4.9.The obvious benefit of this extension is that each macro argument is only expanded once, unlike the __typeof__ solution.__auto_type is a limited form of C++11\'s auto. It cannot (or should not?) be used in C++ code, though there\'s no good reason not to use the superior type inference capabilities of auto when using C++11.That said, I assume there are no issues using this syntax when the macro is included in an extern "C" { ... } scope; e.g., from a C header. AFAIK, this extension has not found its way info clangIf you need min/max in order to avoid an expensive branch, you shouldn\'t use the ternary operator, as it will compile down to a jump. The link below describes a useful method for implementing a min/max function without branching.http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMaxI know the guy said "C"...\nBut if you have the chance, use a C++ template:Type safe, and no problems with the ++ mentioned in other comments.It\'s worth pointing out I think that if you define min and max with the tertiary such asthen to get the same result for the special case of fmin(-0.0,0.0) and fmax(-0.0,0.0) you need to swap the argumentsThe maximum of two integers a and b is (int)(0.5((a+b)+abs(a-b))). This may also work with (double) and fabs(a-b) for doubles (similar for floats)Looks like Windef.h (a la #include <windows.h>) has max and min (lower case) macros, that also suffer from the "double evaluation" difficulty, but they\'re there for those that don\'t want to re-roll their own :)