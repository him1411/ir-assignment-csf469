How do you run the following command in PowerShell?C:\\Program Files\\IIS\\Microsoft Web Deploy\\msdeploy.exe -verb:sync -source:dbfullsql="Data Source=mysource;Integrated Security=false;User ID=sa;Pwd=sapass!;Database=mydb;" -dest:dbfullsql="Data Source=.\\mydestsource;Integrated Security=false;User ID=sa;Pwd=sapass!;Database=mydb;",computername=10.10.10.10,username=administrator,password=adminpass"When PowerShell sees a command starting with a string it just evaluates the string, that is, it typically echos it to the screen, for example:If you want PowerShell to interpret the string as a command name then use the call operator (&) like so:After that you probably only need to quote parameter/argument pairs that contain spaces and/or quotation chars. When you invoke an EXE file like this with complex command line arguments it is usually very helpful to have a tool that will show you how PowerShell sends the arguments to the EXE file. The PowerShell Community Extensions has such a tool. It is called echoargs. You just replace the EXE file with echoargs - leaving all the arguments in place, and it will show you how the EXE file will receive the arguments, for example:Using echoargs you can experiment until you get it right, for example:It turns out I was trying too hard before to maintain the double quotes around the connection string. Apparently that isn\'t necessary because even cmd.exe will strip those out.BTW, hats off to the PowerShell team. They were quite helpful in showing me the specific incantation of single & double quotes to get the desired result - if you needed to keep the internal double quotes in place. :-)  They also realize this is an area of pain, but they are driven by the number of folks are affected by a particular issue. If this is an area of pain for you, then please vote up this PowerShell bug submission.For more information on how PowerShell parses, check out my Effective PowerShell blog series - specifically item 10 - "Understanding PowerShell Parsing Modes"UPDATE 4/4/2012: This situation gets much easier to handle in PowerShell V3. See this blog post for details.Just add the & operator before the .exe name. \nHere is a command to install SQL Server Express in silence mode:I had spaces in both command and parameters, and this is what worked for me:It\'s basically the same as Akira\'s answer, but this works if you dynamically build your command parameters and put them in a variable.See this page:\nhttp://edgylogic.com/blog/powershell-and-external-commands-done-right/Summary using vshadow as the external executable:This worked for me:Just put paths or connection strings in one array item and split the other things in one array item each.There are a lot of other options here: https://social.technet.microsoft.com/wiki/contents/articles/7703.powershell-running-executables.aspxMicrosoft should make this way simpler and compatible with command prompt syntax.I was able to get my similar command working using the following approach:For your command (not that it helps much now), things would look something like this: The key points are:I didn\'t try adding the "computername" part at the end of the command line, but hopefully this info will help others reading this now get closer to their desired result.New escape string in PowerShell V3, quoted from New V3 Language Features:Easier Reuse of Command Lines From Cmd.exeThe web is full of command lines written for Cmd.exe. These commands lines work often enough in PowerShell, but when they include certain characters, for example, a semicolon (;), a dollar sign ($), or curly braces, you have to make some changes, probably adding some quotes. This seemed to be the source of many minor headaches.To help address this scenario, we added a new way to \xe2\x80\x9cescape\xe2\x80\x9d the parsing of command lines. If you use a magic parameter --%, we stop our normal parsing of your command line and switch to something much simpler. We don\xe2\x80\x99t match quotes. We don\xe2\x80\x99t stop at semicolon. We don\xe2\x80\x99t expand PowerShell variables. We do expand environment variables if you use Cmd.exe syntax (e.g. %TEMP%). Other than that, the arguments up to the end of the line (or pipe, if you are piping) are passed as is. Here is an example:This worked for me:The key seems to be that the whole command is enclosed in outer quotes, the "&" ampersand is used to specify another child command file is being executed, then finally escaped (doubled-double-) quotes around the path/file name with spaces in you wanted to execute in the first place.This is also completion of the only workaround to the MS connect issue that -File does not pass-back non-zero return codes and -Command is the only alternative. But until now it was thought a limitation of -Command was that it didn\'t support spaces. I\'ve updated that feedback item too.http://connect.microsoft.com/PowerShell/feedback/details/750653/powershell-exe-doesn-t-return-correct-exit-codes-when-using-the-file-optionI tried all of the suggestions but was still unable to run msiexec.exe with parameters that contained spaces. So my solution ended up using System.Diagnostics.ProcessStartInfo:An alternative answer is to use a Base64 encoded command switch:When decoded, you\'ll see it\'s the OP\'s original snippet with all arguments and double quotes preserved.The original command:It turns into this when encoded as Base64:and here is how to replicate at home:So, I ran into a similar problem and chose to solve it this way instead:Example solution:& { invoke-expression "C:\\Program Files\\IIS\\Microsoft Web Deploy\\msdeploy.exe -verb:sync -source:dbfullsql=`"Data Source=mysource;Integrated Security=false;User ID=sa;Pwd=sapass!;Database=mydb;`" -dest:dbfullsql=`"Data Source=.\\mydestsource;Integrated Security=false;User ID=sa;Pwd=sapass!;Database=mydb;`",computername=10.10.10.10,username=administrator,password=adminpass`"" }