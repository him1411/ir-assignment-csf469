I\'ve heard it said that multiline lambdas can\'t be added in Python because they would clash syntactically with the other syntax constructs in Python.  I was thinking about this on the bus today and realized I couldn\'t think of a single Python construct that multiline lambdas clash with.  Given that I know the language pretty well, this surprised me.Now, I\'m sure Guido had a reason for not including multiline lambdas in the language, but out of curiosity: what\'s a situation where including a multiline lambda would be ambiguous?  Is what I\'ve heard true, or is there some other reason that Python doesn\'t allow multiline lambdas?Look at the following:Is this a lambda returning (y, [1,2,3]) (thus map only gets one parameter, resulting in an error)? Or does it return y? Or is it a syntax error, because the comma on the new line is misplaced? How would Python know what you want?Within the parens, indentation doesn\'t matter to python, so you can\'t unambiguously work with multilines.This is just a simple one, there\'s probably more examples.Guido van Rossum (the inventor of Python) answers this exact question himself in an old blog post.\nBasically, he admits that it\'s theoretically possible, but that any proposed solution would be un-Pythonic:"But the complexity of any proposed solution for this puzzle is immense, to me: it requires the parser (or more precisely, the lexer) to be able to switch back and forth between indent-sensitive and indent-insensitive modes, keeping a stack of previous modes and indentation level. Technically that can all be solved (there\'s already a stack of indentation levels that could be generalized). But none of that takes away my gut feeling that it is all an elaborate Rube Goldberg contraption."This is generally very ugly (but sometimes the alternatives are even more ugly), so a workaround is to make a braces expression:It won\'t accept any assignments though, so you\'ll have to prepare data beforehand.\nThe place I found this useful is the PySide wrapper, where you sometimes have short callbacks. Writing additional member functions would be even more ugly. Normally you won\'t need this.Example:A couple of relevant links:For a while, I was following the development of Reia, which was initially going to have Python\'s indentation based syntax with  Ruby blocks too, all on top of Erlang.  But, the designer wound up giving up on indentation sensitivity, and this post he wrote about that decision includes a discussion about problems he ran into with indentation + multi-line blocks, and an increased appreciation he gained for Guido\'s design issues/decisions:http://www.unlimitednovelty.com/2009/03/indentation-sensitivity-post-mortem.htmlAlso, here\'s an interesting proposal for Ruby-style blocks in Python I ran across where Guido posts a response w/o actually shooting it down (not sure whether there has been any subsequent shoot down, though):http://tav.espians.com/ruby-style-blocks-in-python.htmlLet me try to tackle @balpha parsing problem. I would use parentheses around the multiline lamda. If there is no parentheses, the lambda definition is greedy. So the lambda in returns a function that returns (y*z, [1,2,3])Butmeanswhere func is the multiline lambda that return y*z. Does that work?(For anyone still interested in the topic.)Consider this (includes even usage of statements\' return values in further statements within the "multiline" lambda, although it\'s ugly to the point of vomiting ;-)Let me present to you a glorious but terrifying hack:You can now use this LET form as such:which gives: [0, 3, 8][Edit] Read this answer. It explains why multiline lambda is not a thing. Simply put, it\'s unpythonic. From Guido van Rossum\'s blog post:I find any solution unacceptable that embeds an indentation-based block in the middle of an expression. Since I find alternative syntax for statement grouping (e.g. braces or begin/end keywords) equally unacceptable, this pretty much makes a multi-line lambda an unsolvable puzzle.As for the rest of this answer. Either use a single-line1 lambda or a named function. Please do not use exec--I regret ever suggested that.1You\'d be surprised what you can do with one line of python.A workaround to get multiline lambda functions (an extension to skriticos\'s answer):What it does:Python simplifies (executes) every component of a tuple before\nreading the delimiters.e.g., lambda x: (functionA(), functionB(), functionC(), 0)[-1]\nwould execute all three functions even though the only information\nthat\'s used is the last item in the list (0).Normally you can\'t assign to or declare variables within lists or tuples in python, however using the exec function you can (note that it always returns: None).Note that unless you declare a variable as global it won\'t exist outside of that exec function call (this is only true for exec functions within lambda statements).e.g., (lambda: exec(\'x=5;print(x)\'))() works fine without global declaration. However, (lambda: (exec(\'x=5\'), exec(\'print(x)\')))() or (lambda: (exec(\'x=5\'), x)() do not.Note that all global variables are stored in the global namespace and will continue to exist after the function call is complete. For this reason, this is not a good solution and should be avoided if at all possible. global variables declared from the exec function inside a lambda function are kept separate from the global namespace. (tested in Python 3.3.3)The [-1] at the end of the tuple gets the last index. For example [1,2,3,4][-1] is 4. This is done so only the desired output value(s) is returned rather than an entire tuple containing None from exec functions and other extraneous values.Equivalent multi-line function:Ways to avoid needing a multi-line lambda:Recursion:Booleans are Integers:Iterators: