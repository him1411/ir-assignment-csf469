I am trying to implement the SearchView from the support library. I want the user to be to use the SearchView to filter a List of movies in a RecyclerView.I have followed a few tutorials so far and I have added the SearchView to the ActionBar, but I am not really sure where to go from here. I have seen a few examples but none of them show results as you start typing.This is my MainActivity:And this is my Adapter:Since it is not really clear form your question with what exactly you are having trouble I wrote up this quick walkthrough about how to implement this feature, if you still have questions feel free to ask.I have a working example of everything I am talking about here in this GitHub Repository.\nIf you want to know more about the example project visit the project homepage.In any case the result should looks something like this:If you first want to play around with the demo app you can install it from the Play Store:Anyway lets get started.In the folder res/menu create a new file called main_menu.xml. In it add an item and set the actionViewClass to android.support.v7.widget.SearchView. Since you are using the support library you have to use the namespace of the support library to set the actionViewClass attribute. Your xml file should look something like this:In your Fragment or Activity you have to inflate this menu xml like usual, then you can look for the MenuItem which contains the SearchView and implement the OnQueryTextListener which we are going to use to listen for changes to the text entered into the SearchView:And now the SearchView is ready to be used. We will implement the filter logic later on in onQueryTextChange() once we are finished implementing the Adapter.First and foremost this is the model class I am going to use for this example: It\'s just your basic model which will display a text in the RecyclerView. This is the layout I am going to use to display the text: As you can see I use Data Binding. If you have never worked with data binding before don\'t be discouraged! It\'s very simple and powerful, however I can\'t explain how it works in the scope of this answer.This is the ViewHolder for the ExampleModel class:Again nothing special. It just uses data binding to bind the model class to this layout as we have defined in the layout xml above. Now we can finally come to the really interesting part: Writing the Adapter. I am going to skip over the basic implementation of the Adapter and am instead going to concentrate on the parts which are relevant for this answer.But first there is one thing we have to talk about: The SortedList class.The SortedList is a completely amazing tool which is part of the RecyclerView library. It takes care of notifying the Adapter about changes to the data set and does so it a very efficient way. The only thing it requires you to do is specify an order of the elements. You need to do that by implementing a compare() method which compares two elements in the SortedList just like a Comparator. But instead of sorting a List it is used to sort the items in the RecyclerView! The SortedList interacts with the Adapter through a Callback class which you have to implement:In the methods at the top of the callback like onMoved, onInserted, etc. you have to call the equivalent notify method of your Adapter. The three methods at the bottom compare, areContentsTheSame and areItemsTheSame you have to implement according to what kind of objects you want to display and in what order these objects should appear on the screen.Let\'s go through these methods one by one:This is the compare() method I talked about earlier. In this example I am just passing the call to a Comparator which compares the two models. If you want the items to appear in alphabetical order on the screen. This comparator might look like this:Now let\'s take a look at the next method:The purpose of this method is to determine if the content of a model has changed. The SortedList uses this to determine if a change event needs to be invoked - in other words if the RecyclerView should crossfade the old and new version. If you model classes have a correct equals() and hashCode() implementation you can usually just implement it like above. If we add an equals() and hashCode() implementation to the ExampleModel class it should look something like this:Quick side note: Most IDE\'s like Android Studio, IntelliJ and Eclipse have functionality to generate equals() and hashCode() implementations for you at the press of a button! So you don\'t have to implement them yourself. Look up on the internet how it works in your IDE!Now let\'s take a look at the last method:The SortedList uses this method to check if two items refer to the same thing. In simplest terms (without explaining how the SortedList works) this is used to determine if an object is already contained in the List and if either an add, move or change animation needs to be played. If your models have an id you would usually compare just the id in this method. If they don\'t you need to figure out some other way to check this, but however you end up implementing this depends on your specific app. Usually it is the simplest option to give all models an id - that could for example be the primary key field if you are querying the data from a database.With the SortedList.Callback correctly implemented we can create an instance of the SortedList:As the first parameter in the constructor of the SortedList you need to pass the class of your models. The other parameter is just the SortedList.Callback we defined above.Now let\'s get down to business: If we implement the Adapter with a SortedList it should look something like this:The Comparator used to sort the item is passed in through the constructor so we can use the same Adapter even if the items are supposed to be displayed in a different order.Now we are almost done! But we first need a way to add or remove items to the Adapter. For this purpose we can add methods to the Adapter which allow us to add and remove items to the SortedList:We don\'t need to call any notify methods here because the SortedList already does this for through the SortedList.Callback! Aside from that the implementation of these methods is pretty straight forward with one exception: the remove method which removes a List of models. Since the SortedList has only one remove method which can remove a single object we need to loop over the list and remove the models one by one. Calling beginBatchedUpdates() at the beginning batches all the changes we are going to make to the SortedList together and improves performance. When we call endBatchedUpdates() the RecyclerView is notified about all the changes at once. Additionally what you have to understand is that if you add an object to the SortedList and it is already in the SortedList it won\'t be added again. Instead the SortedList uses the areContentsTheSame() method to figure out if the object has changed - and if it has the item in the RecyclerView will be updated.Anyway, what I usually prefer is one method which allows me to replace all items in the RecyclerView at once. Remove everything which is not in the List and add all items which are missing from the SortedList:This method again batches all updates together to increase performance. The first loop is in reverse since removing an item at the start would mess up the indexes of all items that come up after it and this can lead in some instances to problems like data inconsistencies. After that we just add the List to the SortedList using addAll() to add all items which are not already in the SortedList and - just like I described above - update all items that are already in the SortedList but have changed.And with that the Adapter is complete. The whole thing should look something like this:The only thing missing now is to implement the filtering!To implement the filter logic we first have to define a List of all possible models. For this example I create a List of ExampleModel instances from an array of movies:Nothing special going on here, we just instantiate the Adapter and set it to the RecyclerView. After that we create a List of models from the movie names in the MOVIES array. Then we add all the models to the SortedList.Now we can go back to onQueryTextChange() which we defined earlier and start implementing the filter logic:This is again pretty straight forward. We call the method filter() and pass in the List of ExampleModels as well as the query string. We then call replaceAll() on the Adapter and pass in the filtered List returned by filter(). We also have to call scrollToPosition(0) on the RecyclerView to ensure that the user can always see all items when searching for something. Otherwise the RecyclerView might stay in a scrolled down position while filtering and subsequently hide a few items. Scrolling to the top ensures a better user experience while searching.The only thing left to do now is to implement filter() itself:The first thing we do here is call toLowerCase() on the query string. We don\'t want our search function to be case sensitive and by calling toLowerCase() on all strings we compare we can ensure that we return the same results regardless of case. It then just iterates through all the models in the List we passed into it and checks if the query string is contained in the text of the model. If it is then the model is added to the filtered List.And that\'s it! The above code will run on API level 7 and above and starting with API level 11 you get item animations for free! I realize that this is a very detailed description which probably makes this whole thing seem more complicated than it really is, but there is a way we can generalize this whole problem and make implementing an Adapter based on a SortedList much simpler.In this section I am not going to go into much detail - partly because I am running up against the character limit for answers on Stack Overflow but also because most of it already explained above - but to summarize the changes: We can implemented a base Adapter class which already takes care of dealing with the SortedList as well as binding models to ViewHolder instances and provides a convenient way to implement an Adapter based on a SortedList. For that we have to do two things:This allows us to just focus on the content which is supposed to be displayed in the RecyclerView by just implementing the models and there corresponding ViewHolder implementations. Using this base class we don\'t have to worry about the intricate details of the Adapter and its SortedList. Because of the character limit for answers on StackOverflow I can\'t go through each step of implementing this base class or even add the full source code here, but you can find the full source code of this base class - I called it SortedListAdapter - in this GitHub Gist.To make your life simple I have published a library on jCenter which contains the SortedListAdapter! If you want to use it then all you need to do is add this dependency to your app\'s build.gradle file:You can find more information about this library on the library homepage. To use the SortedListAdapter we have to make two changes:Change the ViewHolder so that it extends SortedListAdapter.ViewHolder. The type parameter should be the model which should be bound to this ViewHolder - in this case ExampleModel. You have to bind data to your models in performBind() instead of bind().Make sure that all your models implement the ViewModel interface:After that we just have to update the ExampleAdapter to extend SortedListAdapter and remove everything we don\'t need anymore. The type parameter should be the type of model you are working with - in this case ExampleModel. But if you are working with different types of models then set the type parameter to ViewModel.After that we are done! However one last thing to mention: The SortedListAdapter does not have the same add(), remove() or replaceAll() methods our original ExampleAdapter had. It uses a separate Editor object to modify the items in the list which can be accessed through the edit() method. So if you want to remove or add items you have to call edit() then add and remove the items on this Editor instance and once you are done, call commit() on it to apply the changes to the SortedList:All changes you make this way are batched together to increase performance. The replaceAll() method we implemented in the chapters above is also present on this Editor object:If you forget to call commit() then none of your changes will be applied!All you need to do is to add filter method in RecyclerView.Adapter:itemsCopy is initialized in adapter\'s constructor like itemsCopy.addAll(items). If you do so, just call filter from OnQueryTextListener:It\'s an example from filtering my phonebook by name and phone number.Following @Shruthi Kamoji in a cleaner way, we can just use a filterable, its meant for that:The E here is a Generic Type, you can extend it using your class:Or just change the E to the type you want (<CustomerModel> for example)Then from searchView (the widget you can put on menu.xml):I recommend modify the solution of @Xaver Kapeller with 2 things below to avoid a problem after you cleared the searched text (the filter didn\'t work anymore) due to the list back of adapter has smaller size than filter list and the IndexOutOfBoundsException happened. So the code need to modify as belowAnd modify also in moveItem functionalityHope that It could help you!I followed these steps and it worked well, not so complicated and it works pretty good we are surfing around same sittuation with different ways\nHope it helpssimply create two list in adapter one orignal and one temp and implements Filterable.whereIn Adapter:In Activity:I have solved the same problem using the link with some modifications in it. Search filter on RecyclerView with Cards. Is it even possible? (hope this helps).Here is my adapter class//Filter class}//Activity classIn OnQueryTextChangeListener() method use your adapter. I have casted it to fragment as my adpter is in fragment. You can use the adapter directly if its in your activity class.