C99 standard has integer types with bytes size like int64_t. I am using the following code:and I get this compiler warning:I tried with:But I get the same warning. I am using this compiler:Which format should I use to print my_int variable without having a warning?For int64_t type:for uint64_t type:you can also use PRIx64 to print in hexadecimal.cppreference.com has a full listing of available macros for all types including intptr_t (PRIxPTR).  There are separate macros for scanf, like SCNd64.A typical definition of PRIu16 would be "hu", so implicit string-constant concatenation happens at compile time.For your code to be fully portable, you must use PRId32 and so on for printing int32_t, and "%d" or similar for printing int.The C99 way isOr you could cast!If you\'re stuck with a C89 implementation (notably Visual Studio) you can perhaps use an open source <inttypes.h> (and <stdint.h>): http://code.google.com/p/msinttypes/With C99 the %j length modifier can also be used with the printf family of functions to print values of type int64_t and uint64_t:Compiling this code with gcc -Wall -pedantic -std=c99 produces no warnings, and the program prints the expected output:This is according to printf(3) on my Linux system (the man page specifically says that j is used to indicate a conversion to an intmax_t or uintmax_t; in my stdint.h, both int64_t and intmax_t are typedef\'d in exactly the same way, and similarly for uint64_t). I\'m not sure if this is perfectly portable to other systems.Coming from the embedded world, where even uclibc is not always available, and code likeuint64_t myval = 0xdeadfacedeadbeef;\nprintf("%llx", myval);is printing you crap or not working at all -- i always use a tiny helper, that allows me to dump properly uint64_t hex:In windows environment, usein Linux, use