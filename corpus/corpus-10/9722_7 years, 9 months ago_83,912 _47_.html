$1 is the first argument.\n$@ is all of them.How can I find the last argument passed to a shell\nscript?This is a bit of a hack:This one is also pretty portable (again, should work with bash, ksh and sh) and it doesn\'t shift the arguments, which could be nice.It uses the fact that for implicitly loops over the arguments if you don\'t tell it what to loop over, and the fact that for loop variables aren\'t scoped: they keep the last value they were set to.This is Bash-only:The simplest answer for bash 3.0 or greater is That\'s it.Output is:The space is necessary so that it doesnt get interpreted as a default value.Use indexing combined with length of:Found this when looking to separate the last argument from all the previous one(s). \nWhilst some of the answers do get the last argument, they\'re not much help if you need all the other args as well. This works much better:This works in all POSIX-compatible shells:Source: http://www.faqs.org/faqs/unix-faq/faq/part2/section-12.htmlThe following will work for you. The @ is for array of arguments. : means at. $# is the length of the array of arguments. So the result is the last element:Example:If you are using Bash >= 3.0Here is mine solution:Code:This shifts the arguments by the number of arguments minus 1, and returns the first (and only) remaining argument, which will be the last one.I only tested in bash, but it should work in sh and ksh as well.If you want to do it in a non-destructive way, one way is to pass all the arguments to a function and return the last one:If you don\'t actually care about keeping the other arguments, you don\'t need it in a function but I have a hard time thinking of a situation where you would never want to keep the other arguments unless they\'ve already been processed, in which case I\'d use the process/shift/process/shift/... method of sequentially processing them.I\'m assuming here that you want to keep them because you haven\'t followed the sequential method. This method also handles the case where there\'s no arguments, returning "". You could easily adjust that behavior by inserting the commented-out else clause.For tcsh:I\'m quite sure this would be a portable solution, except for the assignment.After reading the answers above I wrote a Q&D shell script (should work on sh and bash) to run g++ on PGM.cpp to produce executable image PGM. It assumes that the last argument on the command line is the file name (.cpp is optional) and all other arguments are options.Now I just need to add some text because my answer was too short to post. I need to add more text to edit.I found @AgileZebra\'s answer (plus @starfry\'s comment) the most useful, but it sets heads to a scalar. An array is probably more useful:A solution using eval:The following will set LAST to last argument without changing current environment:If other arguments are no longer needed and can be shifted it can be simplified to:For portability reasons following:can be replaced with:Replacing also $() with backquotes we get:This is part of my copy function:To use in scripts, do this:Explanation (most nested first):Works with Bash as of mid 2015.Try the below script to find last argumentOutput:Thanks.There is a much more concise way to do this.  Arguments to a bash script can be brought into an array, which makes dealing with the elements much simpler.  The script below will always print the last argument passed to a script.Sample outputThis format can worked in Slackware and Cygwin. "${x[@]:(-1)}", if used with $@, "${@:(-1)}"It means is: ${@:(N)}, will return all element after N index.(include N),\n-1 is thelast.