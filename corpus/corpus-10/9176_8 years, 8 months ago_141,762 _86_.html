A query runs fast:subtree cost: 0.502But putting the same SQL in a stored procedure runs slow, and with a totally different execution planSubtree cost: 19.2I\'ve runAnd it still runs the same (badly), and I\'ve also changed the stored \nprocedure toAnd back again, trying to really trick it into recompiling.I\'ve dropped and recreated the stored procedure in order to get it to generate a new plan.I\'ve tried forcing recompiles, and prevent parameter sniffing, by using a decoy variable:I\'ve also tried defining the stored procedure WITH RECOMPILE:So that it\'s plan is never cached, and I\'ve tried forcing a recompile at execute:Which didn\'t help.I\'ve tried converting the procedure to dynamic SQL:Which didn\'t help.The entity "Report_Opener" is a view, which is not indexed. The view only references underlying tables. No table contains computed columns, indexed or otherwise.For the hell of it I tried creating the view with That didn\'t fix it.How is it thatI tried moving the definition of the view directly into the stored procedure (violating 3 business rules, and breaking an important encapsulation), and that makes it only about 6x slower.Why is the stored procedure version so slow? What can possibly account for SQL Server running ad-hoc SQL faster than a different kind of ad-hoc SQL? I\'d really rather notchange the code at allBut what can account for SQL Server being unable to run as fast as SQL Sever running a query, if not parameter sniffing.My next attempt will be to have StoredProcedureA call StoredProcedureB call StoredProcedureC call StoredProcedureD to query the view.And failing that, have the stored procedure call a stored procedure, call a UDF, call a UDF, call a stored procedure, call a UDF to query the view.To sum up, the following run fast from QA, but slow when put into a stored procedure:The original:sp_executesql:EXEC(@sql):Execution PlansThe good plan:The bad planThe bad-one is eager spooling 6 million rows; the other one isn\'t.Note: This isn\'t a question about tuning a query. I have a query that runs lightning fast. I just want SQL Server to run fast from a stored procedure.I had the same problem as the original poster but the quoted answer did not solve the problem for me. The query still ran really slow from a stored procedure.  I found another answer here "Parameter Sniffing", Thanks Omnibuzz. Boils down to using "local Variables" in your stored procedure queries, but read the original for more understanding, it\'s a great write up. e.g.Slow way:Fast way:Hope this helps somebody else, doing this reduced my execution time from 5+ minutes to about 6-7 seconds.I found the problem, here\'s the script of the slow and fast versions of the stored procedure:dbo.ViewOpener__RenamedForCruachan__Slow.PRCdbo.ViewOpener__RenamedForCruachan__Fast.PRCIf you didn\'t spot the difference, I don\'t blame you. The difference is not in the stored procedure at all. The difference that turns a fast 0.5 cost query into one that does an eager spool of 6 million rows:Slow: SET ANSI_NULLS OFFFast: SET ANSI_NULLS ONThis answer also could be made to make sense, since the view does have a join clause that says:So there is some NULLs involved.The explanation is further proved by returning to Query Analizer, and running..And the query is slow.So the problem isn\'t because the query is being run from a stored procedure. The problem is that Enterprise Manager\'s connection default option is ANSI_NULLS off, rather than ANSI_NULLS on, which is QA\'s default.Microsoft acknowledges this fact in KB296769 (BUG: Cannot use SQL Enterprise Manager to create stored procedures containing linked server objects). The workaround is include the ANSI_NULLS option in the stored procedure dialog:Do this for your database. I have the same issue - it works fine in one database but when I copy this database to another using SSIS Import (not the usual restore), this issue happens to most of my stored procedures. So after googling some more, I found the blog of Pinal Dave (which btw, I encountered most of his post and did help me a lot so thanks Pinal Dave).I execute the below query on my database and it corrected my issue:Hope this helps. Just passing the help from others that helped me.This time you found your problem. If next time you are less lucky and cannot figure it out, you can use plan freezing and stop worrying about wrong execution plan.I was experiencing this problem. My query looked something like:My stored procedure was defined like:I changed the datatype to datetime and voila! Went from 30 minutes to 1 minute!Have you tried rebuilding the statistics and/or the indexes on the Report_Opener table. All the recomplies of the SP won\'t be worth anything if the stats still show data from when the database was first inauguarated.The initial query itself works quickly because the optimiser can see that the parameter will never be null.  In the case of the SP the optimiser cannot be sure that the parameter will never be null.Though I\'m usually against it (though in this case it seems that you have a genuine reason), have you tried providing any query hints on the SP version of the query? If SQL Server is preparing a different execution plan in those two instances, can you use a hint to tell it what index to use, so that the plan matches the first one?For some examples, you can go here.EDIT: If you can post your query plan here, perhaps we can identify some difference between the plans that\'s telling.SECOND: Updated the link to be SQL-2000 specific. You\'ll have to scroll down a ways, but there\'s a second titled "Table Hints" that\'s what you\'re looking for.THIRD: The "Bad" query seems to be ignoring the [IX_Openers_SessionGUID] on the "Openers" table - any chance adding an INDEX hint to force it to use that index will change things? This is probably unlikely, but given that your observed behaviour is unusual it needs to be checked and no-one else has mentioned it.Are you absolutely sure that all objects are owned by dbo and you don\'t have a rogue copies owned by yourself or a different user present as well?Just occasionally when I\'ve seen odd behaviour it\'s because there was actually two copies of an object and which one you get depends on what is specified and who you are logged on as.  For example it is perfectly possible to have two copies of a view or procedure with the same name but owned by different owners - a situation that can arise where you are not logged onto the database as a dbo and forget to specify dbo as object owner when you create the object.  In note that in the text you are running some things without specifying owner, egif for example there where two copies of viewOpener present owned by dbo and [some other user] then which one you actually recompile if you don\'t specify is dependent upon circumstances.  Ditto with the Report_Opener view - if there where two copies (and they could differ in specification or execution plan) then what is used depends upon circumstances - and as you do not specify owner it is perfectly possible that your adhoc query might use one and the compiled procedure might use use the other.As I say, it\'s probably unlikely but it is possible and should be checked because your issues could be that you\'re simply looking for the bug in the wrong place.This may sound silly and seems obvious from the name SessionGUID, but is the column a uniqueidentifier on Report_Opener? If not, you may want to try casting it to the correct type and give it a shot or declare your variable to the correct type.The plan created as part of the sproc may work unintuitively and do an internal cast on a large table.I was facing the same issue & this post was very helpful to me but none of the posted answers solved my specific issue. I wanted to post the solution that worked for me in hopes that it can help someone else.https://stackoverflow.com/a/24016676/814299At the end of your query, add OPTION (OPTIMIZE FOR (@now UNKNOWN))I\'ve got another idea. What if you create this table-based function:And then selected from it using the following statement (even putting this in your SP):It looks like what\'s happening (which everybody has already commented on) is that SQL Server just makes an assumption somewhere that\'s wrong, and maybe this will force it to correct the assumption. I hate to add the extra step, but I\'m not sure what else might be causing it.I had the same problem this morning, was very odd, a classic asp page that runs a Stored Proc was taking 1min+. The SQL the asp page was running ran in 2 seconds in MSSMS... Before spending ages investigating the execution plans I thought I would just make a minor change to a SP via ALTER PROCEDURE (inserted a comment line). After running the ALTER statement, the SP executed instantly in both IIS and MSSMS. I am guessing a standard recompile of the SP would have done the trick: (handy info about recompiling here by the way :)http://www.devx.com/tips/Tip/13386Rebuilding the indexes on the concerned tables helped me through this problem-- Here is the solution:-- That\'s it