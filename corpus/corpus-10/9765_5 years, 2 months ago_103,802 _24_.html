I\'m using Mockito 1.9.0.  I want mock the behaviour for a single method of a class in a JUnit test, so I haveThe problem is, in the second line, myClassSpy.method1() is actually getting called, resulting in an exception.  The only reason I\'m using mocks is so that later, whenever myClassSpy.method1() is called, the real method won\'t be called and the myResults object will be returned.  MyClass is an interface and myInstance is an implementation of that, if that matters.What do I need to do to correct this spying behaviour?Let me quote the official documentation:Sometimes it\'s impossible to use when(Object) for stubbing spies. Example: In your case it goes something like:My case was different from the accepted answer. I was trying to mock a package-private method for an instance that did not live in that packageand the test classesThe compilation is correct, but when it tries to setup the test, it invokes the real method instead.Declaring the method protected or public fixes the issue, tho it\'s not a clean solution.The answer by Tomasz Nurkiewicz appears not to tell the whole story!NB Mockito version: 1.10.19.I am very much a Mockito newb, so can\'t explain the following behaviour: if there\'s an expert out there who can improve this answer, please feel free.The method in question here, getContentStringValue, is NOT final and NOT static.This line does call the original method getContentStringValue:This line does not call the original method getContentStringValue:For reasons which I can\'t answer, using isA() causes the intended (?) "do not call method" behaviour of doReturn to fail.Let\'s look at the method signatures involved here: they are both static methods of Matchers. Both are said by the Javadoc to return null, which is a little difficult to get your head around in itself. Presumably the Class object passed as the parameter is examined but the result either never calculated or discarded. Given that null can stand for any class and that you are hoping for the mocked method not to be called, couldn\'t the signatures of isA( ... ) and any( ... ) just return null rather than a generic parameter* <T>?Anyway:The API documentation does not give any clue about this.  It also seems to say the need for such "do not call method" behaviour is "very rare".  Personally I use this technique all the time: typically I find that mocking involves a few lines which "set the scene" ... followed by calling a method which then "plays out" the scene in the mock context which you have staged... and while you are setting up the scenery and the props the last thing you want is for the actors to enter stage left and start acting their hearts out...But this is way beyond my pay grade... I invite explanations from any passing Mockito high priests...* is "generic parameter" the right term?In my case, using Mockito 2.0, I had to change all the any() parameters to nullable() in order to stub the real call.