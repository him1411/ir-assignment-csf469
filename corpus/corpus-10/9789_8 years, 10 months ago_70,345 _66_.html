I\'m developing a multilanguage software. As far as the application code goes, localizability is not an issue. We can use language specific resources and have all kinds of tools that work well with them.But what is the best approach in defining a multilanguage database schema? Let\'s say we have a lot of tables (100 or more), and each table can have multiple columns that can be localized (most of nvarchar columns should be localizable). For instance one of the tables might hold product information:I can think of three approaches to support multilingual text in NAME and DESCRIPTION columns:Separate column for each languageWhen we add a new language to the system, we must create additional columns to store the translated text, like this:Translation table with columns for each languageInstead of storing translated text, only a foreign key to the translations table is stored. The translations table contains a column for each language.Translation tables with rows for each languageInstead of storing translated text, only a foreign key to the translations table is stored. The translations table contains only a key, and a separate table contains a row for each translation to a language.There are pros and cons to each solution, and I would like to know what are your experiences with these approaches, what do you recommend and how would you go about designing a multilanguage database schema.What do you think about having a related translation table for each translatable table?CREATE TABLE T_PRODUCT (pr_id int, PRICE NUMBER(18, 2))CREATE TABLE T_PRODUCT_tr (pr_id INT FK, languagecode varchar, pr_name text, pr_descr text)This way if you have multiple translatable column it would only require a single join to get it + since you are not autogenerating a translationid it may be easier to import items together with their related translations.The negative side of this is that if you have a complex language fallback mechanism you may need to implement that for each translation table - if you are relying on some stored procedure to do that. If you do that from the app this will probably not be a problem.Let me know what you think - I am also about to make a decision on this for our next application.\nSo far we have used your 3rd type.The third option is the best, for a few reasons:-AdamThis is an interesting issue, so let\'s necromance. Let\'s start by the problems of method 1:\nProblem:  You\'re denormalizing to save speed.\nIn SQL (except PostGreSQL with hstore), you can\'t pass a parameter language, and say: So you have to do this:Which means you have to alter ALL your queries if you add a new language.\nThis naturally leads to using "dynamic SQL", so you don\'t have to alter all your queries.This usually results in something like this (and it can\'t be used in views or table-valued functions by the way, which really is a problem if you actually need to filter the reporting date)The problem with this is \na) Date-formatting is very language-specific, so you get a problem there, if you don\'t input in ISO format (which the average garden-variety programmer usually doesn\'t do, and in case of a report the user sure as hell won\'t do for you, even if explicitly instructed to do so). \nand \nb) most significantly, you loose any kind of syntax checking. If <insert name of your "favourite" person here> alters the schema because suddenly the requirements for wing change, and a a new table is created, the old one left but the reference field renamed, you don\'t get any kind of warning. A report even works when you run it without selecting the wing parameter (==> guid.empty). But suddenly, when a actual user actually selects a wing ==> boom. This method completely breakes any kind of testing. Method 2:\nIn a nutshell: "Great" idea (warning - sarcasm), let\'s combine the disadvantages of method 3 (slow speed when many entries) with the rather horrible disadvantages of method 1.\n\nThe only advantage of this method is that you keep all translation in one table, and therefore make maintenance simple. However, the same thing can be achieved with method 1 and a dynamic SQL stored procedure, and a (possibly temporary) table containing the translations, and the name of the target table (and is quite simple assuming you named  all your text-fields the same).Method 3:\nOne table for all translations:\nDisadvantage: \nYou have to store n Foreign Keys in the products table for n fields you want to translate. \nTherefore, you have to do n joins for n fields.\nWhen the translation table is global, it has many entries, and joins become slow. \nAlso, you always have to join the T_TRANSLATION  table n times for n fields. \nThis is quite an overhead. \nNow, what do you do when you must accommodate custom translations per customer ? \nYou\'ll have to add another 2x n joins onto an additional table. \nIf you have to join , say 10 tables, with 2x2xn = 4n additional joins, what a mess ! \nAlso, this design makes it possible to use the same translation with 2 tables. \nIf I change the item name in one table, do I really want to change an entry in another table as well EVERY SINGLE TIME ?Plus you can\'t delete and re-insert the table anymore, because there are now foreign keys IN THE PRODUCT TABLE(s)... you can of course omit setting the FKs, and then <insert name of your "favourite" person here> can delete the table, and re-insert all entries with newid() [or by specifying the id in the insert, but having identity-insert OFF], and that would (and will) lead to data-garbage (and null-reference exceptions) really soon. Then you can get the value by XPath-Query in SQL, where you can put the string-variable inAnd you can update the value like this:Where you can replace /lang/de/... with \'.../\' + @in_language + \'/...\'Kind of like the PostGre hstore, except that due to the overhead of parsing XML (instead of reading an entry from an associative array in PG hstore) it becomes far too slow plus the xml encoding makes it too painful to be useful.Let\'s make an example to see this WORKS: First, create the tables:Then fill in the dataAnd then query the data:If you\'re lazy, then you can also use the ISO-TwoLetterName (\'DE\', \'EN\', etc.) as primary-key of the language table, then you don\'t have to lookup the language id. But if you do so, you maybe want to use the IETF-language tag instead, which is better, because you get de-CH and de-DE, which is really not the same ortography-wise (double s instead of \xc3\x9f everywhere), although it\'s the same base-language. That just as a tiny little detail that may be important to you, especially considering that en-US and en-GB/en-CA/en-AU or fr-FR/fr-CA has similar issues.  Quote: we don\'t need it, we only do our software in English. Answer: Yes - but which one ?? Anyway, if you use an integer ID, you\'re flexible, and can change your method at any later time. \nAnd you should use that integer, because there\'s nothing more annoying, destructive and troublesome than a botched Db design.See also RFC 5646, ISO 639-2,And, if you\'re still saying "we" only make our application for "only one culture" (like en-US usually)- therefore I don\'t need that extra integer, this would be a good time and place to mention the IANA language tags, wouldn\'t it ? \nBecause they go like this:and(there was an orthography reform in 1996...)\nTry finding a word in a dictionary if it is misspelled; this becomes very important in applications dealing with legal and public service portals.\nMore importantly, there are regions that are changing from cyrillic to latin alphabets, which may just be more troublesome than the superficial nuisance of some obscure orthography reform, which is why this might be an important consideration too, depending on which country you live in. One way or the other, it\'s better to have that integer in there, just in case...Edit:\nAnd by adding ON DELETE CASCADE  afteryou can simply say: DELETE FROM T_Products, and get no foreign key violation.As for collation, I\'d do it like this:A) Have your own DAL\nB) Save the desired collation name in the language table You might want to put the collations in their own table, e.g.:C) Have the collation name available in your auth.user.language informationD) Write your SQL like this:E) Then, you can do this in your DAL:Which will then give you this perfectly composed SQL-Query I usually would go for this approach (not actual sql), this corresponds with your last option.Because having all translatable texts in one place makes maintenance so much easier. Sometimes translations are outsourced to translation bureaus, this way you can send them just one big export file, and import it back just as easily.Take a look for this example:I think there\'s no need to explain, the structure describes itself.I was looking for some tips for localization and found this topic.\nI was wondering why this is used:So you get something like user39603 suggests:Can\'t you just leave the table Translation out so you get this:Before going to technical details and solutions, you should stop for a minute and ask a few questions about the requirements. The answers can have a huge impact on the technical solution. Examples of such questions would be:\n  - Will all languages be used all the time?\n  - Who and when will fill the columns with the different language versions?\n  - What happens when a user will need a certain language of a text and there is none in the system?\n  - Only the texts are to be localized or there are also other items (for example PRICE can be stored in $ and â‚¬ because they might be different)I agree with randomizer.  I don\'t see why you need a table "translation".I think, this is enough:Would the below approach be viable? Say you have tables where more than 1 column needs translating. So for product you could have both product name & product description that need translating. Could you do the following:"Which one is best" is based on the project situation. The first one is easy to select and maintain, and also the performance is best since it don\'t need to join tables when select entity. If you confirmed that your poject is just only support 2 or 3 languages, and it will not increase, you can use it.The second one is okey but is hard to understand and maintain. And the performance is worse than first one.The last one is good at scalability but bad at performance. The T_TRANSLATION_ENTRY table will become larger and larger, it\'s terrible when you want to retrieve a list of entities from some tables.