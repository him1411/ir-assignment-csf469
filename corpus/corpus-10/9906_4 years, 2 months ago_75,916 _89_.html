This question already has an answer here:Suppose, I have this interface,Person.Contact.Address.City != null (This works to check if City is null or not.)However, this check fails if Address or Contact or Person itself is null.Currently, one solution I could think of was this:Is there a cleaner way of doing this?I really don\'t like the null check being done as (something == null). Instead, is there another nice way to do something like the something.IsNull() method?In a generic way, you may use an expression tree and check with an extension method:Full code:Your code may have bigger problems than needing to check for null references. As it stands, you are probably violating the Law of Demeter.The Law of Demeter is one of those heuristics, like Don\'t Repeat Yourself, that helps you write easily maintainable code. It tells programmers not to access anything too far away from the immediate scope. For example, suppose I have this code:The DoAnAction method violates the Law of Demeter. In one function, it accesses a BusinessCalcualtor, a BusinessData, and a decimal. This means that if any of the following changes are made, the line will have to be refactored:Considering the situation at had, these changes are rather likely to happen. If code like this is written throughout the codebase, making these changes could become very expensive. Besides that, it means that your BusinessController is coupled to both the BusinessCalculator and the BusinessData types.One way to avoid this situation is rewritting the code like this:Now, if you make either of the above changes, you only have to refactor one more piece of code, the BusinessCalculator.CalculateCents() method. You\'ve also eliminated BusinessController\'s dependency on BusinessData.Your code suffers from a similar issue:If any of the following changes are made, you will need to refactor the main method I wrote or the null check you wrote:I think you should consider a deeper refactoring of your code than simply rewriting a null check.That said, I think that there are times where following the Law of Demeter is inappropriate. (It is, after all, a heuristic, not a hard-and-fast rule, even though it\'s called a "law.")In particular, I think that if:ignoring the Law of Demeter is acceptable when dealing specifically with those classes. This is because they represent the data your application works with, so reaching from one data object into another is a way of exploring the information in your program. In my example above, the coupling caused by violating the Law of Demeter was much more severe: I was reaching all the way from a controller near the top of my stack through a business logic calculator in the middle of the stack into a data class likely in the persistence layer.I bring this potential exception to the Law of Demeter up because with names like Person, Contact, and Address, your classes look like they might be data-layer POCOs. If that\'s the case, and you are extremely confident that you will never need to refactor them in the future, you might be able to get away with ignoring the Law of Demeter in your specific situation.in your case you could create a property for personbut you still have to check if person is nullto your other question, for strings you can also check if null or empty this way:A totally different option (which I think is underused) is the null object pattern. It\'s hard to tell whether it makes sense in your particular situation, but it might be worth a try. In short, you will have a NullContact implementation, a NullAddress implementation and so on that you use instead of null. That way, you can get rid of most of the null checks, of course at the expense at some thought you have to put into the design of these implementations.As Adam pointed out in his comment, this allows you to writein cases where it is really necessary. Of course, this only makes sense if city really is a non-trivial object...Alternatively, the null object can be implemented as a singleton (e.g., look here for some practical instructions concerning the usage of the null object pattern and here for instructions concerning singletons in C#) which allows you to use classical comparison.Personally, I prefer this approach because I think it is easier to read for people not familiar with the pattern.Update 28/04/2014: Null propagation is planned for C# vNextThere are bigger problems than propagating null checks. Aim for readable code that can be understood by another developer, and although it\'s wordy - your example is fine.If it is a check that is done frequently, consider encapsulating it inside the Person class as a property or method call.That said, gratuitous Func and generics!I would never do this, but here is another alternative:Called:The second question,I really don\'t like the null check being done as (something == null). Instead, is there another nice way to do something like the something.IsNull() method?could be solved using an extension method:If for some reason you don\'t mind going with one of the more \'over the top\' solutions, you might want to check out the solution described in my blog post. It uses the expression tree to find out whether the value is null before evaluating the expression. But to keep performance acceptable, it creates and caches IL code.The solution allows you do write this:You can write:and then:Sometimes this makes sense. But personally I would avoid such things... because this is is not clear why you can call a method of the object that is actually null.Do it in a separate method like:Where your IsNull method isDo you need C#, or do you only want .NET? If you can mix another .NET language, have a look at Oxygene. It\'s an amazing, very modern OO language that targets .NET (and also Java and Cocoa as well. Yep. All natively, it really is quite an amazing toolchain.)Oxygene has a colon operator which does exactly what you ask. To quote from their miscellaneous language features page:In Oxygene, like in many of the languages it\n  was influenced by, the "." operator is used to call members on a class\n  or object, such asThis "dereferences" the object contained in\n  "y", calls (in this case) the property getter and returns its value.\n  If "y" happens to be unassigned (i.e. "nil"), an exception is thrown.The ":" operator works in much the same way, but instead of throwing\n  an exception on an unassigned object, the result will simply be nil.\n  For developers coming from Objective-C, this will be familiar, as that\n  is how Objective-C method calls using the [] syntax work, too.... (snip)Where ":" really shines is when accessing properties in a chain, where\n  any element might be nil. For example, the following code:will run without error, and\n  return nil if any of the objects in the chain are nil \xe2\x80\x94 the form, the\n  button or its caption.Don\'t actually do this. Do the null checks, and figure out what formatting you can best live with.I have an extension that could be useful for this; ValueOrDefault(). It accepts a lambda statement and evaluates it, returning either the evaluated value or a default value if any expected exceptions (NRE or IOE) are thrown.The overload not taking a specific default value will return null for any reference type. This should work in your scenario:Such a reference chain may occurre for example if you use an ORM tool, and want to keep your classes as pure as possible. In this scenario I think it cannot be avoided nicely.I have the following extension method "family", which checks if the object on which it\'s called is null, and if not, returns one of it\'s requested properties, or executes some methods with it. This works of course only for reference types, that\'s why I have the corresponding generic constraint.These methods add almost no overhead compared to the manual solution (no reflection, no expression trees), and you can achieve a nicer syntax with them (IMO).Or with methods:However, one could definetely argue about the length of code didn\'t change too much.In my opinion, the equality operator is not a safer and better way for reference equality.It\'s always better to use ReferenceEquals(obj, null). This will always work. On the other hand, the equality operator (==) could be overloaded and might be checking if the values are equal instead of the references, so I will say ReferenceEquals() is a safer and better way.Reference: MSDN article Object.ReferenceEquals Method.But also here are my thoughts for null values Generally, returning null values is the best idea if anyone is trying to indicate that there is no data.If the object is not null, but empty, it implies that data has been returned, whereas returning null clearly indicates that nothing has been returned.Also IMO, if you will return null, it will result in a null exception if you attempt to access members in the object, which can be useful for highlighting buggy code.In C#, there are two different kinds of equality:When a type is immutable, overloading operator == to compare value equality instead of reference equality can be useful.Overriding operator == in non-immutable types is not recommended.Refer to the MSDN article Guidelines for Overloading Equals() and Operator == (C# Programming Guide) for more details.As much as I love C#, this is one thing that\'s kind of likable about C++ when working directly with object instances; some declarations simply cannot be null, so there\'s no need to check for null.The best way you can get a slice of this pie in C# (which might be a bit too much redesigning on your part - in which case, take your pick of the other answers) is with struct\'s. While you could find yourself in a situation where a struct has uninstantiated "default" values (ie, 0, 0.0, null string) there\'s never a need to check "if (myStruct == null)".I wouldn\'t switch over to them without understanding their use, of course. They tend to be used for value types, and not really for large blocks of data - anytime you assign a struct from one variable to another, you tend to be actually copying the data across, essentially creating a copy of each of the original\'s values (you can avoid this with the ref keyword - again, read up on it rather than just using it). Still, it may fit for things like StreetAddress - I certainly wouldn\'t lazily use it on anything I didn\'t want to null-check.Depending on what the purpose of using the "city" variable is, a cleaner way could be to separate the null checks into different classes. That way you also wouldn\'t be violating the Law of Demeter. So instead of: You\'d have:Again, it depends on the purpose of the program.In what circumstances can those things be null? If nulls would indicate a bug in the code then you could use code contracts. They will pick it up if you get nulls during testing, then will go away in the production version. Something like this:Of course, if the possible nulls are coming from somewhere else then you\'ll need to have already conditioned the data. And if any of the nulls are valid then you shouldn\'t make non-null a part of the contract, you need to test for them and handle them appropriately.One way to remove null checks in methods is to encapsulate their functionality elsewhere. One way to do this is through getters and setters. For instance, instead of doing this:Do this:Then, whenever you call "person.contact", the code in the "get" method will run, thus initializing the value if it is null.You could apply this exact same methodology to all of the properties that could be null across all of your types. The benefits to this approach are that it 1) prevents you from having to do null checks in-line and it 2) makes your code more readable and less prone to copy-paste errors. It should be noted, however, that if you find yourself in a situation where you need to perform some action if one of the properties is null (i.e. does a Person with a null Contact actually mean something in your domain?), then this approach will be a hindrance rather than a help. However, if the properties in question should never be null, then this approach will give you a very clean way of representing that fact.--jtlovetteiiiYou could use reflection, to avoid forcing implementation of interfaces and extra code in every class. Simply a Helper class with static method(s). This might not be the most efficient way, be gentle with me, I\'m a virgin (read, noob).. Offcourse if you have a typo in the propnames, the result will be wrong (most likely)..