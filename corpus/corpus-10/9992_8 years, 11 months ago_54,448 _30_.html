What are differences between declaring a method in a base type "virtual" and then overriding it in a child type using the "override" keyword as opposed to simply using the "new" keyword when declaring the matching method in the child type? The "new" keyword doesn\'t override, it signifies a new method that has nothing to do with the base class method. This prints false, if you used override it would have printed true.(Base code taken from Joseph Daigle)So, if you are doing real polymorphism you SHOULD ALWAYS OVERRIDE. The only place where you need to use "new" is when the method is not related in any way to the base class version.I always find things like this more easily understood with pictures:Again, taking joseph daigle\'s code,If you then call the code like this:NOTE: The important thing is that our object is actually a Bar, but we are storing it in a variable of type Foo (this is similar to casting it)Then the result will be as follows, depending on whether you used virtual/override or new when declaring your classes.Here\'s some code to understand the difference in the behavior of virtual and non-virtual methods:The new keyword actually creates a completely new member that only exists on that specific type.For instanceThe method exists on both types. When you use reflection and get the members of type Bar, you will actually find 2 methods called DoSomething() that look exactly the same. By using new you effectively hide the implementation in the base class, so that when classes derive from Bar (in my example) the method call to base.DoSomething() goes to Bar and not Foo.virtual / override tells the compiler that the two methods are related and that in some circumstances when you would think you are calling the first (virtual) method it\'s actually correct to call the second (overridden) method instead. This is the foundation of polymorphism.Will call the SubClass\'s overriden VirtualFoo() method.new tells the compiler that you are adding a method to a derived class with the same name as a method in the base class, but they have no relationship to each other.Will call the BaseClass\'s NewBar() method, whereas:Will call the SubClass\'s NewBar() method.Beyond just the technical details, I think using virtual/override communicates a lot of semantic information on the design.  When you declare a method virtual, you indicate that you expect that implementing classes may want to provide their own, non-default implementations.  Omitting this in a base class, likewise, declares the expectation that the default method ought to suffice for all implementing classes.  Similarly, one can use abstract declarations to force implementing classes to provide their own implementation.  Again, I think this communicates a lot about how the programmer expects the code to be used.  If I were writing both the base and implementing classes and found myself using new I\'d seriously rethink the decision not to make the method virtual in the parent and declare my intent specifically.The difference between the override keyword and new keyword is that the former does method overriding and the later does method hiding.Check out the folllowing links for more information...MSDN    and  OtherMy version of explanation comes from using properties to help understand the differences.override is simple enough, right ? The underlying type overrides the parent\'s.new is perhaps the misleading (for me it was). With properties it\'s easier to understand:Using a debugger you can notice that Foo foo has 2 GetSomething properties, as it actually has 2 versions of the property, Foo\'s and Bar\'s, and to know which one to use, c# "picks" the property for the current type. If you wanted to use the Bar\'s version, you would have used override or use Foo foo instead.Bar bar has only 1, as it wants completely new behavior for GetSomething.