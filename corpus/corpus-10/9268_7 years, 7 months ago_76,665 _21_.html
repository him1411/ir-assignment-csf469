Is there a way for gcc/g++ to dump its preprocessor defines from the command line?\nI mean things like __GNUC__, __STDC__, and so on. Yes, use -E -dM options instead of -c.\nExample (outputs them to stdout):From the gcc manual:Instead of the normal output, generate\n  a list of `#define\' directives for all\n  the macros defined during the\n  execution of the preprocessor,\n  including predefined macros. This\n  gives you a way of finding out what is\n  predefined in your version of the\n  preprocessor. Assuming you have no\n  file foo.h, the commandwill show all the predefined macros.If you use -dM without the -E option,\n  -dM is interpreted as a synonym for -fdump-rtl-mach.I usually do it this way:Note that some preprocessor defines are dependent on command line options - you can test these by adding the relevant options to the above command line. For example, to see which SSE3/SSE4 options are enabled by default:and then compare this when -msse4 is specified:Similarly you can see which options differ between two different sets of command line options, e.g. compare preprocessor defines for optimisation levels -O0 (none) and -O3 (full):Late answer - I found the other answers useful - and wanted to add a bit extra.How do I dump preprocessor macros coming from a particular header file?In particular, I wanted to see what SOMAXCONN was defined to on my system.  I know I could just open up the standard header file, but sometimes I have to search around a bit to find the header file locations.  Instead I can just use this one-liner:The simple approach (gcc -dM -E - < /dev/null) works fine for gcc but fails for g++. Recently I required a test for a C++11/C++14 feature. Recommendations for their corresponding macro names are published at https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations. But:always fails, because it silently invokes the C-drivers (as if invoked by gcc). You can see this by comparing its output against that of gcc or by adding a g++-specific command line option like (-std=c++11) which emits the error message cc1: warning: command line option \xe2\x80\x98-std=c++11\xe2\x80\x99 is valid for C++/ObjC++ but not for C.Because (the non C++) gcc will never support "Templates Aliases" (see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf) you must add the -x c++ option to force the invocation of the C++ compiler (Credits for using the -x c++ options instead of an empty dummy file go to yuyichao, see below):There will be no output because g++ (revision 4.9.1, defaults to -std=gnu++98) does not enable C++11-features by default. To do so, usewhich finally yieldsnoting that g++ 4.9.1 does support "Templates Aliases" when invoked with -std=c++11.More portable approach that works equally well on Windows (where there is no /dev/null) or Linux:While working in a big project which has complex build system and where it is hard to get (or modify) the gcc/g++ command directly there is another way to see the result of macro expansion.\nSimply redefine the macro, and you will get output similiar to following: