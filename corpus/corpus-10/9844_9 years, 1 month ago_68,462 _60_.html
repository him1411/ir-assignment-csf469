Interfaces allow you to create code which defines the methods of classes that implement it. You cannot however add any code to those methods. Abstract classes allow you to do the same thing, along with adding code to the method. Now if you can achieve the same goal with abstract classes, why do we even need the concept of interfaces? I\'ve been told that it has to do with OO theory from C++ to Java, which is what PHP\'s OO stuff is based on. Is the concept useful in Java but not in PHP? Is it just a way to keep from having placeholders littered in the abstract class? Am I missing something?The entire point of interfaces is to give you the flexibility to have your class be forced to implement multiple interfaces, but still not allow multiple inheritance.  The issues with inheriting from multiple classes are many and varied and the wikipedia page on it sums them up pretty well.Interfaces are a compromise.  Most of the problems with multiple inheritance don\'t apply to abstract base classes, so most modern languages these days disable multiple inheritance yet call abstract base classes interfaces and allows a class to "implement" as many of those as they want.The concept is useful all around in object oriented programming. To me I think of an interface as a contract. So long my class and your class agree on this method signature contract we can "interface". As for abstract classes those I see as more of base classes that stub out some methods and I need to fill in the details.Why would you need an interface, if there are already abstract classes?\nTo prevent multiple inheritance (can cause multiple known problems).One of such problems:The "diamond problem" (sometimes referred to as the "deadly diamond of\n  death") is an ambiguity that arises when two classes B and C inherit\n  from A, and class D inherits from both B and C. If there is a method\n  in A that B and/or C has overridden, and D does not override it, then\n  which version of the method does D inherit: that of B, or that of C?Source: https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problemWhy/When to use an interface?\nAn example... All cars in the world have the same interface (methods)... AccelerationPedalIsOnTheRight(), BrakePedalISOnTheLeft(). Imagine that each car brand would have these "methods" different from another brand. BMW would have The brakes on the right side and Honda would have brakes on the left side of the wheel. People would have to learn how these "methods" work every time they would buy a different brand of car. That\'s why it\'s a good idea to have the same interface in multiple "places".What does an interface do for you (why would someone even use one)?\nAn interface prevents you from making "mistakes" (it assures you that all classes which implement a specific interface, will all have the methods which are in the interface).This way, the Create() method will always be used the same way. It doesn\'t metter if we are using the MySqlPerson class or the MongoPerson class. The way how we are using a method stays the same (the interface stays the same).For example, it will be used like this (everywhere in our code):This way, something like this can\'t happen:It\'s much easier to remember one interface and use the same one everywhere, than multiple different ones.This way, the inside of the Create() method can be different for different classes, without affecting the "outside" code, which calls this method. All the  outside code has to know is that the method Create() has 1 parameter ($personObject), because that\'s how the outside code will use/call the method. The outside code doesn\'t care what\'s happening inside the method, it only has to know how to use/call it.You can do this without an interface as well, but if you use an interface, it\'s "safer" (because it prevents you to do mistakes). The interface assures you that the method Create() will have the same signature (same types and same number of parameters) in all classes that implement the interface. This way you can be sure that ANY class which implements the IPersonService interface, will have the method Create() (in this example) and will need only 1 parameter ($personObject) to get called/used.A class that implements an interface, must implement all methods, which the interface does/has.I hope that i didn\'t repeat myself too much.The difference between using an interface and an abstract class has more to do with code organization for me, than enforcement by the language itself. I use them a lot when preparing code for other developers to work with so that they stay within the intended design patterns. Interfaces are a kind of "design by contract" whereby your code is agreeing to respond to a prescribed set of API calls that may be coming from code you do not have aceess to.While inheritance from abstract class is a "is a" relation, that isn\'t always what you want, and implementing an interface is more of a "acts like a" relation. This difference can be quite significant in certain contexts.For example, let us say you have an abstract class Account from which many other classes extend (types of accounts and so forth). It has a particular set of methods that are only applicable to that type group. However, some of these account subclasses implement Versionable, or Listable, or Editable so that they can be thrown into controllers that expect to use those APIs. The controller does not care what type of object it isBy contrast, I can also create an object that does not extend from Account, say a User abstract class, and still implement Listable and Editable, but not Versionable, which doesn\'t make sense here.In this way, I am saying that FooUser subclass is NOT an account, but DOES act like an Editable object. Likewise BarAccount extends from Account, but is not a User subclass, but implements Editable, Listable and also Versionable.Adding all of these APIs for Editable, Listable and Versionable into the abstract classes itself would not only be cluttered and ugly, but would either duplicate the common interfaces in Account and User, or force my User object to implement Versionable, probably just to throw an exception.Interfaces are essentially a blueprint for what you can create. They define what methods a class must have, but you can create extra methods outside of those limitations.I\'m not sure what you mean by not being able to add code to methods - because you can. Are you applying the interface to an abstract class or the class that extends it? A method in the interface applied to the abstract class will need to be implemented in that abstract class. However apply that interface to the extending class and the method only needs implementing in the extending class. I could be wrong here - I don\'t use interfaces as often as I could/should.I\'ve always thought of interfaces as a pattern for external developers or an extra ruleset to ensure things are correct.You will use interfaces in PHP:class Car implements EngineInterface, BodyInterface, SteeringInterface {and other things I cannot think of right nowNumber 4 it\'s probably the most obvious use case that you cannot address with abstract classes.From Thinking in Java:An interface says, \xe2\x80\x9cThis is what all classes that implement this particular interface will look like.\xe2\x80\x9d Thus, any code that uses a particular interface knows what methods can be called for that interface, and that\xe2\x80\x99s all. So the interface is used to establish a \xe2\x80\x9cprotocol\xe2\x80\x9d between classes.Interfaces exist not as a base on which classes can extend but as a map of required functions.  The following is an example of using an interface where an abstract class does not fit:\nLets say I have a calendar application that allows users to import calendar data from external sources.  I would write classes to handle importing each type of data source (ical, rss, atom, json) Each of those classes would implement a common interface that would ensure they all have the common public methods that my application needs to get the data. Then when a user adds a new feed I can identify the type of feed it is and use the class developed for that type to import the data.   Each class written to import data for a specific feed would have completely different code, there may otherwise be very few similarities between the classes outside of the fact that they are required to implement the interface that allows my application to consume them. If I were to use an abstract class, I could very easily ignore the fact that I have not overridden the getEvents() method which would then break my application in this instance whereas using an interface would not let my app run if ANY of the methods defined in the interface do not exist in the class that implemented it. My app doesn\'t have to care what class it uses to get data from a feed, only that the methods it needs to get that data are present.To take this a step further, the interface proves to be extremely useful when I come back to my calendar app with the intent of adding another feed type. Using the ImportableFeed interface means I can continue adding more classes that import different feed types by simply adding new classes that implement this interface.  This allows me to add tons of functionality without having to add unnecessarily bulk to my core application since my core application only relies on there being the public methods available that the interface requires so as long as my new feed import classes implement the ImportableFeed interface then I know I can just drop it in place and keep moving.This is just a very simple start. I can then create another interface that all my calendar classes can be required to implement that offers more functionality specific to the feed type the class handles. Another good example would be a method to verify the feed type, etc.This goes beyond the question but since I used the example above:\nInterfaces come with their own set of issues if used in this manner.  I find myself needing to ensure the output that is returned from the methods implemented to match the interface and to achieve this I use an IDE that reads PHPDoc blocks and add the return type as a type hint in a PHPDoc block of the interface which will then translate to the concrete class that implements it.  My classes that consume the data output from the classes that implement this interface will then at the very least know it\'s expecting an array returned in this example:There isn\'t much room in which to compare abstract classes and interfaces.  Interfaces are simply maps that when implemented require the class to have a set of public interfaces.In my opinion, interfaces should be preferred over non-functional abstract classes. I wouldn\'t be surprised if there would be even a performance hit there, as there is only one object instantiated, instead of parsing two, combining them (although, I can\'t be sure, I\'m not familiar with the inner workings of OOP PHP).It is true that interfaces are less useful/meaningful than compared to, say, Java. On the other hand, PHP6 will introduce even more type hinting, including type hinting for return values. This should add some value to PHP interfaces.tl;dr: interfaces defines a list of methods that need to be followed (think API), while an abstract class gives some basic/common functionality, which the subclasses refine to specific needs.Interfaces aren\'t just for making sure developers implement certain methods.  The idea is that because these classes are guaranteed to have certain methods, you can use these methods even if you don\'t know the class\'s actual type.  Example:In many cases, it doesn\'t make sense to provide a base class, abstract or not, because the implementations vary wildly and don\'t share anything in common besides a few methods.Dynamically typed languages have the notion of "duck-typing" where you don\'t need interfaces; you are free to assume that the object has the method that you\'re calling on it.  This works around the problem in statically typed languages where your object has some method (in my example, read()), but doesn\'t implement the interface.I can\'t remember if PHP is different in this respect, but in Java, you can implement multiple Interfaces, but you can\'t inherit multiple abstract classes. I\'d assume PHP works the same way.In PHP you can apply multiple interfaces by seperating them with a comma (I think, I don\'t find that a clean soloution). As for multiple abstract classes you could have multiple abstracts extending each other (again, I\'m not totally sure about that but I think I\'ve seen that somewhere before). The only thing you can\'t extend is a final class.Interfaces will not give your code any performance boosts or anything like that, but they can go a long way toward making it maintainable. It is true that an abstract class (or even a non-abstract class) can be used to establish an interface to your code, but proper interfaces (the ones you define with the keyword and that only contain method signatures) are just plain easier to sort through and read.That being said, I tend to use discretion when deciding whether or not to use an interface over a class. Sometimes I want default method implementations, or variables that will be common to all subclasses.Of course, the point about multiple-interface implementation is a sound one, too. If you have a class that implements multiple interfaces, you can use an object of that class as different types in the same application.The fact that your question is about PHP, though, makes things a bit more interesting. Typing to interfaces is still not incredibly necessary in PHP, where you can pretty much feed anything to any method, regardless of its type. You can statically type method parameters, but some of that is broken (String, I believe, causes some hiccups). Couple this with the fact that you can\'t type most other references, and there isn\'t much value in trying to force static typing in PHP (at this point). And because of that, the value of interfaces in PHP, at this point is far less than it is in more strongly-typed languages. They have the benefit of readability, but little else. Multiple-implementation isn\'t even beneficial, because you still have to declare the methods and give them bodies within the implementor.Below are the points for PHP Interface Example code :