I used a variable with a lot of data in it, say String data.\nI wanted to use a small part of this string in the following way:After some hours of debugging (with a memory visualizer) I found out that the objects field smallpart remembered all the data from data, although it only contained the substring.When I changed the code into:..the problem was solved! Now my application uses very little memory now! How is that possible? Can anyone explain this? I think this.smallpart kept referencing towards data, but why? UPDATE:\nHow can I clear the big String then? Will data = new String(data.substring(0,100)) do the thing?Doing the following:creates a new (smaller) String object, and throws away the reference to the String created by substring(), thus enabling garbage collection of this. The important thing to realise is that substring() gives a window onto an existing String - or rather, the character array underlying the original String. Hence it will consume the same memory as the original String. This can be advantageous in some circumstances, but problematic if you want to get a substring and dispose of the original String (as you\'ve found out).Take a look at the substring() method in the JDK String source for more info.EDIT: To answer your supplementary question, constructing a new String from the substring will reduce your memory consumption, provided you bin any references to the original String.NOTE (Jan 2013). The above behaviour has changed in Java 7u6. The flyweight pattern is no longer used and substring() will work as you would expect.If you look at the source of substring(int, int), you\'ll see that it returns:where value is the original char[]. So you get a new String but with the same underlying char[].When you do, data.substring() + "", you get a new String with a new underlying char[].Actually, your use case is the only situation where you should use the String(String) constructor:When you use substring, it doesn\'t actually create a new string. It still refers to your original string, with an offset and size constraint.So, to allow your original string to be collected, you need to create a new string (using new String, or what you\'ve got).I think this.smallpart kept\n  referencing towards data, but why?Because Java strings consist of a char array, a start offset and a length (and a cached hashCode). Some String operations like substring() create a new String object that shares the original\'s char array and simply has different offset and/or length fields. This works because the char array of a String is never modified once it has been created.This can save memory when many substrings refer to the same basic string without replicating overlapping parts. As you have noticed, in some situations, it can keep data that\'s not needed anymore from being garbage collected.The "correct" way to fix this is the new String(String) constructor, i.e. BTW, the overall best solution would be to avoid having very large Strings in the first place, and processing any input in smaller chunks, aa few KB at a time.In Java strings are imutable objects and once a string is created, it remains on memory until it\'s cleaned by the garbage colector (and this cleaning is not something you can take for granted).When you call the substring method, Java does not create a trully new string, but just stores a range of characters inside the original string.So, when you created a new string with this code:you actually created a new string when you concatenated the result with the empty string.\nThat\'s why.As documented by jwz in 1997:If you have a huge string, pull out a substring() of it, hold on to the substring and allow the longer string to become garbage (in other words, the substring has a longer lifetime) the underlying bytes of the huge string never go away.Just to sum up, if you create lots of substrings from a small number of big strings, then useSince you only use the space to store the big strings, but if you are extracting a just handful of small strings, from losts of big strings, thenWill keep your memory use down, since the big strings can be reclaimed when no longer needed.That you call new String is a helpful reminder that you really are getting a new string, rather than a reference to the original one.Firstly, calling java.lang.String.substring creates new window on the original String with usage of  the offset and length instead of copying the significant part of underlying array.If we take a closer look at the substring method we will notice a string constructor call String(int, int, char[]) and passing it whole char[] that represents the string. That means the substring will occupy as much amount of memory as the original string.Ok, but why + "" results in demand for less memory than without it?? Doing a + on strings is implemented via StringBuilder.append method call. Look at the implementation of this method in AbstractStringBuilder class will tell us that it finally do arraycopy with the part we just really need (the substring).Any other workaround??Appending "" to a string will sometimes save memory. Let\'s say I have a huge string containing a whole book, one million characters. Then I create 20 strings containing the chapters of the book as substrings. Then I create 1000 strings containing all paragraphs. Then I create 10,000 strings containing all sentences. Then I create 100,000 strings containing all the words. I still only use 1,000,000 characters. If you add "" to each chapter, paragraph, sentence and word, you use 5,000,000 characters. Of course it\'s entirely different if you only extract one single word from the whole book, and the whole book could be garbage collected but isn\'t because that one word holds a reference to it. And it\'s again different if you have a one million character string and remove tabs and spaces at both ends, making say 10 calls to create a substring. The way Java works or worked avoids copying a million characters each time. There is compromise, and it\'s good if you know what the compromises are. 