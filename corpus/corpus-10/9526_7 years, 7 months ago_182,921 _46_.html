I am looking for a way to pass a method by reference. I understand that Java does not pass methods as parameters, however, I would like to get an alternative. I\'ve been told interfaces are the alternative to passing methods as parameters but I don\'t understand how an interface can act as a method by reference. If I understand correctly an interface is simply an abstract set of methods that are not defined. I don\'t want to send an interface that needs to be defined every time because several different methods could call the same method with the same parameters.What I would like to accomplish is something similar to this:invoked such as:Edit: as of Java 8, lambda expressions are a nice solution as other answers have pointed out. The answer below was written for Java 7 and earlier...Take a look at the command pattern.Edit: as Pete Kirkham points out, there\'s another way of doing this using a Visitor. The visitor approach is a little more involved - your nodes all need to be visitor-aware with an acceptVisitor() method - but if you need to traverse a more complex object graph then it\'s worth examining.In Java 8, you can now pass a method more easily using Lambda Expressions. First, some background. A functional interface is an interface that has one and only one abstract method, although it can contain any number of default methods (new in Java 8) and static methods. A lambda expression can quickly implement the abstract method, without all the unnecessary syntax needed if you don\'t use a lambda expression.Without lambda expressions:With lambda expressions:Here is an excerpt from the Java tutorial on Lambda Expressions:A lambda expression consists of the following:A comma-separated list of formal parameters enclosed in parentheses. The CheckPerson.test method contains one parameter, p,\n  which represents an instance of the Person class.Note: You\n  can omit the data type of the parameters in a lambda expression. In\n  addition, you can omit the parentheses if there is only one parameter.\n  For example, the following lambda expression is also valid:The arrow token, ->A body, which consists of a single expression or a statement block. This example uses the following expression:If you specify a single expression, then the Java runtime evaluates the expression and then returns its value. Alternatively,\n  you can use a return statement:A return statement is not an expression; in a lambda expression, you must enclose statements in braces ({}). However, you do not have\n  to enclose a void method invocation in braces. For example, the\n  following is a valid lambda expression:Note that a lambda expression looks a lot like a method declaration;\n  you can consider lambda expressions as anonymous methods\xe2\x80\x94methods\n  without a name.Here is how you can "pass a method" using a lambda expression:Use the java.lang.reflect.Method object and call invokeFirst define an Interface with the method you want to pass as a parameterImplement a class with the method// Invoke like thatThis allows you to pass cmd as parameter and invoke the method call defined in the interfaceWhile this is not yet valid for Java 7 and below, I believe that we should look to the future and at least recognize the changes to come in new versions such as Java 8. Namely, this new version brings lambdas and method references to Java (along with new APIs, which are another valid solution to this problem. While they still require an interface no new objects are created, and extra classfiles need not pollute output directories due to different handling by the JVM. Both flavors(lambda and method reference) require an interface available with a single method whose signature is used:Names of methods will not matter from here on. Where a lambda is accepted, a method reference is as well. For example, to use our signature here:This is just a simple interface invocation, up until the lambda1 gets passed:This will output:Method references are similar. Given:and main:the output would be real static method. Method references can be static, instance, non-static with arbitrary instances, and even constructors. For the constructor something akin to ClassName::new would be used.1 This is not considered a lambda by some, as it has side effects. It does illustrate, however, the use of one in a more straightforward-to-visualize fashion.Last time I checked, Java is not capable of natively doing what you want; you have to use \'work-arounds\' to get around such limitations. As far as I see it, interfaces ARE an alternative, but not a good alternative. Perhaps whoever told you that was meaning something like this:Which you\'d then invoke with:If you don\'t need these methods to return something, you could make them return Runnable objects.Then use it like:Use the Observer pattern (sometimes also called Listener pattern):new ComponentDelegate()... declares an anonymous type implementing the interface.Java do have a mechanism to pass name and call it. It is part of the reflection mechanism.\nYour function should take additional parameter of class Method.Here is a basic example:Output:I\'m not a java expert but I solve your problem like this:I define the parameter in my special InterfaceFinally, I implement getSearchText method while calling initialize method.