Is there any advantage for either approach?Example 1:Example 2:There is additionally the initialization block, which is as well put in the constructor(s) by the compiler:Check Sun\'s explanation and adviceFrom this tutorial: Field declarations, however, are not part of any method, so they cannot be executed as statements are. Instead, the Java compiler generates instance-field initialization code automatically and puts it in the constructor or constructors for the class. The initialization code is inserted into a constructor in the order it appears in the source code, which means that a field initializer can use the initial values of fields declared before it.Additionally, you might want to lazily initialize your field. In cases when initializing a field is an expensive operation, you may initialize it as soon as it is needed:And ultimately (as pointed out by Bill), for the sake of dependency management, it is better to avoid using the new operator anywhere within your class. Instead, using Dependency Injection is preferable - i.e. letting someone else (another class/framework) instantiate and inject the dependencies in your class.Another option would be to use Dependency Injection.This removes the responsibility of creating the B object from the constructor of A.  This will make your code more testable and easier to maintain in the long run.  The idea is to reduce the coupling between the two classes A and B.  A benefit that this gives you is that you can now pass any object that extends B (or implements B if it is an interface) to A\'s constructor and it will work. One disadvantage is that you give up encapsulation of the B object, so it is exposed to the caller of the A constructor. You\'ll have to consider if the benefits are worth this trade-off, but in many cases they are.my personal "rule" (hardly ever broken) is to:So I would have code like:This way I am always 100% certain where to look for variables declarations (at the start of a block), and their assignments (as soon as it makes sense after the declaration).  This winds up potentially being more efficient as well since you never initialize a variable with a value that is not used (for example declare and init vars and then throw an exception before half of those vars needed to have a value).  You also do not wind up doing pointless initialization (like int i = 0; and then later on, before "i" is used, do i = 5;.I value consistency very much, so following this "rule" is something I do all the time, and it makes it much easier to work with the code since you don\'t have to hunt around to find things.  Your mileage may vary.I got burned in an interesting way today:See the mistake? It turns out that the a = null initializer gets called after the superclass constructor is called. Since the superclass constructor calls init(), the initialization of a is followed by the a = null initialization.Example 2 is less flexible. If you add another constructor, you need to remember to instantiate the field in that constructor as well. Just instantiate the field directly, or introduce lazy loading somewhere in a getter.If instantiation requires more than just a simple new, use an initializer block. This will be run regardless of the constructor used. E.g.I take it is almost just a matter of taste, as long as initialization is simple and doesn\'t need any logic. The constructor approach is a bit more fragile if you don\'t use an initializer block, because if you later on add a second constructor and forget to initialize b there, you\'ll get a null b only when using that last constructor.See http://java.sun.com/docs/books/tutorial/java/javaOO/initial.html for more details about initialization in Java (and for explanations on initalizer blocks and other not well known initialization features).Using either dependency injection or lazy initialization is always preferable, as already explained thoroughly in other answers.When you don\'t want or can\'t use those patterns, and for primitive data types, there are three compelling reasons that I can think of why it\'s preferable to initialize the class attributes outside the constructor:I think Example 2 is preferable. I think the best practice is to declare outside the constructor and initialize in the constructor.Both of the methods are acceptable. Note that in the latter case b=new B() may not get initialized if there is another constructor present. Think of initializer code outside constructor as a common constructor and the code is executed. The second is an example of lazy initialization. First one is more simple initialization, they are essentially same.There is one more subtle reason to initialize outside the constructor that no one has mentioned before (very specific I must say).  If you are using UML tools to generate class diagrams from the code (reverse engineering), most of the tools I believe will note the initialization of Example 1 and will transfer it to a diagram (if you prefer it to show the initial values, like I do).  They will not take these initial values from Example 2.  Again, this is a very specific reason - if you are working with UML tools, but once I learned that, I am trying to take all my default values outside of constructor unless, as was mentioned before, there is an issue of possible exception throwing or complicated logic.The second option is preferable as allows to use different logic in ctors for class instantiation and use ctors chaining. E.g.So the second options is more flexible.