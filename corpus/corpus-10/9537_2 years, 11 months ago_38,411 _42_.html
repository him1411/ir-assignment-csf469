I\'m creating a react.js application with flux architecture and I am trying  figure out where and when a request for data from the server should be made. Is there a any example for this. (Not TODO app!)I\'m a big proponent of putting async write operations in the action creators and async read operations in the store. The goal is to keep the store state modification code in fully synchronous action handlers; this makes them simple to reason about and simple to unit test. In order to prevent multiple simultaneous requests to the same endpoint (for example, double-reading), I\'ll move the actual request processing into a separate module that uses promises to prevent the multiple requests; for example:While reads in the store involve asynchronous functions, there is an important caveat that the stores don\'t update themselves in the async handlers, but instead fire an action and only fire an action when the response arrives. Handlers for this action end up doing the actual state modification.For example, a component might do:The store would have a method implemented, perhaps, something like this:Fluxxor has an example of async communication with an API.This blog post has talks about it and has been featured on React\'s blog.I find this a very important and difficult question that is not clearly answered yet, as frontend software synchronization with the backend is still a pain.Should API requests be made in JSX components? Stores? Other place?Performing requests in stores mean that if 2 stores need the same data for a given action, they will issue 2 similar requets (unless you introduce dependencies between stores, which I really don\'t like)In my case, I have found this very handy to put Q promises as payload of actions because:Ajax is EVILI think Ajax will be less and less used in the near future because it is very hard to reason about.\nThe right way? Considering devices as part of the distributed system\nI don\'t know where I first came across this idea (maybe in this inspiring Chris Granger video).Think about it. Now for scalability we use distributed systems with eventual consistency as storage engines (because we can\'t beat the CAP theorem and often we want to be available). These systems do not sync through polling each others (except maybe for consensus operations?) but rather use structures like CRDT and event logs to make all the members of the distributed system eventually consistent (members will converge to the same data, given enough time).Now think about what is a mobile device or a browser. It is just a member of the distributed system that may suffer of network latency and network partitionning. (ie you are using your smartphone on the subway)If we can build network partition and network speed tolerant databases (I mean we can still perform write operations to an isolated node), we can probably build frontend softwares (mobile or desktop) inspired by these concepts, that work well with offline mode supported out of the box without app features unavailability.I think we should really inspire ourselves of how databases are working to architecture our frontend applications. One thing to notice is that these apps do not perform POST and PUT and GET ajax requests to send data to each others, but rather use event logs and CRDT to ensure eventual consistency. So why not do that on the frontend?\nNotice that the backend is already moving in that direction, with tools like Kafka massively adopted by big players. This is somehow related to Event Sourcing / CQRS / DDD too.Check these awesome articles from Kafka authors to convince yourself:Maybe we can start by sending commands to the server, and receiving a stream of server events (through websockets for exemple), instead of firing Ajax requests.I have never been very comfortable with Ajax requests. As we React developpers tend to be functional programmers. I think it\'s hard to reason about local data that is supposed to be your "source of truth" of your frontend application, while the real source of truth is actually on the server database, and your "local" source of truth may already be outdated when you receive it, and will never converge to the real source of truth value unless you press some lame Refresh button... Is this engineering?However it\'s still a bit hard to design such a thing for some obvious reasons:You can call for data in either the action creators or the stores.  The important thing is to not handle the response directly, but to create an action in the error/success callback.  Handling the response directly in the store leads to a more brittle design.I have been using Binary Muse\'s example from the Fluxxor ajax example. Here is my very simple example using the same approach.I have a simple product store some product actions and the controller-view component which has sub-components that all respond to changes made to the product store. For instance product-slider, product-list and product-search components.Fake Product ClientHere is the fake client which you could substitute for calling an actual endpoint returning products.Product StoreHere is the Product Store, obviously this is a very minimal store.Now the product actions, which make the AJAX request and on success fire the LOAD_PRODUCTS_SUCCESS action returning products to the store.Product ActionsSo calling this.getFlux().actions.productActions.loadProducts() from any component listening to this store would load the products. You could imagine having different actions though which would respond to user interactions like addProduct(id) removeProduct(id) etc... following the same pattern.Hope that example helps a bit, as I found this a little tricky to implement, but certainly helped in keeping my stores 100% synchronous.I answered a related question here: How to handle nested api calls in fluxActions are not supposed to be things that cause a change. They are supposed to be like a newspaper that informs the application of a change in the outside world, and then the application responds to that news. The stores cause changes in themselves. Actions just inform them.Bill Fisher, creator of Flux https://stackoverflow.com/a/26581808/4258088What you basically should be doing is, stating via actions what data you need. If the store gets informed by the action, it should decide if it needs to fetch some data. The store should be responsible for accumulating/fetching all the needed data. It is important to note though, that after the store requested the data and gets the response, it should trigger an action itself with the fetched data, opposed to the store handling/saving the response directly. A stores could look like something like this:\nHere\'s my take on this: http://www.thedreaming.org/2015/03/14/react-ajax/Hope that helps.  :)