In Java 8 we have the class Stream<T>, which curiously have a methodSo you would expect it to implement interface Iterable<T>, which requires exactly this method, but that\'s not the case.When I want to iterate over a Stream using a foreach loop, I have to do something likeAm I missing something here?There are already people asked the same on the mailing list \xe2\x98\xba. The main reason is Iterable also has a re-iterable semantic, while Stream is not.I think the main reason is that Iterable implies reusability, whereas Stream is something that can only be used once \xe2\x80\x94 more like an Iterator.If Stream extended Iterable then existing code might be surprised when it receives an Iterable that throws an Exception the\n  second time they do for (element : iterable).To convert a Stream to an Iterable, you can doTo pass a Stream to a method that expects Iterable, simplyhowever it probably looks funny; it might be better to be a little bit more explicitI would like to point out that StreamEx does implement Iterable (and Stream), as well as a host of other immensely awesome functionality missing from Stream.kennytm described why it\'s unsafe to treat a Stream as an Iterable, and Zhong Yu offered a workaround that permits using a Stream as in Iterable, albeit in an unsafe manner.  It\'s possible to get the best of both worlds: a reusable Iterable from a Stream that meets all the guarantees made by the Iterable specification.Note: SomeType is not a type parameter here--you need to replace it with a proper type (e.g., String) or resort to reflectionThere is one major disadvantage:The benefits of lazy iteration will be lost.  If you planned to immediately iterate over all values in the current thread, any overhead will be negligible.  However, if you planned to iterate only partially or in a different thread, this immediate and complete iteration could have unintended consequences.The big advantage, of course, is that you can reuse the Iterable, whereas (Iterable<SomeType>) stream::iterator would only permit a single use.  If the receiving code will be iterating over the collection multiple times, this is not only necessary, but likely beneficial to performance.You can use a Stream in a for loop as follows:(Run this snippet here)(This uses a Java 8 functional interface cast.)(This is covered in some of the comments above (e.g. Aleksandr Dubinsky), but I wanted to pull it out into an answer to make it more visible.)If you don\'t mind using third party libraries cyclops-react defines a Stream that implements both Stream and Iterable and is replayable too (solving the problem kennytm described).or :-[Disclosure I am the lead developer of cyclops-react]Not perfect, but will work:Not perfect because it will fetch all items from the stream and put them into that List, which is not exactly what Iterable and Stream are about. They are supposed to be lazy.