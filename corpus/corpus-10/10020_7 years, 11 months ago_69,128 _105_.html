I am crafting a small project in mixed C and C++.  I am building one small-ish state-machine at the heart of one of my worker thread.I was wondering if you gurus on SO would share your state-machine design techniques.NOTE: I am primarily after tried & tested implementation techniques.UPDATED: Based on all the great input gathered on SO, I\'ve settled on this architecture:State machines that I\'ve designed before (C, not C++) have all come down to a struct array and a loop. The structure basically consists of a state and event (for look-up) and a function that returns the new state, something like:Then you define your states and events with simple defines (the ANY ones are special markers, see below):Then you define all the functions that are called by the transitions:All these function are written to take no variables and return the new state for the state machine. In this example global variables are used for passing any information into the state functions where necessary.Using globals isn\'t as bad as it sounds since the FSM is usually locked up inside a single compilation unit and all variables are static to that unit (which is why I used quotes around "global" above - they\'re more shared within the FSM, than truly global). As with all globals, it requires care.The transitions array then defines all possible transitions and the functions that get called for those transitions (including the catch-all last one):What that means is: if you\'re in the ST_INIT state and you receive the EV_KEYPRESS event, make a call to GotKey.The workings of the FSM then become a relatively simple loop:As alluded to above, note the use of ST_ANY as wild-cards, allowing an event to call a function no matter the current state. EV_ANY also works similarly, allowing any event at a specific state to call a function.It can also guarantee that, if you reach the end of the transitions array, you get an error stating your FSM hasn\'t been built correctly (by using the ST_ANY/EV_ANY combination.I\'ve used code similar for this on a great many communications projects, such as an early implementation of communications stacks and protocols for embedded systems. The big advantage was its simplicity and relative ease in changing the transitions array.I\'ve no doubt there will be higher-level abstractions which may be more suitable nowadays but I suspect they\'ll all boil down to this same sort of structure. And, as ldog states in a comment, you can avoid the globals altogether by passing a structure pointer to all functions (and using that in the event loop). This will allow multiple state machines to run side-by-side without interference.Just create a structure type which holds the machine-specific data (state at a bare minimum) and use that instead of the globals.The reason I\'ve rarely done that is simply because most of the state machines I\'ve written have been singleton types (one-off, at-process-start, configuration file reading for example), not needing to run more than one instance. But it has value if you need to run more than one.The other answers are good, but a very "lightweight" implementation I\'ve used when the state machine is very simple looks like:I would use this when the state machine is simple enough that the function pointer & state transition table approach is overkill.  This is often useful for character-by-character or word-by-word parsing.Pardon me for breaking every rule in computer science, but a state machine is one of the few (I can count only two off hand) places where a goto statement is not only more efficent, but also makes your code cleaner and easier to read. Because goto statements are based on lables, you can name your states instead of having to keep track of a mess of numbers or use an enum. It also makes for much cleaner code since you don\'t need all the extra cruft of function pointers or huge switch statements and while loops. Did I mention it\'s more efficient too?Here\'s what a state machine might look like:You get the general idea. The point is that you can implement the state machine in an efficent way and one that is relatively easy to read and screams at the reader that they are looking at a state machine. Note that if you are using goto statements, you must still be careful as it is very easy to shoot yourself in the foot while doing so.You might consider the State Machine Compiler http://smc.sourceforge.net/This splendid open source utility accepts a description of a state machine in a simple language and compiles it to any one of a dozen or so languages - including C and C++. The utility itself is written in Java, and can be included as part of a build.The reason to do this, rather than hand coding using GoF State pattern or any other approach, is that once your state machine is expressed as code, the underlying structure tends to disappear under the weight of boilerplate that needs to be generated to support it. Using this approach gives you an excellent separation of concerns, and you keep the structure of your state machine \'visible\'. The auto-generated code goes into modules that you don\'t need to touch, so that you can go back and fiddle with the state machine\'s structure without impacting the supporting code that you have written.Sorry, I am being over-enthusiastic, and doubtless putting everyone off. But it is a top notch utility, and well-documented too.Be sure to check the work of Miro Samek (blog State Space, website State Machines & Tools), whose articles at the C/C++ Users Journal were great.The website contains a complete (C/C++) implementation in both open source and commercial license of a state machine framework (QP Framework), an event handler (QEP), a basic modeling tool (QM) and a tracing tool (QSpy) which allow to draw state machines, create code and debug them.The book contains an extensive explanation on the what/why of the implementation and how to use it and is also great material to gain understanding of the fundamentals of hierachical and finite state machines.The website also contains links to several board support packages for use of the software with embedded platforms.I\'ve done something similar to what paxdiablo describes, only instead of an array of state/event transitions, I set up a 2-dimensional array of function pointers, with the event value as the index of one axis and the current state value as the other. Then I just call state = state_table[event][state](params) and the right thing happens. Cells representing invalid state/event combinations get a pointer to a function that says so, of course. Obviously, this only works if the state and event values are both contiguous ranges and start at 0 or close enough.A very nice template-based C++ state machine "framework" is given by Stefan Heinzmann in his article.Since there\'s no link to a complete code download in the article, I\'ve taken the liberty to paste the code into a project and check it out. The stuff below is tested and includes the few minor but pretty much obvious missing pieces.The major innovation here is that the compiler is generating very efficient code. Empty entry/exit actions have no cost. Non-empty entry/exit actions are inlined. The compiler is also verifying the completeness of the statechart. Missing actions generate linking errors. The only thing that is not caught is the missing Top::init.This is a very nice alternative to Miro Samek\'s implementation, if you can live without what\'s missing -- this is far from a complete UML Statechart implementation, although it correctly implements the UML semantics, whereas Samek\'s code by design doesn\'t handle exit/transition/entry actions in correct order.If this code works for what you need to do, and you have a decent C++ compiler for your system, it will probably perform better than Miro\'s C/C++ implementation. The compiler generates a flattened, O(1) transition state machine implementation for you. If the audit of assembly output confirms that the optimizations work as desired, you get close to theoretical performance. Best part: it\'s relatively tiny, easy to understand code.Test code follows.The technique I like for state machines (at least ones for program control) is to use function pointers.  Each state is represented by a different function.  The function takes an input symbol and returns the function pointer for the next state.  The central dispatch loop monitors takes the next input, feeds it to the current state, and processes the result.The typing on it gets a little odd, since C doesn\'t have a way to indicate types of function pointers returning themselves, so the state functions return void*.  But you can do something like this:Then your individual state functions can switch on their input to process and return the appropriate value.Simplest casePoints:\nState is private, not only to the compilation unit but also to the event_handler.\nSpecial cases may be handled separately from the main switch using whatever construct deemed necessary.More complex caseWhen the switch gets bigger than a couple of screens full, split it into functions that handle each state, using a state table to look up the function directly. The state is still private to the event handler. The state handler functions return the next state. If needed some events can still receive special treatment in the main event handler. I like to throw in pseudo-events for state entry and exit and perhaps state machine start:I am not sure if I nailed the syntax, especially regarding the array of function pointers. I have not run any of this through a compiler. Upon review, I noticed that I forgot to explicitly discard the next state when handling the pseudo events (the (void) parenthesis before the call to state_handler()). This is something that I like to do even if compilers accept the omission silently. It tells readers of the code that "yes, I did indeed mean to call the function without using the return value", and it may stop static analysis tools from warning about it. It may be idiosyncratic because I do not recall having seen anybody else doing this.Points: adding a tiny bit of complexity (checking if the next state is different from the current), can avoid duplicated code elsewhere, because the state handler functions can enjoy the pseudo events that occur when a state is entered and left. Remember that state cannot change when handling the pseudo events, because the result of the state handler is discarded after these events. You may of course choose to modify the behaviour. A state handler would look like so:More complexityWhen the compilation unit becomes too large (whatever you feel that is, I should say around 1000 lines), put each state handler in a separate file. When each state handler becomes longer than a couple of screens, split each event out in a separate function, similar to the way that the state switch was split. You may do this in a number of ways, separately from the state or by using a common table, or combining various schemes. Some of them have been covered here by others. Sort your tables and use binary search if speed is a requirement.Generic programmingI should like the preprocessor to deal with issues such as sorting tables or even generating state machines from descriptions, allowing you to "write programs about programs". I believe this is what the Boost people are exploiting C++ templates for, but I find the syntax cryptic.Two-dimensional tablesI have used state/event tables in the past but I have to say that for the simplest cases I do not find them necessary and I prefer the clarity and readability of the switch statement even if it does extend past one screen full. For more complex cases the tables quickly get out of hand as others have noted. The idioms I present here allow you to add a slew of events and states when you feel like it, without having to maintain a memory consuming table (even if it may be program memory). DisclaimerSpecial needs may render these idioms less useful, but I have found them to be very clear and maintainable.Extremely untested, but fun to code, now in a more refined version than my original answer; up-to-date versions can be found at mercurial.intuxication.org:sm.hexample.cComing to this late (as usual) but scanning the answers to date I thinks something important is missing;I have found in my own projects that it can be very helpful to not have a function for every valid state/event combination. I do like the idea of effectively having a 2D table of states/events. But I like the table elements to be more than a simple function pointer. Instead I try to organize my design so at it\'s heart it comprises a bunch of simple atomic elements or actions. That way I can list those simple atomic elements at each intersection of my state/event table. The idea is that you don\'t have to define a mass of N squared (typically very simple) functions. Why have something so error-prone, time consuming, hard to write, hard to read, you name it ?I also include an optional new state, and an optional function pointer for each cell in the table. The function pointer is there for those exceptional cases where you don\'t want to just fire off a list of atomic actions.You know you are doing it right when you can express a lot of different functionality, just by editing your table, with no new code to write.Alrght, I think mine\'s just a little different from everybody else\'s. A little more separation of code and data than I see in the other answers. I really read up on the theory to write this, which implements a full Regular-language (without regular expressions, sadly). Ullman, Minsky, Chomsky. Can\'t say I understood it all, but I\'ve drawn from the old masters as directly as possible: through their words.I use a function pointer to a predicate that determines the transition to a \'yes\' state or a \'no\' state. This facilitates the creation of a finite state acceptor for a regular language that you program in a more assembly-language-like manner. \nPlease don\'t be put-off by my silly name choices. \'czek\' == \'check\'. \'grok\' == [go look it up in the Hacker Dictionary].So for each iteration, czek calls a predicate function with the current character as argument. If the predicate returns true, the character is consumed (the pointer advanced) and we follow the \'y\' transition to select the next state. If the predicate returns false, the character is NOT consumed and we follow the \'n\' transition. So every instruction is a two-way branch! I must have been reading The Story of Mel at the time.This code comes straight from my postscript interpreter, and evolved into its current form with much guidance from the fellows on comp.lang.c. Since postscript basically has no syntax (only requiring balanced brackets), a Regular Language Accepter like this functions as the parser as well. boost.org comes with 2 different state chart implementations:As always, boost will beam you into template hell.The first library is for more performance-critical state machines. The second library gives you a direct transition path from a UML Statechart to code.Here\'s the SO question asking for a comparison between the two where both of the authors respond.Another interesting open source tool is Yakindu Statechart Tools on statecharts.org. It makes use of Harel statecharts and thus provides hierarchical and parallel states and generates C and C++ (as well as Java) code. It does not make use of libraries but follows a \'plain code\' approach. The code basically applies switch-case structures. The code generators can also be customized. Additionally the tool provides many other features.This series of Ars OpenForum posts about a somewhat complicated bit of control logic includes a very easy-to-follow implementation as a state machine in C.Saw this somewhereGiven that you imply you can use C++ and hence OO code, I would suggest evaluating the \'GoF\'state pattern (GoF = Gang of Four, the guys who wrote the design patterns book which brought design patterns into the limelight).It is not particularly complex and it is widely used and discussed so it is easy to see examples and explanations on line.It will also quite likely be recognizable by anyone else maintaining your code at a later date.If efficiency is the worry, it would be worth actually benchmarking to make sure that a non OO approach is more efficient as lots of factors affect performance and it is not always simply OO bad, functional code good. Similarly, if memory usage is a constraint for you it is again worth doing some tests or calculations to see if this will actually be an issue for your particular application if you use the state pattern. The following are some links to the \'Gof\' state pattern, as Craig suggests:I really liked paxdiable\'s answer and decided to implement all the missing features for my application like guard variables and state machine specific data. I uploaded my implementation to this site to share with the community. It has been tested using IAR Embedded Workbench for ARM.https://sourceforge.net/projects/compactfsm/Your question is quite generic,\nHere are two reference articles that might be useful,  Embedded State Machine Implementation This article describes a simple approach to implementing a state machine for an embedded system. For purposes of this article, a state machine is defined as an algorithm that can be in one of a small number of states. A state is a condition that causes a prescribed relationship of inputs to outputs, and of inputs to next states.\n  A savvy reader will quickly note that the state machines described in this article are Mealy machines. A Mealy machine is a state machine where the outputs are a function of both present state and input, as opposed to a Moore machine, in which the outputs are a function only of state.My preoccupation in this article is with state-machine fundamentals and some straightforward programming guidelines for coding state machines in C or C++. I hope that these simple techniques can become more common, so that you (and others) can readily see the state-machine structure right from the source code. I have used State Machine Compiler in Java and Python projects to with success.This is an old post with lots of answers, but I thought I\'d add my own approach to the finite state machine in C. I made a Python script to produce the skeleton C code for any number of states. That script is documented on GituHub at FsmTemplateCThis example is based on other approaches I\'ve read about. It doesn\'t use goto or switch statements but instead has transition functions in a pointer matrix (look-up table). The code relies on a big multi-line initializer macro and C99 features (designated initializers and compound literals) so if you don\'t like these things, you might not like this approach. Here is a Python script of a turnstile example which generates skeleton C-code using FsmTemplateC:The generated output header contains the typedefs:Now for the function declarations in the header:Function names are in the format {prefix}_{from}_{to}, where {from} is the previous (current) state and {to} is the next state. Note that if the transition table does not allow for certain transitions, a NULL pointer instead of a function pointer will be set. Finally, the magic happens with a macro. Here we build the transition table (matrix of state enums) and the state transition functions look up table (a matrix of function pointers):When creating the FSM, the macro FSM_EXAMPLE_CREATE() has to be used. Now, in the source code every state transition function declared above should be populated. The FsmTurnstileFopts struct can be used to pass data to/from the state machine. Every transition must set fsm->check to be equal to either EFSM_EXAMPLE_TR_RETREAT to block it from transitioning or EFSM_EXAMPLE_TR_ADVANCE to allow it to transition to the commanded state. \nA working example can be found at (FsmTemplateC)[https://github.com/ChisholmKyle/FsmTemplateC].Here is the very simple actual usage in your code: All that header business and all those functions just to have a simple and fast interface is worth it in my mind.You could use the open source library OpenFST.OpenFst is a library for constructing, combining, optimizing, and searching weighted finite-state transducers (FSTs). Weighted finite-state transducers are automata where each transition has an input label, an output label, and a weight. The more familiar finite-state acceptor is represented as a transducer with each transition\'s input and output label equal. Finite-state acceptors are used to represent sets of strings (specifically, regular or rational sets); finite-state transducers are used to represent binary relations between pairs of strings (specifically, rational transductions). The weights can be used to represent the cost of taking a particular transition.I personally use self referencing structs in combination with pointer arrays.\nI uploaded a tutorial on github a while back, link: https://github.com/mmelchger/polling_state_machine_cNote: I do realise that this thread is quite old, but I hope to get input and thoughts on the design of the state-machine as well as being able to provide an example for a possible state-machine design in C.