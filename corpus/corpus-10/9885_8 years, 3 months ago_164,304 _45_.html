For example, lets say you have two classes:I have a method that returns a List<TestA> and I would like to cast all the objects in that list to TestB so that I end up with a List<TestB>.Simply casting to List<TestB> almost works; but it doesn\'t work because you can\'t cast a generic type of one parameter to another. However, you can cast through an intermediate wildcard type and it will be allowed (since you can cast to and from wildcard types, just with an unchecked warning):casting of generics is not possible, but if you define the list in another way it is possible to store TestB in it:You still have type checking to do when you are using the objects in the list.You really can\'t*:Example taken from this Java tutorialAssume there are two types A and B such that B extends A.\nThen the following code is correct:  The previous code is valid because B is a subclass of A.\nNow, what happens with List<A> and List<B>?  It turns out that List<B> is not a subclass of List<A> therefore we cannot write Furthermore, we can\'t even write*: To make the casting possible we need a common parent for both List<A> and List<B>: List<?> for example. The following is valid:You will however get a warning. You can suppress it by adding @SuppressWarnings("unchecked") to your method.With Java 8, you actually canI think you are casting in the wrong direction though... if the method returns a list of TestA objects, then it really isn\'t safe to cast them to TestB.Basically you are asking the compiler to let you perform TestB operations on a type TestA that does not support them.The best safe way is to implement an AbstractList and cast items in implementation. I created ListUtil helper class:You can use cast method to blindly cast objects in list and convert method for safe casting. \nExample:Since this is a widely referenced question, and the current answers mainly explain why it does not work (or propose hacky, dangerous solutions that I would never ever like to see in production code), I think it is appropriate to add another answer, showing the pitfalls, and a possible solution.The reason why this does not work in general has already been pointed out in other answers: Whether or not the conversion is actually valid depends on the types of the objects that are contained in the original list. When there are objects in the list whose type is not of type TestB, but of a different subclass of TestA, then the cast is not valid. Of course, the casts may be valid. You sometimes have information about the types that is not available for the compiler. In these cases, it is possible to cast the lists, but in general, it is not recommended:One could either...The implications of the first approach (which corresponds to the currently accepted answer) are subtle. It might seem to work properly at the first glance. But if there are wrong types in the input list, then a ClassCastException will be thrown, maybe at a completely different location in the code, and it may be hard to debug this and to find out where the wrong element slipped into the list. The worst problem is that someone might even add the invalid elements after the list has been casted, making debugging even more difficult. The problem of debugging these spurious ClassCastExceptions can be alleviated with the Collections#checkedCollection family of methods.A more type-safe way of converting from a List<Supertype>  to a List<Subtype> is to actually filter the list, and create a new list that contains only elements that have certain type. There are some degrees of freedom for the implementation of such a method (e.g. regarding the treatment of null entries), but one possible implementation may look like this:This method can be used in order to filter arbitrary lists (not only with a given Subtype-Supertype relationship regarding the type parameters), as in this example:You cannot cast List<TestB> to List<TestA> as Steve Kuo mentions BUT you can dump the contents of List<TestA> into List<TestB>. Try the following:I\'ve not tried this code so there are probably mistakes but the idea is that it should iterate through the data object adding the elements (TestB objects) into the List. I hope that works for you.When you cast an object reference you are just casting the type of the reference, not the type of the object. casting won\'t change the actual type of the object.Java doesn\'t have implicit rules for converting Object types. (Unlike primitives)Instead you need to provide how to convert one type to another and call it manually.This is more verbose than in a language with direct support, but it works and you shouldn\'t need to do this very often.The only way I know is by copying:This is possible due to type erasure. You will find thatInternally both lists are of type List<Object>. For that reason you can\'t cast one to the other - there is nothing to cast.if you have an object of the class TestA, you can\'t cast it to TestB. every TestB is a TestA, but not the other way.in the following code:the second line would throw a ClassCastException.you can only cast a TestA reference if the object itself is TestB. for example:so, you may not always cast a list of TestA to a list of TestB.The problem is that your method does NOT return a list of TestA if it contains a TestB, so what if it was correctly typed?  Then this cast:works about as well as you could hope for (Eclipse warns you of an unchecked cast which is exactly what you are doing, so meh).  So can you use this to solve your problem?  Actually you can because of this:Exactly what you asked for, right? or to be really exact:seems to compile just fine for me.This should would work