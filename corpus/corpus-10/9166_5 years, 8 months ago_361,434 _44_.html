I have a function which I want to take, as a parameter, a 2D array of variable size. So far I have this: And I have declared an array elsewhere in my code:However, calling myFunction(anArray) gives me an error.I do not want to copy the array when I pass it in. Any changes made in myFunction should alter the state of anArray. If I understand correctly, I only want to pass in as an argument a pointer to a 2D array. The function needs to accept arrays of different sizes also. So for example, [10][10] and [5][5]. How can I do this?There are three ways to pass a 2D array to a function:The parameter is a 2D arrayThe parameter is an array containing pointersThe parameter is a pointer to a pointer1. Pass by referenceIn C++ passing the array by reference without losing the dimension information is probably the safest, since one needn\'t worry about the caller passing an incorrect dimension (compiler flags when mismatching). However, this isn\'t possible with dynamic (freestore) arrays; it works for automatic (usually stack-living) arrays only i.e. the dimensionality should be known at compile time.2. Pass by pointerThe C equivalent of the previous method is passing the array by pointer. This should not be confused with passing by the array\'s decayed pointer type (3), which is the common, popular method, albeit less safe than this one but more flexible. Like (1), use this method when all the dimensions of the array is fixed and known at compile-time. Note that when calling the function the array\'s address should be passed process_2d_array_pointer(&a) and not the address of the first element by decay process_2d_array_pointer(a).These are inherited from C but are less safe, the compiler has no way of checking, guaranteeing that the caller is passing the required dimensions. The function only banks on what the caller passes in as the dimension(s). These are more flexible than the above ones since arrays of different lengths can be passed to them invariably.It is to be remembered that there\'s no such thing as passing an array directly to a function in C [while in C++ they can be passed as a reference (1)]; (2) is passing a pointer to the array and not the array itself. Always passing an array as-is becomes a pointer-copy operation which is facilitated by array\'s nature of decaying into a pointer.3. Pass by (value) a pointer to the decayed typeAlthough int array[][10] is allowed, I\'d not recommend it over the above syntax since the above syntax makes it clear that the identifier array is a single pointer to an array of 10 integers, while this syntax looks like it\'s a 2D array but is the same pointer to an array of 10 integers. Here we know the number of elements in a single row (i.e. the column size, 10 here) but the number of rows is unknown and hence to be passed as an argument. In this case there\'s some safety since the compiler can flag when a pointer to an array with second dimension not equal to 10 is passed. The first dimension is the varying part and can be omitted. See here for the rationale on why only the first dimension is allowed to be omitted.4. Pass by pointer to a pointerAgain there\'s an alternative syntax of int *array[10] which is the same as int **array. In this syntax the [10] is ignored as it decays into a pointer thereby becoming int **array. Perhaps it is just a cue to the caller that the passed array should have at least 10 columns, even then row count is required. In any case the compiler doesn\'t flag for any length/size violations (it only checks if the type passed is a pointer to pointer), hence requiring both row and column counts as parameter makes sense here.Note: (4) is the least safest option since it hardly has any type check and the most inconvenient. One cannot legitimately pass a 2D array to this function; C-FAQ condemns the usual workaround of doing int x[5][10]; process_pointer_2_pointer((int**)&x[0][0], 5, 10); as it may potentially lead to undefined behaviour due to array flattening. The right way of passing an array in this method brings us to the inconvenient part i.e. we need an additional (surrogate) array of pointers with each of its element pointing to the respective row of the actual, to-be-passed array; this surrogate is then passed to the function (see below); all this for getting the same job done as the above methods which are more safer, cleaner and perhaps faster.Here\'s a driver program to test the above functions:A modification to shengy\'s first suggestion, you can use templates to make the function accept a multi-dimensional array variable (instead of storing an array of pointers that have to be managed and deleted):The print statements are there to show that the arrays are getting passed by reference (by displaying the variables\' addresses)You can create a function template like this:Then you have both dimension sizes via R and C.  A different function will be created for each array size, so if your function is large and you call it with a variety of different array sizes, this may be costly.  You could use it as a wrapper over a function like this though:It treats the array as one dimensional, and uses arithmetic to figure out the offsets of the indexes.  In this case, you would define the template like this:anArray[10][10] is not a pointer to a pointer, it is a contiguous chunk of memory suitable for storing 100 values of type double, which compiler knows how to address because you specified the dimensions. You need to pass it to a function as an array. You can omit the size of the initial dimension, as follows:However, this will not let you pass arrays with the last dimension other than ten.The best solution in C++ is to use std::vector<std::vector<double> >: it is nearly as efficient, and significantly more convenient.Single dimensional array decays to a pointer pointer pointing to the first element in the array. While a 2D array decays to a pointer pointing to first row. So, the function prototype should be -I would prefer std::vector over raw arrays.You can do something like this...Your output will be as follows...Surprised that no one mentioned this yet, but you can simply template on anything 2D supporting [][] semantics.It works with any 2D "array-like" datastructure, such as std::vector<std::vector<T>>, or a user defined type to maximize code reuse.You can use template facility in C++ to do this. I did something like this :the problem with this approach is that for every value of col which you provide, the a new function definition is instantiated using the template.\nso,instantiates the template twice to produce 2 function definitions (one where col = 3 and one where col = 5).One important thing for passing multidimensional arrays is:1.When only second dimension is available globally (either as a macro or as a global constant)2.Using a single pointer:\nIn this method,we must typecast the 2D array when passing to function.We can use several ways to pass a 2D array to a function:Using single pointer we have to typecast the 2D array.Using double pointer In this way, we also typecast the 2d array