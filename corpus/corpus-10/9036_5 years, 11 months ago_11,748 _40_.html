Let\'s say you\'ve got an airplane, and it is low on fuel.  Unless the plane drops 3000 pounds of passenger weight, it will not be able to reach the next airport.  To save the maximum number of lives, we would like to throw the heaviest people off of the plane first.  And oh yeah, there are millions of people on the airplane, and we would like an optimal algorithm to find the heaviest passengers, without necessarily sorting the entire list.This is a proxy problem for something I\'m trying to code in C++.  I would like to do a "partial_sort" on the passenger manifest by weight, but I don\'t know how many elements I\'m going to need.  I could implement my own "partial_sort" algorithm ("partial_sort_accumulate_until"), but I\'m wondering if there\'s any easier way to do this using standard STL.One way would be to use a min heap (std::priority_queue in C++). Here\'s how you\'d do it, assuming you had a MinHeap class.  (Yes, my example is in C#. I think you get the idea.)According to the standard references, running time should be proportional to n log k, where n is the number of passengers and k is the maximum number of items on the heap. If we assume that passengers\' weights will typically be 100 lbs or more, then it\'s unlikely that the heap will contain more than 30 items at any time.The worst case would be if the passengers are presented in order from lowest weight to highest. That would require that every passenger be added to the heap, and every passenger be removed from the heap. Still, with a million passengers and assuming that the lightest weighs 100 lbs, the n log k works out to a reasonably small number.If you get the passengers\' weights randomly, performance is much better. I use something quite like this for a recommendation engine (I select the top 200 items from a list of several million). I typically end up with only 50,000 or 70,000 items actually added to the heap.I suspect that you\'ll see something quite similar: the majority of your candidates will be rejected because they\'re lighter than the lightest person already on the heap. And Peek is an O(1) operation.For a more information about the performance of heap select and quick select, see When theory meets practice. Short version: if you\'re selecting fewer than 1% of the total number of items, then heap select is a clear winner over quick select. More than 1%, then use quick select or a variant like Introselect.This won\'t help for your proxy problem, however:For 1,000,000 passengers to drop 3000 pounds of weight, each passenger must lose (3000/1000000) = 0.003 lbs per person. That could be achieved through jettisoning every ones shirt, or shoes, or probably even fingernail clippings, saving everyone. This assumes efficient collection and jettison before the weight loss needed increased as the plane used more fuel.Actually, they don\'t allow fingernail clippers on board anymore, so that\'s out.Below is a rather simple implementation of the straightforward solution.  I don\'t think there is a faster way that is 100% correct.This works by filling up the set of "dead people" until it meets the threshold.  Once the threshold is met, we keep going through the list of passengers trying to find any that are heavier than the lightest dead person.  When we have found one, we add them to the list and then start "Saving" the lightest people off the list until we can\'t save any more.In the worst case, this will perform about the same as a sort of the entire list.  But in the best case (the "dead list" is filled up properly with the first X people) it will perform O(n).Assuming all passengers will cooperate: Use a parallel sorting network. (see also this)Here is a live demonstrationUpdate: Alternative video (jump to 1:00)Asking pairs of people to compare-exchange - you can\'t get faster than this.@Blastfurnace was on the right track.  You use quickselect where the pivots are weight thresholds.  Each partition splits one set of people into sets, and returns the total weight for each set of people.  You continue breaking the appropriate bucket until your buckets corresponding to the highest weight people are over 3000 pounds, and your lowest bucket that is in that set has 1 person (that is, it can\'t be split any further.)This algorithm is linear time amortized, but quadratic worst case.  I think it is the only linear time algorithm.Here\'s a Python solution that illustrates this algorithm:Output:Assuming that, like people\'s weights, you have a good idea of what the maximum and minimum values are likely to be use a radix sort to sort them in O(n).  Then simply work from the heaviest end of the list towards the lightest.  Total running time: O(n).  Unfortunately, there isn\'t an implementation of a radix sort in the STL, but it\'s pretty straightforward to write.Why don\'t you use a partial quicksort with a different abort rule than "sorted".\nYou can run it and then use just the higher half and go on until the weight within this higher half does not contain the weight that has at least to be thrown out anymore, than you go back one step in the recursion and sort the list. After that you can start throwing people out from the high end of that sorted list.Massively Parallel Tournament Sort:-Assuming a standard three seats each side of the ailse:-Ask the passengers in the window seat to move to the middle seat if they are heavier than the person in the window seat.Ask the passengers in the middle seat to swap with the passenger in aisle seat if they are heavier.Ask the passenger in the left aisle seat to swap with the passenger in the right aisle seat id they are heavier.Bubble sort the passengers in the right aisle seat. (Takes n steps for n rows).\n-- ask the passengers in the right aisle seat to swap with the person in front n -1 times.5  Kick them out the door until you reach 3000 pounds.3 steps + n steps plus 30 steps if you have a really skinny passenger load.For a two aisle plane -- the instructions are more complex but the performance is about the same.I would probably use std::nth_element to partition off the 20 heaviest people in linear time. Then use a more complex method to find and bump off the heaviest of the heavies.You could make one pass over the list to get the mean and the standard deviation, then use that to approximate the number of people that have to go. Use partial_sort to generate the list based on that number. If the guess was low, use partial_sort again on the remainder with a new guess.@James has the answer in the comments:  a std::priority_queue if you can use any container, or a combination of std::make_heap and std::pop_heap (and std::push_heap) if you want to use something like a std::vector.Here\'s a heap-based solution using Python\'s built-in heapq module. It\'s in Python so doesn\'t answer the original question, but it\'s cleaner (IMHO) than the other posted Python solution.If k = the number of passengers to toss and N = the number of passengers, then the best case for this algorithm is O(N) and the worst case for this algorithm is Nlog(N). The worst case occurs if k is near N for a long time. Here\'s an example of the worst cast:However, in this case (throwing people off the plane (with a parachute, I presume)) then k must be less than 3000, which is << "millions of people". The average runtime should therefore be about Nlog(k), which is linear to the number of people.