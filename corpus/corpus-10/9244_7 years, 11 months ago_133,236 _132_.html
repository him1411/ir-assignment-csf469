I have come across a problem with binding to a PasswordBox. It seems it\'s a security risk but I am using the MVVM pattern so I wish to bypass this. I found some interesting code here (has anyone used this or something similar?)http://www.wpftutorial.net/PasswordBox.htmlIt technically looks great, but I am unsure of how to retrieve the password. I basically have properties in my LoginViewModel for Username and Password. Username is fine and is working as it\'s a TextBox.I used the code above as stated and entered thisWhen I had the PasswordBox as a TextBox and Binding Path=Password then the property in my LoginViewModel was updated.My code is very simple, basically I have a Command for my Button. When I press it CanLogin is called and if it returns true it calls Login.\nYou can see I check my property for Username here which works great. In Login I send along to my service a Username and Password, Username contains data from my View but Password is Null|EmptyThis is what I am doingI have my TextBox, this is no problem, but in my ViewModel the Password is empty.Am I doing something wrong or missing a step?I put a breakpoint and sure enough the code enter the static helper class but it never updates my Password in my ViewModel.Sorry, but you\'re doing it wrong.People should have the following security guideline tattooed on the inside of their eyelids:\nNever keep plain text passwords in memory.The reason the WPF/Silverlight PasswordBox doesn\'t expose a DP for the Password property is security related.\nIf WPF/Silverlight were to keep a DP for Password it would require the framework to keep the password itself unencrypted in memory. Which is considered quite a troublesome security attack vector.\nThe PasswordBox uses encrypted memory (of sorts) and the only way to access the password is through the CLR property. I would suggest that when accessing the PasswordBox.Password CLR property you\'d refrain from placing it in any variable or as a value for any property.\nKeeping your password in plain text on the client machine RAM is a security no-no.\nSo get rid of that "public string Password { get; set; }" you\'ve got up there. When accessing PasswordBox.Password, just get it out and ship it to the server ASAP. \nDon\'t keep the value of the password around and don\'t treat it as you would any other client machine text. Don\'t keep clear text passwords in memory. I know this breaks the MVVM pattern, but you shouldn\'t ever bind to PasswordBox.Password Attached DP, store your password in the ViewModel or any other similar shenanigans.If you\'re looking for an over-architected solution, here\'s one:\n  1. Create the IHavePassword interface with one method that returns the password clear text.\n  2. Have your UserControl implement a IHavePassword interface.\n  3. Register the UserControl instance with your IoC as implementing the IHavePassword interface.\n  4. When a server request requiring your password is taking place, call your IoC for the IHavePassword implementation and only than get the much coveted password.Just my take on it. -- Justin My 2 cents:I developed once a typical login dialog (user and password boxes, plus "Ok" button) using WPF and MVVM. I solved the password binding issue by simply passing the PasswordBox control itself as a parameter to the command attached to the "Ok" button. So in the view I had:And in the ViewModel, the Execute method of the attached command was as follows:This slightly violates the MVVM pattern since now the ViewModel knows something about how the View is implemented, but in that particular project I could afford it. Hope it is useful for someone as well.Maybe I am missing something, but it seems like most of these solutions overcomplicate things and do away with secure practices. This method does not violate the MVVM pattern and maintains complete security. Yes, technically it is code behind, but it is nothing more than a "special case" binding. The ViewModel still has no knowledge of the View implementation, which in my mind it does if you are trying to pass the PasswordBox in to the ViewModel. Code Behind != Automatic MVVM violation. It all depends on what you do with it. In this case, we are just manually coding a binding, so its all considered part of the UI implementation and therefore is ok.In the ViewModel, just a simple property. I made it "write only" since there shouldn\'t be a need to retrieve it from outside the ViewModel for any reason, but it doesn\'t have to be. Note that it is a SecureString, not just a string.In the xaml, you set up a PasswordChanged event handler.In the code behind:With this method, your password remains in a SecureString at all times and therefore provides maximum security. If you really don\'t care about security or you need the clear text password for a downstream method that requires it (note: most .NET methods that require a password also support a SecureString option, so you may not really need a clear text password even if you think you do), you can just use the Password property instead. Like this:(ViewModel property)(Code behind)If you wanted to keep things strongly typed, you could substitute the (dynamic) cast with the interface of your ViewModel. But really, "normal" data bindings aren\'t strongly typed either, so its not that big a deal.So best of all worlds - your password is secure, your ViewModel just has a property like any other property, and your View is self contained with no external references required.You can use this XAML:And this command execute method:This works just fine for me.A simple solution without violating the MVVM pattern is to introduce an event (or delegate) in the ViewModel that harvests the password.In the ViewModel:public event EventHandler<HarvestPasswordEventArgs> HarvestPassword;with these EventArgs:in the View, subscribe to the event on creating the ViewModel and fill in the password value.In the ViewModel, when you need the password, you can fire the event and harvest the password from there:I posted a GIST here that is a bindable password box.This implementation is slightly different. You pass a passwordbox to the View thru binding of a property in ViewModel, it doesn\'t use any command params. The ViewModel Stays Ignorant of the View. \nI have a VB vs 2010 Project that can be downloaded from SkyDrive. Wpf MvvM PassWordBox Example.zip https://skydrive.live.com/redir.aspx?cid=e95997d33a9f8d73&resid=E95997D33A9F8D73!511The way that I am Using PasswordBox in a Wpf MvvM Application is pretty simplistic and works well for Me. That does not mean that I think it is the correct way or the best way. It is just an implementation of Using PasswordBox and the MvvM Pattern.Basicly You create a public readonly property that the View can bind to as a PasswordBox (The actual control) Example:I use a backing field just to do the self Initialization of the property.Then From Xaml you bind the Content of a ContentControl or a Control Container Example:From there you have full control of the passwordbox I also use a PasswordAccessor (Just a Function of String) to return the Password Value when doing login or whatever else you want the Password for. In the Example I have a public property in a Generic User Object Model.\nExample: In the User Object the password string property is readonly without any backing store it just returns the Password from the PasswordBox.\nExample: Then in the ViewModel I make sure that the Accessor is created and set to the PasswordBox.Password  property\'\nExample:When I need the Password string say for login I just get the User Objects Password property that really invokes the Function to grab the password and return it, then the actual password is not stored by the User Object. \nExample: would be in the ViewModelThat should Do It. The ViewModel doesn\'t need any knowledge of the View\'s Controls. The View Just binds to property in the ViewModel, not any different than the View Binding to an Image or Other Resource. In this case that resource(Property) just happens to be a usercontrol. \nIt allows for testing as the ViewModel creates and owns the Property and the Property is independent of the View.\nAs for Security I don\'t know how good this implementation is. But by using a Function the Value is not stored in the Property itself just accessed by the Property.To solve the OP problem without breaking the MVVM, I would use custom value converter and a wrapper for the value (the password) that has to be retrieved from the password box.In the view model:Because the view model uses IWrappedParameter<T>, it does not need to have any knowledge about PasswordBoxWrapper nor PasswordBoxConverter. This way you can isolate the PasswordBox object from the view model and not break the MVVM pattern.In the view:While I agree it\'s important to avoid storing the password anywhere, I still need the ability to instantiate the view model without a view and execute my tests against it.The solution that worked for me was to register the PasswordBox.Password function with the view model, and have the view model invoke it when executing the login code.This does mean a line of code in the view\'s codebehind.So, in my Login.xaml I haveand in Login.xaml.cs I havethen in LoginViewModel.cs I have the PasswordHandler definedand when login needs to happen the code invokes the handler to get the password from the view...This way, when I want to test the viewmodel I can simply set PasswordHandler to an anonymous method that lets me deliver whatever password I want to use in the test.I used this method and passed the password box, although this does violate the MVVM it was essential for me because I was using a content control with data template for my login within my shell which is a complex shell enviroment. So accessing the code behind of the shell would have been crap.Passing the passwordbox I would think is same as accessing control from code behind as far as I know. I agree passwords, dont keep in memory etc In this implementation I don\'t have property for password in view model.Button CommandViewModelI spent a great deal of time looking at various solutions. I didn\'t like the decorators idea, behaviors mess up the validation UI, code behind... really? The best one yet is to stick to a custom attached property and bind to your SecureString property in your view model. Keep it in there for as long as you can. Whenever you\'ll need quick access to the plain password, temporarily convert it to an unsecure string using the code below:Make sure you allow the GC to collect your UI element, so resist the urge of using a static event handler for the PasswordChanged event on the PasswordBox. \nI also discovered an anomaly where the control wasn\'t updating the UI when using the SecurePassword property for setting it up, reason why I\'m copying the password into Password instead. And the XAML usage:My property in the view model looked like this:The RequiredSecureString is just a simple custom validator that has the following logic:Here you have it. A complete and tested pure MVVM solution.you can do it with attached property, see it.. PasswordBox with MVVMI figured I\'d throw my solution in the mix, since this is such a common issue... and having plenty of options is always a good thing.I simply wrapped a PasswordBox in a UserControl and implemented a DependencyProperty to be able to bind.  I\'m doing everything I can to avoid storing any clear text in the memory, so everything is done through a SecureString and the PasswordBox.Password property.  During the foreach loop, each character does get exposed, but it\'s very brief.  Honestly, if you\'re worried about your WPF application to be compromised from this brief exposure, you\'ve got bigger security issues that should be handled.The beauty of this is that you are not breaking any MVVM rules, even the "purist" ones, since this is a UserControl, so it\'s allowed to have code-behind.  When you\'re using it, you can have pure communication between View and ViewModel without your VideModel being aware of any part of View or the source of the password.  Just make sure you\'re binding to SecureString in your ViewModel.BindablePasswordBox.xamlBindablePasswordBox.xaml.cs (Version 1 - No two-way binding support.)Usage of Version 1:BindablePasswordBox.xaml.cs (Version 2 - Has two-way binding support.)Usage of Version 2:In windows universal appyou can use this code with the property "Password" and binding with the modelViewIts very simple . Create another property for password and Bind this with TextBoxBut all input operations perform with actual password propertyprivate string _Password;public string Password\n        {\n            get\n            {\n                return _Password;\n            }As you can see i am binding to Password, but maybe its bind it to the static class..It is an attached property. This kind of property can be applied to any kind of DependencyObject, not just the type in which it is declared. So even though it is declared in the PasswordHelper static class, it is applied to the PasswordBox on which you use it.To use this attached property, you just need to bind it to the Password property in your ViewModel :As mentioned before VM should be unaware of the View but passing whole PasswordBox looks like the simplest approach. So maybe instead of casting passed parameter to PasswordBox use Reflection to extract Password property from it. In this case VM expects some kind of Password Container with property Password(I\'m ussing RelayCommands from MVMM Light-Toolkit):It can be easily tested with anonymous class:For anyone who is aware of the risks this implementation imposes, to have the password sync to your ViewModel simply add Mode=OneWayToSource.XAMLYou find a solution for the PasswordBox in the ViewModel sample application of the WPF Application Framework (WAF) project.However, Justin is right. Don\'t pass the password as plain text between View and ViewModel. Use SecureString instead (See MSDN PasswordBox).I have done like:XAML:C#:It works for me!I used an authentication check followed by a sub called by a mediator class to the View (which also implements an authentication check) to write the password to the data class.It\'s not a perfect solution; however, it remedied my problem of not being able to move the password.I am using succinct MVVM-friendly solution that hasn\'t been mentioned yet. First, I name the PasswordBox in XAML:Then I add a single method call into view constructor:And that\'s it. View model will receive notification when it is attached to a view via DataContext and another notification when it is detached. The contents of this notification are configurable via the lambdas, but usually it\'s just a setter or method call on the view model, passing the problematic control as a parameter.It can be made MVVM-friendly very easily by having the view expose interface instead of child controls.The above code relies on helper class published on my blog.I spent ages trying to get this working. In the end, I gave up and just used the PasswordBoxEdit from DevExpress.It is the simplest solution ever, as it allows binding without pulling any horrible tricks.Solution on DevExpress websiteFor the record, I am not affiliated with DevExpress in any way.To me, both of these things feel wrong:Transferring the SecurePassword (SecureString instance) as described by Steve in CO seems acceptable. I prefer Behaviors to code behind, and I also had the additional requirement of being able to reset the password from the viewmodel.Xaml (Password is the ViewModel property):Behavior:;) easy! well my answerd is more simple just in the for the MVVM patternin class viewmodelthe password property of the PasswordBox that win provides or WatermarkPasswordBox that XCeedtoolkit provides generates an RoutedEventArgs so you can bind it.now in xmal viewor