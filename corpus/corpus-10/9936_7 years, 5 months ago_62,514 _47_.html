LINQ:Is it more efficient to use the Single() operator over First() when ever I know for certain that the query will return a single record?Is there a difference?I know others have written why you use one or the other, but I thought I\'d illustrate why you should NOT use one, when you mean the other.Note: In my code, I will typically use FirstOrDefault() and SingleOrDefault() but that\'s a different question.Take, for example, a table that stores Customers in different languages using a Composite Key ( ID, Lang ): This code above introduces a possible logic error ( difficult to trace ). It will return more than one record ( assuming you have the customer record in multiple languages ) but it will always return only the first one... which may work sometimes... but not others. It\'s unpredictable.Since your intent is to return a Single Customer use Single();The following would throw an exception ( which is what you want in this case ):Then, you simply hit yourself on the forehead and say to yourself... OOPS! I forgot the language field! Following is the correct version:First() is useful in the following scenario:It will return ONE object, and since you\'re using sorting, it will be the most recent record  that is returned.Using Single() when you feel it should explicitly always return 1 record will help you avoid logic errors.Single will throw an exception if it finds more than one record matching the criteria. \nFirst will always select the first record from the list. If the query returns just 1 record, you can go with First(). Both will throw an InvalidOperationException exception if the collection is empty. \nAlternatively you can use SingleOrDefault(). This won\'t throw an exception if the list is emptyThere is a subtle, semantic difference between these two methods.Use Single to retrieve the first (and only) element from a sequence that should contain one element and no more.  If the sequence has more than on element your invocation of Single will cause an exception to be thrown since you indicated that there should only be one element.Use First to retrieve the first element from a sequence that can contain any number of elements.  If the sequence has more than on element your invocation of First will not cause an exception to be thrown since you indicated that you only need the first element in the sequence and do not care if more exist.If the sequence contains no elements both method calls will cause exceptions to be thrown since both methods expect at least one element to be present.If I recall, Single() checks if there is another element after the first one (and throws an exception if it\'s the case), while First() stops after getting it. Both throw an exception if the sequence is empty.Personnally, I always use First().Single()Returns a single specific element of a queryWhen Use: If exactly 1 element is expected; not 0 or more than 1. If the list is empty or has more than one element, it will throw an Exception "Sequence contains more than one element"SingleOrDefault()Returns a single specific element of a query, or a default value if no result foundWhen Use: When 0 or 1 elements are expected. It will throw an exception if the list has 2 or more items.First()Returns the first element of a query with multiple results.When Use:  When 1 or more elements are expected and you want only the first. It will throw an exception if the list contains no elements.FirstOrDefault()Returns the first element of a list with any amount of elements, or a default value if the list is empty.When Use: When multiple elements are expected and you want only the first. Or the list is empty and you want a default value for the specified type, the same as default(MyObjectType). For example: if the list type is list<int> it will return the first number from the list or 0 if the list is empty. If it is list<string>, it will return the first string from the list or null if the list is empty.If you don\'t specifically want an exception thrown in the event that there is more than one item, use First().Both are efficient, take the first item.  First() is slightly more efficient because it doesn\'t bother checking to see if there is a second item.The only difference is that Single() expects there to be only one item in the enumeration to begin with, and will throw an exception if there are more than one.  You use .Single() if you specifically want an exception thrown in this case.Regarding peformance: A coworker and I were discussing the performance of Single vs First (or SingleOrDefault vs FirstOrDefault), and I was arguing for the point that First (or FirstOrDefault) would be faster and improve performance (I\xe2\x80\x99m all about making our app run faster).I\xe2\x80\x99ve read several posts on Stack Overflow that debate this. Some say there are small performance gains using First instead of Single. This is because First would simply return the first item while Single must scan all the results to make sure there isn\xe2\x80\x99t a duplicate (ie: if it found the item in the first row of the table, it still would scan every other row to make sure there isn\xe2\x80\x99t a second value matching the condition which would then throw an error).  I felt like I was on solid ground with \xe2\x80\x9cFirst\xe2\x80\x9d being faster than \xe2\x80\x9cSingle\xe2\x80\x9d so I set out to prove it and put the debate to rest.I setup a test in my database and added 1,000,000 rows of \n    ID  UniqueIdentifier\n    Foreign UniqueIdentifier\n    Info nvarchar(50)  (filled with strings of numbers \xe2\x80\x9c0\xe2\x80\x9d to \xe2\x80\x9c999,9999\xe2\x80\x9d I loaded the data and set ID as a primary key field.Using LinqPad, my goal was to show that if you searched for a value on \xe2\x80\x98Foreign\xe2\x80\x99 or \xe2\x80\x98Info\xe2\x80\x99 using Single, that it would be much worse than using First.I cannot explain the results I got. In almost every case, using Single or SingleOrDefault was slightly faster.  This doesn\xe2\x80\x99t make any logical sense to me, but I wanted to share that.Ex: I used the following queries:I tried similar queries on the \'Foreign\' key field which was not indexed thinking that would prove First is faster, but Single was always slightly faster in my tests.They are different.  Both of them assert that the result set is not empty, but single also asserts that there is not more than 1 result.  I personally use Single in cases where I only expect there to be 1 result just because getting more than 1 result back is an error and probably should be treated as such.A lot of people I know use FirstOrDefault(), but I tend to use SingleOrDefault() more because often it would be some sort of data inconsistency if there were more than one.  This is dealing with LINQ-to-Objects, though.You can try simple example to get difference.\nException will thrown on line 3;