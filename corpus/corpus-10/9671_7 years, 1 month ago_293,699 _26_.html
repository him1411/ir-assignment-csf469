This question already has an answer here:How do I calculate the time taken for the execution of a method in Java?You can take timestamp snapshots before and after, then repeat the experiments several times to average to results. There are also profilers that can do this for you.With System.currentTimeMillis()With a StopWatch classYou can use this StopWatch class, and call start() and stop before and after the method.See here.Application Performance ApplicationPerformance profiles method-level CPU\n  performance (execution time). You can\n  choose to profile the entire\n  application or a part of the\n  application.See here.To be more precise, I would use nanoTime() method rather than currentTimeMillis():In Java 8 (output format is ISO-8601): Guava Stopwatch:In case you develop applications for Android you should try out the TimingLogger class.\nTake a look at these articles describing the usage of the TimingLogger helper class:Check this: System.currentTimeMillis.With this you can calculate the time of your method by doing:You might want to think about aspect-oriented programming.  You don\'t want to litter your code with timings.  You want to be able to turn them off and on declaratively.If you use Spring, take a look at their MethodInterceptor class.If you are currently writing the application, than the answer is to use System.currentTimeMillis or System.nanoTime serve the purpose as pointed by people above. But if you have already written the code, and you don\'t want to change it its better to use Spring\'s method interceptors. So for instance your service is :To avoid changing the service, you can write your own method interceptor:Also there are open source APIs available for Java, e.g. BTrace.\nor Netbeans profiler as suggested above by @bakkal and @Saikikos.\nThanks.As proposed nanoTime () is very precise on short time scales.\nWhen this precision is required you need to take care about what you really measure.\nEspecially not to measure the nanotime call itselfBy the way, you will measure different values for the same call due toNanotime is in fact not even good for elapsed time because it drifts away signficantly more than currentTimeMillis.  Furthermore nanotime tends to provide excessive precision at the expense of accuracy.  It is therefore highly inconsistent,and needs refinement.For any time measuring process,currentTimeMillis (though almost as bad), does better in terms of balancing accuracy and precision.  