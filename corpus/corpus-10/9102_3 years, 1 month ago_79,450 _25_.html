Difference between spring @Controller and @RestController annotation.Can @Controller annotation be used for both Web MVC and REST applications?\nIf yes, how can we differentiate if it is Web MVC or REST application.So the following two controller definitions should do the samein the code below I\'ll show you the difference\nwith  @controllerwith @RestController the  @ResponseBody is activate by default you don\'t need to add it in the above of function signature@RestController annotated classes are the same as @Controller but the @ResponseBody on the handler methods are implied.Actually, be careful - they are not exactly the same.If you define any interceptors within your application, they will not apply to Controllers annotated as @RestController, however they do work with @Controller annotated controllers.ie. configuration for the interceptor:and in the declaration of a Spring controller:Will work, howeverdoes not end up having the interceptor being associated with it.As you can see in Spring documentation (Spring RestController Documentation) Rest Controller annotation is the same as Controller annotation, but assuming that @ResponseBody is active by default, so all the json are parsed to java objects.If you use @RestController you cannot return a view (By using Viewresolver in Spring/springboot) and yes @ResponseBody is not needed in this case.If you use @controller you can return a view in Spring webMVC.THE new @RestController annotation in Spring4+, which marks the class as a controller where every method returns a domain object instead of a view. It\xe2\x80\x99s shorthand for @Controller and @ResponseBody rolled together.@RestController was provided since Spring 4.0.1. These controllers indicate that here @RequestMapping methods assume @ResponseBody semantics by default.In earlier versions the similar functionality could be achieved by using below:@RequestMapping coupled with @ResponseBody like @RequestMapping(value = "/abc", method = RequestMethod.GET, produces ="application/xml")\n    public @ResponseBody MyBean fetch(){\n return new MyBean("hi")\n }<mvc:annotation-driven/> may be used as one of the ways for using JSON with  Jackson or xml.@XmlRootElement(name = "MyBean")\n @XmlType(propOrder = {"field2", "field1"})\n    public class MyBean{\n     field1\n     field2 ..\n    //getter, setter\n    }\nHowever, the Restcontroller is already coupled with ResponseBody and the respective converters. Secondly, here, since instead of converting the responsebody, it is automatically converted to http response.@RestController is composition of @Controller and @ResponseBody, if we are not using the @ResponseBody in Method signature then we need to use the @Restcontroller.Instead of using @Controller and @ResponseBody, @RestController let\'s you expose Rest APIs in Spring 4.0 and above.