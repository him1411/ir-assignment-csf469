I\'m doing a small research of mobile platforms and I would like to know which design patterns are used in Android?e.g. in iOS Model-view-controller is very widely used together with delegation and other patterns. What patterns and where in particular does Android use?EDITI\'m not asking for design patterns used deep in kernel, dalvik and so on, but about patterns which an application developer will meet while developing an application.I tried using both the model\xe2\x80\x93view\xe2\x80\x93controller (MVC) and model\xe2\x80\x93view\xe2\x80\x93presenter design patterns for doing android development. My findings are model\xe2\x80\x93view\xe2\x80\x93controller works fine, but there are a couple of "issues". It all comes down to how you perceive the Android Activity class. Is it a controller, or is it a view?The actual Activity class doesn\'t extend Android\'s View class, but it does, however, handle displaying a window to the user and also handle the events of that window (onCreate, onPause, etc.).This means, that when you are using an MVC pattern, your controller will actually be a pseudo view\xe2\x80\x93controller. Since it is handling displaying a window to the user, with the additional view components you have added to it with setContentView, and also handling events for at least the various activity life cycle events.In MVC, the controller is supposed to be the main entry point. Which is a bit debatable if this is the case when applying it to Android development, since the activity is the natural entry point of most applications.Because of this, I personally find that the model\xe2\x80\x93view\xe2\x80\x93presenter pattern is a perfect fit for Android development. Since the view\'s role in this pattern is:This allows you to implement your model like so:View - this contains your UI components, and handles events for them.Presenter - this will handle communication between your model and your view, look at it as a gateway to your model. Meaning, if you have a complex domain model representing, God know what, and your view only needs a very small subset of this model, the presenters job is to query the model and then update the view. For example, if you have a model containing a paragraph of text, a headline and a word-count. But in a given view, you only need to display the headline in the view. Then the presenter will read the data needed from the model, and update the view accordingly.Model - this should basically be your full domain model. Hopefully it will help making your domain model more "tight" as well, since you won\'t need special methods to deal with cases as mentioned above.By decoupling the model from the view all together (through use of the presenter), it also becomes much more intuitive to test your model. You can have unit tests for your domain model, and unit tests for your presenters.Try it out. I personally find it a great fit for Android development.This answer was updated in order to remain relevant as of November 2016It looks like you are seeking for architectural patterns rather than design patterns.Design patterns aim at describing a general "trick" that programmer might implement for handling a particular set of recurring software tasks. For example: In OOP, when there is a need for an object to notify a set of other objects about some events, the observer design pattern can be employed.Since Android applications (and most of AOSP) are written in Java, which is object-oriented, I think you\'ll have a hard time looking for a single OOP design pattern which is NOT used on Android.Architectural patterns, on the other hand, do not address particular software tasks - they aim to provide templates for software organization based on the use cases of the software component in question.It sounds a bit complicated, but I hope an example will clarify: If some application will be used to fetch data from a remote server and present it to the user in a structured manner, then MVC might be a good candidate for consideration. Note that I said nothing about software tasks and program flow of the application - I just described it from user\'s point of view, and a candidate for an architectural pattern emerged.Since you mentioned MVC in your question, I\'d guess that architectural patterns is what you\'re looking for.Historically, there were no official guidelines by Google about applications\' architectures, which (among other reasons) led to a total mess in the source code of Android apps. In fact, even today most applications that I see still do not follow OOP best practices and do not show a clear logical organization of code.But today the situation is different - Google recently released the Data Binding library, which is fully integrated with Android Studio, and, even, rolled out a set of architecture blueprints for Android applications.Two years ago it was very hard to find information about MVC or MVP on Android. Today, MVC, MVP and MVVM has become "buzz-words" in the Android community, and we are surrounded by countless experts which constantly try to convince us that MVx is better than MVy. In my opinion, discussing whether MVx is better than MVy is totally pointless because the terms themselves are very ambiguous - just look at the answers to this question, and you\'ll realize that different people can associate these abbreviations with completely different constructs.Due to the fact that a search for a best architectural pattern for Android has officially been started, I think we are about to see several more ideas come to light. At this point, it is really impossible to predict which pattern (or patterns) will become industry standards in the future - we will need to wait and see (I guess it is matter of a year or two).However, there is one prediction I can make with a high degree of confidence: Usage of the Data Binding library will not become an industry standard. I\'m confident to say that because the Data Binding library (in its current implementation) provides short-term productivity gains and some kind of architectural guideline, but it will make the code non-maintainable in the long run. Once long-term effects of this library will surface - it will be abandoned.Now, although we do have some sort of official guidelines and tools today, I, personally, don\'t think that these guidelines and tools are the best options available (and they are definitely not the only ones). In my applications I use my own implementation of an MVC architecture. It is simple, clean, readable and testable, and does not require any additional libraries.This MVC is not just cosmetically different from others - it is based on a theory that Activities in Android are not UI Elements, which has tremendous implications on code organization.So, if you\'re looking for a good architectural pattern for Android applications that follows SOLID principles, you can find a description of one in my post about MVC and MVP architectural patterns in Android.There are various patterns used in Android framework like:Here is a great article on Common Design Patterns for Android: Creational patterns:Structural patterns:Behavioral patterns:The Following Android Classes uses Design Patterns1) View Holder uses Singleton Design Pattern 2) Intent uses Factory Design Pattern 3) Adapter uses Adapter Design Pattern 4) Broadcast Receiver uses Observer Design Pattern 5) View uses Composite Design Pattern 6) Media FrameWork uses Fa\xc3\xa7ade Design Pattern When i reach this post it really help me to understand patterns with example so i have make below table to clearly see the Design patterns & their example in Android FrameworkI hope you will find it helpful.In the Notifications case, the NotificationCompat.Builder uses Builder Patternlike,Android also uses the ViewHolder design pattern.It\'s used to improve performance of a ListView while scrolling it.The ViewHolder design pattern enables you to access each list item view without the need for the look up, saving valuable processor cycles. Specifically, it avoids frequent calls of findViewById() during ListView scrolling, and that will make it smooth.All these patterns, MVC, MVVM, MVP, and Presentation Model, can be applied to Android apps, but without a third-party framework, it is not easy to get well-organized structure and clean code.MVVM is originated from PresentationModel. When we apply MVC, MVVM, and Presentation Model to an Android app, what we really want is to have a clear structured project and more importantly easier for unit tests.At the moment, without an third-party framework, you usually have lots of code (like addXXListener(), findViewById(), etc.), which does not add any business value. What\'s more, you have to run Android unit tests instead of normal JUnit tests, which take ages to run and make unit tests somewhat impractical.For these reasons, some years ago we started an open source project, RoboBinding - A data-binding Presentation Model framework for the Android platform. RoboBinding helps you write UI code that is easier to read, test, and maintain. RoboBinding removes the need of unnecessary code like addXXListener or so, and shifts UI logic to the Presentation Model, which is a POJO and can be tested via normal JUnit tests. RoboBinding itself comes with more than 300 JUnit tests to ensure its quality.I would like to add a design pattern that has been applied in Android Framework. This is Half Sync Half Async pattern used in the Asynctask implementation. See my discussion at https://docs.google.com/document/d/1_zihWXAwgTAdJc013-bOLUHPMrjeUBZnDuPkzMxEEj0/edit?usp=sharingIn Android the "work queue processor" pattern is commonly used to offload tasks from an application\'s main thread. Example: The design of the IntentService class.The  IntentService  receives the Intents, launch a worker thread, and stops the service as appropriate.All requests are handled on a single worker thread.Binder uses "Observer Pattern" for Death Recipient notifications.