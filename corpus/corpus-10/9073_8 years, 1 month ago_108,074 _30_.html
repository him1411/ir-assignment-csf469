I was wondering how to use GCC on my C source file to dump a mnemonic version of the machine code so I could see what my code was being compiled into. You can do this with Java but I haven\'t been able to find a way with GCC.I am trying to re-write a C method in assembly and seeing how GCC does it would be a big help.If you compile with debug symbols, you can use objdump to produce a more readable disassembly.Example:I would like to add to these answers that if you give gcc the flag -fverbose-asm, the assembler it emits will be a lot clearer to read.Use the -S (note: capital S) switch to GCC, and it will emit the assembly code to a file with a .s extension. For example, the following command:gcc -O2 -S foo.cwill leave the generated assembly code on the file foo.s.Ripped straight from http://www.delorie.com/djgpp/v2faq/faq8_20.html (but removing erroneous -c)It would be safe to let others know, that the -S switch to GCC on x86 based systems produces a dump of AT&T syntax, by default, by can be specified with the -masm=att switch, as so:Whereas if you\'d like to produce a dump of intel syntax, you could use the -masm=intel switch, as so:(Both produce dumps of code.c into their various syntax, into the file code.s respectively)In order to produce similar effects with objdump, you\'d want to use the disassembler-options=intel/att switch, an example (with code dumps to illustrate the differences in syntax):godbolt is a very useful tool, they list only has C++ compilers but you can use -x c flag in order to get it treat the code as C. It will then generate an assembly listing for your code side by side and you can use the Colourise option to generate colored bars to visually indicate which source code maps to the generated assembly. For example the following code:using the following command line:and Colourise would generate the following:You can use gdb for this like objdump. This excerpt is taken from http://sources.redhat.com/gdb/current/onlinedocs/gdb_9.html#SEC64Here is an example showing mixed source+assembly for Intel x86: Did you try gcc -S -fverbose-asm -O source.c then look into the generated source.s assembler file ?The generated assembler code goes into source.s (you could override that with -o assembler-filename ); the -fverbose-asm option asks the compiler to emit some assembler comments "explaining" the generated assembler code. The -O option asks the compiler to optimize a bit (it could optimize more with -O2 or -O3).If you want to understand what gcc is doing try passing -fdump-tree-all but be cautious: you\'ll get hundreds of dump files.BTW, GCC is extensible thru plugins or with MELT (a high level domain specific language to extend GCC).Use the -S (note: capital S) switch to GCC, and it will emit the assembly code to a file with a .s extension. For example, the following command:gcc -O2 -S -c foo.cI haven\'t given a shot to gcc, but in case of g++. The command below works for me. -g for debug build and -Wa,-adhln is passed to assembler for listing with source codeg++ -g -Wa,-adhln src.cpp