In the Go Language Specification, it mentions a brief overview of tags: A field declaration may be followed by an optional string literal tag,\n  which becomes an attribute for all the fields in the corresponding\n  field declaration. The tags are made visible through a reflection\n  interface but are otherwise ignored.This is a very short explanation IMO, and I was wondering if anyone could provide me with what use these tags would be?A tag for a field allows you to attach meta-information to the field which can be acquired using reflection. Usually it is used to provide transformation info on how a struct field is encoded to or decoded from another format (or stored/retrieved from a database), but you can use it to store whatever meta-info you want to, either intended for another package or for your own use.As mentioned in the documentation of reflect.StructTag, by convention the value of a tag string is a space-separated key:"value" pairs, for example:The key usually denotes the package that the subsequent "value" is for, for example json keys are processed/used by the encoding/json package.If multiple information is to be passed in the "value", usually it is specified by separating it with a comma (\',\'), e.g.Usually a dash value (\'-\') for the "value" means to exclude the field from the process (e.g. in case of json it means not to marshal or unmarshal that field).We can use reflection (reflect package) to access the tag values of struct fields. Basically we need to acquire the Type of our struct, and then we can query fields e.g. with Type.Field(i int) or Type.FieldByName(name string). These methods return a value of StructField which describe / represent a struct field; and StructField.Tag is a value of type StructTag which describes / represents a tag value.Previously we talked about "convention". This convention means that if you follow it, you may use the StructTag.Get(key string) method which parses the value of a tag and returns you the "value" of the key you specify. The convention is implemented / built into this Get() method. If you don\'t follow the convention, Get() will not be able to parse key:"value" pairs and find what you\'re looking for. That\'s also not a problem, but then you need to implement your own parsing logic.Also there is StructTag.Lookup() (was added in Go 1.7) which is "like Get() but distinguishes the tag not containing the given key from the tag associating an empty string with the given key".So let\'s see a simple example:Output (try it on the Go Playground):GopherCon 2015 had a presentation about struct tags called:The Many Faces of Struct Tags (slide) (and a video)Here is a really simple example of tags being used with the encoding/json package to control how fields are interpreted during encoding and decoding:Try live: http://play.golang.org/p/BMeR8p1cKfThe json package can look at the tags for the field and be told how to map json <=> struct field, and also extra options like whether it should ignore empty fields when serializing back to json. Basically, any package can use reflection on the fields to look at tag values and act on those values. There is a little more info about them in the reflect package\nhttp://golang.org/pkg/reflect/#StructTag :By convention, tag strings are a concatenation of optionally\n  space-separated key:"value" pairs. Each key is a non-empty string\n  consisting of non-control characters other than space (U+0020 \' \'),\n  quote (U+0022 \'"\'), and colon (U+003A \':\'). Each value is quoted using\n  U+0022 \'"\' characters and Go string literal syntax.