When should unions be used? Why do we need them?Unions are often used to convert between the binary representations of integers and floats:Although this is technically undefined behavior according to the C standard (you\'re only supposed to read the field which was most recently written), it will act in a well-defined manner in virtually any compiler.Unions are also sometimes used to implement pseudo-polymorphism in C, by giving a structure some tag indicating what type of object it contains, and then unioning the possible types together:This allows the size of struct S to be only 12 bytes, instead of 28.Unions are particularly useful in Embedded programming or in situations where direct access to the hardware/memory is needed. Here is a trivial example:Then you can access the reg as follows:Endianness (byte order) and processor architecture are of course important.Another useful feature is the bit modifier:With this code you can access directly a single bit in the register/memory address:Low level system programming is a reasonable example.IIRC, I\'ve used unions to breakdown hardware registers into the component bits. So, you can access an 8-bit register (as it was, in the day I did this ;-) into the component bits.(I forget the exact syntax but...) This structure would allow a control register to be accessed as a control_byte or via the individual bits. It would be important to ensure the bits map on to the correct register bits for a given endianness.I\'ve seen it in a couple of libraries as a replacement for object oriented inheritance.E.g.If you want the Connection "class" to be either one of the above, you could write something like:Example use in libinfinity: http://git.0x539.de/?p=infinote.git;a=blob;f=libinfinity/common/inf-session.c;h=3e887f0d63bd754c6b5ec232948027cbbf4d61fc;hb=HEAD#l74Unions allow data members which are mutually exclusive to share the same memory.  This is quite important when memory is more scarce, such as in embedded systems.In the following example:This union will take up the space of a single int, rather than 3 separate int values.  If the user set the value of a, and then set the value of b, it would overwrite the value of a since they are both sharing the same memory location.Lots of usages. Just do grep union /usr/include/* or in similar directories. Most of the cases the union is wrapped in a struct and one member of the struct tells which element in the union to access. For example checkout man elf for real life implementations.This is the basic principle:Here\'s an example of a union from my own codebase (from memory and paraphrased so it may not be exact).  It was used to store language elements in an interpreter I built.  For example, the following code:consists of the following language elements:Language elements were defines as \'#define\' values thus:and the following structure was used to store each element:then the size of each element was the size of the maximum union (4 bytes for the type and 4 bytes for the union, though those are typical values, the actual sizes cepend on the implementation).In order to create a "set" element, you would use:In order to create a "variable[b]" element, you would use:In order to create a "constant[7]" element, you would use:and you could easily expand it to include floats (float flt) or rationals (struct ratnl {int num; int denom;}) and other types.The basic premise is that the str and val are not contiguous in memory, they actually overlap, so it\'s a way of getting a different view on the same block of memory, illustrated here, where the structure is based at memory location 0x1010 and integers and pointers are both 4 bytes:If it were just in a structure, it would look like this:I\'d say it makes it easier to reuse memory that might be used in different ways, i.e. saving memory. E.g. you\'d like to do some "variant" struct that\'s able to save a short string as well as a number:In a 32 bit system this would result in at least 96 bits or 12 bytes being used for each instance of variant.Using an union you can reduce the size down to 64 bits or 8 bytes:You\'re able to save even more if you\'d like to add more different variable types etc. It might be true, that you can do similar things casting a void pointer - but the union makes it a lot more accessible as well as type safe. Such savings don\'t sound massive, but you\'re saving one third of the memory used for all instances of this struct.Unions are used when you want to model structs defined by hardware, devices or network protocols, or when you\'re creating a large number of objects and want to save space. You really don\'t need them 95% of the time though, stick with easy-to-debug code.It\'s difficult to think of a specific occasion when you\'d need this type of flexible structure, perhaps in a message protocol where you would be sending different sizes of messages, but even then there are probably better and more programmer friendly alternatives.Unions are a bit like variant types in other languages - they can only hold one thing at a time, but that thing could be an int, a float etc. depending on how you declare it.For example:MyUnion will only contain an int OR a float, depending on which you most recently set. So doing this:u now holds an int equal to 10;u now holds a float equal to 1.0. It no longer holds an int. Obviously now if you try and do printf("MyInt=%d", u.MyInt); then you\'re probably going to get an error, though I\'m unsure of the specific behaviour.The size of the union is dictated by the size of its largest field, in this case the float.Many of these answers deal with casting from one type to another.  I get the most use from unions with the same types just more of them (ie when parsing a serial data stream).  They allow the parsing / construction of a framed packet to become trivial.Edit \nThe comment about endianness and struct padding are valid, and great, concerns.  I have used this body of code almost entirely in embedded software, most of which I had control of both ends of the pipe.What about VARIANT that is used in COM interfaces? It has two fields - "type" and a union holding an actual value that is treated depending on "type" field.In school, I used unions like this:I used it to handle colors more easily, instead of using >> and << operators, I just had to go through the different index of my char array.I used union when I was coding for embedded devices. I have C int that is 16 bit long. And I need to retrieve the higher 8 bits and the lower 8 bits when I need to read from/store to EEPROM. So I used this way:It doesn\'t require shifting so the code is easier to read.On the other hand, I saw some old C++ stl code that used union for stl allocator. If you are interested, you can read the sgi stl source code. Here is a piece of it:Take a look at this: X.25 buffer command handlingOne of the many possible X.25 commands is received into a buffer and handled in place by using a UNION of all the possible structures.In early versions of C, all structure declarations would share a common set of fields.  Given:a compiler would essentially produce a table of structures\' sizes (and possibly alignments), and a separate table of structures\' members\' names, types, and offsets.  The compiler didn\'t keep track of which members belonged to which structures, and would allow two structures to have a member with the same name only if the type and offset matched (as with member q of struct x and struct y).  If p was a pointer to any structure type, p->q would add the offset of "q" to pointer p and fetch an "int" from the resulting address.Given the above semantics, it was possible to write a function that could perform some useful operations on multiple kinds of structure interchangeably, provided that all the fields used by the function lined up with useful fields within the structures in question.  This was a useful feature, and changing C to validate members used for structure access against the types of the structures in question would have meant losing it in the absence of a means of having a structure that can contain multiple named fields at the same address.  Adding "union" types to C helped fill that gap somewhat (though not, IMHO, as well as it should have been).An essential part of unions\' ability to fill that gap was the fact that a pointer to a union member could be converted into a pointer to any union containing that member, and a pointer to any union could be converted to a pointer to any member.  While the C89 Standard didn\'t expressly say that casting a T* directly to a U* was equivalent to casting it to a pointer to any union type containing both T and U, and then casting that to U*, no defined behavior of the latter cast sequence would be affected by the union type used, and the Standard didn\'t specify any contrary semantics for a direct cast from T to U.  Further, in cases where a function received a pointer of unknown origin, the behavior of writing an object via T*, converting the T* to a U*, and then reading the object via U* would be equivalent to writing a union via member of type T and reading as type U, which would be standard-defined in a few cases (e.g. when accessing Common Initial Sequence members) and Implementation-Defined (rather than Undefined) for the rest.  While it was rare for programs to exploit the CIS guarantees with actual objects of union type, it was far more common to exploit the fact that pointers to objects of unknown origin had to behave like pointers to union members and have the behavioral guarantees associated therewith.Unions are great. One clever use of unions I\'ve seen is to use them when defining an event. For example, you might decide that an event is 32 bits.Now, within that 32 bits, you might like to designate the first 8 bits as for an identifier of the sender of the event... Sometimes you deal with the event as a whole, sometimes you dissect it and compare it\'s components. unions give you the flexibility to do both.A simple and very usefull example, is....Imagine:you have a uint32_t array[2] and want to access the 3rd and 4th Byte of the Byte chain.\nyou could do *((uint16_t*) &array[1]).\nBut this sadly breaks the strict aliasing rules!But known compilers allow you to do the following :technically this is still a violation of the rules. but all known standards support this usage.