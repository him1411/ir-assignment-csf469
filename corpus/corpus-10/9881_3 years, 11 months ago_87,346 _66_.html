I followed this thread to override -preferredStatusBarStyle, but it isn\'t called. \nAre there any options that I can change to enable it? (I\'m using XIBs in my project.)I had the same problem, and figured out it was happening because I wasn\'t setting the root view controller in my application window. The UIViewController in which I had implemented the preferredStatusBarStyle was used in a UITabBarController, which controlled the appearance of the views on the screen.When I set the root view controller to point to this UITabBarController, the status bar changes started to work correctly, as expected (and the preferredStatusBarStyle method was getting called).Alternatively, you can call one of the following methods, as appropriate, in each of your view controllers, depending on its background color, instead of having to use setNeedsStatusBarAppearanceUpdate:orNote that you\'ll also need to set UIViewControllerBasedStatusBarAppearance to NO in the plist file if you use this method.For anyone using a UINavigationController:The UINavigationController does not forward on preferredStatusBarStyle calls to its child view controllers. Instead it manages its own state - as it should, it is drawing at the top of the screen where the status bar lives and so should be responsible for it. Therefor implementing preferredStatusBarStyle in your VCs within a nav controller will do nothing - they will never be called.The trick is what the UINavigationController uses to decide what to return for UIStatusBarStyleDefault or UIStatusBarStyleLightContent. It bases this on it\'s UINavigationBar.barStyle. The default (UIBarStyleDefault) results in the dark foreground UIStatusBarStyleDefault status bar. And UIBarStyleBlack will give a UIStatusBarStyleLightContent status bar.TL;DR:If you want UIStatusBarStyleLightContent on a UINavigationController use:So I actually added a category to UINavigationController but used the methods: and had those return the current visible UIViewController. That lets the current visible view controller set its own preferred style/visibility.Here\'s a complete code snippet for it:In Swift:In Objective-C:And for good measure, here\'s how it\'s implemented then in a UIViewController:In SwiftIn Objective-CFinally, make sure your app plist does NOT have the "View controller-based status bar appearance" set to NO. Either delete that line or set it to YES (which I believe is the default now for iOS 7?)Tyson\'s answer is correct for changing the status bar color to white in UINavigationController.If anyone want\'s to accomplish the same result by writing the code in AppDelegate then use below code and write it inside AppDelegate\'s didFinishLaunchingWithOptions method.And don\'t forget to set the UIViewControllerBasedStatusBarAppearance to YES in the .plist file, else the change will not reflect.For anyone still struggling with this, this simple extension in swift should fix the problem for you.An addition to Hippo\'s answer: if you\'re using a UINavigationController, then it\'s probably better to add a category:That solution is probably better than switching to soon-to-be deprecated behaviour.UIStatusBarStyle in iOS 7The status bar in iOS 7 is transparent, the view behind it shows through.The style of the status bar refers to the appearances of its content. In iOS 7, the status bar content is either dark (UIStatusBarStyleDefault) or light (UIStatusBarStyleLightContent). Both UIStatusBarStyleBlackTranslucent and UIStatusBarStyleBlackOpaque are deprecated in iOS 7.0. Use UIStatusBarStyleLightContent instead.How to change UIStatusBarStyleIf below the status bar is a navigation bar, the status bar style will be adjusted to match the navigation bar style (UINavigationBar.barStyle):Specifically, if the navigation bar style is UIBarStyleDefault, the status bar style will be UIStatusBarStyleDefault; if the navigation bar style is UIBarStyleBlack, the status bar style will be UIStatusBarStyleLightContent.If there is no navigation bar below the status bar, the status bar style can be controlled and changed by an individual view controller while the app runs.-[UIViewController preferredStatusBarStyle] is a new method added in iOS 7. It can be overridden to return the preferred status bar style:If the status bar style should be controlled by a child view controller instead of self, override -[UIViewController childViewControllerForStatusBarStyle] to return that child view controller.If you prefer to opt out of this behavior and set the status bar style by using the -[UIApplication statusBarStyle] method, add the UIViewControllerBasedStatusBarAppearance key to an app\xe2\x80\x99s Info.plist file and give it the value NO.@serenn\'s answer above is still a great one for the case of UINavigationControllers. However, for swift 3 the childViewController functions have been changed to vars. So the UINavigationController extension code should be: And then in the view controller that should dictate the status bar style: If your viewController is under UINavigationController.Subclass UINavigationController and addViewController\'s preferredStatusBarStyle will be called.Swift 3 iOS 10 Solution:If anyone is using a Navigation Controller and wants all of their navigation controllers to have the black style, you can write an extension to UINavigationController like this in Swift 3 and it will apply to all navigation controllers (instead of assigning it to one controller at a time).Here\'s my method for solving this.Define a protocol called AGViewControllerAppearance.AGViewControllerAppearance.hDefine a category on UIViewController called Upgrade.UIViewController+Upgrade.hUIViewController+Upgrade.mNow, it\'s time to say that you\'re view controller is implementing the AGViewControllerAppearance protocol.Example:Of course, you can implement the rest of the methods (showsStatusBar, animatesStatusBarVisibility, prefferedStatusBarAnimation) from the protocol and UIViewController+Upgrade will do the proper\ncustomization based on the values provided by them.If someone run into this problem with UISearchController.\nJust create a new subclass of UISearchController, and then add code below into that class:In Swift for any kind of UIViewController:In your AppDelegate set:myRootController can be any kind of UIViewController, e.g. UITabBarController or UINavigationController.Then, override this root controller like this:This will change the appearance of the status bar in your whole app, because the root controller is solely responsible for the status bar appearance.Remember to set the property View controller-based status bar appearance to YES in your Info.plist to make this work (which is the default).On a UINavigationController, preferredStatusBarStyle is not called because its topViewController is preferred to self. So, to get preferredStatusBarStyle called on an UINavigationController, you need to change its childViewControllerForStatusBarStyle.To do it for one UINavigationController (my recommendation):To do it for all UINavigationController (warning: it affects UIDocumentPickerViewController, UIImagePickerController, etc.):The NavigationController or TabBarController are the ones that need to provide the style. Here is how I solved: https://stackoverflow.com/a/39072526/242769Note that when using the self.navigationController.navigationBar.barStyle = UIBarStyleBlack; solutionbe sure to go to your plist and set "View controller-based status bar appearance" to YES. If its NO it will not work. 