Is it possible to write a regular expression that matches a nested pattern that occurs an unknown number of times? For example, can a regular expression match an opening and closing brace when there are an unknown number of open/close braces nested within the outer braces?For example:Should match:No. It\'s that easy. A finite automaton (which is the data structure underlying a regular expression) does not have memory apart from the state it\'s in, and if you have arbitrarily deep nesting, you need an arbitrarily large automaton, which collides with the notion of a finite automaton.You can match nested/paired elements up to a fixed depth, where the depth is only limited by your memory, because the automaton gets very large. In practice, however, you should use a push-down automaton, i.e a parser for a context-free grammar, for instance LL (top-down) or LR (bottom-up). You have to take the worse runtime behavior into account: O(n^3) vs. O(n), with n = length(input).There are many parser generators avialable, for instance ANTLR for Java. Finding an existing grammar for Java (or C) is also not difficult.\nFor more background: Automata Theory at WikipediaProbably working Perl solution, if the string is on one line:HTHEDIT: check:And one more thing by Torsten Marek (who had pointed out correctly, that it\'s not a regex anymore):Using regular expressions to check for nested patterns is very easy.Yes, if it is .NET RegEx-engine. .Net engine supports finite state machine supplied with an external stack. see detailsThe Pumping lemma for regular languages is the reason why you can\'t do that.The generated automaton will have a  finite number of states, say k, so a string of k+1 opening braces is bound to have a state repeated somewhere (as the automaton processes the characters). The part of the string between the same state can be duplicated infinitely many times and the automaton will not know the difference.In particular, if it accepts k+1 opening braces followed by k+1 closing braces (which it should) it will also accept the pumped number of opening braces followed by unchanged k+1 closing brases (which it shouldn\'t).Proper Regular expressions would not be able to do it as you would leave the realm of Regular Languages to land in the Context Free Languages territories.Nevertheless the "regular expression" packages that many languages offer are strictly more powerful.For example, Lua regular expressions have the "%b()" recognizer that will match balanced parenthesis. In your case you would use "%b{}"Another sophisticated tool similar to sed is gema, where you will match balanced curly braces very easily with {#}.So, depending on the tools you have at your disposal your "regular expression" (in a broader sense) may be able to match nested parenthesis.Using the recursive matching in the PHP regex engine is massively faster than procedural matching of brackets. especially with longer strings.http://php.net/manual/en/regexp.reference.recursive.phpe.g.vs.as zsolt mentioned, some regex engines support recursion -- of course, these are typically the ones that use a backtracking algorithm so it won\'t be particularly efficient.  example: /(?>[^{}]*){(?>[^{}]*)(?R)*(?>[^{}]*)}/smNo, you are getting into the realm of Context Free Grammars at that point.This seems to work: /(\\{(?:\\{.*\\}|[^\\{])*\\})/mMy question+answer is related and I make an expression and meta-expression that can match arbitrary (finite) levels of nesting. It\'s pretty fugly but what else can you expect? Use backreferences in the match if your engine supports it. No.  You need a full-blown parser for this type of problem.