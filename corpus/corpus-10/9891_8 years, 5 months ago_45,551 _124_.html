I\xe2\x80\x99ve been looking at Smalltalk (VisualWorks) for the past couple of months - and the more I learn the more I\xe2\x80\x99m impressed.  However, I think I must be missing something as Smalltalk doesn\xe2\x80\x99t seem to be popular these days - and perhaps it never was.  What do the people who have dropped Smalltalk in favor of Java, C++, Ruby, etc. know that I don\xe2\x80\x99t or in other words \xe2\x80\x9cWhy isn\xe2\x80\x99t Smalltalk more popular?\xe2\x80\x9dThere are a number of reasons that Smalltalk didn\'t "catch fire", most of them historical:when Smalltalk was introduced, it was too far ahead of its time in terms of what kind of hardware it really neededIn 1995, when Java was released to great fanfare, one of the primary Smalltalk vendors (ParcPlace) was busy merging with another (Digitalk), and that merger ended up being more of a knife fightBy 2000, when Cincom acquired VisualWorks (ObjectStudio was already a Cincom product), Smalltalk had faded from the "hip language" sceneSince then, Smalltalk has been a small player on the language space, but it\'s back to having a growing market.  There are both commercial offerings (Cincom being the largest player there), and open source (Squeak and Pharo which are mostly under the MIT license, and GNU Smalltalk, which is GPL).  Not all Smalltalk implementations require an image; while those of us who are sold on an image environment love it, you can use GNU Smalltalk with your favorite text editor easily enough.  Ultimately, Smalltalk peaked early, and then had damage done to it by the stupidity of the early vendors in the space.  At this point in time, that\'s all in the past, and I\'d say that the future looks pretty bright.Lots of reasons, some of which are:Having said that, I use Smalltalk (Squeak) myself and enjoy knocking up GUI ideas and tools using it - but only for personal entertainment.Update as of 29-Jul-2010: Having said all the above, which I stand by, the latest version of Squeak (4.1) is a vast improvement in terms of look-and-feel and performance. It is also MIT licensed, if that matters to you. It is well worth a look if you are at all interested in Smalltalk.You had to be there in 1995.  At that time, there were a few commercial Smalltalks but the biggest was VisualWorks from ParcPlace Systems.  The marketers at ParcPlace were idiots - choosing to optimize for max dollers per seat rather than max seats.  Any shop wishing to adopt Smalltalk had to pay a couple thousand dollars per developer for a license.  Any developer wishing to learn Smalltalk either had to get hired to do Smalltalk or sink serious cash into buying his own license.  So it was just plain hard to get a chance to learn it.Also about that time, IBM was looking for a successor to COBOL for their business customers.  They chose Smalltalk (smart) and developed VisualAge and made it so the same program could run without modification on everything from mainframes to AS400s to PCs.  Smalltalk has a friendly minimal syntax and is easy to learn so it seemed a natural replacement for COBOL.  The future looked really bright for Smalltalk.  The companies that were using it were out-producing everyone else by a lot.Then Sun showed up with Java.  They gave it away free instead of charging for it.  IBM took a look at it and figured two things.  First they didn\'t want to enter a marketing war with Sun that was clearly planning to spend a fortune on the Java brand.  Instead they decided to try to beat Sun at their own game - have the best Java on the market.  Why not, they already had a great VM that ran on their whole stack - they just adapted it to handle the Java bytecode set.  In fact, all of IBM\'s Java tools were actually written in Smalltalk for several years.  Thus - if one wants to blame anyone for the rise of Java over Smalltalk - it is pretty easy to place the blame directly at the feet of IBM and their unwillingness to compete.I love Smalltalk.  I love coding in the debugger, being able to archive processes and restore them exactly later if they encounter exceptions, the amazing reliability.  The economy of expression and the brilliant class library.  There is a new resurgence in Smalltalk development thanks to Squeak.  Newspeak, Pharo (which has some really beautiful UI skins), the new cog VM, Seaside and Gemstone, these are all projects working on addressing the historical shortcomings of Smalltalk including the poor OS integration (Newspeak has a slick native widgets integration and Pharo/Squeak have a new external code integration capability called Aliens), and deployment/scalability.Anyhow, I don\'t mind that Smalltalk isn\'t popular.  That makes it a secret weapon for me and I am really encouraged to see all the new development projects.  Smalltalk is growing and advancing again and this is good because a lot of the best ideas in software (XP, unit testing, refactoring editors, coding assistants) all were developed in Smalltalk first and then filtered out to the rest of the world (generally in diluted forms).One other limitation at the time for Smalltalk was application packaging and the lack of dynamic loading support. Large Smalltalk applications had to rebuild the image file and redeploy for a change. Java provided dynamic linking at runtime which provided many benefits to packaged applications. By the time Smalltalk added dynamic loading, Java had won mindshare at IBM so they stopped investing in Smalltalk.No doubt a controversial answer, and definitely a personal one, but... I don\'t like zealots.Most of the Smalltalkers that I\'ve run into on the net try to say how Smalltalk is basically the best thing since sliced bread, and how awful every other language is. I\'m not saying that all Smalltalkers act that way - but it\'s been a very noticeable trend in the ones I\'ve encountered. They\'ve very clearly been looking down on anyone who doesn\'t use Smalltalk.That\'s simply not a good way of persuading people to use a language. It puts me off because I enjoy learning with a community, and I don\'t really want to be part of a community which looks down on me - even if it\'s just a vocal minority taking that attitude.I don\'t know enough about Smalltalk to comment on it technically at all - and I\'d really like to learn it "some day"... but it\'s lower down the list of languages for me to learn than others where I\'ve had a more positive experience with the community. (F# nearly had the same problem for me, due to someone taking that attitude in the C# newsgroup, but fortunately more engaging personalities have prevailed.) The fact that people do like it so much suggests there are good things about it as a technology - but realistically, I\'m a human being rather than a computer. Technical merit is only part of the picture.Maybe I\'m just alone on this, but in general: if you want to show someone how awesome your favourite thing is, and maybe persuade them that they should use it too, starting off by rubbishing their current tool is a bad idea. Operating system zealots (of all kinds) should take note.A couple of people have mentioned syntax as a hindrance to adoption. I think there\'s a particular issue that drives a large number of developers away: lack of algebraic precedence rules.Any language where the expression 2 + 3 * 4 has the value 20 isn\'t going to be a commercial success. Yes, the syntax is very regular, and yes, anybody who knows Smalltalk can figure out why expressions are evaluated the way they are. Unfortunately, it runs counter to what you\'ve had drilled into you during your entire primary education in mathematics.Anyone who\'s learning Smalltalk and is trying to use it to do basically any kind of calculation at all will run into this problem repeatedly until they learn that they have to parenthesize everything. Because it\'s only a problem with some expressions, and causes incorrect results, rather than an error message, it\'ll take them a long time to figure out the first N times it happens.Some significant percentage of developers will never get over this.Two things stand out in my mind:They seem like really obvious mistakes in hindsight, but I guess you just had to be there.I was a Smalltalk programmer in the 1990s, and then again more recently.   I\'m surprised that I can relate to almost every person who wrote on this thread (with a couple of exceptions).Yes, in the mid-1990s, the vendors priced themselves out of the budding market, failed to get bundled into Netscape, and basically got themselves booed off the stage.The particular ingenuity that came from the Smalltalk environment was a product of its inherent strength, which is still there. Smalltalk has the potential for reinventing itself, or more precisely rediscovering its purpose for a new age.Since Smalltalk isn\'t very famous, it\'s hard to land contracts, and the true Smalltalkers often find themselves shuttling from one city to another for engagements. On the other hand, the Smalltalk community, for better or worse, means people actually know each other. In these days, being a part of a community, even a back-biting nerdy one, has its advantages.  Professionally speaking, people know who you are. Since Smalltalk tends to attract mavericks and dreamers, like me, it\'s a good place to be.Some links to ruminate over:The classic Worse is Better. Although pertaining to Lisp, some of the same points apply. A simple solution that isn\'t quite right is better than a complex solution that is more difficult to transport across various boundaries.Python.org. This is not to start a language war, but more specifically, to show how easy it is to download, install, and start working on the language. For Linux, it\'s already there. For Windows/Mac, it\'s a quick installation away. Each comes with a huge amount of libraries that brings things like XML processing, HTTP capabilities, and documentation for it all. Note the installation page for Squeak, not nearly as user friendly.Libraries are also very important. Compare XML processing libraries for something like Smalltalk and then compare that to the almighty CPAN. Meanwhile each different version of Smalltalk has its own library.A programming language can be seen as many things. Some see it as a way of representing algorithms and data structures. In this case, languages like Smalltalk and Lisp and Haskell excel. It can also be seen as a tool that gets a job done. Even as they may curse the tool they use, they still would use what is needed to get the job done.Let\'s compare smalltalk with Java to see what went wrong.Timing. Virtual machines are expensive in terms of speed and memory consuption. When Smalltalk appeared, we were "not there" yet. Smalltalk was a heavy load and it was very difficult to use. Computers were not so as wide-spread as today. Java, on the other side, got in the market "just in time" for a amazing growth of CPU and memory in a already ubiquitous PC.There was freedom. Smalltalk was about "take it all or leave it all". Java is a language, that can be used in different environments. Syntax also plays a role. Although Smalltalk is pure OO and beautiful, it is easier for a programmer to learn Java.I was using Smalltalk commercially in a small way in 1995. (I wrote my company\'s white paper on Java at the same time. IIRC I said Java needed 2-3 years more to mature.)By 1998, Smalltalkers ditched to Java.Vendor licenses were very expensive. Squeak is magic at the price (zilch).The hardware required was outrageous: We had an early SUN UltraSparc with 1 GB of RAM in 1996. It was a Smalltalk application server. For one 3-tier application! With less than 50 users!! (Mind you, every field on every screen populated from the database in its own thread. Made for a very slick UI.)Libraries are NOT the same between vendors, so you get locked in.Basic features of the environment are different between vendors: reflection is a curly one.Basically, the Smalltalk vendors have balkanized the market since the 1980s, and it\'s still fragmented.From a technical viewpoint Samlltalk stomps all over most other languages for productivity. NeXT copied the image-based approach of Smalltalk for Objective-C, and it\'s done very well (just look at all of Apple\'s current products).Looking at this question as a long-time Smalltalker, earning all my income doing web applications in Smalltalk for 12 years, what can I say about it? First, is this a relevant question at all? Why does Smalltalk need to be popular? Isn\'t such a small but nice and lively community as we have now a better thing than the big community?On the other side being more popular is a good selling point. It is hard to persuade customers to go to a less popular road, because they feel less safe.But again, from my experience this is a non-issue for the web applications. There almost no one care much what you are running on. What they care about is the result. That\'s why I think the future of Smalltalk is exactly in the web applications, because here we can explore all its strengths without dealing with that question again and again.A blog post (now offline) The Great Programming Industry Reboot sort of answers this.  Short version: The first microcomputers couldn\'t run Smalltalk, and the number of programmers was growing faster than the new ones could be educated by the old ones.  The programming culture basically started over in the early 1980s on microcomputers, and then the microcomputer programmers  had to spend the next 30 years going through the growing pains that the mainframe/minicomputer programmers had already gone through.Blog post rescued from Wayback machine and posted here:The Great Programming Industry Reboot\nWEDNESDAY, JANUARY 2, 2008A while back I bought a copy of Structured Programming (now available as a free PDF from the ACM), primarily so that I could read Dijkstra\'s essay "Notes on Structured Programming" (an expanded version of EWD249). In addition to "Notes on Structured Programming," it contains an essay by Hoare on "Data Structuring" and one by Hoare and Dahl on "Hierarchical Program Structures."It was this last one, "Hierarchical Program Structures," which ended up having the greatest impact on me. It describes a programming language called Simula 67. Simula 67 is an extended version of Algol 60, which contains some extra simulation capabilities. It has these things called "classes" which each describe the behavior of a bunch of individual "instances." It has this "concatenation" thing which allows one class to include all of the attributes and behaviors of another class. There\'s also this "virtual" function thing, and it\'s statically typed and garbage collected.The similarity to Java was so striking that I was depressed for days.Then, I started looking a little bit forward and backwards from Java and Simula 67, and I found some interesting similarities between a progression of languages that happened since the microcomputer revolution and a progression that happened before the microcomputer revolution.I\'m trying to interpret history here, a good portion of which I did not live through, so I realize that I am entering dangerous territory. I encourage those of you who lived through this history to confirm and/or deny any parts of my speculation that you can.I am more familiar with the more recent progression, so I\'ll start there. Microsoft\'s 4k Basic for the Altair (which you can try out on Peter Schorn\'s simh based Altair emulator) began a period of popularity for Basic, followed by one for Pascal and C, C++, and Java. Ignoring garbage collection in Basic, the rough order in which features were added is:FormulasHigh level control structures (for loops, while loops, if\'s with multi-line bodies, and such) and recursive functionsI noticed that I can construct a very similar progression going from Fortran to Algol 60 to Simula 67, with the exception that the Object Oriented features come more or less at the same time as garbage collection.Now I realize that I am picking and choosing my comparison points here, making me vulnerable to the Texas sharpshooter fallacy. I\'m also using a progression of popular languages for the post-microcomputer languages and a progression languages that each sort of inspired the next for the pre-microcomputer languages. But I have often felt like history is repeating itself, and this particular pair of sequences worked as a lense to focus my thoughts.I have a hypothesis that many parts of the programming industry essentially rebooted with the microcomputer revolution, and two possible reasons that may have contributed to this happening.Possible reason #1: Alan Kay has argued that when people join a community faster than they can be socialized, a new pop culture develops where things which used to be common knowledge among the community become relatively little known. Is it possible that the microcomputer revolution caused the number of programmers to grow so quickly that the newer, larger, overall more ignorant programmer communities of the early 1980s needed to repeat the evolution that their predecessors from the mainframe and minicomputer eras went through?Possible reason #2: The early microcomputers just didn\'t have the horsepower to run the more sophisticated programming systems that had been developed on mainframes and minicomputers. Trying to run a Smalltalk or Lisp system in 4k, or 32k, or 64k on a 1Mhz processor just wasn\'t particularly practical. By the mid 1980s the microcomputers were powerful enough to do some of the fancier stuff, but by then, maybe the new programmers had spent enough time in their impoverished environments that they were only able to be drug into higher level programming languages a little bit at a time?If my speculations are true, then it is kind of depressing that we have lost so many years, but it is also kind of encouraging that we are making progress, because it would mean that we aren\'t stuck in an endless cycle of technology churn, reinventing the same thing over and over, but instead we are almost caught up to where we were before our industry did a great reboot, and we are getting closer to stepping into genuinely new territory.If I were to continue the two progressions of languages that I made above, I would continue the older one into Smalltalk*, and the newer one into Ruby, with the new features being something like "reflection" and "late binding."Footnotes:POSTED BY GLOMEK AT 9:15 AM1 COMMENTS:Rick DeNatale said...\nGarbage Collection is nearly as old as the use of mathematical formulas in programming languages. Lisp is of the same vintage as Fortran and Cobol (late 1950s).Alan Kay\'s initial conception of object-oriented programming purposely left out inheritance as he didn\'t like the way Dahl and Nygaard had done it in Simula.I just wrote about Kay\'s concept of object-orientation yesterday.The primary reason seems to be liter upon liter of misinformation, fermenting to misperception by the galoons. The secondary reason is probably the ParcPlace mis-step of the mid 1990s, and the third is likely losing the one mega-player, as IBM veered off to engage a Microsoft-guided war of attrition, getting sucked into the black hole of a collapsing Sun.Popular - like Paris Hilton?Or quiet pursuit of craft, immersed in the joy of working with great tools, which likewise persist, improve, and grow, albeit in relative obscurity.To each his own, I guess.Having used many, many, many tools over the years, I can say that Smalltalk\nsimply IS worth the price of admission, whatever that price appears to be.In one sense the premise is false. Smalltalk had a high point of popularity in the 1990s when it was used in high-end applications in a reasonably large number of installations, particularly in the financial industry in the NYC area.But the main reason is that Smalltalk is too comprehensively different to overcome inertial forces in the IT industry which favor lowest common denominator kinds of approaches. For that reason there are no general-purpose languages of great popularity which deviate radically from the ALGOL-like languages, mostly variants based on C.Another factor is the insularity of the Smalltalk culture, a special case of provincial language cultures which is somewhat aggravated by the source, image, change triple, which is great for in-universe stuff, less so for interacting with the wider world of computing.It differs too much syntactically and conceptually from languages like C.Switching from a C-like language to Smalltalk might seem too difficult to many people, given that many students and hobbyists grow up learning C-like languages (C, C++, Java, PHP, etc.).Last time I checked I was put off by the documentation. Why on earth should I put colored markers on my mouse just to understand what they are talking about? Is it so hard to call the buttons left, right, middle? See the beginning of Squeak by ExampleInstead they are colors and I constantly have to look up what button is meant. This isn\'t a good idea to get into a flow.I tested Squeak. And I don\'t know how somebody could deploy a Squeak application to "normal" people.The huge fricken images.They\'re a horrible way to distribute software. Get with the program, make a distributable version of Smalltalk that makes executable or at least self bundles and has access to normal GUI toolkits or at least look alike ones.The only people who can really use the language are those running on servers, a la, those who do not have to distribute it.See Why isn\xe2\x80\x99t Smalltalk popular?There is an excellent talk from Robert Martin at RailsConf \'09: "What Killed Smalltalk Could Kill Ruby, Too.".TLDR: "What killed Smalltalk? It was just too easy to make a mess." -- Ward CunninghamI think the reasons may have little to do with technical arguments.  For example, the question is framed in terms of "why Smalltalk was dropped in favor of Java".  I would ask why Java continues to be mainstream when its project failure rate is one of the highest in the industry (per Gartner, http://www.zdnet.com.au/news/business/soa/Java-and-Net-both-a-disaster-research/0,139023166,120269968,00.htm).  Given that kind of evidence, this does not seem to be a rational phenomenon to me, and so I doubt that we (meaning programmers) will find proper, rational explanations to it.Before we explain "why Smalltalk isn\'t popular", I think it would be much more interesting to answer "why do the majority of IT shops choose a technology that is associated with failure 70% of the time"."the more I learn the more I\xe2\x80\x99m impressed"You can learn some more about real Smalltalk applications from conference experience reports - read through Niall Ross\'s conference summaries. There was this module I had in Uni that was called something like Programming Languages and Client-server computing and Concurrency. A certain part of this module was dedicated, as its name indicates, to programming languages in general. Smalltalk was mentioned about as much as ALGOL 60. And you wonder why no-one wants to go the SmallTalk way?I believe the influence of higher education institutions is greater than one would think. We are talking about masses of software engineers/computer scientists, etc... leaving Uni\'s every year with a Java-centric mental model.Very silly licensing. There was a wonderful version of Smalltalk in the 1990s that delivered everything that a developer needed - great tools, excellent cross-platform development, good performance, reliability. This was VisualWorks.It was also not particularly expensive. I was prepared to look at it for major projects, after past success with Digitalk Smalltalk. But then, the company producing VisualWorks went bust, and VisualWorks was taken over by a company (who I shall not embarrass by naming) who changed what would have been a simple purchase of a development product into an absurd licensing arrangement which required an on-going and expensive "customer relationship".In doing so, they killed the chances of this wonderful product becoming mainstream. At the same time, Sun were supplying Java for free. Cross-platform, multiple supplier (Sun and IBM vms), secure, with a syntax familiar to C developers. They also put a huge effort into optimising the JVM, which means that these days Java can easily compete with C in terms of speed.These days I develop in Java, Groovy and Scala on the JVM.  But I miss Smalltalk development.Isn\'t it? According to TIOBE\'s list, it\'s #44 right now. #44 in the world seems pretty darned popular, to me! (Porsche is also about #40 in the world, in terms of popularity, but nobody seems to ask "Why isn\'t Porsche popular?".) We\'ve made huge strides in using open, text-based protocols; who cares if somebody else uses the same programming language?Especially for a computer language that\'s 40 years old -- how many other languages from the 1950s and 1960s do you see in use today? I see, of the top 50, only 6 others: Logo, Pascal, RPG, COBOL, Lisp, and Fortran. There are a bunch of languages with high instantaneous popularity, but which are very likely to drop off the list in well under 40 years.I would consider a top-50 language that\'s been there for two (human!) generations to be much more solid than a top-10 language that\'s been there for only three or four years. The latter is likely a fad; the former is a proven classic.Shakespeare, Twain and Poe are not top-50 authors this year, but may well be top-50 authors over the past 40 years, and I think it\'s pretty likely they\'re top-10 authors over the past century. They all use an open, text-based protocol (English!), so it doesn\'t matter that the person next to me on the bus is reading a short-lived fad like Danielle Steel.First, Smalltalk was quite big. There was a time where there was only Smalltalk and C++ as production-quality OO languages. During that time Smalltalk did very well. IBM Smalltalk was also an alternative to VW Smalltalk that many banks and insurance companies chose to go with as it was from IBM (well, they acquired OTI in order to get hold of it).Then came the Internet and Java. Java was ready for the Internet, but Smalltalk wasn\'t. And in particular the people from the original Smalltalk vendor were convinced that Smalltalk was perfect and nothing had to be added to it. This way Smalltalk lost the race with Java.Then there are also other reasons. Mainly the image concept I would say. The syntax is often mentioned, but Objective-C has the same style of colon separated method parameter lists and nobody seems to care about it in the Objective-C world.Pennsylvania State University (Penn State) was/is big on Smalltalk. Entire student systems, etc. were written in it. Here is my reasoning:If you really want a job doing Smalltalk, babysit psu.jobs. They will lock you in the basement. Maybe you\'ll get something to eat and get some sun, but you are not allowed to quit. You\'ll have a job forever...(diabolical echo of ...)Very nice accepted answer. I would add that early Smalltalk systems weren\'t really on speaking-terms with the host OS and its native applications. It was like APL: If you can live in this strange world called the "workspace" or "image", everything\'s great, but if you want to use your usual window manager or god forbid GNU Emacs, well, you might as well be on Mars.  I believe Squeak still takes this approach, which is why I prefer Ruby :-)First of all, I think Smalltalk is wildly popular among many industries.Many companies swear by it. As a consumer programming language it is obviously not popular because it:Smalltalk excels as a DSL object-rich \'environment\' which lends it well to custom software solutions among major production oriented companies. C-based programming languages essentially gained ground for the same reason the QWERTY designed keyboard did, it just happened to become used on a grand scale (household PC computers) since they were based on operating systems written mostly in C. By comparison it may be less that Smalltalk is not popular and more the case that other C based languages are so popular that it only makes Smalltalk look unpopular.Speaking as someone who has used VisualWorks in school, there are a few things I found annoying.  The biggest was the forced (yes, forced) use of the image environment.  2/3 through my project, the image environment crashed while I had a particular window open.  That caused the window to come up every time, I opened the environment, despite many efforts to correct this issue.  I also found (what I saw as) the weak namespacing and scoping irritating.  "Everything is an object" sounds cool until you realize what it means, that 3 + 4 * 7 = 49.  And though I understand where duck-typing is coming from, I still strongly prefer static type-checking.  The syntax was not that intuitive; I know Java is verbose, but it\'s actually easy to read and write, especially (obviously) for someone who came form a C/C++ background.  This is true even though Java is (almost equally) distinct from C/C++ where it counts (e.g. memory management and object-oriented model).But I do respect certain aspects, not least the many features it originated, such as strong reflection and powerful closures.In this interview Robert Martin gives his point of view about this discussion: http://pragprog.com/podcasts/show/32.