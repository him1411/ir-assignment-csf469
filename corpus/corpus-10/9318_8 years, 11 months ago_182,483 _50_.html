I\'m trying to copy a bunch of files below a directory and a number of the files have spaces and single-quotes in their names.  When I try to string together find and grep with xargs, I get the following error:Any suggestions for a more robust usage of xargs?This is on MacOS 10.5.3 with BSD xargs.You might also be able to combine all of that into a single find command:This will handle filenames and directories with spaces in them.  You can use -name to get case-sensitive results.  (These command line arguments will work with GNU find; I don\'t know if they\'re available with BSD\'s or OS X\'s find.)find . -print0 | grep --null \'FooBar\' | xargs -0 ...I don\'t know about whether grep supports --null, nor whether xargs supports -0, on Leopard, but on GNU it\'s all good.This is more efficient as it does not run "cp" multiple times:I ran into the same problem. Here\'s how I solved it:I used sed to substitute each line of input with the same line, but surrounded by double quotes. From the sed man page, "...An ampersand (``&\'\') appearing in the replacement is replaced by the string matching the RE..." -- in this case, .*, the entire line. This solves the xargs: unterminated quote error.The easiest way to do what the original poster wants is to change the delimiter from any whitespace to just the end-of-line character like this:This method works on Mac OSx Lion 10.7.5Edit: Also just tested the exact syntax you posted. That also worked fine on 10.7.5.Look into using the --null commandline option for xargs with the -print0 option in find.Here is a portable (POSIX) solution, i.e. one that doesn\'t require find, xargs or cp GNU specific extensions:It will correctly handle files and directories with embedded spaces, newlines or whatever, and is more efficient (read faster) than the accepted answer.I have found that the following syntax works well for me.In this example, I am looking for the largest 200 files over 1,000,000 bytes in the filesystem mounted at "/usr/pcapps".The Perl line-liner between "find" and "xargs" escapes/quotes each blank so "xargs" passes any filename with embedded blanks to "ls" as a single argument.Bill Starr\nFri, 23 Jan 2009, 5:40 pm ESTI believe that this will work reliably for any character except line-feed (and I suspect that if you\'ve got line-feeds in your filenames, then you\'ve got worse problems than this).  It doesn\'t require GNU findutils, just Perl, so it should work pretty-much anywhere.For those who relies on commands, other than find, eg ls:Be aware that most of the options discussed in other answers are not standard on platforms that do not use the GNU utilities (Solaris, AIX, HP-UX, for instance).  See the POSIX specification for \'standard\' xargs behaviour.I also find the behaviour of xargs whereby it runs the command at least once, even with no input, to be a nuisance.I wrote my own private version of xargs (xargl) to deal with the problems of spaces in names (only newlines separate  - though the \'find ... -print0\' and \'xargs -0\' combination is pretty neat given that file names cannot contain ASCII NUL \'\\0\' characters.  My xargl isn\'t as complete as it would need to be to be worth publishing - especially since GNU has facilities that are at least as good.The perl version above won\'t work well for embedded newlines (only copes with spaces).  For those on e.g. solaris where you don\'t have the gnu tools, a more complete version might be (using sed)...adjust the find and grep arguments or other commands as you require, but the sed will fix your embedded newlines/spaces/tabs.I used a  Bill Star\'s answer slightly modified on Solaris:this will put quotes around each line. I didn\'t use the \'-l\' option although it probably would help.The file list I was going though might have \'-\' but not newlines. I haven\'t used the output file with any other commands as I want to review what was found before I just start massively deleting them via xargs.With bash (not POSIX) you can use process substitution to get the current line inside a variable. This enables you to use quotes to escape special characters:I played with this a little, started contemplating modifying xargs, and realised that for the kind of use case we\'re talking about here, a simple reimplementation in python is a better idea. For one thing, having ~80 lines of code for the whole thing means it is easy to figure out what is going on, and if different behaviour is required, you can just hack it into a new script in less time than it takes to get a reply on somewhere like stackoverflow.See https://github.com/johnallsup/jda-misc-scripts/blob/master/yargs and https://github.com/johnallsup/jda-misc-scripts/blob/master/zargs.pyWith yargs as written (and python3 installed) you can typeto do the copying 203 files at a time. (Here 203 is just a placeholder, of course, and using a strange number like 203 makes it clear that this number has no other significance.)If you really want something faster and without the need for python, take zargs and yargs as prototypes and rewrite in C++ or C.For me, I was trying to do something a little different. I wanted to copy my txt files into my tmp folder. The txt filenames contain spaces and apostrophe characters. This worked on my mac.For users of the stupid non-GNU version, Bill Starr\'s solution doesn\'t work if there are apostrophes in the filename. rjb1\'s also has the same problem, I think, although I can\'t replicate it with a test. Carl Yamamoto-Furst\'s version works.You might need to grep Foobar directory like:If find and xarg versions on your system doesn\'t support -print0 and -0 switches (for example AIX find and xargs) you can use this terribly looking code:Here sed will take care of escaping the spaces and quotes for xargs.Tested on AIX 5.3If you are using bash, you can convert stdout to an array of lines by mapfile,the benefits are:You can append other arguments to the file names. For cp, you can also:however, some commands don\'t have such feature.the disadvantages:Well... who knows if bash is available on OS X?