I understand the difference between String and StringBuilder (StringBuilder being mutable) but is there a large performance difference between the two? The program I\xe2\x80\x99m working on has a lot of case driven string appends (500+). Is using StringBuilder a better choice?Yes, the performance difference is significant.  See the KB article "How to improve string concatenation performance in Visual C#".I have always tried to code for clarity first, and then optimize for performance later.  That\'s much easier than doing it the other way around! However, having seen the enormous performance difference in my applications between the two, I now think about it a little more carefully.  Luckily, it\'s relatively straightforward to run performance analysis on your code to see where you\'re spending the time, and then to modify it to use StringBuilder where needed.To clarify what Gillian said about 4 string, if you have something like this:then it would be faster using strings and the plus operator. This is because (like Java, as Eric points out), it internally uses StringBuilder automatically (Actually, it uses a primitive that StringBuilder also uses)However, if what you are doing is closer to:Then you need to explicitly use a StringBuilder.  .Net doesn\'t automatically create a StringBuilder here, because it would be pointless.  At the end of each line, "a" has to be an (immutable) string, so it would have to create and dispose a StringBuilder on each line.  For speed, you\'d need to use the same StringBuilder until you\'re done building:StringBuilder is preferable IF you are doing multiple loops, or forks in your code pass... however, for PURE performance, if you can get away with a SINGLE string declaration, then that is much more performant. For example: is more performant thanIn this case, StringBuild could be considered more maintainable, but is not more performant than the single string declaration. 9 times out of 10 though... use the string builder. On a side note: string + var is also more performant that the string.Format approach (generally) that uses a StringBuilder internally (when in doubt... check reflector!)This benchmark shows that regular concatenation is faster when combining 3 or fewer strings.http://www.chinhdo.com/20070224/stringbuilder-is-not-always-faster/StringBuilder can make a very significant improvement in memory usage, especially in your case of adding 500 strings together.  Consider the following example:What happens in memory?  The following strings are created:By adding those five numbers to the end of the string we created 13 string objects!  And 12 of them were useless!  Wow!StringBuilder fixes this problem.  It is not a "mutable string" as we often hear (all strings in .NET are immutable).  It works by keeping an internal buffer, an array of char.  Calling Append() or AppendLine() adds the string to the empty space at the end of the char array; if the array is too small, it creates a new, larger array, and copies the buffer there.  So in the example above, StringBuilder might only need a single array to contain all 5 additions to the string-- depending on the size of its buffer.  You can tell StringBuilder how big its buffer should be in the constructor.Don\'t blindly go for StringBuilder. There are scenarios where StringBuilder does not improve the performance.Rico Mariani has written two insightful blog entries on this:http://blogs.msdn.com/ricom/archive/2003/12/02/40778.aspxhttp://blogs.msdn.com/ricom/archive/2003/12/15/43628.aspxA simple example to demonstrate the difference in speed when using String contactenation vs StringBuilder:Result:Using String contactenation: 15423 millisecondsResult:Using StringBuilder: 10 millisecondsAs a result, the first iteration took 15423 ms while the second iteration using StringBuilder took 10 ms.It looks to me that using StringBuilder is faster, a lot faster.StringBuilder reduces the number of allocations and assignments, at a cost of extra memory used.  Used properly, it can completely remove the need for the compiler to allocate larger and larger strings over and over until the result is found.vs.Yes, StringBuilder gives better performance while performing repeated operation over a string. It is because all the changes are made to a single instance so it can save a lot of time instead of  creating a new instance like String.StringStringBuilder (mutable string)Strongly recommend dotnet mob article : String Vs StringBuilder in C#.Related Stack Overflow question: Mutability of string when string\n  doesn\'t change in C#?.The performance of a concatenation operation for a String or StringBuilder object depends on how often a memory allocation occurs. A String concatenation operation always allocates memory, whereas a StringBuilder concatenation operation only allocates memory if the StringBuilder object buffer is too small to accommodate the new data. Consequently, the String class is preferable for a concatenation operation if a fixed number of String objects are concatenated. In that case, the individual concatenation operations might even be combined into a single operation by the compiler. A StringBuilder object is preferable for a concatenation operation if an arbitrary number of strings are concatenated; for example, if a loop concatenates a random number of strings of user input.Source: MSDNI believe StringBuilder is faster if you have more than 4 strings you need to append together. Plus it can do some cool things like AppendLine.In .NET, StringBuilder is still faster than appending strings.  I\'m pretty sure that in Java, they just create a StringBuffer under the hood when you append strings, so there\'s isn\'t really a difference.  I\'m not sure why they haven\'t done this in .NET yet.Consider \'The Sad Tragedy of Micro-Optimization Theater\'.StringBuilder is better for building up a string from many non-constant values.If you\'re building up a string from a lot of constant values, such as multiple lines of values in an HTML or XML document or other chunks of text, you can get away with just appending to the same string, because almost all compilers do "constant folding", a process of reducing the parse tree when you have a bunch of constant manipulation (it\'s also used when you write something like int minutesPerYear = 24 * 365 * 60). And for simple cases with non-constant values appended to each other, the .NET compiler will reduce your code to something similar to what StringBuilder does.But when your append can\'t be reduced to something simpler by the compiler, you\'ll want a StringBuilder. As fizch points out, that\'s more likely to happen inside of a loop.Using strings for concatenation can lead to a runtime complexity on the order of O(n^2).If you use a StringBuilder, there is a lot less copying of memory that has to be done.  With the StringBuilder(int capacity) you can increase performance if you can estimate how large the final String is going to be.  Even if you\'re not precise, you\'ll probably only have to grow the capacity of StringBuilder a couple of times which can help performance also.I have seen significant performance gains from using the EnsureCapacity(int capacity) method call on an instance of StringBuilder before using it for any string storage. I usually call that on the line of code after instantiation. It has the same effect as if you instantiate the StringBuilder like this:This call allocates needed memory ahead of time, which causes fewer memory allocations during multiple Append() operations.  You have to make an educated guess on how much memory you will need, but for most applications this should not be too difficult. I usually err on the side of a little too much memory (we are talking 1k or so).Further to the previous answers, the first thing I always do when thinking of issues like this is to create a small test application.  Inside this app, perform some timing test for both scenarios and see for yourself which is quicker.IMHO, appending 500+ string entries should definitely use StringBuilder.String and StringBuilder are actually both immutable, the StringBuilder has built in buffers which allow its size to be managed more efficiently. When the StringBuilder needs to resize is when it is re-allocated on the heap. By default it is sized to 16 characters, you can set this in the constructor.eg.StringBuilder sb = new StringBuilder(50);String concatenation will cost you more.\nIn Java, You can use either StringBuffer or StringBuilder based on your need.\nIf you want a synchronized, and thread safe implementation, go for StringBuffer. This will be faster than the String concatenation.If you do not need synchronized or Thread safe implementation, go for StringBuilder.\nThis will be faster than String concatenation and also faster than StringBuffer as their is no synchorization overhead.StringBuilder is probably preferable.  The reason is that it allocates more space than currently needed (you set the number of characters) to leave room for future appends.  Then those future appends that fit in the current buffer don\'t require any memory allocation or garbage collection, which can be expensive.  In general, I use StringBuilder for complex string concatentation or multiple formatting, then convert to a normal String when the data is complete, and I want an immutable object again.If you\'re doing a lot of string concatenation, use a StringBuilder. When you concatenate with a String, you create a new String each time, using up more memory.AlexAs a general rule of thumb, if I have to set the value of the string more than once, or if there are any appends to the string, then it needs to be a string builder. I have seen applications that I have written in the past before learning about string builders that have had a huge memory foot print that just seems to keep growing and growing. Changing these programs to use the string builder cut down the memory usage significantly. Now I swear by the string builder.My approach has always been to use StringBuilder when concatenating 4 or more strings \nOR\nWhen I don\'t know how may concatenations are to take place.Good performance related article on it hereStringBuilder is significantly more efficient but you will not see that performance unless you are doing a large amount of string modification. Below is a quick chunk of code to give an example of the performance. As you can see you really only start to see a major performance increase when you get into large iterations.As you can see the 200,000 iterations took 22 seconds while the 1 million iterations using the StringBuilder was almost instant.Result of the above code:Beginning String + at 28/01/2013 16:55:40.Finished String + at 28/01/2013 16:55:40.Beginning String + at 28/01/2013 16:55:40.Finished String + at 28/01/2013 16:56:02.Beginning Sb append at 28/01/2013 16:56:02.Finished Sb append at 28/01/2013 16:56:02.StringBuilder will perform better, from a memory stand point. As for processing, the difference in time of execution may be negligible.