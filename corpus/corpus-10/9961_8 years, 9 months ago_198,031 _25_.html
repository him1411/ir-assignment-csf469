I need to do a LINQ2DataSet query that does a join on more than one field (asI have yet found a suitable solution (I can add the extra constraints to a where clause, but this is far from a suitable solution, or use this solution, but that assumes an equijoin).Is it possible in LINQ to join on multiple fields in a single join?EDITis the solution I referenced as assuming an equijoin above.Further EDITTo answer criticism that my original example was an equijoin, I do acknowledge that, My current requirement is for an equijoin and I have already employed the solution I referenced above.I am, however, trying to understand what possibilities and best practices I have / should employ with LINQ. I am going to need to do a Date range query join with a table ID soon, and was just pre-empting that issue, It looks like I shall have to add the date range in the where clause.Thanks, as always, for all suggestions and comments givenThe solution with the anonymous type should work fine. LINQ can only represent equijoins (with join clauses, anyway), and indeed that\'s what you\'ve said you want to express anyway based on your original query.If you don\'t like the version with the anonymous type for some specific reason, you should explain that reason.If you want to do something other than what you originally asked for, please give an example of what you really want to do.EDIT: Responding to the edit in the question: yes, to do a "date range" join, you need to use a where clause instead. They\'re semantically equivalent really, so it\'s just a matter of the optimisations available. Equijoins provide simple optimisation (in LINQ to Objects, which includes LINQ to DataSets) by creating a lookup based on the inner sequence - think of it as a hashtable from key to a sequence of entries matching that key.Doing that with date ranges is somewhat harder. However, depending on exactly what you mean by a "date range join" you may be able to do something similar - if you\'re planning on creating "bands" of dates (e.g. one per year) such that two entries which occur in the same year (but not on the same date) should match, then you can do it just by using that band as the key. If it\'s more complicated, e.g. one side of the join provides a range, and the other side of the join provides a single date, matching if it falls within that range, that would be better handled with a where clause (after a second from clause) IMO. You could do some particularly funky magic by ordering one side or the other to find matches more efficiently, but that would be a lot of work - I\'d only do that kind of thing after checking whether performance is an issue.Just to complete this with an equivalent method chain syntax:While the last argument (x, y) => x is what you select (in the above case we select x).You need to do this, if the column names are different in two entities.I think a more readable and flexible option is to use Where function:This also allows to easily change from inner join to left join by appending .DefaultIfEmpty().Using the join operator you can only perform equijoins.  Other types of joins can be constructed using other operators.  I\'m not sure whether the exact join you are trying to do would be easier using these methods or by changing the where clause.  Documentation on the join clause can be found here.  MSDN has an article on join operations with multiple links to examples of other joins, as well.you could do something like (below) If the field name are different in entities Declare a Class(Type) to hold the elements you want to join. In the below example declare JoinElementresults = from course in courseQueryable.AsQueryable()\n                      join agency in agencyQueryable.AsQueryable()\n                       on new JoinElement() { Id = course.CourseAgencyId, Name = course.CourseDeveloper } \n                       equals new JoinElement() { Id = agency.CourseAgencyId, Name = "D" } into temp1this works for me