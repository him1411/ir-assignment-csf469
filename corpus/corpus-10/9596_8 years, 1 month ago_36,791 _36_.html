And what factors would cause me to choose one or the other?Newer versions of Ruby (2.0+) do not really have significant differences between the two classes. Some libraries will use one or the other for historical reasons, but new code does not necessarily need to be concerned. Picking one for consistency is probably best, so try and mesh with what your libraries expect. For example, ActiveRecord prefers DateTime.In versions prior to Ruby 1.9 and on many systems Time is represented as a 32-bit signed value describing the number of seconds since January 1, 1970 UTC, a thin wrapper around a POSIX-standard time_t value, and is bounded:Newer versions of Ruby are able to handle larger values without producing errors.DateTime is a calendar-based approach where the year, month, day, hour, minute and second are stored individually. This is a Ruby on Rails construct that serves as a wrapper around SQL-standard DATETIME fields. These contain arbitrary dates and can represent nearly any point in time as the range of expression is typically very large.So it\'s reassuring that DateTime can handle blog posts from Aristotle.When choosing one, the differences are somewhat subjective now. Historically DateTime has provided better options for manipulating it in a calendar fashion, but many of these methods have been ported over to Time as well, at least within the Rails environment.As of ruby 2.0, most of the aforementioned information is out of date.In particular, Time is now practically unbound. It can be more or less than even 63 bits away from Epoch:The only consequence of using larger values should be performance, which is better when Integers are used (vs. Bignums (values outside of Integer range) or Rationals (when nanoseconds are tracked)):Since Ruby 1.9.2, Time implementation uses a signed 63 bit integer, Bignum or Rational. The integer is a number of nanoseconds since the Epoch which can represent 1823-11-12 to 2116-02-20. When Bignum or Rational is used (before 1823, after 2116, under nanosecond), Time works slower as when integer is used.\n  (http://www.ruby-doc.org/core-2.1.0/Time.html)In other words, as far as I understand, DateTime no longer covers a wider range of potential values than Time.In addition, two previously unmentioned restrictions of DateTime should probably be noted:DateTime does not consider any leapseconds, does not track any summer time rules.\n  (http://www.ruby-doc.org/stdlib-2.1.0/libdoc/date/rdoc/Date.html#class-Date-label-DateTime)First, DateTime has no concept of leap seconds:Second, DateTime has very limited understanding of time zones and in particular has no concept of daylight savings. It pretty much handles time zones as simple UTC + X offsets:This may cause trouble when times are entered as DST and then converted into a non-DST time zone without keeping track of the correct offsets outside of DateTime itself (many operating systems may actually already take care of this for you).Overall, I\'d say that nowadays Time is the better choice for most applications.Also note an important difference on addition: when you add a number to a Time object, it is counted in seconds, but when you add a number to a DateTime, it is counted in days.Outdated! See below...The performance difference can\'t be emphasized enough... Time is C, and DateTime is Ruby:Update (2/2012):As already mentioned in the comment, 1.9.3 has vastly improved DateTime performance:I think the answer to "what\'s the difference" is one of the unfortunate common answers to this question in the Ruby standard libraries: the two classes/libs were created differently by different people at different times. It\'s one of the unfortunate consequences of the community nature of Ruby\'s evolution compared to carefully planned development of something like Java. Developers want new functionality but don\'t want to step on existing APIs so they just create a new class - to the end user there\'s no obvious reason for the two to exist.This is true for software libraries in general: often the reason some code or API is the way it is turns out to be historical rather than logical.The temptation is to start with DateTime because it seems more generic. Date... and Time, right? Wrong. Time also does dates better, and in fact can parse timezones where DateTime can\'t. Also it performs better.I\'ve ended up using Time everywhere.To be safe though, I tend to allow for DateTime arguments to be passed into my Timey APIs, and either convert. Also if I know that both have the method I\'m interested in I accept either, like this method I wrote for converting times to XML (for XMLTV files)I found such things like parsing and calculating the beginning/end of a day in different timezones are easier to do with DateTime, assuming you are using the ActiveSupport extensions.In my case I needed to calculate the end of the day in a user\'s timezone (arbitrary) based on the user\'s local time which I received as a string, e.g. "2012-10-10 10:10 +0300"With DateTime it\'s as simple as Now let\'s try it the same way with Time:Actually, Time needs to know the timezone before parsing (also note it\'s Time.zone.parse, not Time.parse):So, in this case it\'s definitely easier to go with DateTime.Consider how they handle timezones differently with custom instantiations:This can be tricky when creating time ranges, etc.