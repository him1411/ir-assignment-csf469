Before KitKat (or before the new Gallery) the Intent.ACTION_GET_CONTENT returned a URI like thiscontent://media/external/images/media/3951.Using the ContentResolver and quering for\nMediaStore.Images.Media.DATA returned the file URL.In KitKat however the Gallery returns a URI (via "Last") like this:content://com.android.providers.media.documents/document/image:3951How do I handle this?Try this:  Probably need @SuppressLint("NewApi")for takePersistableUriPermissionThis requires no special permissions, and works with the Storage Access Framework, as well as the unofficial ContentProvider pattern (file path in _data field).See an up-to-date version of this method here.Had the same problem, tried the solution above but though it worked generally, for some reason I was getting permission denial on Uri content provider for some images although I had the android.permission.MANAGE_DOCUMENTS permission added properly.Anyway found other solution which is to force opening image gallery instead of KITKAT documents view with :and then load the image:EDITACTION_OPEN_DOCUMENT might require you to persist permissions flags etc and generally often results in Security Exceptions...Other solution is to use the ACTION_GET_CONTENT combined with c.getContentResolver().openInputStream(selectedImageURI) which will work both on pre-KK and KK. Kitkat will use new documents view then and this solution will work with all apps like Photos, Gallery, File Explorer, Dropbox, Google Drive etc...) but remember that when using this solution you have to create image in your onActivityResult() and store it on SD Card for example. Recreating this image from saved uri on next app launch would throw Security Exception on content resolver even when you add permission flags as described in Google API docs (that\'s what happened when I did some testing)Additionally the Android Developer API Guidelines suggest:ACTION_OPEN_DOCUMENT is not intended to be a replacement for ACTION_GET_CONTENT. The one you should use depends on the needs of\n  your app:Use ACTION_GET_CONTENT if you want your app to simply read/import\n  data. With this approach, the app imports a copy of the data, such as\n  an image file.Use ACTION_OPEN_DOCUMENT if you want your app to have\n  long term, persistent access to documents owned by a document\n  provider. An example would be a photo-editing app that lets users edit\n  images stored in a document provider.Just as Commonsware mentioned, you shouldn\'t assume, that the stream you get via ContentResolver is convertable into file.What you really should do is to open the InputStream from the ContentProvider, then create a Bitmap out of it. And it works on 4.4 and earlier versions as well, no need for reflection.Of course if you handle big images, you should load them with appropriate inSampleSize: http://developer.android.com/training/displaying-bitmaps/load-bitmap.html. But that\'s another topic.I believe the responses already posted should get people going in the right direction. However here is what I did that made sense for the legacy code I was updating. The legacy code was using the URI from the gallery to change and then save the images.Prior to 4.4 (and google drive), the URIs would look like this:\ncontent://media/external/images/media/41As stated in the question, they more often look like this:\ncontent://com.android.providers.media.documents/document/image:3951Since I needed the ability to save images and not disturb the already existing code, I just copied the URI from the gallery into the data folder of the app. Then originated a new URI from the saved image file in the data folder.Here\'s the idea:Note - copyAndClose() just does file I/O to copy InputStream into a FileOutputStream. The code is not posted.QuestionHow to get an actual file path from a URIAnswerTo my knowledge, we don\'t need to get the file path from a URI because for most of the cases we can directly use the URI to get our work done (like 1. getting  bitmap 2. Sending a file to the server, etc.)1. Sending to the serverWe can directly send the file to the server using just the URI.Using the URI we can get InputStream, which we can directly send to the server using MultiPartEntity.Example2. Getting a BitMap from a URIIf the URI is pointing to image then we will get bitmap, else null:CommentsReferenceThis Android library handles the case changes in KitKat(including the oldere versions - 2.1+):\nhttps://github.com/iPaulPro/aFileChooserUse the String path = FileUtils.getPath(context, uri) to convert the returned Uri to a path string useable on all OS version.\nSee more about it here: https://stackoverflow.com/a/20559175/860488I\'ve combine multiple answers into one working solution that results with file pathMime type is irrelevant for the example purpose.Handling resultFilePickUtilsThis is what I do:NOTE: managedQuery() method is deprecated, so I am not using it.This answer is from m3n0R on question android get real path by Uri.getPath() and I claim no credit. I just thought that people who haven\'t solved this issue yet could use this.For those who is still using @Paul Burke\'s code with Android SDK version 23 and above, if your project met the error saying that you are missing EXTERNAL_PERMISSION, and you are very sure you have already added user-permission in your AndroidManifest.xml file. That\'s because you may in Android API 23 or above and Google make it necessary to guarantee permission again while you make the action to access the file in runtime.That means: If your SDK version is 23 or above, you are asked for READ & WRITE permission while you are selecting the picture file and want to know the URI of it.And following is my code, in addition to Paul Burke\'s solution. I add these code and my project start to work fine.And in your activity&fragment where you are asking for the URI:In my case, CompatUtils.java is where I define the verifyStoragePermissions method (as static type so I can call it within other activity).Also it should make more sense if you make an if state first to see whether the current SDK version is above 23 or not before you call the verifyStoragePermissions method.Please try to avoid using takePersistableUriPermission method because it raised runtime exception for me.\n/**\n     * Select from gallery.\n     */OnActivity for result to handle the image data:@Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {This is a total hack, but here\'s what I did...So while playing with setting up a DocumentsProvider, I noticed that the sample code (in getDocIdForFile, around line 450) generates a unique id for a selected document based on the file\'s (unique) path relative to the specified root you give it (that is, what you set mBaseDir to on line 96).So the URI ends up looking something like:content://com.example.provider/document/root:path/to/the/fileAs the docs say, it\'s assuming only a single root (in my case that\'s Environment.getExternalStorageDirectory() but you may use somewhere else... then it takes the file path, starting at the root, and makes it the unique ID, prepending "root:".  So I can determine the path by eliminating the "/document/root:" part from uri.getPath(), creating an actual file path by doing something like this:I know.  It\'s shameful, but it worked.  Again, this relies on you using your own documents provider in your app to generate the document ID.(Also, there\'s a better way to build the path that don\'t assume "/" is the path separator, etc.  But you get the idea.)If anyone\'s interested, I made a working Kotlin version for ACTION_GET_CONTENT:This worked fine for me:I\'ve tried several of the answers here, and I think I have a solution that will work every time and manages permissions as well.It is based on the clever solution from LEO. This post should contain all the code you need to make this work, and it should work on any phone and Android version ;)In order to have the ability to pick a file from an SD card, you\'ll need this in your manifest:Launch image pickManage Image pick responseThat\'s all folks; this works for me on all the telephones I have.Building up on Paul Burke\'s answer I faced many problems resolving external SD card\'s URI path as most of the suggested "built-in" functions return paths which do not get resolved to files.However, this is my approach of his\n// TODO handle non-primary volumes.Note it depends on hierarchy which might be different on every phone manufacturer - I have not tested them all (it worked well so far on Xperia Z3 API 23 and Samsung Galaxy A3 API 23).Please confirm if it does not perform well elsewhere.@paul burke\'s answer works fine for both camera and gallery pictures for API level 19 and above, but it doesn\'t work if your Android project\'s minimum SDK is set to below 19, and some answers referring above doesn\'t work for both gallery and camera. Well, I have modified @paul burke\'s code which works for API level below 19. Below is the code.The answer to your question is that you need to have permissions. Type the following code in your manifest.xml file:It worked for me...