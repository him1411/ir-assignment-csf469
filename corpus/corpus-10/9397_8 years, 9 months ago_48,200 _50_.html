In practice with C++, what is RAII, what are smart pointers, how are these implemented in a program and what are the benefits of using RAII with smart pointers?A simple (and perhaps overused) example of RAII is a File class. Without RAII, the code might look something like this:In other words, we must make sure that we close the file once we\'ve finished with it. This has two drawbacks - firstly, wherever we use File, we will have to called File::close() - if we forget to do this, we\'re holding onto the file longer than we need to. The second problem is what if an exception is thrown before we close the file?Java solves the second problem using a finally clause:C++ solves both problems using RAII - that is, closing the file in the destructor of File. So long as the File object is destroyed at the right time (which it should be anyway), closing the file is taken care of for us. So, our code now looks something like:The reason this cannot be done in Java is that we have no guarantee over when the object will be destroyed, so cannot guarantee when a resource such as file will be freed.Onto smart pointers - a lot of the time, we just create objects on the stack. For instance (and stealing an example from another answer):This works fine - but what if we want to return str? We could write this:So, what\'s wrong with that? Well, the return type is std::string - so it means we\'re returning by value. This means that we copy str and actually return the copy. This can be expensive, and we might want to avoid the cost of copying it. Therefore, we might come up with idea of returning by reference or by pointer.Unfortunately, this code doesn\'t work. We\'re returning a pointer to str - but str was created on the stack, so we be deleted once we exit foo(). In other words, by the time the caller gets the pointer, it\'s useless (and arguably worse than useless since using it could cause all sorts of funky errors)So, what\'s the solution? We could create str on the heap using new - that way, when foo() is completed, str won\'t be destroyed.Of course, this solution isn\'t perfect either. The reason is that we\'ve created str, but we never delete it. This might not be a problem in a very small program, but in general, we want to make sure we delete it. We could just say that the caller must delete the object once he\'s finished with it. The downside is that the caller has to manage memory, which adds extra complexity, and might get it wrong, leading to a memory leak i.e. not deleting object even though it is no longer required.This is where smart pointers come in. The following example uses shared_ptr - I suggest you look at the different types of smart pointers to learn what you actually want to use.Now, shared_ptr will count the number of references to str. For instanceNow there are two references to the same string. Once there are no remaining references to str, it will be deleted. As such, you no longer have to worry about deleting it yourself.Quick edit: as some of the comments have pointed out, this example isn\'t perfect for (at least!) two reasons. Firstly, due to the implementation of strings, copying a string tends to be inexpensive. Secondly, due to what\'s known as named return value optimisation, returning by value may not be expensive since the compiler can do some cleverness to speed things up.So, let\'s try a different example using our File class.Let\'s say we want to use a file as a log. This means we want to open our file in append only mode:Now, let\'s set our file as the log for a couple of other objects:Unfortunately, this example ends horribly - file will be closed as soon as this method ends, meaning that foo and bar now have an invalid log file. We could construct file on the heap, and pass a pointer to file to both foo and bar:But then who is responsible for deleting file? If neither delete file, then we have both a memory and resource leak. We don\'t know whether foo or bar will finish with the file first, so we can\'t expect either to delete the file themselves. For instance, if foo deletes the file before bar has finished with it, bar now has an invalid pointer.So, as you may have guessed, we could use smart pointers to help us out.Now, nobody needs to worry about deleting file - once both foo and bar have finished and no longer have any references to file (probably due to foo and bar being destroyed), file will automatically be deleted.RAII This is a strange name for a simple but awesome concept. Better is the name Scope Bound Resource Management (SBRM). The idea is that often you happen to allocate resources  at the begin of a block, and need to release it at the exit of a block. Exiting the block can happen by normal flow control, jumping out of it, and even by an exception. To cover all these cases, the code becomes more complicated and redundant. Just an example doing it without SBRM:As you see there are many ways we can get pwned. The idea is that we encapsulate the resource management into a class. Initialization of its object acquires the resource ("Resource Acquisition Is Initialization"). At the time we exit the block (block scope), the resource is freed again. That is nice if you have got classes of their own which are not solely for the purpose of allocating/deallocating resources. Allocation would just be an additional concern to get their job done. But as soon as you just want to allocate/deallocate resources, the above becomes unhandy. You have to write a wrapping class for every sort of resource you acquire. To ease that, smart pointers allow you to automate that process:Normally, smart pointers are thin wrappers around new / delete that just happen to call delete when the resource they own goes out of scope. Some smart pointers, like shared_ptr allow you to tell them a so-called deleter, which is used instead of delete. That allows you, for instance, to manage window handles, regular expression resources and other arbitrary stuff, as long as you tell shared_ptr about the right deleter. There are different smart pointers for different purposes:Code:Unlike auto_ptr, unique_ptr can be put into a container, because containers will be able to hold non-copyable (but movable) types, like streams and unique_ptr too. Code:Code:As you see, the plot-source (function fx) is shared, but each one has a separate entry, on which we set the color. There is a weak_ptr class which is used when code needs to refer to the resource owned by a smart pointer, but doesn\'t need to own the resource. Instead of passing a raw pointer, you should then create a weak_ptr. It will throw an exception when it notices you try to access the resource by an weak_ptr access path, even though there is no shared_ptr anymore owning the resource.RAII is the design paradigm to ensure that variables handle all needed initialization in their constructors and all needed cleanup in their destructors.  This reduces all initialization and cleanup to a single step.C++ does not require RAII, but it is increasingly accepted that using RAII methods will produce more robust code.The reason that RAII is useful in C++ is that C++ intrinsically manages the creation and destruction of variables as they enter and leave scope, whether through normal code flow or through stack unwinding triggered by an exception.  That\'s a freebie in C++.By tying all initialization and cleanup to these mechanisms, you are ensured that C++ will take care of this work for you as well.Talking about RAII in C++ usually leads to the discussion of smart pointers, because pointers are particularly fragile when it comes to cleanup.  When managing heap-allocated memory acquired from malloc or new, it is usually the responsibility of the programmer to free or delete that memory before the pointer is destroyed.  Smart pointers will use the RAII philosophy to ensure that heap allocated objects are destroyed any time the pointer variable is destroyed.Smart pointer is a variation of RAII. RAII means resource acquisition is initialization. Smart pointer acquires a resource (memory) before usage and then throws it away automatically in a destructor. Two things happen:For instance, another example is network socket RAII. In this case:Now, as you can see, RAII is a very useful tool in most cases as it helps people to get laid.C++ sources of smart pointers are in millions around the net including responses above me.Boost has a number of these including the ones in Boost.Interprocess for shared memory. It greatly simplifies memory management, especially in headache-inducing situations like when you have 5 processes sharing the same data structure: when everyone\'s done with a chunk of memory, you want it to automatically get freed & not have to sit there trying to figure out who should be responsible for calling delete on a chunk of memory, lest you end up with a memory leak, or a pointer which is mistakenly freed twice and may corrupt the whole heap.No matter what happens, bar is going to be properly deleted once the scope of the foo() function has been left behind.Internally std::string implementations often use reference counted pointers.  So the internal string only needs to be copied when one of the copies of the strings changed.  Therefore a reference counted smart pointer makes it possible to only copy something when necessary.In addition, the internal reference counting makes it possible that the memory will be properly deleted when the copy of the internal string is no longer needed.