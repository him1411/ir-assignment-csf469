If I call SelectAll from a GotFocus event handler, it doesn\'t work with the mouse - the selection disappears as soon as mouse is released.EDIT: People are liking Donnelle\'s answer, I\'ll try to explain why I did not like it as much as the accepted answer.Don\'t know why it loses the selection in the GotFocus event.But one solution is to do the selection on the GotKeyboardFocus and the GotMouseCapture events. That way it will always work.We have it so the first click selects all, and another click goes to cursor (our application is designed for use on tablets with pens).You might find it useful.Donnelle\'s answer works the best, but having to derive a new class to use it is a pain. Instead of doing that I register handlers the handlers in App.xaml.cs for all TextBoxes in the application. This allows me to use a Donnelle\'s answer with standard TextBox control.Add the following methods to your App.xaml.cs:This is rather old, but I\'ll display my answer anyway.\nI have chosen part of Donnelle\'s answer (skipped the double-click) for I think this creates the least astonishment in the users. However, like gcores I dislike the need to create a derived class. But I also don\'t like gcores "on Startup..." method. And I need this on a "generally but not always"-basis.  I have Implemented this as an attached dependency Property so I can set SelectTextOnFocus.Active=True in xaml. I find this way the most pleasing.For my "general but not always"-feature I set this Property to True in a (global) TextBox-Style. This way "selecting the Text" is always "on", but I am able to disable it on a per-Textbox-basis.Here are the Blend behaviors implementing the answer solution for your convenience:One for attaching to a single TextBox:And one for attaching to the root of a container containing multiple TextBox\'es:Here\'s a very good very simple solution on MSDN:Here\'s the code behind:Although this is an old question, I have just had this problem but solved it using an Attached Behavior, rather than an Expression Behavior as in Sergey\'s answer. This means I don\'t need a dependency on System.Windows.Interactivity in the Blend SDK:You can then use it in your XAML like this:I blogged about it here.I think this works well:If you would like to implement it as an extension method:And in your GotFocus event:I discovered the solution above because several months ago I was looking for a way to set focus to a given UIElement.  I discovered the the code below somewhere (credit is hereby given) and it works well.  I post it even though it is not directly related to the OP\'s question because it demonstrates the same pattern of using Dispatcher to work with a UIElement.I\'ve found none of the answers presented here mimic a standard Windows textbox. For instance, try to click in the white space between the last character of the textbox and the right side of the textbox. Most of the solutions here will always select the whole content, which makes it very difficult to append text to a textbox.The answer that I present here behaves better in this respect. It is a behavior (so it requires the System.Windows.Interactivity assembly from the Blend SDK). It could be rewritten using attached properties as well.This is based on code I\'ve found here.This simple implementation works perfectly for me:To apply it to all TextBox\'s, put the following code after InitializeComponent();Taken from here:Register global event handler in App.xaml.cs file:\nThen the handler is as simple as:\nin App.xaml filein App.xaml.cs fileWith this code you reach all TextBox in your Application.I have a slightly simplified answer for this (with just the PreviewMouseLeftButtonDown event) which seems to mimic the usual functionality of a browser:In xaml you have a textbox say:In codebehind:For those interested in Donnelle\'s/Groky\'s approach, but want a click to the right of the last character (but still within the TextBox) to place the caret at the end of the entered text, I\'ve come up with this solution:The GetRoundedCharacterIndexFromPoint method was taken from this post.I searched a lot for the solution, I found couple of solutions to selectall But, the issue is when we do right click and do cut/copy after selecting part of text from text box, it selects all even I selected part of text. To fix this here is the solution. Just add the below code in the keyboard select event. This worked for me.I have used Nils\' answer but converted to more flexible.In XAML, you can use like one of these:Try this extension method to add the desired behaviour to any TextBox control. I havn\'t tested it extensively yet, but it seems to fulfil my needs.This seems to work well for me. It\'s basically a recap of some earlier posts. I just put this into my MainWindow.xaml.cs file in the constructor. I create two handlers, one for keyboard, and one for the mouse, and funnel both events into the same function, HandleGotFocusEvent, which is defined right after the constructor in the same file.An easy way to override the mouseDown and select all after doubleclick is:I had same problem. In VB.Net it works easy that way:XAML:Codehind:Try putting this in the constructor of whatever control is housing your textbox:Sergei.After googling and testing, I\'ve found a simple solution that worked for me.You need to add an event handler to the "Loaded" event of your container window:Next, you have to create the handler to the referenced RoutedEventHandler in previous code:Now, you can add the SelectAll() command on GotFocus event handlers to any TextBox controls separately:Your text now is selected on focus!Adapted from Dr. WPF solution, MSDN ForumsThis is by far the simplest solution.Add a global handler to the application (App.xaml.cs) and done. You are going to need only a few lines of code.Check here: WPF TextBox SelectAll on FocusHope it helps.I have tested all of them but only the following worked out:WOW!  After reading all the above I find myself overwhelmed and confused.  I took what I thought I learned in this post and tried something completely different.  To select the text in a textbox when it gets focus I use this:Set the GotFocus property of the textbox to this method.Running the application and clicking once in the textbox highlights everything already in the textbox.If indeed, the objective is to select the text when the user clicks in the textbox, this seems simple and involves a whole lot less code.  Just saying...