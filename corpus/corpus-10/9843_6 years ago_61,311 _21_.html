I noticed that Scala provide lazy vals. But I don\'t get what they do.The REPL shows that y is a lazy val, but how is it different from a normal val?The difference between them is, that a val is executed when it is defined whereas a lazy val is executed when it is accessed the first time.In contrast to a method (defined with def) a lazy val is executed once and then never again. This can be useful when an operation takes long time to complete and when it is not sure if it is later used.Here, when the values x and y are never used, only x unnecessarily wasting resources. If we suppose that y has no side effects and that we do not know how often it is accessed (never, once, thousands of times) it is useless to declare it as def since we don\'t want to execute it several times.If you want to know how lazy vals are implemented, see this question.This feature helps not only delaying expensive calculations, but is also useful to construct mutual dependent or cyclic structures. E.g. this leads to an stack overflow:But with lazy vals it works fineAlso lazy is useful without cyclic dependencies, as in the following code:Accessing Y will now throw null pointer exception, because x is not yet initialized.\nThe following, however, works fine:EDIT: the following will also work: This is called an "early initializer". See this SO question for more details. A lazy val is most easily understood as a "memoized def".Like a def, a lazy val is not evaluated until it is invoked.  But the result is saved so that subsequent invocations return the saved value.  The memoized result takes up space in your data structure, like a val.As others have mentioned, the use cases for a lazy val are to defer expensive computations until they are needed and store their results, and to solve certain circular dependencies between values.Lazy vals are in fact implemented more or less as memoized defs.  You can read about the details of their implementation here:http://docs.scala-lang.org/sips/pending/improved-lazy-val-initialization.htmlI understand that the answer is given but I wrote a simple example to make it easy to understand for beginners like me:Output of above code is:As it can be seen, x is printed when it\'s initialized, but y is not printed when it\'s initialized in same way (I have taken x as var intentionally here - to explain when y gets initialized). Next when y is called, it\'s initialized as well as value of last \'x\' is taken into consideration but not the old one.Hope this helps.