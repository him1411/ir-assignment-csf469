Is there a way of reading one single character from the user input? For instance, they press one key at the terminal and it is returned (sort of like getch()). I know there\'s a function in Windows for it, but I\'d like something that is cross-platform.Here\'s a link to a site that says how you can read a single character in Windows, Linux and OSX: http://code.activestate.com/recipes/134892/will basically read 1 byte from STDIN.If you must use the method which does not wait for the \\n you can use this code as suggested in previous answer:(taken from http://code.activestate.com/recipes/134892/)The ActiveState recipe quoted verbatim in two answers is over-engineered. It can be boiled down to this:Also worth trying is the readchar library, which is in part based on the ActiveState recipe mentioned in other answers.Installation:Usage:Tested on Windows and Linux with Python 2.7.On Windows, only keys which map to letters or ASCII control codes are supported (Backspace, Enter, Esc, Tab, Ctrl+letter). On GNU/Linux (depending on exact terminal, perhaps?) you also get Insert, Delete, Pg Up, Pg Dn, Home, End and F n keys... but then, there\'s issues separating these special keys from an Esc.Caveat: Like with most (all?) answers in here, signal keys like Ctrl+C, Ctrl+D and Ctrl+Z are caught and returned (as \'\\x03\', \'\\x04\' and \'\\x1a\' respectively); your program can be come difficult to abort.An alternative method:From this blog post.I think it gets extremely clunky at this point, and debugging on the different platforms is a big mess.You\'d be better off using something like pyglet, pygame, cocos2d - if you are doing something more elaborate than this and will need visuals, OR curses if you are going to work with the terminal.Curses is standard: http://docs.python.org/library/curses.htmlThis code, based off here, will correctly raise KeyboardInterrupt and EOFError if Ctrl+C or Ctrl+D are pressed.Should work on Windows and Linux. An OS X version is available from the original source.The (currently) top-ranked answer (with the ActiveState code) is overly complicated. I don\'t see a reason to use classes when a mere function should suffice. Below are two implementations that accomplish the same thing but with more readable code.Both of these implementations:Version 1: readable and simpleVersion 2: avoid repeated imports and exception handling:[EDIT] I missed one advantage of the ActiveState code. If you plan to read characters multiple times, that code avoids the (negligible) cost of repeating the Windows import and the ImportError exception handling on Unix-like systems. While you probably should be more concerned about code readability than that negligible optimization, here is an alternative (it is similar to Louis\'s answer, but getChar() is self-contained) that functions the same as the ActiveState code and is more readable:Example code that exercises either of the getChar() versions above:This might be a use case for a context manager.  Leaving aside allowances for Windows OS, here\'s my suggestion:The answers here were informative, however I also wanted a way to get key presses asynchronously and fire off key presses in separate events, all in a thread-safe, cross-platform way. PyGame was also too bloated for me. So I made the following (in Python 2.7 but I suspect it\'s easily portable), which I figured I\'d share here in case it was useful for anyone else. I stored this in a file named keyPress.py.The idea is that you can either simply call keyPress.getKey(), which will read a key from the keyboard, then return it.If you want something more than that, I made a KeyCapture object. You can create one via something like keys = keyPress.KeyCapture().Then there are three things you can do:addEvent(functionName) takes in any function that takes in one parameter. Then every time a key is pressed, this function will be called with that key\'s string as it\'s input. These are ran in a separate thread, so you can block all you want in them and it won\'t mess up the functionality of the KeyCapturer nor delay the other events.get() returns a key in the same blocking way as before. It is now needed here because the keys are being captured via the KeyCapture object now, so keyPress.getKey() would conflict with that behavior and both of them would miss some keys since only one key can be captured at a time. Also, say the user presses \'a\', then \'b\', you call get(), the the user presses \'c\'. That get() call  will immediately return \'a\', then if you call it again it will return \'b\', then \'c\'. If you call it again it will block until another key is pressed. This ensures that you don\'t miss any keys, in a blocking way if desired. So in this way it\'s a little different than keyPress.getKey() from beforeIf you want the behavior of getKey() back, get(lossy=True) is like get(), except that it only returns keys pressed after the call to get(). So in the above example, get() would block until the user presses \'c\', and then if you call it again it will block until another key is pressed.getAsync() is a little different. It\'s designed for something that does a lot of processing, then occasionally comes back and checks which keys were pressed. Thus getAsync() returns a list of all the keys pressed since the last call to getAsync(), in order from oldest key pressed to most recent key pressed. It also doesn\'t block, meaning that if no keys have been pressed since the last call to getAsync(), an empty  [] will be returned.To actually start capturing keys, you need to call keys.startCapture() with your keys object made above. startCapture is non-blocking, and simply starts one thread that just records the key presses, and another thread to process those key presses. There are two threads to ensure that the thread that records key presses doesn\'t miss any keys.If you want to stop capturing keys, you can call keys.stopCapture() and it will stop capturing keys. However, since capturing a key is a blocking operation, the thread capturing keys might capture one more key after calling stopCapture().To prevent this, you can pass in an optional parameter(s) into startCapture(functionName, args) of a function that just does something like checks if a key equals \'c\' and then exits. It\'s important that this function does very little before, for example, a sleep here will cause us to miss keys.However, if stopCapture() is called in this function, key captures will be stopped immediately, without trying to capture any more, and that all get() calls will be returned immediately, with None if no keys have been pressed yet.Also, since get() and getAsync() store all the previous keys pressed (until you retrieve them), you can call clearGetList() and clearAsyncList() to forget the keys previously pressed.Note that get(), getAsync() and events are independent, so if a key is pressed:\n1. One call to get() that is waiting, with lossy on, will return\n   that key. The other waiting calls (if any) will continue waiting.\n2. That key will be stored in the queue of get keys, so that get() with lossy off will return the oldest key pressed not returned by get() yet.\n3. All events will be fired with that key as their input\n4. That key will be stored in the list of getAsync() keys, where that lis twill be returned and set to empty list on the next call to getAsync()If all this is too much, here is an example use case:It is working well for me from the simple test I made, but I will happily take others feedback as well if there is something I missed.I posted this here as well.This is NON-BLOCKING, reads a key and and stores it in keypress.key. in your programmThe build-in raw_input should help. Try this with pygame:Try using this: http://home.wlu.edu/~levys/software/kbhit.py\nIt\'s non-blocking (that means that you can have a while loop and detect a key press without stopping it) and cross-platform.An example to use this:Or you could use the getch module from PyPi. But this would block the while loopThe curses package in python can be used to enter "raw" mode for character input from the terminal with just a few statements.  Curses\' main use is to take over the screen for output, which may not be what you want. This code snippet uses print() statements instead, which are usable, but you must be aware of how curses changes line endings attached to output. A comment in one of the other answers mentioned cbreak mode, which is important for Unix implementations because you generally don\'t want ^C (KeyboardError) to be consumed by getchar (as it will when you set the terminal to raw mode, as done by most other answers).Another important detail is that if you\'re looking to read one character and not one byte, you should read 4 bytes from the input stream, as that\'s the maximum number of bytes a single character will consist of in UTF-8 (Python 3+). Reading only a single byte will produce unexpected results for multi-byte characters such as keypad arrows.Here\'s my changed implementation for Unix:My solution for python3, not depending on any pip packages.