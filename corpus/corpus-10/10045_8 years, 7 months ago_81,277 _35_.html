Is there a valid reason for it being "True" and not "true"? It breaks when writing XML as XML\'s boolean type is lower case, and also isn\'t compatible with C#\'s true/false (not sure about CLS though).UpdateHere is my very hacky way of getting around it in C# (for use with XML)Of course that adds 1 more method to the stack, but removes ToLowers() everywhere.Only people from Microsoft can really answer that question. However, I\'d like to offer some fun facts about it ;)First, this is what it says in MSDN about the Boolean.ToString() method:Return ValueType: System.StringTrueString if the value of this\n  instance is true, or FalseString if\n  the value of this instance is false. RemarksThis method returns the\n  constants "True" or "False". Note that\n  XML is case-sensitive, and that the\n  XML specification recognizes "true"\n  and "false" as the valid set of\n  Boolean values. If the String object\n  returned by the ToString() method\n  is to be written to an XML file, its\n  String.ToLower method should be\n  called first to convert it to\n  lowercase.Here comes the fun fact #1: it doesn\'t return TrueString or FalseString at all. It uses hardcoded literals "True" and "False". Wouldn\'t do you any good if it used the fields, because they\'re marked as readonly, so there\'s no changing them.The alternative method, Boolean.ToString(IFormatProvider) is even funnier:RemarksThe provider parameter is reserved. It does not participate in the execution of this method. This means that the Boolean.ToString(IFormatProvider) method, unlike most methods with a provider parameter, does not reflect culture-specific settings. What\'s the solution? Depends on what exactly you\'re trying to do. Whatever it is, I bet it will require a hack ;)...because the .NET environment is designed to support many languages.System.Boolean (in mscorlib.dll) is designed to be used internally by languages to support a boolean datatype. C# uses all lowercase for its keywords, hence \'bool\', \'true\', and \'false\'.VB.NET however uses standard casing: hence \'Boolean\', \'True\', and \'False\'.Since the languages have to work together, you couldn\'t have true.ToString() (C#) giving a different result to True.ToString() (VB.NET). The CLR designers picked the standard CLR casing notation for the ToString() result.The string representation of the boolean true is defined to be Boolean.TrueString.(There\'s a similar case with System.String: C# presents it as the \'string\' type).For Xml you can use XmlConvert.ToString method.It\'s simple code to convert that to all lower case.Not so simple to convert "true" back to "True", however.is what I use for xml output.How is it not compatible with C#? Boolean.Parse and Boolean.TryParse is case insensitive and the parsing is done by comparing the value to Boolean.TrueString or Boolean.FalseString which are "True" and "False". EDIT: When looking at the Boolean.ToString method in reflector it turns out that the strings are hard coded so the ToString method is as follows:I know the reason why it is the way it is has already been addressed, but when it comes to "custom" boolean formatting, I\'ve got two extension methods that I can\'t live without anymore :-) Usage is trivial. The following converts various bool values to their Portuguese representations:The reason true is "True" is because of Microsoft\'s strong bond with XML standards.From Wikipedia:\n"Extensible Markup Language (XML) is a markup language that defines a set of rules for encoding documents in a format which is both human-readable and machine-readable."Human-readable is subjective, but in the eyes of XML, using the word "One" in place of a number "1" is preferred. You\'ll notice this happens using enums, as the word gets serialized instead of its value ("FirstOption" instead of "0" or "1").Likewise, text commonly follows CamelCasing. Therefore, instead of "string", XML prefers "String". This is why Boolean.TrueString is "True" and Boolean.FalseString is "False" by default.This probably harks from the old VB NOT .Net days when bool.ToString produced True or False.