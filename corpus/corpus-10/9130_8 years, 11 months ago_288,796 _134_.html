How can I check if a given number is even or odd in C?Use the modulo (%) operator to check if there\'s a remainder when dividing by 2:A few people have criticized my answer above stating that using x & 1 is "faster" or "more efficient". I do not believe this to be the case. Out of curiosity, I created two trivial test case programs:I then compiled these with gcc 4.1.3 on one of my machines 5 different times:I examined the assembly output of each compile (using gcc -S) and found that in each case, the output for and.c and modulo.c were identical (they both used the andl $1, %eax instruction). I doubt this is a "new" feature, and I suspect it dates back to ancient versions. I also doubt any modern (made in the past 20 years) non-arcane compiler, commercial or open source, lacks such optimization. I would test on other compilers, but I don\'t have any available at the moment.If anyone else would care to test other compilers and/or platform targets, and gets a different result, I\'d be very interested to know.Finally, the modulo version is guaranteed by the standard to work whether the integer is positive, negative or zero, regardless of the implementation\'s representation of signed integers. The bitwise-and version is not. Yes, I realise two\'s complement is somewhat ubiquitous, so this is not really an issue.You guys are waaaaaaaay too efficient. What you really want is:Repeat for isEven.Of course, that doesn\'t work for negative numbers. But with brilliance comes sacrifice...Use bit arithmetic:This is faster than using division or modulus.[Joke mode="on"][Joke mode="off"]EDIT: Added confusing values to the enum.In response to ffpf - I had exactly the same argument with a colleague years ago, and the answer is no, it doesn\'t work with negative numbers.The C standard stipulates that negative numbers can be represented in 3 ways:Checking like this:will work for 2\'s complement and sign and magnitude representation, but not for 1\'s complement.However, I believe that the following will work for all cases:Thanks to ffpf for pointing out that the text box was eating everything after my less than character!A nice one is:Note that this method use tail recursion involving two functions. It can be implemented efficiently (turned into a while/until kind of loop) if your compiler supports tail recursion like a Scheme compiler. In this case the stack should not overflow !A number is even if, when divided by two, the remainder is 0.  A number is odd if, when divided by 2, the remainder is 1.Methods are great!I\'d say just divide it by 2 and if there is a 0 remainder, it\'s even, otherwise it\'s odd.Using the modulus (%) makes this easy.eg.\n4 % 2 = 0 therefore 4 is even\n5 % 2 = 1 therefore 5 is oddOne more solution to the problem\n(children are welcome to vote)I would build a table of the parities (0 if even 1 if odd) of the integers (so one could do a lookup :D), but gcc won\'t let me make arrays of such sizes:So let\'s instead resort to the mathematical definition of even and odd instead.An integer n is even if there exists an integer k such that n = 2k.An integer n is odd if there exists an integer k such that n = 2k + 1.Here\'s the code for it:Let C-integers denote the possible values of int in a given C compilation. (Note that C-integers is a subset of the integers.)Now one might worry that for a given n in C-integers that the corresponding integer k might not exist within C-integers. But with a little proof it is can be shown that for all integers n, |n| <= |2n| (*), where |n| is "n if n is positive and -n otherwise". In other words, for all n in integers at least one of the following holds (exactly either cases (1 and 2) or cases (3 and 4) in fact but I won\'t prove it here):Case 1: n <= 2n.Case 2: -n <= -2n.Case 3: -n <= 2n.Case 4: n <= -2n.Now take 2k = n. (Such a k does exist if n is even, but I won\'t prove it here. If n is not even then the loop in even fails to return early anyway, so it doesn\'t matter.) But this implies k < n if n not 0 by (*) and the fact (again not proven here) that for all m, z in integers 2m = z implies z not equal to m given m is not 0. In the case n is 0, 2*0 = 0 so 0 is even we are done (if n = 0 then 0 is in C-integers because n is in C-integer in the function even, hence k = 0 is in C-integers). Thus such a k in C-integers exists for n in C-integers if n is even.A similar argument shows that if n is odd, there exists a k in C-integers such that n = 2k + 1.Hence the functions even and odd presented here will work properly for all C-integers.This is a follow up to the discussion with @RocketRoy regarding his answer, but it might be useful to anyone who wants to compare these results.tl;dr From what I\'ve seen, Roy\'s approach ((0xFFFFFFFF == (x | 0xFFFFFFFE)) is not completely optimized to x & 1 as the mod approach, but in practice running times should turn out equal in all cases.So, first I compared the compiled output using Compiler Explorer:Functions tested:CLang 3.9.0 with -O3:GCC 6.2 with -O3:Hats down to CLang, it realized that all three cases are functionally equal. However, Roy\'s approach isn\'t optimized in GCC, so YMMV.It\'s similar with Visual Studio; inspecting the disassembly Release x64 (VS2015) for these three functions, I could see that the comparison part is equal for "mod" and "and" cases, and slightly larger for the Roy\'s "or" case:However, after running an actual benchmark for comparing these three options (plain mod, bitwise or, bitwise and), results were completely equal (again, Visual Studio 2005 x86/x64, Release build, no debugger attached). Release assembly uses the test instruction for and and mod cases, while Roy\'s case uses the cmp eax,0FFFFFFFFh approach, but it\'s heavily unrolled and optimized so there is no difference in practice.My results after 20 runs (i7 3610QM, Windows 10 power plan set to High Performance):The difference between these options is less than 0.3%, so it\'s rather obvious the assembly is equal in all cases.Here is the code if anyone wants to try, with a caveat that I only tested it on Windows (check the #if LINUX conditional for the get_time definition and implement it if needed, taken from this answer).Here is an answer in \nJava:As some people have posted, there are numerous ways to do this. According to this website, the fastest way is the modulus operator:However, here is some other code that was bench marked by the author which ran slower than the common modulus operation above:How many people even knew of the Math.System.DivRem method or why would they use it??Try this: return (((a>>1)<<1) == a)Example:Reading this rather entertaining discussion, I remembered that I had a real-world, time-sensitive function that tested for odd and even numbers inside the main loop. It\'s an integer power function, posted elsewhere on StackOverflow, as follows. The benchmarks were quite surprising. At least in this real-world function, modulo is slower, and significantly so. The winner, by a wide margin, requiring 67% of modulo\'s time, is an or ( | ) approach, and is nowhere to be found elsewhere on this page. For 300 million loops, the benchmark timings are as follows. 3.962 the | and mask approach4.851 the & approach5.850 the % approachFor people who think theory, or an assembly language listing, settles arguments like these, this should be a cautionary tale. There are more things in heaven and earth, Horatio, than are dreamt of in your philosophy. I know this is just syntactic sugar and only applicable in .net but what about extension method...Now you can do the followingIn the "creative but confusing category" I offer:A variant on this theme that is specific to Microsoft C++:The bitwise method depends on the inner representation of the integer. Modulo will work anywhere there is a modulo operator. For example, some systems actually use the low level bits for tagging (like dynamic languages), so the raw x & 1 won\'t actually work in that case.IsOdd(int x) { return true; }Proof of correctness - consider the set of all positive integers and suppose there is a non-empty set of integers that are not odd.  Because positive integers are well-ordered, there will be a smallest not odd number, which in itself is pretty odd, so clearly that number can\'t be in the set.  Therefore this set cannot be non-empty.  Repeat for negative integers except look for the greatest not odd number.Portable:Unportable:done.To give more elaboration on the bitwise operator method for those of us who didn\'t do much boolean algebra during our studies, here is an explanation. Probably not of much use to the OP, but I felt like making it clear why NUMBER & 1 works. Please note like as someone answered above, the way negative numbers are represented can stop this method working. In fact it can even break the modulo operator method too since each language can differ in how it deals with negative operands. However if you know that NUMBER will always be positive, this works well.As Tooony above made the point that only the last digit in binary (and denary) is important.A boolean logic AND gate dictates that both inputs have to be a 1 (or high voltage) for 1 to be returned.1 & 0 = 0.0 & 1 = 0. 0 & 0 = 0.1 & 1 = 1.If you represent any number as binary (I have used an 8 bit representation here), odd numbers have 1 at the end, even numbers have 0.For example:1 = 000000012 = 000000103 = 000000114 = 00000100If you take any number and use bitwise AND (& in java) it by 1 it will either return 00000001, = 1 meaning the number is odd. Or 00000000 = 0, meaning the number is even.E.gIs odd?1 & 1 = 00000001 &00000001 =00000001 <\xe2\x80\x94 Odd2 & 1 =00000010 &00000001 =00000000 <\xe2\x80\x94 Even54 & 1 =00000001 &00110110 =00000000 <\xe2\x80\x94 EvenThis is why this works:Sorry if this is redundant.Number Zero parity | zero http://tinyurl.com/oexhr3kPython code sequence.Output:For the sake of discussion...You only need to look at  the last digit in any given number to see if it is even or odd. \nSigned, unsigned, positive, negative - they are all the same with regards to this.\nSo this should work all round: -The key here is in the third line of code, the division operator performs an integer division, so that result are missing the fraction part of the result. So for example 222 / 10 will give 22 as a result. Then multiply it again with 10 and you have 220. Subtract that from the original 222 and you end up with 2, which by magic is the same number as the last digit in the original number. ;-)\nThe parenthesis are there to remind us of the order the calculation is done in. First do the division and the multiplication, then subtract the result from the original number. We could leave them out, since the priority is higher for division and multiplication than of subtraction, but this gives us "more readable" code.We could make it all completely unreadable if we wanted to. It would make no difference whatsoever for a modern compiler: -But it would make the code way harder to maintain in the future. Just imagine that you would like to change the text for odd numbers to "is not even". Then someone else later on want to find out what changes you made and perform a svn diff or similar...If you are not worried about portability but more about speed, you could have a look at the least significant bit. If that bit is set to 1 it is an odd number, if it is 0 it\'s an even number. \nOn a little endian system, like Intel\'s x86 architecture it would be something like this: -If you want to be efficient, use bitwise operators (x & 1), but if you want to be readable use modulo 2 (x % 2)Checking even or odd is a simple task.We know that any number exactly divisible by 2 is even number else odd.  We just need to check divisibility of any number and for checking divisibility we use % operatorChecking even odd using if else C program to check even or odd using if else Using Conditional/Ternary operatorC program to check even or odd using conditional operator.  Using Bitwise operatorModulus operator \'%\' can be used to check whether a number is odd or even.That is when a number is divided by 2 and if the remainder is 0 then its an even number else its an odd number.But using Bit manipulation is quite faster than the above method,so if you take a number and apply logically AND \'&\' to it ,if the answer is 1 then its even else its odd.That is basically we have to check the last bit of the number n in binary.If the last bit is 0 then n is even else its odd.for example : suppose N = 15 , in binary N = 1111 , now we AND it with 1Since the result is 1 the number N=15 is Odd.\nAgain,suppose N = 8 , in binary N = 1000 , now we AND it with 1Since the result is 0 the number N=8 is Even.