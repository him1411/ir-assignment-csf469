The default shell in Mac OS X is bash, which I\'m generally happy to be using. I just take it for granted. It would be really nice if it auto-completed more stuff, though, and I\'ve heard good things about zsh in this regard. But I don\'t really have the inclination to spend hours fiddling with settings to improve my command line usage by a tiny amount, since my life on the command line isn\'t that bad. (As I understand it, bash can also be configured to auto-complete more cleverly. It\'s the configuring I\'m not all that keen on.)Will switching to zsh, even in a small number cases, make my life easier? Or is it only a better shell if you put in the time to learn why it\'s better? (Examples would be nice, too :) )@Rodney Amato\n&\n@Vulcan Eager\ngive two good reasons to respectively stick to bash and switch to zsh. Looks like I\'ll have to investigate both! Oh well :)Is there anyone with an opinion from both sides of the argument?For casual use you are probably better off sticking with bash and just installing bash completion. Installing it is pretty easy, grab the bash-completion-20060301.tar.gz from http://www.caliban.org/bash/index.shtml#completion and extract it with then copy the bash_completion/bash_completion file to /etc with which will prompt you for your password. You probably will want to make a /etc/bash_completion.d directory for any additional completion scripts (for instance I have the git completion script in there).Once this is done the last step is to make sure the .bash_profile file in your home directory has in it to load the completion file when you login. To test it just open a new terminal, and try completing on cvs and it should show you the cvs options in the list of completions.Personally, I love zsh. Generally, you probably won\'t notice the difference between it and bash, until you want to quickly do things like recursive globbing:Or use suffix aliases to associate specific progs with different suffixes, so that you can "execute" them directly. The below alias lets you "run" a C source file at the prompt by simply typing ./my_program.c \xe2\x80\x93 which will work exactly as if you typed vim ./my_program.c. (Sort of the equivalent to double clicking on the icon of a file.)Or print the names of files modified today:You can probably do all of these things in bash, but my experience with zsh is that if there\'s something I want to do, I can probably find it in zsh-lovers.\nI also find the book \'From Bash to Z-Shell\' really useful.Playing with the mind bogglingly large number of options is good fun too!Switch to zsh. You will have access to:If all you want to use ZSH for is better completion, the configuration is pretty easy. Place this in your ~/.zshrc:However, it\'s worth checking out all the other great features of the ZSH. The above example will give you a pretty plain prompt with good completion. If you don\'t want to fiddle with configurations, but want to see what ZSH can do for you, Google for "zshrc" and you will get some ready to use configurations to get started.zsh has a console gui configuration thing. You can set it up pretty quickly and easily without having to fiddle with configuration files. I don\'t think you will need much time to set it up, probably 10 seconds with just using defaults, so go ahead and try it out.Staale is talking about a wizard like program (CUI) which autoruns the first time you run zsh. Just answer some questions, view/change the defaults and its configured for you.IBM developerWorks has great resources on zsh.I have not used very advanced features and so far I have not come across serious differences which should hamper someone coming from bash.Some examples:!?pattern<Tab> will autocomplete to\nthe last command in history matching\npattern. Very useful.You can configure a prompt on the\nRHS. One use is to keep a fixed\nwidth prompt on the left hand side\nso all commands line up nicely while\ndisplaying the pwd (or anything of\nvariable width) as the right hand\nside prompt.You can redirect input from multiple files (yet to try this): cat < file1 < file2 < file3 