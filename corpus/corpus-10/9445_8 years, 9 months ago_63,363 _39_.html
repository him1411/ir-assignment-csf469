I read about Java\'s type erasure on Sun\'s website.When does type erasure occur? At compile time / runtime? When the class is loaded / runtime? When the class is instantiated?A lot of sites (including the Sun tutorial mentioned above) say type erasure occurs at compile time. If the type information is completely removed at compile time, how does the JDK check type compatibility when a method using generics is invoked with no type information or wrong type information. Consider the following example: Say class A has a method, empty(Box<? extends Number> b). We compile A.java and get the class file A.class.Now we create another class B which invokes the method empty with a non-parameterized argument (raw type)- empty(new Box()). If we compile B.java with A.class in the classpath, javac is smart enough to raise a warning. So A.class has some type information stored in it.My guess would be that type erasure occurs when the class is loaded, but it is just a guess. So when does it happen? Type erasure applies to the use of generics. There\'s definitely metadata in the class file to say whether or not a method/type is generic, and what the constraints are etc. But when generics are used, they\'re converted into compile-time checks and execution-time casts. So this code:is compiled intoAt execution time there\'s no way of finding out that T=String for the list object - that information is gone.... but the List<T> interface itself still advertises itself as being generic.EDIT: Just to clarify, the compiler does retain the information about the variable being a List<String> - but you still can\'t find out that T=String for the list object itself.The compiler is responsible for understanding Generics at compile time. The compiler is also responsible for throwing away this "understanding" of generic classes, in a process we call type erasure. All happens at compile time.Note: Contrary to beliefs of majority of Java developers, it is possible to keep compile-time type information and retrieve this information at runtime, despite in a very restricted way. In other words: Java does provide reified generics in a very restricted way.Notice that, at compile-time, the compiler has full type information available but this information is intentionally dropped in general when the byte code is generated, in a process known as type erasure. This is done this way due to compatibility issues: The intention of language designers was providing full source code compatibility and full byte code compatibility between versions of the platform. If it were implemented differently, you would have to recompile your legacy applications when migrating to newer versions of the platform. The way it was done, all method signatures are preserved (source code compatibility) and you don\'t need to recompile anything (binary compatibility).If you need to keep compile-time type information, you need to employ anonymous classes.\nThe point is: in the very special case of anonymous classes, it is possible to retrieve full compile-time type information at runtime which, in other words means: reified generics. This means that the compiler does not throw away type information when anonymous classes are involved; this information is kept in the generated binary code and the runtime system allows you to retrieve this information.I\'ve written an article about this subject:http://rgomes-info.blogspot.co.uk/2013/12/using-typetokens-to-retrieve-generic.htmlA note about the technique described in the article above is that the technique is obscure for majority of developers. Despite it works and works well, most developers feel confused or uncomfortable with the technique. If you have a shared code base or plan to release your code to the public, I do not recommend the above technique. On the other hand, if you are the sole user of your code, you can take advantage of the power this technique delivers to you.The article above has links to sample code.If you have a field that is a generic type, its type parameters are compiled into the class.If you have a method that takes or returns a generic type, those type parameters are compiled into the class.This information is what the compiler uses to tell you that you can\'t pass a Box<String> to the empty(Box<T extends Number>) method.The API is complicated, but you can inspect this type information through the reflection API with methods like getGenericParameterTypes, getGenericReturnType, and, for fields, getGenericType.If you have code that uses a generic type, the compiler inserts casts as needed (in the caller) to check types. The generic objects themselves are just the raw type; the parameterized type is "erased". So, when you create a new Box<Integer>(), there is no information about the Integer class in the Box object.Angelika Langer\'s FAQ is the best reference I\'ve seen for Java Generics.Generics in Java Language is a really good guide on this topic.Generics are implemented by Java\n  compiler as a front-end conversion\n  called erasure. You can (almost) think\n  of it as a source-to-source\n  translation, whereby the generic\n  version of loophole() is converted to\n  the non-generic version.So, it\'s at compile time. The JVM will never know which ArrayList you used.I\'d also recommend Mr. Skeet\'s answer on What is the concept of erasure in generics in Java?Type erasure occurs at compile time. What type erasure means is that it will forget about the generic type, not about every type. Besides, there will still be metadata about the types being generic. For exampleis converted toat compile time. You may get warnings not because the compiler knows about what type is the generic of, but on the contrary, because it doesn\'t know enough so it cannot guarantee type safety.Additionally, the compiler does retain the type information about the parameters on a method call, which you can retrieve via reflection.This guide is the best I\'ve found on the subject.I\'ve encountered with type erasure in Android. In production we use gradle with minify option. After minification I\'ve got fatal exception. I\'ve made simple function to show inheritance chain of my object:And there is two results of this function:Not minified code:Minified code:So, in minified code actual parametrized classes are replaced with raw classes types without any type information. \nAs a solution for my project i removed all reflection calls and replced them with explicit params types passed in function arguments.