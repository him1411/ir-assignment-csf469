I have a list with 15 numbers in, and I need to write some code that produces all 32,768 combinations of those numbers. I\'ve found some code (by Googling) that apparently does what I\'m looking for, but I found the code fairly opaque and am wary of using it. Plus I have a feeling there must be a more elegant solution.The only thing that occurs to me would be to just loop through the decimal integers 1\xe2\x80\x9332768 and convert those to binary, and use the binary representation as a filter to pick out the appropriate numbers. Does anyone know of a better way? Using map(), maybe?Have a look at itertools.combinations:Return r length subsequences of elements from\n  the input iterable.Combinations are emitted in lexicographic sort order. So, if the\n  input iterable is sorted, the\n  combination tuples will be produced in\n  sorted order.Since 2.6, batteries are included!This answer missed one aspect: the OP asked for ALL combinations... not just combinations of length "r".So you\'d either have to loop through all lengths "L":Or -- if you want to get snazzy (or bend the brain of whoever reads your code after you) -- you can generate the chain of "combinations()" generators, and iterate through that:Here\'s a lazy one-liner, also using itertools:Main idea behind this answer: there are 2^N combinations -- same as the number of binary strings of length N. For each binary string, you pick all elements corresponding to a "1".Things to consider:DemoHere is one using recursion:I agree with Dan H that Ben indeed asked for all combinations. itertools.combinations() does not give all combinations.Another issue is, if the input iterable is big, it is perhaps better to return a generator instead of everything in a list:This one-liner gives you all the combinations (between 0 and n items if the original list/set contains n distinct elements) and uses the native method itertools.combinations:The output will be:Try it online:http://ideone.com/COghfXIn comments under the highly upvoted answer by @Dan H, mention is made of the powerset() recipe in the itertools documentation\xe2\x80\x94including one by Dan himself. However, so far no one has posted it as an answer. Since it\'s probably one of the better if not the best approach to the problem\xe2\x80\x94and given a little encouragement from another commenter, it\'s shown below. The function produces all unique combinations of the list elements of every length possible.Note: If the, subtly different, goal is to obtain only combinations of unique elements, change the line s = list(iterable) to s = list(set(iterable)) to eliminate any duplicate elements. Regardless, the fact that the iterable is ultimately turned into a list means it will work with generators (unlike several of the other answers).Output:You can generating all combinations of a list in python using this simple codeResult would be :Here is yet another solution (one-liner), involving using the itertools.combinations function, but here we use a double list comprehension (as opposed to a for loop or sum):Demo:Below is a "standard recursive answer", similar to the other similar answer https://stackoverflow.com/a/23743696/711085 . (We don\'t realistically have to worry about running out of stack space since there\'s no way we could process all N! permutations.)It visits every element in turn, and either takes it or leaves it (we can directly see the 2^N cardinality from this algorithm).Demo:I thought I would add this function for those seeking an answer without importing itertools or any other extra libraries.Simple Yield Generator Usage:Output from Usage example above:[] ,  [1] , [2] , [1, 2] , [3] , [1, 3] , [2, 3] , [1, 2, 3] , [4] ,\n  [1, 4] ,  [2, 4] , [1, 2, 4] , [3, 4] , [1, 3, 4] , [2, 3, 4] , [1, 2,\n  3, 4] ,Using list comprehension:Output would be:This code employs a simple algorithm with nested lists...This is my implementation