How do I check to see if a column exists in a SqlDataReader object?  In my data access layer, I have create a method that builds the same object for multiple stored procedures calls.  One of the stored procedures has an additional column that is not used by the other stored procedures.  I want to modified the method to accommodate for every scenario.My application is written in C#.In the accepted answer, using Exceptions for control logic is considered bad practice and has performance costs.Looping through the fields can have a small performance hit if you use it a lot and you may want to consider caching the results The more appropriate way to do this is:It\'s much better to use this boolean function:One call - no exceptions. It might throw exceptions internally, but I don\'t think so.NOTE: In the comments below, we figured this out... the correct code is actually this:I think your best bet is to call GetOrdinal("columnName") on your DataReader up front, and catch an IndexOutOfRangeException in case the column isn\'t present.In fact, let\'s make an extension method:EditOk, this post is starting to garner a few down-votes lately, and I can\'t delete it because it\'s the accepted answer, so I\'m going to update it and (I hope) try to justify the use of exception handling as control flow.The other way of achieving this, as posted by Chad Grant, is to loop through each field in the DataReader and do a case-insensitive comparison for the field name you\'re looking for. This will work really well, and truthfully will probably perform better than my method above. Certainly I would never use the method above inside a loop where performace was an issue.I can think of one situation in which the try/GetOrdinal/catch method will work where the loop doesn\'t. It is, however, a completely hypothetical situation right now so it\'s a very flimsy justification. Regardless, bear with me and see what you think.Imagine a database that allowed you to "alias" columns within a table. Imagine that I could define a table with a column called "EmployeeName" but also give it an alias of "EmpName", and doing a select for either name would return the data in that column. With me so far?Now imagine that there\'s an ADO.NET provider for that database, and they\'ve coded up an IDataReader implementation for it which takes column aliases into account.Now, dr.GetName(i) (as used in Chad\'s answer) can only return a single string, so it has to return only one of the "aliases" on a column. However, GetOrdinal("EmpName") could use the internal implementation of this provider\'s fields to check each column\'s alias for the name you\'re looking for.In this hypothetical "aliased columns" situation, the try/GetOrdinal/catch method would be the only way to be sure that you\'re checking for every variation of a column\'s name in the resultset.Flimsy? Sure. But worth a thought. Honestly I\'d much rather an "official" HasColumn method on IDataRecord.Here is a working sample for Jasmin\'s idea:In one line, use this after your DataReader retrieval:Then,this works for me:If you read the question, Michael asked about DataReader, not DataRecord folks. Get your objects right.Using a r.GetSchemaTable().Columns.Contains(field) on a DataRecord does work, but it returns BS columns (see screenshot below.)To see if a data column exists AND contains data in a DataReader, use the following extensions:Usage:Calling r.GetSchemaTable().Columns on a DataReader returns BS columns:The following is simple and worked for me:I wrote for Visual Basic users :I think this is more powerful and the usage is :Here the solution from Jasmine in one line... (one more, tho simple!):Here is a one liner linq version of the accepted answer:This code corrects the issues that Levitikon had with their code:\n(adapted from:   [1]: http://msdn.microsoft.com/en-us/library/system.data.datatablereader.getschematable.aspx)The reason for getting all of those useless column names and not the name of the column from your table...\nIs because your are getting the name of schema column (i.e. the column names for the Schema table)NOTE: this seems to only return the name of the first column...EDIT: corrected code that returns the name of all columns, but you cannot use a SqlDataReader to do itNeither did I get GetSchemaTable to work, until I found this way.Basically I do this:Columns.Contains is case-insensitive btw.To keep your code robust and clean, use a single extension function, like this:You can also call GetSchemaTable() on your DataReader if you want the list of columns and you don\'t want to have to get an exception...These answers are already posted here. Just Linq-ing a bit:The second one is cleaner, and much much faster. Even if you dont run GetSchemaTable every single time in the first approach, the lookup is going to be very slow.In your particular situation (all procedures has the same columns except 1 which has additional 1 column), it will be better and faster to check reader. FieldCount property to distinguish between them.I know it is an old post but I decided to answer to help other in the same situation.\nyou can also (for performance reason) mix this solution with the solution iterating solution.   My data access class needs to be backward compatible, so I might be trying to access a column in a release where it doesn\'t exist in the database yet. We have some rather large data sets being returned so I\'m not a big fan of an extension method that has to iterate the DataReader column collection for each property.I have a utility class that creates a private list of columns and then has a generic method that attempts to resolve a value based on a column name and output parameter type.Then I can just call my code like soHow about It probably would not be as efficient in a loop