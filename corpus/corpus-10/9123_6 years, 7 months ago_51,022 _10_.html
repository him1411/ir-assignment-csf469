Coming from other C-derived languages (like Java or C#) to C++, it is at first very confusing that C++ has three ways to refer to members of a class: a::b, a.b, and a->b. When do I use which one of these operators? \n(Note: This is meant to be an entry to Stack Overflow\'s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)\nThe three distinct operators C++ uses to access the members of a class or class object, namely the double colon ::, the dot ., and the arrow ->, are used for three different scenarios that are always well-defined. Knowing this allows you to immediately know quite a lot about a and b just by looking at a::b, a.b, or a->b, respectively, in any code you look at. a::b is only used if b is a member of the class (or namespace) a. That is, in this case a will always be the name of a class (or namespace). a.b is only used if b is a member of the object (or reference to an object) a. So for a.b, a will always be an actual object (or a reference to an object) of a class. a->b is, originally, a shorthand notation for (*a).b. However, -> is the only of the member access operators that can be overloaded, so if a is an object of a class that overloads operator-> (common such types are smart pointers and iterators), then the meaning is whatever the class designer implemented. To conclude: With a->b, if a is a pointer, b will be a member of the object the pointer a refers to. If, however, a is an object of a class that overloads this operator, then the overloaded operator function operator->() gets invoked. The small print:  Suggesting an alternative for sbi\'s point 3a->b is only used if a is a pointer. It is a shorthand for (*a).b, the b member of the object that a points to. C++ has two kinds of pointers, "regular" and smart pointers. For regular pointers such as A* a, the compiler implements ->. For smart pointers such as std::shared_ptr<A> a, -> is a member function of class shared_ptr.Rationale: the target audience of this FAQ isn\'t writing smart pointers. They don\'t need to know -> is really called operator->(), or that it is the only member access method that can be overloaded.