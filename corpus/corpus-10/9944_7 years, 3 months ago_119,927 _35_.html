I got a lot of errors with the message :after changed from python-psycopg to python-psycopg2 as Django project\'s database engine.The code remains the same, just dont know where those errors are from.This is what postgres does when a query produces an error and you try to run another query without first rolling back the transaction.  To fix it, you\'ll want to figure out where in the code that bad query is being executed.  It might be helpful to use the log_statement and log_min_error_statement options in your postgresql server.To get rid of the error, roll back the last (erroneous) transaction after you\'ve fixed your code:You can use try-except to prevent the error from occurring:Refer : Django documentationSo, I ran into this same issue. The problem I was having here was that my database wasn\'t properly synced. Simple problems always seem to cause the most angst...To sync your django db, from within your app directory, within terminal, type:Edit: Note that if you are using django-south, running the \'$ python manage.py migrate\' command may also resolve this issue.Happy coding!In my experience, these errors happen this way:There nothing wrong with the second query, but since the real error was caught, the second query is the one that raises the (much less informative) error.edit: this only happens if the except clause catches IntegrityError (or any other low level database exception), If you catch something like DoesNotExist this error will not come up, because DoesNotExist does not corrupt the transaction.The lesson here is don\'t do try/except/pass.I think the pattern priestc mentions is more likely to be the usual cause of this issue when using PostgreSQL.However I feel there are valid uses for the pattern and I don\'t think this issue should be a reason to always avoid it. For example:If you do feel OK with this pattern, but want to avoid explicit transaction handling code all over the place then you might want to look into turning on autocommit mode (PostgreSQL 8.2+): https://docs.djangoproject.com/en/dev/ref/databases/#autocommit-modeI am unsure if there are important performance considerations (or of any other type).If you get this while in interactive shell and need a quick fix, do this:originally seen in this answerI\'ve got the silimar problem. The solution was to migrate db (manage.py syncdb or manage.py schemamigration --auto <table name> if you use south).I encountered a similar behavior while running a malfunctioned transaction on the postgres terminal. Nothing went through after this, as the database is in a state of error. However, just as a quick fix, if you can afford to avoid rollback transaction. Following did the trick for me:COMMIT;I just had this error too but it was masking another more relevant error message where the code was trying to store a 125 characters string in a 100 characters column:I had to debug through the code for the above message to show up, otherwise it displaysIn response to @priestc and @Sebastian, what if you do something like this?I just tried this code and it seems to work, failing silently without having to care about any possible errors, and working when the query is good.I believe @AnujGupta\'s answer is correct. However the rollback can itself raise an exception which you should catch and handle:If you find you\'re rewriting this code in various save() locations, you can extract-method:Finally, you can prettify it using a decorator that protects methods which use save():Even if you implement the decorator above, it\'s still convenient to keep try_rolling_back() as an extracted method in case you need to use it manually for cases where specific handling is required, and the generic decorator handling isn\'t enough.This is very strange behavior for me. I\'m surprised that no one thought of savepoints. In my code failing query was expected behavior:I have changed code this way to use savepoints:you could disable transaction via "set_isolation_level(0)"