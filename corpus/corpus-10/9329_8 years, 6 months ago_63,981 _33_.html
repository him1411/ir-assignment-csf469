I\'m returning a reference to a dictionary in my read only property.  How do I prevent consumers from changing my data?  If this were an IList I could simply return it AsReadOnly.  Is there something similar I can do with a dictionary?Here\'s a simple implementation that wraps a dictionary:The .NET Framework 4.5 BCL introduces ReadOnlyDictionary<TKey, TValue> (source).As the .NET Framework 4.5 BCL doesn\'t include an AsReadOnly for dictionaries, you will need to write your own (if you want it). It would be something like the following, the simplicity of which perhaps highlights why it wasn\'t a priority for .NET 4.5.Prior to .NET 4.5, there is no .NET framework class that wraps a Dictionary<TKey, TValue> like the ReadOnlyCollection wraps a List. However, it is not difficult to create one.Here is an example - there are many others if you Google for ReadOnlyDictionary.It was announced in the recent BUILD conference that since .NET 4.5, the interface System.Collections.Generic.IReadOnlyDictionary<TKey,TValue> is included. The proof is here (Mono) and here (Microsoft) ;)Not sure if ReadOnlyDictionary is included too, but at least with the interface it shouldn\'t be difficult to create now an implementation which exposes an official .NET generic interface :)Feel free to use my simple wrapper. It does NOT implement IDictionary, so it doesn\'t have to throw exceptions at runtime for dictionary methods that would change the dictionary. Change methods simply aren\'t there. I made my own interface for it called IReadOnlyDictionary.IsReadOnly on IDictionary<TKey,TValue> is inherited from ICollection<T> (IDictionary<TKey,TValue> extends ICollection<T> as ICollection<KeyValuePair<TKey,TValue>>).  It is not used or implemented in any way ( and is in fact "hidden" through the use of explicitly implementing the associated ICollection<T> members ).There are at least 3 ways I can see to solve the problem:As an aside; when exposing collections, aim to expose the smallest possible interface - in the example case it should be IDictionary as this allows you to vary the underlying implementation without breaking the public contract that the type exposes.A read-only dictionary can to some extent be replaced by Func<TKey, TValue> - I usually use this in an API if I only want people performing lookups; it\'s simple, and in particular, it\'s simple to replace the backend should you ever wish to.  It doesn\'t provide the list of keys, however; whether that matters depends on what you\'re doing.No, but it would be easy to roll your own.  IDictionary does define an IsReadOnly property. Just wrap a Dictionary and throw a NotSupportedException from the appropriate methods.None available in the BCL.  However I published a ReadOnlyDictionary (named ImmutableMap) in my BCL Extras ProjectIn addition to being a fully immutable dictionary, it supports producing a proxy object which implements IDictionary and can be used in any place where IDictionary is taken.  It will throw an exception whenever one of the mutating APIs are calledI don\'t think there\'s an easy way of doing it...if your dictionary is part of a custom class, you could achieve it with an indexer:+1 Great job, Thomas.  I took ReadOnlyDictionary one step further.Much like Dale\'s solution, I wanted to remove Add(), Clear(), Remove(), etc from IntelliSense.  But I wanted my derived objects to implement IDictionary<TKey, TValue>.Furthermore, I would like the following code to break:  (Again, Dale\'s solution does this too)The Add() line results in:The caller can still cast it to IDictionary<TKey, TValue>, but the NotSupportedException will be raised if you try to use the non-read only members (from Thomas\'s solution).Anyway, here\'s my solution for anyone that also wanted this:Now, there are Microsoft Immutable Collections (System.Collections.Immutable). Get them via NuGet.You could create a class that only implements a partial implementation of the dictionary, and hides all the add/remove/set functions. Use a dictionary internally that the external class passes all requests to.However, since your dictionary is likely holding reference types, there is no way you ca stop the user from setting values on the classes held by the dictionary (unless those classes themselves are read only)This is a bad solution, see at bottom.For those still using .NET 4.0 or earlier, I have a class that works just like the one in the accepted answer, but it\'s much shorter. It extends the existing Dictionary object, overriding (actually hiding) certain members to have them throw an exception when called.If the caller tries to call Add, Remove, or some other mutating operation that the built-in Dictionary has, the compiler will throw an error. I use the Obsolete attributes to raise these compiler errors. This way, you can replace a Dictionary with this ReadOnlyDictionary and immediately see where any problems might be without having to run your application and waiting for run-time exceptions.Take a look:This solution has a problem pointed out by @supercat illustrated here:Rather than give a compile-time error like I expected, or a runtime-exception like I hoped, this code runs without error.  It prints four numbers. That makes my ReadOnlyDictionary a ReadWriteDictionary.