I see both in examples when checking what env one is running in.  What\'s preferred?  Are they, for all intents and purposes equal?According to the docs, #Rails.env wraps RAILS_ENV:But, look at specifically how it\'s wrapped, using ActiveSupport::StringInquirer:Wrapping a string in this class gives\n  you a prettier way to test for\n  equality. The value returned by\n  Rails.env  is wrapped in a\n  StringInquirer  object so instead of\n  calling this:you can call this:So they aren\'t exactly equivalent, but they\'re fairly close.  I haven\'t used Rails much yet, but I\'d say #Rails.env is certainly the more visually attractive option due to using StringInquirer.Before Rails 2.x the preferred way to get the current environment was using the RAILS_ENV constant. Likewise, you can use RAILS_DEFAULT_LOGGER to get the current logger or RAILS_ROOT to get the path to the root folder.Starting from Rails 2.x, Rails introduced the Rails module with some special methods:This isn\'t just a cosmetic change. The Rails module offers capabilities not available using the standard constants such as StringInquirer support.\nThere are also some slight differences. Rails.root doesn\'t return a simple String buth a Path instance.Anyway, the preferred way is using the Rails module. Constants are deprecated in Rails 3 and will be removed in a future release, perhaps Rails 3.1.ENV[\'RAILS_ENV\'] is now deprecated. You should use Rails.env which is clearly much nicer.Update: in Rails 3.0.9: \nenv method defined in railties/lib/rails.rbStrange behaviour while debugging my app:\nrequire "active_support/notifications"\n(rdb:1) p ENV[\'RAILS_ENV\']\n"test"\n(rdb:1) p Rails.env\n"development"I would say that you should stick to one or another (and preferably Rails.env)