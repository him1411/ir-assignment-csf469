How can I execute a terminal command (like grep) from my Objective-C Cocoa application?You can use NSTask. Here\'s an example that would run \'/usr/bin/grep foo bar.txt\'.  NSPipe and NSFileHandle are used to redirect the standard output of the task. For more detailed information on interacting with the operating system from within your Objective-C application, you can see this document on Apple\'s Development Center: Interacting with the Operating System. Edit: Included fix for NSLog problemIf you are using NSTask to run a command-line utility via bash, then you need to include this magic line to keep NSLog working:An explanation is here: http://cocoadev.com/HowToPipeCommandsWithNSTask (<--Dead link)in the spirit of sharing... this is a method I use frequently to run shell scripts.\nyou can add a script to your product bundle (in the copy phase of the build) and then\nhave the script be read and run at runtime.  note: this code looks for the script in the privateFrameworks sub-path.\nwarning: this could be a security risk for deployed products, but for our in-house development it is an easy way to customize simple things (like which host to rsync to...) without re-compiling the application, but just editing the shell script in the bundle.Edit: Included fix for NSLog problemIf you are using NSTask to run a command-line utility via bash, then you need to include this magic line to keep NSLog working:In context:An explanation is here: http://www.cocoadev.com/index.pl?NSTaskkent\'s article gave me a new idea. this runCommand method doesn\'t need a script file, just runs a command by a line:You can use this method like this:Changes for Swift 3.0:NSPipe has been renamed PipeNSTask has been renamed ProcessThis is based on inkit\'s Objective-C answer above. He wrote it as a category on NSString \xe2\x80\x94 \nFor Swift, it becomes an extension of String.    or just:Note the Process result as read from the Pipe is an NSString object. It might be an error string and it can also be an empty string, but it should always be an NSString.So, as long as it\'s not nil, the result can cast as a Swift String and returned.If for some reason no NSString at all can be initialized from the file data, the function returns an error message. The function could have been written to return an optional String?, but that would be awkward to use and wouldn\'t serve a useful purpose because it\'s so unlikely for this to occur.fork, exec, and wait should work, if you\'re not really looking for a Objective-C specific way. fork creates a copy of the currently running program, exec replaces the currently running program with a new one, and wait waits for the subprocess to exit. For example (without any error checking):There\'s also system, which runs the command as if you typed it from the shell\'s command line. It\'s simpler, but you have less control over the situation.I\'m assuming you\'re working on a Mac application, so the links are to Apple\'s documentation for these functions, but they\'re all POSIX, so you should be to use them on any POSIX-compliant system.Cleaned up the code in the top answer to make it more readable, less redundant, added the benefits of the one-line method and made into an NSString categoryImplementation:Usage:And if you\'re having problems with output encoding:Hope it\'s as useful to you as it will be to future me. (Hi, you!)Here\'s a Swift example making use of Pipe, Process, and StringUsage:There is also good old POSIX system("echo -en \'\\007\'");I wrote this "C" function, because NSTask is obnoxious..oh, and for the sake of being complete / unambiguous\xe2\x80\xa6Years later, C is still a bewildering mess, to me.. and with little faith in my ability to correct my gross shortcomings above - the only olive branch I offer is a rezhuzhed version of @inket\'s answer that is barest of bones, for my fellow purists / verbosity-haters...Custos Mortem said:I\'m surprised no one really got into blocking/non-blocking call issues For blocking/non-blocking call issues regarding NSTask read below:asynctask.m  --  sample code that shows how to implement asynchronous stdin, stdout & stderr streams for processing data with NSTaskSource code of asynctask.m is available at GitHub.If the Terminal command requires Administrator Privilege (aka sudo), use AuthorizationExecuteWithPrivileges instead.\nThe following will create a file named "com.stackoverflow.test" is the root directory "/System/Library/Caches".Or since Objective C is just C with some OO layer on top you can use the posix conterparts:They are included from unistd.h header file.