I am looking for a .NET implementation of a priority queue or heap data structurePriority queues are data structures that provide more flexibility than simple sorting, because they allow new elements to enter a system at arbitrary intervals. It is much more cost-effective to insert a new job into a priority queue than to re-sort everything on each such arrival.The basic priority queue supports three primary operations:Unless I am looking in the wrong place, there isn\'t one in the framework. Is anyone aware of a good one, or should I roll my own?I like using the OrderedBag and OrderedSet classes in PowerCollections as priority queues.You might like IntervalHeap from the C5 Generic Collection Library. To quote the user guideClass IntervalHeap<T> implements interface IPriorityQueue<T> using an interval heap stored as an array of pairs. The FindMin and\n  FindMax operations, and the indexer\xe2\x80\x99s get-accessor, take time O(1). The DeleteMin,\n  DeleteMax, Add and Update operations, and the indexer\xe2\x80\x99s set-accessor, take time\n  O(log n). In contrast to an ordinary priority queue, an interval heap offers both minimum\n  and maximum operations with the same efficiency.The API is simple enoughInstall from Nuget https://www.nuget.org/packages/C5 or GitHub  https://github.com/sestoft/C5/Here\'s my attempt at a .NET heapSome tests:here\'s one i just wrote, maybe it\'s not as optimized (just uses a sorted dictionary) but simple to understand.\nyou can insert objects of different kinds, so no generic queues.I found one by Julian Bucknall on his blog here - http://www.boyet.com/Articles/PriorityQueueCSharp3.htmlWe modified it slightly so that low-priority items on the queue would eventually \'bubble-up\' to the top over time, so they wouldn\'t suffer starvation.You may find useful this implementation:\nhttp://www.codeproject.com/Articles/126751/Priority-queue-in-Csharp-with-help-of-heap-data-st.aspxit is generic and based on heap data structureeasy.Use a Java to C# translator on the Java implementation (java.util.PriorityQueue) in the Java Collections framework, or more intelligently use the algorithm and core code and plug it into a C# class of your own making that adheres to the C# Collections framework API for Queues, or at least Collections.As mentioned in Microsoft Collections for .NET, Microsoft has written (and shared online) 2 internal PriorityQueue classes within the .NET Framework. Their code is available to try out.EDIT: As @mathusum-mut commented, there is a bug in one of Microsoft\'s internal PriorityQueue classes (the SO community has, of course, provided fixes for it): Bug in Microsoft's internal PriorityQueue<T>? Here is the another implementation from NGenerics team:NGenerics PriorityQueueI had the same issue recently and ended up creating a NuGet package for this.This implements a standard heap-based priority queue. It also has all the usual niceties of the BCL collections: ICollection<T> and IReadOnlyCollection<T> implementation, custom IComparer<T> support, ability to specify an initial capacity, and a DebuggerTypeProxy to make the collection easier to work with in the debugger.There is also an Inline version of the package which just installs a single .cs file into your project (useful if you want to avoid taking externally-visible dependencies).More information is available on the github page.A Simple Max Heap Implementation.https://github.com/bharathkumarms/AlgorithmsMadeEasy/blob/master/AlgorithmsMadeEasy/MaxHeap.csI wrote an open source library called AlgoKit, available via NuGet. It contains:The code has been extensively tested. I definitely recommend you to give it a try.The optimal choice of implementation is strongly input-dependent \xe2\x80\x94 as Larkin, Sen, and Tarjan show in A back-to-basics empirical study of priority queues, arXiv:1403.0252v1 [cs.DS]. They tested implicit d-ary heaps, pairing heaps, Fibonacci heaps, binomial heaps, explicit d-ary heaps, rank-pairing heaps, quake heaps, violation heaps, rank-relaxed weak heaps, and strict Fibonacci heaps.AlgoKit features three types of heaps that appeared to be most efficient among those tested.For a relatively small number of elements, you would likely be interested in using implicit heaps, especially quaternary heaps (implicit 4-ary). In case of operating on larger heap sizes, amortized structures like binomial heaps and pairing heaps should perform better.The following implementation of a PriorityQueue uses SortedSet from the System library. 