We are having a WPF application where parts of it may throw exceptions at runtime. I\'d like to globally catch any unhandled exception and log them, but otherwise continue program execution as if nothing happened (kinda like VB\'s On Error Resume Next).Is this possible in C#? And if so, where exactly would I need to put the exception handling code?Currently I can\'t see any single point where I could wrap a try/catch around and which would catch all exceptions that could occur. And even then I would have left whatever has been executed because of the catch. Or am I thinking in horribly wrong directions here?ETA: Because many people below pointed it out: The application is not for controlling nuclear power plants. If it crashes it\'s not that much a big deal but random exceptions that are mostly UI-related are a nuisance in the context where it would be used. There were (and probably still are) a few of those and since it uses a plugin architecture and may be extended by others (also students in that case; so no experienced developers that are able to write completely error-free code).As for the exceptions that get caught: I do log them to a log file, including the complete stack trace. That was the whole point of that exercise. Just to counter those people  that were taking my analogy to VB\'s OERN too literally.I know that blindly ignoring certain classes of errors is dangerous and might corrupt my application instance. As said before, this program isn\'t mission-critical for anyone. No-one in their right mind would bet the survival of the human civilization on it. It\'s simply a little tool for testing certain design approaches wrt. software engineering.For the immediate use of the application there are not many things that can happen on an exception:As for the experiment data generated by the program: A serious error would at worst just cause no data to be recorded. Subtle changes that change the result of the experiment ever so slightly are pretty unlikely. And even in that case, if the results seem dubious the error was logged; one can still throw away that data point if it\'s a total outlier.To summarize: Yes, I consider myself still at least partially sane and I don\'t consider a global exception handling routine which leaves the program running to be necessarily totally evil. As said twice before, such a decision might be valid, depending on the application. In this case it was judged a valid decision and not total and utter bullshit. For any other application that decision might look different. But please don\'t accuse me or the other people who worked on that project to potentially blow up the world just because we\'re ignoring errors.Side note: There is exactly one user for that application. It\'s not something like Windows or Office that gets used by millions where the cost of having exceptions bubble to the user at all would be very different in the first place already.Use the Application.DispatcherUnhandledException Event. See this question for  a summary (see Drew Noakes\' answer).Be aware that there\'ll be still exceptions which preclude a successful resuming of your application, like after a stack overflow, exhausted memory, or lost network connectivity while you\'re trying to save to the database.AppDomain.UnhandledException EventThis event provides notification of uncaught exceptions. It allows the\n  application to log information about the exception before the system\n  default handler reports the exception to the user and terminates the\n  application.If the UnhandledException event is handled in the default application\n  domain, it is raised there for any unhandled exception in any thread,\n  no matter what application domain the thread started in. If the thread\n  started in an application domain that has an event handler for\n  UnhandledException, the event is raised in that application domain. If\n  that application domain is not the default application domain, and\n  there is also an event handler in the default application domain, the\n  event is raised in both application domains.For example, suppose a thread starts in application domain "AD1",\n  calls a method in application domain "AD2", and from there calls a\n  method in application domain "AD3", where it throws an exception. The\n  first application domain in which the UnhandledException event can be\n  raised is "AD1". If that application domain is not the default\n  application domain, the event can also be raised in the default\n  application domain.In addition what others mentioned here, note that combining the  Application.DispatcherUnhandledException (and its similars) with in the app.config will prevent your secondary threads exception from shutting down the application.Here is complete example using NLogLike "VB\'s On Error Resume Next?" That sounds kind of scary. First recommendation is don\'t do it. Second recommendation is don\'t do it and don\'t think about it. You need to isolate your faults better. As to how to approach this problem, it depends on how you\'re code is structured. If you are using a pattern like MVC or the like then this shouldn\'t be too difficult and would definitely not require a global exception swallower. Secondly, look for a good logging library like log4net or use tracing. We\'d need to know more details like what kinds of exceptions you\'re talking about and what parts of your application may result in exceptions being thrown. 