Can I define custom types for user-defined exceptions in JavaScript?  If I can, how would I do it?From: http://www.webreference.com/programming/javascript/rg32/2.htmlYou could implement your own exceptions and their handling for example like here:There is another syntax for catching a typed exception, although this won\'t work in every browser (for example not in IE):You should create a custom exception that prototypically inherits from Error.  For example:This is basically a simplified version of what disfated posted above with the enhancement that stack traces work on Firefox and other browsers.  It satisfies the same tests that he posted:Usage:And it will behave is expected:Yes. You can throw anything you want: integers, strings, objects, whatever. If you want to throw an object, then simply create a new object, just as you would create one under other circumstances, and then throw it. Mozilla\'s Javascript reference has several examples.This allows for usage like..I often use an approach with prototypal inheritance. Overriding toString() gives you the advantage that tools like Firebug will log the actual information instead of [object Object] to the console for uncaught exceptions.Use instanceof to determine the type of exception.Here is how you can create custom errors with completely identical to native Error\'s behaviour. This technique works only in Chrome and node.js for now. I also wouldn\'t recommend to use it if you don\'t understand what it does.As a reasult we getThen you can use it like this:And use NotImplementedError as you would Error:And it will behave is expected:Note, that error.stack works absolutle correct and won\'t include NotImplementedError constructor call (thanks to v8\'s Error.captureStackTrace()).Note. There is ugly eval(). The only reason it is used is to get correct err.constructor.name. If you don\'t need it, you can a bit simplify everything.Use the throw statement.JavaScript doesn\'t care what the exception type is (as Java does).\nJavaScript just notices, there\'s an exception and when you catch it, you can "look" what the exception "says".If you have different exception types you have to throw, I\'d suggest to use variables which contain the string/object of the exception i.e. message. Where you need it use "throw myException" and in the catch, compare the caught exception to myException.In short:If you are using ES6 without transpilers:See Extending Error in Javascript with ES6 syntax for what\'s the current best practiceIf you are using Babel transpiler:Option 1: use babel-plugin-transform-builtin-extendOption 2: do it yourself (inspired from that same library)If you are using pure ES5:Alternative: use Classtrophobic frameworkExplanation:Why extending the Error class using ES6 and Babel is a problem?Because an instance of CustomError is not anymore recognized as such.In fact, from the official documentation of Babel, you cannot extend any built-in JavaScript classes such as Date, Array, DOM or Error.The issue is described here:What about the other SO answers?All the given answers fix the instanceof issue but you lose the regular error console.log:Whereas using the method mentioned above, not only you fix the instanceof issue but you also keep the regular error console.log:See this example in the MDN.If you need to define multiple Errors (test the code here!):Code is mostly copied from: What's a good way to extend Error in JavaScript?An alternative to the answer of asselin for use with ES2015 classesNow we set add the reason or whatever properties we want to the error object and retrieve it. By making the error more reasonable.