I\'m reading "Introduction to Algorithm" CLRS. and the authors are talking about loop invariants, in chapter 2 (Insertion Sort). I don\'t have any idea of what it means.In simple words, a loop invariant is some predicate (condition) that holds for every iteration of the loop. For example, let\'s look at a simple for loop that looks like this:In this example it is true (for every iteration) that i + j == 9. A weaker invariant that is also true is that \ni >= 0 && i < 10 (because this is the continuation condition!) or that j <= 9 && j >= 0.I like this very simple definition:A loop invariant is a condition [among program variables] that is necessarily true immediately before and immediately after each iteration of a loop. (Note that this says nothing about its truth or falsity part way through an iteration.)Source: http://www.cs.uofs.edu/~mccloske/courses/cmps144/invariants_lec.htmlBy itself, a loop invariant doesn\'t do much. However, given an appropriate invariant, it can be used to help prove the correctness of an algorithm. The simple example in CLRS probably has to do with sorting. For example, let your loop invariant be something like, at the start of the loop, the first i entries of this array are sorted. If you can prove that this is indeed a loop invariant (i.e. that it holds before and after every loop iteration), you can use this to prove the correctness of a sorting algorithm: at the termination of the loop, the loop invariant is still satisfied, and the counter i is the length of the array. Therefore, the first i entries are sorted means the entire array is sorted.An even simpler example is shown at http://academic.evergreen.edu/curricular/dsa01/loops.html.The way I understand a loop invariant is as a systematic, formal tool to reason about programs. We make a single statement that we focus on proving true, and we call it the loop invariant. This organizes our logic. While we can just as well argue informally about the correctness of some algorithm, using a loop invariant forces us to think very carefully and ensures our reasoning is airtight.There is one thing that many people don\'t realize right away when dealing with loops and invariants.  They get confused between the loop invariant, and the loop conditional ( the condition which controls termination of the loop ).  As people point out, the loop invariant must be true ( although it can temporarily be false during the body of the loop ).  On the other hand the loop conditional must be false after the loop terminates, otherwise the loop would never terminate.  Thus the loop invariant and the loop conditional must be different conditions.A good example of a complex loop invariant is for binary search.So the loop conditional seems pretty straight forward - when start > end the loop terminates.  But why is the loop correct?  What is the loop invariant which proves it\'s correctness?The invariant is the logical statement:This statement is a logical tautology - it is always true in the context of the specific loop / algorithm we are trying to prove.  And it provides useful information about the correctness of the loop after it terminates.If we return because we found the element in the array then the statement is clearly true, since if A[mid] == a then a is in the array and mid must be between start and end.  And if the loop terminates because start > end then there can be no number such that start <= mid and mid <= end and therefore we know that the statement A[mid] == a must be false.  However, as a result the overall logical statement is still true in the null sense.  ( In logic the statement if ( false ) then ( something ) is always true. )Now what about what I said about the loop conditional necessarily being false when the loop terminates?  It looks like when the element is found in the array then the loop conditional is true when the loop terminates!?  It\'s actually not, because the implied loop conditional is really while ( A[mid] != a && start <= end ) but we shorten the actual test since the first part is implied.  This conditional is clearly false after the loop regardless of how the loop terminates.Previous answers have defined a Loop Invariant in a very good way.Now let me try to explain how authors of CLRS used Loop Invariants to prove correctness of Insertion Sort.Insertion Sort algorithm(as given in Book):Loop Invariant in this case (Source: CLRS book):\nSubarray[1 to j-1] is always sorted.Now let us check this and prove that algorithm is correct.Initialization: Before the first iteration j=2. So Subarray [1:1] is the array to be tested.As it has only one element so it is sorted.Thus Invariant is satisfied.Maintanence: This can be easily verified by checking the invariant after each iteration.In this case it is satisfied.Termination: This is the step where we will prove the correctness of algorithm.When the loop terminates then value of j=n+1. Again Loop invariant is satisfied.This means that Subarray[1 to n] should be sorted.This is what we want to do with our Algorithm.Thus our Algorithm is correct.Beside all of the good answers, I guess a great example from  How to Think About Algorithms, by Jeff Edmonds can illustrate the concept very well:EXAMPLE 1.2.1 "The Find-Max Two-Finger Algorithm"1) Specifications: An input instance consists of a list L(1..n) of\n  elements. The output consists of an index i such that L(i) has maximum\n  value. If there are multiple entries with this same value, then any\n  one of them is returned.2) Basic Steps: You decide on the two-finger method. Your right finger\n  runs down the list.3) Measure of Progress: The measure of progress is how far along the\n  list your right finger is.4) The Loop Invariant: The loop invariant states that your left finger points to one of the largest entries encountered so far by your\n  right finger.5) Main Steps: Each iteration, you move your right finger down one\n  entry in the list. If your right finger is now pointing at an entry\n  that is larger then the left finger\xe2\x80\x99s entry, then move your left\n  finger to be with your right finger.6) Make Progress: You make progress because your right finger moves\n  one entry.7) Maintain Loop Invariant: You know that the loop invariant has been maintained as follows. For each step, the new left finger element\n  is Max(old left finger element, new element). By the loop invariant,\n  this is Max(Max(shorter list), new element). Mathe- matically, this is\n  Max(longer list).8) Establishing the Loop Invariant: You initially establish the loop invariant by point- ing both fingers to the first element.9) Exit Condition: You are done when your right finger has finished\n  traversing the list.10) Ending: In the end, we know the problem is solved as follows. By\n  the exit condi- tion, your right finger has encountered all of the\n  entries. By the loop invariant, your left finger points at the maximum\n  of these. Return this entry.11) Termination and Running Time: The time required is some constant\n  times the length of the list.12) Special Cases: Check what happens when there are multiple entries\n  with the same value or when n = 0 or n = 1.13) Coding and Implementation Details: ...14) Formal Proof: The correctness of the algorithm follows from the\n  above steps.Invariant in this case means a condition that must be true at a certain point in every loop iteration.In contract programming, an invariant is a condition that must be true (by contract) before and after any public method is called.It should be noted that a Loop Invariant can help in the design of iterative algorithms when considered an assertion that expresses important relationships among the variables that must be true at the start of every iteration and when the loop terminates. If this holds, the computation is on the road to effectiveness. If false, then the algorithm has failed.The meaning of invariant is never changeHere the loop invariant means "The change which happen to variable in the loop(increment or decrement) is not changing the loop condition i.e the condition is satisfying " so that the loop invariant concept has came It is hard to keep track of what is happening with loops. Loops which don\'t terminate or terminate without achieving their goal behavior is a common problem in computer programming. Loop invariants help. A loop invariant is a formal statement about the relationship between variables in your program which holds true just before the loop is ever run (establishing the invariant) and is true again at the bottom of the loop, each time through the loop (maintaining the invariant).\nHere is the general pattern of the use of Loop Invariants in your code:...\n   // the Loop Invariant must be true here\n        while ( TEST CONDITION ) {\n      // top of the loop\n      ...\n      // bottom of the loop\n      // the Loop Invariant must be true here\n   }\n   // Termination + Loop Invariant = Goal\n   ...\nBetween the top and bottom of the loop, headway is presumably being made towards reaching the loop\'s goal. This might disturb (make false) the invariant. The point of Loop Invariants is the promise that the invariant will be restored before repeating the loop body each time.\nThere are two advantages to this:Work is not carried forward to the next pass in complicated, data dependent ways. Each pass through the loop in independent of all others, with the invariant serving to bind the passes together into a working whole.\nReasoning that your loop works is reduced to reasoning that the loop invariant is restored with each pass through the loop. This breaks the complicated overall behavior of the loop into small simple steps, each which can be considered separately.\nThe test condition of the loop is not part of the invariant. It is what makes the loop terminate. You consider separately two things: why the loop should ever terminate, and why the loop achieves its goal when it terminates. The loop will terminate if each time through the loop you move closer to satisfying the termination condition. It is often easy to assure this: e.g. stepping a counter variable by one until it reaches a fixed upper limit. Sometimes the reasoning behind termination is more difficult.The loop invariant should be created so that when the condition of termination is attained, and the invariant is true, then the goal is reached:invariant + termination => goal\nIt takes practice to create invariants which are simple and relate which capture all of goal attainment except for termination. It is best to use mathematical symbols to express loop invariants, but when this leads to over-complicated situations, we rely on clear prose and common-sense.Sorry I don\'t have comment permission.@Tomas Petricek as you mentionedA weaker invariant that is also true is that  i >= 0 && i < 10 (because this is the continuation condition!)" How it\'s a loop invariant?I hope I am not wrong, as far as I understand[1], Loop invariant will be true at the beginning of the loop (Initialization), it will be true before and after each iteration (Maintenance) and it will also be true after the termination of the loop (Termination). But after the last iteration i becomes 10. So, the condition i >= 0 && i < 10 becomes false and terminates the loop. It violates the third property (Termination) of loop invariant.[1] http://www.win.tue.nl/~kbuchin/teaching/JBP030/notebooks/loop-invariants.htmlThe Loop Invariant Property is a condition that holds for every step of a loops execution (ie. for loops, while loops, etc.)This is essential to a Loop Invariant Proof, where one is able to show that an algorithm executes correctly if at every step of its execution this loop invariant property holds.For an algorithm to be correct, the Loop Invariant must hold at:Initialization (the beginning)Maintenance (each step after)Termination (when it\'s finished)This is used to evaluate a bunch of things, but the best example is greedy algorithms for weighted graph traversal. For a greedy algorithm to yield an optimal solution (a path across the graph), it must reach connect all nodes in the lowest weight path possible.Thus, the loop invariant property is that the path taken has the least weight. At the beginning we haven\'t added any edges, so this property is true (it isn\'t false, in this case). At each step, we follow the lowest weight edge (the greedy step), so again we\'re taking the lowest weight path. At the end, we have found the lowest weighted path, so our property is also true.If an algorithm doesn\'t do this, we can prove that it isn\'t optimal.Loop invariant is a mathematical formula such as (x=y+1). In that example, x and y represent two variables in a loop. Considering the changing behavior of those variables throughout the execution of the code, it is almost impossible to test all possible to x and y values and see if they produce any bug. Lets say x is an integer. Integer can hold 32 bit space in the memory. If that number exceeds, buffer overflow occurs. So we need to be sure that throughout the execution of the code, it never exceeds that space. for that, we need to understand a general formula that shows the relationship between variables. \nAfter all, we just try to understand the behavior of the program.In Linear Search (as per exercise given in book), we need to find value V in given array.Its simple as scanning the array from 0 <= k < length and comparing each element. If V found, or if scanning reaches length of array, just terminate the loop.As per my understanding in above problem-Loop Invariants(Initialization):\nV is not found in k - 1 iteration. Very first iteration, this would be -1 hence we can say V not found at position -1Maintainance:\nIn next iteration,V not found in k-1 holds trueTerminatation:\nIf V found in k position or k reaches the length of the array, terminate the loop.