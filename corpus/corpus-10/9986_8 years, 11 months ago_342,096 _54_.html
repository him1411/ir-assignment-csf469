For example, this regexwill match:But how do I get it to match across multiple lines?It depends on the language, but there should be a modifier that you can add to the regex pattern. In PHP it is:The s at the end causes the dot to match all characters including newlines.Try this:  It basically says "any character or a newline" repeated zero or more times.If you\'re using Eclipse search, you can enable the "DOTALL" option to make \'.\' match any character including line delimiters: just add "(?s)" at the beginning of your search string. Example: In JavaScript, use /[\\S\\s]*<Foobar>/. Source([\\s\\S]*)<FooBar>The dot matches all except newlines (\\r\\n). So use \\s\\S, which will match ALL characters. In Ruby ruby you can use the \'m\' option (multiline):See the Regexp documentation on ruby-doc.org for more information. "." normally doesn\'t match line-breaks. Most regex engines allows you to add the S-flag (also called DOTALL and SINGLELINE) to make "." also match newlines.\nIf that fails, you could do something like [\\S\\s].For Eclipse worked following expression:Foojadajada Bar"Regular-Expression: the s causes Dot (.) to match carriage returnsNote that (.|\\n)* can be less efficient than (for example) [\\s\\S]* (if your language\'s regexes support such escapes) and than finding how to specify the modifier that makes . also match newlines.  Or you can go with POSIXy alternatives like [[:space:][:^space:]]*.Use RegexOptions.Singleline, it changes the meaning of . to include newlinesRegex.Replace(content, searchText, replaceText, RegexOptions.Singleline);Use pattern modifier sU will get the desired matching in PHP.http://dreamluverz.com/developers-tools/regex-match-all-including-new-line\nhttp://php.net/manual/en/reference.pcre.pattern.modifiers.phpIn java based regular expression you can use [/s/S]In the context of use within languages, regular expressions act on strings, not lines. So you should be able to use the regex normally, assuming that the input string has multiple lines.In this case, the given regex will match the entire string, since "<FooBar>" is present. Depending on the specifics of the regex implementation, the $1 value (obtained from the "(.*)") will either be "fghij" or "abcde\\nfghij". As others have said, some implementations allow you to control whether the "." will match the newline, giving you the choice.Line-based regular expression use is usually for command line things like egrep.I had the same problem and solved it in probably not the best way but it works.  I replaced all line breaks before I did my real match:I am manipulating HTML so line breaks don\'t really matter to me in this case. I tried all of the suggestions above with no luck, I am using .Net 3.5 FYII wanted to match a particular if block in javaIf I use the regExp it included the closing brace for the method block so I usedto exclude the closing brace from the wildcard match.Often we have to modify a substring with a few  keywords spread across lines preceding the substring. Consider an xml element:Suppose we want to modify the 81, to some other value, say 40.  First identify .UID.21..UID., then skip all characters including \\n till .PercentCompleted.. The regular expression pattern and the replace specification are:The subgroup (.|\\n) is probably the missing group $3. If we make it non-capturing by (?:.|\\n) then the $3 is  (<PercentComplete>). So the pattern and replaceSpec can also  be:and the replacement works correctly as before.The question is, can . pattern match any character? The answer varies from engine to engine. The main difference is whether the pattern is used by a POSIX or non-POSIX regex library.Special note about lua-patterns: they are not considered regular expressions, but . matches any char there, same as POSIX based engines.Another note on matlab and octave: the . matches any char by default (demo): str = "abcde\\n     fghij<Foobar>"; expression = \'(.*)<Foobar>*\'; [tokens,matches] = regexp(str,expression,\'tokens\',\'match\'); (tokens contain a abcde\\n     fghij item).Also, in all of boost\'s regex grammars the dot matches line breaks by default. Boost\'s ECMAScript grammar allows you to turn this off with regex_constants::no_mod_m (source).As for oracle (it is POSIX based), use n option (demo): select regexp_substr(\'abcde\' || chr(10) ||\'     fghij<Foobar>\', \'(.*)<Foobar>\', 1, 1, \'n\', 1) as results from dualPOSIX-based engines:tcl (demo), postgresql (demo), r (TRE, base R default engine with no perl=TRUE, for base R with perl=TRUE or for stringr/stringi patterns, see php below) (demo). A mere . already matches line breaks, no need to use any modifiers.Non-POSIX-based engines:NOTES ON (?s):In most non-POSIX engines, (?s) inline modifier (or embedded flag option) can be used to enforce . to match line breaks.If placed at the start of the pattern, (?s) changes the bahavior of all . in  the pattern. If the (?s) is placed somewhere after the beginning, only those . will be affected that are located to the right of it unless this is a pattern passed to Python re. In Python re, regardless of the (?s) location, the whole pattern . are affected. The (?s) effect is stopped using (?-s). A modified group can be used to only affect a specified range of a regex pattern (e.g. Delim1(?s:.*?)\\nDelim2.* will make the first .*? match across newlines and the second .* will only match the rest of the line).POSIX note:In non-regex engines, to match any char, [\\s\\S] / [\\d\\D] / [\\w\\W] constructs can be used.In POSIX, [\\s\\S] is not matching any char (as in JavaScript or any non-POSIX engine) because regex escape sequences are not supported inside bracket expressions. [\\s\\S] is parsed as bracket expressions that match a single char, \\ or s or S.generally . doesn\'t match newlines, so try ((.|\\n)*)<foobar>