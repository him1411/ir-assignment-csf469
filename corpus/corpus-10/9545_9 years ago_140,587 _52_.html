In Cocoa, if I want to loop through an NSMutableArray and remove multiple objects that fit a certain criteria, what\'s the best way to do this without restarting the loop each time I remove an object?Thanks,Edit: Just to clarify - I was looking for the best way, e.g. something more elegant than manually updating the index I\'m at. For example in C++ I can do;For clarity I like to make an initial loop where I collect the items to delete.  Then I delete them.  Here\'s a sample using Objective-C 2.0 syntax:Then there is no question about whether indices are being updated correctly, or other little bookkeeping details.Edited to add:It\'s been noted in other answers that the inverse formulation should be faster.  i.e. If you iterate through the array and compose a new array of objects to keep, instead of objects to discard.  That may be true (although what about the memory and processing cost of allocating a new array, and discarding the old one?) but even if it\'s faster it may not be as big a deal as it would be for a naive implementation, because NSArrays do not behave like "normal" arrays.  They talk the talk but they walk a different walk.  See a good analysis here:http://ridiculousfish.com/blog/archives/2005/12/23/array/The inverse formulation may be faster, but I\'ve never needed to care whether it is, because the above formulation has always been fast enough for my needs.For me the take-home message is to use whatever formulation is clearest to you.  Optimize only if necessary.  I personally find the above formulation clearest, which is why I use it.  But if the inverse formulation is clearer to you, go for it.One more variation. So you get readability and good performace:Some of the other answers would have poor performance on very large arrays, because methods like removeObject: and removeObjectsInArray: involve doing a linear search of the receiver, which is a waste because you already know where the object is.  Also, any call to removeObjectAtIndex: will have to copy values from the index to the end of the array up by one slot at a time.More efficient would be the following:Because we set the capacity of itemsToKeep, we don\'t waste any time copying values during a resize.  We don\'t modify the array in place, so we are free to use Fast Enumeration.  Using setArray: to replace the contents of array with itemsToKeep will be efficient.  Depending on your code, you could even replace the last line with:So there isn\'t even a need to copy values, only swap a pointer.For cryin\' out loud!!  This is a very simple problem.  You just iterate backwards:This is a very common pattern, but only Jens appears to have gotten it.You can use NSpredicate to remove items from your mutable array. This requires no for loops.For example if you have an NSMutableArray of names, you can create a predicate like this one:The following line will leave you with an array that contains only names starting with b.If you have trouble creating the predicates you need, use this apple developer link.Either use loop counting down over indices \xe2\x80\x93 for (NSInteger i = array.count - 1; i >= 0; --i) \xe2\x80\x93 or make a copy with the objects you want to keep. In particular, do not use a for(id object in array) loop or NSEnumerator.I did a performance test using 4 different methods. Each test iterated through all elements in a 100,000 element array, and removed every 5th item. The results did not vary much with/ without optimization. These were done on an iPad 4:(1) removeObjectAtIndex: -- 271 ms(2) removeObjectsAtIndexes: -- 1010 ms (because building the index set takes ~700 ms; otherwise this is basically the same as calling removeObjectAtIndex: for each item)(3) removeObjects: -- 326 ms(4) make a new array with objects passing the test -- 17 msSo, creating a new array is by far the fastest. The other methods are all comparable, except that using removeObjectsAtIndexes: will be worse with more items to remove, because of the time needed to build the index set.For iOS 4+ or OS X 10.6+, Apple added passingTest series of APIs in NSMutableArray, like \xe2\x80\x93 indexesOfObjectsPassingTest:. A solution with such API would be:Nowadays you can use reversed block-based enumeration. A simple example code:Result:another option with just one line of code:In a more declarative way, depending on the criteria matching the items to remove you could use:@Nathan should be very efficientHere\'s the easy and clean way. I like to duplicate my array right in the fast enumeration call:This way you enumerate through a copy of the array being deleted from, both holding the same objects. An NSArray holds object pointers only so this is totally fine memory/performance wise.Add the objects you want to remove to a second array and, after the loop, use -removeObjectsInArray:.this should do it:hope this helps...Why don\'t you add the objects to be removed to another NSMutableArray. When you are finished iterating, you can remove the objects that you have collected.If all objects in your array are unique or you want to remove all occurrences of an object when found, you could fast enumerate on an array copy and use [NSMutableArray removeObject:] to remove the object from the original.benzado\'s anwser above is what you should do for preformace.  In one of my applications removeObjectsInArray took a running time of 1 minute, just adding to a new array took .023 seconds.  I define a category that lets me filter using a block, like this:which can then be used like this:A nicer implementation could be to use the category method below on NSMutableArray.The predicate block can be implemented to do processing on each object in the array. If the predicate returns true the object is removed.An example for a date array to remove all dates that lie in the past:How about swapping the elements you want to delete with the \'n\'th element, \'n-1\'th element and so on?When you\'re done you resize the array to \'previous size - number of swaps\'Iterating backwards-ly was my favourite for years , but for a long time I never encountered the case where the \'deepest\' ( highest count) object was removed first. Momentarily before the pointer moves on to the next index there ain\'t anything and it crashes.  Benzado\'s way is the closest to what i do now but I never realised there would be the stack reshuffle after every remove.under Xcode 6 this works