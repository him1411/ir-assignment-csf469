I\'m using React-router and it works fine while I\'m clicking into link buttons, but when I refresh my webpage it does not load what I want.For instance, I am into localhost/joblist and everything is fine because I arrived here pressing a link. But If I refresh the webpage I get: Cannot GET /joblistBy default It didn\'t work like this. Initially I had my URL: localhost/#/ and localhost/#/joblist and they worked perfectly fine. But I don\'t like this kind of url, so trying to erase that \'#\' I wrote:This problem does not happen with localhost/, this one always returns what I want.EDIT: This app is single-page, so /joblist don\'t need to ask anything to any server.EDIT2: My entire router.Looking at the comments on the accepted answer and the generic nature of this question (\'don\'t work\'), I thought this might be a good place for some general explanations about the issues involved here. So this answer is intended as background info / elaboration on the specific use case of the OP. Please bear with me.The first big thing to understand about this is that there are now 2 places where the URL is interpreted, whereas there used to be only 1 in \'the old days\'. In the past, when life was simple, some user sent a request for http://example.com/about to the server, which inspected the path part of the URL, determined the user was requesting the about page and then sent back that page.With client-side routing, which is what React-Router provides, things are less simple. At first, the client does not have any JS code loaded yet. So the very first request will always be to the server. That will then return a page that contains the needed script tags to load React and React Router etc. Only when those scripts have loaded does phase 2 start. In phase 2, when the user clicks on the \'About us\' navigation link for example, the URL is changed locally only to http://example.com/about (made possible by the History API), but no request to the server is made.  Instead, React Router does it\'s thing on the client side, determines which React view to render and renders it. Assuming your about page does not need to make any REST calls, it\'s done already. You have transitioned from Home to About Us without any server request having fired.So basically when you click a link, some Javascript runs that manipulates the URL in the address bar, without causing a page refresh, which in turn causes React Router to perform a page transition on the client side.But now consider what happens if you copy-paste the URL in the address bar and e-mail it to a friend. Your friend has not loaded your website yet. In other words, she is still in phase 1. No React Router is running on her machine yet. So her browser will make a server request to http://example.com/about. And this is where your trouble starts. Until now, you could get away with just placing a static HTML at the webroot of your server. But that would give 404 errors for all other URLs when requested from the server. Those same URLs work fine on the client side, because there React Router is doing the routing for you, but they fail on the server side unless you make your server understand them.If you want the http://example.com/about URL to work on both the server- and the client-side, you need to set up routes for it on both the server- and the client side. Makes sense right?And this is where your choices begin. Solutions range from bypassing the problem altogether, via a catch-all route that returns the bootstrap HTML, to the full-on isomorphic approach where both the server and the client run the same JS code..With Hash History i.s.o Browser History, your URL for the about page would look something like this:\nhttp://example.com/#/about\nThe part after the hash (#) symbol is not sent to the server. So the server only sees http://example.com/ and sends the index page as expected. React-Router will pick up the #/about part and show the correct page.Downsides: .With this approach you do use Browser History, but just set up a catch-all on the server that sends /* to index.html, effectively giving you much the same situation as with Hash History. You do have clean URLs however and you could improve upon this scheme later without having to invalidate all your user\'s favorites.Downsides: .In the hybrid approach you expand upon the catch-all scenario by adding specific scripts for specific routes. You could make some simple PHP scripts to return the most important pages of your site with content included, so Googlebot can at least see what\'s on your page.Downsides:.What if we use Node JS as our server so we can run the same JS code on both ends? Now, we have all our routes defined in a single react-router config and we don\'t need to duplicate our rendering code. This is \'the holy grail\' so to speak. The server sends the exact same markup as we would end up with if the page transition had happened on the client. This solution is optimal in terms of SEO.Downsides:.Choose the one that you can get away with. Personally I think the catch-all is simple enough to set up that that would be my minimum. This setup allows you to improve on things over time. If you are already using Node JS as your server platform, I\'d definitely investigate doing an isomorphic app. Yes it\'s tough at first but once you get the hang of it it\'s actually a very elegant solution to the problem. So basically, for me, that would be the deciding factor. If my server runs on Node JS, I\'d go isomorphic, otherwise I would go for the Catch-all solution and just expand on it (Hybrid solution) as time progresses and SEO requirements demand it.If you\'d like to learn more on isomorphic (also called \'universal\') rendering with React, there are some good tutorials on the subject:Also, to get you started, I recommend looking at some starter kits. Pick one that matches your choices for the technology stack (remember, React is just the V in MVC, you need more stuff to build a full app). Start with looking at the one published by Facebook itself:Or pick one of the many by the community. There is a nice site now that tries to index all of them:I started with these:Currently I am using a home-brew version of universal rendering that was inspired by the two starter kits above, but they are out of date now. Good luck with your quest!The answers here are all extremely helpful, what worked for me was configuring my Webpack server to expect the routes.The historyApiFallback is what fixed this issue for me. Now routing works correctly and I can refresh the page or type in the URL directly. No need to worry about work arounds on your node server. This answer obviously only works if you\'re using webpack.EDIT: see my answer here for a more detailed reason why this is necessary:\nhttps://stackoverflow.com/a/37622953/5217568The router can be called in two different ways, depending on whether the navigation occurs on the client or on the server. You have it configured for client-side operation. The key parameter is the second one to the run method, the location.When you use the React Router Link component, it blocks browser navigation and calls transitionTo to do a client-side navigation. You are using HistoryLocation, so it uses the HTML5 history API to complete the illusion of navigation by simulating the new URL in the address bar. If you\'re using older browsers, this won\'t work. You would need to use the HashLocation component.When you hit refresh, you bypass all of the React and React Router code. The server gets the request for /joblist and it must return something. On the server you need to pass the path that was requested to the run method in order for it to render the correct view. You can use the same route map, but you\'ll probably need a different call to Router.run.  As Charles points out, you can use URL rewriting to handle this. Another option is to use a node.js server to handle all requests and pass the path value as the location argument. In express, for example, it might look like this:Note that the request path is being passed to run. To do this, you\'ll need to have a server-side view engine that you can pass the rendered HTML to. There are a number of other considerations using renderToString and in running React on the server. Once the page is rendered on the server, when your app loads in the client, it will render again, updating the server-side rendered HTML as needed.You can change your htaccess and insert this:The Webpack Dev Server has an option to enable this. Open up package.json and add --history-api-fallback.\nThis solutions worked for me.https://github.com/reactjs/react-router-tutorial/tree/master/lessons/10-clean-urls#configuring-your-serverFor React Router V4 Users:If you try to solve this problem by Hash History technique mentioned in other answers, note that <Router history={hashHistory} >does not work in V4, please use HashRouter instead:Reference:\nhttps://reacttraining.com/react-router/web/api/HashRouterThis can solve your problem I also faced the same problem in ReactJS application in Production mode.\nHere is the 2 solution to the problem.1.Change the routing history to "hashHistory" instead of browserHistory in the place of Now build the app using the command Then place the build folder in your var/www/ folder, Now the application is working fine with addition of # tag in each and every url. like localhost/#/home\n   localhost/#/aboutusSolution 2 : Without # tag using browserHistory,Set your history = {browserHistory} in your Router,Now build it using sudo npm run build.You need to create the "conf" file to solve the 404 not found page,\nthe conf file should be like this.open your terminal type the below commands cd /etc/apache2/sites-available\nls\nnano sample.conf\nAdd the below content in it.Now you need to enable the sample.conf file by using the following commandthen it will ask you to reload the apache server,using\n     sudo service apache2 reload or restartthen open your localhost/build folder and add the .htaccess file with content of below.Now the app is working normally.Note: change 0.0.0.0 ip to your local ip address.If any doubts regarding this feel free to raise a comment.I hope it is helpful to others.If you do have a fallback to your index.html, make sure that in your index.html file you have this:This may differ from project to project.I\'m not using server side rendering yet but I hit the same problem as the OP where Link seemed to work fine most of the time but failed when I had a parameter. I\'ll document my solution here to see if it helps anyone.My main jsx contains this:This works fine for the first matching link but when the :id changes in <Link> expressions nested on that model\'s detail page, the url changes in the browser bar but the content of the page did not initially change to reflect the linked model.The trouble was that I had used the props.params.id to set the model in componentDidMount. The component is just mounted once so this means that the first model is the one that sticks on the page and the subsequent Links change the props but leave the page looking unchanged.Setting the model in the component state in both componentDidMount and in componentWillReceiveProps (where it is based on the next props) solves the problem and the page content changes to reflect the desired model.This topic is a little bit old and solved but I would like to suggest you a simply, clear and better solution. It works if you use web server.Each web server has an ability to redirect the user to an error page in case of http 404. To solve this issue you need to redirect user to the index page.If you use Java base server (tomcat or any java application server) the solution could be the following:web.xml:Example:That is it, no more magic needs:)If you are using Create React App:There\'s a great walk though of this issue with solutions for many major hosting platforms that you can find HERE on the Create React App page.  For example, I use React Router v4 and Netlify for my frontend code.  All it took was adding 1 file to my public folder ("_redirects") and one line of code in that file:Now my website properly renders paths like mysite.com/pricing when entered into the browser or when someone hits refresh.If you are hosting in IIS ; Adding this to my webconfig solved my problemYou can make similar configuration for any other serverI had this same problem and this solution worked for us..Background:We are hosting multiple apps on the same server.  When we would refresh the server would not understand where to look for our index in the dist folder for that particular app.  The above link will take you to what worked for us... Hope this helps, as we have spent quite a hours on figuring out a solution for our needs. We are using:my webpack.config.jsmy index.jsmy app.jsProduction stack: React, React Router v4, BrowswerRouter, Express, Nginx1) User BrowserRouter for pretty urls 2) Add index.html to all unknown requests by using /*3) bundle webpack with webpack -p4) run nodemon server.js or node server.jsI used create-react-app to make a website just now and had the same issue presented here. I use BrowserRouting from the react-router-dom package. I am running on a Nginx server and what solved it for me was adding the following to /etc/nginx/yourconfig.confWhich corresponds to adding the following to the .htaccess in case you are running AppacheThis also seems to be the solution suggested by Facebook themselves and can be found hereadd this to webpack.congif.jsPractical workaround:No server-side changes required.