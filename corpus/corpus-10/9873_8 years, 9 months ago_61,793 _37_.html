In .NET, a value type (C# struct) can\'t have a constructor with no parameters. According to this post this is mandated by the CLI specification. What happens is that for every value-type a default constructor is created (by the compiler?) which initialized all members to zero (or null).Why is it disallowed to define such a default constructor?One trivial use is for rational numbers:Using current version of C#, a default Rational is 0/0 which is not so cool.PS: Will default parameters help solve this for C#Â 4.0 or will the CLR-defined default constructor be called?Jon Skeet answered:To use your example, what would you want to happen when someone did:Should it run through your constructor 1000 times?Sure it should, that\'s why I wrote the default constructor in the first place. The CLR should use the default zeroing constructor when no explicit default constructor is defined; that way you only pay for what you use. Then if I want a container of 1000 non-default Rationals (and want to optimize away the 1000 constructions) I will use a List<Rational> rather than an array.This reason, in my mind, is not strong enough to prevent definition of a default constructor. Note: the answer below was written a long time prior to C# 6, which is planning to introduce the ability to declare parameterless constructors in structs - but they still won\'t be called in all situations (e.g. for array creation)  (in the end this feature was not added to C# 6).EDIT: I\'ve edited the answer below due to Grauenwolf\'s insight into the CLR.The CLR allows value types to have parameterless constructors, but C# doesn\'t. I believe this is because it would introduce an expectation that the constructor would be called when it wouldn\'t. For instance, consider this:The CLR is able to do this very efficiently just by allocating the appropriate memory and zeroing it all out. If it had to run the MyStruct constructor 1000 times, that would be a lot less efficient. (In fact, it doesn\'t - if you do have a parameterless constructor, it doesn\'t get run when you create an array, or when you have an uninitialized instance variable.)The basic rule in C# is "the default value for any type can\'t rely on any initialization". Now they could have allowed parameterless constructors to be defined, but then not required that constructor to be executed in all cases - but that would have led to more confusion. (Or at least, so I believe the argument goes.)EDIT: To use your example, what would you want to happen when someone did:Should it run through your constructor 1000 times?EDIT: (Answering a bit more of the question) The parameterless constructor isn\'t created by the compiler. Value types don\'t have to have constructors as far as the CLR is concerned - although it turns out it can if you write it in IL. When you write "new Guid()" in C# that emits different IL to what you get if you call a normal constructor. See this SO question for a bit more on that aspect.I suspect that there aren\'t any value types in the framework with parameterless constructors. No doubt NDepend could tell me if I asked it nicely enough... The fact that C# prohibits it is a big enough hint for me to think it\'s probably a bad idea.A struct is a value type and a value type must have a default value as soon as it is declared.If you declare two fields as above without instantiating either, then break the debugger, m will be null but m2 will not. Given this, a parameterless constructor would make no sense, in fact all any constructor on a struct does is assign values, the thing itself already exists just by declaring it. Indeed m2 could quite happily be used in the above example and have its methods called, if any, and its fields and properties manipulated!You can make a static property that initializes and returns a default "rational" number:And use it like:Shorter explanation: In C++, struct and class were just two sides of the same coin. The only real difference is that one was public by default and the other was private.In .NET, there is a much greater difference between a struct and a class. The main thing is that struct provides value-type semantics, while class provides reference-type semantics. When you start thinking about the implications of this change, other changes start to make more sense as well, including the constructor behavior you describe.Although the CLR allows it, C# does not allow structs to have a default parameter-less constructor. The reason is that, for a value type, compilers by default neither generate a default constructor, nor do they generate a call to the default constructor. So, even if you happened to define a default constructor, it will not be called, and that will only confuse you.To avoid such problems, the C# compiler disallows definition of a default constructor by the user. And because it doesn\'t generate a default constructor, you can\'t initialize fields when defining them.Or the big reason is that a structure is a value type and value types are initialized by a default value and the constructor is used for initialization.You don\'t have to instantiate your struct with the new keyword. It instead works like an int; you can directly access it.Structs cannot contain explicit parameterless constructors. Struct members are automatically initialized to their default values.A default (parameter-less) constructor for a struct could set different values than the all-zeroed state which would be unexpected behavior. The .NET runtime therefore prohibits default constructors for a struct.Just special-case it. If you see a numerator of 0 and a denominator of 0, pretend like it has the values you really want.You can\'t define a default constructor because you are using C#.Structs can have default constructors in .NET, though I don\'t know of any specific language that supports it.Here\'s my solution to the no default constructor dilemma. I know this is a late solution, but I think it\'s worth noting this is a solution. ignoring the fact I have a static struct called null, (Note: This is for all positive quadrant only), using get;set; in C#, you can have a try/catch/finally, for dealing with the errors where a particular data type is not initialized by the default constructor Point2D(). I guess this is elusive as a solution to some people on this answer. Thats mostly why i\'m adding mine. Using the getter and setter functionality in C# will allow you to bypass this default constructor non-sense and put a try catch around what you dont have initialized. For me this works fine, for someone else you might want to add some if statements. So, In the case where you would want a Numerator/Denominator setup, this code might help. I\'d just like to reiterate that this solution does not look nice, probably works even worse from an efficiency standpoint, but, for someone coming from an older version of C#, using array data types gives you this functionality. If you just want something that works, try this: