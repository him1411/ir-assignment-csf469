I am starting to learn Swift, and have been following the very good Stanford University video lectures on YouTube. Here is a link if you are interested or it helps (although it isn\'t required to understand my problem):Developing iOS 8 Apps with Swift - 2. More Xcode and Swift, MVCWhile following the lectures I got to a point where (as far as I could tell) my code was identical to the code in the video but on my system I got a compiler error. After a lot of trial and error I have managed to reduce my code to two examples, one of which generates an error, the other or which doesn\'t, but I have no idea what is actually causing the error or how to resolve it.The code which creates the error is:This creates the following compiler error:Method \'perform\' with Objective-C selector \'perform: \' conflicts with previous declaration with the same Objective-C selectorBy simply removing the sub-classing of UIViewController the code compiles:Some other information which may or may not be relevant:I am half hoping this is a bug in the compiler because otherwise this doesn\'t make any sense to me. Any help very gratefully received!Objective-C does not support method overloading, you have to use a different method name. When you inherited UIViewController you inherited NSObject and made the class interopable to Obj-C. Swift on the other hand does support overloading, that\'s why it works when you remove the inheritance.I myself am also taking the Standford course and I got stuck here for a long time too, but after some searching, I found something from here: Xcode release notes and it mentioned something below: Swift 1.2 is strict about checking type-based overloading of @objc\n  methods and initializers, something not supported by Objective-C.This code would work when invoked from Swift, but could easily crash\n  if invoked from Objective-C. To solve this problem, use a type that is\n  not supported by Objective-C to prevent the Swift compiler from\n  exposing the member to the Objective-C runtime:Overrides of methods exposed\n  to Objective-C in private subclasses are not inferred to be @objc,\n  causing the Swift compiler to crash. Explicitly add the @objc\n  attribute to any such overriding methods. (19935352)Symbols from SDKs are not available when using Open Quickly in a\n  project or workspace that uses Swift. (20349540)what i did was just adding "private" in front of the override method like this:As it has already been answered, ObjC doesn\'t support method overloading (two methods with the same name) and In swift 2 under Xcode 7 there are two options to solve this kind of problems. One option is to rename the method using the attribute: @objc(newNameMethod:) another option to solve this problem in Xcode 7+ is by applying  @nonobjc attribute to any method, subscript or initialiser The problem is UIViewController is an @objc class. When inheriting from UIViewController, BugViewController is also a @objc class.This means it must conform to the rules of Objective-C selectors (the name of a method). The methods func perform(operation: (Double) -> Double) and func perform(operation: (Double, Double) -> Double) both have the same selector @selector(perform:). This is not allowed.To resolve this, use different names: like func perform1(operation: (Double) -> Double) and func perform2(operation: (Double, Double) -> Double).I think the best way to handle this is to give your perform() methods more descriptive names. What do these methods do? How do they change the state of the view controller? Look at the other UIViewController methods to get a feel for the style of method naming, or read Method Names Should Be Expressive and Unique Within a ClassFrom https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html under "Xcode 6.3 Release Notes" -> "Swift Language Changes" you findSwift now detects discrepancies between overloading and overriding in the Swift type system and the effective behavior seen via the Objective-C runtime.I got the same error due to having having two methods with the same Obj-C signature:I didn\'t want to mark one of them as @nonobjc due to possibility of unforseen consequences at runtime. (Someone can correct me if there is no possibility)Resolved it by using Swift\'s external parameter name feature (I made external name same as local name) to the second method, which effectively changes the Obj-c method signature: