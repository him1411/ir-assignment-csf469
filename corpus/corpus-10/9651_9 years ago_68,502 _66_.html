I\'m starting to learn Python and I\'ve come across generator functions, those that have a yield statement in them.  I want to know what types of problems that these functions are really good at solving.Generators give you lazy evaluation. You use them by iterating over them, either explicitly with \'for\' or implicitly by passing it to any function or construct that iterates. You can think of generators as returning multiple items, as if they return a list, but instead of returning them all at once they return them one-by-one, and the generator function is paused until the next item is requested.Generators are good for calculating large sets of results (in particular calculations involving loops themselves) where you don\'t know if you are going to need all results, or where you don\'t want to allocate the memory for all results at the same time. Or for situations where the generator uses another generator, or consumes some other resource, and it\'s more convenient if that happened as late as possible.Another use for generators (that is really the same) is to replace callbacks with iteration. In some situations you want a function to do a lot of work and occasionally report back to the caller. Traditionally you\'d use a callback function for this. You pass this callback to the work-function and it would periodically call this callback. The generator approach is that the work-function (now a generator) knows nothing about the callback, and merely yields whenever it wants to report something. The caller, instead of writing a separate callback and passing that to the work-function, does all the reporting work in a little \'for\' loop around the generator.For example, say you wrote a \'filesystem search\' program. You could perform the search in its entirety, collect the results and then display them one at a time. All of the results would have to be collected before you showed the first, and all of the results would be in memory at the same time. Or you could display the results while you find them, which would be more memory efficient and much friendlier towards the user. The latter could be done by passing the result-printing function to the filesystem-search function, or it could be done by just making the search function a generator and iterating over the result.If you want to see an example of the latter two approaches, see os.path.walk() (the old filesystem-walking function with callback) and os.walk() (the new filesystem-walking generator.) Of course, if you really wanted to collect all results in a list, the generator approach is trivial to convert to the big-list approach:One of the reasons to use generator is to make the solution clearer for some kind of solutions.The other is to treat results one at a time, avoiding building huge lists of results that you would process separated anyway. If you have a fibonacci-up-to-n function like this:You can more easily write the function as this:The function is clearer. And if you use the function like this:in this example, if using the generator version, the whole 1000000 item list won\'t be created at all, just one value at a time. That would not be the case when using the list version, where a list would be created first.See the "Motivation" section in PEP 255.A non-obvious use of generators is creating interruptible functions, which lets you do things like update UI or run several jobs "simultaneously" (interleaved, actually) while not using threads.Buffering. When it is efficient to fetch data in large chunks, but process it in small chunks, then a generator might help:The above lets you easily separate buffering from processing. The consumer function can now just get the values one by one without worrying about buffering.I find this explanation which clears my doubt. Because there is a possibility that person who don\'t know Generators also don\'t know about yieldReturnThe return statement is where all the local variables are destroyed and the resulting value is given back (returned) to the caller.  Should the same function be called some time later, the function will get a fresh new set of variables.YieldBut what if the local variables aren\'t thrown away when we exit a function?  This implies that we can resume the function where we left off.  This is where the concept of generators are introduced and the yield statement resumes where the function left off.So that\'s the difference between return and yield statements in Python.  Yield statement is what makes a function a generator function.So Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called, the generator resumes where it left-off (it remembers all the data values and which statement was last executed).Lets say you have 100 million domains in your MySQL table and you would like to update alexa rank for each domain.First thing you need is to select your domain names from the database. Lets say your table name is domains and column name is domainIf you use SELECT domain FROM domains its going to return 100 million rows which is going to  consume lot of memory. So your server might crashSo you decided to run the program in batches. Let say our batch size is 1000.In our first batch we will query the first 1000 rows, check alexa rank for each domain and update the database row. In our second batch we will work on the next 1000 rows. In our third batch it will be from 2001 to 3000 and so on.Now we need a generator function which generates our batches. Here is our generator functionAs you can see our function keep yielding the results. If you used the keyword return instead of yield, then the whole function will be ended once it reaches returnIf a function uses the keyword yield then its a generator.Now you can iterate like thisI have found that generators are very helpful in cleaning up your code and by giving you a very unique way to encapsulate and modularize code.  In a situation where you need something to constantly spit out values based on its own internal processing and when that something needs to be called from anywhere in your code (and not just within a loop or a block for example), generators are the feature to use.An abstract example would be a fibonacci number generator that does not live within a loop and when it is called from anywhere will always return the next number in sequence:Now you have two fibonacci number generator objects which you can call from anywhere in your code and they will always return ever larger fibonacci numbers in sequence as follows:The lovely thing about generators is that they encapsulate state without having to go through the hoops of creating objects.  One way of thinking about them is as "functions" which remember their internal state.I got the fibonacci example from http://www.neotitans.com/resources/python/python-generators-tutorial.html and with a little imagination, you can come up with a lot of other situations where generators make for a great alternative to for-loops and other traditional iteration constructs.The simple explanation:\nConsider a for statementA lot of the time, all the items in iterable doesn\'t need to be there from the start, but can be generated on the fly as they\'re required. This can be a lot more efficient in both Other times, you don\'t even know all the items ahead of time. For example:You have no way of knowing all the user\'s commands beforehand, but you can use a nice loop like this if you have a generator handing you commands:With generators you can also have iteration over infinite sequences, which is of course not possible when iterating over containers.My favorite uses are "filter" and "reduce" operations.Let\'s say we\'re reading a file, and only want the lines which begin with "##".We can then use the generator function in a proper loopThe reduce example is similar.  Let\'s say we have a file where we need to locate blocks of <Location>...</Location> lines.  [Not HTML tags, but lines that happen to look tag-like.]Again, we can use this generator in a proper for loop.The idea is that a generator function allows us to filter or reduce a sequence, producing a another sequence one value at a time.A practical example where you could make use of a generator is if you have some kind of shape and you want to iterate over its corners, edges or whatever. For my own project (source code here) I had a rectangle:Now I can create a rectangle and loop over its corners:Instead of __iter__ you could have a method iter_corners and call that with for corner in myrect.iter_corners(). It\'s just more elegant to use __iter__ since then we can use the class instance name directly in the for expression.Basically avoiding call-back functions when iterating over input maintaining state.See here and here for an overview of what can be done using generators.Some good answers here, however, I\'d also recommend a complete read of the python Functional Programming tutorial which helps explain some of the more potent use-cases of generators.I use generators when our web server is acting as a proxy:Since the send method of a generator has not been mentioned here is an example:It shows the possibility to send a value to a running generator\nA more advanced course on generators in the video below (including yield from explination, generators for parallel processing, escaping recursion limit etc.)David Beazley on generators at PyCon 2014Piles of stuff. Any time you want to generate a sequence of items, but don\'t want to have to \'materialize\' them all into a list at once. For example, you could have a simple generator that returns prime numbers:You could then use that to generate the products of subsequent primes:These are fairly trivial examples, but you can see how it can be useful for processing large (potentially infinite!) datasets without generating them in advance, which is only one of the more obvious uses.Also good for printing the prime numbers up to n: