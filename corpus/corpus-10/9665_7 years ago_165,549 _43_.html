This question already has an answer here:Are they really same? Today, I ran into this problem. Here is the dump from the Immediate Window:So, both s and tvi.Header contain "Category", but == returns false and Equals() returns true.s is defined as string, tvi.Header is actually a WPF TreeViewItem.Header. So, why are they returning different results? I always thought that they were interchangable in C#.Can anybody explain why this is?Two differences:Equals is polymorphic (i.e. it can be overridden, and the implementation used will depend on the execution-time type of the target object), whereas the implementation of == used is determined based on the compile-time types of the objects:Equals will go bang if you call it on null, == won\'tNote that you can avoid the latter being a problem using object.Equals:The apparent contradictions that appear in the question are caused because in one case the Equals function is called on a string object, and in the other case the == operator is called on the System.Object type. string and object implement equality differently from each other (value vs. reference respectively).Beyond this fact, any type can define == and Equals differently, so in general they are not interchangeable.Here\xe2\x80\x99s an example using double (from Joseph Albahari\xe2\x80\x99s note to \xc2\xa77.9.2 of the C# language specification):He goes on to say that the double.Equals(double) method was designed to work correctly with lists and dictionaries. The == operator, on the other hand, was designed to follow the IEEE 754 standard for floating point types.In the specific case of determining string equality, the industry preference is to use neither == nor string.Equals(string) most of the time. These methods determine whether two string are the same character-for-character, which is rarely the correct behavior. It is better to use string.Equals(string, StringComparison), which allows you to specify a particular type of comparison. By using the correct comparison, you can avoid a lot of potential (very hard to diagnose) bugs.Here\xe2\x80\x99s one example:Both strings in this example look the same ("Caf\xc3\xa9"), so this could be very tough to debug if using a na\xc3\xafve (ordinal) equality.C# has two "equals" concepts: Equals and ReferenceEquals.  For most classes you will encounter, the == operator uses one or the other (or both), and generally only tests for ReferenceEquals when handling reference types (but the string Class is an instance where C# already knows how to test for value equality).Example Code:The Header property of the TreeViewItem is statically typed to be of type object.Therefore the == yields false. You can reproduce this with the following simple snippet:In addition to Jon Skeet\'s answer, I\'d like to explain why most of the time when using == you actually get the answer true on different string instances with the same value:As you can see, a and b must be different string instances, but because strings are immutable, the runtime uses so called string interning to let both a and b reference the same string in memory. The == operator for objects checks reference, and since both a and b reference the same instance, the result is true. When you change either one of them, a new string instance is created, which is why string interning is possible.By the way, Jon Skeet\'s answer is not complete. Indeed, x == y is false but that is only because he is comparing objects and objects compare by reference. If you\'d write (string)x == (string)y, it will return true again. So strings have their ==-operator overloaded, which calls String.Equals underneath.There are plenty of descriptive answers here so I\'m not going to repeat what has already been said. What I would like to add is the following code demonstrating all the permutations I can think of. The code is quite long due to the number of combinations. Feel free to drop it into MSTest and see the output for yourself (the output is included at the bottom).This evidence supports Jon Skeet\'s answer.Code:Output:It is clear that tvi.header is not a String. The == is an operator that is overloaded by String class, which means it will be working only if compiler knows that both side of the operator are String.An object is defined by an OBJECT_ID, which is unique. If A and B are objects and\nA == B is true, then they are the very same object, they have the same data and methods, but, this is also true:A.OBJECT_ID == B.OBJECT_IDif\nA.Equals(B) is true, that means that the two objects are in the same state, but this doesn\'t mean that A is the very same as B.Strings are objects.Note that the == and Equals operators are reflexive, simetric, tranzitive, so they are equivalentic relations (to use relational algebraic terms)What this means:\nIf A, B and C are objects, then:(1) A == A is always true; A.Equals(A) is always true (reflexivity)(2) if A == B then B == A; If A.Equals(B) then B.Equals(A) (simetry)(3) if A == B and B == C, then A == C; if A.Equals(B) and B.Equals(C) then A.Equals(C) (tranzitivity)Also, you can note that this is also true:(A == B)  => (A.Equals(B)), but the inverse is not true.Example of real life:\nTwo Hamburgers of the same type have the same properties: they are objects of the Hamburger class, their properties are exactly the same, but they are different entities. If you buy these two Hamburgers and eat one, the other one won\'t be eaten. So, the difference between Equals and ==:\nYou have hamburger1 and hamburger2. They are exactly in the same state (the same weight, the same temperature, the same taste), so hamburger1.Equals(hamburger2) is true. But hamburger1 == hamburger2 is false, because if the state of hamburger1 changes, the state of hamburger2 not necessarily change and vice versa.If you and a friend get a Hamburger, which is yours and his in the same time, then you must decide to split the Hamburger into two parts, because you.getHamburger() == friend.getHamburger() is true and if this happens: friend.eatHamburger(), then your Hamburger will be eaten too.I could write other nuances about Equals and ==, but I\'m getting hungry, so I have to go.Best regards,\nLajos Arpad.