In swift there seem to be two equality operators: the double equals (==) and the triple equals (===), what is the difference between the two?!== and === are identity operators and are used to determine if two objects have the same reference.Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance.Excerpt From: Apple Inc. \xe2\x80\x9cThe Swift Programming Language.\xe2\x80\x9d iBooks. https://itun.es/us/jEUH0.lIn both Objective-C and Swift, the == and != operators test for value equality for number values (e.g., NSInteger, NSUInteger, NSNumber in Objective-C and Int, UInt, etc. in Swift). For objects (NSObject and subclasses) in Objective-C and reference types in Swift, == and != test that the objects/reference types are the same identical thing -- i.e., same hash value -- or are not the same identical thing, respectively.Swift\'s identity equality operators, === and !==, check referential equality -- and thus, should probably be called the referential equality operators IMO.It\'s also worth pointing out that custom reference types in Swift (that do not subclass a class that conforms to Equatable) do not automatically implement the equal to operators, but the identity equality operators still apply. Also, by implementing ==, != is automatically implemented.These equality operators are not implemented for other types such as structures in either language. However, custom operators can be created in Swift, which would, for example, enable you to create an operator to check equality of a CGPoint.There are subtleties with Swifts === that go beyond mere pointer arithmetics. While in Objective-C you were able to compare any two pointers (i.e. NSObject *) with == this is no longer true in Swift since types play a much greater role during compilation.A Playground will give youWith strings we will have to get used to this:but then you can also have fun as follows:I am sure you can think of a lot more funny cases :-)Update for Swift 3 (as suggested by the comment from Jakub Truhl\xc3\xa1\xc5\x99)This looks a little more consistent with Type \'Int\' does not conform to protocol \'AnyObject\', however we then getbut the explicit conversion makes clear that there might be something going on.\nOn the String-side of things NSString will still be available as long as we import Cocoa. Then we will haveIt is still confusing to have two String classes, but dropping the implicit conversion will probably make it a little more palpable.In swift 3Here I compare three instances (class is a reference type)For example, if you create two instances of a class e.g. myClass:you can compare those instances, cited:which you use to test whether two object references both refer to the\n  same object instance.Excerpt From: Apple Inc. \xe2\x80\x9cThe Swift Programming Language.\xe2\x80\x9d iBooks. https://itun.es/sk/jEUH0.lIn Swift we have === simbol which means is both objects are referring to the same reference same addressJust a minor contribution related to the Any object.I was working with unit tests around NotificationCenter, which makes use of Any as a parameter that I wanted to compare for equality.However, since Any cannot be used in an equality operation, it was necessary to change it. Ultimately, I settled on the following approach, which allowed me to get equality in my specific situation, shown here with a simplistic example:This function takes advantage of ObjectIdentifier, which provides a unique address for the object, allowing me to test.One item to note though about ObjectIdentifier per Apple at the above link:In Swift, only class instances and metatypes have unique identities.\n  There is no notion of identity for structs, enums, functions, or\n  tuples.(==) will check if both have same values or not,\nif(a==b){//value}but (===) will check value as well as type of \nthose variables, if its same or not..!!\nif(a===b){//value and data type}thanks,