Possible Duplicate:\n  Why do people put code like “throw 1; <dont be evil>” and “for(;;);” in front of json responses? I found this kind of syntax being used on Facebook for Ajax calls. I\'m confused on the for (;;); part in the beginning of response. What is it used for?This is the call and response: Response:Facebook has a ton of developers working internally on a lot of projects, and it is very common for someone to make a minor mistake; whether it be something as simple and serious as failing to escape data inserted into an HTML or SQL template or something as intricate and subtle as using eval (sometimes inefficient and arguably insecure) or JSON.parse (a compliant but not universally implemented extension) instead of a "known good" JSON decoder, it is important to figure out ways to easily enforce best practices on this developer population.To face this challenge, Facebook has recently been going "all out" with internal projects designed to gracefully enforce these best practices, and to be honest the only explanation that truly makes sense for this specific case is just that: someone internally decided that all JSON parsing should go through a single implementation in their core library, and the best way to enforce that is for every single API response to get for(;;); automatically tacked on the front.In so doing, a developer can\'t be "lazy": they will notice immediately if they use eval(), wonder what is up, and then realize their mistake and use the approved JSON API.The other answers being provided seem to all fall into one of two categories: Those in the first category rely on the idea that an attacker can somehow make a request "using JSONP" to an API that doesn\'t support it. JSONP is a protocol that must be supported on both the server and the client: it requires the server to return something akin to myFunction({"t":"continue"}) such that the result is passed to a local function. You can\'t just "use JSONP" by accident.Those in the second category are citing a very real vulnerability that has been described allowing a cross-site request forgery via  tags to APIs that do not use JSONP (such as this one), allowing a form of "JSON hijacking". This is done by changing the Array/Object constructor, which allows one to access the information being returned from the server without a wrapping function.However, that is simply not possible in this case: the reason it works at all is that a bare array (one possible result of many JSON APIs, such as the famous Gmail example) is a valid expression statement, which is not true of a bare object.In fact, the syntax for objects defined by JSON (which includes quotation marks around the field names, as seen in this example) conflicts with the syntax for blocks, and therefore cannot be used at the top-level of a script.For this example to be exploitable by way of Object() constructor remapping, it would require the API to have instead returned the object inside of a set of parentheses, making it valid JavaScript (but then not valid JSON).Now, it could be that this for(;;); prefix trick is only "accidentally" showing up in this example, and is in fact being returned by other internal Facebook APIs that are returning arrays; but in this case that should really be noted, as that would then be the "real" cause for why for(;;); is appearing in this specific snippet.I suspect the primary reason it\'s there is control. It forces you to retrieve the data via Ajax, not via JSON-P or similar (which uses script tags, and so would fail because that for loop is infinite), and thus ensures that the Same Origin Policy kicks in. This lets them control what documents can issue calls to the API — specifically, only documents that have the same origin as that API call, or ones that Facebook specifically grants access to via CORS (on browsers that support CORS). So you have to request the data via a mechanism where the browser will enforce the SOP, and you have to know about that preface and remove it before deserializing the data.So yeah, it\'s about controlling (useful) access to that data.Well the for(;;); is an infinite loop (you can use Chrome\'s JavaScript console to run that code in a tab if you want, and then watch the CPU-usage in the task manager go through the roof until the browser kills the tab).  So I suspect that maybe it is being put there to frustrate anyone attempting to parse the response using eval or any other technique that executes the returned data.To explain further, it used to be fairly commonplace to parse a bit of JSON-formatted data using JavaScript\'s eval() function, by doing something like: var parsedJson = eval(\'(\' + jsonString + \')\');...this is considered unsafe, however, as if for some reason your JSON-formatted data contains executable JavaScript code instead of (or in addition to) JSON-formatted data then that code will be executed by the eval().  This means that if you are talking with an untrusted server, or if someone compromises a trusted server, then they can run arbitrary code on your page.  Because of this, using things like eval() to parse JSON-formatted data is generally frowned upon, and the for(;;); statement in the Facebook JSON will prevent people from parsing the data that way.  Anyone that tries will get an infinite loop.  So essentially, it\'s like Facebook is trying to enforce that people work with its API in a way that doesn\'t leave them vulnerable to future exploits that try to hijack the Facebook API to use as a vector.This looks like a hack to prevent a CSRF attack.  There are browser-specific ways to hook into object creation, so a malicious website could use do that first, and then have the following:<script src="http://0.131.channel.facebook.com/x/1476579705/51033089/false/p_1524926084=0" />If there weren\'t the infinite loop before the JSON, an object would be created (since JSON can be eval()ed as javascript, and the hooks would detect it and sniff the object members.Now if you visit that site from a browser, while logged into facebook, it can get at your data as if it were you, and then send it back to its own server via e.g. an AJAX or javascript post.I\'m a bit late and T.J. has basically solved the mystery, but I thought I\'d share a great paper on this particular topic that has good examples and provides deeper insight into this mechanism.These infinite loops are a countermeasure against "Javascript hijacking", a type of attack that gained public attention with an attack on Gmail that was published by Jeremiah Grossman.The idea is as simple as beautiful: A lot of users tend to be logged in permanently in Gmail or Facebook. So what you do is you set up a site and in your malicious site\'s Javascript you override the object or array constructor:then you include a <script> tag in that site such asAnd finally you can read all about the JSON objects in your malicious server\'s logs.As promised, the link to the paper. 