I need to write a T-SQL stored procedure that updates a row in a table. If the row doesn\'t exist, insert it. All this steps wrapped by a transaction. This is for a booking system, so it must be atomic and reliable. It must return true if the transaction was committed and the flight booked.I\'m new to T-SQL, and not sure on how to use @@rowcount. This is what I\'ve written until now. Am I on the right road? I\'m sure is an easy problem for you.Take a look at MERGE command. You can do UPDATE, INSERT & DELETE in  one statement.Here is a working implementation on using MERGE\n- It checks whether flight is full before doing an update, else does an insert.And then ...I assume a single row for each flight? If so:I assume what I said, as your way of doing things can overbook a flight, as it will insert a new row when there are 10 tickets max and you are booking 20.Pass updlock, rowlock, holdlock hints when testing for existence of the row.  The updlock hint forces the query to take an update lock on the row if it already exists, preventing other transactions from modifying it until you commit or roll back.The holdlock hint forces the query to take a range lock, preventing other transactions from adding a row matching your filter criteria until you commit or roll back.  The rowlock hint forces lock granularity to row level instead of the default page level, so your transaction won\'t block other transactions trying to update unrelated rows in the same page (but be aware of the trade-off between reduced contention and the increase in locking overhead - you should avoid taking large numbers of row-level locks in a single transaction).See http://msdn.microsoft.com/en-us/library/ms187373.aspx for more information.Note that locks are taken as the statements which take them are executed - invoking begin tran doesn\'t give you immunity against another transaction pinching locks on something before you get to it.  You should try and factor your SQL to hold locks for the shortest possible time by committing the transaction as soon as possible (acquire late, release early).Note that row-level locks may be less effective if your PK is a bigint, as the internal hashing on SQL Server is degenerate for 64-bit values (different key values may hash to the same lock id).i\'m writing my solution. my method doesn\'t stand \'if\' or \'merge\'. my method is easy.For Example:Explanation:(1) SELECT col1,col2 FROM TableName WHERE col1=@par1 AND col2=@par2\nIt selects from TableName searched values(2) SELECT @par1, @par2 WHERE NOT EXISTS\nIt takes if not exists from (1) subquery(3) Inserts into TableName (2) step valuesThis is something I just recently had to do:You could use the Merge Functionality to achieve. Otherwise you can do:Full solution is below (including cursor structure). Many thanks to Cassius Porcus for the begin trans ... commit code from posting above.I finally was able to insert a row, on the condition that it didn\'t already exist, using the following model: which I found at: http://www.postgresql.org/message-id/87hdow4ld1.fsf@stark.xeocode.com