Why do I have to specify runat="server" on all my ASP.NET controls when it is a mandatory attribute and server is the only option available in my limited knowledge of ASP.NET, and I get an error if I don\'t use it?I do understand that I can optionally use it on my HTML tags, and I do understand the client/server paradigm and what it is actually specifying.Is it a redundant tag that could just be implied by the control being an ASP.NET control, or is there an underlying reason?I\'ve always believed it was there more for the understanding that you can mix ASP.NET tags and HTML Tags, and HTML Tags have the option of either being runat="server" or not.  It doesn\'t hurt anything to leave the tag in, and it causes a compiler error to take it out.  The more things you imply about web language, the less easy it is for a budding programmer to come in and learn it.  That\'s as good a reason as any to be verbose about tag attributes.This conversation was had on Mike Schinkel\'s Blog between himself and Talbot Crowell of Microsoft National Services.  The relevant information is below (first paragraph paraphrased due to grammatical errors in source):[...] but the importance of <runat="server"> is more for consistency and extensibility. If the developer has to mark some tags (viz. <asp: />) for the ASP.NET Engine to ignore, then there\'s also the potential issue of namespace collisions among tags and future enhancements. By requiring the <runat="server"> attribute, this is negated.It continues:If <runat=client> was required for all client-side tags, the parser would need to parse all tags and strip out the <runat=client> part.He continues:  Currently,\n  If my guess is correct, the parser\n  simply ignores all text (tags or no\n  tags) unless it is a tag with the\n  runat=server attribute or a \xe2\x80\x9c<%\xe2\x80\x9d\n  prefix or ssi \xe2\x80\x9c<!\xe2\x80\x93 #include\xe2\x80\xa6 (...)\n  Also, since ASP.NET is designed to\n  allow separation of the web designers\n  (foo.aspx) from the web developers\n  (foo.aspx.vb), the web designers can\n  use their own web designer tools to\n  place HTML and client-side JavaScript\n  without having to know about ASP.NET\n  specific tags or attributes.I usually don\'t like to guess, but I\'m going to on this one...If you remember Microsoft\'s .NET marketing hype back in the day (2001?), it was hard to tell what .NET even was. Was it a server? a programming platform? a language? something new entirely? Given the ads, it was ambiguously anything you wanted it to be - it just solved any problem you might have.So, my guess is there was a hidden grand vision that ASP.NET code could run anywhere - server side OR client side, in a copy of Internet Explorer tied to the .NET runtime. runat="server" is just a vestigial remnant, left behind because it\'s client-side equivalent never made it to production.Remember those weird ads?  Related: Article from The Register with some .NET history.Not all controls that can be included in a page must be run at the server.  For example:<INPUT type="submit" runat=server />This is essentially the same as:<asp:Button runat=server />Remove the runat=server tag from the first one and you have a standard HTML button that runs in the browser.  There are reasons for and against running a particular control at the server, and there is no way for ASP.NET to "assume" what you want based on the HTML markup you include.  It might be possible to "infer" the runat=server for the <asp:XXX /> family of controls, but my guess is that Microsoft would consider that a hack to the markup syntax and ASP.NET engine.Microsoft Msdn article The Forgotten Controls: HTML Server Controls explains use of runat="server" with an example on text box <input type="text"> by converting it to <input type="text" id="Textbox1" runat="server">Doing this will give you programmatic access to the HTML element on\n  the server before the Web page is created and sent down to the client.\n  The HTML element must contain an id attribute. This attribute serves\n  as an identity for the element and enables you to program to elements\n  by their specific IDs. In addition to this attribute, the HTML element\n  must contain runat="server". This tells the processing server that the\n   tag is processed on the server and is not to be considered a\n  traditional HTML element.In short, to enable programmatic access to the HTML element add runat="server" to it.My suspicion is that it has to do with how server-side controls are identified during processing.  Rather than having to check every control at runtime by name to determine whether server-side processing needs to be done, it does a selection on the internal node representation by tag.  The compiler checks to make sure that all controls that require server tags have them during the validation step.It\'s there because all controls in ASP .NET inherit from System.Web.UI.Control which has the "runat" attribute.in the class System.Web.UI.HTMLControl, the attribute is not required, however, in the class System.Web.UI.WebControl the attribute is required.edit:\nlet me be more specific.  since asp.net is pretty much an abstract of HTML, the compiler needs some sort of directive so that it knows that specific tag needs to run server-side. if that attribute wasn\'t there then is wouldn\'t know to process it on the server first. if it isn\'t there it assumes it is regular markup and passes it to the client.I think that Microsoft can fix this ambiguity by making the compiler add runat attribute before the page is ever compiled, something like the type-erasure thing that java has with the generics, instead of erasing, it could be writing runat=server wherever it sees asp: prefix for tags, so the developer would not need to worry about it.If you use it on normal html tags, it means that you can programatically manipulate them in event handlers etc, eg change the href or class of an anchor tag on page load... only do that if you have to, because vanilla html tags go faster. As far as user controls and server controls, no, they just wont work without them, without having delved into the innards of the aspx preprocessor, couldn\'t say exactly why, but would take a guess that for probably good reasons, they just wrote the parser that way, looking for things explicitly marked as "do something".  If @JonSkeet is around anywhere, he will probably be able to provide a much better answer.HTML elements in ASP.NET files are, by default, treated as text. To make these elements programmable, add a runat="server" attribute to the HTML element. This attribute indicates that the element should be treated as a server control.When submitting the data to ASP.NET Web server the controls mentioned as Runat = \xe2\x80\x9cserver\xe2\x80\x9d will  be represented as Dot Net objects in Server Application. You can manually type the code in HTML controls or else can use Run As Server option by right clicking in design view.\nASP.NET controls will automatically get this attribute once you drag it from toolbox where usually HTML controls don\'t.Pretty redundant attribute, considering the "asp" tag is obviously an ASP element and should be enough to identify it as a server side accessible element.Elsewhere however it used to elevate normal tags to be used in the code-behind.runat="Server" indicates a postback to the server will occur for the HTML "control."Web Forms use postback constantly to signal the server to process a page control event..NET MVC pages DO NOT use postback (except for a form "submit").  MVC relies on JQUERY to manage the page on the client side (thus bypassing the need for a lot of postback messages to the server).So:\n.NET Web Forms... use "runat" attribute a lot in the page markup..NET MVC hardly ever uses "runat" attribute in the page markup.Hope this helps clarify why runat is necessary...