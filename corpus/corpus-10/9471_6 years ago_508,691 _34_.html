I want to convert a std::string into a char* or char[] data type.Results in: \xe2\x80\x9cerror: cannot convert \xe2\x80\x98std::string\xe2\x80\x99 to \xe2\x80\x98char\xe2\x80\x99 ...\xe2\x80\x9d.What methods are there available to do this?It won\'t automatically convert (thank god). You\'ll have to use the method c_str() to get the C string version.Note that it returns a const char *; you aren\'t allowed to change the C-style string returned by c_str(). If you want to process it you\'ll have to copy it first:Or in modern C++:More details here, and here but you can use If I\'d need a mutable raw copy of a c++\'s string contents, then I\'d do this: and later:So why don\'t I fiddle with std::vector or new[] like anyone else? Because when I need a mutable C-style raw char* string, then because I want to call C code which changes the string and C code deallocates stuff with free() and allocates with malloc() (strdup uses malloc). So if I pass my raw string to some function X written in C it might have a constraint on it\'s argument that it has to allocated on the heap (for example if the function might want to call realloc on the parameter). But it is highly unlikely that it would expect an argument allocated with (some user-redefined) new[]!(This answer applies to C++98 only.)Please, don\'t use a raw char*.If you just want a C-style string representing the same content:If you want a C-style string with new contents, one way (given that you don\'t know the string size at compile-time) is dynamic allocation:Don\'t forget to delete[] it later.If you want a statically-allocated, limited-length array instead:std::string doesn\'t implicitly convert to these types for the simple reason that needing to do this is usually a design smell. Make sure that you really need it.If you definitely need a char*, the best way is probably:Assuming you just need a C-style string to pass as input:To be strictly pedantic, you cannot "convert a std::string into a char* or char[] data type." As the other answers have shown, you can copy the content of the std::string to a char array, or make a const char* to the content of the std::string so that you can access it in a "C style".If you\'re trying to change the content of the std::string, the std::string type has all of the methods to do anything you could possibly need to do to it. If you\'re trying to pass it to some function which takes a char*, there\'s std::string::c_str().This would be better as a comment on bobobobo\'s answer, but I don\'t have the rep for that. It accomplishes the same thing but with better practices.Although the other answers are useful, if you ever need to convert std::string to char* explicitly without const, const_cast is your friend. Note that this will not give you a copy of the data; it will give you a pointer to the string. Thus, if you modify an element of chr, you\'ll modify str.For completeness\' sake, don\'t forget std::string::copy().std::string::copy() doesn\'t NUL terminate. If you need to ensure a NUL terminator for use in C string functions:Alternatively , you can use vectors to get a writable char* as demonstrated below;Here is one more robust version from Protocol BufferThis will also workYou can make it using iterator.Good luck.A safe version of orlp\'s char* answer using unique_ptr: