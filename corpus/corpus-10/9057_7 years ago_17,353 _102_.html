I\'ve just read on the net about a newly discovered security vulnerability in ASP.NET. You can read the details here.The problem lies in the way that\n  ASP.NET implements the AES encryption\n  algorithm to protect the integrity of\n  the cookies these applications\n  generate to store information during\n  user sessions.This is a bit vague, but here is a more frightening part:The first stage of the attack takes a\n  few thousand requests, but once it\n  succeeds and the attacker gets the\n  secret keys, it\'s totally stealthy.The\n  cryptographic knowledge required is\n  very basic.All in all, I\'m not familiar enough with the security/cryptograpy subject to know if this is really that serious.So, should all ASP.NET developers fear this technique that can own any ASP.NET website in seconds or what?How does this issue affect the average ASP.NET developer? Does it affect us at all?\nIn real life, what are the consequences of this vulnerability? And, finally: is there some workaround that prevents this vulnerability?Thanks for your answers!So, this is basically a "padding oracle" type of attack. @Sri provided a great explanation about what does this type of attack mean. Here is a shocking video about the issue!About the seriousness of this vulnerability: Yes, it is indeed serious. It lets the attacker to get to know the machine key of an application. Thus, he can do some very unwanted things.Here is a bunch of good practices I got that don\'t solve the issue but help improve the general security of a web application.Now, let\'s focus on this issue.The solutionSome other thoughtsThanks to everyone who answered my question. I learned a lot about not only this issue, but web security in general. I marked @Mikael\'s answer as accepted, but the other answers are also very useful.[Update 2010-09-29]Microsoft security bulletinKB Article with reference to the fixScottGu has links for the downloads[Update 2010-09-25]While we are waiting for the fix, yesterday ScottGu postet an update on how to add an extra step to protect your sites with a custom URLScan rule.Additionally add a random time sleep in the error page to prevent the attacker from timing the responses for added attack information.In web.configThis will redirect any error to a custom page returned with a 200 status code. This way an attacker cannot look at the error code or error information for information needed for further attacks.It is also safe to set customErrors mode="RemoteOnly", as this will redirect "real" clients. Only browsing from localhost will show internal .Net errors.The important part is to make sure that all errors are configured to return the same error page.  This requires you to explicitly set the defaultRedirect attribute on the <customErrors> section and ensure that no per-status codes are set.If an attacker manage to use the mentioned exploit, he/she can download internal files from within your web application. Typically web.config is a target and may contain sensitive information like login information in a database connection string, or even link to an automouted sql-express database which you don\'t want someone to get hold of. But if you are following best practice you use Protected Configuration to encrypt all sensitive data in your web.config.Read Microsoft\'s official comment about the vulnerability at http://www.microsoft.com/technet/security/advisory/2416728.mspx. Specifically the "Workaround" part for implementation details on this issue.Also some information on ScottGu\'s blog, including a script to find vulnerable ASP.Net apps on your web server.For an explanation on "Understanding Padding Oracle Attacks", read @sri\'s answer.Comments to the article:The attack that Rizzo and Duong have implemented against ASP.NET apps requires that the crypto\n  implementation on the Web site have an oracle that, when sent ciphertext, will not only decrypt the text\n  but give the sender a message about whether the padding in the ciphertext is valid. If the padding is invalid, the error message that the sender gets will give him some information about the way that the site\'s decryption process works.In order for the attack to work the following must be true:So, if you return human readable error messages in your app like "Something went wrong, please try again" then you should be pretty safe. Reading a bit on the comments on the article also gives valuable information.That way a hijacked cookie can only be used to retrieve a session which most likely is no longer present or invalidated.It will be interesting to see what is actually presented at the Ekoparty conference, but right now I\'m not too worried about this vulnerability.Understanding Padding Oracle AttacksLets assume your application accepts an encrypted string as a parameter - whether the parameter is a cookie, a url parameter or something else is immaterial. When the application tries to decode it, there are 3 possible outcomes - Outcome 1 : The encrypted string decrypted properly, and the application was able to make sense of it. Meaning, if the encrypted string was an 10 digit account number, after decryption the application found something like "1234567890" and not "abcd1213ef"Outcome 2 : The padding was correct, but after decryption the string obtained was gibberish that the app couldn\'t understand. For example, the string decrypted to "abcd1213ef", but the app was expecting only numbers. Most apps will show a message like "Invalid account number".Outcome 3 : The padding was incorrect, and the application threw some kind of error message. Most apps will show a generic message like "Some error occurred".In order for a Padding Oracle attack to be successful, the attacker must be able to make several thousands of requests, and must be able to classify the response into one of the above 3 buckets without error.If these two conditions are met, the attacker can eventually decrypt the message, and then re-encrypt it with whatever he wishes. Its just a question of time. What can be done to prevent it?Simplest thing - anything sensitive should never be sent to the client, encrypted or no encrypted. Keep it on the server. Make sure that outcome 2 and outcome 3 in the above list appear exactly the same to the attacker. There should be no way to figure out one from the other. This is not all that easy, though - an attacker can discriminate using some kind of timing attack. As a last line of defence, have a Web Application Firewall. The padding oracle attack needs to make several requests that look almost similar (changing one bit at a time), so it should be possible for a WAF to catch and block such requests.P.S. A good explanation of Padding Oracle Attacks can be found in this blog post. Disclaimer: Its NOT my blog.From what I read until now...The attack allows someone to decrypt\n  sniffed cookies, which could contain\n  valuable data such as bank balancesThey need the encrypted cookie of a user that have been already logged in, on any account. They also need to find data in cookies - I hope that developers do not store critical data in cookies :). And there is a way that I have below to not let asp.net store data in the login cookie.How can someone get the cookie of a user that is online if he doesn\'t get his hands on the browser data? Or sniff the IP packet ?One way to prevent that is to not allow cookies to transport without ssl encryption.Also one more measure is to prevent storing Roles in cookies.Now about the cookies that are not secure for the regular pages, this needs some more thinking what you left your user do and what not, how you trust him, what extra check you can do (for example if you see a change on the ip, maybe stop trust him until relogin from security page).Reference:\nCan some hacker steal the cookie from a user and login with that name on a web site?How to check from where attacks come and not give back informations. I wrote here a simple way to prevent the padding is invalid and logging at the same time to track down attackers: CryptographicException: Padding is invalid and cannot be removed and Validation of viewstate MAC failedThe way to track the attacker is to check the padding is invalid. With a simple procedure you can track them down and block them - they need some thousands of call on your page to find the key !I have download the tool that suppose that\'s find the KEY and decrypt the data, and as I say its trap on the above code that\'s check the viewstate. From my tests this tool have many more to fix, for example can not scan compressed view state as it is and its crash on my tests.If some one try to use this tool or this method the above code can track them down and you can block them out of your page with simple code like this one  "Prevent Denial Of Service (DOS)", or like this code for preventing Denial of service.Its seems from what I read until now that the only think that is really need it to not give information back about the error, and just place a custom error page and if you like you can just create and a random delay to this page.a very interesting video on this issue.So all the above its more measure for more protections but not 100% necessaries for this particular issue. For example to use ssl cookie is solve the snif issue, the not cache the Roles in cookies it good to not send and get back big cookies, and to avoid some one that have all ready crack the code, to just place the admin role on the cookie of him.The viewstate track its just one more measure to find attack.Here is the MS response.  It all boils down to "use a custom error page" and you won\'t be giving away any clues.EDIT\nHere is some more detailed info from scottgu.Adding ScottGu\'s responses taken from discussion at http://weblogs.asp.net/scottgu/archive/2010/09/18/important-asp-net-security-vulnerability.aspxIs custom IHttpModule instead of customErrors affected?Q: I don\'t have a  element declared in my web.config, I have instead an IHttpModule inside the  section. This module logs the error and redirects to either a search page (for 404\'s) or to an error page (for 500\'s). Am I vulnerable?A: I would recommend temporarily updating the module to always redirect to the search page.  One of the ways this attack works is that looks for differentiation between 404s and 500 errors.  Always returning the same HTTP code and sending them to the same place is one way to help block it.Note that when the patch comes out to fix this, you won\'t need to do this (and can revert back to the old behavior).  But for right now I\'d recommend not differentiating between 404s and 500s to clients.Can I continue using different errors for 404 and 500 errors?Q: I take it we can still have a custom 404 page defined in addition to the default redirect on error, without violating the principles described above?A: No - until we release a patch for the real fix, we recommend the above workaround which homogenizes all errors.  One of the ways this attack works is that looks for differentiation between 404s and 500 errors.  Always returning the same HTTP code and sending them to the same place is one way to help block it.Note that when the patch comes out to fix this, you won\'t need to do this (and can revert back to the old behavior).  But for right now you should not differentiate between 404s and 500s to clients.How does this allow exposure of web.config?Q:  How does this allow exposure of web.config?  This seems to enable decrypting of ViewState only, is there another related vulnerability that also allows the information disclosure?  Is there a whitepaper that details the attack for a better explanation of what\'s going on?A: The attack that was shown in the public relies on a feature in ASP.NET that allows files (typically javascript and css) to be downloaded, and which is secured with a key that is sent as part of the request. Unfortunately if you are able to forge a key you can use this feature to download the web.config file of an application (but not files outside of the application).  We will obviously release a patch for this - until then the above workaround closes the attack vector.EDIT: additional FAQ available in the second blogpost at http://weblogs.asp.net/scottgu/archive/2010/09/20/frequently-asked-questions-about-the-asp-net-security-vulnerability.aspxIMO, there is no across-the-board prevention for this, it needs to be handled on a case-by-case basis:http://www.onpreinit.com/2010/09/aspnet-vulnerability-workaround-flawed.htmlA few significant links:[To answer the seriousness aspect of this (what has been published and workarounds are covered by other answers).]The key being attacked is used to protect both view state and session cookies. Normally this key is generated internally by ASP.NET with each new instance of the web app. This will limit the scope of damage to the lifetime of the worker process, of course for a busy application this could be days (i.e. not much of a limit). During this time the attacker can change (or inject) values into the ViewState and change their session.Even more seriously if you want sessions to be able to span worker process lifetimes, or allow web farms (i.e. all instances in the farm can handle any user session) the key needs to be hard coded, this is done in web.config:Those are, of course, newly created keys, I use the following PowerShell to access Windows cryptographic random number generator:(Using an array length of 20 for the validation and 16 for the decryption keys.)As well as modifying the public error pages to not leak the specific error, it would seem a good time to change the above keys (or cycle worker processes if they have been running for a while).[Edit 2010-09-21: Added links to top]I just posted my full take on this in my blog, after extra research on the issue. I think its important clearing out why they are getting as far as forging an auth cookie.Just want to get some facts straight:About 1, afaik the encrypted messages can\'t be 100% arbitrary need to tolerate a tiny piece of garbage somewhere in the message, as there is 1 block in the message which decrypt value that can\'t be controlled.Finally I would like to say that this issue is the result of ms not following its own guidance in this case: a feature relies on something sent to the client being tamper proof.More on:I don\'t know if padding gives invalid results in error while padding valid results in ignored authentication ticket (don\'t know if its or not the case) ... the same analysis should apply to the session cookie.The auth cookie is signed, and from the info in the paper they shouldn\'t be able to generate a signed cookie if they don\'t get to the actual keys (as they did in the video before forging the auth cookie).As Aristos mentioned, for the session id in the cookie, that\'s random for the user session, so it\'d have to be sniffed from an user with the target security level and cracked while that session is active. Even then if you are relying in authentication to assign/authorize the user operations, then the impact would be minimal / it\'d depends a lot in what Session is used for in that app.A patch for this bug has been released on Windows Update:\nhttp://weblogs.asp.net/scottgu/archive/2010/09/30/asp-net-security-fix-now-on-windows-update.aspxAsp.Net MVC is also affected by this problem (as is Sharepoint, ...)I\'ve covered the fix for MVC here: Is ASP.NET MVC vulnerable to the oracle padding attack?