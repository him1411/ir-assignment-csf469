I setup global namespaces for my objects by explicitly setting a property on window.TypeScript underlines MyNamespace and complains that:The property \'MyNamespace\' does not exist on value of type \'window\'\n  any"I can make the code work by declaring MyNamespace as an ambient variable and dropping the window explicitness but I don\'t want to do that.How can I keep window in there and make TypeScript happy?As a side note I find it especially funny that TypeScript complains since it tells me that window is of type any which by definitely can contain anything.To keep it dynamic, just use:Just found the answer to this in another StackOverflow question\'s answer.Basically you need to extend the existing window interface to tell it about your new property.Or...you can just type:and you wont get a compile error and it works the same as typing window.MyNamespaceUsing TSX?  None of the other answers were working for me.  Here\'s what I did:The accepted answer is what I used to use, but with TypeScript 0.9.* it no longer works. The new definition of the Window interface seems to completely replace the built-in definition, instead of augmenting it.I have taken to doing this instead:UPDATE: With TypeScript 0.9.5 the accepted answer is working again.If you need to extend the window object with a custom type that requires the use of import you can use the following method:window.d.tsSee \'Global Augmentation\' in the \'Declaration Merging\' section of the Handbook: https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentationHere\'s how to do it, if you\'re using TypeScript Definition Manager!Create typings/custom/window.d.ts:Install your custom typing:  Done, use itâ€Œ! Typescript won\'t complain anymore:If you\'re using the Angular CLI it\'s really straightforward (tested on CLI RC.0):src/polyfills.tsmy-custom-utils.tsI\'m using IntelliJ, so I also needed to change the following setting in the IDE before my new polyfills picked up:Most of the other answers are not perfect.I also encounter the similar problem this morning. I tried so many "solutions" on SO, but none of them produce no type error absolutely and enable triggering type jumping in IDE(webstorm or vscode). Finally, from herehttps://github.com/Microsoft/TypeScript/issues/3180#issuecomment-102523512, I find a reasonable solution to attach typings for global variable which acts as interface/class and namespace both.Example is below:Now, the code above merges the typings of namespace MyNamespace and interface MyNamespace into the global variable myNamespace(the property of window).Global are "evil" :), i think the best way to have also the portability is:First you export the interface: (eg: ./custom.window.ts)export interface CustomWindow extends Window {\n    customAttribute: any;\n}Second you importimport {CustomWindow} from \'./custom.window.ts\';Third cast global var window with CustomWindowdeclare let window: CustomWindow;In this way you don\'t have also red line in different IDE if you use with existent attributes of window object, so at the end try:Tested with Typescript 2.4.xWhen I tried this, window is typed to Window - which means there is a definition that states what properties and methods a Window can support, and your custom namespace isn\'t in that list.Can you not get the behaviour you want using a TypeScript module?For reference (this is the correct answer):Inside a .d.ts definition fileIf you work in the browser, \nyou add members to the browser\'s window context by reopening Window\'s interface:Same idea for NodeJS:Now you declare the root variable (that will actually live on window or global)Then in a regular .ts file, but imported as side-effect, you actually implement it:And finally use it elsewhere in the codebase, with either:After finding answers around, I think this page might be helpful.\nhttps://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation\nNot sure about the history of declaration merging, but it explains why the following could work.