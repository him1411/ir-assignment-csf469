Scenario: The user taps on a button on a view controller. The view controller is the topmost (obviously) in the navigation stack. The tap invokes a utility class method called on another class. A bad thing happens there and I want to display an alert right there before control returns to the view controller.This was possible with UIAlertView (but perhaps not quite proper). In this case, how do you present a UIAlertController, right there in myUtilityMethod? At WWDC, I stopped in at one of the labs and asked an Apple Engineer this same question: "What was the best practice for displaying a UIAlertController?" And he said they had been getting this question a lot and we joked that they should have had a session on it. He said that internally Apple is creating a UIWindow with a transparent UIViewController and then presenting the UIAlertController on it. Basically what is in Dylan Betterman\'s answer.But I didn\'t want to use a subclass of UIAlertController because that would require me changing my code throughout my app. So with the help of an associated object, I made a category on UIAlertController that provides a show method in Objective-C.Here is the relevant code:Here is a sample usage:The UIWindow that is created will be destroyed when the UIAlertController is dealloced, since it is the only object that is retaining the UIWindow. But if you assign the UIAlertController to a property or cause its retain count to increase by accessing the alert in one of the action blocks, the UIWindow will stay on screen, locking up your UI. See the sample usage code above to avoid in the case of needing to access UITextField.I made a GitHub repo with a test project: FFGlobalAlertControllerYou can do the following with Swift 2.2:And Swift 3.0:Objective-CSwift 2.3Swift 3Pretty generic UIAlertController extension for all cases of UINavigationController and/or UITabBarController. Also works if there\'s a modal VC on screen at the moment.  Usage:This is the extension:  I posted a similar question a couple months ago and think I\'ve finally solved the problem. Follow the link at the bottom of my post if you just want to see the code.The solution is to use an additional UIWindow. When you want to display your UIAlertController:A couple things to note:Lastly, I have a completed implementation if you just want to look at that.https://github.com/dbettermann/DBAlertControllerImproving on agilityvision\'s answer, you\'ll need to create a window with a transparent root view controller and present the alert view from there.However as long as you have an action in your alert controller, you don\'t need to keep a reference to the window. As a final step of the action handler block, you just need to hide the window as part of the cleanup task. By having a reference to the window in the handler block, this creates a temporary circular reference that would be broken once the alert controller is dismissed.The following solution did not work even though it looked quite promising with all the versions. This solution is generating WARNING.Warning: Attempt to present  on  whose view is not in the window hierarchy!https://stackoverflow.com/a/34487871/2369867 =>\nThis is looked promising then. But it was not in Swift 3.\nSo I am answering this in Swift 3 and this is not template example. This is rather fully functional code by itself once you paste inside any function.Quick Swift 3 self-contained codeThis is tested and working code in Swift 3.Adding on to Zev\'s answer (and switching back to Objective-C), you could run into a situation where your root view controller is presenting some other VC via a segue or something else. Calling presentedViewController on the root VC will take care of this:This straightened out an issue I had where the root VC had segued to another VC, and instead of presenting the alert controller, a warning like those reported above was issued:I haven\'t tested it, but this may also be necessary if your root VC happens to be a navigation controller. This works in Swift for normal view controllers and even if there is a navigation controller on the screen:Create Extension like in Aviel Gross answer. Here You have Objective-C extension.Here You have header file *.hAnd implementation: *.mYou are using this extension in Your implementation file like this:Shorthand way to do present the alert in Objective-C:Where alertController is your UIAlertController object.NOTE: You\'ll also need to make sure your helper class extends UIViewControllerYou can send the current view or controller as a parameter:Cross post my answer since these two threads are not flagged as dupes...Now that UIViewController is part of the responder chain, you can do something like this:If anyone is interested I created a Swift 3 version of @agilityvision answer. The code:With this you can easily present your alert like soOne thing to note is that if there\'s a UIAlertController currently being displayed, UIApplication.topMostViewController will return a UIAlertController. Presenting on top of a UIAlertController has weird behavior and should be avoided. As such, you should either manually check that !(UIApplication.topMostViewController is UIAlertController) before presenting, or add an else if case to return nil if self is UIAlertControllerZev Eisenberg\'s answer is simple and straightforward, but it does not always work, and it may fail with this warning message: This is because the windows rootViewController is not at the top of the presented views. To correct this we need to walk up the presentation chain, as shown in my UIAlertController extension code written in Swift 3:Updates on 9/15/2017:Tested and confirmed that the above logic still works great in the newly available iOS 11 GM seed. The top voted method by agilityvision, however, does not: the alert view presented in a newly minted UIWindow is below the keyboard and potentially prevents the user from tapping its buttons. This is because in iOS 11 all windowLevels higher than that of keyboard window is lowered to a level below it. One artifact of presenting from keyWindow though is the animation of keyboard sliding down when alert is presented, and sliding up again when alert is dismissed. If you want the keyboard to stay there during presentation, you can try to present from the top window itself, as shown in below code: The only not so great part of the above code is that it checks the class name UIRemoteKeyboardWindow to make sure we can include it too. Nevertheless the above code does work great in iOS 9, 10 and 11 GM seed, with the right tint color and without the keyboard sliding artifacts.You can try to implement a category on UIViewController with mehtod like \n- (void)presentErrorMessage; And and inside that method you implement UIAlertController and then present it on self. Than in your client code you will have something like:[myViewController presentErrorMessage];In that way you\'ll avoid unneccessary parametrs and warnings about view not being in window hierarchy.There 2 approaches that you can use:-Use UIAlertView or \'UIActionSheet\' instead (not recommended, cause it deprecated in iOS 8 but it works now)-Somehow remember the last view controller which is presented. Here is example.Usage:Kevin Sliech provided a great solution.I now use the below code in my main UIViewController subclass.One small alteration i made was to check to see if the best presentation controller is not a plain UIViewController. If not, it\'s got to be some VC that presents a plain VC. Thus we return the VC that\'s being presented instead.Seems to all work out so far in my testing.Thank you Kevin!I use this code with some little personal variations in my AppDelegate classIn addition to great answers given (agilityvision, adib, malhal). To reach queueing behaviour like in good old UIAlertViews (avoid alert windows overlap), use this block to observe window level availability:Complete example:This will allow you to avoid alert windows overlap. Same method can be used to separate and put in queue view controllers for any number of window layers.Seems to work:create helper class AlertWindow and than use as@agilityvision\'s answer is so good. I have sense used in swift projects so  I thought I would share my take on his answer using swift 3.0Register for a notification prior to calling the class method.Swift code:In the displayAlert instance method you could display your alert.