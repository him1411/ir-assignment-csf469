Suppose we want to write a macro that defines an anonymous class with some type members or methods, and then creates an instance of that class that\'s statically typed as a structural type with those methods, etc. This is possible with the macro system in 2.10.0, and the type member part is extremely easy:(Where ReflectionUtils is a convenience trait that provides my constructor method.)This macro lets us specify the name of the anonymous class\'s type member as a string literal:Note that it\'s appropriately typed. We can confirm that everything\'s working as expected:Now suppose that we try to do the same thing with a method:But when we try it out, we don\'t get a structural type:But if we stick an extra anonymous class in there:It works:This is extremely handy\xe2\x80\x94it lets you do things like this, for example\xe2\x80\x94but I don\'t understand why it works, and the type member version works, but not bar. I know this may not be defined behavior, but does it make any sense? Is there an cleaner way to get a structural type (with the methods on it) from a macro?This question is answered in duplicate by Travis here. There are links to the issue in the tracker and to Eugene\'s discussion (in the comments and mailing list).In the famous "Skylla and Charybdis" section of the type checker, our hero decides what shall escape dark anonymity and see the light as a member of the structural type.There are a couple of ways to trick the type checker (which do not entail Odysseus\'s ploy of hugging a sheep).  The simplest is to insert a dummy statement so that the block doesn\'t look like an anonymous class followed by its instantiation.If the typer notices that you\'re a public term that isn\'t referenced by the outside, it will make you private.