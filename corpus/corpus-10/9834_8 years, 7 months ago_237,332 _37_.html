How do I convert a decimal to an int?Use Convert.ToInt32 from mscorlib as inSee MSDN. You can also use Decimal.ToInt32. Again, see MSDN. Finally, you can do a direct cast as inwhich uses the explicit cast operator. See MSDN.You can\'t.Well, of course you could, however an int (System.Int32) is not big enough to hold every possible decimal value.  That means if you cast a decimal that\'s larger than int.MaxValue you will overflow, and if the decimal is smaller than int.MinValue, it will underflow.  What happens when you under/overflow?  One of two things.  If your build is unchecked (i.e., the CLR doesn\'t care if you do), your application will continue after the value over/underflows, but the value in the int will not be what you expected.  This can lead to intermittent bugs and may be hard to fix.  You\'ll end up your application in an unknown state which may result in your application corrupting whatever important data its working on.  Not good.If your assembly is checked (properties->build->advanced->check for arithmetic overflow/underflow or the /checked compiler option), your code will throw an exception when an under/overflow occurs.  This is probably better than not; however the default for assemblies is not to check for over/underflow.The real question is "what are you trying to do?"  Without knowing your requirements, nobody can tell you what you should do in this case, other than the obvious:  DON\'T DO IT.  If you specifically do NOT care, the answers here are valid.  However, you should communicate your understanding that an overflow may occur and that it doesn\'t matter by wrapping your cast code in an unchecked blockThat way people coming behind you understand you don\'t care, and if in the future someone changes your builds to /checked, your code won\'t break unexpectedly.If all you want to do is drop the fractional portion of the number, leaving the integral part, you can use Math.Truncate.will give you the number rounded down.If you want to round to the nearest even number (i.e. >.5 will round up) you can useIn general you can cast between all the numerical types in C#. If there is no information that will be lost during the cast you can do it implicitly:though you can still do it explicitly if you wish:However, if you are going to be losing information through the cast you must do it explicitly (to show you are aware you may be losing information):Here you are losing the ".5". This may be fine, but you must be explicit about it and make an explicit cast to show you know you may be losing the information.This should work just fine.A neat trick for fast rounding is to add .5 before you cast your decimal to an int.Still leaves i=10, but Would round up so that i=11.System.Decimal implements the IConvertable interface, which has a ToInt32() member. Does calling System.Decimal.ToInt32() work for you?I prefer using Math.Round, Math.Floor, Math.Ceiling or Math.Truncate to explicitly set the rounding mode as appropriate. Note that they all return Decimal as well - since Decimal has a larger range of values than an Int32, so you\'ll still need to cast (and check for overflow/underflow).Here is a very handy convert data type webpage for those of others.\nhttp://www.convertdatatypes.com/Convert-decimal-to-int-in-CSharp.htmldecimal d = 5.5;ref: link textRounding a decimal to the nearest integerwhen a = 49.9, then b = 50when a = 49.5, then b = 50when a = 49.4, then b = 49 etc.I find that the casting operator does not work if you have a boxed decimal (i.e. a decimal value inside an object type).  Convert.ToInt32(decimal as object) works fine in this case.This situation comes up when retrieving IDENTITY/AUTONUMBER values from the database:See 4.3.2 Unboxing conversions