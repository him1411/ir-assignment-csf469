I\'m working on networking for my app. So I decided to try out Square\'s Retrofit. I see that they support simple Callbackand RxJava\'s ObservableBoth look pretty similar at first glance, but when it gets to implementation it gets interesting...While with simple callback implementation would look similar to this:which is quite simple and straightforward. And with Observable it quickly gets verbose and quite complicated.And that is not it. You still have to do something like this:Am I missing something here? Or is this a wrong case to use Observables?\nWhen would/should one prefer Observable over simple Callback?Using retrofit is much simpler than example above as @Niels showed in his answer or in Jake Wharton\'s example project U2020. But essentially the question stays the same - when should one use one way or the other?For simple networking stuff, the advantages of RxJava over Callback is very limited. The simple getUserPhoto example:RxJava:Callback:The RxJava variant is not much better than the Callback variant. For now, let\'s ignore the error handling.\nLet\'s take a list of photos:RxJava:Callback:Now, the RxJava variant still isn\'t smaller, although with Lambdas it would be getter closer to the Callback variant.\nFurthermore, if you have access to the JSON feed, it would be kind of weird to retrieve all photos when you\'re only displaying the PNGs. Just adjust the feed to it only displays PNGs.First conclusion It doesn\'t make your codebase smaller when you\'re loading a simple JSON that you prepared to be in the right format.Now, let\'s make things a bit more interesting. Let\'s say you not only want to retrieve the userPhoto, but you have an Instagram-clone, and you want to retrieve 2 JSONs:\n1. getUserDetails()\n2. getUserPhotos()You want to load these two JSONs in parallel, and when both are loaded, the page should be displayed.\nThe callback variant will become a bit more difficult: you have to create 2 callbacks, store the data in the activity, and if all the data is loaded, display the page:Callback:RxJava:We are getting somewhere! The code of RxJava is now as big as the callback option. The RxJava code is more robust; \nThink of what would happen if we needed a third JSON to be loaded (like the latest Videos)? The RxJava would only need a tiny adjustment, while the Callback variant needs to be adjusted in multiple places (on each callback we need to check if all data is retrieved).Another example; we want to create an autocomplete field, which loads data using Retrofit.\nWe don\'t want to do a webcall every time an EditText has a TextChangedEvent. When typing fast, only the last element should trigger the call.\nOn RxJava we can use the debounce operator:I won\'t create the Callback variant but you will understand this is much more work.Conclusion:\nRxJava is exceptionally good when data is sent as a stream. The Retrofit Observable pushes all elements on the stream at the same time. \nThis isn\'t particularly useful in itself compared to Callback. But when there are multiple elements pushed on the stream and different times, and you need to do timing-related stuff, RxJava makes the code a lot more maintainable.The Observable stuff is already done in Retrofit, so the code could be this:In the case of getUserPhoto() the advantages for RxJava aren\'t great.\nBut let\'s take another example when you\'ll get all the photos for a user, but only when the image is PNG, and you don\'t have access to the JSON to do the filtering on the serverside.Now the JSON returns a list of Photo\'s. We\'ll flatMap them to individual items. By doing so, we\'ll be able to use the filter method to ignore photos which are not PNG. After that, we\'ll subscribe, and get a callback for each individual photo, an errorHandler, and a callback when all rows have been completed.TLDR\nPoint here being; the callback only returns you a callback for succes and failure; the RxJava Observable allows you to do map, reduce, filter and many more stuff.With rxjava you can do more things with less code.Let\xc2\xb4s assume that you want to implement instant search in your app.\nWith callbacks you have worried about unsubscribing the previous request and subscribe to the new one, handle orientation change yourself... I think it\xc2\xb4s a lot of code and too verbose.With rxjava is very simple.if you want to implement instant search you only have to listen for TextChangeListener and call to photoModel.setUserId(EditText.getText());In onCreate method of Fragment or activity you subscribe to the Observable that returns   photoModel.subscribeToPhoto(), it returns an Observable that always emit the items emited by the latest Observable(request).Also, if PhotoModel is a Singleton, for instance, you don\'t need to worry about orientation changes, because BehaviorSubject emits the last server response, regardless of when you subscribe.With this lines of code we have implemented an instant search and handle orientation changes.\nDo you think that you can implement this with callbacks with less code? I doubt it.It looks like you\'re reinventing the wheel, what you\'re doing is already implemented in retrofit.For an example, you could look at retrofit\'s RestAdapterTest.java, where they define an interface with Observable as return type, and then use it.By the samples and conclusions in other answers, I think there is no big difference for simple one or two-steps tasks. However, Callback is simple and straightforward. RxJava is more complicated and too big for simple task. There is the third solution by: AbacusUtil. Let me implement above use cases with all three solutions: Callback, RxJava, CompletableFuture(AbacusUtil) with Retrolambda:Fetch photo from network and save/display on device:Load user details and photo in parallel