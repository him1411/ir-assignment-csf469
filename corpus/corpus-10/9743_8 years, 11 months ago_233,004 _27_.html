For example:This comes up in Java 5 and later if you\'re using collections without type specifiers (e.g., Arraylist() instead of ArrayList<String>()).  It means that the compiler can\'t check that you\'re using the collection in a type-safe way, using generics.To get rid of the warning, just be specific about what type of objects you\'re storing in the collection.  So, instead of useIn Java 7 you can shorten generic instantiation by using Type Inference.If you do what it suggests and recompile with the "-Xlint:unchecked" switch, it will give you more detailed information.As well as the use of raw types (as described by the other answers), an unchecked cast can also cause the warning.Once you\'ve compiled with -Xlint, you should be able to rework your code to avoid the warning.  This is not always possible, particularly if you are integrating with legacy code that cannot be changed.  In this situation, you may decide to suppress the warning in places where you know that the code is correct:This warning means that your code operates on a raw type, recompile the example with the to get the details like this:  docs.oracle.com talks about it here: \nhttp://docs.oracle.com/javase/tutorial/java/generics/rawTypes.htmlfor example when you call a function that returns Generic Collections and you don\'t specify the generic parameters yourself.for a functionwill generate this error.To solve it you would just add the parametersThe "unchecked or unsafe operations" warning was added when java added Generics, if I remember correctly. It\'s usually asking you to be more explicit about types, in one way or another. For example. the code ArrayList foo = new ArrayList(); triggers that warning because javac is looking for ArrayList<String> foo = new ArrayList<String>();I just want to add one example of the kind of unchecked warning I see quite often. If you use classes that implement an interface like Serializable, often you will call methods that return objects of the interface, and not the actual class. If the class being returned must be cast to a type based on generics, you can get this warning. Here is a brief (and somewhat silly) example to demonstrate:getInstance() returns an object that implements Serializable. This must be cast to the actual type, but this is an unchecked cast.The solution would be to use specific type in <> like ArrayList.example: File curfolder = new File( "C:\\\\Users\\\\username\\\\Desktop");\nFile[] file = curfolder.listFiles();\nArrayList filename = Arrays.asList(file);above code generate warning because ArrayList is not of specific type.File curfolder = new File( "C:\\\\Users\\\\username\\\\Desktop");\nFile[] file = curfolder.listFiles();\nArrayList<File> filename = Arrays.asList(file);above code will do fine. Only change is in third line after ArrayList.