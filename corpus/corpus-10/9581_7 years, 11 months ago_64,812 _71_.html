I would like to know a list of the most common application/websites/solutions where Erlang is used, successfully or not.Explaining why it is used into a specific solution instead of others programming languages would be very much appreciated, too.Listing BAD Erlang case studies (cases in which Erlang is misused) it would be interesting, as well.From Programming Erlang:alt text http://bks8.books.google.com/books?id=Qr_WuvfTSpEC&printsec=frontcover&img=1&zoom=5&sig=ACfU3U2F4YY4KqO0vCuZ4WEZjdE2yFFvvg\xe2\x80\xa2 Amazon uses Erlang to implement SimpleDB, providing database services as a part\nof the Amazon Elastic Compute Cloud (EC2).\xe2\x80\xa2 Yahoo! uses it in its social bookmarking service, Delicious, which has more than\n5 million users and 150 million bookmarked URLs.\xe2\x80\xa2 Facebook uses Erlang to power the backend of its chat service, handling more than\n100 million active users.  \n\xe2\x80\xa2 WhatsApp uses Erlang to run messaging servers, achieving up to 2 million connected users per server.\xe2\x80\xa2 T-Mobile uses Erlang in its SMS and authentication systems.\xe2\x80\xa2 Motorola is using Erlang in call processing products in the public-safety industry.\xe2\x80\xa2 Ericsson uses Erlang in its support nodes, used in GPRS and 3G mobile networks\nworldwide.\xe2\x80\xa2 The 3D subdivision modeler Wings 3D, used to model and texture polygon\nmeshes.\xe2\x80\xa2 The Ejabberd system, which provides an Extensible Messaging and Presence Protocol\n(XMPP) based instant messaging (IM) application server.\xe2\x80\xa2 The CouchDB \xe2\x80\x9cschema-less\xe2\x80\x9d document-oriented database, providing scalability\nacross multicore and multiserver clusters.\xe2\x80\xa2 The MochiWeb library that provides support for building lightweight HTTP servers.\nIt is used to power services such as MochiBot and MochiAds, which serve\ndynamically generated content to millions of viewers daily.\xe2\x80\xa2 RabbitMQ, an AMQP messaging protocol implementation. AMQP is an emerging\nstandard for high-performance enterprise messaging.ejabberd is one of the most well know erlang application and the one I learnt erlang with.I think it\'s the one of most interesting project for learning erlang because it is really building on erlang\'s strength. (However some will argue that it\'s not OTP, but don\'t worry there\'s still a trove of great code inside...)Why ?An XMPP server (like ejabberd) can be seen as a high level router, routing messages between end users. Of course there are other features, but this is the most important aspect of an instant messaging server. It has to route many messages simultaneously, and handle many a lot of TCP/IP connections.So we have 2 features:These are examples where erlang shines.handle many connectionsIt is very easy to build scalable non-blocking TCP/IP servers with erlang. In fact, it was designed to solve this problem.\nAnd given it can spawn hundreds of thousand of processes (and not threads, it\'s a share-nothing approach, which is simpler to design), ejabberd is designed as a set of erlang processes (which can be distributed over several servers) :All of them exchanging messages.route messages given some aspects of the messageAnother very lovable feature of erlang is pattern matching.\nIt is used throughout the language.For instance, in the following :That\'s 5 different versions of the access function.\nErlang will select the most appropriate version given the arguments received. (Config is a structure of type #config which has a type attribute).That means it is very easy and much clearer than chaining if/else or switch/case to make business rules.To wrap upWriting scalable servers, that\'s the whole point of erlang. Everything is designed it making this easy. On the two previous features, I\'d add :Fewer LOCsThere is also this article from Richard Jones. He rewrote an application from C++ to erlang: 75% fewer lines in erlang.The list of most common applications for Erlang as been covered (CouchDb, ejabberd, RabbitMQ etc) but I would like to contribute the following.The reason why it is used in these applications comes from the core strength of Erlang: managing application availability.Erlang was built from ground up for the telco environment requiring that systems meet at least 5x9\'s availability (99.999% yearly up-time).  This figure doesn\'t leave much room for downtime during a year! For this reason primarily, Erlang comes loaded with the following features (non-exhaustive):Horizontal scalability (ability to distribute jobs across machine boundaries easily through seamless intra & inter machine communications). The built-in database (Mnesia) is also distributed by nature.Vertical scalability (ability to distribute jobs across processing resources on the same machine): SMP is handled natively. Code Hot-Swapping: the ability to update/upgrade code live during operationsAsynchronous: the real world is async so Erlang was built to account for this basic nature. One feature that contributes to this requirement: Erlang\'s "free" processes (>32000 can run concurrently).Supervision: many different strategies for process supervision with restart strategies, thresholds etc. Helps recover from corner-cases/overloading more easily whilst still maintaining traces of the problems for later trouble-shooting, post-mortem analysis etc.Resource Management: scheduling strategies, resource monitoring etc.  Note that the default process scheduler operates with O(1) scaling.Live debugging: the ability to "log" into live nodes at will helps trouble-shooting activities. Debugging can be undertaken live with full access to any process\' running state. Also the built-in error reporting tools are very useful (but sometimes somewhat awkward to use).Of course I could talk about its functional roots but this aspect is somewhat orthogonal to the main goal (high availability).  The main component of the functional nature which contributes generously to the target goal is, IMO: "share nothing". This characteristic helps contain "side effects" and reduce the need for costly synchronization mechanisms.I guess all these characteristics help extending a case for using Erlang in business critical applications.One thing Erlang isn\'t really good at: processing big blocks of data.Erlang comes from Ericsson, and is used within some of their telecoms systems. Outside telecoms, CouchDb (a document-oriented database) is possibly the best known Erlang application so far.Why Erlang ? From the overview (worth reading in full):The document, view, security and\n  replication models, the special\n  purpose query language, the efficient\n  and robust disk layout and the\n  concurrent and reliable nature of the\n  Erlang platform are all carefully\n  integrated for a reliable and\n  efficient system.We built a betting exchange (aka prediction market) using Erlang.  We chose Erlang over some of the more traditional financial languages (C++, Java etc) because of the built-in concurrency.  Markets function very similarly to telephony exchanges.  Our CTO gave a talk on our use of Erlang at CTO talk.We also use CouchDB and RabbitMQ as part of our stack.Apparently, Yahoo used Erlang to make something it calls Harvester. Article about it here: http://www.ddj.com/architect/220600332I came across this is in the process of writing up a report: Erlang in Acoustic Ray Tracing. It\'s an experience report on a research group\'s attempt to use Erlang for Acoustic Ray Tracing. They found that while it was easier to write the program, less buggy, etc. It scaled worse, and performed 10x slower than a comparable C program. So one spot where it may not be well suited is CPU intensive scenarios.Do note though, that the people wrote the paper were in the stages of first learning Erlang, and may not have known the proper development procedures for CPU intensive Erlang.  What is erlang good for?http://beebole.com/en/blog/erlang/why-erlang/http://www.aquabu.com/2008/2/15/erlang-pragmatic-studio-day-3-noteshttp://www.reddit.com/r/programming/comments/9q0lr/erlang_and_highfrequency_trading/\n(jerf\'s answer)It\'s important to realize that Erlang\'s 4 parts: the language itself, the VMs(BEAM, hipe) standard libs (plus modules on github, CEAN, etc.) and development environment are being steadily updated / expanded/improved.  For example, i remember reading that the floating point performance improved when Wings3d\'s author realized it needed to improve (I can\'t find a source for this). And this guy just wrote about it:http://marian-dan.com/wordpress/?p=324A couple years ago, Tim Bray\'s Wide Finder publicity and all the folks starting to do web app frameworks and HTTP servers lead (at least in part) to improved regex and binaries handling. And there\'s all the work integrating HiPE and SMP, the dialyzer project, multiple unit testing and build libs springing up, ..So its sweet spot is expanding,  The difficult thing is that the official docs can\'t keep up very well, and the mailing list and erlang blogosphere volume are growing quickly  We are using Erlang to provide the back-end muscle power for our really real-time browser-based multi-player game Pixza. We don\'t use Flash or any other third-party plugins, though the game is real-time multi-player. We use pure JS and COMET techniques instead. And Erlang supports the "really realtimeliness" of Pixza.I\'m working for wooga, a social game company and we use Erlang for some of our game backends (basically http apis for millions of daily users) and auxiliary services like ios push notification provider, payment etc.I think it really shines in network related tasks and it makes it kind of straight forward to structure and implement simple and complex network services alike in it. Distribution, fault tolerance and performance are easy to achieve because Erlang already has some of the key ingredients built in and they are being used for a long time in critical production infrastructure. So its not like "the new hip technology thing 0.0.2 alpha".I know that other game companies use Erlang as well. You should be able to find presentations on slideshare about that.Erlang draws its strength from being a functional language with no shared memory. Hence IMO, Erlang won\'t be suitable for applications that require in place memory manipulations. Image editing for example.