The problem I\'m having is that the dragleave event of an element is fired when hovering a child element of that element. Also, dragenter is not fired when hovering back the parent element again.I made a simplified fiddle: http://jsfiddle.net/pimvdb/HU6Mk/1/.HTML:with the following JavaScript:What it is supposed to do is notifying the user by making the drop div red when dragging something there. This works, but if you drag into the p child, the dragleave is fired and the div isn\'t red anymore. Moving back to the drop div also doesn\'t make it red again. It\'s necessary to move completely out of the drop div and drag back into it again to make it red.Is it possible to prevent dragleave from firing when dragging into a child element?2017 Update:  TL;DR, Look up CSS pointer-events: none; as described in @H.D.\'s answer below that works in modern browsers and IE11.You just need to keep a reference counter, increment it when you get a dragenter, decrement when you get a dragleave.  When the counter is at 0 - remove the class.Note: In the drop event, reset counter to zero, and clear the added class.You can run it hereHere, the simplest Cross-Browser solution (seriously):jsfiddle <-- try dragging some file inside the boxYou can do something like that:In a few words, you create a "mask" inside the dropzone, with width & height inherited, position absolute, that will just show when the dragover starts.\nSo, after showing that mask, you can do the trick by attaching the others dragleave & drop events on it.After leaving or dropping, you just hide the mask again. \nSimple and without complications.(Obs.: Greg Pettit advice -- You must be sure that the mask hover the entire box, including the border)Is it possible to prevent dragleave from firing when dragging into a child element?Yes.That CSS seem to be enough for Chrome.While using it with Firefox, the #drop shouldn\'t have text nodes directly (else there\'s a strange issue where a element "leave it to itself"), so I suggest to leave it with only one element (e.g., use a div inside #drop to put everything inside)Here\'s a jsfiddle solving the original question (broken) example.I\'ve also made a simplified version forked from the @Theodore Brown example, but based only in this CSS.Not all browsers have this CSS implemented, though:\nhttp://caniuse.com/pointer-eventsSeeing the Facebook source code I could find this pointer-events: none; several times, however it\'s probably used together with graceful degradation fallbacks. At least it\'s so simple and solves the problem for a lot of environments.The "right" way to solve this issue is to disable pointer events on child elements of the drop target (as in @H.D.\'s answer). Here\'s a jsFiddle I created which demonstrates this technique. Unfortunately, this doesn\'t work in versions of Internet Explorer prior to IE11, since they didn\'t support pointer events.Luckily, I was able to come up with a workaround which does work in old versions of IE. Basically, it involves identifying and ignoring dragleave events which occur when dragging over child elements. Because the dragenter event is fired on child nodes before the dragleave event on the parent, separate event listeners can be added to each child node which add or remove an "ignore-drag-leave" class from the drop target. Then the drop target\'s dragleave event listener can simply ignore calls which occur when this class exists. Here\'s a jsFiddle demonstrating this workaround. It is tested and working in Chrome, Firefox, and IE8+.Update:I created a jsFiddle demonstrating a combined solution using feature detection, where pointer events are used if supported (currently Chrome, Firefox, and IE11), and the browser falls back to adding events to child nodes if pointer event support isn\'t available (IE8-10).It has been quite some time after this question is asked and a lot of solutions (including ugly hacks) are provided. I managed to fix the same problem I had recently thanks to the answer in this answer and thought it may be helpful to someone who comes through to this page.\nThe whole idea is to store the evenet.target in ondrageenter everytime it is called on any of the parent or child elements. Then in ondragleave check if the current target (event.target) is equal to the object you stored in ondragenter.The only case these two are matched is when your drag is leaving the browser window.The reason that this works fine is when the mouse leaves an element (say el1) and enters another element (say el2), first the el1.ondragenter is called and then el2.ondragleave. Only when the drag is leaving/entering the browser window, event.target will be \'\' in both el1.ondragenter  and el2.ondragleave.Here is my working sample. I have tested it on IE9+, Chrome, Firefox and Safari.And here is a simple html page:With proper styling what I have done is to make the inner div (#file-drop-area) much bigger whenever a file is dragged into the screen so that the user can easily drop the files into the proper place.The problem is that the dragleave event is being fired when the mouse goes in front of the child element.I\'ve tried various methods of checking to see if the e.target element is the same as the this element, but couldn\'t get any improvement.The way I fixed this problem was a bit of a hack, but works 100%.You can fix it in Firefox with a little inspiration from the jQuery source code:Unfortunately it doesn\'t work in Chrome because relatedTarget appears not to exist on dragleave events, and I assume you\'re working in Chrome because your example did\'t work in Firefox.  Here\'s a version with the above code implemented.And here it goes, a solution for Chrome:Not sure if this cross browser, but I tested in Chrome and it solves my problem:I want to drag and drop a file over entire page, but my dragleave is fired when i drag over child element.  My fix was to look at the x and y of mouse:i have a div that overlays my entire page, when the page loads i hide it.when you drag over document i show it, and when you drop on the parent it handles it, and when you leave the parent i check x and y.I\'ve written a little library called Dragster to handle this exact issue, works everywhere except silently doing nothing in IE (which doesn\'t support DOM Event Constructors, but it\'d be pretty easy to write something similar using jQuery\'s custom events)I was having the same issue and tried to use pk7s solution. It worked but it could be done a little bit better without any extra dom elements.Basicly the idea is same - add an extra unvisible overlay over droppable area. Only lets do this without any extra dom elements. Here is the part were CSS pseudo-elements come to play.This after rule will create a fully covered overlay for droppable area.Here is the full solution: http://jsfiddle.net/F6GDq/8/I hope it helps anyone with the same problem.Here\'s another solution using document.elementFromPoint:Hope this works, here\'s a fiddle.I\'ve stumbled into the same problem and here\'s my solution - which I think is much easier then above. I\'m not sure if it\'s crossbrowser (might depend on even bubbling order)I\'ll use jQuery for simplicity, but solution should be framework independent.The event bubbles to parent either way so given:We attach eventsAnd that\'s about it. :) it works because even though onEnter on child fires before onLeave on parent, we delay it slightly reversing the order, so class is removed first then reaplied after a milisecond.A very simple solution is to use the pointer-events CSS property. Just set its value to none upon dragstart on every child element. These elements won\'t trigger mouse-related events anymore, so they won\'t catch the mouse over them and thus won\'t trigger the dragleave on the parent. Don\'t forget to set this property back to auto when finishing the drag ;)An alternate working solution, a little simpler.After spending so many hours I got that suggestion working exactly as intended. I wanted to provide a cue only when files were dragged over, and document dragover, dragleave was causing painful flickers on Chrome browser.This is how I solved it, also throwing in proper cues for user.I wrote a drag-and-drop module called drip-drop that fixes this weirdo behavior, among others. If you\'re looking for a good low-level drag-and-drop module you can use as the basis for anything (file upload, in-app drag-and-drop, dragging from or to external sources), you should check this module out:https://github.com/fresheneesz/drip-dropThis is how you would do what you\'re trying to do in drip-drop:To do this without a library, the counter technique is what I used in drip-drop, tho the highest rated answer misses important steps that will cause things to break for everything except the first drop. Here\'s how to do it properly:I had a similar problem \xe2\x80\x94 my code for hiding the dropzone on dragleave event for body was fired contatantly when hovering child elements making the dropzone flicker in Google Chrome.I was able to solve this by scheduling the function for hiding dropzone instead of calling it right away. Then, if another dragover or dragleave is fired, the scheduled function call is cancelled.Just check if the dragged over element is a child, if it is, then don\'t remove your \'dragover\' style class. Pretty simple and works for me:   Here is another approach based on the timing of events.The dragenter event dispatched from the child element can be captured by the parent element and it always occurs before the dragleave. The timing between these two events is really short, shorter than any possible human mouse action. So, the idea is to memorize the time when a dragenter happens and filter dragleave events that occurs "not too quickly" after ...This short example works on Chrome and Firefox:pimvdb..Why don\'t you try out using drop instead of dragleave. It worked for me. hope this solves your problem. Please check the jsFiddle : http://jsfiddle.net/HU6Mk/118/You can use a timeout with a transitioning flag and listen on the top element.  dragenter / dragleave from child events will bubble up to the container.Since dragenter on the child element fires before dragleave of the container, we will set the flag show as transitioning for 1ms... the dragleave listener will check for the flag before the 1ms is up.The flag will be true only during transitions to child elements, and will not be true when transitioning to a parent element (of the container)jsfiddle: http://jsfiddle.net/ilovett/U7mJj/You need to remove the pointer events for all child objects of the drag target.use this code http://jsfiddle.net/HU6Mk/258/:Just try to use the event.eventPhase. It will set to 2 (Event.AT_TARGET) only if the target ist entered, otherwise it is set to 3 (Event.BUBBLING_PHASE).I\'fe used the eventPhase to bind or unbind the dragleave Event.Guidoif you are using HTML5, you can get the parent\'s clientRect:Then in the parent.dragleave():here is a jsfiddle