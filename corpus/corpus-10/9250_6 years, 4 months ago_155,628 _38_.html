I ran a git pull that ended in a conflict. I resolved the conflict  and everything is fine now (I used mergetool also).When I commit the resolved file with git commit file.php -m "message" I get the error:I had the same issue before and using -a in commit worked perfectly. I think it\'s not the perfect way because I don\'t want to commit all changes. I want to commit files separately with separate comments. How can I do that? Why doesn\'t git allow users to commit files separately after a merge? I could not find a satisfactory answer to this problem.I found that adding "-i" to the commit command fixes this problem for me. The -i basically tells it to stage additional files before committing.\nThat is:This worked for me. You can try this also.You can use git commit -i for most cases but in case  it doesn\'t work You need to do git commit -m "your_merge_message". During a merge conflict you cannot merge one single file so you need to You probably got a conflict in something that you haven\'t staged for commit.  git won\'t let you commit things independently (because it\'s all part of the merge, I guess), so you need to git add that file and then git commit -m "Merge conflict resolution".  The -i flag for git commit does the add for you.I got this when I forgot the -m in my git commit when resolving a git merge conflict.should be Your merge stopped in the middle of the action.\nYou should add your files, and then \'git commit\':\ngit add file_1.php file_2.php file_3.php\ngit commitCheersAs the error message says you cannot do a partial commit after a merge. Instead of committing just file.php you should commit all the changes. This should work.If you just want to ditch the whole cherry-picking and commit files in whatever sets you want, gets you there.What soft reset does is it moves the pointer pointing to current HEAD to the commit(ish) you gave but does not alter the files. Hard reset would move the pointer and also revert all files to the state in that commit(ish). This means with soft reset you can clear the merge status but keep the changes to actual files and then commit or reset them each individually per your liking.During a merge Git wants to keep track of the parent branches for all sorts of reasons.  What you want to do is not a merge as git sees it.  You will likely want to do a rebase or cherry-pick manually.For myself this happened in SourceTree when I tried to commit a merge before resolving all of the files. I then marked the last file resolved and yet it still gave me this error when trying to commit. I closed SourceTree and reopened it, and then it committed fine.git commit -i -m \'merge message\' didn\'t work for me. It said:fatal: No paths with --include/--only does not make sense.FWIW, I got here via this related question because I was getting this message:fatal: You have not concluded your merge (MERGE_HEAD exists).I also tried mergetool, which said No files need merging. Very confusing! So the MERGE_HEAD is not in a file that needs merging-??Finally, I used this trick to add only the modified files (did not want to add all the files in my tree, since I have some I want to keep untracked): git ls-files -m | xargs git addThen I was finally (!) able to commit and push up. It sure would be nice if git gave you better hints about what to do in these situations. I solved this with a completely different approach, using only Xcode\'s Source Control.Background: Another team Pushed changes to the remote Git repository (via Beanstalk). On my end, the .xcodeproj files came in under different directory, and the changes didn\'t take. Later, when I tried to commit, I received a Tree Conflict error in Xcode.Being nearly impossible to correct using Xcode, I replaced the .xcodeproj file with a downloaded version from the Git server. The result... the Xcode project appeared to clear up, however all the updates from the corrupt Pull were showing up as changes I made and were Staged for a Commit. However when trying to Commit, I received the same "fatal: cannot do a partial commit during a merge" error, discussed here.Here\'s how I solved the problem... (Now, understand that I\'m a rookie programmer, so I could lack some understanding... but my ignorance led me to find another way to do this.) First, I Cloned my master Branch into a secondary Branch and switched to that branch. Then I created a Working Copy and placed the directory to that working copy outside of the original project directory. (I don\'t know if this was necessary, but its what I did as I read other troubleshooting techniques.) Then I switched branches to the master, where I realized all my Staged files (changes to Commit) were gone. To make sure all the files were updated to the latest changes made by the other party, I created a new branch called ThirdBranch, which duplicated all files, Pushed it to the Git Server and let Beanstalk compare my server version of the master branch to the ThirdBrach branch I just Pushed (line by line), and all the changes by the other party were present on my Xcode. This meant that my master repository and the Git master repository were the same, which verifies that I solved the problem using Xcode, only.Don\'t ask me how, beyond what I just described... and certainly fill in the gaps I left out. I\'m new at this and I don\'t understand everything. Maybe an experienced programmer can separate the irrelevant info from the relevant and recreate this technique more clearly, which is in part why I\'m posting this.This is a duplicate answer to duplicate question as at: Failed Xcode Git Merge is stuckIf it is in Source Tree, we should explicitly mark a file as resolved after the conflicts are resolved. Select file that was just resolved to no conflicts. Then Actions -> Resolve Conflicts -> Mark Resolved. If you have multiple files, do the same for all. Commit now.