In my production error logs I occasionally see:SQLSTATE[HY000]: General error: 1205\n  Lock wait timeout exceeded; try\n  restarting transactionI know which query is trying to access the database at that moment but is there a way to find out which query had the lock at that precise moment?What gives this away is the word transaction. It is evident by the statement that the  query was attempting to change at least one row in one or more InnoDB tables.Since you know the query, all the tables being accessed are candidates for being the culprit.From there, you should be able to run SHOW ENGINE INNODB STATUS\\GYou should be able to see the affected table(s)You get all kinds of additional Locking and Mutex Information.Here is a sample from one of my clients:You should consider increasing the lock wait timeout value for InnoDB by setting the innodb_lock_wait_timeout, default is 50 secYou can set it to higher value in /etc/my.cnf permanently with this lineand restart mysql. If you cannot restart mysql at this time, run this:You could also just set it for the duration of your sessionfollowed by your queryAs someone mentioned in one of the many SO threads concerning this problem: Sometimes the process that has locked the table shows up as sleeping in the processlist! I was tearing my hair out until I killed all the sleeping threads that were open in the database in question (none were active at the time). That finally unlocked the table and let the update query run. The commenter said something akin to "Sometimes a MySQL thread locks a table, then sleeps while it waits for something non-MySQL-related to happen."After re-re-reviewing the show engine innodb status log (once I\'d tracked down the client responsible for the lock), I noticed the stuck thread in question was listed at the very bottom of the transaction list, beneath the active queries that were about to error out because of the frozen lock:(unsure if the "Trx read view" message is related to the frozen lock, but unlike the other active transactions, this one does not show up with the query that was issued and instead claims the transaction is "cleaning up," yet has multiple row locks)The moral of the story is that a transaction can be active even though the thread is sleeping.Due do the MySQL popularity, there\'s no wonder Lock wait timeout exceeded; try restarting transaction exception gets so much attention on SO.The more contention you have, the greater the chance of deadlocks, which a DB engine will resolve by time-outing one of the deadlocked transactions. Also, long-running transactions that have modified (e.g. UPDATE or DELETE) a large number of entries (which take locks to avoid dirty-write anomalies as explained in the High-Performance Java Persistence book) are more likely to generate conflicts with other transactions.Although InnoDB MVCC, you can still request explicit locks using the FOR UPDATE clause. However, unlike other popular DBs (Oracle, MSSQL, PostgreSQL, DB2), MySQL uses REPEATABLE_READ as the default isolation level. Now, the locks that you acquired (either by modifying rows or using explicit locking), are held for the duration of the currently running transaction. If you want a good explanation of the difference between REPEATABLE_READ and READ COMMITTED in regards to locking, please read this Percona article.In REPEATABLE READ every lock acquired during a transaction is held\n  for the duration of the transaction.In READ COMMITTED the locks that did not match the scan are released after the STATEMENT completes....This means that in READ COMMITTED other transactions are free to update rows that they would not have been able to update (in REPEATABLE READ) once the UPDATE statement completes.This more restrictive the isolation level (REPEATABLE_READ, SERIALIZABLE) the greater the chance of deadlock. This is not an issue "per se", it\'s a trade-off.You can get very good results with READ_COMMITED, as you need application-level lost update prevention when using logical transactions that span over multiple HTTP requests. The optimistic locking approach targets lost updates that might happen even if you use the SERIALIZABLE isolation level while reducing the lock contention by allowing you to use READ_COMMITED.For the record, the lock wait timeout exception happens also when there is a deadlock and MySQL cannot detect it, so it just times out. Another reason might be an extremely long running query, which is easier to solve/repair, however, and I will not describe this case here.MySQL is usually able to deal with deadlocks if they are constructed "properly" within two transactions. MySQL then just kills/rollback the one transaction that owns fewer locks (is less important as it will impact less rows) and lets the other one finish.Now, let\'s suppose there are two processes A and B and 3 transactions:This is a very unfortunate setup because MySQL cannot see there is a deadlock (spanned within 3 transactions). So what MySQL does is ... nothing! It just waits, since it does not know what to do. It waits until the first acquired lock exceeds the timeout (Process A Transaction 1: Locks X), then this will unblock the Lock X, which unlocks Transaction 2 etc.The art is to find out what (which query) causes the first lock (Lock X). You will be able to see easily (show engine innodb status) that Transaction 3 waits for Transaction 2, but you will not see which transaction Transaction 2 is waiting for (Transaction 1). MySQL will not print any locks or query associated with Transaction 1. The only hint will be that at the very bottom of the transaction list (of the show engine innodb status printout), you will see Transaction 1 apparently doing nothing (but in fact waiting for Transaction 3 to finish).The technique for how to find which SQL query causes the lock (Lock X) to be granted for a given transaction that is waiting is described here Tracking MySQL query history in long running transactionsIf you are wondering what the process and the transaction is exactly in the example. The process is a PHP process. Transaction is a transaction as defined by innodb-trx-table. In my case, I had two PHP processes, in each I started a transaction manually. The interesting part was that even though I started one transaction in a process, MySQL used internally in fact two separate transactions (I don\'t have a clue why, maybe some MySQL dev can explain). MySQL is managing its own transactions internally and decided (in my case) to use two transactions to handle all the SQL requests coming from the PHP process (Process A). The statement that Transaction 1 is waiting for Transaction 3 to finish is an internal MySQL thing. MySQL "knew" the Transaction 1 and Transaction 3 were actually instantiated as part of one "transaction" request (from Process A). Now the whole "transaction" was blocked because Transaction 3 (a subpart of "transaction") was blocked. Because "transaction" was not able to finish the Transaction 1 (also a subpart of the "transaction") was marked as not finished as well. This is what I meant by "Transaction 1 waits for Transaction 3 to finish".Take a look at the man page of the pt-deadlock-logger utility:It extracts information from the engine innodb status mentioned above and also \nit can be used to create a daemon which runs every 30 seconds.The big problem with this exception is that its usually not reproducible in a test environment and we are not around to run innodb engine status when it happens on prod. So in one of the projects I put the below code into a catch block for this exception. That helped me catch the engine status when the exception happened. That helped a lot.Extrapolating from Rolando\'s answer above, it is these that are blocking your query:If you need to execute your query and can not wait for the others to run, kill them off using the MySQL thread id:(from within mysql, not the shell, obviously)You have to find the thread IDs from the:command, and figure out which one is the one that is blocking the database.You can use:which will list all the connections in MySQL and the current state of connection as well as the query being executed. There\'s also a shorter variant show processlist; which displays the truncated query as well as the connection stats.Activate MySQL general.log (disk intensive) and use mysql_analyse_general_log.pl to extract long running transactions, for example with :--min-duration=your innodb_lock_wait_timeout valueDisable general.log after that.