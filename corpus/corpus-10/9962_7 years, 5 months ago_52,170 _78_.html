I\'m trying my hardest to wrap my head around JavaScript closures.I get that by returning an inner function, it will have access to any variable defined in its immediate parent.Where would this be useful to me? Perhaps I haven\'t quite got my head around it yet. Most of the examples I have seen online don\'t provide any real world code, just vague examples.Can someone show me a real world use of a closure?Is this one, for example?I\'ve used closures to do things like:As you can see there, a is now an object, with a method publicfunction ( a.publicfunction() ) which calls privatefunction, which only exists inside the closure.  You can NOT call privatefunction directly (i.e. a.privatefunction() ), just publicfunction().Its a minimal example but maybe you can see uses to it? We used this to enforce public/private methods.The example you give is an excellent one. Closures are an abstraction mechanism that allow you to separate concerns very cleanly. Your example is a case of separating instrumentation (counting calls) from semantics (an error-reporting API). Other uses include:Passing parameterised behaviour into an algorithm (classic higher-order programming):Simulating object oriented programming:Implementing exotic flow control, such as jQuery\'s Event handling and AJAX APIs.Yes, that is a good example of a useful closure. The call to warnUser creates the calledCount variable in its scope and returns an anonymous function which is stored in the warnForTamper variable.  Because there is still a closure making use of the calledCount variable, it isn\'t deleted upon the function\'s exit, so each call to the warnForTamper() will increase the scoped variable and alert the value.The most common issue I see on StackOverflow is where someone wants to "delay" use of a variable that is increased upon each loop, but because the variable is scoped then each reference to the variable would be after the loop has ended, resulting in the end state of the variable:This would result in every alert showing the same value of i, the value it was increased to when the loop ended.  The solution is to create a new closure, a separate scope for the variable.  This can be done using an instantly executed anonymous function, which receives the variable and stores its state as an argument:In the JavaScript (or any ECMAScript) language, in particular, closures are useful in hiding the implementation of functionality while still revealing the interface.For example, imagine you are writing a class of date utility methods and you want to allow users to lookup weekday names by index but you don\'t want them to be able to modify the array of names you use under the hood.Note that the days array could simply be stored as a property of the dateUtil object but then it would be visible to users of the script and they could even change it if they wanted, without even needing your source code.  However, since it\'s enclosed by the anonymous function which returns the date lookup function it is only accessible by the lookup function so it is now tamper-proof.Suppose, you want to count the number of times user clicked a button on a webpage.\nFor this, you are triggering a function on  onclick event of button to update the count of the variable 1) You could use a global variable, and a function to increase the counter:But, the pitfall is that any script on the page can change the counter, without calling updateClickCount().  2) Now, You might be thinking of declaring the variable inside the function:But, Hey! Every time updateClickCount() function is called, the counter is set to 1 again.3) Thinking about Nested functions?     Nested functions have access to the scope "above" them.\nIn this example, the inner function updateClickCount() has access to the counter variable in the parent function countWrapper()This could have solved the counter dilemma, if you could reach the updateClickCount() function from the outside and you also need to find a way to execute counter = 0 only once not everytime.4) Closure to the rescue! (self-invoking function):  The self-invoking function only runs once. It sets the counter to zero (0), and returns a function expression.This way updateClickCount becomes a function. The "wonderful" part is that it can access the counter in the parent scope.This is called a JavaScript closure. It makes it possible for a function to have "private" variables.The counter is protected by the scope of the anonymous function, and can only be changed using the add function!More lively example on Closure: There is a section on Practical Closures at the Mozilla Developer Network.Another common use for closures is to bind this in a method to a specific object, allowing it to be called elsewhere (such as as an event handler).Whenever a mousemove event fires, watcher.follow(evt) is called.Closures are also an essential part of higher-order functions, allowing the very common pattern of rewriting multiple similar functions as a single higher order function by parameterizing the dissimilar portions. As an abstract example,becomeswhere A and B aren\'t syntactical units but source code strings (not string literals).See "Streamlining my javascript with a function" for a concrete example.Here, I have a greeting that I want to say several times. If I create a closure, I can simply call that function to record the greeting. If I don\'t create the closure, I have to pass my name in every single time.Without a closure (https://jsfiddle.net/lukeschlangen/pw61qrow/3/):With a closure (https://jsfiddle.net/lukeschlangen/Lb5cfve9/3/):If you\'re comfortable with the concept of instantiating a class in the object-oriented sense (i.e. to create an object of that class) then you\'re close to understanding closures. Think of it this way: when you instantiate two Person objects you know that the class member variable "Name" is not shared between instances; each object has its own \'copy\'. Similarly, when you create a closure, the free variable (\'calledCount\' in your example above) is bound to the \'instance\' of the function. I think your conceptual leap is slightly hampered by the fact that every function/closure returned by the warnUser function (aside: that\'s a higher-order function) closure binds \'calledCount\' with the same initial value (0), whereas often when creating closures it is more useful to pass different initializers into the higher-order function, much like passing different values to the constructor of a class.So, suppose when \'calledCount\' reaches a certain value you want to end the user\'s session; you might want different values for that depending on whether the request comes in from the local network or the big bad internet (yes, it\'s a contrived example). To achieve this, you could pass different initial values for calledCount into warnUser (i.e. -3, or 0?).Part of the problem with the literature is the nomenclature used to describe them ("lexical scope", "free variables"). Don\'t let it fool you, closures are more simple than would appear... prima facie ;-)I like Mozilla\'s function factory example.I wrote an article a while back about how closures can be used to simplify event-handling code. It compares ASP.NET event handling to client-side jQuery.http://www.hackification.com/2009/02/20/closures-simplify-event-handling-code/JavaScript module pattern uses closures. Its nice pattern allowes you to have something alike "public" and "private" vars. Another great example would be a converter class:EXPLAINED:\nWhen you declare a local variable...that variable...has a scope.  Meaning, it lives within the "lexical" scope it is declared-in.Now...Notice the variable OFFSET - it has it\'s own scope.  Now notice the RETURN, it too has its\' own scope - which is the returned scope & is completely separate from OFFSETS scope.  And yet...somehow...the value of OFFSET is still available to the returned scope (for use).  How?That is what a CLOSURE does: it closes-over the original scope & encapsulates it (like an envelope).  When you see a function that returns a separate function (or a separate result that not declared in the original scope) a separate scope is created...and and such...that scope CLOSES-OVER the original scope.Hence....a closure.  Get it?Use of Closures :Closures are one of the most powerful features of JavaScript. JavaScript allows for the nesting of functions and grants the inner function full access to all the variables and functions defined inside the outer function (and all other variables and functions that the outer function has access to). However, the outer function does not have access to the variables and functions defined inside the inner function. This provides a sort of security for the variables of the inner function. Also, since the inner function has access to the scope of the outer function, the variables and functions defined in the outer function will live longer than the outer function itself, if the inner function manages to survive beyond the life of the outer function. A closure is created when the inner function is somehow made available to any scope outside the outer function.Example :In the code above, the name variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner function act as safe stores for the inner functions. They hold "persistent", yet secure, data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.\nread here for detailReference: Practical usage of closuresIn practice closures may create elegant designs, allowing customization of various calculations, deferred calls, callbacks, creating encapsulated scope etc.An example the sort method of arrays which accepts as an argument the sort-condition function:Mapping functionals as the map method of arrays which maps a new array by the condition of the functional argument:Often it is convenient to implement search functions with using functional arguments defining almost unlimited conditions for search:Also, we may note applying functionals as, for example, a forEach method which applies a function to an array of elements:A function is applied to arguments (to a list of arguments \xe2\x80\x94 in apply, and to positioned arguments \xe2\x80\x94 in call):Deferred calls: Callback functions:Creation of an encapsulated scope for the purpose of hiding auxiliary objects:Much of the code we write in front-end JavaScript is event-based \xe2\x80\x94 we define some behavior, then attach it to an event that is triggered by the user (such as a click or a keypress). Our code is generally attached as a callback: a single function which is executed in response to the event.\n  size12, size14, and size16 are now functions which will resize the body text to 12, 14, and 16 pixels, respectively. We can attach them to buttons (in this case links) as follows:FiddleClosures are a useful way to create generators, a sequence incremented on-demand:The differences are summarized as follows:References