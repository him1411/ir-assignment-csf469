As someone that\'s new to Objective-C can someone give me an overview of the retain, assign, copy and any others I\'m missing, that follow the @property directive? What are they doing and why would I want to use one over another?The article linked to by MrMage is no longer working. So, here is what I\'ve learned in my (very) short time coding in Objective-C:nonatomic vs. atomic\n- "atomic" is the default. Always use "nonatomic". I don\'t know why, but the book I read said there is "rarely a reason" to use "atomic". (BTW: The book I read is the BNR "iOS Programming" book.)readwrite vs. readonly\n- "readwrite" is the default. When you @synthesize, both a getter and a setter will be created for you. If you use "readonly", no setter will be created. Use it for a value you don\'t want to ever change after the instantiation of the object.retain vs. copy vs. assignBefore you know about the attributes of @property, you should know what is the use of @property.@property offers a way to define the information that a class is intended to encapsulate.\nIf you declare an object/variable using @property, then that object/variable will be accessible to other classes importing its class. If you declare an object using @property in the header file, then you have to synthesize it using @synthesize in the implementation file. This makes the object KVC compliant. By default, compiler will synthesize accessor methods for this object.accessor methods are : setter and getter.Example:\n.h.mNow the compiler will synthesize accessor methods for name.List of attributes of @propertyatomic, nonatomic, retain, copy, readonly, readwrite, assign, strong, getter=method, setter=method, unsafe_unretainedatomic is the default behavior. If an object is declared as atomic then it becomes thread-safe. Thread-safe means, at a time only one thread of a particular instance of that class can have the control over that object. If the thread is performing getter method then other thread cannot perform setter method on that object. It is slow.For this reason, it\xe2\x80\x99s faster to access a nonatomic property than an atomic one.     The setter method will increase retain count of the object, so that it will occupy memory in autorelease pool.Even if a mutable string is set and subsequently changed, the instance captures whatever value it has at the time it is set. No setter and getter methods will be synthesized.now,name will remain unaffected. Compiler will generate a getter, but not a setter.It is opposite of readonly.Keep in mind retain and assign are basically interchangeable when garbage collection is enabled.It comes with ARC.In the case of Boolean properties (properties that have a YES or NO value), it\xe2\x80\x99s customary for the getter method to start with the word \xe2\x80\x9cis\xe2\x80\x9dThe method should end with a colon.An unsafe reference is similar to a weak reference in that it doesn\xe2\x80\x99t keep its related object alive, but it won\xe2\x80\x99t be set to nil if the destination object is deallocated.If you need to specify multiple attributes, simply include them as a comma-separated list, like this:After reading many articles I decided to put all the attributes information together:Below is a link to the detailed article where you can find these attributes.Many thanks to all the people who give best answers here!!Variable property attributes or Modifiers in iOSHere is the Sample Description from ArticleExample :Example:Explain:Suppose there is an atomic string property called "name", and if you call [self setName:@"A"] from thread A, \ncall [self setName:@"B"] from thread B, and call [self name] from thread C, then all operation on different thread will be performed serially which means if one thread is executing setter or getter, then other threads will wait. This makes property "name" read/write safe but if another thread D calls [name release] simultaneously then this operation might produce a crash because there is no setter/getter call involved here. Which means an object is read/write safe (ATOMIC) but not thread safe as another threads can simultaneously send any type of messages to the object. Developer should ensure thread safety for such objects.If the property "name" was nonatomic, then all threads in above example - A,B, C and D will execute simultaneously producing any unpredictable result. In case of atomic, Either one of A, B or C will execute first but D can still execute in parallel.Example:Example :Strong & Weak Explanation, Thanks to BJ Homer:Imagine our object is a dog, and that the dog wants to run away (be deallocated).\nStrong pointers are like a leash on the dog. As long as you have the leash attached to the dog, the dog will not run away. If five people attach their leash to one dog, (five strong pointers to one object), then the dog will not run away until all five leashes are detached.\nWeak pointers, on the other hand, are like little kids pointing at the dog and saying "Look! A dog!" As long as the dog is still on the leash, the little kids can still see the dog, and they\'ll still point to it. As soon as all the leashes are detached, though, the dog runs away no matter how many little kids are pointing to it.\nAs soon as the last strong pointer (leash) no longer points to an object, the object will be deallocated, and all weak pointers will be zeroed out.\nWhen we use weak?\nThe only time you would want to use weak, is if you wanted to avoid retain cycles \n(e.g. the parent retains the child and the child retains the parent so neither is ever released).Example:Example:unsafe_unretained-unsafe_unretained is an ownership qualifier that tells ARC how to insert retain/release calls\n-unsafe_unretained is the ARC version of assign.Example:Example:Atomic property can be accessed by only one thread at a time. It is thread safe. Default is atomic .Please note that there is no keyword  atomicNonatomic means multiple thread can access the item .It is thread unsafeSo one should be very careful while using atomic .As it affect the performance of your code 