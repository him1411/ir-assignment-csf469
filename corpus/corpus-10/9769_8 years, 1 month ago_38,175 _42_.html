During a code review with a Microsoft employee we came across a large section of code inside a try{} block. She and an IT representative suggested this can have effects on performance of the code. In fact, they suggested most of the code should be outside of try/catch blocks, and that only important sections should be checked. The Microsoft employee added and said an upcoming white paper warns against incorrect try/catch blocks.  I\'ve looked around and found it can affect optimizations, but it seems to only apply when a variable is shared between scopes.I\'m not asking about maintainability of the code, or even handling the right exceptions (the code in question needs re-factoring, no doubt). I\'m also not referring to using exceptions for flow control, this is clearly wrong in most cases. Those are important issues (some are more important), but not the focus here.How do try/catch blocks affect performance when exceptions are not thrown?EDIT: I\'m adding a bounty. There are interesting responses, but I would like to get some more input.Check it.Output:In milliseconds:New code:New results:After seeing all the stats for with try/catch and without try/catch, curiosity forced me to look behind to see what is generated for both the cases. Here is the code:C#: MSIL:C#:MSIL:I\'m not an expert in IL but we can see that an local exception object is created on fourth line .locals init ([0] class [mscorlib]System.Exception ex) after that things are pretty same as for method without try/catch till the line seventeen IL_0021:  leave.s    IL_002f. If an exception occurs the control jumps to line IL_0025:  ldloc.0 otherwise we jump to label IL_002d:  leave.s    IL_002f and function returns.I can safely assume that if no exceptions occur then it is the overhead of creating local variables to hold exception objects only and a jump instruction.No. If the trivial optimizations a try/finally block precludes actually have a measurable impact on your program, you probably should not be using .NET in the first place.Quite comprehensive explanation of the .NET exception model.Rico Mariani\'s Performance Tidbits: Exception Cost: When to throw and when not toThe first kind of cost is the static\n  cost of having exception handling in\n  your code at all.  Managed exceptions\n  actually do comparatively well here,\n  by which I mean the static cost can be\n  much lower than say in C++.  Why is\n  this?  Well, static cost is really\n  incurred in two kinds of places:\n  First, the actual sites of\n  try/finally/catch/throw where there\'s\n  code for those constructs. Second, in\n  unmanged code, there\'s the stealth\n  cost associated with keeping track of\n  all the objects that must be\n  destructed in the event that an\n  exception is thrown.  There\'s a\n  considerable amount of cleanup logic\n  that must be present and the sneaky\n  part is that even code that doesn\'t\n  itself throw or catch or otherwise\n  have any overt use of exceptions still\n  bears the burden of knowing how to\n  clean up after itself.Dmitriy Zaslavskiy:As per Chris Brumme\'s note: There is\n  also a cost related to the fact the\n  some optimization are not being\n  performed by JIT in the presence of\n  catchThe structure is different in the example from Ben M. It will be extended overhead inside the inner for loop that will cause it to not be good comparison between the two cases.The following is more accurate for comparison where the entire code to check (including variable declaration) is inside the Try/Catch block:When I ran the original test code from Ben M, I noticed a difference both in Debug and Releas configuration.This version, I noticed a difference in the debug version (actually more than the other version), but it was no difference in the Release version. Conclution:\nBased on these test, I think we can say that Try/Catch does have a small impact on performance.EDIT:\nI tried to increase the loop value from 10000000 to 1000000000, and ran again in Release to get some differences in the release, and the result was this:You see that the result is inconsequent. In some cases the version using Try/Catch is actually faster!I tested the actual impact of a try..catch in a tight loop, and it\'s too small by itself to be a performance concern in any normal situation.If the loop does very little work (in my test I did an x++), you can measure the impact of the exception handling. The loop with exception handling took about ten times longer to run.If the loop does some actual work (in my test I called the Int32.Parse method), the exception handling has too little impact to be measurable. I got a much bigger difference by swapping the order of the loops...try catch blocks have a negligible impact on performance but exception Throwing can be pretty sizable, this is probably where your coworker was confused. The try/catch HAS impact on the performance. But its not a huge impact. try/catch complexity is generally O(1), just like a simple assignment, except when they are placed in a loop. So you have to use them wisely.Here is a reference about try/catch performance (doesn\'t explain the complexity of it though, but it is implied). Take a look at Throw Fewer Exceptions sectionSee discussion on try/catch implementation for a discussion of how try/catch blocks work, and how some implementations have high overhead, and some have zero overhead,\nwhen no exceptions occur.   In particular, I think the Windows 32 bit implementation has high overhead, and the 64 bit implementation does not.In theory, a try/catch block will have no effect on code behavior unless an exception actually occurs.  There are some rare circumstances, however, where the existence of a try/catch block may have a major effect, and some uncommon-but-hardly-obscure ones where the effect can be noticeable.  The reason for this is that given code like:the compiler may be able to optimize statement1 based upon the fact that statement2 is guaranteed to execute before statement3.  If the compiler can recognize that thing1 has no side-effects and thing2 doesn\'t actually use x, it may safely omit thing1 altogether.  If [as in this case] thing1 was expensive, that could be a major optimization, though the cases where thing1 is expensive are also those the compiler would be least likely to optimize out.  Suppose the code were changed:Now there exists a sequence of events where statement3 could execute without statement2 having executed.  Even if nothing in the code for thing2 could throw an exception, it would be possible that another thread could use an Interlocked.CompareExchange to notice that q was cleared and set it to Thread.ResetAbort, and then perform a Thread.Abort() before statement2 wrote its value to x.  Then the catch would execute Thread.ResetAbort() [via delegate q], allowing execution to continue with statement3.  Such a sequence of events would of course be exceptionally improbable, but a compiler is required to generate code which work according to specification even when such improbable events occur.In general, the compiler is much more likely to notice opportunities to leave out simple bits of code than complex ones, and thus it would be rare for a try/catch could affect performance much if exceptions are never thrown.  Still, there are some situations where the existence of a try/catch block may prevent optimizations which--but for the try/catch--would have allowed code to run faster.