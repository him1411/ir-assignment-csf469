The reason for interfaces truly eludes me. From what I understand, it is kind of a work around for the non-existent multi-inheritance which doesn\'t exist in C# (or so I was told).All I see is, you predefine some members and functions, which then have to be re-defined in the class again. Thus making the interface redundant. It just feels like syntactic... well, junk to me (Please no offense meant. Junk as in useless stuff).In the example given below taken from a different C# interfaces thread on stack overflow, I would just create a base class called Pizza instead of an interface.easy example (taken from a different stack overflow contribution)The point is that the interface represents a contract. A set of public methods any implementing class has to have. Technically, the interface only governs syntax, i.e. what methods are there,  what arguments they get and what they return. Usually they encapsulate semantics as well, although that only by documentation.You can then have different implementations of an interface and swap them out at will. In your example, since every pizza instance is an IPizza you can use IPizza wherever you handle an instance of an unknown pizza type. Any instance whose type inherits from IPizza is guaranteed to be orderable, as it has an Order() method.Python is not statically-typed, therefore types are kept and looked up at runtime. So you can try calling an Order() method on any object. The runtime is happy as long as the object has such a method and probably just shrugs and says \xc2\xbbMeh.\xc2\xab if it doesn\'t. Not so in C#. The compiler is responsible for making the correct calls and if it just has some random object the compiler doesn\'t know yet whether the instance during runtime will have that method. From the compiler\'s point of view it\'s invalid since it cannot verify it. (You can do such things with reflection or the dynamic keyword, but that\'s going a bit far right now, I guess.)Also note that an interface in the usual sense does not necessarily have to be a C# interface, it could be an abstract class as well or even a normal class (which can come in handy if all subclasses need to share some common code \xe2\x80\x93 in most cases, however, interface suffices).No one has really explained in plain terms how interfaces are useful, so I\'m going to give it a shot (and steal an idea from Shamim\'s answer a bit).  Lets take the idea of a pizza ordering service.  You can have multiple types of pizzas and a common action for each pizza is preparing the order in the system.  Each pizza has to be prepared but each pizza is prepared differently.  For example, when a stuffed crust pizza is ordered the system probably has to verify certain ingredients are available at the restaurant and set those aside that aren\'t needed for deep dish pizzas.When writing this in code, technically you could just doHowever, deep dish pizzas (in C# terms) may require different properties to be set in the Prepare() method than stuffed crust, and thus you end up with a lot of optional properties, and the class doesn\'t scale well (what if you add new pizza types).The proper way to solve this is to use interface.  The interface declares that all Pizzas can be prepared, but each pizza can be prepared differently.  So if you have the following interfaces:Now your order handling code does not need to know exactly what types of pizzas were ordered in order to handle the ingredients.  It just has:Even though each type of pizza is prepared differently, this part of the code doesn\'t have to care what type of pizza we are dealing with, it just knows that it\'s being called for pizzas and therefore each call to Prepare will automatically prepare each pizza correctly based on its type, even if the collection has multiple types of pizzas.For me, the point to these only became clear when you stop looking at them as things to make your code easier/faster to write - this is not their purpose. They have a number of uses:(This is going to lose the pizza analogy, as it\'s not very easy to visualise a use of this)Say you are making a simple game on screen and It will have creatures with which you interact.A: They can make your code easier to maintain in the future by introducing a loose coupling between your front end and your back end implementation.  You could write this to start with, as there are only going to be trolls:Front end:Two weeks down the line, marketing decide you also need Orcs, as they read about them on twitter, so you would have to do something like:Front end:And you can see how this starts to get messy.  You could use an interface here so that your front end would be written once and (here\'s the important bit) tested, and you can then plug in further back end items as required:Front end is then:The front end now only cares about the interface ICreature - it\'s not bothered about the internal implementation of a troll or an orc, but only on the fact that they implement ICreature.An important point to note when looking at this from this point of view is that you could also easily have used an abstract creature class, and from this perspective, this has the same effect. And you could extract the creation out to a factory:And our front end would then become:The front end now does not even have to have a reference to the library where Troll and Orc are implemented (providing the factory is in a separate library) - it need know nothing about them whatsoever.B: Say you have functionality that only some creatures will have in your otherwise homogenous data structure, e.g.Front end could then be:C: Usage for dependency injectionMost dependency injection frameworks are easier to work with when there is a very loose coupling between the front end code and the back end implementation.  If we take our factory example above and have our factory implement an interface:Our front end could then have this injected (e.g an MVC API controller) through the constructor (typically):With our DI framework (e.g. Ninject or Autofac), we can set them up so that at runtime a instance of CreatureFactory will be created whenever an ICreatureFactory is needed in an constructor - this makes our code nice and simple. It also means that when we write a unit test for our controller, we can provide a mocked ICreatureFactory (e.g. if the concrete implementation required DB access, we don\'t want our unit tests dependent on that) and easily test the code in our controller.D: There are other uses e.g. you have two projects A and B that for \'legacy\' reasons are not well structured, and A has a reference to B.  You then find functionality in B that needs to call a method already in A. You can\'t do it using concrete implementations as you get a circular reference.You can have an interface declared in B that the class in A then implements. Your method in B can be passed an instance of a class that implements the interface with no problem, even though the concrete object is of a type in A.Here are your examples reexplained:Examples above don\'t make much sense. You could accomplish all above examples using classes (abstract class if you want it to behave only as a contract):You get the same behavior as with interface. You can create a List<Food> and iterate that w/o knowing what class sits on top.More adequate example would be multiple inheritance:Then you can use all of them as MenuItem and don\'t care about how they handle each method call.In the absence of duck typing as you can use it in Python, C# relies on interfaces to provide abstractions. If the dependencies of a class were all concrete types, you could not pass in any other type - using interfaces you can pass in any type that implements the interface.The Pizza example is bad because you should be using an abstract class that handles the ordering, and the pizzas should just override the pizza type, for example.You use interfaces when you have a shared property, but your classes inherit from different places, or when you don\'t have any common code you could use. For instance, this is used things that can be disposed IDisposable, you know it will be disposed, you just don\'t know what will happen when it\'s disposed.An interface is just a contract that tells you some things an object can do, what parameters and what return types to expect.Consider the case where you don\'t control or own the base classes.Take visual controls for instance, in .NET for Winforms they all inherit from the base class Control, that is completely defined in the .NET framework.Let\'s assume you\'re in the business of creating custom controls. You want to build new buttons, textboxes, listviews, grids, whatnot and you\'d like them all to have certain features unique to your set of controls.For instance you might want a common way to handle theming, or a common way to handle localization.In this case you can\'t "just create a base class" because if you do that, you have to reimplement everything that relates to controls.Instead you will descend from Button, TextBox, ListView, GridView, etc. and add your code.But this poses a problem, how can you now identify which controls are "yours", how can you build some code that says "for all the controls on the form that are mine, set the theme to X".Enter interfaces.Interfaces are a way to look at an object, to determine that the object adheres to a certain contract.You would create "YourButton", descend from Button, and add support for all the interfaces you need.This would allow you to write code like the following:This would not be possible without interfaces, instead you would have to write code like this:In this case, you could ( and probably would ) just define a Pizza base class and inherit from them. However, there are two reasons where Interfaces allow you to do things that cannot be achieved in other ways:A class can implement multiple interfaces. It just defines features that the class must have. Implementing a range of interfaces means that a class can fulfil multiple functions in different places.An interface can be defined in a hogher scope than the class or the caller. This means that you can separate the functionality, separate the project dependency, and keep the functionality in one project or class, and the implementation of this elsewhere.One implication of 2 is that you can change the class that is being used, just requiring that it implements the appropriate interface.Consider you can\'t use multiple inheritance in C#, and then look at your question again. An interface is really a contract that the implementing classes must follow, it is in fact the base for pretty much every design pattern I know.In your example, the interface is created because then anything that IS A Pizza, which means implements the Pizza interface, is guaranteed to have implemented After your mentioned code you could have something like this:This way you are using polymorphism and all you care is that your objects respond to order().If I am working on an API to draw shapes, I may want to use DirectX or graphic calls, or OpenGL.  So, I will create an interface, which will abstract my implementation from what you call.So you call a factory method: MyInterface i = MyGraphics.getInstance().  Then, you have a contract, so you know what functions you can expect in MyInterface.  So, you can call i.drawRectangle or i.drawCube and know that if you swap one library out for another, that the functions are supported.This becomes more important if you are using Dependency Injection, as then you can, in an XML file, swap implementations out.So, you may have one crypto library that can be exported that is for general use, and another that is for sale only to American companies, and the difference is in that you change a config file, and the rest of the program isn\'t changed.This is used a great deal with collections in .NET, as you should just use, for example, List variables, and don\'t worry whether it was an ArrayList or LinkedList.As long as you code to the interface then the developer can change the actual implementation and the rest of the program is left unchanged.This is also useful when unit testing, as you can mock out entire interfaces, so, I don\'t have to go to a database, but to a mocked out implementation that just returns static data, so I can test my method without worrying if the database is down for maintenance or not.So I\'m a foreperson on a construction site.Tradies walk on the site all the time. I don\'t know who\'s going to walk through those doors. But I basically tell them what to do.The problem with the above approach is that I have to: (i) know who\'s walking in that door, and depending on who it is, I have to tell them what to do. That means I have to know everything about a particular trade. I\'d rather not know everything about plumbing. That\'s the plumber\'s job! That\'s what he/she is paid to do!Imagine a scenario where, no matter who walks in the door, I can say: "Work()" and they do the respect jobs that they specialise in:  the plumber would deal with pipes, and the electrician would deal with wires.The benefit of this approach is that: (i) I don\'t need to know exactly who is walking in through that door - all i need to know is that they will be a type of tradie and that they can do work, and secondly, (ii) i don\'t need to know anything about that particular trade. The tradie will take care of that.So instead of this:I can do something like this:An interface allows you to get the person to do the work they are assigned to, without you have the knowledge of exactly who they are or the specifics of what they can do.Hope this helps.Interface = contract, used for loose coupling (see GRASP). Interfaces are for applying connection between different classes. for example, you have a class for car and a tree;you want to add a burnable functionality for both classes. But each class have their own ways to burn. so you simply make;You will get interfaces, when you will need them :) You can study examples, but you need the Aha! effect to really get them.Now that you know what interfaces are, just code without them. Sooner or later you will run into a problem, where the use of interfaces will be the most natural thing to do.I\'m surprised that not many posts contain the one most important reason for an interface: Design Patterns. It\'s the bigger picture into using contracts, and although it\'s a syntax decoration to machine code (to be honest, the compiler probably just ignores them), abstraction and interfaces are pivotal for OOP, human understanding, and complex system architectures.Let\'s expand the pizza analogy to say a full fledge 3 course meal. We\'ll still have the core Prepare() interface for all our food categories, but we\'d also have abstract declarations for course selections (starter, main, dessert), and differing properties for food types (savoury/sweet, vegetarian/non-vegetarian, gluten free etc).Based on these specifications, we could implement the Abstract Factory pattern to conceptualise the whole process, but use interfaces to ensure that only the foundations were concrete. Everything else could become flexible or encourage polymorphism, yet maintain encapsulation between the different classes of Course that implement the ICourse interface. If I had more time, I\'d like to draw up a full example of this, or someone can extend this for me, but in summary, a C# interface would be the best tool in designing this type of system.Here\'s an interface for objects that have a rectangular shape:All it demands is that you implement ways to access the width and height of the object.Now let\'s define a method that will work on any object that is IRectangular:That will return the area of any rectangular object.Let\'s implement a class SwimmingPool that is rectangular:And another class House that is also rectangular:Given that, you can call the Area method on houses or swimming-pools:In this way, your classes can "inherit" behavior (static-methods) from any number of interfaces.I did a search for the word "composition" on this page and didn\'t see it once.  This answer is very much in addition to the answers aforementioned.One of the absolutely crucial reasons for using interfaces in an Object Oriented Project is that they allow you to favour composition over inheritance.  By implementing interfaces you can decouple your implementations from the various algorithms you are applying to them.This superb "Decorator Pattern" tutorial by Derek Banas (which - funnily enough - also uses pizza as an example) is a worthwhile illustration:https://www.youtube.com/watch?v=j40kRwSm4VEAn interface defines a contract between the provider of a certain functionality and the correspondig consumers. It decouples the implementation from the contract (interface). You should have a look at object oriented architecture and design. You may want to start with wikipedia: http://en.wikipedia.org/wiki/Interface_(computing)The main purpose of the interfaces is that it makes a contract between you and any other class that implement that interface which makes your code decoupled and allows expandability. Therese are ask really great examples.Another, in the case of a switch statement, you no longer have the need to maintain and switch every time you want rio perform a task in a specific way. In your pizza example, if want to make a pizza, the interface is all you need, from there each pizza takes care of it\'s own logic.  This helps to reduce coupling and cyclomatic complexity. You have to still implement the logic but there will be less you have to keep track of in the broader picture. For each pizza you can then keep track of information specific to that pizza. What other pizzas have doesn\'t matter because only the other pizzas need to know.The simplest way to think about interfaces is to recognize what inheritance means.  If class CC inherits class C, it means both that:Those two function of inheritance are in some sense independent; although inheritance applies both simultaneously, it is also possible to apply the second without the first.  This is useful because allowing an object to inherit members from two or more unrelated classes is much more complicated than allowing one type of thing to be substitutable for multiple types.An interface is somewhat like an abstract base class, but with a key difference: an object which inherits a base class cannot inherit any other class.  By contrast, an object may implement an interface without affecting its ability to inherit any desired class or implement any other interfaces.One nice feature of this (underutilized in the .net framework, IMHO) is that they make it possible to indicate declaratively the things an object can do.  Some objects, for example, will want data-source object from which they can retrieve things by index (as is possible with a List), but they won\'t need to store anything there.  Other routines will need a data-depository object where they can store things not by index (as with Collection.Add), but they won\'t need to read anything back.  Some data types will allow access by index, but won\'t allow writing; others will allow writing, but won\'t allow access by index.  Some, of course, will allow both.If ReadableByIndex and Appendable were unrelated base classes, it would be impossible to define a type which could be passed both to things expecting a ReadableByIndex and things expecting an Appendable.  One could try to mitigate this by having ReadableByIndex or Appendable derive from the other; the derived class would have to make available public members for both purposes, but warn that some public members might not actually work.  Some of Microsoft\'s classes and interfaces do that, but that\'s rather icky.  A cleaner approach is to have interfaces for the different purposes, and then have objects implement interfaces for the things they can actually do.  If one had an interface IReadableByIndex and another interface IAppendable, classes which could do one or the other could implement the appropriate interfaces for the things they can do.Interfaces can also be daisy chained to create yet another interface. This ability to implement multiple Interfaces give the developer the advantage of adding functionality to their classes without having to change current class functionality (SOLID Principles) O = "Classes should be open for extension but closed for modification"There are a lot of good answers here but I would like to try from a slightlt different perspective.You may be familiar with the SOLID principles of object oriented design. In summary:S - Single Responsibility Principle\nO - Open/Closed Principle\nL - Liskov Substitution Principle\nI - Interface Segregation Principle\nD - Dependency Inversion PrincipleFollowing the SOLID principles helps to produce code that is clean, well factored, cohesive and loosely coupled. Given that:"Dependency management is the key challenge in software at every scale" (Donald Knuth)then anything that helps with dependency management is a big win. Interfaces and the Dependency Inversion Principle really help to decouple code from dependencies on concrete classes, so code can be written and reasoned about in terms of behaviours rather than implementations. This helps to break the code into components which can be composed at runtime rather than compile time and also means those components can be quite easily plugged in and out without having to alter the rest of the code.Interfaces help in particular with the Dependency Inversion Principle, where code can be componentized into a collection of services, with each service being described by an interface. Services can then be "injected" into classes at runtime by passing them in as a constructor parameter. This technique really becomes critical if you start to write unit tests and use test driven development. Try it! You will quickly understand how interfaces help to break apart the code into manageable chunks that can be individually tested in isolation.Am I correct then to take another look at Interfaces,  The graphical interface (winforms / WPF) is like the Interface.  It displays only what the end user will interact with.  The end user will then not have to know what went into the design of the application, but would know what they can do with it, based on available options on the form.  In OOP view then the idea is to create a structured interface that informs other users of your e.g DLL libraries what is available to use and that it\'s like an guarantee/contract that the field, methods and properties will be available to use (inherit in your classes).   I share your sense that Interfaces are not necessary. Here is a quote from Cwalina pg 80 Framework Design Guidelines "I often here people saying that interfaces specify contracts. I believe this a dangerous myth. Interfaces by themselves do not specify much. ..." He and co-author Abrams managed 3 releases of .Net for Microsoft. He goes on to say that the \'contract\' is "expressed" in an implementation of the class. IMHO watching this for decades, there were many people warning Microsoft that taking the engineering paradigm to the max in OLE/COM might seem good but its usefulness is more directly to hardware. Especially in a big way in the 80s and 90s getting interoperating standards codified. In our TCP/IP Internet world there is little appreciation of the hardware and software gymnastics we would jump through to get solutions \'wired up\' between and among mainframes, minicomputers, and microprocessors of which PCs were just a small minority. So coding to interfaces and their protocols made computing work. And interfaces ruled. But what does solving making X.25 work with your application have in common with posting recipes for the holidays? I have been coding C++ and C# for many years and I never created one once.