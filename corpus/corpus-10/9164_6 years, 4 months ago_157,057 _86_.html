Update: Again thanks for the examples, they have been very helpful and with the following I don\'t mean \nto take anything away from them.Aren\'t the currently given examples, as far as I understand them & state-machines, only half of what we usually understand by a state-machine?\nIn the sense that the examples do change state but that\'s only represented by changing the value of a variable (and allowing different value- changes in different states), while usually a state machine should also change it\'s behavior, and behavior not (only) in the sense of allowing different value changes for a variable depending on state, but in the sense of allowing different methods to be executed for different states.Or do I have a misconception of state machines and their common use?Best regardsOriginal question: I found this discussion about state machines & iterator blocks in c# and tools to create state machines and what not for C#, so I found a lot of abstract stuff but as a noob all of this is a little confusing.So it would be great if someone could provide a C# source code-example that realizes a simple state machine with perhaps 3,4 states, just to get the gist of it.Let\'s start with this simple state diagram:We have:You can convert this to C# in a handful of ways, such as performing a switch statement on the current state and command, or looking up transitions in a transition table. For this simple state machine, I prefer a transition table, which is very easy to represent using a Dictionary:As a matter of personal preference, I like to design my state machines with a GetNext function to return the next state deterministically, and a MoveNext function to mutate the state machine.You might want to use one of the existing open source Finite State Machines. E.g. bbv.Common.StateMachine found at http://code.google.com/p/bbvcommon/wiki/StateMachine. It has a very intuitive fluent syntax and a lot of features such as, enter/exit actions, transition actions, guards, hierarchical, passive implementation (executed on the thread of the caller) and active implementation (own thread on which the fsm runs, events are added to a queue).Taking Juliets example the definition for the state machine gets very easy:Update: The project location has moved to: https://github.com/appccelerate/statemachineHeres an example of a very clasic finite state machine, modelling a very simplified electronic device (like a TV)Some shameless self-promo here, but a while ago I created a library called YieldMachine which allows a limited-complexity state machine to be described in a very clean and simple way. For example, consider a lamp:Notice that this state machine has 2 triggers and 3 states. In YieldMachine code, we write a single method for all state-related behavior, in which we commit the horrible atrocity of using goto for each state. A trigger becomes a property or field of type Action, decorated with an attribute called Trigger. I\'ve commented the code of the first state and its transitions below; the next states follow the same pattern.Short and nice, eh! This state machine is controlled simply by sending triggers to it:Just to clarify, I\'ve added some comments to the first state to help you understand how to use this.This works because the C# compiler actually created a state machine internally for each method that uses yield return. This construct is usually used to lazily create sequences of data, but in this case we\'re not actually interested in the returned sequence (which is all nulls anyway), but in the state behaviour that gets created under the hood. The StateMachine base class does some reflection on construction to assign code to each [Trigger] action, which sets the Trigger member and moves the state machine forward.But you don\'t really need to understand the internals to be able to use it.You can code an iterator block that lets you execute a code block in an orchestrated fashion. How the code block is broken up really doesn\'t have to correspond to anything, it\'s just how you want to code it. For example:In this case, when you call CountToTen, nothing actually executes, yet. What you get is effectively a state machine generator, for which you can create a new instance of the state machine. You do this by calling GetEnumerator(). The resulting IEnumerator is effectively a state machine that you can drive by calling MoveNext(...). Thus, in this example, the first time you call MoveNext(...) you will see "1" written to the console, and the next time you call MoveNext(...) you will see 2, 3, 4, and then 5, 6, 7 and then 8, and then 9, 10. As you can see, it\'s a useful mechanism for orchestrating how things should occur.It\'s useful to remember that state machines are an abstraction, and you don\'t need particular tools to create one, however tools can be useful.You can for example realise a state machine with functions:This machine would hunt for gulls and try to hit them with water balloons. If it misses it will try firing one until it hits (could do with some realistic expectations ;)), otherwise it will gloat in the console. It continues to hunt until it\'s out of gulls to harass.Each function corresponds to each state; the start and end (or accept) states are not shown. There are probably more states in there than modelled by the functions though. For example after firing the balloon the machine is really in another state than it was before it, but I decided this distinction was impractical to make.A common way is to use classes to represent states, and then connect them in different ways.Im posting annother answer here as this is state machines from a different perspective; very visual.My origianl answer is clasic imperitive code.  I think its quite visual as code goes becuase of the array which makes visualising the state machine simple.  The downside is you have to write all this.  Remos\'s answer aleviates the effort of writing the boiler-plate code but is far less visual.  There is the third alternative; really drawing the state machine.If you are using .NET and can target version 4 of the run time then you have the option of using workflow\'s state machine activities.  These in essence let you draw the state machine (much as in Juliet\'s diagram) and have the WF runtime execute it for you.See the MSDN article Building State Machines with Windows Workflow Foundation for more details, and this CodePlex site for the latest version.Thats the option I would always prefer when targeting .NET because its easy to see, change and explain to non programmers; pictures are worth a thousand words as they say!I haven\'t tried implementing a FSM in C# yet, but these all sound (or look) very complicated to the way I handled FSM\'s in the past in low-level languages like C or ASM.  I believe the method I\'ve always known is called something like an "Iterative Loop".  In it, you essentially have a \'while\' loop that periodically exits based on events (interrupts), then returns to the main loop again. Within the interrupt handlers, you would pass a CurrentState and return a NextState, which then overwrites the CurrentState variable in the main loop.  You do this ad infinitum until the program closes (or the microcontroller resets). What I\'m seeing other answers all look very complicated compared with how a FSM is, in my mind, intended to be implemented; its beauty lies in its simplicity and FSM can be very complicated with many, many states and transitions, but they allow complicated process to be easily broken down and digested. I realize my response shouldn\'t include another question, but I am forced to ask: why do these other proposed solutions appear to be so complicated?\nThey seem to be akin to hitting a small nail with a giant sledge hammer.What a bout StatePattern. Does that fit your needs?I think its context related, but its worth a shot for sure.http://en.wikipedia.org/wiki/State_patternThis let your states decide where to go and not the "object" class.BrunoToday i deep in State Design Pattern.\nI did and tested ThreadState, which equal (+/-) to Threading in C#, as described in picture from enter link description hereYou can easly add new states, configure moves from one state to other is very easy becouse it incapsulated in state implementationImplementation and using at: Implements .NET ThreadState by State Design PatternFound this great tutorial online and it helped me wrap my head around finite state machines.http://gamedevelopment.tutsplus.com/tutorials/finite-state-machines-theory-and-implementation--gamedev-11867The tutorial is language agnostic, so it can easily be adapted to your C# needs. Also, the example used (an ant looking for food) is easy to understand.\nFrom the tutorial:I\'ve just contributed this:https://code.google.com/p/ysharp/source/browse/#svn%2Ftrunk%2FStateMachinesPoCHere\'s one of the examples demoing direct and indirect sending of commands, with states as IObserver(of signal), thus responders to a signal source, IObservable(of signal):Note : this example is rather artificial and mostly meant to demo a number of orthogonal features. There should seldomly be a real need to implement the state value domain itself by a full blown class, using the CRTP ( see : http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern ) like this.Here\'s for a certainly simpler and likely much more common implementation use case (using a simple enum type as the states value domain), for the same state machine, and with the same test case :https://code.google.com/p/ysharp/source/browse/trunk/StateMachinesPoC/WatchingTVSample.cs\'HTHI think the state machine proposed by Juliet has a mistake: the method GetHashCode can return the same hash code for two different transitions, for example:State = Active (1) , Command = Pause (2) => HashCode = 17 + 31 + 62 =\n  110State = Paused (2) , Command = End (1) => HashCode = 17 + 62 + 31 =\n  110To avoid this error, the method should be like this:AlexFiniteStateMachine is a Simple State Machine, written in C# LinkAdvantages tu use my library FiniteStateMachine:Download DLL DownloadExample on LINQPad:I would recommend state.cs. I personally used state.js (the JavaScript version) and am very happy with it. That C# version works in a similar way. You instantiate states:You instantiate some transitions:You define actions on states and transitions:And that\'s (pretty much) it. Look at the website for more information.In my opinion a state machine is not only meant for changing states but also (very important) for handling triggers/events within a specific state. If you want to understand state machine design pattern better, a good description can be found within the book Head First Design Patterns, page 320.  It is not only about the states within variables but also about handling triggers within the different states. Great chapter (and no, there is no fee for me in mentioning this :-) which contains just an easy to understand explanation.There are 2 popular state machine packages in NuGet.Appccelerate.StateMachine (13.6K downloads + 3.82K of legacy version (bbv.Common.StateMachine))StateMachineToolkit (1.56K downloads)The Appccelerate lib has good documentation, but it does not support .NET 4, so I chose StateMachineToolkit for my project.