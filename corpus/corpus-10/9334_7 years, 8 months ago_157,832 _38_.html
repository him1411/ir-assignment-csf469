This question already has an answer here:I\'m migrating a piece of code to make use of generics. One argument for doing so is that the for loop is much cleaner than keeping track of indexes, or using an explicit iterator.In about half the cases, the list (an ArrayList) is being iterated in reverse order by using an index today.Can someone suggest a cleaner way of doing this (since I dislike the indexed for loop when working with collections), though it does work?Note: I can\'t add any new dependencies outside the JDK.Try this:Guava offers Lists#reverse(List) and ImmutableList#reverse(). As in most cases for Guava, the former delegates to the latter if the argument is an ImmutableList, so you can use the former in all cases.  These do not create new copies of the list but just "reversed views" of it.ExampleI don\'t think it\'s possible using the for loop syntax.  The only thing I can suggest is to do something like:... but I wouldn\'t say this is "cleaner" given that it\'s going to be less efficient.Option 1: Have you thought about reversing the List with Collections#reverse() and then using foreach?Of course, you may also want to refactor your code such that the list is ordered correctly so you don\'t have to reverse it, which uses extra space/time.EDIT:Option 2: Alternatively, could you use a Deque instead of an ArrayList?  It will allow you to iterate forwards and backwardsEDIT:Option 3: As others have suggested, you could write an Iterator that will go through the list in reverse, here is an example:Create a custom reverseIterable You could use the concrete class LinkedList instead of the general interface List. Then you have a descendingIterator for iterating with the reverse direction.Don\'t know why there is no descendingIterator with ArrayList...Here is an (untested) implementation of a ReverseIterable.  When iterator() is called it creates and returns a private ReverseIterator implementation, which simply maps calls to hasNext() to hasPrevious() and calls to next() are mapped to previous().  It means you could iterate over an ArrayList in reverse as follows:Class DefinitionIf the lists are fairly small so that performance is not a real issue, one can use the reverse-metod of the Lists-class in Google Guava. Yields pretty for-each-code, and the original list stays the same. Also, the reversed list is backed by the original list, so any change to the original list will be reflected in the reversed one.Yields the following result:Which means that reverse iteration of myList can be written as:Very simple Example:This is an old question, but it\'s lacking a java8-friendly answer. Here are some ways of reverse-iterating the list, with the help of the Streaming API:Also found google collections reverse method.To have code which looks like this:Put this code into a file called "In.java":You could use ReverseListIterator from Apache Commons-Collections:https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/iterators/ReverseListIterator.htmlAs has been suggested at least twice, you can use descendingIterator with a Deque, in particular with a LinkedList. If you want to use the for-each loop (i.e., have an Iterable), you can construct and use a wraper like this:Reason : "Don\'t know why there is no descendingIterator with ArrayList..."Since array list doesnot keep the list in the same order as data has been added to list. So, never use Arraylist .Linked list will keep the data in same order of ADD to list.So , above in my example, i used ArrayList() in order to make user to twist their mind and make them to workout something from their side.Instead of thisUSE: