How do I set environment variables from Java?  I see that I can do this for subprocesses using ProcessBuilder.  I have several subprocesses to start, though, so I\'d rather modify the current process\'s environment and let the subprocesses inherit it.There\'s a System.getenv(String) for getting a single environment variable.  I can also get a Map of the complete set of environment variables with System.getenv().  But calling put() on that Map throws an UnsupportedOperationException -- apparently they mean for the environment to be read only.  And there\'s no System.setenv().So, is there any way to set environment variables in the currently running process?  If so, how?  If not, what\'s the rationale?  (Is it because this is Java and therefore I shouldn\'t be doing evil nonportable obsolete things like touching my environment?)  And if not, any good suggestions for managing the environment variable changes that I\'m going to need to be feeding to several subprocesses?(Is it because this is Java and therefore I shouldn\'t be doing evil nonportable obsolete things like touching my environment?)I think you\'ve hit the nail on the head.A possible way to ease the burden would be to factor out a methodand pass any ProcessBuilders through it before starting them.Also, you probably already know this, but you can start more than one process with the same ProcessBuilder. So if your subprocesses are the same, you don\'t need to do this setup over and over.For use in scenarios where you need to set specific environment values for unit tests, you might find the following hack useful. It will change the environment variables throughout the JVM (so make sure you reset any changes after your test), but will not alter your system environment.I found that a combination of the two dirty hacks by Edward Campbell and anonymous works best, as one of the does not work under linux, one does not work under windows 7. So to get a multiplatform evil hack I combined them:This Works like a charm. Full credits to the two authors of these hacks.on Android the interface is exposed via Libcore.os as a kind of hidden API.The Libcore class as well as the interface OS is public. Just the class declaration is missing and need to be shown to the linker. No need to add the classes to the application, but it also does not hurt if it is included.It turns out that the solution from @pushy/@anonymous/@Edward Campbell does not work on Android because Android is not really Java.  Specifically, Android does not have java.lang.ProcessEnvironment at all.  But it turns out to be easier in Android, you just need to do a JNI call to POSIX setenv():In C/JNI:\nAnd in Java:Poking around online, it looks like it might be possible to do this with JNI.  You\'d then have to make a call to putenv() from C, and you\'d (presumably) have to do it in a way that worked on both Windows and UNIX.If all that can be done, it surely wouldn\'t be too hard for Java itself to support this instead of putting me in a straight jacket.A Perl-speaking friend elsewhere suggests that this is because environment variables are process global and Java is striving for good isolation for good design.This is a combination of @paul-blair \'s answer converted to Java which includes some cleanups pointed out by paul blair and some mistakes that seem to have been inside @pushy \'s code which is made up of @Edward Campbell and anonymous.I cannot emphasize how much this code should ONLY be used in testing and is extremely hacky. But for cases where you need the environment setup in tests it is exactly what I needed.This also includes some minor touches of mine that allow the code to work on both Windows running on as well as Centos running onThe implementation:Tried pushy\'s answer above and it worked for the most part. However, in certain circumstances, I would see this exception:This turns out to happen when the method was called more than once, owing to the implementation of certain inner classes of ProcessEnvironment. If the setEnv(..) method is called more than once, when the keys are retrieved from the theEnvironment map, they are now strings (having been put in as strings by the first invocation of setEnv(...) ) and cannot be cast to the map\'s generic type, Variable, which is a private inner class of ProcessEnvironment.A fixed version (in Scala), is below. Hopefully it isn\'t too difficult to carry over into Java.Setting single environment variables (based on answer by Edward Campbell):Usage:First, put the method in any class you want, e.g. SystemUtil.If you call System.getenv("SHELL") after this, you\'ll get "/bin/bash" back.Like most people who have found this thread, I was writing some unit tests and needed to modify the environment variables to set the correct conditions for the test to run.  However, I found the most upvoted answers had some issues and/or were very cryptic or overly complicated.  Hopefully this will help others to sort out the solution more quickly.First off, I finally found @Hubert Grzeskowiak\'s solution to be the simplest and it worked for me.  I wish I would have come to that one first.  It\'s based on @Edward Campbell\'s answer, but without the complicating for loop search.However, I started with @pushy\'s solution, which got the most upvotes. It is a combo of @anonymous and @Edward Campbell\'s.  @pushy claims both approaches are needed to cover both Linux and Windows environments.  I\'m running under OS X and find that both work (once an issue with @anonymous approach is fixed).  As others have noted, this solution works most of the time, but not all.I think the source of most of the confusion comes from @anonymous\'s solution operating on the \'theEnvironment\' field.  Looking at the definition of the ProcessEnvironment structure, \'theEnvironment\' is not a Map< String, String > but rather it is a Map< Variable, Value >.  Clearing the map works fine, but the putAll operation rebuilds the map a Map< String, String >, which potentially causes problems when subsequent operations operate on the data structure using the normal API that expects Map< Variable, Value >.  Also, accessing/removing individual elements is a problem.  The solution is to access \'theEnvironment\' indirectly through \'theUnmodifiableEnvironment\'.  But since this is a type UnmodifiableMap the access must be done through the private variable \'m\' of the UnmodifiableMap type.  See getModifiableEnvironmentMap2 in code below.In my case I needed to remove some of the environment variables for my test (the others should be unchanged).  Then I wanted to restore the environment variables to their prior state after the test.  The routines below make that straight forward to do.  I tested both versions of getModifiableEnvironmentMap on OS X, and both work equivalently.  Though based on comments in this thread, one may be a better choice than the other depending on the environment.Note: I did not include access to the \'theCaseInsensitiveEnvironmentField\' since that seems to be Windows specific and I had no way to test it, but adding it should be straight forward.You can pass parameters into your initial java process with -D: