One of the things that get me thoroughly confused is the use of session.Flush,in conjunction with session.Commit, and session.Close.Sometimes session.Close works, e.g., it commits all the changes that I need. I know I need to use commit when I have a transaction, or a unit of work with several creates/updates/deletes, so that I can choose to rollback if an error occurs.But sometimes I really get stymied by the logic behind session.Flush. I have seen examples where you have a session.SaveOrUpdate() followed by a flush, but when I remove Flush it works fine anyway. Sometimes I run into errors on the Flush statement saying that the session timed out, and removing it made sure that I didn\'t run into that error.Does anyone have a good guideline as to where or when to use a Flush? I\'ve checked out the NHibernate documentation for this, but I still can\'t find a straightforward answer.Briefly:From the documentation:From time to time the ISession will execute the SQL statements needed to synchronize the ADO.NET connection\'s state with the state of objects held in memory. This process, flush, occurs by default at the following pointsThe SQL statements are issued in the following order(An exception is that objects using native ID generation are inserted when they are saved.)Except when you explicity Flush(), there are absolutely no guarantees about when the Session executes the ADO.NET calls, only the order in which they are executed. However, NHibernate does guarantee that the ISession.Find(..) methods will never return stale data; nor will they return the wrong data.It is possible to change the default behavior so that flush occurs less frequently. The FlushMode class defines three different modes: only flush at commit time (and only when the NHibernate ITransaction API is used), flush automatically using the explained routine, or never flush unless Flush() is called explicitly. The last mode is useful for long running units of work, where an ISession is kept open and disconnected for a long time....Also refer to this section:Ending a session involves four distinct phases:If you happen to be using the ITransaction API, you don\'t need to worry about this step. It will be performed implicitly when the transaction is committed. Otherwise you should call ISession.Flush() to ensure that all changes are synchronized with the database.If you are using the NHibernate ITransaction API, this looks like:If you are managing ADO.NET transactions yourself you should manually Commit() the ADO.NET transaction.If you decide not to commit your changes:or:If you rollback the transaction you should immediately close and discard the current session to ensure that NHibernate\'s internal state is consistent.A call to ISession.Close() marks the end of a session. The main implication of Close() is that the ADO.NET connection will be relinquished by the session.If you provided your own connection, Close() returns a reference to it, so you can manually close it or return it to the pool. Otherwise Close() returns it to the pool. Starting in NHibernate 2.0, transactions are required for DB operations.  Therefore, the ITransaction.Commit() call will handle any necessary flushing.  If for some reason you aren\'t using NHibernate transactions, then there will be no auto-flushing of the session.Here are two examples of my code where it would fail without session.Flush():http://www.lucidcoding.blogspot.co.uk/2012/05/changing-type-of-entity-persistence.htmlat the end of this, you can see a section of code where I set identity insert on, save the entity then flush, then set identity insert off. Without this flush it seemed to be setting identity insert on and off then saving the entity. The use of Flush() gave me more control over what was going on.Here is another example:Sending NServiceBus message inside TransactionScopeI don\'t fully understand why on this one, but Flush() prevented my error from happening.From time to time the ISession will execute the SQL statements needed to synchronize the ADO.NET connection\'s state with the state of objects held in memory.And always use after the changes are committed than this changes to save into database we use  transaction.Commit();