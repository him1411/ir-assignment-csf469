In the example above xargs takes echo % as the command argument. But in some cases, I need multiple commands to process instead of one, for example:But xargs doesn\'t accept this form. One solution I know is that I can define a function to wrap the commands, but it\'s not pipeline, I don\'t prefer it. Is there other solution?Note that this is a Useless Use Of cat.  I\'d write it as:(Yes, the redirection can be at the beginning of the command.)Presumably command1 and/or command2 will contain one or more % characters; otherwise there wouldn\'t be much point to the -I % option to xargs.With GNU Parallel you can do:Watch the intro videos to learn more: https://www.youtube.com/playlist?list=PL284C9FF2488BC6D1+1 for Keith answer because it does what the OP wants. This is just another approach without xargs nor cat:One thing I do is to add to .bashrc/.profile this function:then you can do things likewhich is less verbose than xargs or -exec. You could also modify the function to insert the value from the read at an arbitrary location in the commands to each, if you needed that behavior also.You can use{} = variable for each line on the text fileAnother possible solution that works for me is something like -Note the \'bash\' at the end - I assume it is passed as argv[0] to bash. Without it in this syntax the first parameter to each command is lost. It may be any word.Example:A little late to the party. I use format below for compressing my directories with thousands of tiny files before migrating. If you don\'t need single quotes inside commands, it should work.With some modification, I\'m sure it will be useful for someone. Tested in Cygwin (babun)find . Find here\n-maxdepth 1 Don\'t go into child directories\n! -path . Exclude . / Current directory path\n-type d match only directories\n-print0 Separate output by null bytes \\0\n| xargs Pipe to xargs\n-0 Input is null separated bytes\n-I @@ Placeholder is @@. Replace @@ with input.\nbash -c \'...\' Run Bash command\n{...} Command grouping\n&& Execute next command only if previous command exited successfully (exit 0)  Final ; is important, otherwise it will fail.Output:My current BKM for this isIt is unfortunate that this uses perl, which is less likely to be installed than bash; but it handles more input that the accepted answer.   (I welcome a ubiquitous version that does not rely on perl.)@KeithThompson\'s suggestion of is great - unless you have the shell comment character # in your input, in which case part of the first command and all of the second command will be truncated.Hashes # can be quite common, if the input is derived from a filesystem listing, such as ls or find, and your editor creates temporary files with # in their name.Example of the problem:Oops, here is the problem:Ahh, that\'s better:I prefer style which allows dry run mode (without | sh) :Works with pipes too: