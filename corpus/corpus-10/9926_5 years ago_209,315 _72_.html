I\'ve been writing some batch files, and I ran into this user guide, which has been quite informative. One thing it showed me was that lines can be commented not just with REM, but also with ::. It says:Comments in batch code can be made by using a double-colon, this is better than using the REM command because labels are processed before redirection symbols. ::<remark> causes no problems but rem <remark> produces errors. Why then, do most guides and examples I see use the REM command? Does :: work on all versions of Windows?tl;dr: REM is the documented and supported way to embed comments in batch files.:: is essentially a blank label that can never be jumped to, whereas REM is an actual command that just does nothing. In neither case (at least on Windows 7) does the presence of redirection operators cause a problem.However, :: is known to misbehave in blocks under certain circumstances, being parsed not as a label but as some sort of drive letter. I\'m a little fuzzy on where exactly but that alone is enough to make me use REM exclusively. It\'s the documented and supported way to embed comments in batch files whereas :: is merely an artifact of a particular implementation.EDITHere is an example where :: produces a problem in a FOR loop.This example will not work in a file called test.bat on your desktop:While this example will work as a comment correctly:The problem appears to be when trying to redirect output into a file. My best guess is that it is interpreting :: as an escaped label called :echo.A REM can remark a complete line, also a multiline caret at the line end, if it\'s not the end of the first token.  REM followed by some characters .:\\/= works a bit different, it doesn\'t comment an ampersand, so you can use it as inline comment.But to avoid problems with existing files like REM, REM.bat or REM;.bat only a modified variant should be used.And for the character ; is also allowed one of ;,:\\/=REM is about 6 times slower than :: (tested on Win7SP1 with 100000 comment lines).\nFor a normal usage it\'s not important (58\xc2\xb5s versus 360\xc2\xb5s per comment line)A :: always executes a line end caret.Labels and also the comment label :: have a special logic in parenthesis blocks.\nThey span always two lines SO: goto command not working.\nSo they are not recommended for parenthesis blocks, as they are often the cause for syntax errors.With ECHO ON a REM line is shown, but not a line commented with ::Both can\'t really comment out the rest of the line, so a simple %~ will cause a syntax error.  But REM is able to stop the batch parser at an early phase, even before the special character phase is done.You can use &REM or &:: to add a comment to the end of command line.\nThis approach works because \'&\' introduces a new command on the same line.There exists a comment style with percent signs.  In reality these are variables but they are expanded to nothing.\nBut the advantage is that they can be placed in the same line, even without &.\nThe equal sign ensures, that such a variable can\'t exists.  The percent style is recommended for batch macros, as it doesn\'t change the runtime behaviour, as the comment will be removed when the macro is defined.After I realized that I could use label :: to make comments and comment out code REM just looked plain ugly to me. As has been mentioned the double-colon can cause problems when used inside () blocked code, but I\'ve discovered a work-around by alternating between the labels :: and :spaceIt\'s not ugly like REM, and actually adds a little style to your code.So outside of code blocks I use :: and inside them I alternate between :: and :.By the way, for large hunks of comments, like in the header of your batch file, you can avoid special commands and characters completely by simply gotoing over your comments.  This let\'s you use any method or style of markup you want, despite that fact that if CMD ever actually tried to processes those lines it\'d throw a hissy.Use what ever notation you wish *\'s, @\'s etc.Another alternative is to express the comment as a variable expansion that always expands to nothing.Variable names cannot contain =, except for undocumented dynamic variables like %=ExitCode% and %=C:%. No variable name can ever contain an = after the 1st position. So I sometimes use the following to include comments within a parenthesized block:It is also a good method for incorporating in-line commentsThe leading = is not necessary, but I like if for the symmetry.There are two restrictions: 1) the comment cannot contain %2) the comment cannot contain :This page tell that using "::" will be faster under certain constraints\nJust a thing to consider when choosingThis answer attempts a pragmatic summary of the many great answers on this page:jeb\'s great answer deserves special mention, because it really goes in-depth and covers many edge cases.\nNotably, he points out that a misconstructed variable/parameter reference such as %~ can break any of the solutions below - including REM lines.REM (or case variations thereof) is the only official comment construct, and is the safest choice - see Joey\'s helpful answer.:: is a (widely used) hack, which has pros and cons:Pros:Cons:If you do want to use ::, you have these choices:Note that none of these styles are directly supported by the batch language, but can be emulated.Inline comments:\n* The code snippets below use ver as a stand-in for an arbitrary command, so as to facilitate experimentation.\n* To make SET commands work correctly with inline comments, double-quote the name=value part; e.g., SET "foo=bar".[1]\nIn this context we can distinguish two subtypes:EOL comments ([to-the-]end-of-line), which  can be placed after a command, and invariably extend to the end of the line (again, courtesy of jeb\'s answer):Intra-line comments, which be placed between multiple commands on a line or ideally even inside of a given command.\nIntra-line comments are the most flexible (single-line) form and can by definition also be used as EOL comments.ver & REM^. ^<comment^> & ver allows inserting a comment between commands (again, courtesy of jeb\'s answer), but note how < and > needed to be ^-escaped, because the following chars. cannot be used as-is: < > | (whereas unescaped & or && or || start the next command).%= <comment> =%, as detailed in dbenham\'s great answer, is the most flexible form, because it can be placed inside a command (among the arguments).\nIt takes advantage of variable-expansion syntax in a way that ensures that the expression always expands to the empty string - as long as the comment text contains neither % nor :\nLike REM, %= <comment> =% works well both outside and inside (...) blocks, but it is more visually distinctive; the only down-sides are that it is harder to type, easier to get wrong syntactically, and not widely known, which can hinder understanding of source code that uses the technique.Multi-line (whole-line block) comments:James K\'s answer shows how to use a goto statement and a label to delimit a multi-line comment of arbitrary length and content (which in his case he uses to store usage information).Zee\'s answer shows how to use a "null label" to create a multi-line comment, although care must be taken to terminate all interior lines with ^.Rob van der Woude\'s blog post mentions another somewhat obscure option that allows you to end a file with an arbitrary number of comment lines: An opening ( only causes everything that comes after to be ignored, as long as it doesn\'t contain a ( non-^-escaped) ), i.e., as long as the block is not closed.[1] Using SET "foo=bar" to define variables - i.e., putting double quotes around the name and = and the value combined - is necessary in commands such as SET "foo=bar" & REM Set foo to bar., so as to ensure that what follows the intended variable value (up to the next command, in this case a single space) doesn\'t accidentally become part of it.\n(As an aside: SET foo="bar" would not only not avoid the problem, it would make the double quotes part of the value).\nNote that this problem is inherent to SET and even applies to accidental trailing whitespace following the value, so it is advisable to always use the SET "foo=bar" approach.good question... I\'ve been looking for this functionality for long too...after several tests and tricks it seem the better solution is the more obvious one...--> best way I found to do it, preventing parser integrity fail, is reusing REM:you can also use multiline with the "NULL LABEL" trick... \n(dont forget the ^ at the end of the line for continuity)A very detailed and analytic discussion on the topic is available on THIS pageIt has the example codes and the pros/cons of different options.James K, I\'m sorry I was wrong in a fair portion of what I said.  The test I did was the following:This meets your description of alternating but fails with a ") was unexpected at this time." error message.  I did some farther testing today and found that alternating isn\'t the key but it appears the key is having an even number of lines, not having any two lines in a row starting with double colons (::) and not ending in double colons. Consider the following:This works!  But also consider this:The rule of having an even number of comments doesn\'t seems to apply when ending in a command.Unfortunately this is just squirrelly enough that I\'m not sure I want to use it.  Really, the best solution, and the safest that I can think of, is if a program like Notepad++ would read REM as double colons and then would write double colons back as REM statements when the file is saved.  But I\'m not aware of such a program and I\'m not aware of any plugins for Notepad++ that does that either.