I know how to redirect stdout to a file:this will put the \'test\' into the foo.log file.Now I want to redirect the output into the log file AND keep it on stdouti.e. it can be done trivially from outside the script:but I want to do it from the insideI triedbut it didn\'t workNote that this is bash, not sh. If you invoke the script with sh myscript.sh, you will get an error along the lines of syntax error near unexpected token \'>\'.If you are working with signal traps, you might want to use the tee -i option to avoid disruption of the output if a signal occurs. (Thanks to  JamesThomasMoon1979 for the comment.)Tools that change their output depending on whether they write to a pipe or a terminal (ls using colors and columnized output, for example) will detect the above construct as meaning that they output to a pipe.There are options to enforce the colorizing / columnizing (e.g. ls -C --color=always). Note that this will result in the color codes being written to the logfile as well, making it less readable.The accepted answer does not preserve STDERR as a separate file descriptor.  That meanswill not output bar to the terminal, only to the logfile, andwill output both foo and bar to the terminal.  Clearly that\'s not\nthe behaviour a normal user is likely to expect.  This can be\nfixed by using two separate tee processes both appending to the same\nlog file:(Note that the above does not initially truncate the log file - if you want that behaviour you should addto the top of the script.)The POSIX.1-2008 specification of tee(1) requires that output is unbuffered, i.e. not even line-buffered, so in this case it is possible that STDOUT and STDERR could end up on the same line of foo.log; however that could also happen on the terminal, so the log file will be a faithful reflection of what could be seen on the terminal, if not an exact mirror of it.  If you want the STDOUT lines cleanly separated from the STDERR lines, consider using two log files, possibly with date stamp prefixes on each line to allow chronological reassembly later on.Solution for busybox and non-bash shellsThe accepted answer is certainly the best choice for bash.  I\'m working in a Busybox environment without access to bash, and it does not understand the exec > >(tee log.txt) syntax.  It also does not do exec >$PIPE properly, trying to create an ordinary file with the same name as the named pipe, which fails and hangs.Hopefully this would be useful to someone else who doesn\'t have bash.Also, for anyone using a named pipe, it is safe to rm $PIPE, because that unlinks the pipe from the VFS, but the processes that use it still maintain a reference count on it until they are finished.Note the use of $* is not necessarily safe.Inside your script file, put all of the commands within parentheses, like this:Easy way to make a bash script log to syslog.  The script output is available both through /var/log/syslog and through stderr.  syslog will add useful metadata, including timestamps.Add this line at the top:Alternatively, send the log to a separate file:This requires moreutils (for the ts command, which adds timestamps).Using the accepted answer my script kept returning exceptionally early (right after \'exec > >(tee ...)\') leaving the rest of my script running in the background. As I couldn\'t get that solution to work my way I found another solution/work around to the problem:This makes output from script go from the process, through the pipe into the sub background process of \'tee\' that logs everything to disc and to original stdout of the script.Note that \'exec &>\' redirects both stdout and stderr, we could redirect them separately if we like, or change to \'exec >\' if we just want stdout. Even thou the pipe is removed from the file system in the beginning of the script it will continue to function until the processes finishes. We just can\'t reference it using the file name after the rm-line.Bash 4 has a coproc command which establishes a named pipe to a command and allows you to communicate through it.Neither of these is a perfect solution, but here are a couple things you could try:orThe second one would leave a pipe file sitting around if something goes wrong with your script, which may or may not be a problem (i.e. maybe you could rm it in the parent shell afterwards).