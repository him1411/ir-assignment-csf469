I have a string that I want to use as a filename, so I want to remove all characters that wouldn\'t be allowed in filenames, using Python.I\'d rather be strict than otherwise, so let\'s say I want to retain only letters, digits, and a small set of other characters like "_-.() ". What\'s the most elegant solution?The filename needs to be valid on multiple operating systems (Windows, Linux and Mac OS) - it\'s an MP3 file in my library with the song title as the filename, and is shared and backed up between 3 machines.You can look at the Django framework for how they create a "slug" from arbitrary text.  A slug is URL- and filename- friendly.Their template/defaultfilters.py (at around line 183) defines a function, slugify, that\'s probably the gold standard for this kind of thing.  Essentially, their code is the following.There\'s more, but I left it out, since it doesn\'t address slugification, but escaping.This whitelist approach (ie, allowing only the chars present in valid_chars) will work if there aren\'t limits on the formatting of the files or combination of valid chars that are illegal (like ".."), for example, what you say would allow a filename named " . txt" which I think is not valid on Windows. As this is the most simple approach I\'d try to remove whitespace from the valid_chars and prepend a known valid string in case of error, any other approach will have to know about what is allowed where to cope with Windows file naming limitations and thus be a lot more complex. What is the reason to use the strings as file names? If human readability is not a factor I would go with base64 module which can produce file system safe strings. It won\'t be readable but you won\'t have to deal with collisions and it is reversible.Update: Changed based on Matthew comment.You can use list comprehension together with the string methods.Just to further complicate things, you are not guaranteed to get a valid filename just by removing invalid characters.  Since allowed characters differ on different filenames, a conservative approach could end up turning a valid name into an invalid one.  You may want to add special handling for the cases where:The string is all invalid characters (leaving you with an empty string)You end up with a string with a special meaning, eg "." or ".."On windows, certain device names are reserved.  For instance, you can\'t create a file named "nul", "nul.txt" (or nul.anything in fact)  The reserved names are:CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2,  LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9You can probably work around these issues by prepending some string to the filenames that can never result in one of these cases, and stripping invalid characters.This is the solution I ultimately used:The unicodedata.normalize call replaces accented characters with the unaccented equivalent, which is better than simply stripping them out. After that all disallowed characters are removed.My solution doesn\'t prepend a known string to avoid possible disallowed filenames, because I know they can\'t occur given my particular filename format. A more general solution would need to do so.There is a nice project on Github called python-slugify:  Install:Then use:Keep in mind, there are actually no restrictions on filenames on Unix systems other than Everything else is fair game. Yes, i just stored ANSI Colour Codes in a file name and had them take effect. For entertainment, put a BEL character in a directory name and watch the fun that ensues when you CD into it ;) It doesn\'t handle empty strings, special filenames (\'nul\', \'con\', etc).Why not just wrap the "osopen" with a try/except and let the underlying OS sort out whether the file is valid?This seems like much less work and is valid no matter which OS you use.You could use the re.sub() method to replace anything not "filelike". But in effect, every character could be valid; so there are no prebuilt functions (I believe), to get it done.Would result in a filehandle to /tmp/filename.txt.Though you have to be careful. It is not clearly said in your intro, if you are looking only at latine language. Some words can become meaningless or another meaning if you sanitize them with ascii characters only.imagine you have "for\xc3\xaat po\xc3\xa9sie" (forest poetry), your sanitization might give "fort-posie" (strong + something meaningless)Worse if  you have to deal with chinese characters."\xe4\xb8\x8b\xe5\x8c\x97\xe6\xb2\xa2" your system might end up doing "---" which is doomed to fail after a while and not very helpful. So if you deal with only files I would encourage to either call them a generic chain that you control or to keep the characters as it is. For URIs, about the same.Another issue that the other comments haven\'t addressed yet is the empty string, which is obviously not a valid filename. You can also end up with an empty string from stripping too many characters.What with the Windows reserved filenames and issues with dots, the safest answer to the question \xe2\x80\x9chow do I normalise a valid filename from arbitrary user input?\xe2\x80\x9d is \xe2\x80\x9cdon\'t even bother try\xe2\x80\x9d: if you can find any other way to avoid it (eg. using integer primary keys from a database as filenames), do that.If you must, and you really need to allow spaces and \xe2\x80\x98.\xe2\x80\x99 for file extensions as part of the name, try something like:Even this can\'t be guaranteed right especially on unexpected OSs\xe2\x80\x89\xe2\x80\x94\xe2\x80\x89for example RISC OS hates spaces and uses \xe2\x80\x98.\xe2\x80\x99 as a directory separator.In one line:you can also put \'_\' character to make it more readable (in case of replacing slashs, for example)Most of these solutions don\'t work.\'/hello/world\' -> \'helloworld\'\'/helloworld\'/ -> \'helloworld\'This isn\'t what you want generally, say you are saving the html for each link, you\'re going to overwrite the html for a different webpage.I pickle a dict such as:2 represents the number that should be appended to the next filename.I look up the filename each time from the dict. If it\'s not there, I create a new one, appending the max number if needed.I\'m sure this isn\'t a great answer, since it modifies the string it\'s looping over, but it seems to work alright:Not exactly what OP was asking for but this is what I use because I need unique and reversible conversions:Result is "somewhat" readable, at least from a sysadmin point of view.UPDATEAll links broken beyond repair in this 6 year old answer.Also, I also wouldn\'t do it this way anymore, just base64 encode or drop unsafe chars. Python 3 example:With base64 you can encode and decode, so you can retrieve the original filename again.But depending on the use case you might be better off generating a random filename and storing the metadata in separate file or DB.ORIGINAL LINKROTTEN ANSWER:The bobcat project contains a python module that does just this.It\'s not completely robust, see this post and this reply.So, as noted: base64 encoding is probably a better idea if readability doesn\'t matter.