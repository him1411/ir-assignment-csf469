I have a Person model that has a foreign key relationship to Book.  Book has a number of fields, but I\'m most concerned about "author" (a standard CharField).With that being said, in my PersonAdmin model, I\'d like to display "book.author" using "list_display".  I\'ve tried all of the obvious methods for doing so (see below), but nothing seems to work.  Any suggestions?As another option, you can do look ups like:Despite all the great answers above and due to me being new to Django, I was still stuck.  Here\'s my explanation from a very newbie perspective.models.pyadmin.py (Incorrect Way) - you think it would work by using \'model__field\' to reference, but it doesn\'tadmin.py (Correct Way)  - this is how you reference a foreign key name the Django wayFor additional reference, see the Django model link hereLike the rest, I went with callables too. But they have one downside: by default, you can\'t order on them. Fortunately, there is a solution for that:According to the documentation, you can only display the __unicode__ representation of a ForeignKey:http://docs.djangoproject.com/en/dev/ref/contrib/admin/#list-displaySeems odd that it doesn\'t support the \'book__author\' style format which is used everywhere else in the DB API.Turns out there\'s a ticket for this feature, which is marked as Won\'t Fix.Please note that adding the get_author function would slow the list_display in the admin, because showing each person would make a SQL query.To avoid this, you need to modify get_queryset method in PersonAdmin, for example:Before: 73 queries in 36.02ms (67 duplicated queries in admin)After: 6 queries in 10.81msYou can show whatever you want in list display by using a callable. It would look like this:I just posted a snippet that makes admin.ModelAdmin support \'__\' syntax:http://djangosnippets.org/snippets/2887/So you can do:This is basically just doing the same thing described in the other answers, but it automatically takes care of (1) setting admin_order_field (2) setting short_description and (3) modifying the queryset to avoid a database hit for each row.This one\'s already accepted, but if there are any other dummies out there (like me) that didn\'t immediately get it from the presently accepted answer, here\'s a bit more detail. The model class referenced by the ForeignKey needs to have a __unicode__ method within it, like here: That made the difference for me, and should apply to the above scenario.  This works on Django 1.0.2.There is a very easy to use package available in PyPI that handles exactly that: django-related-admin. You can also see the code in GitHub.Using this, what you want to achieve is as simple as:Both links contain full details of installation and usage so I won\'t paste them here in case they change.Just as a side note, if you\'re already using something other than model.Admin (e.g. I was using SimpleHistoryAdmin instead), you can do this: class MyAdmin(SimpleHistoryAdmin, RelatedFieldAdmin).if you try it in Inline, you wont succeed unless:in your inline:in your model (MyModel):If you have a lot of relation attribute fields to use in list_display and do not want create a function (and it\'s attributes) for each one, a dirt but simple solution would be override the ModelAdmin instace __getattr__ method, creating the callables on the fly:As gist hereCallable especial attributes like boolean and short_description must be defined as ModelAdmin attributes, eg book__author_verbose_name = \'Author name\' and category__is_new_boolean = True.The callable admin_order_field attribute is defined automatically.Don\'t forget to use the list_select_related attribute in your ModelAdmin to make Django avoid aditional queries.AlexRobbins\' answer worked for me, except that the first two lines need to be in the model (perhaps this was assumed?), and should reference self:Then the admin part works nicely.I prefer this: