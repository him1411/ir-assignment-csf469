I find it more conveniant to access dict keys as obj.foo instead of obj[\'foo\'], so I wrote this snippet:However, I assume there must be some reason that Python doesn\'t provide this functionality out of the box. What would be the caveats and pitfalls of accessing dict keys in this manner?The best way to do this is:Some pros:Cons:As noted in the "cons" list, this combines the namespace of stored keys (which may come from arbitrary and/or untrusted data!) with the namespace of builtin dict method attributes. For example:You can have all legal string characters as part of the key if you use array notation.\nFor example, obj[\'!#$%^&*()_\']From This other SO question there\'s a great implementation example that simplifies your existing code.  How about:Much more concise and doesn\'t leave any room for extra cruft getting into your __getattr__ and __setattr__ functions in the future. I suspect that it has to do with the Zen of Python: "There should be one -- and preferably only one -- obvious way to do it."  This would create two obvious ways to access values from dictionaries: obj[\'key\'] and obj.key.These include possible lack of clarity and confusion in the code.  i.e., the following could be confusing to someone else who is going in to maintain your code at a later date, or even to you, if you\'re not going back into it for awhile.  Again, from Zen: "Readability counts!"If d is instantiated or KEY is defined or d[KEY] is assigned far away from where d.foo is being used, it can easily lead to confusion about what\'s being done, since this isn\'t a commonly-used idiom.  I know it would have the potential to confuse me.As others have noted, you can use any hashable object (not just a string) as a dict key.  For example,is legal, butis not.  This gives you access to the entire range of printable characters or other hashable objects for your dictionary keys, which you do not have when accessing an object attribute.  This makes possible such magic as a cached object metaclass, like the recipe from the Python Cookbook (Ch. 9).I prefer the aesthetics of spam.eggs over spam[\'eggs\'] (I think it looks cleaner), and I really started craving this functionality when I met the namedtuple.  But the convenience of being able to do the following trumps it.This is a simple example, but I frequently find myself using dicts in different situations than I\'d use obj.key notation (i.e., when I need to read prefs in from an XML file).  In other cases, where I\'m tempted to instantiate a dynamic class and slap some attributes on it for aesthetic reasons, I continue to use a dict for consistency in order to enhance readability.I\'m sure the OP has long-since resolved this to his satisfaction, but if he still wants this functionality, then I suggest he download one of the packages from pypi that provides it:However, in order to improve readability of his code I strongly recommend that he not mix his notation styles.  If he prefers this notation then he should simply instantiate a dynamic object, add his desired attributes to it, and call it a day:What if you wanted a key which was a method, such as __eq__ or __getattr__?And you wouldn\'t be able to have an entry that didn\'t start with a letter, so using 0343853 as a key is out.And what if you didn\'t want to use a string?Caveat emptor: For some reasons classes like this seem to break the multiprocessing package.  I just struggled with this bug for awhile before finding this SO: \nFinding exception in python multiprocessingYou can pull a convenient container class from the standard library:to avoid having to copy around code bits. No standard dictionary access, but easy to get one back if you really want it. The code in argparse is simple,tuples can be used dict keys. How would you access tuple in your construct?Also, namedtuple is a convenient structure which can provide values via the attribute access.It doesn\'t work in generality.  Not all valid dict keys make addressable attributes ("the key").  So, you\'ll need to be careful.Python objects are all basically dictionaries.  So I doubt there is much performance or other penalty.No need to write your own as\nsetattr() and getattr() already exist.The advantage of class objects probably comes into play in class definition and inheritance.I created this based on the input from this thread. I need to use odict though, so I had to override get and set attr. I think this should work for the majority of special uses.Usage looks like this:The class:This is a pretty cool pattern already mentioned in the thread, but if you just want to take a dict and convert it to an object that works with auto-complete in an IDE, etc:Apparently there is now a library for this - https://pypi.python.org/pypi/attrdict - which implements this exact functionality plus recursive merging and json loading. Might be worth a look.This doesn\'t address the original question, but should be useful for people that, like me, end up here when looking for a lib that provides this functionality.Addict it\'s a great lib for this: https://github.com/mewwts/addict it takes care of many concerns mentioned in previous answers.An example from the docs:With addict:Here\'s a short example of immutable records using built-in collections.namedtuple:and a usage example:As noted by Doug there\'s a Bunch package which you can use to achieve the obj.key functionality. Actually there\'s a newer version calledNeoBunchIt has though a great feature converting your dict to a NeoBunch object through its neobunchify function. I use Mako templates a lot and passing data as NeoBunch objects makes them far more readable, so if you happen to end up using a normal dict in your Python program but want the dot notation in a Mako template you can use it that way:And the Mako template could look like:This isn\'t a \'good\' answer, but I thought this was nifty (it doesn\'t handle nested dicts in current form). Simply wrap your dict in a function:Now you have slightly different syntax. To acces the dict items as attributes do f.key. To access the dict items (and other dict methods) in the usual manner do f()[\'key\'] and we can conveniently update the dict by calling f with keyword arguments and/or a dictionaryAnd there it is. I\'ll be happy if anyone suggests benefits and drawbacks of this method.You can do it using this class I just made. With this class you can use the Map object like another dictionary(including json serialization) or with the dot notation. I hope help you:Usage examples:Solution is:Let me post another implementation, which builds upon the answer of Kinvais, but integrates ideas from the AttributeDict proposed in http://databio.org/posts/python_AttributeDict.html.The advantage of this version is that it also works for nested dictionaries:Just to add some variety to the answer, sci-kit learn has this implemented as a Bunch:All you need is to get the setattr and getattr methods - the getattr checks for dict keys and the moves on to checking for actual attributes. The setstaet is a fix for fix for pickling/unpickling "bunches" - if inerested check https://github.com/scikit-learn/scikit-learn/issues/6196