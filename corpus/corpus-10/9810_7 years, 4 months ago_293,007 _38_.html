I am trying to figure out a way of checking for the existence of a value in an array without iterating through the array.I am reading a file for a parameter.  I have a long list of parameters I do not want to deal with. I placed these unwanted parameters in an array @badparams.I want to read a new parameter and if it does not exist in @badparams, process it. If it does exist in @badparams, go to the next read.Simply turn the array into a hash:You can also add more (unique) params to the list:And later get a list of (unique) params back:Best general purpose - Especially short arrays (1000 items or less) and coders that are unsure of what optimizations best suit their needs.It has been mentioned that grep passes through all values even if the first value in the array matches.  This is true, however grep is still extremely fast for most cases.  If you\'re talking about short arrays (less than 1000 items) then most algorithms are going to be pretty fast anyway.  If you\'re talking about very long arrays (1,000,000 items) grep is acceptably quick regardless of whether the item is the first or the middle or last in the array.Optimization Cases for longer arrays:If your array is sorted, use a "binary search".If the same array is repeatedly searched many times, copy it into a hash first and then check the hash.  If memory is a concern, then move each item from the array into the hash. More memory efficient but destroys the original array.If same values are searched repeatedly within the array, lazily build a cache. (as each item is searched, first check if the search result was stored in a persisted hash. if the search result is not found in the hash, then search the array and put the result in the persisted hash so that next time we\'ll find it in the hash and skip the search).Note: these optimizations will only be faster when dealing with long arrays.  Don\'t over optimize.You can use smartmatch feature in Perl 5.10 as follows:For literal value lookup doing below will do the trick.For scalar lookup, doing below will work as above.For inline array doing below, will work as above.In Perl 5.18 smartmatch is flagged as experimental therefore you need to turn off the warnings by turning on experimental pragma by adding below to your script/module:Alternatively if you want to avoid the use of smartmatch - then as Aaron said use:This blog post discusses the best answers to this question.As a short summary, if you can install CPAN modules then the most readable solutions are:orHowever, a more common idiom is: But please don\'t use the first() function! It doesn\'t express the intent of your code at all. Don\'t use the ~~ "Smart match" operator: it is broken. And don\'t use grep() nor the solution with a hash: they iterate through the whole list.any() will stop as soon as it finds your value.Check out the blog post for more details.Even though it\'s convenient to use, it seems like the convert-to-hash solution costs quite a lot of performance, which was an issue for me.Output of benchmark test:@eakssjo\'s benchmark is broken - measures creating hashes in loop vs creating regexes in loop. Fixed version (plus I\'ve added List::Util::first and List::MoreUtils::any):And result (it\'s for 100_000 iterations, ten times more than in @eakssjo\'s answer):You certainly want a hash here.  Place the bad parameters as keys in the hash, then decide whether a particular parameter exists in the hash.If you are really interested in doing it with an array, look at List::Util or List::MoreUtilsTry to avoid using grep, if looking at resources.(added in Perl 5.10, marked is experimental in Perl 5.18).There are two ways you can do this. You can use the throw the values into a hash for a lookup table, as suggested by the other posts. ( I\'ll add just another idiom. )But if it\'s data of mostly word characters and not too many meta, you can dump it into a regex alternation: This solution would have to be tuned for the types of "bad values" you\'re looking for. And again, it might be totally inappropriate for certain types of strings, so caveat emptor.You may want to check for numerical leading spaces consistancy