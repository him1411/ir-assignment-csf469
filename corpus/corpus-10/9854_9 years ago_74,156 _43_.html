How often should you use git-gc?  The manual page simply says:Users are encouraged to run this task on a regular basis within each repository to maintain good disk space utilization and good operating performance.Are there some commands to get some object counts to find out whether it\'s time to gc?It depends mostly on how much the repository is used.  With one user checking in once a day and a branch/merge/etc operation once a week you probably don\'t need to run it more than once a year.With several dozen developers working on several dozen projects each checking in 2-3 times a day, you might want to run it nightly.It won\'t hurt to run it more frequently than needed, though.What I\'d do is run it now, then a week from now take a measurement of disk utilization, run it again, and measure disk utilization again.  If it drops 5% in size, then run it once a week.  If it drops more, then run it more frequently.  If it drops less, then run it less frequently.Note that the downside of garbage-collecting your repository is that, well, the garbage gets collected. As we all know as computer users, files we consider garbage right now might turn out to be very valuable three days in the future. The fact that git keeps most of its debris around has saved my bacon several times \xe2\x80\x93 by browsing all the dangling commits, I have recovered much work that I had accidentally canned.So don\xe2\x80\x99t be too much of a neat freak in your private clones. There\xe2\x80\x99s little need for it.OTOH, the value of data recoverability is questionable for repos used mainly as remotes, eg. the place all the devs push to and/or pulled from. There, it might be sensible to kick off a GC run and a repacking frequently.Recent versions of git run gc automatically when required, so you shouldn\'t have to do anything. See the Options section of man git-gc(1): "Some git commands run git gc --auto after performing operations that could create many loose objects."If you\'re using Git-Gui, it tells you when you should worry:The following command will bring a similar number:Except, from its source, git-gui will do the math by itself, actually counting something at .git/objects folder and probably brings an approximation (I don\'t know tcl to properly read that!).In any case, it seems to give the warning based on an arbitrary number around 300 loose objects.Drop it in a cron job that runs every night (afternoon?) when you\'re sleeping.I use git gc after I do a big checkout, and have a lot of new object. it can save space. E.g. if you checkout a big SVN project using git-svn, and do a git gc, you typically save a lot of spaceYou can do it without any interruption, with the new (Git 2.0 Q2 2014) setting gc.autodetach.See commit 4c4ac4d and commit 9f673f9 (Nguy\xe1\xbb\x85n Th\xc3\xa1i Ng\xe1\xbb\x8dc Duy, aka pclouds):gc --auto takes time and can block the user temporarily (but not any less annoyingly).\n  Make it run in background on systems that support it.\n  The only thing lost with running in background is printouts. But gc output is not really interesting.\n  You can keep it in foreground by changing gc.autodetach.Since that 2.0 release, there was a bug though: git 2.7 (Q4 2015) will make sure to not loose the error message.\nSee commit 329e6e8 (19 Sep 2015) by Nguy\xe1\xbb\x85n Th\xc3\xa1i Ng\xe1\xbb\x8dc Duy (pclouds).\n(Merged by Junio C Hamano -- gitster -- in commit 076c827, 15 Oct 2015) While commit 9f673f9 (gc: config option for running --auto in background - 2014-02-08) helps reduce some complaints about \'gc --auto\' hogging the terminal, it creates another set of problems.The latest in this set is, as the result of daemonizing, stderr is closed and all warnings are lost. This warning at the end of cmd_gc() is particularly important because it tells the user how to avoid "gc --auto" running repeatedly.\n  Because stderr is closed, the user does not know, naturally they complain about \'gc --auto\' wasting CPU.Daemonized gc now saves stderr to $GIT_DIR/gc.log.\n  Following gc --auto will not run and gc.log printed out until the user removes gc.log.This quote is taken from;\nVersion Control with GitGit runs garbage collection automatically:\xe2\x80\xa2 If there are too many loose objects in the repository       \xe2\x80\xa2 When a push to a remote repository happens\xe2\x80\xa2 After some commands that might introduce many loose objects\xe2\x80\xa2 When some commands such as  git reflog expire explicitly request itAnd finally, garbage collection occurs when you explicitly request it\n  using the  git gc command. But when should that be? There\xe2\x80\x99s no solid\n  answer to this question, but there is some good advice and best\n  practice. You should consider running  git gc manually in a few\n  situations:\xe2\x80\xa2 If you have just completed a  git filter-branch . Recall that \n  filter-branch rewrites many commits, introduces new ones, and leaves\n  the old ones on a  ref that should be removed when you are satisfied\n  with the results. All those dead objects (that are no longer\n  referenced since you just removed the one  ref pointing to them)\n  should be removed via garbage collection.\xe2\x80\xa2 After some commands that might introduce many loose objects. This\n  might be a large rebase effort, for example. And on the flip side,\n   when should you be wary of garbage collection?\xe2\x80\xa2 If there are orphaned refs that you might want to recover\xe2\x80\xa2 In the context of  git rerere and you do not need to save the\n  resolutions forever\xe2\x80\xa2 In the context of only tags and branches being sufficient to cause\n  Git to retain a commit permanently\xe2\x80\xa2 In the context of  FETCH_HEAD retrievals (URL-direct retrievals via \n  git fetch ) because they are immediately subject to garbage collection\xe2\x80\xa2 In the context of only tags and branches being sufficient to cause\n  Git to retain a commit permanently\xe2\x80\xa2 In the context of  FETCH_HEAD retrievals (URL-direct retrievals via \n  git fetch ) because they are immediately subject to garbage collectionI use when I do a big commit, above all when I remove more files from the repository.. after, the commits are faster