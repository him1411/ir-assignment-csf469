How can I access a function name from inside that function?  In ES5, the best thing to do is:Using Function.caller is non-standard and arguments.callee is forbidden in strict mode.Edit: nus\'s regex based answer below achieves the same thing, but has better performance!In ES6, you can just use myFunction.name.Note: Beware that some JS minifiers might throw away function names, to compress better; you may need to tweak their settings to avoid that.ES6 (inspired by sendy halim\'s answer below):Explanation on MDN. As of 2015 works in nodejs and all major browsers except IE.Note: On bound functions this will give "bound <originalName>". You will have to strip the "bound " if you want to get the original name.ES5 (inspired by Vlad\'s answer):If you have a reference to the function, you can do:[1] I include it here because it is legal and often enough syntax highlighting tools fail to take into account the white space between function name and parenthesis. On the other hand, I\'m not aware of any implementation of .toString() that will include white space here, so that\'s why you can omit it.As an answer to the original question, I would drop parasitic inheritance and go for some more traditional OOP design patterns. I wrote a TidBits.OoJs to comfortably write OOP code in JavaScript with a feature set mimicking C++ (not yet complete, but mostly).I see from the comments that you would like to avoid passing information parent needs to it\'s constructor. I must admit that traditional design patterns won\'t save you from that one though, since it is generally a considered a good thing to make your dependencies obvious and enforced.I would also suggest to steer away from anonymous functions. They only make debugging and profiling a PITA because everything just shows up as "anonymous function", and there is no benefit to them that I\'m aware of.what you\'re doing is assigning unnamed function to a variable. you probably need named function expression instead ( http://kangax.github.com/nfe/ ).however I\'m not sure how much cross-browser that is; there\'s an issue with IE6 that makes you function\'s name leak to the outer scope. also, arguments.callee is kind of deprecated and will result in error if you\'re using strict mode.This might work for you:running foo() will output "foo" or undefined if you call from an anonymous function.It works with constructors too, in which case it would output the name of the calling constructor (eg "Foo").More info here: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/CallerThey claim it\'s non-standard, but also that it\'s supported by all major browsers: Firefox, Safari, Chrome, Opera and IE.Any constructor exposes a property name, which is the function name. You access the constructor via an instance (using new) or a prototype:You can\'t. Functions don\'t have names according to the standard (though mozilla has such an attribute) - they can only be assigned to variables with names. Also your comment:is inside the function my.namespace.myFunc.getFnWhat you can do is return the constructor of an object created by newSo you could say You can use name property to get the function name, unless you\'re using an anonymous functionFor example: now let\'s try with named functionnow you can use You could use Function.name:In most implementations of JavaScript, once you have your constructor\'s reference in scope, you can get its string name from its name property (e.g. Function.name, or Object.constructor.nameYou could use Function.callee:The native arguments.caller method has been deprecated, but most browsers support Function.caller, which will return the actual invoking object (its body of code):\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2FcallerYou could create a source map:If what you need is the literal function signature (the "name" of it) and not the object itself, you might have to resort to something a little more customized, like creating an array reference of the API string values you\'ll need to access frequently. You can map them together using Object.keys() and your array of strings, or look into Mozilla\'s source maps library on GitHub, for bigger projects:\nhttps://github.com/mozilla/source-mapYou could use this, but it\'s not for all browsers, only the ones that support Error.stackOf course this is for the current function, but you get the idea.Cheers!as part as ECMAScript 6 you can use Function.name methodlook here: http://www.tek-tips.com/viewthread.cfm?qid=1209619seems to be right for your needs.I know this is a old question but lately I\'ve been facing some similar issue while trying to decorate some React Component\'s methods, for debugging purposes. As people already said, arguments.caller and arguments.callee are forbidden in strict mode which is probably enabled by default in your React transpiling. You can either disable it, or I\'ve been able to come up with another hack, because in React all class functions are named, you can actually do this:This worked for me.Test code: I had a similar problem and I solved it as follows:This code implements, in a more comfortable fashion, one response I already read here at the top of this discussion.\nNow I have a member function retrieving the name of any function object.\nHere\'s the full script ...you can use Error.stack to trace the function name and exact position of where you are in it.See stacktrace.jsEasy way to get function name from within fuction you are running.