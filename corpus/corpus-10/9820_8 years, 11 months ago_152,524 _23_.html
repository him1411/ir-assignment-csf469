How do I do thisin Linq to SQL?In VB:This assumes that MyTable implements IQueryable.  You may have to access that through a DataContext or some other provider.It also assumes that Foo is a column in MyTable that gets mapped to a property name.See http://blogs.msdn.com/vbteam/archive/2008/01/08/converting-sql-to-linq-part-7-union-top-subqueries-bill-horst.aspx for more detail.Use the Take method:In VB LINQ has a take expression:From the documentation:Take<TSource> enumerates source and yields elements until count elements have been yielded or source contains no more elements. If count exceeds the number of elements in source, all elements of source are returned.Use the Take(int n) method:@Janei: my first comment here is about your sample ;)I think if you do like this, you want to take 4, then applying the sort on these 4.Different than sorting whole tbl_News by idNews descending and then taking 4no ? results may be different.The OP actually mentioned offset as well, so for ex. if you\'d like to get the items from 30 to 60, you would do:  Use the "Skip" method for offset.\nUse the "Take" method for limit.This works well in C#I do like this:You would use the Take(N) method.Whether the take happens on the client or in the db depends on where you apply the take operator.  If you apply it before you enumerate the query (i.e. before you use it in a foreach or convert it to a collection) the take will result in the "top n" SQL operator being sent to the db.  You can see this if you run SQL profiler.  If you apply the take after enumerating the query it will happen on the client, as LINQ will have had to retrieve the data from the database for you to enumerate through itTaking data of DataBase without sorting is the same as random takeI had to use Take(n) method, then transform to list, Worked like a charm: