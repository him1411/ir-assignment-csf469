Or is it now the other way around?From what I\'ve heard there are some areas in which C# proves to be faster than C++, but I\'ve never had the guts to test it by myself.Thought any of you could explain these differences in detail or point me to the right place for information on this.There is no strict reason why a bytecode based language like C# or Java that has a JIT cannot be as fast as C++ code. However C++ code used to be significantly faster for a long time, and also today still is in many cases. This is mainly due to the more advanced JIT optimizations being complicated to implement, and the really cool ones are only arriving just now.So C++ is faster, in many cases. But this is only part of the answer. The cases where C++ is actually faster, are highly optimized programs, where expert programmers thoroughly optimized the hell out of the code. This is not only very time consuming (and thus expensive), but also commonly leads to errors due to over-optimizations.On the other hand, code in interpreted languages gets faster in later versions of the runtime (.NET CLR or Java VM), without you doing anything. And there are a lot of useful optimizations JIT compilers can do that are simply impossible in languages with pointers. Also, some argue that garbage collection should generally be as fast or faster as manual memory management, and in many cases it is. You can generally implement and achieve all of this in C++ or C, but it\'s going to be much more complicated and error prone.As Donald Knuth said, "premature optimization is the root of all evil". If you really know for sure that your application will mostly consist of very performance critical arithmetic, and that it will be the bottleneck, and it\'s certainly going to be faster in C++, and you\'re sure that C++ won\'t conflict with your other requirements, go for C++. In any other case, concentrate on first implementing your application correctly in whatever language suits you best, then find performance bottlenecks if it runs too slow, and then think about how to optimize the code. In the worst case, you might need to call out to C code through a foreign function interface, so you\'ll still have the ability to write critical parts in lower level language.Keep in mind that it\'s relatively easy to optimize a correct program, but much harder to correct an optimized program.Giving actual percentages of speed advantages is impossible, it largely depends on your code. In many cases, the programming language implementation isn\'t even the bottleneck. Take the benchmarks at http://benchmarksgame.alioth.debian.org/ with a great deal of scepticism, as these largely test arithmetic code, which is most likely not similar to your code at all.C# may not be faster, but it makes YOU/ME faster. That\'s the most important measure for what I do. :)It\'s five oranges faster. Or rather: there can be no (correct) blanket answer. C++ is a statically compiled language (but then, there\'s profile guided optimization, too), C# runs aided by a JIT compiler. There are so many differences that questions like \xe2\x80\x9chow much faster\xe2\x80\x9d cannot be answered, not even by giving orders of magnitude.In my experience (and I have worked a lot with both languages), the main problem with C# compared to C++ is high memory consumption, and I have not found a good way to control it. It was the memory consumption that would eventually slow down .NET software.Another factor is that JIT compiler cannot afford too much time to do advanced optimizations, because it runs at runtime, and the end user would notice it if it takes too much time. On the other hand, a C++ compiler has all the time it needs to do optimizations at compile time. This factor is much less significant than memory consumption, IMHO.One particular scenario where C++ still has the upper hand (and will, for years to come) occurs when polymorphic decisions can be predetermined at compile time.Generally, encapsulation and deferred decision-making is a good thing because it makes the code more dynamic, easier to adapt to changing requirements and easier to use as a framework. This is why object oriented programming in C# is very productive and it can be generalized under the term \xe2\x80\x9cgeneralization\xe2\x80\x9d. Unfortunately, this particular kind of generalization comes at a cost at run-time.Usually, this cost is non-substantial but there are applications where the overhead of virtual method calls and object creation can make a difference (especially since virtual methods prevent other optimizations such as method call inlining). This is where C++ has a huge advantage because you can use templates to achieve a different kind of generalization which has no impact on runtime but isn\'t necessarily any less polymorphic than OOP. In fact, all of the mechanisms that constitute OOP can be modelled using only template techniques and compile-time resolution.In such cases (and admittedly, they\'re often restricted to special problem domains), C++ wins against C# and comparable languages.I\'m going to start by disagreeing with part of the accepted (and well-upvoted) answer to this question by stating:There are actually plenty of reasons why JITted code will run slower than a properly optimized C++ (or other language without runtime overhead) \nprogram including:compute cycles spent on JITting code at runtime are by definition unavailable for use in program execution.any hot paths in the JITter will be competing with your code for instruction and data cache in the CPU.  We know that cache dominates when it comes to performance and native languages like C++, by definition, do not have this type of contention.a run-time optimizer\'s time budget is necessarily much more constrained than that of a compile-time optimizer\'s (as another commenter pointed out)Bottom line: Ultimately, you will almost certainly be able to create a faster implementation in C++ than you could in C#.Now, with that said, how much faster really isn\'t quantifiable, as there are too many variables: the task, problem domain, hardware, quality of implementations, and many other factors.  You\'ll have run tests on your scenario to decide whether the additional effort and complexity is worth it.This is a very long and complex topic, but I feel it\'s worth mentioning for the sake of completeness that C#\'s runtime optimizer is excellent, and is able to perform certain dynamic optimizations at runtime that are simply not available to C++ with its compile-time (static) optimizer.  Even with this, the advantage is still typically deeply in the native application\'s court, but the dynamic optimizer is the reason for the "almost certainly" qualifier, given above. --In terms of relative performance, I was also disturbed by the figures and discussions I saw in some other answers, so I thought I\'d chime in and at the same time, provide some support for the statements I\'ve made above.A huge part of the problem with those benchmarks is you can\'t write C++ code as if you were writing C# and expect to get representative results (eg. performing thousands of memory allocations in C++ is going to give you terrible numbers.)Instead, I wrote slightly more idiomatic C++ code and compared against the C# code @Wiory provided.  The two major changes I made to the C++ code were:1) used vector::reserve()2) flattened the 2d array to 1d to achieve better cache locality (contiguous block)C# (.NET 4.6.1)Run time (Release): Init: 124ms, Fill: 165ms C++14 (Clang v3.8/C2)Run time (Release): Init: 398\xc2\xb5s (yes, that\'s microseconds), Fill: 152msObservationsChanging the C# implementation to the same 1d array implementation\nyielded Init: 40ms, Fill: 171ms, Total: 211ms (C++ was still almost\n40% faster).It is much harder to design and write "fast" code in C++ than it is to write "regular" code in either language.It\'s (perhaps) astonishingly easy to get poor performance in C++; we saw that with unreserved vectors performance.  And there are lots of pitfalls like this.C#\'s performance is rather amazing when you consider all that is going on at runtime.  And that performance is comparatively easy to\naccess.More anecdotal data comparing the performance of C++ and C#: https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=gpp&lang2=csharpcoreThe bottom line is that C++ gives you much more control over performance.  Do you want to use a pointer?  A reference?  Stack memory?  Heap?  Dynamic polymorphism or eliminate the runtime overhead of a vtable with static polymorphism (via templates/CRTP)?  In C++ you have to... er, get to make all these choices (and more) yourself, ideally so that your solution best addresses the problem you\'re tackling.Ask yourself if you actually want or need that control, because even for the trivial example above, you can see that although there is a significant improvement in performance, it requires a deeper investment to access.C++ (or C for that matter) gives you fine-grained control over your data structures. If you want to bit-twiddle you have that option. Large managed Java or .NET apps (OWB, Visual Studio 2005) that use the internal data structures of the Java/.NET libraries carry the baggage with them. I\'ve seen OWB designer sessions using over 400 MB of RAM and BIDS for cube or ETL design getting into the 100\'s of MB as well.On a predictable workload (such as most benchmarks that repeat a process many times) a JIT can get you code that is optimised well enough that there is no practical difference.IMO on large applications the difference is not so much the JIT as the data structures that the code itself is using. Where an application is memory-heavy you will get less efficient cache usage. Cache misses on modern CPUs are quite expensive. Where C or C++ really win is where you can optimise your usage of data structures to play nicely with the CPU cache.For graphics the standard C# Graphics class is way slower than GDI accessed via C/C++.\nI know this has nothing to do with the language per se, more with the total .NET platform, but Graphics is what is offered to the developer as a GDI replacement, and its performance is so bad I wouldn\'t even dare to do graphics with it.We have a simple benchmark we use to see how fast a graphics library is, and that is simply drawing random lines in a window. C++/GDI is still snappy with 10000 lines while C#/Graphics has difficulty doing 1000 in real-time.The garbage collection is the main reason Java# CANNOT be used for real-time systems.When will the GC happen?How long will it take?This is non-deterministic.We have had to determine if C# was comparable to C++ in performance and I wrote some test programs for that (using Visual Studio 2005 for both languages). It turned out that without garbage collection and only considering the language (not the framework) C# has basically the same performance as C++. Memory allocation is way faster in C# than in C++ and C# has a slight edge in determinism when data sizes are increased beyond cache line boundaries. However, all of this had eventually to be paid for and there is a huge cost in the form of non-deterministic performance hits for C# due to garbage collection.As usual, it depends on the application.  There are cases where C# is probably negligibly slower, and other cases where C++ is 5 or 10 times faster, especially in cases where operations can be easily SIMD\'d.I know it isn\'t what you were asking, but C# is often quicker to write than C++, which is a big bonus in a commercial setting.It\'s an extremely vague question without real definitive answers.For example; I\'d rather play 3D-games that are created in C++ than in C#, because the performance is certainly a lot better. (And I know XNA, etc., but it comes no way near the real thing).On the other hand, as previously mentioned; you should develop in a language that lets you do what you want quickly, and then if necessary optimize.> From what I\'ve heard ...Your difficulty seems to be in deciding whether what you have heard is credible, and that difficulty will just be repeated when you try to assess the replies on this site.How are you going to decide if the things people say here are more or less credible than what you originally heard?One way would be to ask for evidence.When someone claims "there are some areas in which C# proves to be faster than C++" ask them why they say that, ask them to show you measurements, ask them to show you programs. Sometimes they will simply have made a mistake. Sometimes you\'ll find out that they are just expressing an opinion rather than sharing something that they can show to be true.Often information and opinion will be mixed up in what people claim, and you\'ll have to try and sort out which is which. For example, from the replies in this forum:"Take the benchmarks at http://shootout.alioth.debian.org/\nwith a great deal of scepticism, as\nthese largely test arithmetic code,\nwhich is most likely not similar to\nyour code at all."Ask yourself if you really\nunderstand what "these largely test\narithmetic code" means, and then\nask yourself if the author has\nactually shown you that his claim is\ntrue."That\'s a rather useless test, since it really depends on how well\nthe individual programs have been\noptimized; I\'ve managed to speed up\nsome of them by 4-6 times or more,\nmaking it clear that the comparison\nbetween unoptimized programs is\nrather silly."Ask yourself whether the author has\nactually shown you that he\'s managed\nto "speed up some of them by 4-6\ntimes or more" - it\'s an easy claim to make!.NET languages can be as fast as C++ code, or even faster, but C++ code will have a more constant throughput as the .NET runtime has to pause for GC, even if it\'s very clever about its pauses.So if you have some code that has to consistently run fast without any pause, .NET will introduce latency at some point, even if you are very careful with the runtime GC.In theory, for long running server-type application, a JIT-compiled language can become much faster than a natively compiled counterpart.  Since the JIT compiled language is generally first compiled to a fairly low-level intermediate language, you can do a lot of the high-level optimizations right at compile time anyway.  The big advantage comes in that the JIT can continue to recompile sections of code on the fly as it gets more and more data on how the application is being used.  It can arrange the most common code-paths to allow branch prediction to succeed as often as possible.  It can re-arrange separate code blocks that are often called together to keep them both in the cache.  It can spend more effort optimizing inner loops.I doubt that this is done by .NET or any of the JREs, but it was being researched back when I was in university, so it\'s not unreasonable to think that these sort of things may find their way into the real world at some point soon.Applications that require intensive memory access eg. image manipulation are usually better off written in unmanaged environment (C++) than managed (C#). Optimized inner loops with pointer arithmetics are much easier to have control of in C++. In C# you might need to resort to unsafe code to even get near the same performance.For \'embarassingly parallel\' problems, when using Intel TBB and OpenMP on C++ I have observed a roughly 10x performance increase compared to similar (pure math) problems done with C# and TPL. SIMD is one area where C# cannot compete, but I also got the impression that TPL has a sizeable overhead.That said, I only use C++ for performance-critical tasks where I know I will be able to multithread and get results quickly. For everything else, C# (and occasionally F#) is just fine.C/C++ can perform vastly better in programs where there are either large arrays or heavy looping/iteration over arrays (of any size). This is the reason that graphics are generally much faster in C/C++, because heavy array operations underlie almost all graphics operations. .NET is notoriously slow in array indexing operations due to all the safety checks, and this is especially true for multi-dimensional arrays (and, yes, rectangular C# arrays are even slower than jagged C# arrays).The bonuses of C/C++ are most pronounced if you stick directly with pointers and avoid Boost, std::vector and other high-level containers, as well as inline every small function possible. Use old-school arrays whenever possible. Yes, you will need more lines of code to accomplish the same thing you did in Java or C# as you avoid high-level containers. If you need a dynamically sized array, you will just need to remember to pair your new T[] with a corresponding delete[] statement (or use std::unique_ptr)—the price for the extra speed is that you must code more carefully. But in exchange, you get to rid yourself of the overhead of managed memory / garbage collector, which can easily be 20% or more of the execution time of heavily object-oriented programs in both Java and .NET, as well as those massive managed memory array indexing costs. C++ apps can also benefit from some nifty compiler switches in certain specific cases.I am an expert programmer in C, C++, Java, and C#. I recently had the rare occasion to implement the exact same algorithmic program in the latter 3 languages. The program had a lot of math and multi-dimensional array operations. I heavily optimized this in all 3 languages. The results were typical of what I normally see in less rigorous comparisons: Java was about 1.3x faster than C# (most JVMs are more optimized than the CLR), and the C++ raw pointer version came in about 2.1x faster than C#. Note that the C# program only used safe code—it is my opinion that you might as well code it in C++ before using the unsafe keyword.Lest anyone think I have something against C#, I will close by saying that C# is probably my favorite language. It is the most logical, intuitive and rapid development language I\'ve encountered so far. I do all my prototyping in C#. The C# language has many small, subtle advantages over Java (yes, I know Microsoft had the chance to fix many of Java\'s shortcomings by entering the game late and arguably copying Java). Toast to Java\'s Calendar class anyone? If Microsoft ever spends real effort to optimize the CLR and the .NET JITter, C# could seriously take over. I\'m honestly surprised they haven\'t already—they did so many things right in the C# language, why not follow it up with heavy-hitting compiler optimizations? Maybe if we all beg.I\'ve tested vector in C++ and C# equivalent - List and simple 2d arrays.I\'m using Visual C#/C++ 2010 Express editions. Both projects are simple console applications, I\'ve tested them in standard (no custom settings) release and debug mode.\nC# lists run faster on my pc, array initialization is also faster in C#, math operations are slower.I\'m using Intel Core2Duo P8600@2.4GHz, C# - .NET 4.0.I know that vector implementation is different than C# list, but I just wanted to test collections that I would use to store my objects (and being able to use index accessor).Of course you need to clear memory (let\'s say for every use of new), but I wanted to keep the code simple.C++ vector test:C# list test:C++ - array:C# - array:Time: (Release/Debug)C++(Yes, 13 seconds, I always have problems with lists/vectors in debug mode.)C#:I would put it this way: programmers who write faster code, are the ones who are the more informed of what makes current machines go fast, and incidentally they are also the ones who use an appropriate tool that allows for precise low-level and deterministic optimisation techniques. For these reasons, these people are the ones who use C/C++ rather than C#. I would go as far as stating this as a fact.If I\'m not mistaken, C# templates are determined at runtime. This must be slower than compile time templates of C++. And when you take in all the other compile-time optimizations mentioned by so many others, as well as the lack of safety that does, indeed, mean more speed...I\'d say C++ is the obvious choice in terms of raw speed and minimum memory consumption. But this also translates into more time developing the code and ensuring you aren\'t leaking memory or causing any null pointer exceptions.Verdict:C#: Faster development, slower runC++: Slow development, faster run.I suppose there are applications written in C# running fast, as well as there are more C++ written apps running fast (well C++ just older... and take UNIX too...)\n- the question indeed is - what is that thing, users and developers are complaining about ...\nWell, IMHO, in case of C# we have very comfort UI, very nice hierarchy of libraries, and whole interface system of CLI. In case of C++ we have templates, ATL, COM, MFC and whole shebang of alreadyc written and running code like OpenGL, DirectX and so on... Developers complains of indeterminably risen GC calls in case of C# (means program runs fast, and in one second - bang! it\'s stuck).\nTo write code in C# very simple and fast (not to forget that also increase chance of errors. \nIn case of C++,  developers complains of memory leaks, - means crushes, calls between DLLs, as well as of "DLL hell" - problem with support and replacement libraries by newer ones...\nI think more skill you\'ll have in the programming language, the more quality (and speed) will characterize your software.Well, it depends. If the byte-code is translated into machine-code (and not just JIT) (I mean if you execute the program) and if your program uses many allocations/deallocations it could be faster because the GC algorithm just need one pass (theoretically) through the whole memory once, but normal malloc/realloc/free C/C++ calls causes an overhead on every call (call-overhead, data-structure overhead, cache misses ;) ).So it is theoretically possible (also for other GC languages).I don\'t really see the extreme disadvantage of not to be able to use metaprogramming with C# for the most applications, because the most programmers don\'t use it anyway.Another big advantage is that the SQL, like the LINQ "extension", provides opportunities for the compiler to optimize calls to databases (in other words, the compiler could compile the whole LINQ to one "blob" binary where the called functions are inlined or for your use optimized, but I\'m speculating here).> After all, the answers have to be somewhere, haven\'t they? :)Umm, no.As several replies noted, the question is under-specified in ways that invite questions in response, not answers. To take just one way:And then which programs? Which machine? Which OS? Which data set?Inspired by this, I did a quick test with 60 percent of common instruction needed in most of the programs.Here\xe2\x80\x99s the C# code:String array and arraylist are used purposely to include those instructions.Here\'s the c++ code:The input file size I used was 40 KB.And here\'s the result -Oh, but this was on Linux... With C# running on Mono... And C++ with g++.OK, this is what I got on Windows \xe2\x80\x93 Visual Studio 2003: