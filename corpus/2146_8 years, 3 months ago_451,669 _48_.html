Recently I\'ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.My main question is, how do I implement it in the right way?See this article for a simple design for a lazy evaluated with guaranteed destruction singleton:\nCan any one provide me a sample of Singleton in c++? The classic lazy evaluated and correctly destroyed singleton.See this article about when to use a singleton: (not often)\nSingleton: How should it be usedSee this two article about initialization order and how to cope:\nStatic variables initialisation order\nFinding C++ static initialization order problems See this article describing lifetimes:\nWhat is the lifetime of a static variable in a C++ function? See this article that discusses some threading implications to singletons:\nSingleton instance declared as static variable of GetInstance methodSee this article that explains why double checked locking will not work on C++:\nWhat are all the common undefined behaviours that a C++ programmer should know about?Being a Singleton, you usually do not want it to be destructed.It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it\'s fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it\'s used, but that\'s outside of the scope of a "classic" singleton.You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):It has no dynamic memory allocation.Another non-allocating alternative: create a singleton, say of class C, as you need it:usingNeither this nor C\xc4\x83t\xc4\x83lin\'s answer is automatically thread-safe in current C++, but will be in C++0x.@Loki Astari\'s answer is excellent. However there are times with multiple static objects where you need to be able to guarantee that the singleton will not be destroyed until all your static objects that use the singleton no longer need it.In this case std::shared_ptr can be used to keep the singleton alive for all users even when the static destructors are being called at the end of the program:The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the "main" function. There may be problems really, when some dependent objects are allocated inside "main".I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt\'s main class "QApplication" was allocated on stack in the "main" function, and Qt forbids creating/destroying dialogs when no application object is available.That is why I prefer heap-allocated singletons. I provide an explicit "init()" and "term()" methods for all the singletons and call them inside "main". Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called "getInstance()" or not.Here is an easy implementation.Only one object created and this object reference is returned each and every time afterwords.Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.N.B. This is not a thread safe one.You have to ensure thread safety.If you want to allocate the object in heap, why don\'t use a unique pointer. Memory will also be deallocated since we are using a unique pointer.It is indeed probably allocated from the heap, but without the sources there is no way of knowing.The typical implementation (taken from some code I have in emacs already) would be:...and rely on the program going out of scope to clean up afterwards.If you work on a platform where cleanup must be done manually, I\'d probably add a manual cleanup routine.Another issue with doing it this way is that it isn\'t thread-safe. In a multithreaded environment, two threads could get through the "if" before either has a chance to allocate the new instance (so both would). This still isn\'t too big of a deal if you are relying on program termination to clean up anyway.This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:\nhttp://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf Example:In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...Now somewhere inside a function (such as main) you can do:The refs don\'t need to store a pointer back to their respective Store because that information is supplied at compile-time. You also don\'t have to worry about the Store\'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of Store then there\'s no overhead in this approach; with more than one instance it\'s up to the compiler to be clever about code generation. If necessary, the ItemRef class can even be made a friend of Store (you can have templated friends!).If Store itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:The user can now create a StoreWrapper type (and global instance) for each global Store instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using Store).I think You should write a static function wherein your static object is deleted.\nYou should call this function when you are about to close your application.\nThis will ensure you dont have memory leakage.The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object\'s constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.There is a lot of answers here and it was asked a while ago but I would like to add the following. Credit to Alan and Paul Ezust. (An Intro to design patterns in C++ with Qt)The Singleton pattern is a specialized factory used in situations where you wish to limit the number or type of instances created. The CustomerFactory::instance() method, defined below is an example o a singleton factory. It creates an object if needed, but only the first time that the method is called. On subsequent calls it always returns a pointer to the same object. 1 Ensures this object and all its children are cleaned up when the QApplication exits.It is important when dealing with heap objects to not leave memory leaks behind. You can use QObjects parent-child relationship to help in this regard.How about using placement new like this: