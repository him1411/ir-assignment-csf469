The following are two methods of building a link that has the sole purpose of running JavaScript code. Which is better, in terms of functionality, page load speed, validation purposes, etc.?orI use javascript:void(0).Three reasons. Encouraging the use of # amongst a team of developers inevitably leads to some using the return value of the function called like this:But then they forget to use return doSomething() in the onclick and just use doSomething().A second reason for avoiding # is that the final return false; will not execute if the called function throws an error. Hence the developers have to also remember to handle any error appropriately in the called function.A third reason is that there are cases where the onclick event property is assigned dynamically.  I prefer to be able to call a function or assign it dynamically without having to code the function specifically for one method of attachment or another. Hence my onclick (or on anything) in HTML markup look like this:ORUsing javascript:void(0) avoids all of the above headaches, and I haven\'t found any examples of a downside.So if you\'re a lone developer then you can clearly make your own choice, but if you work as a team you have to either state:Use href="#", make sure onclick always contains return false; at the end, that any called function does not throw an error and if you attach a function dynamically to the onclick property make sure that as well as not throwing an error it returns false.ORUse href="javascript:void(0)"The second is clearly much easier to communicate.Neither.  If you can have an actual URL that makes sense use that as the HREF.  The onclick won\'t fire if someone middle-clicks on your link to open a new tab or if they have JavaScript disabled.If that is not possible, then you should at least inject the anchor tag into the document with JavaScript and the appropriate click event handlers.  I realize this isn\'t always possible, but in my opinion it should be striven for in developing any public website.Check out Unobtrusive JavaScript and Progressive enhancement (both Wikipedia).Doing <a href="#" onclick="myJsFunc();">Link</a> or <a href="javascript:void(0)" onclick="myJsFunc();">Link</a> or whatever else that contains an onclick attribute - was okay back five years ago, though now it can be a bad practice. Here\'s why:It promotes the practice of obtrusive JavaScript - which has turned out to be difficult to maintain and difficult to scale. More on this in Unobtrusive JavaScript.You\'re spending your time writing incredibly overly verbose code - which has very little (if any) benefit to your codebase.There are now better, easier, and more maintainable and scalable ways of accomplishing the desired result.Just don\'t have a href attribute at all! Any good CSS reset would take care of the missing default cursor style, so that is a non-issue. Then attach your JavaScript functionality using graceful and unobtrusive  best practices - which are more maintainable as your JavaScript logic stays in JavaScript, instead of in your markup - which is essential when you start developing large scale JavaScript applications which require your logic to be split up into blackboxed components and templates. More on this in Large-scale JavaScript Application ArchitectureFor a scalable, blackboxed, Backbone.js component example - see this working jsfiddle example here. Notice how we utilize unobtrusive JavaScript practices, and in a tiny amount of code have a component that can be repeated across the page multiple times without side-effects or conflicts between the different component instances. Amazing!Omitting the href attribute on the a element will cause the element to not be accessible using tab key navigation. If you wish for those elements to be accessible via the tab key, you can set the tabindex attribute, or use button elements instead. You can easily style button elements to look like normal links as mentioned in Tracker1\'s answer.Omitting the href attribute on the a element will cause Internet Explorer 6 and Internet Explorer 7 to not take on the a:hover styling, which is why we have added a simple JavaScript shim to accomplish this via a.hover instead. Which is perfectly okay, as if you don\'t have a href attribute and no graceful degradation then your link won\'t work anyway - and you\'ll have bigger issues to worry about.If you want your action to still work with JavaScript disabled, then using an a element with a href attribute that goes to some URL that will perform the action manually instead of via an Ajax request or whatever should be the way to go. If you are doing this, then you want to ensure you do an event.preventDefault() on your click call to make sure when the button is clicked it does not follow the link. This option is called graceful degradation.\'#\' will take the user back to the top of the page, so I usually go with void(0).javascript:; also behaves like javascript:void(0);I would honestly suggest neither.  I would use a stylized <button></button> for that behavior.This way you can assign your onclick.  I also suggest binding via script, not using the onclick attribute on the element tag.  The only gotcha is the psuedo 3d text effect in older IEs that cannot be disabled.If you MUST use an A element, use javascript:void(0); for reasons already mentioned.NOTE: You can replace the 0 with a string such as javascript:void(\'Delete record 123\') which can serve as an extra indicator that will show what the click will actually do.The first one, ideally with a real link to follow in case the user has JavaScript disabled. Just make sure to return false to prevent the click event from firing if the JavaScript executes.Ideally you\'d do this:Or, even better, you\'d have the default action link in the HTML, and you\'d add the onclick event to the element unobtrusively via JavaScript after the DOM renders, thus ensuring that if JavaScript is not present/utilized you don\'t have useless event handlers riddling your code and potentially obfuscating (or at least distracting from) your actual content.Neither if you ask me;If your "link" has the sole purpose of running some JavaScript code it doesn\'t qualify as a link; rather a piece of text with a JavaScript function coupled to it. I would recommend to use a <span> tag with an onclick handler attached to it and some basic CSS to immitate a link. Links are made for navigation, and if your JavaScript code isn\'t for navigation it should not be an <a> tag.Example:Using just # makes some funny movements, so I would recommend to use #self if you would like to save on typing efforts of JavaScript bla, bla,.I use the followinginsteadI agree with suggestions elsewhere stating that you should use regular URL in href attribute, then call some JavaScript function in onclick. The flaw is, that they automaticaly add return false after the call.The problem with this approach is, that if the function will not work or if there will be any problem, the link will become unclickable. Onclick event will always return false, so the normal URL will not be called.There\'s very simple solution. Let function return true if it works correctly. Then use the returned value to determine if the click should be cancelled or not:JavaScriptHTMLNote, that I negate the result of the doSomething() function. If it works, it will return true, so it will be negated (false) and the path/to/some/URL will not be called. If the function will return false (for example, the browser doesn\'t support something used within the function or anything else goes wrong), it is negated to true and the path/to/some/URL is called.# is better than javascript:anything, but the following is even better:HTML:JavaScript:You should always strive for graceful degradation (in the event that the user doesn\'t have JavaScript enabled...and when it is with specs. and budget).  Also, it is considered bad form to use JavaScript attributes and protocol directly in HTML.Unless you\'re writing out the link using JavaScript (so that you know it\'s enabled in the browser), you should ideally be providing a proper link for people who are browsing with JavaScript disabled and then prevent the default action of the link in your onclick event handler. This way those with JavaScript enabled will run the function and those with JavaScript disabled will jump to an appropriate page (or location within the same page) rather than just clicking on the link and having nothing happen.I recommend using a <button> element instead, especially if the control is supposed to produce a change in the data. (Something like a POST.)It\'s even better if you inject the elements unobtrusively, a type of progressive enhancement. (See this comment.)Definitely hash (#) is better because in JavaScript it is a pseudoscheme:Of course "#" with an onclick handler which prevents default action is [much] better. Moreover, a link that has the sole purpose to run JavaScript is not really "a link" unless you are sending user to some sensible anchor on the page (just # will send to top) when something goes wrong. You can simply simulate look and feel of link with stylesheet and forget about href at all.In addition, regarding cowgod\'s suggestion, particularly this: ...href="javascript_required.html" onclick="... This is good approach, but it doesn\'t distinguish between "JavaScript disabled" and "onclick fails" scenarios.I would use:Reasons:I usually go forIt\'s shorter than javascript:void(0) and does the same.It would be better to use jQuery,and omit both href="#" and href="javascript:void(0)".The anchor tag markup will be like Simple enough!I choose use javascript:void(0), because use this could prevent right click to open the content menu.So, when you are doing some JavaScript things with an <a /> tag and if you put href="#" as well, you can add return false at the end of the event (in case of inline event binding) like:Or you can change the href attribute with JavaScript like:orBut semantically, all the above ways to achieve this are wrong (it works fine though). If any element is not created to navigate the page and that have some JavaScript things associated with it, then it should not be a <a> tag. You can simply use a <button /> instead to do things or any other element like b, span or whatever fits there as per your need, because you are allowed to add events on all the elements.So, there is one benefit to use <a href="#">. You get the cursor pointer by default on that element when you do a href="#". For that, I think you can use CSS for this like cursor:pointer; which solves this problem also.And at the end, if you are binding the event from the JavaScript code itself, there you can do event.preventDefault() to achieve this if you are using <a> tag, but if you are not using a <a> tag for this, there you get an advantage, you don\'t need to do this.So, if you see, it\'s better not to use a tag for this kind of stuff.If you happen to be using AngularJS, you can use the following:Which will not do anything.In additionDon\'t use links for the sole purpose of running JavaScript. The use of href="#" scrolls the page to the top; the use of void(0) creates navigational problems within the browser.Instead, use an element other than a link:And style it with CSS:Usually, you should always have a fall back link to make sure that clients with JavaScript disabled still has some functionality. This concept is called unobtrusive JavaScript. Example... Let\'s say you have the following search link:You can always do the following:That way, people with JavaScript disabled are directed to search.php while your viewers with JavaScript view your enhanced functionality.If there is no href maybe there is no reason to use an anchor tag.You can attach events (click, hover, etc.) on almost every element, so why not just use a spanor a div?And for users with JavaScript disabled: if there isn\'t a fallback (for example, an alternative href), they should at least not be able to see and interact with that element at all, whatever it is an <a> or a <span> tag.Depending on what you want to accomplish, you could forget the onclick and just use the href:It gets around the need to return false. I don\'t like the # option because, as mentioned, it will take the user to the top of the page. If you have somewhere else to send the user if they don\'t have JavaScript enabled (which is rare where I work, but a very good idea), then Steve\'s proposed method works great. Lastly, you can use javascript:void(0) if you do not want anyone to go anywhere and if you don\'t want to call a JavaScript function. It works great if you have an image you want a mouseover event to happen with, but there\'s not anything for the user to click on.I believe you are presenting a false dichotomy. These are not the only two options. I agree with Mr. D4V360 who suggested that, even though you are using the anchor tag, you do not truly have an anchor here. All you have is a special section of a document that should behave slightly different. A <span> tag is far more appropriate.I tried both in google chrome with the developer tools, and the id="#" took 0.32 seconds. While the javascript:void(0) method took only 0.18 seconds. So in google chrome, javascript:void(0) works better and faster.When I\'ve got several faux-links, I prefer to give them a class of \'no-link\'.Then in jQuery, I add the following code:And for the HTML, the link is simplyI don\'t like using Hash-Tags unless they\'re used for anchors, and I only do the above when I\'ve got more than two faux-links, otherwise I go with javascript:void(0).Typically, I like to just avoid using a link at all and just wrap something around in a span and use that as a way to active some JavaScript code, like a pop-up or a content-reveal.I\'m basically paraphrasing from this practical article using progressive enhancement. The short answer is that you never use javascript:void(0); or # unless your user interface has already inferred that JavaScript is enabled, in which case you should use javascript:void(0);. Also, do not use span as links, since that is semantically false to begin with.Using SEO friendly URL routes in your application, such as /Home/Action/Parameters is a good practice as well. If you have a link to a page that works without JavaScript first, you can enhance the experience afterward. Use a real link to a working page, then add an onlick event to enhance the presentation.Here is a sample. Home/ChangePicture is a working link to a form on a page complete with user interface and standard HTML submit buttons, but it looks nicer injected into a modal dialog with jQueryUI buttons. Either way works, depending on the browser, which satisfies mobile first development.You can also write a hint in an anchor like this:so the user will know what this link does.