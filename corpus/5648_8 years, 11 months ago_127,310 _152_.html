What is the best or most concise method for returning a string repeated an arbitrary amount of times?The following is my best shot so far:Note to new readers: This answer is old and and not terribly practical - it\'s just "clever" because it uses Array stuff to get\n  String things done. When I wrote "less process" I definitely meant\n  "less code" because, as others have noted in subsequent answers, it\n  performs like a pig. So don\'t use it if speed matters to you.I\'d put this function onto the String object directly.  Instead of creating an array, filling it, and joining it with an empty char, just create an array of the proper length, and join it with your desired string.  Same result, less process!I\'ve tested the performance of all the proposed approaches.Here is the fastest variant I\'ve got.Or as stand-alone function:It is based on artistoex algorithm.\nIt is really fast. And the bigger the count, the faster it goes compared with the traditional new Array(count + 1).join(string) approach.  I\'ve only changed 2 things:UPDCreated a little performance-testing playground here for those who interested.variable count ~ 0 .. 100:\nTesting performance of different variants of String.repeat() http://tinyurl.com/kb3raxrconstant count = 1024:\nTesting performance of different variants of String.repeat() http://tinyurl.com/k527auoUse it and make it even faster if you can :)This one is pretty efficientThis problem is a well-known / "classic" optimization issue for JavaScript, caused by the fact that JavaScript strings are "immutable" and addition by concatenation of even a single character to a string requires creation of, including memory allocation for and copying to, an entire new string.Unfortunately, the accepted answer on this page is wrong, where "wrong" means by a performance factor of 3x for simple one-character strings, and 8x-97x for short strings repeated more times, to 300x for repeating sentences, and infinitely wrong when taking the limit of the ratios of complexity of the algorithms as n goes to infinity. Also, there is another answer on this page which is almost right (based on one of the many generations and variations of the correct solution circulating throughout the Internet in the past 13 years). However, this "almost right" solution misses a key point of the correct algorithm causing a 50% performance degradation.JS Performance Results for the accepted answer, the top-performing other answer (based on a degraded version of the original algorithm in this answer), and this answer using my algorithm created 13 years ago~ October 2000 I published an algorithm for this exact problem which was widely adapted, modified, then eventually poorly understood and forgotten. To remedy this issue, in August, 2008 I published an article http://www.webreference.com/programming/javascript/jkm3/3.html explaining the algorithm and using it as an example of simple of general-purpose JavaScript optimizations. By now, Web Reference has scrubbed my contact information and even my name from this article. And once again, the algorithm has been widely adapted, modified, then poorly understood and largely forgotten.Original string repetition/multiplication JavaScript algorithm by\n  Joseph Myers, circa Y2K as a text multiplying function within Text.js;\n  published August, 2008 in this form by Web Reference:\n  http://www.webreference.com/programming/javascript/jkm3/3.html (The\n  article used the function as an example of JavaScript optimizations,\n  which is the only for the strange name "stringFill3.")Within two months after publication of that article, this same question was posted to Stack Overflow and flew under my radar until now, when apparently the original algorithm for this problem has once again been forgotten. The best solution available on this Stack Overflow page is a modified version of my solution, possibly separated by several generations. Unfortunately, the modifications ruined the solution\'s optimality. In fact, by changing the structure of the loop from my original, the modified solution performs a completely unneeded extra step of exponential duplicating (thus joining the largest string used in the proper answer with itself an extra time and then discarding it).Below ensues a discussion of some JavaScript optimizations related to all of the answers to this problem and for the benefit of all.To illustrate how this technique works, we use a real-life JavaScript function which creates strings of whatever length is needed. And as we\'ll see, more optimizations can be added!A function like the one used here is to create padding to align columns of text, for formatting money, or for filling block data up to the boundary. A text generation function also allows variable length input for testing any other function that operates on text. This function is one of the important components of the JavaScript text processing module.As we proceed, we will be covering two more of the most important optimization techniques while developing the original code into an optimized algorithm for creating strings. The final result is an industrial-strength, high-performance function that I\'ve used everywhere--aligning item prices and totals in JavaScript order forms, data formatting and email / text message formatting and many other uses.Original code for creating strings stringFill1()The syntax is here is clear. As you can see, we\'ve used local function variables already, before going on to more optimizations.Be aware that there\'s one innocent reference to an object property s.length in the code that hurts its performance. Even worse, the use of this object property reduces the simplicity of the program by making the assumption that the reader knows about the properties of JavaScript string objects.The use of this object property destroys the generality of the computer program. The program assumes that x must be a string of length one. This limits the application of the stringFill1() function to anything except repetition of single characters. Even single characters cannot be used if they contain multiple bytes like the HTML entity &nbsp;.The worst problem caused by this unnecessary use of an object property is that the function creates an infinite loop if tested on an empty input string x. To check generality, apply a program to the smallest possible amount of input. A program which crashes when asked to exceed the amount of available memory has an excuse. A program like this one which crashes when asked to produce nothing is unacceptable. Sometimes pretty code is poisonous code.Simplicity may be an ambiguous goal of computer programming, but generally it\'s not. When a program lacks any reasonable level of generality, it\'s not valid to say, "The program is good enough as far as it goes." As you can see, using the string.length property prevents this program from working in a general setting, and in fact, the incorrect program is ready to cause a browser or system crash.Is there a way to improve the performance of this JavaScript as well as take care of these two serious problems?Of course. Just use integers.Optimized code for creating strings stringFill2()Timing code to compare stringFill1() and stringFill2()The success so far of stringFill2()stringFill1() takes 47.297 microseconds (millionths of a second) to fill a 100-byte string, and stringFill2() takes 27.68 microseconds to do the same thing. That\'s almost a doubling in performance by avoiding a reference to an object property.Our previous result looked good--very good, in fact. The improved function stringFill2() is much faster due to the use of our first two optimizations. Would you believe it if I told you that it can be improved to be many times faster than it is now?Yes, we can accomplish that goal. Right now we need to explain how we avoid appending short strings to long strings.The short-term behavior appears to be quite good, in comparison to our original function. Computer scientists like to analyze the "asymptotic behavior" of a function or computer program algorithm, which means to study its long-term behavior by testing it with larger inputs. Sometimes without doing further tests, one never becomes aware of ways that a computer program could be improved. To see what will happen, we\'re going to create a 200-byte string.The problem that shows up with stringFill2()Using our timing function, we find that the time increases to 62.54 microseconds for a 200-byte string, compared to 27.68 for a 100-byte string. It seems like the time should be doubled for doing twice as much work, but instead it\'s tripled or quadrupled. From programming experience, this result seems strange, because if anything, the function should be slightly faster since work is being done more efficiently (200 bytes per function call rather than 100 bytes per function call). This issue has to do with an insidious property of JavaScript strings: JavaScript strings are "immutable."Immutable means that you cannot change a string once it\'s created. By adding on one byte at a time, we\'re not using up one more byte of effort. We\'re actually recreating the entire string plus one more byte.In effect, to add one more byte to a 100-byte string, it takes 101 bytes worth of work. Let\'s briefly analyze the computational cost for creating a string of N bytes. The cost of adding the first byte is 1 unit of computational effort. The cost of adding the second byte isn\'t one unit but 2 units (copying the first byte to a new string object as well as adding the second byte). The third byte requires a cost of 3 units, etc.C(N) = 1 + 2 + 3 + ... + N = N(N+1)/2 = O(N^2). The symbol O(N^2) is pronounced Big O of N squared, and it means that the computational cost in the long run is proportional to the square of the string length. To create 100 characters takes 10,000 units of work, and to create 200 characters takes 40,000 units of work.This is why it took more than twice as long to create 200 characters than 100 characters. In fact, it should have taken four times as long. Our programming experience was correct in that the work is being done slightly more efficiently for longer strings, and hence it took only about three times as long. Once the overhead of the function call becomes negligible as to how long of a string we\'re creating, it will actually take four times as much time to create a string twice as long.(Historical note: This analysis doesn\'t necessarily apply to strings in source code, such as html = \'abcd\\n\' + \'efgh\\n\' + ... + \'xyz.\\n\', since the JavaScript source code compiler can join the strings together before making them into a JavaScript string object. Just a few years ago, the KJS implementation of JavaScript would freeze or crash when loading long strings of source code joined by plus signs. Since the computational time was O(N^2) it wasn\'t difficult to make Web pages which overloaded the Konqueror Web browser or Safari, which used the KJS JavaScript engine core. I first came across this issue when I was developing a markup language and JavaScript markup language parser, and then I discovered what was causing the problem when I wrote my script for JavaScript Includes.)Clearly this rapid degradation of performance is a huge problem. How can we deal with it, given that we cannot change JavaScript\'s way of handling strings as immutable objects? The solution is to use an algorithm which recreates the string as few times as possible.To clarify, our goal is to avoid adding short strings to long strings, since in order to add the short string, the entire long string also must be duplicated.How the algorithm works to avoid adding short strings to long stringsHere\'s a good way to reduce the number of times new string objects are created. Concatenate longer lengths of string together so that more than one byte at a time is added to the output.For instance, to make a string of length N = 9:Doing this required creating a string of length 1, creating a string of length 2, creating a string of length 4, creating a string of length 8, and finally, creating a string of length 9. How much cost have we saved?Old cost C(9) = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 9 = 45.New cost C(9) = 1 + 2 + 4 + 8 + 9 = 24.Note that we had to add a string of length 1 to a string of length 0, then a string of length 1 to a string of length 1, then a string of length 2 to a string of length 2, then a string of length 4 to a string of length 4, then a string of length 8 to a string of length 1, in order to obtain a string of length 9. What we\'re doing can be summarized as avoiding adding short strings to long strings, or in other words, trying to concatenate strings together that are of equal or nearly equal length.For the old computational cost we found a formula N(N+1)/2. Is there a formula for the new cost? Yes, but it\'s complicated. The important thing is that it is O(N), and so doubling the string length will approximately double the amount of work rather than quadrupling it.The code that implements this new idea is nearly as complicated as the formula for the computational cost. When you read it, remember that >>= 1 means to shift right by 1 byte. So if n = 10011 is a binary number, then n >>= 1 results in the value n = 1001.The other part of the code you might not recognize is the bitwise and operator, written &. The expression n & 1 evaluates true if the last binary digit of n is 1, and false if the last binary digit of n is 0.New highly-efficient stringFill3() functionIt looks ugly to the untrained eye, but it\'s performance is nothing less than lovely.Let\'s see just how well this function performs. After seeing the results, it\'s likely that you\'ll never forget the difference between an O(N^2) algorithm and an O(N) algorithm.stringFill1() takes 88.7 microseconds (millionths of a second) to create a 200-byte string, stringFill2() takes 62.54, and stringFill3() takes only 4.608. What made this algorithm so much better? All of the functions took advantage of using local function variables, but taking advantage of the second and third optimization techniques added a twenty-fold improvement to performance of stringFill3().Deeper analysisWhat makes this particular function blow the competition out of the water?As I\'ve mentioned, the reason that both of these functions, stringFill1() and stringFill2(), run so slowly is that JavaScript strings are immutable. Memory cannot be reallocated to allow one more byte at a time to be appended to the string data stored by JavaScript. Every time one more byte is added to the end of the string, the entire string is regenerated from beginning to end.Thus, in order to improve the script\'s performance, one must precompute longer length strings by concatenating two strings together ahead of time, and then recursively building up the desired string length.For instance, to create a 16-letter byte string, first a two byte string would be precomputed. Then the two byte string would be reused to precompute a four-byte string. Then the four-byte string would be reused to precompute an eight byte string. Finally, two eight-byte strings would be reused to create the desired new string of 16 bytes. Altogether four new strings had to be created, one of length 2, one of length 4, one of length 8 and one of length 16. The total cost is 2 + 4 + 8 + 16 = 30.In the long run this efficiency can be computed by adding in reverse order and using a geometric series starting with a first term a1 = N and having a common ratio of r = 1/2. The sum of a geometric series is given by a_1 / (1-r) = 2N.This is more efficient than adding one character to create a new string of length 2, creating a new string of length 3, 4, 5, and so on, until 16. The previous algorithm used that process of adding a single byte at a time, and the total cost of it would be n (n + 1) / 2 = 16 (17) / 2 = 8 (17) = 136.Obviously, 136 is a much greater number than 30, and so the previous algorithm takes much, much more time to build up a string.To compare the two methods you can see how much faster the recursive algorithm (also called "divide and conquer") is on a string of length 123,457. On my FreeBSD computer this algorithm, implemented in the stringFill3() function, creates the string in 0.001058 seconds, while the original stringFill1() function creates the string in 0.0808 seconds. The new function is 76 times faster.The difference in performance grows as the length of the string becomes larger. In the limit as larger and larger strings are created, the original function behaves roughly like C1 (constant) times N^2, and the new function behaves like C2 (constant) times N.From our experiment we can determine the value of C1 to be C1 = 0.0808 / (123457)2 = .00000000000530126997, and the value of C2 to be C2 = 0.001058 / 123457 = .00000000856978543136. In 10 seconds, the new function could create a string containing 1,166,890,359 characters. In order to create this same string, the old function would need 7,218,384 seconds of time.This is almost three months compared to ten seconds!I\'m only answering (several years late) because my original solution to this problem has been floating around the Internet for more than 10 years, and apparently is still poorly-understood by the few who do remember it. I thought that by writing an article about it here I would help:Performance Optimizations for High Speed JavaScript / Page 3Unfortunately, some of the other solutions presented here are still some of those that would take three months to produce the same amount of output that a proper solution creates in 10 seconds.I want to take the time to reproduce part of the article here as a canonical answer on Stack Overflow.Note that the best-performing algorithm here is clearly based on my algorithm and was probably inherited from someone else\'s 3rd or 4th generation adaptation. Unfortunately, the modifications resulted in reducing its performance. The variation of my solution presented here perhaps did not understand my confusing for (;;) expression which looks like the main infinite loop of a server written in C, and which was simply designed to allow a carefully-positioned break statement for loop control, the most compact way to avoid exponentially replicating the string one extra unnecessary time.Good news! String.prototype.repeat is accepted for Harmony (ECMAScript 6).The method is available in recent versions of V8, used by Node.js, Chrome (String.repeat supported since version 41) and Opera. Newer versions of Safari and Firefox also seem to have support, but Internet Explorer doesn\'t. For an up to date list, see MDN: String.prototype.repeat > Browser compatibility.MDN proposes the following polyfill:Expanding P.Bailey\'s solution:This way you should be safe from unexpected argument types:EDIT: Credits to jerone for his elegant ++num idea!String.prototype.repeat is now ES6 Standard.this is how to repeat string several times using delimeter.Use Array(N+1).join("string_to_repeat")Here\'s a 5-7% improvement on disfated\'s answer.Unroll the loop by stopping at count > 1 and perform an additional result += pattnern concat after the loop. This will avoid the loops final previously unused pattern += pattern without having to use an expensive if-check.\nThe final result would look like this:And here\'s disfated\'s fiddle forked for the unrolled version: http://jsfiddle.net/wsdfg/Tests of the various methods:Here\'s the JSLint safe versionThis is about as concise as it gets :If you also care about performance, this is a much better approach :If you want to compare the performance of both options, see this Fiddle and this Fiddle for benchmark tests. During my own tests, the second option was about 2 times faster in Firefox and about 4 times faster in Chrome!In modern browsers, you can now also do this :This option is not only shorter than both other options, but it\'s even faster than the second option.Unfortunately, it doesn\'t work in any version of Internet explorer. The numbers in the table specify the first browser version that fully supports the method :You can test it at JSFiddle. Benchmarked against the hacky Array.join and mine is, roughly speaking, 10 (Chrome) to 100 (Safari) to 200 (Firefox) times faster (depending on the browser).This may be the smallest recursive one:-Fiddle: http://jsfiddle.net/3Y9v2/I just wanted to give it a bash, and made this:I can\'t say I gave it much thought, and it probably shows :-)And it\'s a lot like an answer already posted - I know this.And how about a little default behaviour too?Because, although the non recursive method will handle arbitrarily large repeats without hitting call stack limits, it\'s a lot slower.Partly for my own amusement, and partly to point out in the simplest way I know that there are many ways to skin a cat, and depending on the situation, it\'s quite possible that the apparently best method isn\'t ideal.A relatively fast and sophisticated method may effectively crash and burn under certain circumstances, whilst a slower, simpler method may get the job done - eventually.Some methods may be little more than exploits, and as such prone to being fixed out of existence, and other methods may work beautifully in all conditions, but are so constructed that one simply has no idea how it works."So what if I dunno how it works?!"Seriously?JavaScript suffers from one of its greatest strengths; it\'s highly tolerant of bad behaviour, and so flexible it\'ll bend over backwards to return results, when it might have been better for everyone if it\'d snapped!"With great power, comes great responsibility" ;-)But more seriously and importantly, although general questions like this do lead to awesomeness in the form of clever answers that if nothing else, expand one\'s knowledge and horizons, in the end, the task at hand - the practical script that uses the resulting method - may require a little less, or a little more clever than is suggested.These "perfect" algorithms are fun and all, but "one size fits all" will rarely if ever be better than tailor made.This sermon was brought to you courtesy of a lack of sleep and a passing interest.\nGo forth and code!Firstly, the OP\'s questions seems to be about conciseness - which I understand to mean "simple and easy to read", while most answers seem to be about efficiency - which is obviously not the same thing and also I think that unless you implement some very specific large data manipulating algorithms, shouldn\'t worry you when you come to implement basic data manipulation Javascript functions. Conciseness is much more important.Secondly, as Andr\xc3\xa9 Laszlo noted, String.repeat is part of ECMAScript 6 and already available in several popular implementations - so the most concise implementation of String.repeat is not to implement it ;-)Lastly, if you need to support hosts that don\'t offer the ECMAScript 6 implementation, MDN\'s polyfill mentioned by Andr\xc3\xa9 Laszlo is anything but concise. So, without further ado - here is my concise polyfill:Yes, this is a recursion. I like recursions - they are simple and if done correctly are easy to understand. Regarding efficiency, if the language supports it they can be very efficient if written correctly.From my tests, this method is ~60% faster than the Array.join approach. Although it obviously comes nowhere close disfated\'s implementation, it is much simpler than both. My test setup is node v0.10, using "Strict mode" (I think it enables some sort of TCO), calling repeat(1000) on a 10 character string a million times.Use Lodash for Javascript utility functionality, like repeating strings.Lodash provides nice performance and ECMAScript compatibility.I highly recommend it for UI development and it works well server side, too.Here\'s how to repeat the string "yo" 2 times using Lodash:Just another repeat function:http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype.repeat\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\nhttp://www.w3schools.com/jsref/jsref_repeat.asp Recursive solution using divide and conquer:I came here randomly and never had a reason to repeat a char in javascript before.I was impressed by artistoex\'s way of doing it and disfated\'s results. I noticed that the last string concat was unnecessary, as Dennis also pointed out.I noticed a few more things when playing with the sampling disfated put together.The results varied a fair amount often favoring the last run and similar algorithms would often jockey for position. One of the things I changed was instead of using the JSLitmus generated count as the seed for the calls; as count was generated different for the various methods, I put in an index. This made the thing much more reliable. I then looked at ensuring that varying sized strings were passed to the functions. This prevented some of the variations I saw, where some algorithms did better at the single chars or smaller strings. However the top 3 methods all did well regardless of the string size. Forked test sethttp://jsfiddle.net/schmide/fCqp3/134/I then included Dennis\' fix and decided to see if I could find a way to eek out a bit more.Since javascript can\'t really optimize things, the best way to improve performance is to manually avoid things. If I took the first 4 trivial results out of the loop, I could avoid 2-4 string stores and write the final store directly to the result.This resulted in a 1-2% improvement on average over Dennis\' fix. However, different runs and different browsers would show a fair enough variance that this extra code probably isn\'t worth the effort over the 2 previous algorithms.A chartEdit: I did this mostly under chrome. Firefox and IE will often favor Dennis by a couple %.Simple method:People overcomplicate this to a ridiculous extent or waste performance. Arrays? Recursion? You\'ve got to be kidding me.Edit. I ran some simple tests to compare with the bitwise version posted by artistoex / disfated and a bunch of other people. The latter was only marginally faster, but orders of magnitude more memory-efficient. For 1000000 repeats of the word \'blah\', the Node process went up to 46 megabytes with the simple concatenation algorithm (above), but only 5.5 megabytes with the logarithmic algorithm. The latter is definitely the way to go. Reposting it for the sake of clarity:If you think all those prototype definitions, array creations, and join operations are overkill, just use a single line code where you need it. String S repeating N times:This is what you\'re looking for I hope.\nSee the original implementation I found in the source code of node.js.Concatenating strings based on an number.Hope that helps!