A friend of mine was asked the following question today at interview for the position of software developer:Given two string s1 and s2 how will you check if s1 is a rotated version of s2 ?Example: If s1 = "stackoverflow" then the following are some of its rotated versions:where as "stackoverflwo" is not a rotated version.The answer he gave was:Take s2 and find the longest prefix that is a sub string of s1, that will give you the point of rotation. Once you find that point, break s2 at that point to get s2a and s2b, then just check if concatenate(s2a,s2b) == s1It looks like a good solution to me and my friend. But the interviewer thought otherwise. He asked for a simpler solution. Please help me by telling how would you do this in Java/C/C++ ?Thanks in advance.First make sure s1 and s2 are of the same length. Then check to see if s2 is a substring of s1 concatenated with s1:In Java:Surely a better answer would be, "Well, I\'d ask the stackoverflow community and would probably have at least 4 really good answers within 5 minutes".  Brains are good and all, but I\'d place a higher value on someone who knows how to work with others to get a solution.Another python example (based on THE answer):As others have submitted quadratic worst-case time complexity solution, I\'d add a linear one (based on the KMP Algorithm):working exampleEDIT: The accepted answer is clearly more elegant and efficient than this, if you spot it. I left this answer as what I\'d do if I hadn\'t thought of doubling the original string.I\'d just brute-force it. Check the length first, and then try every possible rotation offset. If none of them work out, return false - if any of them does, return true immediately.There\'s no particular need to concatenate - just use pointers (C) or indexes (Java) and walk both along, one in each string - starting at the beginning of one string and the current candidate rotation offset in the second string, and wrapping where necessary. Check for character equality at each point in the string. If you get to the end of the first string, you\'re done.It would probably be about as easy to concatenate - though probably less efficient, at least in Java.Here\'s one using regex just for fun:You can make it a bit simpler if you can use a special delimiter character guaranteed not to be in either strings.You can also use lookbehind with finite repetition instead:Whoa, whoa... why is everyone so thrilled with an O(n^2) answer?  I\'m positive that we can do better here.  THE answer above includes an O(n) operation in an O(n) loop (the substring/indexOf call).  Even with a more efficient search algorithm; say Boyer-Moore or KMP, the worst-case is still O(n^2) with duplicates.A O(n) randomized answer is straightforward; take a hash (like a Rabin fingerprint) that supports an O(1) sliding window; hash string 1, then hash string 2, and proceed to move the window for hash 1 around the string and see if the hash functions collide.If we imagine the worst case being something like "scanning two strands of DNA", then the probability of collisions goes up, and this probably degenerates to something like O(n^(1+e)) or something (just guessing here).Finally, there\'s a deterministic O(nlogn) solution that has a very big constant outside.  Basically, the idea is to take a convolution of the two strings.  The max value of the convolution will be the rotation difference (if they are rotated); an O(n) check confirms.  The nice thing is that if there are two equal max values, then they are both also valid solutions.  You can do the convolution with two FFT\'s and a dot product, and an iFFT, so nlogn + nlogn + n + nlogn + n == O(nlogn).  Since you can\'t pad with zeroes, and you can\'t guarantee that the strings are of 2^n length, the FFTs won\'t be the fast ones; they\'ll be the slow ones, still O(nlogn) but a much bigger constant than the CT algorithm.All that said, I\'m absolutely, 100% positive that there is a deterministic O(n) solution here, but darned if I can find it.Fist, make sure the 2 strings have the same length. Then in C, you can do this with a simple pointer iteration.Here is an O(n) and in place alghoritm. It uses < operator for the elements of the strings. It\'s not mine of course. I took it from here (The site is in polish. I stumbled upon it once in the past and I couldn\'t find something like that now in English, so I show what I have :)).I guess its better to do this in Java:In Perl I would do:or even better using the index function instead of the regex:Not sure if this is the most efficient method, but it might be relatively interesting: the the Burrows-Wheeler transform.  According to the WP article, all rotations of the input yield the same output.  For applications such as compression this isn\'t desirable, so the original rotation is indicated (e.g. by an index; see the article).  But for simple rotation-independent comparison, it sounds ideal.  Of course, it\'s not necessarily ideally efficient!Take each character as an amplitude and perform a discrete Fourier transform on them. If they differ only by rotation, the frequency spectra will be the same to within rounding error. Of course this is inefficient unless the length is a power of 2 so you can do an FFT :-)Nobody offered a modulo approach yet, so here\'s one:Output:[EDIT: 2010-04-12]piotr noticed the flaw in my code above. It errors when the first character in the string occurs twice or more. For example, stackoverflow tested against owstackoverflow resulted in false, when it should be true.Thanks piotr for spotting the error.Now, here\'s the corrected code:Here\'s the output:Here\'s the lambda approach:Here\'s the lambda approach output:As no one has given a C++ solution. here it it:Opera\'s simple pointer rotation trick works, but it is extremely inefficient in the worst case in running time. Simply imagine a string with many long repetitive runs of characters, ie:S1 =\n  HELLOHELLOHELLO1HELLOHELLOHELLO2S2 =\n  HELLOHELLOHELLO2HELLOHELLOHELLO1The "loop until there\'s a mismatch, then increment by one and try again" is a horrible approach, computationally.To prove that you can do the concatenation approach in plain C without too much effort, here is my solution:This is linear in running time, at the expense of O(n) memory usage in overhead.(Note that the implementation of strstr() is platform-specific, but if particularly brain-dead, can always be replaced with a faster alternative such as the Boyer-Moore algorithm)C#:I like THE answer that checks if s2 is a substring of s1 concatenated with s1.I wanted to add an optimization that doesn\'t lose its elegance. Instead of concatenating the strings you can use a join view (I don\'t know for other language, but for C++ Boost.Range provide such kind of views).As the check if a string is a substring of another has linear average complexity (Worst-case complexity is quadratic), this optimization should improve the speed by a factor of 2 in average. A pure Java answer (sans null checks)And now for something completely different.If you want a really fast answer in some constrained context when strings are not rotation of one anotherAgreed, it can fail, but it is very fast to say if strings don\'t match and if they match you can still use another algorithm like string concatenation to check.Another Ruby solution based on the answer:It\'s very easy to write in PHP using strlen and strpos functions:I don\'t know what strpos uses internally, but if it uses KMP this will be linear in time.Reverse one of the strings. Take the FFT of both (treating them as simple sequences of integers). Multiply the results together point-wise. Transform back using inverse FFT. The result will have a single peak if the strings are rotations of each other -- the position of the peak will indicate by how much they are rotated with respect to each other.Why not something like this?Of course, you could write your own IndexOf() function; I\'m not sure if .NET uses a naive way or a faster way.Naive:Faster:Edit: I might have some off-by-one problems; don\'t feel like checking. ;)I\'d do this in Perl:Join string1 with string2 and use KMP algorithm to check whether string2 is present in newly formed string. Because time complexity of KMP is lesser than substr.