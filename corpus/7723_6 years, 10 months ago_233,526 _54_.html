I have a simple server running in node.js using connect:In my code I have actual handlers, but thats the basic idea. The problem I keep getting isI receive this error when running my application again after it previously crashed or errors. Since I am not opening a new instance of terminal I close out the process with ctr + z.I am fairly certain all I have to do is close out the server or connection. I tried calling server.close() in process.on(\'exit\', ...); with no luck.process.on(\'exit\', ..) isn\'t called if the process crashes or is killed. It is only called when the event loop ends, and since server.close() sort of ends the event loop (it still has to wait for currently running stacks here and there) it makes no sense to put that inside the exit event...On crash, do process.on(\'uncaughtException\', ..) and on kill do process.on(\'SIGTERM\', ..)That being said, SIGTERM (default kill signal) lets the app clean up, while SIGKILL (immediate termination) won\'t let the app do anything.You can also go the command line route:to get the process ids.Then:Doing the -9 on kill sends a SIGKILL (instead of a SIGTERM).\nSIGTERM has been ignored by node for me sometimes.I found for me the quickest way to resolve this was:I hit this on my laptop running win8. this worked.Run cmd.exe as \'Administrator\':First, you would want to know which process is using port 3000this will list all PID listening on this port, once you have the PID you can terminate it with the following: Are you on linux or windows? If on linux\ntype: ps and check the PID of your node process.then, sudo kill PIDEDIT: For Windows:Use tasklist to display the list of running processes:tasklist /Oand then kill the node process like so (PID obtained from the tasklist command):taskkill /pid PIDI found this solution, try itI was getting this error once and took many of the approaches here. My issues was that I had two app.listen(3000); calls in the same app.js script. The first app.listen() succeeded where the second threw the error.Another useful command I came across that helped me debug was sudo fuser -k 3000/tcp which will kill any rogue processes you might have started (some processes may restart, e.g. if run with forever.js, but it was useful for me).FYI, you can kill the process in one command  sudo fuser -k 3000/tcp. This can be done for all other ports like 8000, 8080 or 9000 which are commonly used for development.You may use hot-node to prevent your server from crashing/ run-time-errors. Hot-node automatically restarts the nodejs application for you whenever there is a change in the node program[source] / process[running node program].Install hot-node using npm using the global option:npm install -g hotnodePowerShell users:Taskkill /IM node.exe /FNode is running somewhere in memory and has that port locked down. On Windows, this problem will happen, like most Windows problems, be solved by hitting CTRL+ALT+DEL and/or rebooting.Task Manager (ctrl+alt+del) -> Processes  tab -> select the "node.exe" process and hit "End Process" With due respect to all the answers in the form, I would like to add a point.I found that when I terminate a node app on error using Ctrl + Z, the very next time when I try to open it got the same error EADDRINUSE. When I use Ctrl + C to terminate a node app, the next time I opened it, it did without a hitch.Changing the port number to something other than the one in error solved the issue.Reasons for this issues are:You may be use more than one server. You can close them and use one server.In Linux you can use killall node command.Just in case check if you have added this line multiple times by mistakeThe above code is for express but just check if you are trying to use the same port twice in your code.Be careful that, like me, you don\'t have another DOS box (or similar) running that you\'ve forgotten about x)It did produce the exact error shown above!This means you have two node servers running on the same port ,if one is running on port let say 3000 change the other one to another port lets say 3001 and everything will work wellI wonder, why nobody yet mentioned this possibility: So, debug your code and check what exactly you pass to functions, before starting to check for the processes, that are using your port.Add function to ~/.bashrc:Pull changes: source ~/.bashrcAnd use it: killTcpListen 3000This command list the tasks related to the \'node\' and have each of them terminated.