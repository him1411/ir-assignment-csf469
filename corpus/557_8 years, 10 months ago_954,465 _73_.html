I\'ve been using the idiom below for some time now. And it seems to be the most wide-spread, at least on the sites I\'ve visited.Is there a better/different way to read a file into a string in Java?Here\'s a compact, robust idiom for Java 7, wrapped up in a utility method:Java 7 added a convenience method to read a file as lines of text, represented as a List<String>. This approach is "lossy" because the line separators are stripped from the end of each line.The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn\'t need to contain the entire file. However, it\'s still not suitable for files that are very large relative to available memory.For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, "large" depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.The StandardCharsets class define some constants for the encodings required of all Java runtimes:The platform default is available from the Charset class itself:Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the "edited" link on this answer.Commons FileUtils.readFileToString:Reads the contents of a file into a String using the default encoding\n  for the VM. The file is always closed.Parameters:Returns:\n  the file contents, never nullThrows:\n   - IOException - in case of an I/O errorSince:\n  Commons IO 1.3.1The code used (indirectly) by that class is:IOUtils.java under Apache Licence 2.0.It is very similar to the one used by Ritche_W.From this page a very lean solution:or If you want to set the charsetIf you\'re looking for an alternative that doesn\'t involve a third-party library (e.g. Commons I/O), you can use the Scanner class:Guava has a method similar to the one from Commons IOUtils that Willi aus Rohr mentioned:EDIT by Oscar ReyesThis is the (simplified) underlying code on the cited library:Edit (by Jonik): The above doesn\'t match the source code of recent Guava versions. For the current source, see the classes Files, CharStreams, ByteSource and CharSource in com.google.common.io package........   If you need a string processing (parallel processing) Java 8 has the great Stream API.More examples are available in JDK samples sample/lambda/BulkDataOperations that can be downloaded from Oracle Java SE 8 download page Another one liner exampleThat code will normalize line breaks, which may or may not be what you really want to do.Here\'s an alternative which doesn\'t do that, and which is (IMO) simpler to understand than the NIO code (although it still uses java.nio.charset.Charset):since java 7 you can do it this way.If it\'s a text file why not use apache commons-io?  http://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/FileUtils.htmlIt has the following methodIf you want the lines as a list useTo read a File as binary and convert at the endJava attempts to be extremely general and flexible in all it does. As a result, something which is relatively simple in a scripting language (your code would be replaced with "open(file).read()" in python) is a lot more complicated. There doesn\'t seem to be any shorter way of doing it, except using an external library (like Willi aus Rohr mentioned). Your options:Your best bet is probably the 2nd one, as it has the least dependencies.One Line Solution There is a variation on the same theme that uses a for loop, instead of a while loop, to limit the scope of the line variable.  Whether it\'s "better" is a matter of personal taste.With Java 7, this is my preferred option to read a UTF-8 file:Since Java 7, the JDK has the new java.nio.file API, which provides many shortcuts, so 3rd party libraries are not always required for simple file operations.If you do not have access to Files, you do the next:A flexible solution using IOUtils from Apache commons-io in combination with StringWriter:It works with any reader or input stream (not just with files), for example when reading from a URL.Be aware when using fileInputStream.available() the returned integer does not have to represent the actual file size, but rather the guessed amount of bytes the system should be able to read from the stream without blocking IO. A safe and simple way could look like thisIt should be considered that this approach is not suitable for multi-byte character encodings like UTF-8.This one uses the method RandomAccessFile.readFully, it seems to be available from JDK 1.0 !After Ctrl+F\'ing after Scanner, I think that the Scanner solution should be listed too. In the easiest to read fashion it goes like this:If you use Java 7 or newer (and you really should) consider using try-with-resources to make the code easier to read. No more dot-close stuff littering everything. But that\'s mostly a stylistic choice methinks.I\'m posting this mostly for completionism, since if you need to do this a lot, there should be things in java.nio.file.Files that should do the job better.My suggestion would be to use Files#readAllBytes(Path) to grab all the bytes, and feed it to new String(byte[] Charset) to get a String out of it that you can trust. Charsets will be mean to you during your lifetime, so beware of this stuff now.Others have given code and stuff, and I don\'t want to steal their glory. ;)Using this library, it is one line:You can try Scanner and File class, a few lines solutionAlso if your file happens to be inside a jar, you can also use this:The path should start with /  for instance if your jar isThen you want to invoke it like this:I cannot comment other entries yet, so I\'ll just leave it here.One of best answers here (https://stackoverflow.com/a/326448/1521167):still has one flaw. It always puts new line char in the end of string, which may cause some weirds bugs. My suggestion is to change it to:In one line (Java 8), assuming you have a Reader:in java 8 , there are a new Class java.util.stream.StreamA stream represents a sequence of elements and supports different kind of operations to perform computations upon those elementsto Read more about it :Oracle DocumentationHere an Example :Use code:fileStr contains output in String.