First of all: yes, I read all the other threads on this topic. And not only those from this site... (you see, I\'m a little frustrated)Most of them come with the advice to use android:id instead of just id in the XML file. I did.From others, I learned, that View.findViewById works different than Activity.findViewById. I handled that, too.In my location_layout.xml, I use:In my Activity I do:and in my custom view class:which returns null. Doing this, my Activity works fine. So maybe it\'s because of the Activity.findViewById and View.findViewById differences. So I stored the context passed to the customs view constructor locally and tried:which also returned null.Then, I changed my custom view to extend ViewGroup instead View and changed the location_layout.xml to let the TextView be a direct child of my custom view, so that the View.findViewById should work as supposed. Suprise: it didn\'t solve anything.So what the heck am I doing wrong? I\'ll appreciate any comments.which returns nullPossibly because you are calling it too early. Wait until onFinishInflate(). Here is a sample project demonstrating a custom View accessing its contents.Possibly, you are calling findViewById before calling setContentView?\nIf that\'s the case, try calling findViewById AFTER calling setContentViewMake sure you don\'t have multiple versions of your layout for different screen densities. I ran into this problem once when adding a new id to an existing layout but forgot to update the hdpi version. If you forget to update all versions of the layout file it will work for some screen densities but not others.In my case, I had 2 activites in my project, main.xml and main2.xml. From the beginning, main2 was a copy of main, and everything worked well, until I added new TextView to main2, so the R.id.textview1 became available for the rest of app. Then I tried to fetch it by standard calling:and it was always null. It turned out, that in onCreate constructor  I was instantiating not main2, but the other one. I had:instead of I noticed this after I arrived here, on the site.Alongside the classic causes, mentioned elsewhere:There is one I have found for custom views in standard layouts, which goes against the documentation:In theory you can create a custom view and add it to a layout (see here). However, I have found that in such situations, sometimes the id attribute works for all the views in the layout except the custom ones. The solution I use is:In onCreate:which puts the custom view in the frame.FindViewById can be null if you call the wrong super constructor in a custom view. The ID tag is part of attrs, so if you ignore attrs, you delete the ID.This would be wrongThis is correctA answer for those using ExpandableListView and run into this question based on it\'s title. I had this error attempting to work with TextViews in my child and group views as part of an ExpandableListView implementation.You can use something like the following in your implementations of the getChildView() and getGroupView() methods.I found this here.I\'m pretty new to Android/Eclipse, by mistake I added the UI stuff to activity_main.xml instead of fragment_main.xml. Took me some hours to figure that out...In my particular case, I was trying to add a footer to a ListView. The following call in onCreate() was returning null.Changing this to inflate the footer view instead of finding it by ID solved this issue.FWIW, I don\'t see that anyone solved this in quite the same way as I needed to. No complaints at compile time, but I was getting a null view at runtime, and calling things in the proper order. That is, \n    findViewById() \nafter \n    setContentView().\nThe problem turned out that my view is defined in content_main.xml, but in my activity_main.xml, I lacked this one statement: When I added that to activity_main.xml, no more NullPointer. In my case, I was using ExpandableListView and I had set android:transcriptMode="normal". This was causing few children in expandable group to disappear and I used to get NULL exception when ever I used scroll the list.For me I had two xml layouts for the same activity - one in portrait mode and one in landscape. Of course I had changed the id of an object in the landscape xml but had forgotten to make the same change in the portrait version. Make sure if you change one you do the same to the other xml or you will not get an error until you run/debug it and it can\'t find the id you didn\'t change. Oh dumb mistakes, why must you punish me so?Set the activity content from a layout resource.\nie.,setContentView(R.layout.basicXml);I had this same problem.  I was using a third-party library that allows you to override their adapter for a GridView and to specify your own layout for each GridView cell.I finally realized what was happening.  Eclipse was still using the library\'s layout xml file for each cell in the GridView, even though it gave no indication of this.  In my custom adapter, it indicated that it was using the xml resource from my own project even though at runtime, it wasn\'t.So what I did was to make sure my custom xml layouts and ids were different from those still sitting in the library, cleaned the project and then it started reading the correct custom layouts that were in my project.In short, be careful if you\'re overriding a third-party library\'s adapter and specifying your own layout xml for the adapter to use.  If your layout inside your project has the same file name as that in the library, you might encounter a really difficult-to-find bug!I have the same problem, but I think its worth sharing with you guys.\nIf you have to findViewById in custom layout, for example:you cannot get the view in constructor.\nYou should call findViewById after view has inflated.\nTheir is a method you can override onFinishInflateIn my case I had inflated the layout but the child views were returning null. Originally I had this:However, when I changed it to the following it worked:The key was to specifically reference the already inflated layout in order to get the child views. That is, to add footerView:In my experience, it seems that this can also happen when your code is called after OnDestroyView (when the fragment is on the back stack.)  If you are updating the UI on input from a BroadCastReceiver, you ought to check if this is the case.In addition of the above solutions you make sure the\ntools:context=".TakeMultipleImages"\nin the layout is same value in the mainfest.xml file :\nandroid:name=".TakeMultipleImages" for the same activity element.\nit is occur when use copy and paste to create new activityINFLATE THE LAYOUT !! (which contains the id)In my case findViewById() returned null, because the layout in which the element was written, was not inflated...Eg.\nfragment_layout.xmlfindViewById(R.id.listview) returned null, because I had not done \ninflater.inflate(R.layout.fragment_layout, ..., ...); \nbefore it.Hope this answer helps some of y\'all.My fix was to just clean the project. Just wanted to throw my specific case in here. Might help someone down the line.I was using the  directive in my Android UI XML like this:Parent view:Child view (retry_button):.findViewById(R.id.retry) would always return null. But, if I moved the ID from the child view into the include tag, it started working.Fixed parent:Fixed child:findViewById also can return null if you\'re inside a Fragment.  As described here: findViewById in Fragment You should call getView() to return the top level View inside a Fragment.  Then you can find the layout items (buttons, textviews, etc)