I am currently getting this error:System.Data.SqlClient.SqlException: New transaction is not allowed because there are other threads running in the session.while running this code:Model #1 - This model sits in a database on our Dev Server.\nModel #1 http://content.screencast.com/users/Keith.Barrows/folders/Jing/media/bdb2b000-6e60-4af0-a7a1-2bb6b05d8bc1/Model1.png Model #2 - This model sits in a database on our Prod Server and is updated each day by automatic feeds.  alt text http://content.screencast.com/users/Keith.Barrows/folders/Jing/media/4260259f-bce6-43d5-9d2a-017bd9a980d4/Model2.pngNote - The red circled items in Model #1 are the fields I use to "map" to Model #2.  Please ignore the red circles in Model #2: that is from another question I had which is now answered.Note:  I still need to put in an isDeleted check so I can soft delete it from DB1 if it has gone out of our client\'s inventory.All I want to do, with this particular code, is connect a company in DB1 with a client in DB2, get their product list from DB2 and INSERT it in DB1 if it is not already there.  First time through should be a full pull of inventory.  Each time it is run there after nothing should happen unless new inventory came in on the feed over night.So the big question - how to I solve the transaction error I am getting?  Do I need to drop and recreate my context each time through the loops (does not make sense to me)?After much pulling out of hair I discovered that the foreach loops were the culprits.  What needs to happen is to call EF but return it into an IList<T> of that target type then loop on the IList<T>.Example:As you\'ve already identified, you cannot save from within a foreach that is still drawing from the database via an active reader.Calling ToList() or ToArray() is fine for small data sets, but when you have thousands of rows, you will be consuming a large amount of memory.It\'s better to load the rows in chunks.Given the above extension methods, you can write your query like this:The queryable object you call this method on must be ordered.  This is because Entity Framework only supports IQueryable<T>.Skip(int) on ordered queries, which makes sense when you consider that multiple queries for different ranges require the ordering to be stable.  If the ordering isn\'t important to you, just order by primary key as that\'s likely to have a clustered index.This version will query the database in batches of 100.  Note that SaveChanges() is called for each entity.If you want to improve your throughput dramatically, you should call SaveChanges() less frequently.  Use code like this instead:This results in 100 times fewer database update calls.  Of course each of those calls takes longer to complete, but you still come out way ahead in the end.  Your mileage may vary, but this was worlds faster for me.And it gets around the exception you were seeing.EDIT I revisited this question after running SQL Profiler and updated a few things to improve performance.  For anyone who is interested, here is some sample SQL that shows what is created by the DB.The first loop doesn\'t need to skip anything, so is simpler.Subsequent calls need to skip previous chunks of results, so introduces usage of row_number:We have now posted an official response to the bug opened on Connect.  The workarounds we recommend are as follows:This error is due to Entity Framework creating an implicit transaction during the SaveChanges() call. The best way to work around the error is to use a different pattern (i.e., not saving while in the midst of reading) or by explicitly declaring a transaction. Here are three possible solutions:I was getting this same issue but in a different situation. I had a list of items in a list box. The user can click an item and select delete but I am using a stored proc to delete the item because there is a lot of logic involved in deleting the item. When I call the stored proc the delete works fine but any future call to SaveChanges will cause the error. My solution was to call the stored proc outside of EF and this worked fine. For some reason when I call the stored proc using the EF way of doing things it leaves something open.Just put context.SaveChanges() after end of your foreach(loop).FYI: from a book and some lines adjusted because its stil valid:Invoking SaveChanges() method begins a transaction which automatically rolls back all changes persisted to the database if an exception occurs before iteration completes; otherwise the transaction commits. You might be tempted to apply the method after each entity update or deletion rather than after iteration completes, especially when you\'re updating or deleting massive numbers of entities.If you try to invoke SaveChanges() before all data has been processed, you incur a "New transaction is not allowed because there are other threads running in the session" exception. The exception occurs because SQL Server doesn\'t permit starting a new transaction on a connection that has a SqlDataReader open, even with Multiple Active Record Sets (MARS) enabled by the connection string (EF\'s default connection string enables MARS)Sometimes its better to understand why things are happening ;-)So in the project were I had this exact same issue the problem wasn\'t in the foreach or the .toList() it was actually in the AutoFac configuration we used.\nThis created some weird situations were the above error was thrown but also a bunch of other equivalent errors were thrown.This was our fix:\nChanged this:To:I was also facing same issue.Here is the cause and solution.http://blogs.msdn.com/b/cbiyikoglu/archive/2006/11/21/mars-transactions-and-sql-error-3997-3988-or-3983.aspxMake sure before firing data manipulation commands like inserts, updates, you have closed all previous active SQL readers.Most common error is functions that read data from db and return values.\nFor e.g functions like isRecordExist.In this case we immediately return from the function if we found the record and forget to close the reader.In my case, the problem appeared when I called Stored Procedure via EF and then later SaveChanges throw this exception. The problem was in calling the procedure, the enumerator was not disposed. I fixed the code following way:I needed to read a huge ResultSet and update some records in the table.\nI tried to use chunks as suggested in  Drew Noakes\'s answer.Unfortunately after 50000 records I\'ve got  OutofMemoryException.\nThe answer Entity framework large data set, out of memory exception explains, that EF creates second copy of data which uses for change detection (so\n  that it can persist changes to the database). EF holds this second set\n  for the lifetime of the context and its this set thats running you out\n  of memory.The recommendation  is to renew your context each batch.So I\'ve retrieved Minimal and Maximum values of the primary key- the tables have primary keys as auto incremental integers.Then I retrieved from the database chunks of records by opening context for each chunk. After processing the chunk  context closes and releases the memory. It insures that memory usage is not growing.Below is a snippet from my code: FromToRange is a simple structure with From and To properties.Here are another 2 options that allow you to invoke SaveChanges() in a for each loop.The first option is use one DBContext to generate your list objects to iterate through, and then create a 2nd DBContext to call SaveChanges() on.  Here is an example:The 2nd option is to get a list of database objects from the DBContext, but to select only the id\'s.  And then iterate through the list of id\'s (presumably an int) and get the object corresponding to each int, and invoke SaveChanges() that way.  The idea behind this method is grabbing a large list of integers, is a lot more efficient then getting a large list of db objects and calling .ToList() on the entire object.  Here is an example of this method:The code below works for me:I am much late to the party but today I faced the same error and how I resolved was simple. My scenario was similar to this given code I was making DB transactions inside of nested for-each loops.The problem is as a Single DB transaction takes a little bit time longer than for-each loop so once the earlier transaction is not complete then the new traction throws an exception, so the solution is to create a new object in the for-each loop where you are making a db transaction.For the above mentioned scenarios the solution will be like this:I am a little bit late, but I had this error too. I solved the problem by checking what where the values that where updating.I found out that my query was wrong and that there where over 250+ edits pending. So I corrected my query, and now it works correct.So in my situation: Check the query for errors, by debugging over the result that the query returns. After that correct the query.Hope this helps resolving future problems.Always Use your selection as ListEg:Then Loop through the Collection while save changes