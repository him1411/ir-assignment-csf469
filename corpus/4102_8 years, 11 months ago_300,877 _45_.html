I need a robust and simple way to remove illegal path and file characters from a simple string. I\'ve used the below code but it doesn\'t seem to do anything, what am I missing?Try something like this instead;But I have to agree with the comments, I\'d probably try to deal with the source of the illegal paths, rather than try to mangle an illegal path into a legitimate but probably unintended one.Edit: Or a potentially \'better\' solution, using Regex\'s.Still, the question begs to be asked, why you\'re doing this in the first place.I use Linq to clean up filenames. You can easily extend this to check for valid paths as well.Some comments indicate this method is not working for them so I\'ve included a link to a DotNetFiddle snippet so you may validate the method. https://dotnetfiddle.net/nw1SWYThis answer was on another thread by Ceres, I really like it neat and simple.You can remove illegal chars using Linq like this:EDIT\nThis is how it looks with the required edit mentioned in the comments:These are all great solutions, but they all rely on Path.GetInvalidFileNameChars, which may not be as reliable as you\'d think. Notice the following remark in the MSDN documentation on Path.GetInvalidFileNameChars:The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names. The full set of invalid characters can vary by file system. For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<), greater than (>), pipe (|), backspace (\\b), null (\\0) and tab (\\t).It\'s not any better with Path.GetInvalidPathChars method. It contains the exact same remark.For starters, Trim only removes characters from the beginning or end of the string. Secondly, you should evaluate if you really want to remove the offensive characters, or fail fast and let the user know their filename is invalid. My choice is the latter, but my answer should at least show you how to do things the right AND wrong way:StackOverflow question showing how to check if a given string is a valid file name. Note you can use the regex from this question to remove characters with a regular expression replacement (if you really need to do this).I use regular expressions to achieve this. First, I dynamically build the regex.Then I just call removeInvalidChars.Replace to do the find and replace. This can obviously be extended to cover path chars as well.I absolutely prefer the idea of Jeff Yates. It will work perfectly, if you slightly modify it:The improvement is just to escape the automaticially generated regex.For file names:For full paths:The best way to  remove illegal character from user input is to replace illegal character using Regex class, create method in code behind or also it validate at client side using RegularExpression control.ORHere\'s a code snippet that should help for .NET 3 and higher.Most solutions above combine illegal chars for both path and filename which is wrong (even when both calls currently return the same set of chars). I would first split the path+filename in path and filename, then apply the appropriate set to either if them and then combine the two again.wvd_vegtThrow an exception.If you remove or replace with a single character the invalid characters, you can have collisions:Here is a simple method to avoid this:The result:I think it is much easier to validate using a regex and specifiing which characters are allowed, instead of trying to check for all bad characters.\nSee these links:\nhttp://www.c-sharpcorner.com/UploadFile/prasad_1/RegExpPSD12062005021717AM/RegExpPSD.aspx\nhttp://www.windowsdevcenter.com/pub/a/oreilly/windows/news/csharp_0101.htmlAlso, do a search for "regular expression editor"s, they help a lot. There are some around which even output the code in c# for you.I wrote this monster for fun, it lets you roundtrip:This seems to be O(n) and does not spend too much memory on strings:This will do want you want, and avoid collisionsI think the question already not full answered...\nThe answers only describe clean filename OR path... not both. Here is my solution:Scanning over the answers here, they all** seem to involve using a char array of invalid filename characters. Granted, this may be micro-optimising - but for the benefit of anyone who might be looking to check a large number of values for being valid filenames, it\'s worth noting that building a hashset of invalid chars will bring about notably better performance. I have been very surprised (shocked) in the past just how quickly a hashset (or dictionary) outperforms iterating over a list. With strings, it\'s a ridiculously low number (about 5-7 items from memory). With most other simple data (object references, numbers etc) the magic crossover seems to be around 20 items. There are 40 invalid characters in the Path.InvalidFileNameChars "list". Did a search today and there\'s quite a good benchmark here on StackOverflow that shows the hashset will take a little over half the time of an array/list for 40 items: https://stackoverflow.com/a/10762995/949129Here\'s the helper class I use for sanitising paths. I forget now why I had the fancy replacement option in it, but it\'s there as a cute bonus.Additional bonus method "IsValidLocalPath" too :)(** those which don\'t use regular expressions)Or you can just do