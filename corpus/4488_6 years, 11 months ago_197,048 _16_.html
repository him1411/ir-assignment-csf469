I would assume there\'s a simple LINQ query to do this, I\'m just not exactly sure how.  Please see code snippet below, the comment explains what I\'d like to do:If you override the equality of People then you can also use:Except should be significantly faster than the Where(...Any) variant since it can put the second list into a hashtable. Where(...Any) has a runtime of O(peopleList1.Count * peopleList2.Count) whereas variants based on HashSet<T> (almost) have a runtime of O(peopleList1.Count + peopleList2.Count).Except implicitly removes duplicates. That shouldn\'t affect your case, but might be an issue for similar cases.Or if you want fast code but don\'t want to override the equality:This variant does not remove duplicates.Since all of the solutions to date used fluent syntax, here is a solution in query expression syntax, for those interested:I think it is different enough from the answers given to be of interest to some, even thought it most likely would be suboptimal for Lists. Now for tables with indexed IDs, this would definitely be the way to go.Or if you want it without negation:Basically it says get all from peopleList2 where all ids in peopleList1 are different from id in peoplesList2. Just a little bit different approach from the accepted answer :)Bit late to the party but a good solution which is also Linq to SQL compatible is:Kudos to http://www.dotnet-tricks.com/Tutorial/linq/UXPF181012-SQL-Joins-with-CThis Enumerable Extension allow you to define a list of item to exclude and a function to use to find key to use to perform comparison.You can use it this wayHere is a working example that get IT skills that a job candidate does not\nalready have.