What\'s the C++ way of parsing a string (given as char *) into an int? Robust and clear error handling is a plus (instead of returning zero).In the new C++11 there are functions for that: stoi, stol, stoll, stoul and so on.It will throw an exception on conversion error.Even these new functions still have the same issue as noted by Dan: they will happily convert the string "11x" to integer "11".See more: http://en.cppreference.com/w/cpp/string/basic_string/stolHere is my first piece of advice: do not use stringstream for this. While at first it may seem simple to use, you\'ll find that you have to do a lot of extra work if you want robustness and good error handling.Here is an approach that intuitively seems like it should work:This has a major problem: str2int(i, "1337h4x0r") will happily return true and i will get the value 1337. We can work around this problem by ensuring there are no more characters in the stringstream after the conversion:We fixed one problem, but there are still a couple of other problems.What if the number in the string is not base 10? We can try to accommodate other bases by setting the stream to the correct mode (e.g. ss << std::hex) before trying the conversion. But this means the caller must know a priori what base the number is -- and how can the caller possibly know that? The caller doesn\'t know what the number is yet. They don\'t even know that it is a number! How can they be expected to know what base it is? We could just mandate that all numbers input to our programs must be base 10 and reject hexadecimal or octal input as invalid. But that is not very flexible or robust. There is no simple solution to this problem. You can\'t simply try the conversion once for each base, because the decimal conversion will always succeed for octal numbers (with a leading zero) and the octal conversion may succeed for some decimal numbers. So now you have to check for a leading zero. But wait! Hexadecimal numbers can start with a leading zero too (0x...). Sigh.Even if you succeed in dealing with the above problems, there is still another bigger problem: what if the caller needs to distinguish between bad input (e.g. "123foo") and a number that is out of the range of int (e.g. "4000000000" for 32-bit int)? With stringstream, there is no way to make this distinction. We only know whether the conversion succeeded or failed. If it fails, we have no way of knowing why it failed. As you can see, stringstream leaves much to be desired if you want robustness and clear error handling.This leads me to my second piece of advice: do no use Boost\'s lexical_cast for this. Consider what the lexical_cast documentation has to say:Where a higher degree of control is\n  required over conversions,\n  std::stringstream and\n  std::wstringstream offer a more\n  appropriate path. Where\n  non-stream-based conversions are\n  required, lexical_cast is the wrong\n  tool for the job and is not\n  special-cased for such scenarios.What?? We\'ve already seen that stringstream has a poor level of control, and yet it says stringstream should be used instead of lexical_cast if you need "a higher level of control". Also, because lexical_cast is just a wrapper around stringstream, it suffers from the same problems that stringstream does: poor support for multiple number bases and poor error handling.Fortunately, somebody has already solved all of the above problems. The C standard library contains strtol and family which have none of these problems.Pretty simple for something that handles all the error cases and also supports any number base from 2 to 36. If base is zero (the default) it will try to convert from any base. Or the caller can supply the third argument and specify that the conversion should only be attempted for a particular base. It is robust and handles all errors with a minimal amount of effort.Other reasons to prefer strtol (and family):There is absolutely no good reason to use any other method.This is a safer C way than atoi()C++ with standard library stringstream: (thanks CMS )With boost library: (thanks jk)Edit: Fixed the stringstream version so that it handles errors. (thanks to CMS\'s and jk\'s comment on original post)You can use Boost\'s lexical_cast, which wraps this in a more generic interface.\nlexical_cast<Target>(Source) throws bad_lexical_cast on failure.The good \'old C way still works. I recommend strtol or strtoul. Between the return status and the \'endPtr\', you can give good diagnostic output. It also handles multiple bases nicely.You can use the a stringstream from the C++ standard libraray:The stream state will be set to fail\n  if a non-digit is encountered when\n  trying to read an integer.See Stream pitfalls for pitfalls of errorhandling and streams in C++.You can use stringstream\'sThe C++ String Toolkit Library (StrTk) has the following solution:The InputIterator can be of either unsigned char*, char* or std::string iterators, and T is expected to be a signed int, such as signed int, int, or longI think these three links sum it up:stringstream and lexical_cast solutions are about the same as lexical cast is using stringstream.Some specializations of lexical cast use different approach see http://www.boost.org/doc/libs/release/boost/lexical_cast.hpp for details.  Integers and floats are now specialized for integer to string conversion.  One can specialize lexical_cast for his/her own needs and make it fast. This would be the ultimate solution satisfying all parties, clean and simple.Articles already mentioned show comparison between different methods of converting  integers <-> strings. Following approaches make sense:  old c-way, spirit.karma, fastformat, simple naive loop.  Lexical_cast is ok in some cases e.g. for int to string conversion.Converting string to int using lexical cast is not a good idea as it is 10-40 times slower than atoi depending on the platform/compiler used.Boost.Spirit.Karma seems to be the fastest library for converting integer to string.and basic simple loop from the article mentioned above is a fastest way to convert string to int, obviously not the safest one, strtol() seems like a safer solutionIf you have C++11, the appropriate solutions nowadays are the C++ integer conversion functions in <string>: stoi, stol, stoul, stoll, stoull.  They throw appropriate exceptions when given incorrect input and use the fast and small strto* functions under the hood.If you are stuck with an earlier revision of C++, it would be forward-portable of you to mimic these functions in your implementation.I like Dan Moulding\'s answer, I\'ll just add a bit of C++ style to it:It works for both std::string and const char* through the implicit conversion. It\'s also useful for base conversion, e.g. all to_int("0x7b") and to_int("0173") and to_int("01111011", 2) and to_int("0000007B", 16) and to_int("11120", 3) and to_int("3L", 34); would return 123.Unlike std::stoi it works in pre-C++11. Also unlike std::stoi, boost::lexical_cast and stringstream it throws exceptions for weird strings like "123hohoho".NB: This function tolerates leading spaces but not trailing spaces, i.e. to_int("  123") returns 123 while to_int("123   ") throws exception. Make sure this is acceptable for your use case or adjust the code.Such function could be part of STL...I like Dan\'s answer, esp because of the avoidance of exceptions. For embedded systems development and other low level system development, there may not be a proper Exception framework available. Added a check for white-space after a valid string...these three lines\nAdded a check for parsing errors too.\nHere is the complete function..I know three ways of converting String into int:Either use stoi(String to int) function or just go with Stringstream, the third way to go individual conversion, Code is below:1st Method2nd Method3rd Method - but not for an individual conversion You could use this defined method.And if you were to convert from String to an Integer, you would just do the following.The output would be 102.I know this is an older question, but I\'ve come across it so many times and, to date, have still not found a nicely templated solution having the following characteristics:So, here is mine, with a test strap.  Because it uses the C functions strtoull/strtoll under the hood, it always converts first to the largest type available.  Then, if you are not using the largest type, it will perform additional range checks to verify your type was not over(under)flowed. For this, it is a little less performant than if one properly chose strtol/strtoul.  However, it also works for shorts/chars and, to the best of my knowledge, there exists no standard library function that does that, too.Enjoy; hopefully someone finds it useful.StringToDecimal is the user-land method; it is overloaded so it can be called either like this:or this:I hate repeating the int type, so prefer the latter. This ensures that if the type of \'a\' changes one does not get bad results. I wish the compiler could figure it out like:...but, C++ does not deduce template return types, so that\'s the best I can get.The implementation is pretty simple:CstrtoxllWrapper wraps both strtoull and strtoll, calling whichever is necessary based on the template type\'s signed-ness and providing some additional guarantees (e.g. negative input is disallowed if unsigned and it ensures the entire string was converted).CstrtoxllWrapper is used by StringToSigned and StringToUnsigned with the largest type (long long/unsigned long long) available to the compiler; this allows the maximal conversion to be performed.  Then, if it is necessary, StringToSigned/StringToUnsigned performs the final range checks on the underlying type. Finally, the end-point method, StringToDecimal, decides which of the StringTo* template methods to call based on the underlying type\'s signed-ness.I think most of the junk can be optimized out by the compiler; just about everything should be compile-time deterministic. Any commentary on this aspect would be interesting to me!In C, you can use int atoi (const char * str),Parses the C-string str interpreting its content as an integral number, which is returned as a value of type int.