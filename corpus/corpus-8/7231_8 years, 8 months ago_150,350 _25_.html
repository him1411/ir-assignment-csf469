It\'s a pretty open ended question.  I\'ll be starting out a new project and am looking at different ORMs to integrate with database access.Do you have any favorites?\nAre there any you would advise staying clear of?I have stopped using ORMs.The reason is not any great flaw in the concept. Hibernate works well. Instead, I have found that queries have low overhead and I can fit lots of complex logic into large SQL queries, and shift a lot of my processing into the database.So consider just using the JDBC package.None, because having an ORM takes too much control away with small benefits. The time savings gained are easily blown away when you have to debug abnormalities resulting from the use of the ORM. Furthermore, ORMs discourage developers from learning SQL and how relational databases work and using this for their benefit.Many ORM\'s are great, you need to know why you want to add abstraction on top of JDBC. I can recommend http://www.jooq.org to you (disclaimer: I\'m the creator of jOOQ, so this answer is biased). jOOQ embraces the following paradigm:There are many other good ORM\'s. Especially Hibernate or iBATIS have a great community. But if you\'re looking for an intuitive, simple one, I\'ll say give jOOQ a try. You\'ll love it! :-)Check out this example SQL:And how it can be expressed in jOOQ:Hibernate, because it\'s basically the defacto standard in Java and was one of the driving forces in the creation of the JPA. It\'s got excellent support in Spring, and almost every Java framework supports it. Finally, GORM is a really cool wrapper around it doing dynamic finders and so on using Groovy.It\'s even been ported to .NET (NHibernate) so you can use it there too.Hibernate, because it:A few points on why (and when) to use ORM:I would recommend using MyBatis.  It is a thin layer on top of JDBC, it is very easy to map objects to tables and still use plain SQL, everything is under your control.I had a really good experience with Avaje Ebean when I was writing a medium sized JavaSE application. It uses standard JPA annotations to define entities, but exposes a much simpler API (No EntityManager or any of that attached/detached entities crap). It also lets you easily use SQL queries or event plain JDBC calls when necessary.It also has a very nice fluid and type-safe API for queries. You can write things like:SimpleORM, because it is straight-forward and no-magic. It defines all meta data structures in Java code and is very flexible.SimpleORM provides similar\n  functionality to Hibernate by mapping\n  data in a relational database to Java\n  objects in memory.  Queries can be\n  specified in terms of Java objects,\n  object identity is aligned with\n  database keys, relationships between\n  objects are maintained and modified\n  objects are automatically flushed to\n  the database with optimistic locks.But unlike Hibernate, SimpleORM uses a\n  very simple object structure and\n  architecture that avoids the need for\n  complex parsing, byte code processing\n  etc.  SimpleORM is small and\n  transparent, packaged in two jars of\n  just 79K and 52K in size, with only\n  one small and optional dependency\n  (Slf4j).  (Hibernate is over 2400K\n  plus about 2000K of dependent Jars.) \n  This makes SimpleORM easy to\n  understand and so greatly reduces\n  technical risk.Eclipse Link, for many reasons, but notably I feel like it has less bloat than other main stream solutions (at least less in-your-face bloat).Oh and Eclipse Link has been chosen to be the reference implementation for JPA 2.0While I share the concerns regarding Java replacements for free-form SQL queries, I really do think people criticizing ORM are doing so because of a generally poor application design.True OOD is driven by classes and relationships, and ORM gives you consistent mapping of different relationship types and objects.\nIf you use an ORM tool and end up coding query expressions in whatever query language the ORM framework supports (including, but not limited to Java expression trees, query methods, OQL etc.), you are definitely doing something wrong, i.e. your class model most likely doesn\'t support your requirements in the way it should. A clean application design doesn\'t really need queries on the application level. I\'ve been refactoring many projects people started out using an ORM framework in the same way as they were used to embed SQL string constants in their code, and in the end everyone was suprised about how simple and maintainable the whole application gets once you match up your class model with the usage model. Granted, for things like search functionality etc. you need a query language, but even then queries are so much constrained that creating an even complex VIEW and mapping that to a read-only persistent class is much nicer to maintain and look at than building expressions in some query language in the code of your application. The VIEW approach also leverages database capabilities and, via materialization, can be much better performance-wise than any hand-written SQL in your Java source.\nSo, I don\'t see any reason for a non-trivial application NOT to use ORM.