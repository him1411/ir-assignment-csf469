How do I get a list of all index & index columns in SQL Server 2005+? The closest I could get is:Which is not exactly what I want.\nWhat I want is, to list all user-defined indexes, (which means no indexes which support unique constraints & primary keys) with all columns (ordered by how do they appear in index definition) plus as much metadata as possible.There are two "sys" catalog views you can consult:\n\nThose will give you just about any info you could possibly want about indices and their columns.EDIT: This query\'s getting pretty close to what you\'re looking for:You can use the sp_helpindex to view all the indexes of one table.And for all the indexes, you can traverse sys.objects to get all the indexes for each table.None of the above did the job for me, but this does:If your names include spaces, add square brackets around them in the creation scripts.When the last Key column is all nulls, you know that none are missing.Filtering out primary keys etc as in the original request is trivial.NOTE: Take care with this solution as it doesn\'t distinguish indexed and included columns.--Short and sweet:Following gives what is similar as sp_helpindex tablenameHey guys, I didn\'t go through but I got what I wanted in the query posted by the original author.I used it (without conditions/filters) for my requirement but it gave incorrect resultsThe main problem was the results getting cross product without join condition on index_id this will work: this does not reurn the table name and you will get warnings for all tables without an index, if that is a problem, you can create a loop over the tables that have indexes like this:EDIT\nif you want, you can filter the data, here are some examples (these work for either method):I have needed to get particular indexes, their index columns and their included columns as well. Here is the query I have used:This is a way of backing into the indexes. You can use SHOWCONTIG to assess fragmentation. It will list all of the indexes for the database or table, along with statistics. I would caution that on a large database, it can be long-running. For me, one of the benefits of this approach is that you don\'t have to be an admin to use it.--Show fragmentation info on all indexes in a database...turn NOCOUNT back OFF when done--Show fragmentation info on all indexes on a table--Show fragmentation information on a specific indexI came up with this one, which is giving me the exact overview I need. What is helps is that you get one row per index into which the index columns are aggregated. May I hazard another answer to this saturated question?This is a liberal reworking of @marc_s answer, mixed with some stuff from @Tim Ford, with the goal of having a bit of a cleaner and simpler result set and final display and ordering for my current need.The following works on SQL Server 2014/2016 as well as any Microsoft Azure SQL Database.Produces a comprehensive result set that is easily exportable to Notepad/Excel for slicing and dicing and includesSince your profile states that you are using .NET you could use Server Managed Objects (SMO) programmatically... otherwise any of the above answers are fantastic.The above solution is elegant, but according to MS, INDEXKEY_PROPERTY is being deprecated. See: http://msdn.microsoft.com/en-us/library/ms186773.aspxbased on Tim Ford code, this is the right answer:In OracleIn SQL Server\nwith Just note that if you are going to use any of the above working queries to script your indexes, you need to incorporate filter_definition column from sys.indexes table in your queries to get the filter definition of non-clustered indexes in SQL 2008+AMHere is the best way to do it:I prefer using implicit joins as it\'s much easier for me to understand. You can remove the object_id reference as you might not need it.Cheers.First, please note that all the above queries may miss out or erroneously incorporate the INCLUDE columns of the indices. Also missing in some is the proper ordering and/or ASC/DESC option of the columns.Modified the above query by jona. As an aside, in many of the database I use, I install my own CLR CONCATENATE aggregate function, so the code below depends on something like this being present. The above SQL statements reduce to a much more maintainable:There are lots of concatenation aggregates out there if your environment allows CLR-based functions added to it.For unique columns per index:Using SQL Server 2016, this gives a complete list of all indexes, with an included dump of each table so you can see how the tables relate. It also shows columns included in covering indexes:The query below includes all of the pertinent information for the user-defined indexes, (no indexes for unique constraints & primary keys) with all columns:As an added bonus, the below query is formatted to write out the create index and drop index scripts: