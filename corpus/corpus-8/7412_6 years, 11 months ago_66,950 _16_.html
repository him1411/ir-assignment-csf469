The Jackson library\'s ObjectMapper class seems to be thread safe.Does this mean that I should declare my ObjectMapper as a static field like thisinstead of as an instance-level field like this?Yes, that is safe and recommended.The only caveat from the page you referred is that you can\'t be modifying configuration of the mapper once it is shared; but you are not changing configuration so that is fine. If you did need to change configuration, you would do that from the static block and it would be fine as well.EDIT: (2013/10)With 2.0 and above, above can be augmented by noting that there is an even better way: use ObjectWriter and ObjectReader objects, which can be constructed by ObjectMapper.\nThey are fully immutable, thread-safe, meaning that it is not even theoretically possible to cause thread-safety issues (which can occur with ObjectMapper if code tries to re-configure instance).Although ObjectMapper is thread safe, I would strongly discourage from declaring it as a static variable, especially in multithreaded application.\nNot even because it is a bad practice, but because you are running a heavy risk of deadlocking. I am telling it from my own experience. I created an application with 4 identical threads that were getting and processing JSON data from web services.\nMy application was frequently stalling on the following command, according to the thread dump:Beside that, performance was not good.\nWhen I replaced static variable with the instance based variable, stalling disappeared and performance quadrupled. I.e. 2.4 millions JSON documents were processed in 40min.56sec., instead of 2.5 hours previously.Although it is safe to declare a static ObjectMapper in terms of thread safety, you should be aware that constructing static Object variables in Java is considered bad practice. For more details, see Why are static variables considered evil? (and if you\'d like, my answer)In short, statics should be avoided because the make it difficult to write concise unit tests. For example, with a static final ObjectMapper, you can\'t swap out the JSON serialization for dummy code or a no-op.In addition, a static final prevents you from ever reconfiguring ObjectMapper at runtime. You might not envision a reason for that now, but if you lock yourself into a static final pattern, nothing short of tearing down the classloader will let you re-initialize it.In the case of ObjectMapper its fine, but in general it is bad practice and there is no advantage over using a singleton pattern or inversion-of-control to manage your long-lived objects.com.fasterxml.jackson.databind.type.TypeFactory._hashMapSuperInterfaceChain(HierarchicType)The method _hashMapSuperInterfaceChain in class com.fasterxml.jackson.databind.type.TypeFactory is synchronized. \nAm seeing contention on the same at high loads.May be another reason to avoid a static ObjectMapper