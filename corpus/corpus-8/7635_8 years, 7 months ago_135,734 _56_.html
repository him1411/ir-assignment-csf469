I realise the second one avoids the overhead of a function call (update, is actually a language construct), but it would be interesting to know if one is better than the other. I have been using unset() for most of my coding, but I\'ve recently looked through a few respectable classes found off the net that use $var = null instead.Is there a preferred one, and what is the reasoning?It was mentioned in the unset manual\'s page in 2009:unset() does just what its name says - unset a variable. It does not force immediate memory freeing. PHP\'s garbage collector will do it when it see fits - by intention as soon, as those CPU cycles aren\'t needed anyway, or as late as before the script would run out of memory, whatever occurs first.If you are doing $whatever = null; then you are rewriting variable\'s data. You might get memory freed / shrunk faster, but it may steal CPU cycles from the code that truly needs them sooner, resulting in a longer overall execution time.(Since 2013, that unset man page don\'t include that section anymore)Note that until php5.3, if you have two objects in circular reference, such as in a parent-child relationship, calling unset() on the parent object will not free the memory used for the parent reference in the child object. (Nor will the memory be freed when the parent object is garbage-collected.) (bug 33595)The question "difference between unset and = null" details some differences:unset($a) also removes $a from the symbol table; for example:Outputs:But when $a = null is used:It seems that $a = null is a bit faster than its unset() counterpart: updating a symbol table entry appears to be faster than removing it.unset is not actually a function, but a language construct. It is no more a function call than a return or an include.Aside from performance issues, using unset makes your code\'s intent much clearer.By doing an unset() on a variable, you\'ve essentially marked the variable for \'garbage collection\' (PHP doesn\'t really have one, but for example\'s sake) so the memory isn\'t immediately available. The variable no longer houses the data, but the stack remains at the larger size. Doing the null method drops the data and shrinks the stack memory almost immediately.This has been from personal experience and others as well. See the comments of the unset() function here.I personally use unset() between iterations in a loop so that I don\'t have to have the delay of the stack being yo-yo\'d in size. The data is gone, but the footprint remains. On the next iteration, the memory is already being taken by php and thus, quicker to initialize the next variable.Per that it seems like "= null" is faster.PHP 5.4 results:PHP 5.3 results:PHP 5.2 results:PHP 5.1 results:Things start to look different with PHP 5.0 and 4.4.5.0:4.4:Keep in mind microtime(true) doesn\'t work in PHP 4.4 so I had to use the microtime_float example given in php.net/microtime / Example #1.It makes a difference with array elements.Consider this exampleHere, the key  \'test\' still exists. However, in this examplethe key no longer exists.It works in different way for varaiables copied by reference:Regarding objects, especially in lazy-load scenario, one should consider garbage collector is running in idle CPU cycles, so presuming you\'re going into trouble when a lot of objects are loading small time penalty will solve the memory freeing.Use time_nanosleep to enable GC to collect memory.\nSetting variable to null is desirable.Tested on production server, originally the job consumed 50MB and then was halted.\nAfter nanosleep was used  14MB was constant memory consumption.One should say this depends on GC behaviour which may change from PHP version to version.\nBut it works on PHP 5.3 fine.eg. this sample (code taken form VirtueMart2 google feed)I still doubt about this, but I\'ve tried it at my script and I\'m using xdebug to know how it will affect my app memory usage.\nThe script is set on my function like this :And I add unset just before the return code and it give me : 160200\nthen I try to change it with $sql = NULL and it give me : 160224 :)But there is something unique on this comparative when I am not using unset() or NULL, xdebug give me 160144 as memory usageSo, I think giving line to use unset() or NULL will add process to your application and it will be better to stay origin with your code and decrease the variable that you are using as effective as you can .Correct me if I\'m wrong, thanksI created a new performance test for unset and =null, because as mentioned in the comments the here written has an error (the recreating of the elements). \nI used arrays, as you see it didn\'t matter now.But i can only test it on an PHP 5.5.9 server, here the results:\n - took 4.4571571350098 seconds\n - took 4.4425978660583 secondsI prefer unset for readability reasons.unset code if not freeing immediate memory is still very helpful and would be a good practice to do this each time we pass on code steps before we exit a method. take note its not about freeing immediate memory. \nimmediate memory is for CPU, what about secondary memory which is RAM.and this also tackles about preventing memory leaks. please see this link\nhttp://www.hackingwithphp.com/18/1/11/be-wary-of-garbage-collection-part-2i have been using unset for a long time now.better practice like this in code to instanly unset all variable that have been used already as array. and just unset($data); to free all variable usage.please see related topic to unsetHow important is it to unset variables in PHP?[bug]For the record, and excluding the time that it takes:It returnsConclusion, both null and unset free memory as expected (not only at the end of the execution).   Also, reassigning a variable holds the value twice at some point (520216 versus 438352)