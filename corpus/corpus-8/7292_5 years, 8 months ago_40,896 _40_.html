Clang adds a keyword instancetype that, as far as I can see, replaces id as a return type in -alloc and init. Is there a benefit to using instancetype instead of id?There definitely is a benefit. When you use \'id\', you get essentially no type checking at all. With instancetype, the compiler and IDE know what type of thing is being returned, and can check your code better and autocomplete better.Only use it where it makes sense of course (i.e. a method that is returning an instance of that class); id is still useful.Yes, there are benefits to using instancetype in all cases where it applies. I\'ll explain in more detail, but let me start with this bold statement: Use instancetype whenever it\'s appropriate, which is whenever a class returns an instance of that same class.In fact, here\'s what Apple now says on the subject:In your code, replace occurrences of id as a return value with instancetype where appropriate. This is typically the case for init methods and class factory methods. Even though the compiler automatically converts methods that begin with \xe2\x80\x9calloc,\xe2\x80\x9d \xe2\x80\x9cinit,\xe2\x80\x9d or \xe2\x80\x9cnew\xe2\x80\x9d and have a return type of id to return instancetype, it doesn\xe2\x80\x99t convert other methods. Objective-C convention is to write instancetype explicitly for all methods.With that out of the way, let\'s move on and explain why it\'s a good idea.First, some definitions:For a class factory, you should always use instancetype. The compiler does not automatically convert id to instancetype. That id is a generic object. But if you make it an instancetype the compiler knows what type of object the method returns.This is not an academic problem. For instance, [[NSFileHandle fileHandleWithStandardOutput] writeData:formattedData] will generate an error on Mac OS X (only) Multiple methods named \'writeData:\' found with mismatched result, parameter type or attributes. The reason is that both NSFileHandle and NSURLHandle provide a writeData:. Since [NSFileHandle fileHandleWithStandardOutput] returns an id, the compiler is not certain what class writeData: is being called on.You need to work around this, using either:or:Of course, the better solution is to declare fileHandleWithStandardOutput as returning an instancetype. Then the cast or assignment isn\'t necessary.(Note that on iOS, this example won\'t produce an error as only NSFileHandle provides a writeData: there. Other examples exist, such as length, which returns a CGFloat from UILayoutSupport but a NSUInteger from NSString.)For initializers, it\'s more complicated. When you type this:\xe2\x80\xa6the compiler will pretend you typed this instead:This was necessary for ARC. This is described in Clang Language Extensions Related result types. This is why people will tell you it isn\'t necessary to use instancetype, though I contend you should. The rest of this answer deals with this.There\'s three advantages:It\'s true that there\'s no technical benefit to returning instancetype from an init. But this is because the compiler automatically converts the id to instancetype. You are relying on this quirk; while you\'re writing that the init returns an id, the compiler is interpreting it as if it returns an instancetype.These are equivalent to the compiler:These are not equivalent to your eyes. At best, you will learn to ignore the difference and skim over it. This is not something you should learn to ignore.While there\'s no difference with init and other methods, there is a difference as soon as you define a class factory.These two are not equivalent:You want the second form. If you are used to typing instancetype as the return type of a constructor, you\'ll get it right every time.Finally, imagine if you put it all together: you want an init function and also a class factory.If you use id for init, you end up with code like this:But if you use instancetype, you get this:It\'s more consistent and more readable. They return the same thing, and now that\'s obvious.Unless you\'re intentionally writing code for old compilers, you should use instancetype when appropriate.You should hesitate before writing a message that returns id. Ask yourself: Is this returning an instance of this class? If so, it\'s an instancetype.There are certainly cases where you need to return id, but you\'ll probably use instancetype much more frequently.Above answers are more than enough to explain this question. I would just like to add an example for the readers to understand it in terms of coding.ClassAClass BTestViewController.mYou also can get detail at The Designated Initializer****\nThis keyword can only be used for return type, that it matches with return type of receiver. init method always declared to return instancetype.\nWhy not make the return type Party for party instance, for example?\nThat would cause a problem if the Party class was ever subclassed. The subclass would inherit all of the methods from Party, including initializer and its return type. If an instance of the subclass was sent this initializer message, that would be return? Not a pointer to a Party instance, but a pointer to an instance of subclass. You might think that is No problem, I will override the initializer in the subclass to change the return type. But in Objective-C, you cannot have two methods with the same selector and different return types (or arguments). By specifying that an initialization method return "an instance of the receiving object," you would never have to worry what happens in this situation.\n****\nBefore the instancetype has been introduced in Objective-C, initializers return id (eye-dee). This type is defined as "a pointer to any object". (id is a lot like void * in C.) As of this writing, XCode class templates still use id as the return type of initializers added in boilerplate code.\nUnlike instancetype, id can be used as more than just a return type. You can declare variables or method parameters of type id when you are unsure what type of object the variable will end up pointing to.\nYou can use id when using fast enumeration to iterate over an array of multiple or unknow types of objects. Note that because id is undefined as "a pointer to any object," you do not include an * when declaring a variable or object parameter of this type.