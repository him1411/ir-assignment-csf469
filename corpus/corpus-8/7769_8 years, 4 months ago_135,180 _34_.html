I\'m having a debate with a co-worker about throwing exceptions from constructors, and thought I would like some feedback.Is it ok to throw exceptions from constructors, from a design point of view?Lets say I\'m wrapping a posix mutex in a class, it would look something like this:My question is, is this the standard way to do it? Because if the pthread mutex_init call fails the mutex object is unusable so throwing an exception ensures that the mutex won\'t be created.Should I rather create a member function init for the Mutex class and call pthread mutex_init within which would return a bool based on pthread mutex_init\'s return? This way I don\'t have to use exceptions for such a low level object.Yes, throwing an exception from the failed constructor is the standard way of doing this. Read this FAQ about Handling a constructor that fails for more information. Having a init() method will also work, but everybody who creates the object of mutex has to remember that init() has to be called. I feel it goes against the RAII principle.If you do throw an exception from a constructor, keep in mind that you need to use the function try/catch syntax if you need to catch that exception in a constructor initializer list.e.g.vs.Throwing an exception is the best way of dealing with constructor failure. You should particularly avoid half-constructing an object and then relying on users of your class to detect construction failure by testing flag variables of some sort.On a related point, the fact that you have several different exception types for dealing with mutex errors worries me slightly. Inheritance is a great tool, but it can be over-used. In this case I would probably prefer a single MutexError exception, possibly containing an informative error message.It is OK to throw from your constructor, but you should make sure that\nyour object is constructed after main has started and before it\nfinishes:the output:the destructors are not called, so if a exception need to be thrown in a constructor, a lot of stuff(e.g. clean up?) to do.If your project generally relies on exceptions to distinguish bad data from good data, then throwing an exception from the constructor is better solution than not throwing. If exception is not thrown, then object is initialized in a zombie state. Such object needs to expose a flag which says whether the object is correct or not. Something like this:Problem with this approach is on the caller side. Every user of the class would have to do an if before actually using the object. This is a call for bugs - there\'s nothing simpler than forgetting to test a condition before continuing.In case of throwing an exception from the constructor, entity which constructs the object is supposed to take care of problems immediately. Object consumers down the stream are free to assume that object is 100% operational from the mere fact that they obtained it.This discussion can continue in many directions.For example, using exceptions as a matter of validation is a bad practice. One way to do it is a Try pattern in conjunction with factory class. If you\'re already using factories, then write two methods:With this solution you can obtain the status flag in-place, as a return value of the factory method, without ever entering the constructor with bad data.Second thing is if you are covering the code with automated tests. In that case every piece of code which uses object which does not throw exceptions would have to be covered with one additional test - whether it acts correctly when IsValid() method returns false. This explains quite well that initializing objects in zombie state is a bad idea.Apart from the fact that you do not need to throw from the constructor in your specific case because pthread_mutex_lock actually returns an EINVAL if your mutex has not been initialized and you can throw after the call to lock as is done in std::mutex:then in general throwing from constructors is ok for acquisition errors during construction, and in compliance with RAII ( Resource-acquisition-is-Initialization ) programming paradigm.Check this example on RAII Focus on these statements:The first statement is RAII and noexcept. In (2) it is clear that RAII is applied on lock_guard and it actually can throw , whereas in (3) ofstream seems not to be RAII , since the objects state has to be checked by calling is_open() that checks the failbit flag.At first glance it seems that it is undecided on what it the standard way and in the first case std::mutex does not throw in initialization , *in contrast to OP implementation * . In the second case it will throw whatever is thrown from std::mutex::lock, and in the third there is no throw at all. Notice the differences:(1) Can be declared static, and will actually be declared as a member variable\n(2) Will never actually be expected to be declared as a member variable\n(3) Is expected to be declared as a member variable, and the underlying resource may not always be available.All these forms are RAII; to resolve this, one must analyse RAII.This does not require you to initialize and connect everything on construction. For example when you would create a network client object you would not actually connect it to the server upon creation, since it is a slow operation with failures. You would instead write a connect function to do just that. On the other hand you could create the buffers or just set its state.Therefore, your issue boils down to defining your initial state. If in your case your initial state is mutex must be initialized then you should throw from the constructor. In contrast it is just fine not to initialize then ( as is done in std::mutex ), and define your invariant state as mutex is created . At any rate the invariant is not compromized necessarily by the state of its member object, since the mutex_ object mutates between locked and unlocked through the Mutex public methods Mutex::lock() and Mutex::unlock().The only time you would NOT throw exceptions from constructors is if your project has a rule against using exceptions (for instance, Google doesn\'t like exceptions). In that case, you wouldn\'t want to use exceptions in your constructor any more than anywhere else, and you\'d have to have an init method of some sort instead.Although I have not worked C++ at a professional level, in my opinion, it is OK to throw exceptions from the constructors. I do that(if needed) in .Net. Check out this and this link. It might be of your interest.