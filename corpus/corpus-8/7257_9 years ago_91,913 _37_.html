What would be better practice when giving a function the original variable to work with:or:IOW: Is there any reason to pick one over another?My rule of thumb is:Use pointers if you want to do pointer arithmetic with them (e.g. incrementing the pointer address to step through an array) or if you ever have to pass a NULL-pointer.Use references otherwise.I really think you will benefit from establishing the following function calling coding guidelines:As in all other places, always be const-correct.Only pass a value by pointer if the value 0/NULL is a valid input in the current context.Rationale 1: As a caller, you see that whatever you pass in must be in a usable state.Rationale 2: As called, you know that whatever comes in is in a usable state. Hence, no NULL-check or error handling needs to be done for that value.Rationale 3: Rationales 1 and 2 will be compiler enforced. Always catch errors at compile time if you can.If a function argument is an out-value, then pass it by reference.Choose "pass by value" over "pass by const reference" only if the value is a POD (Plain old Datastructure) or small enough (memory-wise) or in other ways cheap enough (time-wise) to copy.This ultimately ends up being subjective. The discussion thus far is useful, but I don\'t think there is a correct or decisive answer to this. A lot will depend on style guidelines and your needs at the time.While there are some different capabilities (whether or not something can be NULL) with a pointer, the largest practical difference for an output parameter is purely syntax. Google\'s C++ Style Guide (https://google.github.io/styleguide/cppguide.html#Reference_Arguments), for example, mandates only pointers for output parameters, and allows only references that are const. The reasoning is one of readability: something with value syntax should not have pointer semantic meaning. I\'m not suggesting that this is necessarily right or wrong, but I think the point here is that it\'s a matter of style, not of correctness.You should pass a pointer if you are going to modify the value of the variable.\nEven though technically passing a reference or a pointer are the same, passing a pointer in your use case is more readable as it "advertises" the fact that the value will be changed by the function.If you have a parameter where you may need to indicate the absence of a value, it\'s common practice to make the parameter a pointer value and pass in NULL.A better solution in most cases (from a safety perspective) is to use boost::optional. This allows you to pass in optional values by reference and also as a return value.Pointers Vs. ReferecesReferences are less powerful than pointers:1) Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.3) A reference must be initialized when declared. There is no such restriction with pointersDue to the above limitations, references in C++ cannot be used for implementing data structures like Linked List, Tree, etc. In Java, references don\xe2\x80\x99t have above restrictions, and can be used to implement all data structures. References being more powerful in Java, is the main reason Java doesn\xe2\x80\x99t need pointers.References are safer and easier to use:1) Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don\xe2\x80\x99t refer to a valid location2) Easier to use: References don\xe2\x80\x99t need dereferencing operator to access the value. They can be used like normal variables. \xe2\x80\x98&\xe2\x80\x99 operator is needed only at the time of declaration. Also, members of an object reference can be accessed with dot operator (\xe2\x80\x98.\xe2\x80\x99), unlike pointers where arrow operator (->) is needed to access members.Together with the above reasons, there are few places like copy constructor argument where pointer cannot be used. Reference must be used pass the argument in copy constructor. Similarly references must be used for overloading some operators like ++.A reference is an implicit pointer. Basically you can change the value the reference points to but you can\'t change the reference to point to something else. So my  2 cents is that if you only want to change the value of a parameter pass it as a reference but if you need to change the parameter to point to a different object pass it using a pointer.Consider C#\'s out keyword. The compiler requires the caller of a method to apply the out keyword to any out args, even though it knows already if they are. This is intended to enhance readability. Although with modern IDEs I\'m inclined to think that this is a job for syntax (or semantic) highlighting.Use a reference when you can, use a pointer when you have to.\nFrom C++ FAQ: "When should I use references, and when should I use pointers?"Pass by const reference unless there is a reason you wish to change/keep the contents you are passing in.This will be the most efficient method in most cases.Make sure you use const on each parameter you do not wish to change, as this not only protects you from doing something stupid in the function, it gives a good indication to other users what the function does to the passed in values. This includes making a pointer const when you only want to change whats pointed to...Pointers:References: