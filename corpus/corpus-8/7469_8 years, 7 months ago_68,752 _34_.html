I\'ve looked up what this does, but does anyone actually have an example of when you would use the strictfp keyword in Java? Has anyone actually found a use for this?Would there be any side-effects of just putting it on all my floating point operations?Strictfp ensures that you get exactly the same results from your floating point calculations on every platform.  If you don\'t use strictfp, the JVM implementation is free to use extra precision where available.From the JLS:Within an FP-strict expression, all\n  intermediate values must be elements\n  of the float value set or the double\n  value set, implying that the results\n  of all FP-strict expressions must be\n  those predicted by IEEE 754 arithmetic\n  on operands represented using single\n  and double formats. Within an\n  expression that is not FP-strict, some\n  leeway is granted for an\n  implementation to use an extended\n  exponent range to represent\n  intermediate results; the net effect,\n  roughly speaking, is that a\n  calculation might produce "the correct\n  answer" in situations where exclusive\n  use of the float value set or double\n  value set might result in overflow or\n  underflow.In other words, it\'s about making sure that Write-Once-Run-Anywhere actually means Write-Once-Get-Equally-Wrong-Results-Everywhere.With strictfp your results are portable, without it they are more likely to be accurate.Wikipedia actually has a good article about this topic here, with a link to the Java specification.Reading between the lines, the implication is that if you don\'t specify strictfp, then the JVM and JIT compiler have license to compute your floating-point calculations however they want.  In the interest of speed, they will most likely delegate the computation to your processor.  With strictfp on, the computations have to conform to IEEE 754 arithmetic standards, which, in practice, probably means that the JVM will do the computation.So why would you want to use strictfp?  One scenario I can see is in a distributed application (or multiplayer game) where all floating-point calculations need to be deterministic no matter what the underlying hardware or CPU is.  What\'s the trade-off?  Most likely execution time.Here are several references:jGuru: What is the strictfp modifier for? When would I consider using it?Basically, what it all boils down to is whether or not you care that the results of floating-point expressions in your code are fast or predictable. For example, if you need the answers that your code comes up with which uses floating-point values to be consistent across multiple platforms then use strictfp.strictfp - Java Glossary Floating point hardware calculates with more precision, and with a greater range of values than the Java specification requires. It would be confusing if some platforms gave more precision than others. When you use the strictfp modifier on a method or class, the compiler generates code that adheres strictly to the Java spec for identical results on all platforms. Without strictfp, is it is slightly laxer, but not so lax as to use the guard bits in the Pentium to give 80 bits of precision.And finally the actual Java Language Specification, \xc2\xa715.4 FP-strict Expressions:  Within an FP-strict expression, all intermediate values must be elements of the float value set or the double value set, implying that the results of all FP-strict expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats. Within an expression that is not FP-strict, some leeway is granted for an implementation to use an extended exponent range to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the float value set or double value set might result in overflow or underflow.I\'ve never personally had a use for it, though.It all began with a story, When java was being developed by James Gosling, Herbert and rest of his team. They had this crazy thing in mind called platform independency. They wanted to make oak(Java) so much better that it would run exactly same on any machine having different instruction set, even running different operating systems. But, there was a problem with decimal point numbers also known as floating point and double in programming languages. Some machines were built targeting efficiency while rest were targeting accuracy. So, the later(more accurate) machines had size of floating point as 80 bits while the former(more efficient/faster) machines had 64 bit doubles. But, this was against there core idea of building a platform independent language. Also, this might lead to loss of precision/data when a code is built on some machine(having double of 64 bit size) and run on another kind of machine(having double of 80 bit size).Up-Sizing can be tolerated but Down-Sizing can\'t be. \nSo, they came across a concept of strictfp i.e. strict floating point. If you use this keyword with a class/function then its floating point and doubles have a consistent size over any machine. i.e. 32/64 -bit respectively.As the other answers mentioned it cause the intermediate floating point results to conform to the IEEE specification.  In particular x86 processors can store intermediate results with different precision from the IEEE spec.  The situation gets more complicated when the JIT optimizes a particular computation; the order the instructions could be different each time resulting in slightly different rounding.The overhead incurred by strictfp likely to be very processor and JIT dependent.\nThis wikipedia article on SSE2 seems to have some insight into the problem.\nSo if the JIT can generate SSE instructions to perform a calculation it seems that strictfp will not have any overhead. In my current project there are a few places where I use strictfp.  There is a point where  potential cosmic rays need to be removed from pixel values.  If some outside researcher has the the same pixel value and cosmic ray in front them they should get the same resulting value as our software.strictfp is a modifier which restricts floating point calculations as per IEEE 754.This can be used on whole class like "public strictfp class StrictFpModifierExample{}" or on method "public strictfp void example()".If it is used on class than all methods will follow IEEE 754 and if used on method then particular method will follow IEEE 754. Why it is used??:::\nAs different platforms have different floating point hardware which calculates with more precision and greater range  of values than the java specification requires which may produce  diffrent output on diffrent plateforms.so it confirms the same output irrespective of diffrent plateformsstrictfp also ensures to take advantage of the speed and precision of the extended precision floating-point operations.There is no disadvantage with this keyword we can use when we are doing floating point calculationsMy last point is --What is IEEE754 in short\nIEEE 754 defines standard method for both floating point calculations and storage of floating point values in either single (32-bit, used in Java floats) or double (64-bit, used in Java doubles) precision.It also defines norms for intermediate calculations and for extended precision formats.strictfp is a keyword and can be used as a non Non-access modifier for classes or a methods (but never variables). Marking a class as strictfp means that any method code in the class will conform to the IEEE 754 standard rules for floating points. Without that modifier, floating points used in the methods might behave in a platform-dependent way. With it you can predict how your floating points will behave regardless of the underlying platform the JVM is running on. The downside is that if the underlying platform is capable of supporting greater precision, a strictfp method won\'t be able to take advantage of it.If you don\'t declare a class as strictfp, you can still get strictfp behavior on a method-by-method basis, by declaring a method as strictfp.~ SCJP Sun\xc2\xaeCertified Programmer for Java\xe2\x84\xa2 6 - Kathy Sierra & Bert Bates ~