I have read some articles saying that git bisect is awesome, however I\'m not native speaker and I can\'t understand why it\'s awesome.Could you please demonstrate on some code sample what is so amazing about it? Is it just like svn blame?The idea behind git bisect is to perform a binary search in the history to find a particular regression. Imagine that you have the following development history:You know that your program is not working properly at the current revision, and that it was working at the revision 0. So the regression was likely introduced in one of the commits 1, 2, 3, 4, 5, current.You could try to check out each commit, build it, check if the regression is present or not. If there is a large number of commits, this can take a long time. This is a linear search. We can do better by doing a binary search. This is what the git bisect command does. At each step it tries to reduce the number of revisions that are potentially bad by half.You\'ll use the command like this:After this command, git will checkout a commit. In our case, it\'ll be commit 3. You need to build your program, and check whether or not the regression is present. You\'ll also need to tell git the status of this revision with either git bisect bad if the regression is present, or git bisect good if it is not.Let\'s suppose that the regression was introduced in commit 4. Then the regression is not present in this revision, and we tell it to git.It will then checkout another commit. Either 4 or 5 (as there are only two commits). Let\'s suppose it picked 5. After a build we test the program and see that the regression is present. We then tell it to git:We test the last revision, 4. And since it is the one that introduced the regression, we tell it to git:In this simple situation, we only had to test 3 versions (3, 4, 5) instead of 4 (1, 2, 3, 4). This is a small win, but this is because our history is so small. If the search range is of N commits, we should expect to test 1 + log2 N commits with git bisect instead of roughly N / 2 commits with a linear search.Once you\'ve found the commit that introduced the regression, you can study it to find the issue. Once this is done, you use git bisect reset to put everything back on the original state before using git bisect command.If you have an automated test script that has exit status 0 iff the test is OK, you can automatically find the bug with bisect run:Other useful actions:Stay on the first failing commit after bisect instead of going back to master:start + initial bad and good in one go:is the same as:See what has been tested so far (by manual good and bad or run):Sample output:Consider this test repo if you want to play around with the command.Bisecting: X revisions left to test after this (roughly Y steps)Issue still exists?Just to add a further point:We can specify a file name or path to  git bisect start in case we know that the bug has come from particular files.\nFor example, \nSuppose we knew that the changes that caused the regression were in the com/workingDir\ndirectory then we can run git bisect start com/workingDir This means that\nonly the commits that changed the contents of this directory will be checked, and\nthis makes things even faster.Also,If it\xe2\x80\x99s difficult  to tell if a particular commit is good or bad, you\ncan run git bisect skip, which will ignore it. Given there are enough other\ncommits, git bisect will use another to narrow the search instead.$ git bisect .. bascically a Git tool for debugging. \'Git Bisect\' debugs by going through the previous commits since your last (known) working commit. It uses binary search to go through all those commits, to get to the one which introduced the regression/bug.$ git bisect start  # Starting bisect$ git bisect bad  # stating that the current commit (v1.5) has the regression/ setting \'bad\' point$ git bisect good v1.0  # mentioning it the last good working commit (without regression)This mentioning of \'bad\' and \'good\' points will help git bisect (binary search) pick the middle element (commit v1.3). If the regression is there at commit v1.3, you\'ll set it as the new \'bad\' point i.e. (Good -> v1.0 and Bad -> v1.3) or similarly if the commit v1.3 is bug-free you\'ll set it as the new \'Good point\' i.e. (*Good -> v1.3 and Bad -> v1.6).