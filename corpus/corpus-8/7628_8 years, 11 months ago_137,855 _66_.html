Does C++ support \'finally\' blocks?What is the RAII idiom?What is the difference between C++\'s RAII idiom and C#\'s \'using\' statement?No, C++ does not support \'finally\' blocks.  The reason is that C++ instead supports RAII: "Resource Acquisition Is Initialization" -- a poor name\xe2\x80\xa0 for a really useful concept.  The idea is that an object\'s destructor is responsible for freeing resources.  When the object has automatic storage duration, the object\'s destructor will be called when the block in which it was created exits -- even when that block is exited in the presence of an exception.  Here is Bjarne Stroustrup\'s explanation of the topic.A common use for RAII is locking a mutex:RAII also simplifies using objects as members of other classes. When the owning class\' is destructed, the resource managed by the RAII class gets released because the destructor for the RAII-managed class gets called as a result.  This means that when you use RAII for all members in a class that manage resources, you can get away with using a very simple, maybe even the default, destructor for the owner class since it doesn\'t need to manually manage its member resource lifetimes. (Thanks to Mike B for pointing this out.)For those familliar with C# or VB.NET, you may recognize that RAII is similar to .NET deterministic destruction using IDisposable and \'using\' statements.  Indeed, the two methods are very similar.  The main difference is that RAII will deterministically release any type of resource -- including memory.  When implementing IDisposable in .NET (even the .NET language C++/CLI), resources will be deterministically released except for memory.  In .NET, memory is not deterministically released; memory is only released during garbage collection cycles.Â \xe2\x80\xa0 Some people believe that "Destruction is Resource Relinquishment" is a more accurate name for the RAII idiom.In C++ the finally is NOT required because of RAII.RAII moves the responsibility of exception safety from the user of the object to the designer (and implementer) of the object. I would argue this is the correct place as you then only need to get exception safety correct once (in the design/implementation). By using finally you need to get exception safety correct every time you use an object.Also IMO the code looks neater (see below).Example:A database object. To make sure the DB connection is used it must be opened and closed. By using RAII this can be done in the constructor/destructor.The use of RAII makes using a DB object correctly very easy. The DB object will correctly close itself by the use of a destructor no matter how we try and abuse it.When using finally the correct use of the object is delegated to the user of the object. i.e. It is the responsibility of the object user to correctly to explicitly close the DB connection. Now you could argue that this can be done in the finaliser, but resources may have limited availability or other constraints and thus you generally do want to control the release of the object and not rely on the non deterministic behavior of the garbage collector.Also this is a simple example.\nWhen you have multiple resources that need to be released the code can get complicated.A more detailed analysis can be found here: http://accu.org/index.php/journals/236In C++11, if needed, RAII allows to make a finally:example of use:the output will be:Personally I used this few times to ensure to close POSIX file descriptor in a C++ program.Having a real class that manage resources and so avoids any kind of leaks is usually better, but this finally is useful in the cases where making a class sounds like an overkill.Besides, I like it better than other languages finally because if used naturally you write the closing code nearby the opening code (in my example the new and delete) and destruction follows construction in LIFO order as usual in C++. The only downside is that you get an auto variable you don\'t really use and the lambda syntax make it a little noisy (in my example in the fourth line only the word finally and the {}-block on the right are meaningful, the rest is essentially noise).Another example:The disable member is useful if the finally has to be called only in case of failure. For example, you have to copy an object in three different containers, you can setup the finally to undo each copy and disable after all copies are successful. Doing so, if the destruction cannot throw, you ensure the strong guarantee.disable example:Beyond making clean up easy with stack-based objects, RAII is also useful because the same \'automatic\' clean up occurs when the object is a member of another class.  When the owning class is destructed, the resource managed by the RAII class gets cleaned up because the dtor for that class gets called as a result.This means that when you reach RAII nirvana and all members in a class use RAII (like smart pointers), you can get away with a very simple (maybe even default) dtor for the owner class since it doesn\'t need to manually manage its member resource lifetimes.why is it that even managed languages provide a finally-block despite resources being deallocated automatically by the garbage collector anyway?Actually, languages based on Garbage collectors need "finally" more. A garbage collector does not destroy your objects in a timely manner, so it can not be relied upon to clean up non-memory related issues correctly.In terms of dynamically-allocated data, many would argue that you should be using smart-pointers.However...RAII moves the responsibility of exception safety from the user of the object to the designerSadly this is its own downfall.  Old C programming habits die hard.  When you\'re using a library written in C or a very C style, RAII won\'t have been used. Short of re-writing the entire API front-end, that\'s just what you have to work with.  Then the lack of "finally" really bites.Sorry for digging up such an old thread, but there is a major error in the following reasoning:RAII moves the responsibility of exception safety from the user of the object to the designer (and implementer) of the object. I would argue this is the correct place as you then only need to get exception safety correct once (in the design/implementation). By using finally you need to get exception safety correct every time you use an object.More often than not, you have to deal with dynamically allocated objects, dynamic numbers of objects etc. Within the try-block, some code might create many objects (how many is determined at runtime) and store pointers to them in a list. Now, this is not an exotic scenario, but very common. In this case, you\'d want to write stuff likeOf course the list itself will be destroyed when going out of scope, but that wouldn\'t clean up the temporary objects you have created.Instead, you have to go the ugly route:Also: why is it that even managed lanuages provide a finally-block despite resources being deallocated automatically by the garbage collector anyway?Hint: there\'s more you can do with "finally" than just memory deallocation.FWIW, Microsoft Visual C++ does support try,finally and it has historically been used in MFC apps as a method of catching serious exceptions that would otherwise result in a crash.  For example;I\'ve used this in the past to do things like save backups of open files prior to exit.  Certain JIT debugging settings will break this mechanism though.Not really, but you can emulate them to some extend, for example:Note that the finally-block might itself throw an exception before the original exception is re-thrown, thereby discarding the original exception. This is the exact same behavior as in a Java finally-block. Also, you cannot use return inside the try&catch blocks.I came up with a finally macro that can be used almost like\xc2\xb9 the finally keyword in Java; it makes use of std::exception_ptr and friends, lambda functions and std::promise, so it requires C++11 or above; it also makes use of the compound statement expression GCC extension, which is also supported by clang.WARNING: an earlier version of this answer used a different implementation of the concept with many more limitations. First, let\'s define a helper class.Then there\'s the actual macro.\nIt can be used like this:The use of std::promise makes it very easy to implement, but it probably also introduces quite a bit of unneeded overhead which could be avoided by reimplementing only the needed functionalities from std::promise.\xc2\xb9 CAVEAT: there are a few things that don\'t work quite like the java version of finally. Off the top of my head:All in all, I don\'t know if I\'d ever use this stuff myself, but it was fun playing with it. :)As many people have stated, the solution is to use C++11 features to avoid finally blocks. One of the features is unique_ptr.Here is Mephane\'s answer written using RAII patterns.Some more introduction to using unique_ptr with C++ Standard Library containers is hereI would like to provide an alternative.If you want finally block to be called always, just put it after last catch block (which probably should be catch( ... ) to catch not known exception)If you want finally block as a last thing to do when any exception is thrown you can use boolean local variable - before run you set it to false and put true assignment at the very end of try block, then after catch block check for the variable value:I have a use case where I think finally should be a perfectly acceptable part of the C++11 language, as I think it is easier to read from a flow point of view. My use case is a consumer/producer chain of threads, where a sentinel nullptr is sent at the end of the run to shut down all threads.If C++ supported it, you would want your code to look like this:I think this is more logical that putting your finally declaration at the start of the loop, since it occurs after the loop has exited... but that is wishful thinking because we can\'t do it in C++. Note that the queue downstream is connected to another thread, so you can\'t put in the sentinel push(nullptr) in the destructor of downstream because it can\'t be destroyed at this point... it needs to stay alive until the other thread receives the nullptr.So here is how to use a RAII class with lambda to do the same:and here is how you use it: