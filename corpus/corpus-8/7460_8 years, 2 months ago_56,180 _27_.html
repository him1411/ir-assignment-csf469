From what I understand, Git doesn\'t really need to track file rename/move/copy operations, so what\'s the real purpose \nof git mv? The man page isn\'t specially descriptive...Is it obsolete? Is it an internal command, not meant to be used by regular users?is just shorthand for:i.e. it updates the index for both old and new paths automatically.From the official GitFaq:Git has a rename command git mv, but that is just a convenience. The effect\n  is indistinguishable from removing the file and adding another with different\n  name and the same contentGit is just trying to guess for you what you are trying to do. It is making every attempt to preserve unbroken history. Of course, it is not perfect. So git mv allows you to be explicit with your intention and to avoid some errors.Consider this example. Starting with an empty repo,Result:Autodetection failed :(\nOr did it?and then Now try instead (remember to delete the .git folder when experimenting):So far so good:Now, nobody is perfect:Really? But of course......and the result is the same as above: only --follow shows the full history. Now, be careful with renaming, as either option can still produce weird effects.\nExample:Contrast it with:Result:Ups... Now the history is going back to initial a instead of initial b, which is wrong. So when we did two moves at a time, Git became confused and did not track the changes properly. By the way, in my experiments the same happened when I deleted/created files instead of using git mv. Proceed with care; you\'ve been warned...As @Charles says, git mv is a shorthand. The real question here is "Other version control systems (eg. Subversion and Perforce) treat file renames specially. Why doesn\'t Git?"Linus explains at http://permalink.gmane.org/gmane.comp.version-control.git/217 with characteristic tact:Please stop this "track files" crap. Git tracks exactly what matters, \n  namely "collections of files". Nothing else is relevant, and even \n  thinking that it is relevant only limits your world-view. Notice how the \n  notion of CVS "annotate" always inevitably ends up limiting how people use \n  it. I think it\'s a totally useless piece of crap, and I\'ve described \n  something that I think is a million times more useful, and it all fell out \n  exactly because I\'m not limiting my thinking to the wrong model of the \n  world.There\'s another use I have for git mv not mentioned above.Since discovering git add -p (git add\'s patch mode; see http://git-scm.com/docs/git-add), I like to use it to review changes as I add them to the index. Thus my workflow becomes (1) work on code, (2) review and add to index, (3) commit.How does git mv fit in? If moving a file directly then using git rm and git add, all changes get added to the index, and using git diff to view changes is less easy (before committing). Using git mv, however, adds the new path to the index but not changes made to the file, thus allowing git diff and git add -p to work as usual.