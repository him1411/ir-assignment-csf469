The app crashes when trying to open a file. It work below Android N, but on Android N it crashes. It only crashes when I try to open a file from the SD card, not from the system partition. Some permission problem?Sample code:Log: Edit:When targeting Android N, file:// URIs are not allowed anymore. We should use content:// URIs instead. However, my app needs to open files in root directories. Any ideas?If your targetSdkVersion is 24 or higher, we have to use FileProvider class to give access to the particular file or folder to make them accessible for other apps. We create our own class inheriting FileProvider in order to make sure our FileProvider doesn\'t conflict with FileProviders declared in imported dependencies as described here.Steps to replace file:// uri with content:// uri:add a class extending FileProvideradd a FileProvider  tag in AndroidManifest.xml under  tag. Specify an unique authority for the android:authorities attribute to avoid conflicts, imported dependencies might specify ${applicationId}.provider and other commonly used authorities.The final step is to change the line of code below intoEdit: If using an intent to make the system open your file, you may need to add the following line of code:Hope this will help...:)Please refer, full code and solution has been explained here.Besides the solution using the FileProvider, there is another way to work around this. Simply put in Application.onCreate(). In this way the VM ignores the file URI exposure.Methodenables the file exposure check, which is also the default behavior if we don\'t setup a VmPolicy.I encountered a problem that if I use a content:// URI to send something, some apps just can\'t understand it. And downgrading the target SDK version is not allowed. In this case my solution is useful.If your targetSdkVersion is 24 or higher, you can not use file: Uri values in Intents on Android 7.0+ devices.Your choices are:Drop your targetSdkVersion to 23 or lower, orPut your content on internal storage, then use FileProvider to make it available selectively to other appsFor example:(from this sample project)If your app targets API 24+, and you still want/need to use file:// intents, you can use hacky way to disable the runtime check:Method StrictMode.disableDeathOnFileUriExposure is hidden and documented as:Problem is that my app is not lame, but rather doesn\'t want to be crippled by using content:// intents which are not understood by many apps out there. For example, opening mp3 file with content:// scheme offers much fewer apps than when opening same over file:// scheme. I don\'t want to pay for Google\'s design faults by limiting my app\'s functionality.Google wants developers to use content scheme, but the system is not prepared for this, for years apps were made to use Files not "content", files can be edited and saved back, while files served over content scheme can\'t be (can they?).First you need to add a provider to your AndroidManifestnow create a file in xml resource folder (if using android studio you can hit Alt + Enter after highlighting file_paths and select create a xml resource option)Next in the file_paths file enterThis example is for external-path you can refere here for more options.\nThis will allow you to share files which are in that folder and its sub-folder. Now all that\'s left is to create the intent as follows:EDIT: I added the root folder of the sd card in the file_paths. I have tested this code and it does work.@palash k answer is correct and worked for internal storage files, but in my case I want to open files from external storage also, my app crashed when open file from external storage like sdcard and usb, but I manage to solve the issue by modifying provider_paths.xml from the accepted answerchange the provider_paths.xml like belowand in java class(No change as the accepted answer just a small edit)This help me to fix the crash for files from external storages, Hope this will help some one having same issue as mine\n:)Using the fileProvider is the way to go.\nBut you can use this simple workaround:WARNING: It will be fixed in next Android release -\n  https://issuetracker.google.com/issues/37122890#comment4replace:byI used Palash\'s answer given above but it was somewhat incomplete, I had to provide permission like thisIf targetSdkVersion is higher than 24, then FileProvider is used to grant access. Create an xml file(Path: res\\xml) provider_paths.xmlAdd a Provider in AndroidManifest.xmland replace toand you are good to go.