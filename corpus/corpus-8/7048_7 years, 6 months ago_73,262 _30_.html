CSS isn\'t, insofar as I know, Turing complete.  But my knowledge of CSS is very limited.  You can encode Rule 110 in CSS3, so it\'s Turing-complete so long as you consider an appropriate accompanying HTML file and user interactions to be part of the \xe2\x80\x9cexecution\xe2\x80\x9d of CSS. A pretty good implementation is available, and another implementation is included here (JsFiddle version):One aspect of Turing completeness is that its halting problem is undecidable.This means there\'s no general algorithm for determining whether a CSS program will finish running or loop forever.But we can derive such an algorithm for CSS! Here it is:If the stylesheet doesn\'t declare any animations, then it will halt.If it does have animations, then:If any animation-iteration-count is infinite, and the containing selector is matched in the HTML, then it will not halt.Otherwise, it will halt.That\'s it. Since we just showed that the halting problem is decidable for CSS, it follows that CSS is not Turing complete.(Other people have mentioned IE 6, which allows for embedding arbitrary JavaScript expressions in CSS; that will obviously add Turing completeness. But that feature is non-standard, and nobody in their right mind uses it anyway.)Daniel Wagner brought up a point that I missed in the original answer. He notes that while I\'ve covered animations, other parts of the style engine such as selector matching or layout can lead to Turing completeness as well. While it\'s difficult to make a formal argument about these, I\'ll try to outline why Turing completeness is still unlikely to happen.First: Turing complete languages have some way of feeding data back into itself, whether it be through recursion or looping. But the design of the CSS language is hostile to this feedback:@media queries can only check properties of the browser itself, such as viewport size or pixel resolution. These properties can change via user interaction or JavaScript code (e.g. resizing the browser window), but not through CSS alone.::before and ::after pseudo-elements are not considered part of the DOM, and cannot be matched in any other way.Selector combinators can only inspect elements above and before the current element, so they cannot be used to create dependency cycles.It\'s possible to shift an element away when you hover over it, but the position only updates when you move the mouse.That should be enough to convince you that selector matching, on its own, cannot be Turing complete. But what about layout?The modern CSS layout algorithm is very complex, with features such as Flexbox and Grid muddying the waters. But even if it were possible to trigger an infinite loop with layout, it would be hard to leverage this to perform useful computation. That\'s because CSS selectors inspect only the internal structure of the DOM, not how these elements are laid out on the screen. So any Turing completeness proof using the layout system must depend on layout alone.Finally – and this is perhaps the most important reason – browser vendors have an interest in keeping CSS not Turing complete. By restricting the language, vendors allow for clever optimizations that make the web faster for everyone. Moreover, Google dedicates a whole server farm to searching for bugs in Chrome. If there were a way to write an infinite loop using CSS, then they probably would have found it already \xf0\x9f\x98\x89As per this article, it\'s not. The article also argues that it\'s not a good idea to make it one.To quote from one of the comments:So, I do not believe that CSS is\n  turing complete. There is no\n  capability to define a function in\n  CSS. In order for a system to be\n  turing-complete it has to be possible\n  to write an interpreter: a function\n  that interprets expressions that\n  denote programs to execute. CSS has no\n  variables that are directly accessible\n  to the user; so you cannot even model\n  the structure that represents the\n  program to be interpreted in CSS.Turing-completeness is not only about "defining functions" or "have ifs/loops/etc". For example, Haskell doesn\'t have "loop", lambda-calculus don\'t have "ifs", etc...For example, this site: http://experthuman.com/programming-with-nothing. The author uses Ruby and create a "FizzBuzz" program with only closures (no strings, numbers, or anything like that)...There are examples when people compute some arithmetical functions on Scala using only the type systemSo, yes, in my opinion, CSS3+HTML is turing-complete (even if you can\'t exactly do any real computation with then without becoming crazy) The fundamental issue here is that any machine written in HTML+CSS cannot evaluate infinitely many steps (i.e there can be no "real" recursion) unless the code is infinitely long. And the question will this machine reach configuration H in n steps or less is always answerable if n is finite.CSS is not a programming language, so the question of turing-completeness is a meaningless one. If programming extensions are added to CSS such as was the case in IE6 then that new synthesis is a whole different thing.CSS is merely a description of styles; it does not have any logic, and its structure is flat.