As an example take the following code:I want a to databind the property ExampleProperty to a ComboBox, so that it shows the options "FooBar" and "BarFoo" and works in mode TwoWay. Optimally I want my ComboBox definition to look something like this:Currently I have handlers for the ComboBox.SelectionChanged and ExampleClass.PropertyChanged events installed in my Window where I do the binding manually.Is there a better or some kind of canonical way? Would you usually use Converters and how would you populate the ComboBox with the right values? I don\'t even want to get started with i18n right now.EditSo one question was answered: How do I populate the ComboBox with the right values.Retrieve Enum values as a list of strings via an ObjectDataProvider from the static Enum.GetValues method:This I can use as an ItemsSource for my ComboBox:You can create a custom markup extension.Example of usage:And the implementation...In the viewmodel you can have:In XAML the ItemSource binds to MyEnumTypeValues and SelectedItem binds to  SelectedMyEnumType.I prefer not to use the name of enum in UI. I prefer use different value for user (DisplayMemberPath) and different for value (enum in this case) (SelectedValuePath). Those two values can be packed to KeyValuePair and stored in dictionary.XAMLC#EDIT: Compatible with the MVVM pattern.I don\'t know if it is possible in XAML-only but try the following:Give your ComboBox a name so you can access it in the codebehind: "typesComboBox1"Now try the followingBased on the accepted but now deleted answer provided by ageektrapped I created a slimmed down version without some of the more advanced features. All the code is included here to allow you to copy-paste it and not get blocked by link-rot.I use the System.ComponentModel.DescriptionAttribute which really is intended for design time descriptions. If you dislike using this attribute you may create your own but I think using this attribute really gets the job done. If you don\'t use the attribute the name will default to the name of the enum value in code.Here is the class used as the items source:You can use it in XAML like this:Use ObjectDataProvider:and then bind to static resource:Find this solution at this blogyou can consider something like that:define a style for textblock, or any other control you want to use to display your enum:define your style for ComboBoxItemadd a combobox and load it with your enum values:if your enum is large, you can of course do the same in code, sparing a lot of typing. \ni like that approach, since it makes localization easy - you define all the templates once, and then, you only update your string resource files.Here is a generic solution using a helper method.\nThis can also handle an enum of any underlying type (byte, sbyte, uint, long, etc.)Helper Method:View Model:ComboBox:This is a DevExpress specific answer based on the top-voted answer by Gregor S. (currently it has 128 votes).This means we can keep the styling consistent across the entire application:Unfortunately, the original answer doesn\'t work with a ComboBoxEdit from DevExpress without some modifications.First, the XAML for the ComboBoxEdit:Needsless to say, you will need to point xamlExtensions at the namespace that contains the XAML extension class (which is defined below):And we have to point myEnum at the namespace that contains the enum:Then, the enum:The problem in with the XAML is that we can\'t use SelectedItemValue, as this throws an error as the setter is unaccessable (bit of an oversight on your part, DevExpress). So we have to modify our ViewModel to obtain the value directly from the object:For completeness, here is the XAML extension from the original answer (slightly renamed):Disclaimer: I have no affiliation with DevExpress. Telerik is also a great library.If you are using a MVVM, based on @rudigrobler answer you can do the following:Add the following property to the ViewModel classThen in the XAML do the following:Try using I\'ve created an open source CodePlex project that does this.  You can download the NuGet package from here.My favorite way to do this is with a ValueConverter so that the ItemsSource and SelectedValue both bind to the same property. This requires no additional properties to keep your ViewModel nice and clean.And the definition of the Converter:This converter will work with any enum. ValueDescription is just a simple class with a Value property and a Description property. You could just as easily use a Tuple with Item1 and Item2, or a KeyValuePair with Key and Value instead of Value and Description or any other class of your choice as long as it has can hold an enum value and string description of that enum value.