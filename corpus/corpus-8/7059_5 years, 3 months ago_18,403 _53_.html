It seems that Template Haskell is often viewed by the Haskell community as an unfortunate convenience. It\'s hard to put into words exactly what I have observed in this regard, but consider these few examplesI\'ve seen various blog posts where people do pretty neat stuff with Template Haskell, enabling prettier syntax that simply wouldn\'t be possible in regular Haskell, as well as tremendous boilerplate reduction. So why is it that Template Haskell is looked down upon in this way? What makes it undesirable? Under what circumstances should Template Haskell be avoided, and why?One reason for avoiding Template Haskell is that it as a whole isn\'t type-safe, at all, thus going against much of "the spirit of Haskell." Here are some examples of this:TH is also outright dangerous:Then there are some problems that make TH functions less fun to use as a library developer:Finally, there are some things that make TH functions less fun to use as an end-user:This is solely my own opinion.It\'s ugly to use. $(fooBar \'\'Asdf) just does not look nice. Superficial, sure, but it contributes.It\'s even uglier to write. Quoting works sometimes, but a lot of the time you have to do manual AST grafting and plumbing. The API is big and unwieldy, there\'s always a lot of cases you don\'t care about but still need to dispatch, and the cases you do care about tend to be present in multiple similar but not identical forms (data vs. newtype, record-style vs. normal constructors, and so on). It\'s boring and repetitive to write and complicated enough to not be mechanical. The reform proposal addresses some of this (making quotes more widely applicable).The stage restriction is hell. Not being able to splice functions defined in the same module is the smaller part of it: the other consequence is that if you have a top-level splice, everything after it in the module will be out of scope to anything before it. Other languages with this property (C, C++) make it workable by allowing you to forward declare things, but Haskell doesn\'t. If you need cyclic references between spliced declarations or their dependencies and dependents, you\'re usually just screwed.It\'s undisciplined. What I mean by this is that most of the time when you express an abstraction, there is some kind of principle or concept behind that abstraction. For many abstractions, the principle behind them can be expressed in their types. For type classes, you can often formulate laws which instances should obey and clients can assume. If you use GHC\'s new generics feature to abstract the form of an instance declaration over any datatype (within bounds), you get to say "for sum types, it works like this, for product types, it works like that". Template Haskell, on the other hand, is just macros. It\'s not abstraction at the level of ideas, but abstraction at the level of ASTs, which is better, but only modestly, than abstraction at the level of plain text.*It ties you to GHC. In theory another compiler could implement it, but in practice I doubt this will ever happen. (This is in contrast to various type system extensions which, though they might only be implemented by GHC at the moment, I could easily imagine being adopted by other compilers down the road and eventually standardized.)The API isn\'t stable. When new language features are added to GHC and the template-haskell package is updated to support them, this often involves backwards-incompatible changes to the TH datatypes. If you want your TH code to be compatible with more than just one version of GHC you need to be very careful and possibly use CPP.There\'s a general principle that you should use the right tool for the job and the smallest one that will suffice, and in that analogy Template Haskell is something like this. If there\'s a way to do it that\'s not Template Haskell, it\'s generally preferable.The advantage of Template Haskell is that you can do things with it that you couldn\'t do any other way, and it\'s a big one. Most of the time the things TH is used for could otherwise only be done if they were implemented directly as compiler features. TH is extremely beneficial to have both because it lets you do these things, and because it lets you prototype potential compiler extensions in a much more lightweight and reusable way (see the various lens packages, for example).To summarize why I think there are negative feelings towards Template Haskell: It solves a lot of problems, but for any given problem that it solves, it feels like there should be a better, more elegant, disciplined solution better suited to solving that problem, one which doesn\'t solve the problem by automatically generating the boilerplate, but by removing the need to have the boilerplate.* Though I often feel that CPP has a better power-to-weight ratio for those problems that it can solve.EDIT 23-04-14: What I was frequently trying to get at in the above, and have only recently gotten at exactly, is that there\'s an important distinction between abstraction and deduplication. Proper abstraction often results in deduplication as a side effect, and duplication is often a telltale sign of inadequate abstraction, but that\'s not why it\'s valuable. Proper abstraction is what makes code correct, comprehensible, and maintainable. Deduplication only makes it shorter. Template Haskell, like macros in general, is a tool for deduplication.I\'d like to address a few of the points dflemstr brings up.I don\'t find the fact that you can\'t typecheck TH to be that worrying. Why? Because even if there is an error, it will still be compile time. I\'m not sure if this strengthens my argument, but this is similar in spirit to the errors that you receive when using templates in C++. I think these errors are more understandable than C++\'s errors though, as you\'ll get a pretty printed version of the generated code.If a TH expression / quasi-quoter does something that\'s so advanced that tricky corners can hide, then perhaps it\'s ill-advised?I break this rule quite a bit with quasi-quoters I\'ve been working on lately (using haskell-src-exts / meta) - https://github.com/mgsloan/quasi-extras/tree/master/examples . I know this introduces some bugs such as not being able to splice in the generalized list comprehensions. However, I think that there\'s a good chance that some of the ideas in http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal will end up in the compiler. Until then, the libraries for parsing Haskell to TH trees are a nearly perfect approximation.Regarding compilation speed / dependencies, we can use the "zeroth" package to inline the generated code. This is at least nice for the users of a given library, but we can\'t do much better for the case of editing the library. Can TH dependencies bloat generated binaries? I thought it left out everything that\'s not referenced by the compiled code.The staging restriction / splitting of compilation steps of the Haskell module does suck.RE Opacity: This is the same for any library function you call. You have no control over what Data.List.groupBy will do. You just have a reasonable "guarantee" / convention that the version numbers tell you something about the compatibility. It is somewhat of a different matter of change when.This is where using zeroth pays off - you\'re already versioning the generated files - so you\'ll always know when the form of the generated code has changed. Looking at the diffs might be a bit gnarly, though, for large amounts of generated code, so that\'s one place where a better developer interface would be handy.RE Monolithism: You can certainly post-process the results of a TH expression, using your own compile-time code. It wouldn\'t be very much code to filter on top-level declaration type / name. Heck, you could imagine writing a function that does this generically. For modifying / de-monolithisizing quasiquoters, you can pattern match on "QuasiQuoter" and extract out the transformations used, or make a new one in terms of the old.This answer is in response to the issues brought up by illissius, point by point:I agree.  I feel like $( ) was chosen to look like it was part of the language - using the familiar symbol pallet of Haskell.  However, that\'s exactly what you /don\'t/ want in the symbols used for your macro splicing.  They definitely blend in too much, and this cosmetic aspect is quite important.  I like the look of {{ }} for splices, because they are quite visually distinct.I also agree with this, however, as some of the comments in "New Directions for TH" observe, the lack of good out-of-the-box AST quoting is not a critical flaw.  In this WIP package, I seek to address these problems in library form: https://github.com/mgsloan/quasi-extras .  So far I allow splicing in a few more places than usual and can pattern match on ASTs.I\'ve run into the issue of cyclic TH definitions being impossible before...  It\'s quite annoying.  There is a solution, but it\'s ugly - wrap the things involved in the cyclic dependency in a TH expression that combines all of the generated declarations.  One of these declarations generators could just be a quasi-quoter that accepts Haskell code.It\'s only unprincipled if you do unprincipled things with it.  The only difference is that with the compiler implemented mechanisms for abstraction, you have more confidence that the abstraction isn\'t leaky.  Perhaps democratizing language design does sound a bit scary!  Creators of TH libraries need to document well and clearly define the meaning and results of the tools they provide.  A good example of principled TH is the derive package: http://hackage.haskell.org/package/derive - it uses a DSL such that the example of many of the derivations /specifies/ the actual derivation.That\'s a pretty good point - the TH API is pretty big and clunky.  Re-implementing it seems like it could be tough.  However, there are only really only a few ways to slice the problem of representing Haskell ASTs.  I imagine that copying the TH ADTs, and writing a converter to the internal AST representation would get you a good deal of the way there.  This would be equivalent to the (not insignificant) effort of creating haskell-src-meta.  It could also be simply re-implemented by pretty printing the TH AST and using the compiler\'s internal parser.While I could be wrong, I don\'t see TH as being that complicated of a compiler extension, from an implementation perspective.  This is actually one of the benefits of "keeping it simple" and not having the fundamental layer be some theoretically appealing, statically verifiable templating system.This is also a good point, but somewhat dramaticized.  While there have been API additions lately, they haven\'t been extensively breakage inducing.  Also, I think that with the superior AST quoting I mentioned earlier, the API that actually needs to be used can be very substantially reduced.  If no construction / matching needs distinct functions, and are instead expressed as literals, then most of the API disappears.  Moreover, the code you write would port more easily to AST representations for languages similar to Haskell.In summary, I think that TH is a powerful, semi-neglected tool.  Less hate could lead to a more lively eco-system of libraries, encouraging the implementation of more language feature prototypes.  It\'s been observed that TH is an overpowered tool, that can let you /do/ almost anything.  Anarchy!  Well, it\'s my opinion that this power can allow you to overcome most of its limitations, and construct systems capable of quite principled meta-programming approaches.  It\'s worth the usage of ugly hacks to simulate the "proper" implementation, as this way the design of the "proper" implementation will gradually become clear. In my personal ideal version of nirvana, much of the language would actually move out of the compiler, into libraries of these variety.  The fact that the features are implemented as libraries does not heavily influence their ability to faithfully abstract.What\'s the typical Haskell answer to boilerplate code?  Abstraction.  What\'re our favorite abstractions?  Functions and typeclasses!Typeclasses let us define a set of methods, that can then be used in all manner of functions generic on that class.  However, other than this, the only way classes help avoid boilerplate is by offering "default definitions".  Now here is an example of an unprincipled feature!Minimal binding sets are not declarable / compiler checkable.  This could lead to inadvertent definitions that yield bottom due to mutual recursion.Despite the great convenience and power this would yield, you cannot specify superclass defaults, due to orphan instances  http://lukepalmer.wordpress.com/2009/01/25/a-world-without-orphans/  These would let us fix the numeric hierarchy gracefully!Going after TH-like capabilities for method defaults led to http://www.haskell.org/haskellwiki/GHC.Generics .  While this is cool stuff, my only experience debugging code using these generics was nigh-impossible, due to the size of the type induced for and ADT as complicated as an AST. https://github.com/mgsloan/th-extra/commit/d7784d95d396eb3abdb409a24360beb03731c88cIn other words, this went after the features provided by TH, but it had to lift an entire domain of the language, the construction language, into a type system representation.  While I can see it working well for your common problem, for complex ones, it seems prone to yielding a pile of symbols far more terrifying than TH hackery.TH gives you value-level compile-time computation of the output code, whereas generics forces you to lift the pattern matching / recursion part of the code into the type system.  While this does restrict the user in a few fairly useful ways, I don\'t think the complexity is worth it.I think that the rejection of TH and lisp-like metaprogramming led to the preference towards things like method-defaults instead of more flexible, macro-expansion like declarations of instances.  The discipline of avoiding things that could lead to unforseen results is wise, however, we should not ignore that Haskell\'s capable type system allows for more reliable metaprogramming than in many other environments (by checking the generated code).One rather pragmatic problem with Template Haskell is that it only works when GHC\'s bytecode interpreter is available, which is not the case on all architectures. So if your program uses Template Haskell or relies on libraries that use it, it will not run on machines with an ARM, MIPS, S390 or PowerPC CPU.This is relevant in practice: git-annex is a tool written in Haskell that makes sense to run on machines worrying about storage, such machines often have non-i386-CPUs. Personally, I run git-annex on a NSLU 2 (32 MB of RAM, 266MHz CPU; did you know Haskell works fine on such hardware?) If it would use Template Haskell, this is not possible.(The situation about GHC on ARM is improving these days a lot and I think 7.4.2 even works, but the point still stands).Why is TH bad? For me, it comes down to this:If you need to produce so much repetitive code that you find yourself trying to use TH to auto-generate it, you\'re doing it wrong!Think about it. Half the appeal of Haskell is that its high-level design allows you to avoid huge amounts of useless boilerplate code that you have to write in other languages. If you need compile-time code generation, you\'re basically saying that either your language or your application design has failed you. And we programmers don\'t like to fail.Sometimes, of course, it\'s necessary. But sometimes you can avoid needing TH by just being a bit more clever with your designs.(The other thing is that TH is quite low-level. There\'s no grand high-level design; a lot of GHC\'s internal implementation details are exposed. And that makes the API prone to change...)