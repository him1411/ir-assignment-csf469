Is there a way to specify default arguments to a function in C?Not really.  The only way would be to write a varargs function and manually fill in default values for arguments which the caller doesn\'t pass.Wow, everybody is such a pessimist around here.  The answer is yes. It ain\'t trivial: by the end, we\'ll have the core function, a supporting struct, a wrapper function, and a macro\naround the wrapper function. In my work I have a set of macros to automate all this; once\nyou understand the flow it\'ll be easy for you to do the same.I\'ve written this up elsewhere, so here\'s a detailed external link to supplement the summary here: http://modelingwithdata.org/arch/00000022.htmWe\'d like to turninto a function that takes defaults (i=8, x=3.14). Define a companion struct:Rename your function f_base, and define a wrapper function that sets defaults and calls\nthe base:Now add a macro, using C\'s variadic macros. This way users don\'t have to know they\'re\nactually populating a f_args struct and think they\'re doing the usual:OK, now all of the following would work:Check the rules on how compound initializers set defaults for the exact rules.One thing that won\'t work: f(0), because we can\'t distinguish between a missing value and\nzero. In my experience, this is something to watch out for, but can be taken care of as\nthe need arises---half the time your default really is zero.I went through the trouble of writing this up because I think named arguments and defaults\n really do make coding in C easier and even more fun. And\nC is awesome for being so simple and still having enough there to make all this possible.Yes. :-) But not in a way you would expect.Unfortunately, C doesn\'t allow you to overload methods so you\'d end up with two different functions. Still, by calling f2, you\'d actually be calling f1 with a default value. This is a "Don\'t Repeat Yourself" solution, which helps you to avoid copying/pasting existing code.We can create functions which use named parameters (only) for default values. This is a continuation of bk.\'s answer.The C99 standard defines that later names in the initialization override previous items. We can also have some standard positional parameters as well, just change the macro and function signature accordingly. The default value parameters can only be used in named parameter style.Program output:No.Not even the very latest C99 standard supports this.No, that\'s a C++ language feature.Yet another option uses structs:Short answer: No.Slightly longer answer: There is an old, old workaround where you pass a string that you parse for optional arguments:where opt may include "name=value" pair or something, and which you would call likeObviously this is only occasionally useful. Generally when you want a single interface to a family of functionality.You still find this approach in particle physics codes that are written by professional programs in c++ (like for instance ROOT). It\'s main advantage is that it may be extended almost indefinitely while maintaining back compatibility.OpenCV uses something like:If the user doesn\'t know what he should write, this trick can be helpful:Probably the best way to do this (which may or may not be possible in your case depending on your situation) is to move to C++ and use it as \'a better C\'. You can use C++ without using classes, templates, operator overloading or other advanced features.This will give you a variant of C with function overloading and default parameters (and whatever other features you chose to use). You just have to be a little disciplined if you\'re really serious about using only a restricted subset of C++.A lot of people will say it\'s a terrible idea to use C++ in this way, and they might have a point.  But\'s it\'s just an opinion; I think it\'s valid to use features of C++ that you\'re comfortable with without having to buy into the whole thing. I think a significant part of the reason for the sucess of C++ is that it got used by an awful lot of programmers in it\'s early days in exactly this way.No.            No, but you might consider using a set of functions (or macros) to approximate using default args:Yes, with features of C99 you may do this. This works without defining new data structures or so and without the function having to decide at runtime how it was called, and\nwithout any computational overhead.For a detailed explanation see my post athttp://gustedt.wordpress.com/2010/06/03/default-arguments-for-c99/JensGenerally no, but in gcc You may make the last parameter of funcA() optional with a macro.In funcB() i use a special value (-1) to signal that i need the default value for the \'b\' parameter.I improved Jens Gustedt\xe2\x80\x99s answer so that:variadic.h:Simplified usage scenario:And with _Generic:And with variadic function name selection, which can\'t be combined with _Generic:Yes you can do somthing simulair, here you have to know the different argument lists you can get but you have the same function to handle then all.Why can\'t we do this.Give the optional argument a default value. In that way, the caller of the function don\'t necessarily need to pass the value of  the argument. The argument takes the default value.\nAnd easily that argument becomes optional for the client.For e.g.void foo(int a, int b = 0);Here b is an optional argument.