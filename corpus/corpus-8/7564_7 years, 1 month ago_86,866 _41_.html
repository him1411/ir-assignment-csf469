Given a collection, is there a way to get the last N elements of that collection?  If there isn\'t a method in the framework, what would be the best way to write an extension method to do this?This approach preserves item order without a dependency on any sorting, and has broad compatibility across several LINQ providers.It is important to take care not to call Skip with a negative number. Some providers, such as the Entity Framework, will produce an ArgumentException when presented with a negative argument. The call to Math.Max avoids this neatly.The class below has all of the essentials for extension methods, which are: a static class, a static method, and use of the this keyword.A brief note on performance:Because the call to Count() can cause enumeration of certain data structures, this approach has the risk of causing two passes over the data. This isn\'t really a problem with most enumerables; in fact, optimizations exist already for Lists, Arrays, and even EF queries to evaluate the Count() operation in O(1) time.If, however, you must use a forward-only enumerable and would like to avoid making two passes, consider a one-pass algorithm like Lasse V. Karlsen or Mark Byers describe. Both of these approaches use a temporary buffer to hold items while enumerating, which are yielded once the end of the collection is found.UPDATE: To address clintp\'s problem:  a) Using the TakeLast() method I defined above solves the problem, but if you really want the do it without the extra method, then you just have to recognize that while Enumerable.Reverse() can be used as an extension method, you aren\'t required to use it that way:Note: I missed your question title which said Using Linq, so my answer does not in fact use Linq.If you want to avoid caching a non-lazy copy of the entire collection, you could write a simple method that does it using a linked list.The following method will add each value it finds in the original collection into a linked list, and trim the linked list down to the number of items required. Since it keeps the linked list trimmed to this number of items the entire time through iterating through the collection, it will only keep a copy of at most N items from the original collection.It does not require you to know the number of items in the original collection, nor iterate over it more than once.Usage:Extension method:Here\'s a method that works on any enumerable but uses only O(N) temporary storage:Usage:It works by using a ring buffer of size N to store the elements as it sees them, overwriting old elements with new ones. When the end of the enumerable is reached the ring buffer contains the last N elements.I am surprised that no one has mentioned it, but SkipWhile does have a method that uses the element\'s index. The only perceivable benefit that this solution presents over others is that you can have the option to add in a predicate to make a more powerful and efficient LINQ query, instead of having two separate operations that traverse the IEnumerable twice.Use EnumerableEx.TakeLast in RX\'s System.Interactive assembly. It\'s an O(N) implementation like @Mark\'s, but it uses a queue rather than a ring-buffer construct (and dequeues items when it reaches buffer capacity).(NB: This is the IEnumerable version - not the IObservable version, though the implementation of the two is pretty much identical)If you don\'t mind dipping into Rx as part of the monad, you can use TakeLast:If you are dealing with a collection with a key (e.g. entries from a database) a quick (i.e. faster than the selected answer) solution would beIf using a third-party library is an option, MoreLinq defines TakeLast() which does exactly this.I tried to combine efficiency and simplicity and end up with this : About \nperformance : In C#, Queue<T> is implemented using a circular buffer so there is no object instantiation done each loop (only when the queue is growing up). I did not set queue capacity (using dedicated constructor) because someone might call this extension with count = int.MaxValue . For extra performance you might check if source implement IList<T> and if yes, directly extract the last values using array indexes.It is a little inefficient to take the last N of a collection using LINQ as all the above solutions require iterating across the collection. TakeLast(int n) in System.Interactive also has this problem.If you have a list a more efficient thing to do is slice it using the following methodwithand some test casesI know it\'s to late to answer this question. But if you are working with collection of type IList<> and you don\'t care about an order of the returned collection, then this method is working faster. I\'ve used Mark Byers answer and made a little changes. So now method TakeLast is:For test I have used Mark Byers method and kbrimington\'s andswer. This is test:And here are results for taking 10 elements:and for taking 1000001 elements results are:\n Here\'s my solution:The code is a bit chunky, but as a drop-in reusable component, it should perform as well as it can in most scenarios, and it\'ll keep the code that\'s using it nice and concise. :-)My TakeLast for non-IList`1 is based on the same ring buffer algorithm as that in the answers by @Mark Byers and @MackieChan further up. It\'s interesting how similar they are -- I wrote mine completely independently. Guess there\'s really just one way to do a ring buffer properly. :-)Looking at @kbrimington\'s answer, an additional check could be added to this for IQuerable<T> to fall back to the approach that works well with Entity Framework -- assuming that what I have at this point does not.Below the real example how to take last 3 elements from a collection (array):Using This Method To Get All Range Without Error