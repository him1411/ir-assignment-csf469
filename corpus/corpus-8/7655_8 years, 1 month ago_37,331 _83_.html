I am starting a project with jQuery.What pitfalls/errors/misconceptions/abuses/misuses did you have in your jQuery project?Being unaware of the performance hit and overusing selectors instead of assigning them to local variables. For example:-Rather than:-Or even better with chaining:-I found this the enlightening moment when I realized how the call stacks work.Edit: incorporated suggestions in comments.Understand how to use context.  Normally, a jQuery selector will search the whole doc:But you can speed things up by searching within a context:Don\'t use bare class selectors, like this:This will end up looking at every single element to see if it has a class of "button".Instead, you can help it out, like:I learned this last year from Rebecca Murphy\'s blogUpdate - This answer was given over 2 years ago and is not correct for the current version of jQuery.\nOne of the comments includes a test to prove this.\nThere is also an updated version of the test that includes the version of jQuery at the time of this answer.Try to split out anonymous functions so you can reuse them.I have seen hundreds of lines of code inside the doc ready statement. Ugly, unreadable and impossible to maintain.While using $.ajax function for Ajax requests to server, you should avoid using the complete event to process response data. It will fire whether the request was successful or not. Rather than complete, use success.See Ajax Events in the docs.Suppose you wanted to animate a paragraph vanishing upon clicking it. You also wanted to remove the element from the DOM afterwards. You may think you can simply chain the methods:In this example, .remove() will be called before .fadeOut() has completed, destroying your gradual-fading effect, and simply making the element vanish instantly. Instead, when you want to fire a command only upon finishing the previous, use the callback\'s:The second parameter of .fadeOut() is an anonymous function that will run once the .fadeOut() animation has completed. This makes for a gradual fading, and a subsequent removal of the element.Don\'t abuse plug-ins. Most of the times you\'ll only need the library and maybe the user interface. If you keep it simple your code will be maintainable in the long run. Not all plug-ins are supported and maintained, actually most are not. If you can mimic the functionality using core elements I strongly recommend it. Plug-ins are easy to insert in your code, save you some time, but when you\'ll need an extra something, it is a bad idea to modify them, as you lose the possible updates. The time you save at the start you\'ll loose later on changing deprecated plug-ins.Choose the plug-ins you use wisely.\nApart from library and user interface, I constantly use $.cookie , $.form, $.validate and thickbox. For the rest I mostly develop my own plug-ins.If you bind() the same event multiple times it will fire multiple times . I usually always go unbind(\'click\').bind(\'click\') just to be safePitfall: Using loops instead of selectors. If you find yourself reaching for the jQuery \'.each\' method to iterate over DOM elements, ask yourself if can use a selector to get the elements instead. More information on jQuery selectors:\nhttp://docs.jquery.com/SelectorsPitfall: NOT using a tool like FirebugFirebug was practically made for this kind of debugging.  If you\'re going to be mucking about in the DOM with Javascript, you need a good tool like Firebug to give you visibility.More information on Firebug:\nhttp://getfirebug.com/Other great ideas are in this episode of the Polymorphic Podcast: \n(jQuery Secrets with Dave Ward)\nhttp://polymorphicpodcast.com/shows/jquery/Misunderstanding of using this identifier in the right context. For instance:And here one of the samples how you can solve it:Avoid searching through the entire DOM several times.  This is something that really can delay your script. Bad:Good:Bad:Good:Always cache $(this) to a meaningful variable\nespecially in a .each()Like thisSimilar to what Repo Man said, but not quite.When developing ASP.NET winforms, I often doforgetting the # sign.  The correct form isEventsdoesn\'t clone any of the events - you have to rebind them all. As per JP\'s comment - clone() does rebind the events if you pass true.Avoid multiple creation of the same jQuery objectsI say this for JavaScript as well, but jQuery, JavaScript should NEVER replace CSS.Also, make sure the site is usable for someone with JavaScript turned off (not as relevant today as back in the day, but always nice to have a fully usable site).Making too many DOM manipulations. While the .html(), .append(), .prepend(), etc. methods are great, due to the way browsers render and re-render pages, using them too often will cause slowdowns. It\'s often better to create the html as a string, and to include it into the DOM once, rather than changing the DOM multiple times.Instead of:Try this:Or even this ($wrapper is a newly created element that hasn\'t been injected to the DOM yet. Appending nodes to this wrapper div does not cause slowdowns, and at the end we append $wrapper to $parent, using only one DOM manipulation):Using ClientID to get the "real" id of the control in ASP.NET projects.Also, if you are using jQuery inside SharePoint you must call jQuery.noConflict().Passing IDs instead of jQuery objects to functions:Passing a wrapped set is far more flexible:Excessive use of chaining. See this:ExplanationUse strings accumulator-styleUsing + operator a new string is created in memory and the concatenated value is assigned to it. Only after this the result is assigned to a variable.\nTo avoid the intermediate variable for concatenation result, you can directly assign the result using += operator.\nSlow:Faster:Primitive operations can be faster than function callsConsider using alternative primitive operation over function calls in performance critical loops and functions.\nSlow:Faster:Read More at JavaScript Performance Best PracticesIf you want users to see html entities in their browser, use \'html\' instead of \'text\' to inject a Unicode string, like:my two cents)Usually, working with jquery means you don\'t have to worry about DOM elements actual all the time. You can write something like this - $(\'div.mine\').addClass(\'someClass\').bind(\'click\', function(){alert(\'lalala\')}) - and this code will execute without throwing any errors.In some cases this is useful, in some cases - not at all, but it is a fact that jquery tends to be, well, empty-matches-friendly. Yet, replaceWith will throw an error if one tries to use it with an element which doesn\'t belong to the document. I find it  rather counter-intuitive. Another pitfall is, in my opinion, the order of nodes returned by prevAll() method - $(\'<div><span class="A"/><span class="B"/><span class="C"/><span class="D"/></div>\').find(\'span:last-child\').prevAll(). Not a big deal, actually, but we should keep in mind this fact.If you plan to Ajax in lots of data, like say, 1500 rows of a table with 20 columns, then don\'t even think of using jQuery to insert that data into your HTML. Use plain JavaScript. jQuery will be too slow on slower machines.Also, half the time jQuery will do things that will cause it to be slower, like trying to parse script tags in the incoming HTML, and deal with browser quirks. If you want fast insertion speed, stick with plain JavaScript. Using jQuery in a small project that can be completed with just a couple of lines of ordinary JavaScript.Not understanding event binding. JavaScript and jQuery work differently.By popular demand, an example:In jQuery:Without jQuery:Basically the hooks required for JavaScript are no longer necessary. I.e. use inline markup (onClick, etc) because you can simply use the ID\'s and classes that a developer would normally leverage for CSS purposes.