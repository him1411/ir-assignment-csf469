I saw this tip in another question and was wondering if someone could explain to me how on earth this works? I mean, does the finally clause really execute after the return statement? How thread-unsafe is this code? Can you think of any additional hackery that can be done w.r.t. this try-finally hack?No - at the IL level you can\'t return from inside an exception-handled block. It essentially stores it in a variable and returns afterwardsi.e. similar to:for example (using reflector):compiles to:This basically declares a local variable (CS$1$0000), places the value into the variable (inside the handled block), then after exiting the block loads the variable, then returns it. Reflector renders this as:The finally statement is executed, but the return value isn\'t affected. The execution order is:Here\'s a short program to demonstrate:This prints "try" (because that\'s what\'s returned) and then "finally" because that\'s the new value of x.Of course, if we\'re returning a reference to a mutable object (e.g. a StringBuilder) then any changes made to the object in the finally block will be visible on return - this hasn\'t affected the return value itself (which is just a reference).The finally clause executes after the return statement but before actually returning from the function. It has little to do with thread safety, I think. It is not a hack - the finally is guaranteed to always run no matter what you do in your try block or your catch block.Adding onto the answers given by Marc Gravell and Jon Skeet, it is important to note objects and other reference types behave similarly when returned but do have some differences.The "What" that gets returned follows the same logic as simple types:The reference that is being returned has already been evaluated before the local variable is assigned a new reference in the finally block.The execution is essentially:The difference is it would still be possible to modify mutable types using the properties/methods of the object which can result in unexpected behaviors if you are not careful.A second thing to consider about try-return-finally is that parameters passed "by reference" can still be modified after the return. Only the return value has been evaluated and is stored in a temporary variable waiting to be returned, any other variables are still modified the normal way. The contract of an out parameter can even go unfulfilled until the finally block this way.Like any other flow construct "try-return-finally" has its place and can allow for cleaner looking code than writing the structure it actually compiles to. But it must be used carefully to avoid gotcha\'s.If x is a local variable, I don\'t see the point, as x will be effectively set to null anyway when the method is exited and the value of the return value is not null (since it was placed in the register before the call to set x to null).I can only see doing this happening if you want to guarantee the change of the value of a field upon return (and after the return value is determined).