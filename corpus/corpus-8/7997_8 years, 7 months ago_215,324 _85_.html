When using SQL, are there any benefits of using = in a WHERE clause instead of LIKE?Without any special operators, LIKE and = are the same, right?LIKE and = are different operators. Most answers here focus on the wildcard support, which is not the only difference between these operators!= is a comparison operator that operates on numbers and strings. When comparing strings, the comparison operator compares whole strings.LIKE is a string operator that compares character by character.To complicate matters, both operators use a collation which can have important effects on the result of the comparison.Let\'s first identify an example where these operators produce obviously different results. Allow me to quote from the MySQL manual:Per the SQL standard, LIKE performs matching on a per-character basis, thus it can produce results different from the = comparison operator:Please note that this page of the MySQL manual is called String Comparison Functions, and = is not discussed, which implies that = is not strictly a string comparison function.The SQL Standard \xc2\xa7 8.2 describes how = compares strings:The comparison of two character strings is determined as follows:a) If the length in characters of X is not equal to the length\n  in characters of Y, then the shorter string is effectively\n  replaced, for the purposes of comparison, with a copy of\n  itself that has been extended to the length of the longer\n  string by concatenation on the right of one or more pad \n  characters, where the pad character is chosen based on CS. If\n  CS has the NO PAD attribute, then the pad character is an\n  implementation-dependent character different from any \n  character in the character set of X and Y that collates less\n  than any string under CS. Otherwise, the pad character is a\n  .b) The result of the comparison of X and Y is given by the \n  collating sequence CS.c) Depending on the collating sequence, two strings may \n  compare as equal even if they are of different lengths or \n  contain different sequences of characters. When the operations\n  MAX, MIN, DISTINCT, references to a grouping column, and the\n  UNION, EXCEPT, and INTERSECT operators refer to character\n  strings, the specific value selected by these operations from\n  a set of such equal values is implementation-dependent.(Emphasis added.)What does this mean? It means that when comparing strings, the = operator is just a thin wrapper around the current collation. A collation is a library that has various rules for comparing strings. Here\'s an example of a binary collation from MySQL:This particular collation happens to compare byte-by-byte (which is why it\'s called "binary" \xe2\x80\x94 it doesn\'t give any special meaning to strings). Other collations may provide more advanced comparisons. For example, here is a UTF-8 collation that supports case-insensitive comparisons. The code is too long to paste here, but go to that link and read the body of my_strnncollsp_utf8mb4(). This collation can process multiple bytes at a time and it can apply various transforms (such as case insensitive comparison). The = operator is completely abstracted from the vagaries of the collation.The SQL Standard \xc2\xa7 8.5 describes how LIKE compares strings:The <predicate>M LIKE Pis true if there exists a partitioning of M into substrings\n  such that:i) A substring of M is a sequence of 0 or more contiguous\n  <character representation>s of M and each <character \n  representation> of M is part of exactly one substring.ii) If the i-th substring specifier of P is an arbitrary \n  character specifier, the i-th substring of M is any single\n  <character representation>.iii) If the i-th substring specifier of P is an arbitrary string\n  specifier, then the i-th substring of M is any sequence of\n  0 or more <character representation>s.iv) If the i-th substring specifier of P is neither an \n  arbitrary character specifier nor an arbitrary string specifier, \n  then the i-th substring of M is equal to that substring \n  specifier according to the collating sequence of\n  the <like predicate>, without the appending of <space>\n  characters to M, and has the same length as that substring\n  specifier.v) The number of substrings of M is equal to the number of\n  substring specifiers of P.(Emphasis added.)This is pretty wordy, so let\'s break it down. Items ii and iii refer to the wildcards _ and %, respectively. If P does not contain any wildcards, then only item iv applies. This is the case of interest posed by the OP.In this case, it compares each "substring" (individual characters) in M against each substring in P using the current collation.The bottom line is that when comparing strings, = compares the entire string while LIKE compares one character at a time. Both comparisons use the current collation. This difference leads to different results in some cases, as evidenced in the first example in this post.Which one should you use? Nobody can tell you that \xe2\x80\x94 you need to use the one that\'s correct for your use case. Don\'t prematurely optimize by switching comparison operators.The equals (=) operator is a "comparison operator compares two values for equality."  In other words, in an SQL statement, it won\'t return true unless both sides of the equation are equal.  For example:The LIKE operator "implements a pattern match comparison" that attempts to match "a string value against a pattern string containing wild-card characters."  For example:LIKE is generally used only with strings and equals (I believe) is faster.  The equals operator treats wild-card characters as literal characters.  The difference in results returned are as follows:AndWould return the same result, though using LIKE would generally take longer as its a pattern match.  However,AndWould return different results, where using "=" results in only results with "Chris%" being returned and the LIKE operator will return anything starting with "Chris".Hope that helps.  Some good info can be found here.LIKE and = are different. LIKE is what you would use in a search query. It also allows wildcards like _ (simple character wildcard) and % (multi-character wildcard).= should be used if you want exact matches and it will be faster.This site explains LIKEThis is a copy/paste of another answer of mine for question SQL 'like' vs '=' performance:A personal example using mysql 5.5: I had an inner join between 2 tables, one of 3 million rows and one of 10 thousand rows.When using a like on an index as below(no wildcards), it took about 30 seconds:  using \'explain\' I get:When using an \'=\' on the same query, it took about 0.1 seconds:Using \'explain\' I get:As you can see, the like completely cancelled the index seek, so query took 300 times more time.One difference - apart from the possibility to use wildcards with LIKE - is in trailing spaces: The = operator ignores trailing space, but LIKE does not.Depends on the database system.Generally with no special characters, yes, = and LIKE are the same.Some database systems, however, may treat collation settings differently with the different operators.For instance, in MySQL comparisons with = on strings is always case-insensitive by default, so LIKE without special characters is the same. On some other RDBMS\'s LIKE is case-insensitive while = is not.For this example we take it for granted that varcharcol doesn\'t contain \'\' and have no empty cell against this columnThe first one results in 0 row output while the second one shows the whole list. = is strictly-match case while like acts like a filter. if filter has no criteria, every data is valid.like - by the virtue of its purpose works a little slower and is intended for use with varchar and similar data.To address the original question regarding performance, it comes down to index utilization.  When a simple table scan occurs, "LIKE" and "=" are identical.  When indexes are involved, it depends on how the LIKE clause is formed.  More specifically, what is the location of the wildcard(s)?Consider the following:There may be also negligible difference in the creation of the query plan when using "=" vs "LIKE".Using = avoids wildcards and special characters conflicts in the string when you build the query at run time. This makes the programmer\'s life easier by not having to escape all special wildcard characters that might slip in the LIKE clause and not producing the intended result. After all, = is the 99% use case scenario, it would be a pain to have to escape them every time.rolls eyes at \'90sI also suspect it\'s a little bit slower, but I doubt it\'s significant if there are no wildcards in the pattern.If you search for an exact match, you can use both,  = and LIKE.Using "=" is a tiny bit faster in this case (searching for an exact match) - you can check this yourself by having the same query twice in SQL Server Management Studio, once using "=", once using "LIKE", and then using the "Query" / "Include actual execution plan".Execute the two queries and you should see your results twice, plus the two actual execution plans. In my case, they were split 50% vs. 50%, but the "=" execution plan has a smaller "estimated subtree cost" (displayed when you hover over the left-most "SELECT" box) - but again, it\'s really not a huge difference.But when you start searching with wildcards in your LIKE expression, search performance will dimish. Search "LIKE Mill%" can still be quite fast - SQL Server can use an index on that column, if there is one. Searching "LIKE %expression%" is horribly slow, since the only way SQL Server can satisfy this search is by doing a full table scan. So be careful with your LIKE\'s ! MarcBesides the wildcards, the difference between = AND LIKE will depend on both the kind of SQL server and on the column type.Take this example:Using MS SQL Server 2012, the trailing spaces will be ignored in the comparison, except with LIKE when the column type is VARCHAR.Using MySQL 5.5, the trailing spaces will be ignored for =, but not for LIKE, both with CHAR and VARCHAR.Using PostgreSQL 9.1, spaces are significant with both = and LIKE using VARCHAR, but not with CHAR (see documentation).The behaviour with LIKE also differs with CHAR.Using the same data as above, using an explicit CAST on the column name also makes a difference:This only returns rows for "CAST both" and "CAST col".The LIKE keyword undoubtedly comes with a "performance price-tag" attached.  That said, if you have an input field that could potentially include wild card characters to be used in your query, I would recommend using LIKE only if the input contains one of the wild cards.  Otherwise, use the standard equal to comparison.Best regards...Really it comes down to what you want the query to do.  If you mean an exact match then use =.  If you mean a fuzzier match, then use LIKE.  Saying what you mean is usually a good policy with code.In Oracle, a \xe2\x80\x98like\xe2\x80\x99 with no wildcards will return the same result as an \xe2\x80\x98equals\xe2\x80\x99, but could require additional processing. According to Tom Kyte, Oracle will treat a \xe2\x80\x98like\xe2\x80\x99 with no wildcards as an \xe2\x80\x98equals\xe2\x80\x99 when using literals, but not when using bind variables.= and LIKE is not the same; 