Sorry for the waffly title - if I could come up with a concise title, I wouldn\'t have to ask the question.Suppose I have an immutable list type. It has an operation Foo(x) which returns a new immutable list with the specified argument as an extra element at the end. So to build up a list of strings with values "Hello", "immutable", "world" you could write:(This is C# code, and I\'m most interested in a C# suggestion if you feel the language is important. It\'s not fundamentally a language question, but the idioms of the language may be important.)The important thing is that the existing lists are not altered by Foo - so empty.Count would still return 0.Another (more idiomatic) way of getting to the end result would be:My question is: what\'s the best name for Foo?EDIT 3: As I reveal later on, the name of the type might not actually be ImmutableList<T>, which makes the position clear. Imagine instead that it\'s TestSuite and that it\'s immutable because the whole of the framework it\'s a part of is immutable...(End of edit 3)Options I\'ve come up with so far:The criteria I\'m using for choosing are:Please ask for more details if I\'m not making myself clear enough...EDIT 1: Here\'s my reasoning for preferring Plus to Add. Consider these two lines of code:In my view (and this is a personal thing) the latter is clearly buggy - it\'s like writing "x + 5;" as a statement on its own. The first line looks like it\'s okay, until you remember that it\'s immutable. In fact, the way that the plus operator on its own doesn\'t mutate its operands is another reason why Plus is my favourite. Without the slight ickiness of operator overloading, it still gives the same connotations, which include (for me) not mutating the operands (or method target in this case).EDIT 2: Reasons for not liking Add.Various answers are effectively: "Go with Add. That\'s what DateTime does, and String has Replace methods etc which don\'t make the immutability obvious." I agree - there\'s precedence here. However, I\'ve seen plenty of people call DateTime.Add or String.Replace and expect mutation. There are loads of newsgroup questions (and probably SO ones if I dig around) which are answered by "You\'re ignoring the return value of String.Replace; strings are immutable, a new string gets returned."Now, I should reveal a subtlety to the question - the type might not actually be an immutable list, but a different immutable type. In particular, I\'m working on a benchmarking framework where you add tests to a suite, and that creates a new suite. It might be obvious that:isn\'t going to accomplish anything, but it becomes a lot murkier when you change it to:That looks like it should be okay. Whereas this, to me, makes the mistake clearer:That\'s just begging to be:Ideally, I would like my users not to have to be told that the test suite is immutable. I want them to fall into the pit of success. This may not be possible, but I\'d like to try.I apologise for over-simplifying the original question by talking only about an immutable list type. Not all collections are quite as self-descriptive as ImmutableList<T> :)In situations like that, I usually go with Concat.  That usually implies to me that a new object is being created.I\'d go with Cons, for one simple reason: it means exactly what you want it to.I\'m a huge fan of saying exactly what I mean, especially in source code.  A newbie will have to look up the definition of Cons only once, but then read and use that a thousand times.  I find that, in the long term, it\'s nicer to work with systems that make the common case easier, even if the up-front cost is a little bit higher.The fact that it would be "meaningless" to people with no FP experience is actually a big advantage.  As you pointed out, all of the other words you found already have some meaning, and that meaning is either slightly different or ambiguous.  A new concept should have a new word (or in this case, an old one).  I\'d rather somebody have to look up the definition of Cons, than to assume incorrectly he knows what Add does.Other operations borrowed from functional languages often keep their original names, with no apparent catastrophes.  I haven\'t seen any push to come up with synonyms for "map" and "reduce" that sound more familiar to non-FPers, nor do I see any benefit from doing so.(Full disclosure: I\'m a Lisp programmer, so I already know what Cons means.)Actually I like And, especially in the idiomatic way.  I\'d especially like it if you had a static readonly property for the Empty list, and perhaps make the constructor private so you always have to build from the empty list.Whenever I\'m in a jam with nomenclature, I hit up the interwebs.thesaurus.com returns this for "add":Definition: adjoin, increase; make\n  further commentSynonyms: affix,\n  annex, ante, append, augment, beef\n  up, boost, build up, charge up,\n  continue, cue in, figure in, flesh\n  out, heat up, hike, hike up, hitch on,\n  hook on, hook up with, include, jack\n  up, jazz up, join together, pad,\n  parlay, piggyback, plug into, pour it\n  on, reply, run up, say further, slap\n  on, snowball, soup up, speed up,\n  spike, step up, supplement, sweeten,\n  tack on, tagI like the sound of Adjoin, or more simply Join.  That is what you\'re doing, right?  The method could also apply to joining other ImmutableList<>\'s.Personally, I like .With().  If I was using the object, after reading the documentation or the code comments, it would be clear what it does, and it reads ok in the source code.Or, you add "Along" with it..  :)I ended up going with Add for all of my Immutable Collections in BclExtras.  The reason being is that it\'s an easy predictable name.  I\'m not worried so much about people confusing Add with a mutating add since the name of the type is prefixed with Immutable.For awhile I considered Cons and other functional style names.  Eventually I discounted them because they\'re not nearly as well known.  Sure functional programmers will understand but they\'re not the majority of users.Other Names: you mentioned:Options I considered:Unfortunately there doesn\'t really seem to be a word that is It gets even more odd when you consider collections other than List.  Take for instance Stack.  Even first year programmers can tell you that Stacks have a Push/Pop pair of methods.  If you create an ImmutableStack and give it a completely different name, lets call it Foo/Fop, you\'ve just added more work for them to use your collection.  Edit: Response to Plus EditI see where you\'re going with Plus.  I think a stronger case would actually be Minus for remove.  If I saw the following I would certainly wonder what in the world the programmer was thinkingThe biggest problem I have with Plus/Minus or a new pairing is it feels like overkill.  The collection itself already has a distinguishing name, the Immutable prefix.  Why go further by adding vocabulary whose intent is to add the same distinction as the Immutable prefix already did.I can see the call site argument.  It makes it clearer from the standpoint of a single expression.  But in the context of the entire function it seems unnecessary.Edit 2Agree that people have definitely been confused by String.Concat and DateTime.Add.  I\'ve seen several very bright programmers hit this problem.  However I think ImmutableList is a different argument.  There is nothing about String or DateTime that establishes it as Immutable to a programmer.  You must simply know that it\'s immutable via some other source.  So the confusion is not unexpected.  ImmutableList does not have that problem because the name defines it\'s behavior.  You could argue that people don\'t know what Immutable is and I think that\'s also valid.  I certainly didn\'t know it till about year 2 in college.  But you have the same issue with whatever name you choose instead of Add.  Edit 3: What about types like TestSuite which are immutable but do not contain the word?I think this drives home the idea that you shouldn\'t be inventing new method names.  Namely because there is clearly a drive to make types immutable in order to facilitate parallel operations.  If you focus on changing the name of methods for collections, the next step will be the mutating method names on every type you use that is immutable. I think it would be a more valuable effort to instead focus on making types identifiable as Immutable.  That way you can solve the problem without rethinking every mutating method pattern out there.  Now how can you identify TestSuite as Immutable?  In todays environment I think there are a few waysMy guess/hope is development tools will start helping this problem by making it easy to identify immutable types simply by sight (different color, stronger font, etc ...).  But I think that\'s the answer though over changing all of the method names.  I think this may be one of those rare situations where it\'s acceptable to overload the + operator.  In math terminology, we know that + doesn\'t append something to the end of something else.  It always combines two values together and returns a new resulting value.For example, it\'s intuitively obvious that when you saythe resulting value of x is 4, not 22.Similarly,should make clear what each variable is going to hold.  It should be clear that list2 is not changed in the last line, but instead that list3 is assigned the result of appending "word" to list2.Otherwise, I would just name the function Plus().To be as clear as possible, you might want to go with the wordier CopyAndAdd, or something similar.I would call it Extend() or maybe ExtendWith() if you feel like really verbose.Extends means adding something to something else without changing it. I think this is very relevant terminology in C# since this is similar to the concept of extension methods - they "add" a new method to a class without "touching" the class itself.Otherwise, if you really want to emphasize that you don\'t modify the original object at all, using some prefix like Get- looks like unavoidable to me.I like mmyers suggestion of CopyAndAdd. In keeping with a "mutation" theme, maybe you could go with Bud (asexual reproduction), Grow, Replicate, or Evolve? =)EDIT: To continue with my genetic theme, how about Procreate, implying that a new object is made which is based on the previous one, but with something new added.Added(), Appended()I like to use the past tense for operations on immutable objects. It conveys the idea that you aren\'t changing the original object, and it\'s easy to recognize when you see it.Also, because mutating method names are often present-tense verbs, it applies to most of the immutable-method-name-needed cases you run into. For example an immutable stack has the methods "pushed" and "popped".This is probably a stretch, but in Ruby there is a commonly used notation for the distinction: add doesn\'t mutate; add! mutates. If this is an pervasive problem in your project, you could do that too (not necessarily with non-alphabetic characters, but consistently using a notation to indicate mutating/non-mutating methods).Join seems appropriate.Maybe the confusion stems from the fact that you want two operations in one. Why not separate them? DSL style:Copy would return an intermediate object, that\'s a mutable copy of the original list. With would return a new immutable list.Update:But, having an intermediate, mutable collection around is not a good approach. The intermediate object should be contained in the Copy operation:Now, the Copy operation takes a delegate, which receives a mutable list, so that it can control the copy outcome. It can do much more than appending an element, like removing elements or sorting the list. It can also be used in the ImmutableList constructor to assemble the initial list without intermediary immutable lists.Now there\'s no possibility of misinterpretation by the users, they will naturally fall into the pit of success.Yet another update:If you still don\'t like the mutable list mention, even now that it\'s contained, you can design a specification object, that will specify, or script, how the copy operation will transform its list. The usage will be the same:Now you can be creative with the rules names and you can only expose the functionality that you want Copy to support, not the entire capabilities of an IList.For the chaining usage, you can create a reasonable constructor (which will not use chaining, of course):Or use the same delegate in another constructor:This assumes that the rules.Append method returns this.This is what it would look like with your latest example:A few random thoughts:DateTime in C# uses Add. So why not use the same name? As long the users of your class understand the class is immutable. I think the key thing you\'re trying to get at that\'s hard to express is the nonpermutation, so maybe something with a generative word in it, something like CopyWith() or InstancePlus().I don\'t think the English language will let you imply immutability in an unmistakable way while using a verb that means the same thing as "Add".  "Plus" almost does it, but people can still make the mistake.  The only way you\'re going to prevent your users from mistaking the object for something mutable is by making it explicit, either through the name of the object itself or through the name of the method (as with the verbose options like "GetCopyWith" or "CopyAndAdd").So just go with your favourite, "Plus."First, an interesting starting point:\nhttp://en.wikipedia.org/wiki/Naming_conventions_(programming)  ...In particular, check the "See Also" links at the bottom.I\'m in favor of either Plus or And, effectively equally.Plus and And are both math-based in etymology.  As such, both connote mathematical operation; both yield an expression which reads naturally as expressions which may resolve into a value, which fits with the method having a return value.  And bears additional logic connotation, but both words apply intuitively to lists.  Add connotes action performed on an object, which conflicts with the method\'s immutable semantics.Both are short, which is especially important given the primitiveness of the operation.  Simple, frequently-performed operations deserve shorter names.Expressing immutable semantics is something I prefer to do via context.  That is, I\'d rather simply imply that this entire block of code has a functional feel; assume everything is immutable.  That might just be me, however.  I prefer immutability to be the rule; if it\'s done, it\'s done a lot in the same place; mutability is the exception.How about Chain() or Attach()?I prefer Plus (and Minus). They are easily understandable and map directly to operations involving well known immutable types (the numbers). 2+2 doesn\'t change the value of 2, it returns a new, equally immutable, value.Some other possibilities:Splice()Graft()Accrete()Apparently I\'m the first Obj-C/Cocoa person to answer this question.Not going to win any code golf games with this.How about mate, mateWith, or coitus, for those who abide.  In terms of reproducing mammals are generally considered immutable.Going to throw Union out there too.  Borrowed from SQL.I think "Add" or "Plus" sounds fine.  The name of the list itself should be enough to convey the list\'s immutability. Maybe there are some words which remember me more of making a copy and add stuff to that instead of mutating the instance (like "Concatenate"). But i think having some symmetry for those words for other actions would be good to have too. I don\'t know of a similar word for "Remove" that i think of the same kind like "Concatenate". "Plus" sounds little strange to me. I wouldn\'t expect it being used in a non-numerical context. But that could aswell come from my non-english background.Maybe i would use this schemeThese have their own problems though, when i think about it. One could think they remove something or add something to an argument given. Not sure about it at all. Those words do not play nice in chaining either, i think. Too wordy to type. Maybe i would just use plain "Add" and friends too. I like how it is used in mathWell, certainly, a 2 remains a 2 and you get a new number. This is about two numbers and not about a list and an element, but i think it has some analogy. In my opinion, add does not necessarily mean you mutate something. I certainly see your point that having a lonely statement containing just an add and not using the returned new object does not look buggy. But I\'ve now also thought some time about that idea of using another name than "add" but i just can\'t come up with another name, without making me think "hmm, i would need to look at the documentation to know what it is about" because its name differs from what I would expect to be called "add". Just some weird thought about this from litb, not sure it makes sense at all :)Looking at http://thesaurus.reference.com/browse/add and http://thesaurus.reference.com/browse/plus I found gain and affix but I\'m not sure how much they imply non-mutation.I think that Plus() and Minus() or, alternatively, Including(), Excluding() are reasonable at implying immutable behavior. However, no naming choice will ever make it perfectly clear to everyone, so I personally believe that a good xml doc comment would go a very long way here. VS throws these right in your face when you write code in the IDE - they\'re hard to ignore.Append - because, note that names of the System.String methods suggest that they mutate the instance, but they don\'t.Or I quite like AfterAppending:list.CopyWith(element) As does Smalltalk :)And also list.copyWithout(element) that removes all occurrences of an element, which is most useful when used as list.copyWithout(null) to remove unset elements.I would go for Add, because I can see the benefit of a better name, but the problem would be to find different names for every other immutable operation which might make the class quite unfamiliar if that makes sense.