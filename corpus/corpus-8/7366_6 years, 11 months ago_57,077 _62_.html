I am trying to understand what Python\'s descriptors are and what they can be useful for. However, I am failing at it. I understand how they work, but here are my doubts. Consider the following code:Why do I need the descriptor class? Please explain using this example or the one you think is better. What is instance and owner here? (in __get__). So my question is, what is the purpose of the third parameter here?How would I call/ use this example?The descriptor is how Python\'s property type is implemented. A descriptor simply implements __get__, __set__, etc. and is then added to another class in its definition (as you did above with the Temperature class). For example:Accessing the property you assigned the descriptor to (celsius in the above example) calls the appropriate descriptor method.instance in __get__ is the instance of the class (so above, __get__ would receive temp, while owner is the class with the descriptor (so it would be Temperature).You need to use a descriptor class to encapsulate the logic that powers it. That way, if the descriptor is used to cache some expensive operation (for example), it could store the value on itself and not its class.An article about descriptors can be found at http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/EDIT: As jchl pointed out in the comments, if you simply try Temperature.celsius, instance will be None.Why do I need the descriptor class? Please explain using this example or the one you think is better.it gives you extra control over how attributes work.  if you\'re used to getters and setters in java, for example, then it\'s python\'s way of doing that.  one advantage is that it looks to users just like an attribute (there\'s no change in syntax).  so you can start with an ordinary attribute and then, when you need to do something fancy, switch to a descriptor.an attribute is just a mutable value.  a descriptor lets you execute arbitrary code when reading or setting (or deleting) a value.  so you could imagine using it to map an attribute to a field in a database, for example - a kind of ORM.another use might be refusing to accept a new value by throwing an exception in __set__ - effectively making the "attribute" read only.What is instance and owner here? (in __get__). So my question is, what is the purpose of the third parameter here?this is pretty subtle (and the reason i am writing a new answer here - i found this question while wondering the same thing and didn\'t find the existing answer that great).a descriptor is defined on a class, but is typically called from an instance.  when it\'s called from an instance both instance and owner are set (and you can work out owner from instance so it seems kinda pointless).  but when called from a class, only owner is set - which is why it\'s there.this is only needed for __get__ because it\'s the only one that can be called on a class.  if you set the class value you set the descriptor itself.  similarly for deletion.  which is why the owner isn\'t needed there.How would I call/ use this example?well, here\'s a cool trick using similar classes:(i\'m using python 3; for python 2 you need to make sure those divisions are / 5.0 and / 9.0).  that gives:now there are other, arguably better ways to achieve the same effect in python (eg if celsius were a property, which is the same basic mechanism but places all the source inside the Temperature class), but that shows what can be done...I am trying to understand what Python\'s descriptors are and what they\n  can useful for.Descriptors are objects with any of __get__, __set__, or __delete__. These descriptor objects can be used as attributes on other object class definitions. Descriptor objects can be used to programmatically manage the results of a dotted lookup (e.g. foo.descriptor) in a normal expression, an assignment, and even a deletion. Bound methods, property, classmethod, and staticmethod all use these special methods to manage how they are accessed via the dotted lookup.A descriptor is an object with any of the following methods (__get__, __set__, or __delete__), intended to be used via dotted-lookup as if it were a typical attribute of an instance. For an owner-object, obj_instance, with a descriptor object:descriptor.__get__(self, obj_instance, owner_class) (returning a value)\nis invoked by\nobj_instance.descriptordescriptor.__set__(self, obj_instance, value) (returning None)\nis invoked by\nobj_instance.descriptor = value descriptor.__delete__(self, obj_instance) (returning None)\nis invoked by\ndel obj_instance.descriptor obj_instance is the instance whose class contains the descriptor object\'s instance. self is the instance of the descriptor (probably just one for the class of the obj_instance)To define this with code, an object is a descriptor if the set of its attributes intersects with any of the required attributes:A Data Descriptor has a __set__ and/or __delete__.\nA Non-Data-Descriptor has neither __set__ nor __delete__.We can see that classmethod and staticmethod are Non-Data-Descriptors:Both only have the __get__ method:Note that all functions are also Non-Data-Descriptors:However, property is a Data-Descriptor:These are important distinctions, as they affect the lookup order for a dotted lookup. The consequence of this lookup order is that Non-Data-Descriptors like functions/methods can be overridden by instances.We have learned that descriptors are objects with any of __get__, __set__, or __delete__. These descriptor objects can be used as attributes on other object class definitions. Now we will look at how they are used, using your code as an example.Here\'s your code, followed by your questions and answers to each:Your descriptor ensures you always have a float for this class attribute of Temperature, and that you can\'t use del to delete the attribute:Otherwise, your descriptors ignore the owner-class and instances of the owner, instead, storing state in the descriptor. You could just as easily share state across all instances with a simple class attribute (so long as you always set it as a float to the class and never delete it, or are comfortable with users of your code doing so):This gets you exactly the same behavior as your example (see response to question 3 below), but uses a Pythons builtin (property), and would be considered more idiomatic:instance is the instance of the owner that is calling the descriptor. The owner is the class in which the descriptor object is used to manage access to the data point. See the descriptions of the special methods that define descriptors next to the first paragraph of this answer for more descriptive variable names.Here\'s a demonstration:You can\'t delete the attribute:And you can\'t assign a variable that can\'t be converted to a float:Otherwise, what you have here is a global state for all instances, that is managed by assigning to any instance.  The expected way that most experienced Python programmers would accomplish this outcome would be to use the property decorator, which makes use of the same descriptors under the hood, but brings the behavior into the implementation of the owner class:Which has the exact same expected behavior of the original piece of code:We\'ve covered the attributes that define descriptors, the difference between data- and non-data-descriptors, builtin objects that use them, and specific questions about use.So again, how would you use the question\'s example? I hope you wouldn\'t. I hope you would start with my first suggestion (a simple class attribute) and move on to the second suggestion (the property decorator) if you feel it is necessary. Why do I need the descriptor class? Please explain using this example or the one you think is better.Inspired by Fluent Python by Buciano RamalhoImaging you have a class like thisWe should validate the weight and price in avoid to assign them a negative number, we can write less code if we use descriptor as a proxy as thisthen define class LineItem like this:and we can extend the Quantity class to do more common validatingI tried (with minor changes as suggested) the code from Andrew Cooke\'s answer. (I am running python 2.7).The code:The result:With Python prior to 3, make sure you subclass from object which will make the descriptor work correctly as the get magic does not work for old style classes.