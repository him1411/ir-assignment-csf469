This question already has an answer here:What is the most modern (best) way of satisfying the following in C#?BUT with a minimum of fuss involving salts, keys, mucking about with byte[], etc.Been Googling and confused at what I\'m finding (you can see the list of similar SO Qs to see this is a deceptive question to ask).UPDATE 23/Dec/2015: Since this answer seems to be getting a lot of upvotes, I\'ve updated it to fix silly bugs and to generally improve the code based upon comments and feedback.  See the end of the post for a list of specific improvements.As other people have said, Cryptography is not simple so it\'s best to avoid "rolling your own" encryption algorithm.You can, however, "roll your own" wrapper class around something like the built-in RijndaelManaged cryptography class.Rijndael is the algorithmic name of the current Advanced Encryption Standard, so you\'re certainly using an algorithm that could be considered "best practice".The RijndaelManaged class does indeed normally require you to "muck about" with byte arrays, salts, keys, initialization vectors etc. but this is precisely the kind of detail that can be somewhat abstracted away within your "wrapper" class.The following class is one I wrote a while ago to perform exactly the kind of thing you\'re after, a simple single method call to allow some string-based plaintext to be encrypted with a string-based password, with the resulting encrypted string also being represented as a string.  Of course, there\'s an equivalent method to decrypt the encrypted string with the same password.Unlike the first version of this code, which used the exact same salt and IV values every time, this newer version will generate random salt and IV values each time.  Since salt and IV must be the same between the encryption and decryption of a given string, the salt and IV is prepended to the cipher text upon encryption and extracted from it again in order to perform the decryption.  The result of this is that encrypting the exact same plaintext with the exact same password gives and entirely different ciphertext result each time.The "strength" of using this comes from using the RijndaelManaged class to perform the encryption for you, along with using the Rfc2898DeriveBytes function of the System.Security.Cryptography namespace which will generate your encryption key using a standard and secure algorithm (specifically, PBKDF2) based upon the string-based password you supply.  (Note this is an improvement of the first version\'s use of the older PBKDF1 algorithm).Finally, it\'s important to note that this is still unauthenticated encryption.  Encryption alone provides only privacy (i.e. message is unknown to 3rd parties), whilst authenticated encryption aims to provide both privacy and authenticity (i.e. recipient knows message was sent by the sender).  Without knowing your exact requirements, it\'s difficult to say whether the code here is sufficiently secure for your needs, however, it has been produced to deliver a good balance between relative simplicity of implementation vs "quality".  For example, if your "receiver" of an encrypted string is receiving the string directly from a trusted "sender", then authentication may not even be necessary.If you require something more complex, and which offers authenticated encryption, check out this post for an implementation.Here\'s the code:The above class can be used quite simply with code similar to the following:(You can download a simple VS2013 sample solution (which includes a few unit tests) here).UPDATE 23/Dec/2015:\nThe list of specific improvements to the code are:  Try this class:and use it like this:If you need to store a password in memory and would like to have it encrypted you should use SecureString:http://msdn.microsoft.com/en-us/library/system.security.securestring.aspxFor more general uses I would use a FIPS approved algorithm such as Advanced Encryption Standard, formerly known as Rijndael. See this page for an implementation example:http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndael.aspxYou may be looking for the ProtectedData class, which encrypts data using the user\'s logon credentials.If you are targeting ASP.NET Core that does not support RijndaelManaged yet, you can use IDataProtectionProvider.First, configure your application to use data protection:Then you\'ll be able to inject IDataProtectionProvider instance and use it to encrypt/decrypt data:See this article for more details.The easiest way that I\'ve seen to do encryption is through RSACheck out the MSDN on it: http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspxIt does involve using bytes, but when it comes down to it you kind of do want encryption and decryption to be tough to figure out otherwise it will be easy to hack.