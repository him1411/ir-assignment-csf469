This question already has an answer here:In Stack Overflow question Redefining lambdas not allowed in C++11, why?, a small program was given that does not compile:The question was answered and all seemed fine. Then came Johannes Schaub and made an interesting observation:If you put a + before the first lambda, it magically starts to work.So I\'m curious: Why does the following work?It compiles fine with both GCC 4.7+ and Clang 3.2+. Is the code standard conforming?Yes, the code is standard conforming. The + triggers a conversion to a plain old function pointer for the lambda.What happens is this:The compiler sees the first lambda ([]{}) and generates a closure object according to \xc2\xa75.1.2. As the lambda is a non-capturing lambda, the following applies:6 The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\xe2\x80\x99s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\xe2\x80\x99s function call operator.This is important as the unary operator + has a set of built-in overloads, specifically this one:8 For every type T there exist candidate operator functions of the form    T* operator+(T*);And with this, it\'s quite clear what happens: When operator + is applied to the closure object, the set of overloaded built-in candidates contains a conversion-to-any-pointer and the closure type contains exactly one candidate: The conversion to the function pointer of the lambda.The type of test in auto test = +[]{}; is therefore deduced to void(*)(). Now the second line is easy: For the second lambda/closure object, an assignment to the function pointer triggers the same conversion as in the first line. Even though the second lambda has a different closure type, the resulting function pointer is, of course, compatible and can be assigned.