This question already has an answer here:I recently was introduced to a large codebase and noticed all string comparisons are done using String.Equals() instead of == What\'s the reason for this, do you think?It\'s entirely likely that a large portion of the developer base comes from a Java background where using == to compare strings is wrong and doesn\'t work.In C# there\'s no (practical) difference (for strings) as long as they are typed as string.If they are typed as object or T then see other answers here that talk about generic methods or operator overloading as there you definitely want to use the Equals method.There is practical difference between string.Equals and ==Adding WatchNow look at {1#} and {5#}obj, str2, str4 and obj2 references are same. obj and obj2 are object type and others are string typeConclusion:There is one subtle but very important difference between == and the String.Equals methods:Produces this output:You can see that the == operator is returning false to two obviously equal strings. Why? Because the == operator in use in the generic method is resolved to be the op_equal method as defined by System.Object (the only guarantee of T the method has at compile time), which means that it\'s reference equality instead of value equality.When you have two values typed as System.String explicitly, then == has a value-equality semantic because the compiler resolves the == to System.String.op_equal instead of System.Object.op_equal.So to play it safe, I almost always use String.Equals instead to that I always get the value equality semantics I want.And to avoid NullReferenceExceptions if one of the values is null, I always use the static String.Equals method:String.Equals does offer overloads to handle casing and culture-aware comparison.  If your code doesn\'t make use of these, the devs may just be used to Java, where (as Matthew says), you must use the .Equals method to do content comparisons.There\'s a writeup on this article which you might find to be interesting, with some quotes from Jon Skeet. It seems like the use is pretty much the same.Jon Skeet states that the performance of instance Equals "is slightly better when the strings are short\xe2\x80\x94as the strings increase in length, that difference becomes completely insignificant."Both methods do the same functionality - to compare values.\nAs it is written in MSDN:But if one of your string instances is null, these methods are working differently:I want to add that there is another difference. It is related to what Andrew posts.It is also related to a VERY annoying to find bug in our software. See the following simplified example (I also omitted the null check).This will compile and always return false. While the following will give a compile error:We have had to solve a similar problem where someone compared enums of different type using Equals. You are going to read over this MANY times before realising it is the cause of the bug. Especially if the definition of SPECIAL_NUMBER is not near the problem area.This is why I am really against the use of Equals in situations where is it not necessary. You lose a little bit of type-safety.I\'ve just been banging my head against a wall trying to solve a bug because I read this page and concluded there was no meaningful difference when in practice there is so I\'ll post this link here in case anyone else finds they get different results out of == and equals.Object == equality fails, but .Equals succeeds. Does this make sense?I sometimes use the .Equals method, because it can make things slightly clearer and more concise at times. Consider:The test for NULL can be completely ignored if using .Equals like so: