Recently I read through this\n Developer Works Document. The document is all about defining hashCode() and equals() effectively and correctly, but I am not able to figure out why we need to override these two methods. How can I take the decision to implement these method efficiently?Joshua Bloch says on Effective JavaYou must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable.Let\'s try to understand it with an example of what would happen if we override equals() without overriding hashCode() and attempt to use a Map.Say we have a class like this and that two objects of MyClass are equal if their importantField is equal (with hashCode() and equals() generated by eclipse)Override only equalsIf only equals is overriden, then when you call myMap.put(first,someValue) first will hash to some bucket and when you call myMap.put(second,someOtherValue) it will hash to some other bucket (as they have a different hashCode). So, although they are equal, as they don\'t hash to the same bucket, the map can\'t realize it and both of them stay in the map.Although it is not necessary to override equals() if we override hashCode(), let\'s see what would happen in this particular case where we know that two objects of MyClass are equal if their importantField is equal but we do not override equals().Override only hashCodeImagine you have thisIf you only override hashCode then when you call myMap.put(first,someValue) it takes first, calculates its hashCode and stores it in a given bucket. Then when you call myMap.put(second,someOtherValue) it should replace first with second  as per the Map Documentation because they are equal (according to the business requirement).But the problem is that equals was not redefined, so when the map hashes second and iterates through the bucket looking if there is an object k such that second.equals(k) is true it won\'t find any as second.equals(first) will be false.Hope it was clearCollections such as HashMap and HashSet use the hashcode value of an object to determine how the object should be stored in the collection, and the hashcode is used again to help locate the object\nin the collection.Hashing retrieval is a two-step process.here is a small example why we should overrride equals() and hashcode().Consider an Employee class which has two fields age and name.Now create a class, insert Employee object to a HashSet and test whether that object is present or not.Now remove the commented line from hashcode() and execute the same you will find below resultNow can you see why if two objects are considered equal, their hashcodes must\nalso be equal? Otherwise, you\'d never be able to find the object since the default\nhashcode method in class Object virtually always comes up with a unique number\nfor each object, even if the equals() method is overridden in such a way that two\nor more objects are considered equal. It doesn\'t matter how equal the objects are if\ntheir hashcodes don\'t reflect that. So one more time: If two objects are equal, their\nhashcodes must be equal as well.You must override hashCode() in every\n  class that overrides equals(). Failure\n  to do so will result in a violation of\n  the general contract for\n  Object.hashCode(), which will prevent\n  your class from functioning properly\n  in conjunction with all hash-based\n  collections, including HashMap,\n  HashSet, and Hashtable.    from Effective Java, by Joshua BlochBy defining equals() and hashCode() consistently, you can improve the usability of your classes as keys in hash-based collections. As the API doc for hashCode explains: "This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable." The best answer to your question about how to implement these methods efficiently is suggesting you to read Chapter 3 of Effective Java.Simply put, the equals-method in Object check for reference equality, where as two instances of your class could still be semantically equal when the properties are equal. This is for instance important when putting your objects into a container that utilizes equals and hashcode, like HashMap and Set. Let\'s say we have a class like:We create two instances with the same id:Without overriding equals we are getting:Correct? Well maybe, if this is what you want. But let\'s say we want objects with the same id to be the same object, regardless if it\'s two different instances. We override the equals (and hashcode):As for implementing equals and hashcode I can recommend using Guava\'s helper methodsOk, Let me explain the concept in very simple words.Firstly from a broader perspective we have collections,and hashmap is one of the datastructure in the collections.To understand why we have to override the both equals and hashcode method, if need to first understand what is hashmap and what is does.A hashmap is a datastructure which stores key value pairs of data in array fashion. Lets say a[], where each element in \'a\' is a key value pair.Also each index in the above array can be linked list thereby having more than one values at one index.Now why is a hashmap used?\nIf we have to search among  a large array then searching through each if them will not be efficient, so what hash technique tells us that lets pre process the array with some logic and group the elements based on that logic i.e. Hashingeg: we have array 1,2,3,4,5,6,7,8,9,10,11 and we apply a hash function mod 10 so 1,11 will be grouped in together. So if we had to search for 11 in previous array then we would have to iterate the complete array but when we group it we limit our scope of iteration thereby improving speed. That datastructure used to store all the above information can be thought of as a 2d array for simplicityNow apart from the above hashmap also tells that it wont add any Duplicates in it. And this is the main reason why we have to override the equals and hashcodeSo when its said that explain the internal working of hashmap , we need to find what methods the hashmap has and how does it follow the above rules which i explained aboveso the hashmap has method called as put(K,V) , and according to hashmap it should follow the above rules of efficiently distributing the array and not adding any duplicatesso what put does is that it will first generate the hashcode for the given key to decide which index the value should go in.if nothing is present at that index then the new value will be added over there, if something is already present over there then the new value should be added after the end of the linked list at that index. but remember no duplicates should be added as per the desired behavior of the hashmap. so lets say you have two Integer objects aa=11,bb=11.\nas every object derived from the object class, the default implementation for comparing two objects is that it compares the reference and not values inside the object. So in the above case both though semantically equal will fail the equality test, and possibility that two objects which same hashcode and same values will exists thereby creating duplicates. If we override then we could avoid adding duplicates.\nYou could also refer to Detail workinghashCode() :If you only override hash-code method nothing will happen. Because it always return new hashCode for each object  as an Object class.equals() :If you only override equal method, a.equals(b) is true it means the hashCode of a and b must be same but not happen. Because you did not override hashCode method.Note :  hashCode() method of Object class always return new hashCode for each object.So when you need to use your object in the hashing based collection, must override both equals() and hashCode().Why do I need to override the equals and hashCode methods in Java?   First we have to understand the use of equals method.In order to identity differences between two objects we need to override equals method.   For example:Now hashCode method can understand easily.hashCode produces integer in order to store object in data structures like HashMap, HashSet.Assume we have override equals method of Customer as above, While working with data structure when we store object in buckets. If we use built-in hash technique, for above two customers it generates two different hashcode. So we are storing the same identical object in two different places. To avoid this kind of issues we should override the hashCode method also based on the following principles.  Java puts a rule that "If two objects are equal using Object class equals method, then the hashcode method should give the same value for these two objects."So, if in our class we override equals we should override hashcode method also to fallow this rule.\nThese both methods equals and hashcode are used in Hashtable to store values as key-value pair.If we do override one and not the other , there is a possibility that the hashtable may not work as we want, if we use such object as key.In order to use our own class objects as keys in collections like HashMap, Hashtable etc.. , we should override both methods ( hashCode() and equals() ) by having an awareness on internal working of collection. Otherwise, it leads to wrong results which we are not expected.Equals and Hashcode methods in JavaThey are methods of java.lang.Object class which is the super class of all the classes (custom classes as well and others defined in java API).Implementation:public boolean equals(Object obj)public int hashCode()public boolean equals(Object obj)This method simply checks if two object references x and y refer to the same object. i.e. It checks if x == y.It is reflexive: for any reference value x, x.equals(x) should return true.It is symmetric: for any reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.It is transitive: for any reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.It is consistent: for any reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the object is modified.For any non-null reference value x, x.equals(null) should return\n  false.public int hashCode()This method returns the hash code value for the object on which this method is invoked. This method returns the hash code value as an integer and is supported for the benefit of hashing based collection classes such as Hashtable, HashMap, HashSet etc. This method must be overridden in every class that overrides the equals method.The general contract of hashCode is:Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.Equal objects must produce the same hash code as long as they are\n  equal, however unequal objects need not produce distinct hash codes.Resources: JavaRanchPictureBecause if you do not override them you will be use the default implentation in Object.Given that instance equality and hascode values generally require knowledge of what makes up an object they generally will need to be redefined in your class to have any tangible meaning.Adding to @Lombo \'s answerWhen will you need to override equals() ?The default implementation of Object\'s equals() iswhich means two objects will be considered equal only if they have the same memory address which will be true only if you are\ncomparing an object with itself.But you might want to consider two objects the same if they have the same value for one\nor more of their properties (Refer the example given in @Lombo \'s answer). So you will override equals() in these situations and you would give your own conditions for equality.I have successfully implemented equals() and it is working great.So why are they asking to override hashCode() as well?Well.As long as you don\'t use "Hash" based Collections on your user-defined class,it is fine.\nBut some time in the future you might want to use HashMap or HashSet and if you don\'t override and "correctly implement" hashCode(), these Hash based collection won\'t work as intended.Override only equals (Addition to @Lombo \'s answer)First of all,HashMap checks if the hashCode of second is the same as first.\nOnly if the values are the same,it will proceed to check the equality in the same bucket.But here the hashCode is different for these 2 objects (because they have different memory address-from default implementation).\nHence it will not even care to check for equality.If you have a breakpoint inside your overridden equals() method,it wouldn\'t step in if they have different hashCodes.\ncontains() checks hashCode() and only if they are the same it would call your equals() method.Why can\'t we make the HashMap check for equality in all the buckets? So there is no necessity for me to override hashCode() !!Then you are missing the point of Hash based Collections.\nConsider the following :The following are the keys stored in the form of buckets.Say,you want to know if the map contains the key 10.\nWould you want to search all the buckets? or Would you want to search only one bucket?Based on the hashCode,you would identify that if 10 is present,it must be present in Bucket 1.\nSo only Bucket 1 will be searched !!Consider collection of balls in a bucket all in black color. Your Job is to color those balls as follows and use it for appropriate game,For Tennis - Yellow, Red.\nFor Cricket - WhiteNow bucket has balls in three colors Yellow, Red and White. And that now you did the coloring Only you know which color is for which game.Coloring the balls - Hashing.\nChoosing the ball for game - Equals.If you did the coloring and some one chooses the ball for either cricket or tennis they wont mind the color!!!I was looking into the explanation " If you only override hashCode then when you call myMap.put(first,someValue) it takes first, calculates its hashCode and stores it in a given bucket. Then when you call myMap.put(first,someOtherValue) it should replace first with second as per the Map Documentation because they are equal (according to our definition)." :I think 2nd time when we are adding in myMap then it should be the \'second\' object like myMap.put(second,someOtherValue)It is useful when using Value Objects. The following is an excerpt from the Portland Pattern Repository:Examples of value objects are things\n  like numbers, dates, monies and\n  strings. Usually, they are small\n  objects which are used quite widely.\n  Their identity is based on their state\n  rather than on their object identity.\n  This way, you can have multiple copies\n  of the same conceptual value object.So I can have multiple copies of an\n  object that represents the date 16 Jan\n  1998. Any of these copies will be equal to each other. For a small\n  object such as this, it is often\n  easier to create new ones and move\n  them around rather than rely on a\n  single object to represent the date.A value object should always override\n  .equals() in Java (or = in Smalltalk).\n  (Remember to override .hashCode() as\n  well.)Assume you have class (A) that aggregates two other (B) (C), and you need to store instances of (A) inside hashtable. Default implementation only allows distinguishing of instances, but not by (B) and (C). So two instances of A could be equal, but default wouldn\'t allow you to compare them in correct way.  The methods equals and hashcode are defined in the object class. By default if the equals method returns true, then the system will go further and check the value of the hash code. If the hash code of the 2 objects is also same only then the objects will be considered as same. So if you override only equals method, then even though the overridden equals method indicates 2 objects to be equal , the system defined hashcode may not indicate that the 2 objects are equal. So we need to override hash code as well.if Both are overridden,Map<A> if equals is not overriddenMap<A> If hashCode is not overriddenMap<A> HashCode Equal ContractIn the example below, if you comment out the override for equals or hashcode in the Person class, this code will fail to look up Tom\'s order. Using the default implementation of hashcode can cause failures in hashtable lookups.What I have below is a simplified code that pulls up people\'s order by Person. Person is being used as a key in the hashtable.String class and wrapper classes have different implementation of equals() and hashCode() methods than Object class. equals() method of Object class compares the references of the objects, not the contents. hashCode() method of Object class returns distinct hashcode for every single object whether the contents are same.It leads problem when you use Map collection and the key is of Persistent type, StringBuffer/builder type. Since they don\'t override equals() and hashCode() unlike String class, equals() will return false when you compare two different objects even though both have same contents. It will make the hashMap storing same content keys. Storing same content keys means it is violating the rule of Map because Map doesnt allow duplicate keys at all.\nTherefore you override equals() as well as hashCode() methods in your class and provide the implementation(IDE can generate these methods) so that they work same as String\'s equals() and hashCode() and prevent same content keys. You have to override hashCode() method along with equals() because equals() work according hashcode. Moreover overriding hashCode() method along with equals() helps to intact the equals()-hashCode() contract: "If two objects are equal, then they must have the same hash code."When do you need to write custom implementation for hashCode()?As we know that internal working of HashMap is on principle of Hashing. There are certain buckets where entrysets get stored. You customize the hashCode() implementation according your requirement so that same category objects can be stored into same index. \nwhen you store the values into Map collection using put(k,v)method, the internal implementation of put() is:Means, it generates index and the index is generated based on the hashcode of particular key object. So make this method generate hashcode according your requirement because same hashcode entrysets will be stored into same bucket or index. That\'s it!The reason behind this:\nWhen your object fields can be null, implementing Object.equals can be a pain, because you have to check separately for null. Using Objects.equal lets you perform equals checks in a null-sensitive way, without risking a NullPointerException.\nObjects.equal("a", "a"); // returns true\nObjects.equal(null, "a"); // returns false\nObjects.equal("a", null); // returns false\nObjects.equal(null, null); // returns truehashCode() method is used to get a unique integer for given object. This integer is used for determining the bucket location, when this object needs to be stored in some HashTable, HashMap like data structure. By default, Object\xe2\x80\x99s hashCode() method returns and integer representation of memory address where object is stored.The hashCode() method of objects is used when we insert them into a HashTable, HashMap or HashSet. More about HashTables on Wikipedia.org for reference.To insert any entry in map data structure, we need both key and value. If both key and values are user define data types, the hashCode() of the key will be determine where to store the object internally. When require to lookup the object from the map also, the hash code of the key will be determine where to search for the object.The hash code only points to a certain "area" (or list, bucket etc) internally. Since different key objects could potentially have the same hash code, the hash code itself is no guarantee that the right key is found. The HashTable then iterates this area (all keys with the same hash code) and uses the key\'s equals() method to find the right key. Once the right key is found, the object stored for that key is returned.So, as we can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a HashTable.NOTES:Always use same attributes of an object to generate hashCode() and equals() both. As in our case, we have used employee id.equals() must be consistent (if the objects are not modified, then it must keep returning the same value).Whenever a.equals(b), then a.hashCode() must be same as b.hashCode().If you override one, then you should override the other.http://parameshk.blogspot.in/2014/10/examples-of-comparable-comporator.htmlIMHO, it\'s as per the rule says - If two objects are equal then they should have same hash, i.e., equal objects should produce equal hash values.Given above, default equals() in Object is == which does comparison on the address, hashCode() returns the address in integer(hash on actual address) which is again distinct for distinct Object.If you need to use the custom Objects in the Hash based collections, you need to override both equals() and hashCode(), example If I want to maintain the HashSet of the Employee Objects, if I don\'t use stronger hashCode and equals I may endup overriding the two different Employee Objects, this happen when I use the age as the hashCode(), however I should be using the unique value which can be the Employee ID.1) The common mistake is shown in the example below.the green Car is not found2. Problem caused by hashCode()The problem is caused by the un-overridden method hashCode(). The contract between equals() and hashCode() is:If two objects have the same hash code, they may or may not be equal.As per java documentation, developers should override both methods in order to achieve a fully working equality mechanism and it\xe2\x80\x99s not enough to just implement the equals() method.If two objects are equal according to the equals(Object) method, then\n  calling the hashcode() method on each of the two objects must produce\n  the same integer result.Overriding equals() alone would serve your needs when checking the equality of 2 normal objects and would also work with you when searching for an element inside a list.However, you will fail when working with hashing data structures like: HashSet, HashMap, HashTable .. This tutorial describes in details along with examples why it\'s necessary to always override equals() and hashcode() together. It\'s worth reading, check it.Both the methods are defined in Object class. And both are in its simplest implementation. So when you need you want add some more implementation to these methods then you have override in  your class. For Ex: equals() method in object only checks its equality on the reference. So if you need compare its state as well then you can override that as it is done in String class.Bah - "You must override hashCode() in every class that overrides equals()."[from Effective Java, by Joshua Bloch?]Isn\'t this the wrong way round?  Overriding hashCode likely implies you\'re writing a hash-key class, but overriding equals certainly does not. There are many classes that are not used as hash-keys, but do want a logical-equality-testing method for some other reason. If you choose "equals" for it, you may then be mandated to write a hashCode implementation by overzealous application of this rule. All that achieves is adding untested code in the codebase, an evil waiting to trip someone up in the future. Also writing code you don\'t need is anti-agile. It\'s just wrong (and an ide generated one will probably be incompatible with your hand-crafted equals). Surely they should have mandated an Interface on objects written to be used as keys? Regardless, Object should never have provided default hashCode() and equals() imho. It\'s probably encouraged many broken hash collections.But anyway, I think the "rule" is written back to front. In the meantime, I\'ll keep avoiding using "equals" for equality testing methods :-(