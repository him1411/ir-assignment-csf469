I\'m reading the documentation and I am constantly shaking my head at some of the design decisions of the language.  But the thing that really got me puzzled is how arrays are handled.I rushed to the playground and tried these out.  You can try them too.  So the first example:Here a and b are both [1, 42, 3], which I can accept.  Arrays are referenced - OK!Now see this example:c is [1, 2, 3, 42] BUT d is [1, 2, 3].  That is, d saw the change in the last example but doesn\'t see it in this one.  The documentation says that\'s because the length changed.Now, how about this one:e is [4, 5, 3], which is cool.  It\'s nice to have a multi-index replacement, but f STILL doesn\'t see the change even though the length has not changed.So to sum it up, common references to an array see changes if you change 1 element, but if you change multiple elements or append items, a copy is made.This seems like a very poor design to me.  Am I right in thinking this?  Is there a reason I don\'t see why arrays should act like this?EDIT: Arrays have changed and now have value semantics.  Much more sane!Note that array semantics and syntax was changed in Xcode beta 3 version (blog post), so the question no longer applies. The following answer applied to beta 2:It\'s for performance reasons. Basically, they try to avoid copying arrays as long as they can (and claim "C-like performance"). To quote the language book:For arrays, copying only takes place when you perform an action that has the potential to modify the length of the array. This includes appending, inserting, or removing items, or using a ranged subscript to replace a range of items in the array.I agree that this is a bit confusing, but at least there is a clear and simple description of how it works.That section also includes information on how to make sure an array is uniquely referenced, how to force-copy arrays, and how to check whether two arrays share storage.From the official documentation of the Swift language:Note that the array is not copied when you set a new value with subscript syntax, because setting a single value with subscript syntax does not have the potential to change the array\xe2\x80\x99s length. However, if you append a new item to array, you do modify the array\xe2\x80\x99s length. This prompts Swift to create a new copy of the array at the point that you append the new value. Henceforth, a is a separate, independent copy of the array.....Read the whole section Assignment and Copy Behavior for Arrays in this documentation. You will find that when you do replace a range of items in the array then the array takes a copy of itself for all items. The behavior has changed with Xcode 6 beta 3. Arrays are no longer reference types and have a copy-on-write mechanism, meaning as soon as you change an array\'s content from one or the other variable, the array will be copied and only the one copy will be changed.Old answer:As others have pointed out, Swift tries to avoid copying arrays if possible, including when changing values for single indexes at a time.If you want to be sure that an array variable (!) is unique, i.e. not shared with another variable, you can call the unshare method. This copies the array unless it already only has one reference. Of course you can also call the copy method, which will always make a copy, but unshare is preferred to make sure no other variable holds on to the same array.The behavior is extremely similar to the Array.Resize method in .NET.  To understand what\'s going on, it may be helpful to look at the history of the . token in C, C++, Java, C#, and Swift.In C, a structure is nothing more than an aggregation of variables.  Applying the . to a variable of structure type will access a variable stored within the structure.  Pointers to objects do not hold aggregations of variables, but identify them.  If one has a pointer which identifies a structure, the -> operator may be used to access a variable stored within the structure identified by the pointer.In C++, structures and classes not only aggregate variables, but can also attach code to them.  Using . to invoke a method will on a variable ask that method to act upon the contents of the variable itself; using -> on a variable which identifies an object will ask that method to act upon the object identified by the variable.In Java, all custom variable types simply identify objects, and invoking a method upon a variable will tell the method what object is identified by the variable.  Variables cannot hold any kind of composite data type directly, nor is there any means by which a method can access a variable upon which it is invoked.  These restrictions, although semantically limiting, greatly simplify the runtime, and facilitate bytecode validation; such simplifications reduced the resource overhead of Java at a time when the market was sensitive to such issues, and thus helped it gain traction in the marketplace.  They also meant that there was no need for a token equivalent to the . used in C or C++.  Although Java could have used -> in the same way as C and C++, the creators opted to use single-character . since it was not needed for any other purpose.In C# and other .NET languages, variables can either identify objects or hold composite data types directly.  When used on a variable of a composite data type, . acts upon the contents of the variable; when used on a variable of reference type, . acts upon the object identified by it.  For some kinds of operations, the semantic distinction isn\'t particularly important, but for others it is.  The most problematical situations are those in which a composite data type\'s method which would modify the variable upon which it is invoked, is invoked on a read-only variable.  If an attempt is made to invoke a method on a read-only value or variable, compilers will generally copy the variable, let the method act upon that, and discard the variable.  This is generally safe with methods that only read the variable, but not safe with methods that write to it.  Unfortunately, .does has not as yet have any means of indicating which methods can safely be used with such substitution and which can\'t.In Swift, methods on aggregates can expressly indicate whether they will modify the variable upon which they are invoked, and the compiler will forbid the use of mutating methods upon read-only variables (rather than having them mutate temporary copies of the variable which will then get discarded).  Because of this distinction, using the . token to call methods that modify the variables upon which they are invoked is much safer in Swift than in .NET.  Unfortunately, the fact that the same . token is used for that purpose as to act upon an external object identified by a variable means the possibility for confusion remains.If had a time machine and went back to the creation of C# and/or Swift, one could retroactively avoid much of the confusion surrounding such issues by having languages use the . and -> tokens in a fashion much closer to the C++ usage.  Methods of both aggregates and reference types could use . to act upon the variable upon which they were invoked, and -> to act upon a value (for composites) or the thing identified thereby (for reference types).  Neither language is designed that way, however.In C#, the normal practice for a method to modify a variable upon which it is invoked is to pass the variable as a ref parameter to a method.  Thus calling Array.Resize(ref someArray, 23); when someArray identifies an array of 20 elements will cause someArray to identify a new array of 23 elements, without affecting the original array.  The use of ref makes clear that the method should be expected to modify the variable upon which it is invoked.  In many cases, it\'s advantageous to be able to modify variables without having to use static methods; Swift addresses that means by using . syntax.  The disadvantage is that it loses clarify as to what methods act upon variables and what methods act upon values.To me this makes more sense if you first replace your constants with variables:The first line never needs to change the size of a. In particular, it never needs to do any memory allocation. Regardless of the value of i, this is a lightweight operation. If you imagine that under the hood a is a pointer, it can be a constant pointer.The second line may be much more complicated. Depending on the values of i and j, you may need to do memory management. If you imagine that e is a pointer that points to the contents of the array, you can no longer assume that it is a constant pointer; you may need to allocate a new block of memory, copy data from the old memory block to the new memory block, and change the pointer.It seems that the language designers have tried to keep (1) as lightweight as possible. As (2) may involve copying anyway, they have resorted to the solution that it always acts as if you did a copy.This is complicated, but I am happy that they did not make it even more complicated with e.g. special cases such as "if in (2) i and j are compile-time constants and the compiler can infer that the size of e is not going to change, then we do not copy".Finally, based on my understanding of the design principles of the Swift language, I think the general rules are these:What I\'ve found is: The array will be a mutable copy of the referenced one if and only if the operation has the potential to change the array\'s length. In your last example, f[0..2] indexing with many, the operation has the potential to change its length (it might be that duplicates are not allowed), so it\'s getting copied.Delphi\'s strings and arrays had the exact same "feature".  When you looked at the implementation, it made sense.Each variable is a pointer to dynamic memory.  That memory contains a reference count followed by the data in the array.  So you can easily change a value in the array without copying the whole array or changing any pointers.  If you want to resize the array, you have to allocate more memory.  In that case the current variable will point to the newly allocated memory.  But you can\'t easily track down all of the other variables that pointed to the original array, so you leave them alone.Of course, it wouldn\'t be hard to make a more consistent implementation.  If you wanted all variables to see a resize, do this:\nEach variable is a pointer to a container stored in dynamic memory.  The container holds exactly two things, a reference count and pointer to the actual array data.  The array data is stored in a separate block of dynamic memory.  Now there is only one pointer to the array data, so you can easily resize that, and all variables will see the change.A lot of Swift early adopters have complained about this error-prone array semantics and Chris Lattner has written that the array semantics had been revised to provide full value semantics ( Apple Developer link for those who have an account). We will have to wait at least for the next beta to see what this exactly means.I use .copy() for this. 