In my bash script I have an external (received from user) string, which I should use in sed pattern.How can I escape the $REPLACE string so it would be safely accepted by sed as a literal replacement?NOTE: The KEYWORD is a dumb substring with no matches etc. It is not supplied by user.Warning: This does not consider newlines. For a more in-depth answer, see this SO-question instead. (Thanks, Ed Morton & Niklas Peter)Note that escaping everything is a bad idea. Sed needs many characters to be escaped to get their special meaning. For example, if you escape a digit in the replacement string, it will turn in to a backreference.As Ben Blank said, there are only three characters that need to be escaped in the replacement string (escapes themselves, forward slash for end of statement and & for replace all):If you ever need to escape the KEYWORD string, the following is the one you need:Addendum: Remember, if you use a character other than / as delimiter, you need replace the slash in the expressions above wih the character you are using. See PeterJCLaw\'s comment for explanation.Fix 1 for KEYWORD variant: Added the two characters Peter.O mentioned, and \'(\' and \')\'.Fix 2 for KEYWORD variant: Removed \'(\' and \')\' again. Don\'t know what I was thinking when I added them. Thanks, Jesse.The sed command allows you to use other characters instead of / as separator:The double quotes are not a problem.The only three literal characters which are treated specially in the replace clause are / (to close the clause), \\ (to escape characters, backreference, &c.), and & (to include the match in the replacement).  Therefore, all you need to do is escape those three characters:Example:Based on Pianosaurus\'s regular expressions, I made a bash function that escapes both keyword and replacement.Here\'s how you use it:It\'s a bit late to respond... but there IS a much simpler way to do this.  Just change the delimiter (i.e., the character that separates fields).  So, instead of s/foo/bar/ you write s|bar|foo.And, here\'s the easy way to do this:The resulting output is devoid of that nasty DEFINER clause.It turns out you\'re asking the wrong question. I also asked the wrong question. The reason it\'s wrong is the beginning of the first sentence: "In my bash script...".I had the same question & made the same mistake. If you\'re using bash, you don\'t need to use sed to do string replacements (and it\'s much cleaner to use the replace feature built into bash).Instead of something like, for example:you can use bash features exclusively:Use awk - it is cleaner:Here is an example of an AWK I used a while ago.  It is an AWK that prints new AWKS.  AWK and SED being similar it may be a good template.It looks excessive, but somehow that combination of quotes works to keep the \' printed as literals.  Then if I remember correctly the vaiables are just surrounded with quotes like this: "$1".  Try it, let me know how it works with SED.If the case happens to be that you are generating a random password to pass to sed replace pattern, then you choose to be careful about which set of characters in the random string. If you choose a password made by encoding a value as base64, then there is is only character that is both possible in base64 and is also a special character in sed replace pattern. That character is "/", and is easily removed from the password you are generating:Just escape everything in the REPLACE varible:don\'t forget all the pleasure that occur with the shell limitation around " and \'so (in ksh)If you are just looking to replace Variable value in sed command then just remove \nExample: