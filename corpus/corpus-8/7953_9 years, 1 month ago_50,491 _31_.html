In other words, is this Singleton implementation thread safe:Static constructors are guaranteed to be run only once per application domain, before any instances of a class are created or any static members are accessed. http://msdn.microsoft.com/en-us/library/aa645612.aspxThe implementation shown is thread safe for the initial construction, that is, no locking or null testing is required for constructing the Singleton object. However, this does not mean that any use of the instance will be synchronised. There are a variety of ways that this can be done; I\'ve shown one below.While all of these answers are giving the same general answer, there is one caveat.  Remember that all potential derivations of a generic class are compiled as individual types.  So use caution when implementing static constructors for generic types.EDIT:Here is the demonstration:In the console:Using a static constructor actually is threadsafe.  The static constructor is guaranteed to be executed only once.From the C# language specification http://msdn.microsoft.com/en-us/library/aa645612(VS.71).aspx:The static constructor for a class executes at most once in a given application domain. The execution of a static constructor is triggered by the first of the following events to occur within an application domain:So yes, you can trust that your singleton will be correctly instantiated.Zooba made an excellent point (and 15 seconds before me, too!) that the static constructor will not guarantee thread-safe shared access to the singleton.  That will need to be handled in another manner.Here\'s the Cliffnotes version from the above MSDN page on c# singleton:Use the following pattern, always, you can\'t go wrong:Beyond the obvious singleton features, it gives you these two things for free (in respect to singleton in c++): Static constructors are guaranteed to fire only once per App Domain so your approach should be OK. However, it is functionally no different from the more concise, inline version:Thread safety is more of an issue when you are lazily initializing things.The Common Language Infrastructure specification guarantees that "a type initializer shall run exactly once for any given type, unless explicitly called by user code." (Section 9.5.3.1.) So unless you have some whacky IL on the loose calling Singleton::.cctor directly (unlikely) your static constructor will run exactly once before the Singleton type is used, only one instance of Singleton will be created, and your Instance property is thread-safe.Note that if Singleton\'s constructor accesses the Instance property (even indirectly) then the Instance property will be null. The best you can do is detect when this happens and throw an exception, by checking that instance is non-null in the property accessor. After your static constructor completes the Instance property will be non-null.As Zoomba\'s answer points out you will need to make Singleton safe to access from multiple threads, or implement a locking mechanism around using the singleton instance.Just to be pedantic, but there is no such thing as a static constructor, but rather static type initializers, here\'s a small demo of cyclic static constructor dependency which illustrates this point.Static constructor is guaranteed to be thread safe.\nAlso, check out the discussion on Singleton at DeveloperZen:\nhttp://www.developerzen.com/2007/07/15/whats-wrong-with-this-code-1-discussion/The static constructor will finish running before any thread is allowed to access the class.The code above produced the results below.Even though the static constructor took a long time to run, the other threads stopped and waited.  All threads read the value of _x set at the bottom of the static constructor.Although other answers are mostly correct, there is yet another caveat with static constructors.As per section II.10.5.3.3 Races and deadlocks of the ECMA-335 Common Language \nInfrastructure\nType initialization alone shall not create a deadlock unless some code\n  called from a  type initializer (directly or indirectly) explicitly\n  invokes blocking operations.The following code results in a deadlockOriginal author is Igor Ostrovsky, see his post here.