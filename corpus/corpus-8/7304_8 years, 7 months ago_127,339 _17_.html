Does c# have its own version of the java "synchronized" keyword? I.e. in java it can be specified either to a function, an object or a block of code, like so:orFirst - most classes will never need to be thread-safe. Use YAGNI: only apply thread-safety when you know you actually are going to use it (and test it).For the method-level stuff, there is [MethodImpl]:This can also be used on accessors (properties and events):Note that field-like events are synchronized by default, while auto-implemented properties are not:Personally, I don\'t like the implementation of MethodImpl as it locks this or typeof(Foo) - which is against best practice. The preferred option is to use your own locks:Note that for field-like events, the locking implementation is dependent on the compiler; in older Microsoft compilers it is a lock(this) / lock(Type) - however, in more recent compilers it uses Interlocked updates - so thread-safe without the nasty parts.This allows more granular usage, and allows use of Monitor.Wait/Monitor.Pulse etc to communicate between threads.A related blog entry (later revisited).Does c# have its own version of the java "synchronized" keyword? No. In C#, you explicitly lock resources that you want to work on synchronously across asynchronous threads. lock opens a block; it doesn\'t work on method level.However, the underlying mechanism is similar since lock works by invoking Monitor.Enter (and subsequently Monitor.Exit) on the runtime. Java works the same way, according to the Sun documentation.You can use the lock statement instead.  I think this can only replace the second version.  Also, remember that both synchronized and lock need to operate on an object.Take note, with full paths the line: [MethodImpl(MethodImplOptions.Synchronized)] should look like[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.Synchronized)]