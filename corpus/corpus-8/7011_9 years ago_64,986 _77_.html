I have read this post about how to test private methods. I usually do not test them, because I always thought it\'s faster to test only public methods that will be called from outside the object. Do you test private methods? Should I always test them?I do not unit test private methods. A private method is an implementation detail that should be hidden to the users of the class. Testing private methods breaks encapsulation.If I find that the private method is huge or complex or important enough to require its own tests, I just put it in another class and make it public there (Method Object). Then I can easily test the previously-private-but-now-public method that now lives on its own class.What is the purpose of testing?The majority of the answers so far are saying that private methods are implementation details which don\'t (or at least shouldn\'t) matter so long as the public interface is well-tested and working.  That\'s absolutely correct if your only purpose for testing is to guarantee that the public interface works.Personally, my primary use for code tests is to ensure that future code changes don\'t cause problems and to aid my debugging efforts if they do.  I find that testing the private methods just as thoroughly as the public interface (if not more so!) furthers that purpose.Consider:  You have public method A which calls private method B.  A and B both make use of method C.  C is changed (perhaps by you, perhaps by a vendor), causing A to start failing its tests.  Wouldn\'t it be useful to have tests for B also, even though it\'s private, so that you know whether the problem is in A\'s use of C, B\'s use of C, or both?Testing private methods also adds value in cases where test coverage of the public interface is incomplete.  While this is a situation we generally want to avoid, the efficiency unit testing depends both on the tests finding bugs and the associated development and maintenance costs of those tests. In some cases, the benefits of 100% test coverage may be judged insufficient to warrant the costs of those tests, producing gaps in the public interface\'s test coverage. In such cases, a well-targeted test of a private method can be a very effective addition to the code base.I tend to follow the advice of Dave Thomas and Andy Hunt in their book Pragmatic Unit Testing:In general, you don\'t want to break any encapsulation for the sake of\n  testing (or as Mom used to say, "don\'t expose your privates!"). Most\n  of the time, you should be able to test a class by exercising its\n  public methods. If there is significant functionality that is hidden\n  behind private or protected access, that might be a warning sign that\n  there\'s another class in there struggling to get out.But sometimes I can\'t stop myself from testing private methods because it gives me that sense of reassurance that I\'m building a completely robust program.I kind of feel compelled to test private functions as I am following more and more one of our latest QA recommendation in our project:No more than 10 in cyclomatic complexity per function.Now the side effect of the enforcing of this policy is that many of my very large public functions get divided in many more focused, better named private function.\nThe public function still there (of course) but is essentially reduced to called all those private \'sub-functions\'That is actually cool, because the callstack is now much easier to read (instead of a bug within a large function, I have a bug in a sub-sub-function with the name of the previous functions in the callstack to help me to understand \'how I got there\')However, it now seem easier to unit-test directly those private functions, and leave the testing of the large public function to some kind of \'integration\' test where a scenario needs to be addressed.Just my 2 cents.Yes I do test private functions, because although they are tested by your public methods, it is nice in TDD (Test Driven Design) to test the smallest part of the application. But private functions are not accessible when you are in your test unit class. Here\'s what we do to test our private methods.Why do we have private methods?Private functions mainly exists in our class because we want to create readable code in our public methods.\nWe do not want the user of this class to call these methods directly, but through our public methods. Also, we do not want change their behavior when extending the class (in case of protected), hence it\'s a private.When we code, we use test-driven-design (TDD). This means that sometimes we stumble on a piece of functionality that is private and want to test. Private functions are not testable in phpUnit, because we cannot access them in the Test class (they are private).We think here are 3 solutions:1. You can test your privates through your public methodsAdvantagesDisadvantages2. If the private is so important, then maybe it is a codesmell to create a new separate class for itAdvantagesDisadvantages3. Change the access modifier to (final) protectedAdvantagesDisadvantagesExampleSo our test unit can now call test_sleepWithSuspect to test our former private function.I think it\'s best to just test the public interface of an object.  From the point of view of the outside world, only the behavior of the public interface matters and this is what your unit tests should be directed towards.Once you have some solid unit tests written for an object you do not want to have to go back and change those tests just because the implementation behind the interface changed.  In this situation, you\'ve ruined the consistency of your unit testing.If the private method is well defined (ie, it has a function that is testable and is not meant to change over time) then yes.  I test everything that\'s testable where it makes sense.For instance, an encryption library might hide the fact that it performs block encryption with a private method that encrypts only 8 bytes at a time.  I would write a unit test for that - it\'s not meant to change, even though it\'s hidden, and if it does break (due to future performance enhancements, for instance) then I want to know that it\'s the private function that broke, not just that one of the public functions broke.It speeds debugging later.-AdamIf your private method is not tested by calling your public methods then what is it doing?\nI\'m talking private not protected or friend.If you are developing test driven (TDD), you will test your private methods.We test private methods by inference, by which I mean we look for total class test coverage of at least 95%, but only have our tests call into public or internal methods.  To get the coverage, we need to make multiple calls to the public/internals based on the different scenarios that may occur.  This makes our tests more intentful around the purpose of the code they are testing.Trumpi\'s answer to the post you linked is the best one.I am not an expert in this field, but unit testing should test behaviour, not implementation. Private methods are strictly part of the implementation, so IMHO should not be tested.Unit tests I believe are for testing public methods. Your public methods use your private methods, so indirectly they are also getting tested.I\'ve been stewing over this issue for a while especially with trying my hand at TDD.I\'ve come across two posts that I think address this problem thoroughly enough in the case of TDD.In Summary:When using test driven development (design) techniques, private methods should arise only during the re-factoring process of already working and tested code.By the very nature of the process, any bit of simple implementation functionality extracted out of a thoroughly tested function will be it self tested (i.e. indirect testing coverage).To me it seems clear enough that in the beginning part of coding most methods will be higher level functions because they are encapsulating/describing the design.Therefore, these methods will be public and testing them will be easy enough.The private methods will come later once everything is working well and we are re factoring for the sake of readability and cleanliness.As quoted above, "If you don\'t test your private methods, how do you know they won\'t break?"This is a major issue.  One of the big points of unit tests is to know where, when, and how something broke ASAP.  Thus decreasing a significant amount of development & QA effort.  If all that is tested is the public, then you don\'t have honest coverage and delineation of the internals of the class.I\'ve found one of the best ways to do this is simply add the test reference to the project and put the tests in a class parallel to the private methods.  Put in the appropriate build logic so that the tests don\'t build into the final project.Then you have all the benefits of having these methods tested and you can find problems in seconds versus minutes or hours.So in summary, yes, unit test your private methods.If you don\'t test your private methods, how do you know they won\'t break?You should not. If your private methods have enough complexity that must be tested, you should put them on another class. Keep high cohesion, a class should have only one purpose. The class public interface should be enough.It\'s obviously language dependent. In the past with c++, I\'ve declared the testing class to be a friend class.  Unfortunately, this does require your production code to know about the testing class.I understand the point of view where private methods are considered as implementations details and then don\'t have to be tested. And I would stick with this rule if we had to develop outside of the object only. But us, are we some kind of restricted developers who are developing only outside of objects, calling only their public methods? Or are we actually also developing that object? As we are not bound to program outside objects, we will probably have to call those private methods into new public ones we are developing. Wouldn\'t it be great to know that the private method resist against all odds?I know some people could answer that if we are developing another public method into that object then this one should be tested and that\'s it (the private method could carry on living without test). But this is also true for any public methods of an object: when developing a web app, all the public methods of an object are called from controllers methods and hence could be considered as implementation details for controllers.So why are we unit testing objects? Because it is really difficult, not to say impossible to be sure that we are testing the controllers\' methods with the appropriate input which will trigger all the branches of the underlying code. In other words, the higher we are in the stack, the more difficult it is to test all the behaviour. And so is the same for private methods.To me the frontier between private and public methods is a psychologic criteria when it comes to tests. Criteria which matters more to me are: If I find that the private method is huge or complex or important enough to require its own tests, I just put it in another class and make it public there (Method Object). Then I can easily test the previously private but now public method that now lives on its own class.Absolutely YES. That is the point of Unit testing, you test Units. Private method is a Unit. Without testing private methods TDD (Test Driven Development) would be impossible,If we test to ensure the correctness of the logic, and a private method is carrying a logic, we should test it. Isn\'t it? So why are we going to skip that?Writing tests based on the visibility of methods is completely irrelevant idea. If the method is significant enough/complex enough , I\'ll usually make it "protected" and test it. Some methods will be left private and tested implicitly as part of unit tests for the public/protected methods.I see many people are in the same line of thinking: test at the public level. but isn\'t that what our QA team does? They test input and expected output.  If as developers we only test the public methods then we are simply redoing QA\'s job and not adding any value by "unit testing". The answer to "Should I test private methods?" is ".......sometimes".  Typically you should be testing against the interface of your classes. Here is an example:In RefactoredThing you now have 5 tests, 2 of which you had to update for refactoring, but your object\'s functionality really hasn\'t changed.  So let\'s say that things are more complex than that and you have some method that defines the order of the output such as: This shouldn\'t be run by an outside user, but your encapsulating class may be to heavy to run that much logic through it over and over again. In this case maybe you would rather extract this into a seperate class, give that class an interface and test against it.And finally, let\'s say that your main object is super heavy, and the method is quite small and you really need to ensure that the output is correct.  You are thinking, "I have to test this private method!". Have you that maybe you can make your object lighter by passing in some of the heavy work as an initialization parameter?  Then you can pass something lighter in and test against that.No You shouldn\'t test the Private Methods why? and moreover the popular mocking framework such as Mockito doesn\'t provide support for testing private methods.