How do you manage configuration variables/constants for different environments?This could be an example:  My rest API is reachable on localhost:7080/myapi/, but my friend that works on the same code under Git version control has the API deployed on his Tomcat on localhost:8099/hisapi/.Supposing that we have something like this : How do I dynamically inject the correct value of the API endpoint, depending on the environment?In PHP I usually do this kind of stuff with a config.username.xml file, merging the basic configuration file (config.xml) with the local environment configuration file recognised by the name of the user. But I don\'t know how to manage this kind of thing in JavaScript?I\'m a little late to the thread, but if you\'re using Grunt I\'ve had great success with grunt-ng-constant.The config section for ngconstant in my Gruntfile.js looks likeThe tasks that use ngconstant look likeSo running grunt server will generate a config.js file in app/scripts/ that looks likeFinally, I declare the dependency on whatever modules need it:Now my constants can be dependency injected where needed. E.g.,One cool solution might be separating all environment-specific values into some separate angular module, that all other modules depend on:Then your modules that need those entries can declare a dependency on it:Now you could think about further cool stuff:The module, that contains the configuration can be separated into configuration.js, that will be included at your page.This script can be easily edited by each of you, as long as you don\xe2\x80\x99t check this separate file into git. But it\'s easier to not check in the configuration if it is in a separate file. Also, you could branch it locally.Now, if you have a build-system, like ANT or Maven, your further steps could be implementing some placeholders for the values API_END_POINT, that will be replaced during build-time, with your specific values.Or you have your configuration_a.js and configuration_b.js and decide at the backend which to include.For Gulp users, gulp-ng-constant is also useful combined with gulp-concat, event-stream and yargs.In my config folder I have these files:Then you can run gulp config --env development and that will create something like this:I also have this spec:To achieve that, I suggest you to use AngularJS Environment Plugin: https://www.npmjs.com/package/angular-environmentHere\'s an example:And then, you can call the variables from your controllers such as this:Hope it helps.You could use lvh.me:9000 to access your AngularJS app, (lvh.me just points to 127.0.0.1) and then specify a different endpoint if lvh.me is the host:And then inject the Configuration service and use Configuration.API wherever you need to access the API:A tad clunky, but works fine for me, albeit in a slightly different situation (API endpoints differ in production and development).Good question!One solution could be to continue using your config.xml file, and provide api endpoint information from the backend to your generated html, like this (example in php):Maybe not a pretty solution, but it would work.Another solution could be to keep the API_END_POINT constant value as it should be in production, and only modify your hosts-file to point that url to your local api instead.Or maybe a solution using localStorage for overrides, like this:We could also do something like this. And in your controller/service, we can inject the dependency and call the get method with property to be accessed. $http.get(env.get(\'apiroot\') would return the url based on the host environment.Very late to the thread, but a technique I\'ve used, pre-Angular, is to take advantage of JSON and the flexibility of JS to dynamically reference collection keys, and use inalienable facts of the environment (host server name, current browser language, etc.) as inputs to selectively discriminate/prefer suffixed key names within a JSON data structure.This provides not merely deploy-environment context (per OP) but any arbitrary context (such as language) to provide i18n or any other variance required simultaneously, and (ideally) within a single configuration manifest, without duplication, and readably obvious.IN ABOUT 10 LINES VANILLA JSOverly-simplified but classic example: An API endpoint base URL in a JSON-formatted properties file that varies per environment where (natch) the host server will also vary:A key to the discrimination function is simply the server hostname in the request.This, naturally, can be combined with an additional key based on the user\'s language settings:The scope of the discrimination/preference can be confined to individual keys (as above) where the "base" key is only overwritten if there\'s a matching key+suffix for the inputs to the function -- or an entire structure, and that structure itself recursively parsed for matching discrimination/preference suffixes:SO, if a visiting user to the production website has German (de) language preference setting, the above configuration would collapse to:What does such a magical preference/discrimination JSON-rewriting function look like? Not much:In our implementations, which include Angular and pre-Angular websites, we simply bootstrap the configuration well ahead of other resource calls by placing the JSON within a self-executing JS closure, including the prefer() function, and fed basic properties of hostname and language-code (and accepts any additional arbitrary suffixes you might need):A pre-Angular site would now have a collapsed (no @ suffixed keys) window.app_props to refer to.An Angular site, as a bootstrap/init step, simply copies the dead-dropped props object into $rootScope, and (optionally) destroys it from global/window scopeto be subsequently injected into controllers:or referred to from bindings in views:Caveats? The @ character is not valid JS/JSON variable/key naming, but so far accepted. If that\'s a deal-breaker, substitute for any convention you like, such as "__" (double underscore) as long as you stick to it.The technique could be applied server-side, ported to Java or C# but your efficiency/compactness may vary.Alternately, the function/convention could be part of your front-end compile script, so that the full gory all-environment/all-language JSON is never transmitted over the wire.UPDATEWe\'ve evolved usage of this technique to allow multiple suffixes to a key, to avoid being forced to use collections (you still can, as deeply as you want), and as well to honor the order of the preferred suffixes.Example (also see working jsFiddle):1/2 (basic usage) prefers \'@dev\' keys, discards all other suffixed keys3 prefers \'@dev\' over \'@fr\', prefers \'@dev&fr\' over all others4 (same as 3 but prefers \'@fr\' over \'@dev\')5 no preferred suffixes, drops ALL suffixed propertiesIt accomplishes this by scoring each suffixed property and promoting the value of a suffixed property to the non-suffixed property when iterating over the properties and finding a higher-scored suffix.Some efficiencies in this version, including removing dependence on JSON to deep-copy, and only recursing into objects that survive the scoring round at their depth:If you\'re using Brunch, the plugin Constangular helps you to manage variables for different environments.Have you seen this question and its answer?You can set a globally valid value for you app like this:and then use it in your services. You could move this code to a config.js file and execute it on page load or another convenient moment.