I found this article about Lazy: Laziness in C# 4.0 \xe2\x80\x93 LazyWhat is the best practice to have best performance using Lazy objects?\nCan someone point me to a practical use in a real application? In other words, when should I use it?You typically use it when you want to instantiate something the first time its actually used.  This delays the cost of creating it till if/when it\'s needed instead of always incurring the cost.Usually this is preferable when the object may or may not be used and the cost of constructing it is non-trivial.You should try to avoid using Singletons, but if you ever do need to, Lazy<T> makes implementing lazy, thread-safe singletons easy:A great real-world example of where lazy loading comes in handy is with ORM\'s (Object Relation Mappers) such as Entity Framework and NHibernate.Say you have an entity Customer which has properties for Name, PhoneNumber, and Orders. Name and PhoneNumber are regular strings but Orders is a navigation property that returns a list of every order the customer ever made.You often might want to go through all your customer\'s and get their name and phone number to call them. This is a very quick and simple task, but imagine if each time you created a customer it automatically went and did a complex join to return thousands of orders. The worst part is that you aren\'t even going to use the orders so it is a complete waste of resources!This is the perfect place for lazy loading because if the Order property is lazy it will not go fetch all the customer\'s order unless you actually need them. You can enumerate the Customer objects getting only their Name and Phone Number while the Order property is patiently sleeping, ready for when you need it.I have been considering using Lazy<T> properties to help improve the performance of my own code (and to learn a bit more about it).  I came here looking for answers about when to use it but it seems that everywhere I go there are phrases like:Use lazy initialization to defer the creation of a large or\n  resource-intensive object, or the execution of a resource-intensive\n  task, particularly when such creation or execution might not occur\n  during the lifetime of the program.from MSDN Lazy<T> ClassI am left a bit confused because I am not sure where to draw the line.  For example, I consider linear interpolation as a fairly quick computation but if I don\'t need to do it then can lazy initialisation help me to avoid doing it and is it worth it?In the end I decided to try my own test and I thought I would share the results here.  Unfortunately I am not really an expert at doing these sort of tests and so I am happy to get comments that suggest improvements.DescriptionFor my case, I was particularly interested to see if Lazy Properties could help improve a part of my code that does a lot of interpolation (most of it being unused) and so I have created a test that compared 3 approaches.I created a separate test class with 20 test properties (lets call them t-properties) for each approach.The test results are measured in ms and are the average of 50 instantiations or 20 property gets.  Each test was then run 5 times.Test 1 Results: Instantiation (average of 50 instantiations)Test 2 Results: First Get (average of 20 property gets)Test 3 Results: Second Get (average of 20 property gets)ObservationsGetInterp is fastest to instantiate as expected because its not doing anything. InitLazy is faster to instantiate than InitInterp suggesting that the overhead in setting up lazy properties is faster than my linear interpolation calculation.  However, I am a bit confused here because InitInterp should be doing 20 linear interpolations (to set up it\'s t-properties) but it is only taking 0.09 ms to instantiate (test 1), compared to GetInterp which takes 0.28 ms to do just one linear interpolation the first time (test 2), and 0.1 ms to do it the second time (test 3).It takes InitLazy almost 2 times longer than GetInterp to get a property the first time, while InitInterp is the fastest, because it populated its properties during instantiation.  (At least that is what it should have done but why was it\'s instantiation result so much quicker than a single linear interpolation?  When exactly is it doing these interpolations?)Unfortunately it looks like there is some automatic code optimisation going on in my tests.  It should take GetInterp the same time to get a property the first time as it does the second time, but it is showing as more than 2x faster.  It looks like this optimisation is also affecting the other classes as well since they are all taking about the same amount of time for test 3.  However, such optimisations may also take place in my own production code which may also be an important consideration.ConclusionsWhile some results are as expected, there are also some very interesting unexpected results probably due to code optimisations. Even for classes that look like they are doing a lot of work in the constructor, the instantiation results show that they may still be very quick to create, compared to getting a double property.  While experts in this field may be able to comment and investigate more thoroughly, my personal feeling is that I need to do this test again but on my production code in order to examine what sort of optimisations may be taking place there too.  However, I am expecting that InitInterp may be the way to go.From MSDN:Use an instance of Lazy to defer the creation of a large or resource-intensive object or the execution of a resource-intensive task, particularly when such creation or execution might not occur during the lifetime of the program.In addition to James Michael Hare\'s answer, Lazy provides thread-safe initialization of your value. Take a look at LazyThreadSafetyMode enumeration MSDN entry describing various types of thread safety modes for this class. Just to point onto the example posted by Mathewbefore the Lazy was born we would have done it this way: