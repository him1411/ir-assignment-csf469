In C# when debugging threads for example, you can see each thread\'s ID.I couldn\'t find a way to get that same thread, programmatically. I could not even get the ID of the current thread (in the properties of the Thread.currentThread).So, I wonder how does Visual Studio get the IDs of the threads, and is there a way to get the handle of the thread with id 2345, for example?GetThreadId returns the ID of a given native thread. There are ways to make it work with managed threads, I\'m sure, all you need to find is the thread handle and pass it to that function.GetCurrentThreadId returns the ID of the current thread. GetCurrentThreadId has been deprecated as of .NET 2.0: the recommended way is the Thread.CurrentThread.ManagedThreadId property.In C# when debugging threads for example, you can see each thread\'s\n  ID.This will be the Ids of the managed threads.  ManagedThreadId is a member of Thread so you can get the Id from from any Thread object.  This will get you the current ManagedThreadID:To get an OS thread by it\'s OS thread ID (not ManagedThreadID), you can try a bit of linq.It seems there is no way to enumerate the managed threads and no relation between ProcessThread and Thread, so getting a managed thread by it\'s Id is a tough one.For more details on Managed vs Unmanaged threading see this MSDN arcticle.You can use the deprecated AppDomain.GetCurrentThreadId to get the ID of the currently running thread. This method uses a PInvoke to the Win32 API method GetCurrentThreadID, and will return the Windows thread ID.This method is marked as deprecated because the .NET Thread object does not correspond to a single Windows thread, and as such there is no stable ID which can be returned by Windows for a given .NET thread. See configurator\'s answer for more reasons why this is the case.To get the OS ID use:According to MSDN:An operating-system ThreadId has no\n  fixed relationship to a managed\n  thread, because an unmanaged host can\n  control the relationship between\n  managed and unmanaged threads.\n  Specifically, a sophisticated host can\n  use the CLR Hosting API to schedule\n  many managed threads against the same\n  operating system thread, or to move a\n  managed thread between different\n  operating system threads.So basically, the Thread object does not necessarily correspond to an OS thread - which is why it doesn\'t have the native ID exposed.For those about to hack:To find the current thread Id use - `Thread.CurrentThread.ManagedThreadId\'.\nBut in this case you might need the current win32 thread id - use pInvoke to get it with this function:First you\'ll need to save the managed thread id and win32 thread id connection - use a dictionary that maps a win32 id to managed thread.  Then to find a thread by it\'s id iterate over the process\'s thread using Process.GetCurrentProcess().Threads and find the thread with that id:From managed code you have access to instances of the Thread type for each managed thread. Thread encapsulates the concept of an OS thread and as of the current CLR there\'s a one-to-one correspondance with managed threads and OS threads. However, this is an implementation detail, that may change in the future. The ID displayed by Visual Studio is actually the OS thread ID. This is not the same as the managed thread ID as suggested by several replies. The Thread type does include a private IntPtr member field called DONT_USE_InternalThread, which points to the underlying OS structure. However, as this is really an implementation detail it is not advisable to pursue this IMO. And the name sort of indicates that you shouldn\'t rely on this. System.Threading.Thread.CurrentThread.NameYou can use Thread.GetHashCode, which returns the managed thread ID. If you think about the purpose of GetHashCode, this makes good sense -- it needs to be a unique identifier (e.g. key in a dictionary) for the object (the thread).The reference source for the Thread class is instructive here. (Granted, a particular .NET implementation may not be based on this source code, but for debugging purposes I\'ll take my chances.)GetHashCode "provides this hash code for algorithms that need quick checks of object equality," so it is well-suited for checking Thread equality -- for example to assert that a particular method is executing on the thread you wanted it called from. 