How do you do "inline functions" in C#? I don\'t think I understand the concept. Are they like anonymous methods? Like lambda functions?Note: The answers almost entirely deal with the ability to inline functions, i.e. "a manual or compiler optimization that replaces a function call site with the body of the callee." If you are interested in anonymous (a.k.a. lambda) functions, see @jalf\'s answer or What is this 'Lambda' everyone keeps speaking of?.Finally in .NET 4.5, the CLR allows one to hint/suggest1 method inlining using MethodImplOptions.AggressiveInlining value. It is also available in the Mono\'s trunk (committed today).1. Previously "force" was used here. Since there were a few downvotes, I\'ll try to clarify the term. As in the comments and the documentation, The method should be inlined if possible. Especially considering Mono (which is open), there are some mono-specific technical limitations considering inlining or more general one (like virtual functions). Overall, yes, this is a hint to compiler, but I guess that is what was asked for.Inline methods are simply a compiler optimization where the code of a function is rolled into the caller.There\'s no mechanism by which to do this in C#, and they\'re to be used sparingly in languages where they are supported -- if you don\'t know why they should be used somewhere, they shouldn\'t be.Edit: To clarify, there are two major reasons they need to be used sparingly:It\'s best to leave things alone and let the compiler do its work, then profile and figure out if inline is the best solution for you.  Of course, some things just make sense to be inlined (mathematical operators particularly), but letting the compiler handle it is typically the best practice.Update: Per konrad.kruczynski\'s answer, the following is true for versions of .NET up to and including 4.0.You can use the MethodImplAttribute class to prevent a method from being inlined......but there is no way to do the opposite and force it to be inlined.You\'re mixing up two separate concepts. Function inlining is a compiler optimization which has no impact on the semantics. A function behaves the same whether it\'s inlined or not.On the other hand, lambda functions are purely a semantic concept. There is no requirement on how they should be implemented or executed, as long as they follow the behavior set out in the language spec. They can be inlined if the JIT compiler feels like it, or not if it doesn\'t.There is no inline keyword in C#, because it\'s an optimization that can usually be left to the compiler, especially in JIT\'ed languages. The JIT compiler has access to runtime statistics which enables it to decide what to inline much more efficiently than you can when writing the code. A function will be inlined if the compiler decides to, and there\'s nothing you can do about it either way. :)Do you mean inline functions in the C++ sense?  In which the contents of a normal function are automatically copied inline into the callsite?  The end effect being that no function call actually happens when calling a function.Example:If so then no, there is no C# equivalent to this.  Or Do you mean functions that are declared within another function?  If so then yes, C# supports this via anonymous methods or lambda expressions.  Example:Cody has it right, but I want to provide an example of what an inline function is.Let\'s say you have this code:The compilerJust-In-Time optimizer could choose to alter the code to avoid repeatedly placing a call to OutputItem() on the stack, so that it would be as if you had written the code like this instead:In this case, we would say the OutputItem() function was inlined.  Note that it might do this even if the OutputItem() is called from other places as well.Edited to show a scenario more-likely to be inlined.Yes Exactly, the only distinction is the fact it returns a value.Simplification (not using expressions):List<T>.ForEach Takes an action, it doesn\'t expect a return result.So an Action<T> delegate would suffice.. say:is the same as saying:the difference is that the param type and delegate decleration are inferred by usage and the braces aren\'t required on a simple inline method.Where asList<T>.Where Takes a function, expecting a result.So an Function<T, bool> would be expected:which is the same as:You can also declare these methods inline and asign them to variables IE:orI hope this helps.There are occasions where I do wish to force code to be in-lined.For example if I have a complex routine where there are a large number of decisions made within a highly iterative block and those decisions result in similar but slightly differing actions to be carried out. Consider for example, a complex (non DB driven) sort comparer where the sorting algorythm sorts the elements according to a number of different unrelated criteria such as one might do if they were sorting words according to gramatical as well as semantic criteria for a fast language recognition system.  I would tend to write helper functions to handle those actions in order to maintain the readability and modularity of the source code.I know that those helper functions should be in-lined because that is the way that the code would be written if it never had to be understood by a human. I would certainly want to ensure in this case that there were no function calling overhead. The statement "its best to leave these things alone and let the compiler do the work.."   (Cody Brocious)  is complete rubish.  I have been programming high performance game code for 20 years, and I have yet to come across a compiler that is \'smart enough\' to know which code should be inlined (functions) or not.   It would be useful to have a "inline" statement in c#, truth is that the compiler just doesnt have all the information it needs to determine which function should be always inlined or not without the "inline" hint.  Sure if the function is small (accessor) then it might be automatically inlined, but what if it is a few lines of code?   Nonesense, the compiler has no way of knowing, you cant just leave that up to the compiler for optimized code (beyond algorithims). No, there is no such construct in C#, but the .NET JIT compiler could decide to do inline function calls on JIT time. But i actually don\'t know if it is really doing such optimizations.\n(I think it should :-))In case your assemblies will be ngen-ed, you might want to take a look at TargetedPatchingOptOut. This will help ngen decide whether to inline methods. MSDN referenceIt is still only a declarative hint to optimize though, not an imperative command.I know this question is about C#. However, you can write inline functions in .NET with F#. see: Use of `inline` in F# I\'ve got a method that returns true/false if running in debug mode.  I\'ve got a few security checks that get bypassed if in debug mode.I\'d like to inline the call because if I have a dozen places checking for debug mode, it\'d be harder to bypass by forcing someone to override all 12 places, instead of just w/in the one method.Now to be honest, I don\'t know if the compiler is already inlining this or not.  It\'d be nice to force it to do so though.Maybe when we move to 4.5 I guess...C# does not support inline methods (or functions) in the way dynamic languages like python do. However anonymous methods and lambdas can be used for similar purposes including when you need to access a variable in the containing method like in the example below.Lambda expressions are inline functions! I think, that C# doesn`t have a extra attribute like inline or something like that!