How do we decide on the best implementation of hashCode() method for a collection (assuming that equals method has been overridden correctly) ?The best implementation? That is a hard question because it depends on the usage pattern.A for nearly all cases reasonable good implementation was proposed in Josh Bloch\'s  Effective Java in item 8. The best thing is to look it up there because the author explains there why the approach is good.Create a int result and assign a non-zero value.For every field f tested in the equals() method, calculate a hash code c by:Combine the hash value c with result:Return resultThis should result in a proper distribution of hash values for most use situations.If you\'re happy with the Effective Java implementation recommended by dmeister, you can use a library call instead of rolling your own:This requires either guava (com.google.common.base.Objects.hashCode(...)) or JDK7 (java.util.Objects.hash(...)) but works the same way.It is better to use the functionality provided by Eclipse which does a pretty good job and you can put your efforts and energy in developing the business logic.Although this is linked to Android documentation (Wayback Machine) and My own code on Github, it will work for Java in general. My answer is an extension of dmeister\'s Answer with just code that is much easier to read and understand.EDITTypically, when you override hashcode(...), you also want to override equals(...). So for those that will or has already implemented equals, here is a good reference from my Github...First make sure that equals is implemented correctly. From an IBM DeveloperWorks article:Then make sure that their relation with hashCode respects the contact (from the same article):Finally a good hash function should strive to approach the ideal hash function.about8.blogspot.com, you said if equals() returns true for two objects, then hashCode() should return the same value. If equals() returns false, then hashCode() should return different valuesI cannot agree with you. If two objects have the same hashcode it doesn\'t have to mean that they are equal. If A equals B then A.hashcode must be equal to B.hascodebutif A.hashcode equals B.hascode it does not mean that A must equals BThere\'s a good implementation of the Effective Java\'s hashcode() and equals() logic in Apache Commons Lang. Checkout HashCodeBuilder and EqualsBuilder.If I understand your question correctly, you have a custom collection class (i.e. a new class that extends from the Collection interface) and you want to implement the hashCode() method.If your collection class extends AbstractList, then you don\'t have to worry about it, there is already an implementation of equals() and hashCode() that works by iterating through all the objects and adding their hashCodes() together.Now if what you want is the best way to calculate the hash code for a specific class, I normally use the ^ (bitwise exclusive or) operator to process all fields that I use in the equals method:If you use eclipse, you can generate equals() and hashCode() using:Source -> Generate hashCode() and equals(). Using this function you can decide which fields you want to use for equality and hash code calculation, and Eclipse generates the corresponding methods.Just a quick note for completing other more detailed answer (in term of code):If I consider the question how-do-i-create-a-hash-table-in-java and especially the jGuru FAQ entry, I believe some other criteria upon which a hash code could be judged are:@about8 : there is a pretty serious bug there.  same hashcodeyou probably want something like(can you get hashCode directly from int in Java these days? I think it does some autocasting.. if that\'s the case, skip the toString, it\'s ugly.)As you specifically asked for collections, I\'d like to add an aspect that the other answers haven\'t mentioned yet: A HashMap doesn\'t expect their keys to change their hashcode once they are added to the collection. Would defeat the whole purpose...any hashing method that evenly distributes the hash value over the possible range is a good implementation. See effective java ( http://books.google.com.au/books?id=ZZOiqZQIbRMC&dq=effective+java&pg=PP1&ots=UZMZ2siN25&sig=kR0n73DHJOn-D77qGj0wOxAxiZw&hl=en&sa=X&oi=book_result&resnum=1&ct=result ) , there is a good tip in there for hashcode implementation (item 9 i think...). When combining hash values, I usually use the combining method that\'s used in the boost c++ library, namely:This does a fairly good job of ensuring an even distribution.  For some discussion of how this formula works, see the StackOverflow post: Magic number in boost::hash_combineThere\'s a good discussion of different hash functions at: http://burtleburtle.net/bob/hash/doobs.htmlI prefer using utility methods fromm Google Collections lib from class Objects that helps me to keep my code clean. Very often equals and hashcode methods are made from IDE\'s template, so their are not clean to read. Use the reflection methods on Apache Commons EqualsBuilder and HashCodeBuilder.I use a tiny wrapper around Arrays.deepHashCode(...) because it handles arrays supplied as parameters correctlyHere is another JDK 1.7+ approach demonstration with superclass logics accounted. I see it as pretty convinient with Object class hashCode() accounted, pure JDK dependency and no extra manual work. Please note Objects.hash() is null tolerant.I have not include any equals() implementation but in reality you will of course need it.For a simple class it is often easiest to implement hashCode() based on the class fields which are checked by the equals() implementation.The most important thing is to keep hashCode() and equals() consistent: if equals() returns true for two objects, then hashCode() should return the same value. If equals() returns false, then hashCode() should return different values.