I\'ve read on Wikipedia and other sites about OSGi, but I don\'t really see the big picture. It says that it\'s a component based platform, and that you can reload modules at runtime. Also the "practical example" given everywhere is the Eclipse Plugin Framework.My questions are:What is the clear and simple definition of OSGi?What common problems does it solve?By "common problems" I mean problems we face everyday, like "What can OSGi do for making our jobs more efficient/fun/simple?"I\'ve found the following benefits from OSGi:With this, you can structure your application as a set of versioned plugin artifacts that are loaded on demand.  Each plugin is a standalone component.  Just as Maven helps you structure your build so it is repeatable and defined by a set of specific versions of artifacts it is created by, OSGi helps you do this at runtime.  Reduced Complexity - Developing with OSGi technology means developing bundles: the OSGi components. Bundles are modules. They hide their internals from other bundles and communicate through well defined services. Hiding internals means more freedom to change later. This not only reduces the number of bugs, it also makes bundles simpler to develop because correctly sized bundles implement a piece of functionality through well defined interfaces. There is an interesting blog that describes what OSGi technology did for their development process.Reuse - The OSGi component model makes it very easy to use many third party components in an application. An increasing number of open source projects provide their JARs ready made for OSGi. However, commercial libraries are also becoming available as ready made bundles.Real World - The OSGi framework is dynamic. It can update bundles on the fly and services can come and go. Developers used to more traditional Java see this as a very problematic feature and fail to see the advantage. However, it turns out that the real world is highly dynamic and having dynamic services that can come and go makes the services a perfect match for many real world scenarios. For example, a service could model a device in the network. If the device is detected, the service is registered. If the device goes away, the service is unregistered. There are a surprising number of real world scenarios that match this dynamic service model. Applications can therefore reuse the powerful primitives of the service registry (register, get, list with an expressive filter language, and waiting for services to appear and disappear) in their own domain. This not only saves writing code, it also provides global visibility, debugging tools, and more functionality than would have implemented for a dedicated solution. Writing code in such a dynamic environment sounds like a nightmare, but fortunately, there are support classes and frameworks that take most, if not all, of the pain out of it.Easy Deployment - The OSGi technology is not just a standard for components. It also specifies how components are installed and managed. This API has been used by many bundles to provide a management agent. This management agent can be as simple as a command shell, a TR-69 management protocol driver, OMA DM protocol driver, a cloud computing interface for Amazon\'s EC2, or an IBM Tivoli management system. The standardized management API makes it very easy to integrate OSGi technology in existing and future systems.Dynamic Updates - The OSGi component model is a dynamic model. Bundles can be installed, started, stopped, updated, and uninstalled without bringing down the whole system. Many Java developers do not believe this can be done reliably and therefore initially do not use this in production. However, after using this in development for some time, most start to realize that it actually works and significantly reduces deployment times.Adaptive - The OSGi component model is designed from the ground up to allow the mixing and matching of components. This requires that the dependencies of components need to be specified and it requires components to live in an environment where their optional dependencies are not always available. The OSGi service registry is a dynamic registry where bundles can register, get, and listen to services. This dynamic service model allows bundles to find out what capabilities are available on the system and adapt the functionality they can provide. This makes code more flexible and resilient to changes.Transparency - Bundles and services are first class citizens in the OSGi environment. The management API provides access to the internal state of a bundle as well as how it is connected to other bundles. For example, most frameworks provide a command shell that shows this internal state. Parts of the applications can be stopped to debug a certain problem, or diagnostic bundles can be brought in. Instead of staring at millions of lines of logging output and long reboot times, OSGi applications can often be debugged with a live command shell.Versioning - OSGi technology solves JAR hell. JAR hell is the problem that library A works with library B;version=2, but library C can only work with B;version=3. In standard Java, you\'re out of luck. In the OSGi environment, all bundles are carefully versioned and only bundles that can collaborate are wired together in the same class space. This allows both bundle A and C to function with their own library. Though it is not advised to design systems with this versioning issue, it can be a life saver in some cases.Simple - The OSGi API is surprisingly simple. The core API is only one package and less than 30 classes/interfaces. This core API is sufficient to write bundles, install them, start, stop, update, and uninstall them and includes all listener and security classes. There are very few APIs that provide so much functionality for so little API.Small - The OSGi Release 4 Framework can be implemented in about a 300KB JAR file. This is a small overhead for the amount of functionality that is added to an application by including OSGi. OSGi therefore runs on a large range of devices: from very small, to small, to mainframes. It only asks for a minimal Java VM to run and adds very little on top of it.Fast - One of the primary responsibilities of the OSGi framework is loading the classes from bundles. In traditional Java, the JARs are completely visible and placed on a linear list. Searching a class requires searching through this (often very long, 150 is not uncommon) list. In contrast, OSGi pre-wires bundles and knows for each bundle exactly which bundle provides the class. This lack of searching is a significant speed up factor at startup.Lazy - Lazy in software is good and the OSGi technology has many mechanisms in place to do things only when they are really needed. For example, bundles can be started eagerly, but they can also be configured to only start when other bundles are using them. Services can be registered, but only created when they are used. The specifications have been optimized several times to allow for these kind of lazy scenarios that can save tremendous runtime costs.Secure - Java has a very powerful fine grained security model at the bottom but it has turned out very hard to configure in practice. The result is that most secure Java applications are running with a binary choice: no security or very limited capabilities. The OSGi security model leverages the fine grained security model but improves the usability (as well as hardening the original model) by having the bundle developer specify the requested security details in an easily audited form while the operator of the environment remains fully in charge. Overall, OSGi likely provides one of the most secure application environments that is still usable short of hardware protected computing platforms.Non Intrusive - Applications (bundles) in an OSGi environment are left to their own. They can use virtually any facility of the VM without the OSGi restricting them. Best practice in OSGi is to write Plain Old Java Objects and for this reason, there is no special interface required for OSGi services, even a Java String object can act as an OSGi service. This strategy makes application code easier to port to another environment.Runs Everywhere - Well, that depends. The original goal of Java was to run anywhere. Obviously, it is not possible to run all code everywhere because the capabilities of the Java VMs differ. A VM in a mobile phone will likely not support the same libraries as an IBM mainframe running a banking application. There are two issue to take care of. First, the OSGi APIs should not use classes that are not available on all environments. Second, a bundle should not start if it contains code that is not available in the execution environment. Both of these issues have been taken care of in the OSGi specifications.Source : www.osgi.org/Technology/WhyOSGiI don\'t care too much about the hotplugability of OSGi modules (at least currently). It\'s more the enforced modularity. Not having millions of "public" classes available on the classpath at any time protects well from circular dependencies: You have to really think about your public interfaces - not just in terms of the java language construct "public", but in terms of your library/module: What (exactly) are the components, that you want to make available for others? What (exactly) are the interfaces (of other modules) you really need to implement your functionality?It\'s nice, that hotplug comes with it, but I\'d rather restart my usual applications than testing all combinations of hotplugability... There are a lot of benefits (I reminded just these now), available for everyone who uses Java.edited for clarity. OSGi page gave a better simple answer than mineA simple answer: An OSGi Service Platform provides a standardized, component-oriented computing environment for cooperating networked services. This architecture significantly reduces the overall complexity of building, maintaining and deploying applications.\nThe OSGi Service Platform provides the functions to change the composition dynamically on the device of a variety of networks, without requiring a restarts.In a single application structure, say the Eclipse IDE, it\'s not a big deal to restart when you install a new plugin. Using the OSGi implementation completely, you should be able to add plugins at runtime, get the new functionality, but not have to restart eclipse at all.Again, not a big deal for every day, small application use.But, when you start to look at multi-computer, distributed application frameworks, that\'s where it starts to get interesting. When you have to have 100% uptime for critical systems, the capability to hotswap components or add new functionality at runtime is useful. Granted, there are capabilities for doing this now for the most part, but OSGi is trying to bundle everything into a nice little framework with common interfaces.Does OSGi solve common problems, I\'m not sure about that. I mean, it can, but the overhead may not be worth it for simpler problems. But it\'s something to consider when you are starting to deal with larger, networked, applications.A Few Things that drive me nuts on OSGi:1) The implentations and their context loaders have a lot of quirks to them, and can be somewhat async (We use felix inside of confluence).  Compared to a pure spring (no DM) where [main] is pretty much running through everything sync.2)Classes are not equal after a hot load.  Say, for instance you have a tangosol cache layer on hibernate.  It is filled with Fork.class, outside of the OSGi scope.  You hotload a new jar, and Fork has not changed.  Class[Fork] != Class[Fork].  It also appears during serialization, for the same underlying causes.3)Clustering.You can work around these things, but it is a major major pain, and makes your architecture look flawed.And to those of you advertising the hotplugging.. OSGi\'s #1 Client?  Eclipse.  What does Eclipse do after loading the bundle?It restarts.If a Java based application requires adding or removing modules (extending the base functionality of application), without shutting down the JVM, OSGI can be employed. Usually if the cost of shutting down JVM is more, just to update or to enhance functionality. Examples:Note: Spring framework stopped supporting OSGI spring bundles, considering it as unnecessary complexity for transaction based applications or for some point in these lines. I personally do not consider OSGI unless it is absolutely necessary, in something big like building a platform.I am yet to be a "fan" of OSGi...I have been working with an enterprise application at Fortune 100 companies.  Recently, the product we use has "upgraded" to an OSGi implementation.starting local cba deployment...\n[2/18/14 8:47:23:727 EST] 00000347 CheckForOasisfinally deployed and "the following bundles will be quiesced and then restarted"\n[2/18/14 9:38:33:108 EST] 00000143 AriesApplicat I   CWSAI0054I: As part of an update operation for application51 minutes... each time code changes... The previous version (non-OSGi) would deploy in less than 5 minutes on older development machines.on a machine with 16 gig ram and 40 free gig disk and Intel i5-3437U 1.9 GHz CPUThe "benefit" of this upgrade was sold as improving (production) deployments - an activity that we do about 4 times a year with maybe 2-4 small fix deployments a year.  Adding 45 minutes per day to 15 people (QA and developers) I can\'t imagine ever being justified.  In big enterprise applications, if your application is a core application, then changing it is, rightly so (small changes have potential for far reaching impacts - must be communicated and planned with consumers all over the enterprise), a monumental activity - wrong architecture for OSGi.  If your application is not an enterprise application - i.e. each consumer can have their own tailored module likely hitting their own silo of data in their own silo\'d database and running on a server that hosts many applications, then maybe look at OSGi.  At least, that is my experience thus far.It is also being used to bring additional portability of middleware and applications on the mobile side.  Mobile side is available for WinMo, Symbian, Android for example.  As soon as integration with device features occurs, can get fragmented.At the very least, OSGi makes you THINK about modularity, code reuse, versioning and in general the plumbing of a project.The OSGi provides following benefit:\xe2\x96\xa0  A portable and secure execution environment based on Java\xe2\x96\xa0 A service management system, which can be used to register and share services across bundles and decouple service providers from service consumers\xe2\x96\xa0 A dynamic module system, which can be used to dynamically install and uninstall\nJava modules, which OSGi calls bundles\xe2\x96\xa0 A lightweight and scalable solutionOthers have already outlined the benefits in detail, I hereby explain the practical usecases I have either seen or used OSGi.OSGi makes your code throw NoClassDefFoundError and ClassNotFoundException for no apparent reason (most probably because you forgot to export a package in OSGi configuration file); since it has ClassLoaders it can make your class com.example.Foo fail to be cast to com.example.Foo since it\'s actually two different classes loaded by two different classloaders. It can make your Eclipse boot into an OSGi console after installing an Eclipse plugin.For me, OSGi only added complexity (because it added one more mental model for me to grok), added annoyances because of exceptions; I never really needed the dynamicity it "offers". It was intrusive since it required OSGi bundle configuration for all modules; it was definitely not simple (in a larger project).Because of my bad experience, I tend to stay away from that monster, thank you very much. I\'d rather suffer from jar dependency hell, since that\'s way way more easily understandable than the classloader hell OSGi introduces.