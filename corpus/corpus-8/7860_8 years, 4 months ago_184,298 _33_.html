I have a textbox with the .Multiline property set to true.  At regular intervals, I am adding new lines of text to it.  I would like the textbox to automatically scroll to the bottom-most entry (the newest one) whenever a new line is added.  How do I accomplish this?At regular intervals, I am adding new lines of text to it. I would like the textbox to automatically scroll to the bottom-most entry (the newest one) whenever a new line is added.If you use TextBox.AppendText(string text), it will automatically scroll to the end of the newly appended text. It avoids the flickering scrollbar if you\'re calling it in a loop.It also happens to be an order of magnitude faster than concatenating onto the .Text property. Though that might depend on how often you\'re calling it; I was testing with a tight loop.This will not scroll if it is called before the textbox is shown, or if the textbox is otherwise not visible (e.g. in a different tab of a TabPanel). See TextBox.AppendText() not autoscrolling. This may or may not be important, depending on if you require autoscroll when the user can\'t see the textbox.It seems that the alternative method from the other answers also don\'t work in this case. One way around it is to perform additional scrolling on the VisibleChanged event:Internally, AppendText does something like this:But there should be no reason to do it manually.(If you decompile it yourself, you\'ll see that it uses some possibly more efficient internal methods, and has what seems to be a minor special case.)You can use the following code snippet:which will automatically scroll to the end.It seems the interface has changed in .NET 4.0.  There is the following method that achieves all of the above. As Tommy Engebretsen suggested, putting it in a TextChanged event handler makes it automatic.Try to add the suggested code to the TextChanged event:I needed to add a refresh:didn\'t work for me (Windows 8.1, whatever the reason).\nAnd since I\'m still on .NET 2.0, I can\'t use ScrollToEnd.\n\nBut this works:VB.NET:I found a simple difference that hasn\'t been addressed in this thread.If you\'re doing all the ScrollToCarat() calls as part of your form\'s Load() event, it doesn\'t work.  I just added my ScrollToCarat() call to my form\'s Activated() event, and it works fine.EditIt\'s important to only do this scrolling the first time form\'s Activated event is fired (not on subsequent activations), or it will scroll every time your form is activated, which is something you probably don\'t want.So if you\'re only trapping the Activated() event to scroll your text when your program loads, then you can just unsubscribe to the event inside the event handler itself, thusly:If you have other things you need to do each time your form is activated, you can set a bool to true the first time your Activated() event is fired, so you don\'t scroll on subsequent activations, but can still do the other things you need to do.Also, if your TextBox is on a tab that isn\'t the SelectedTab, ScrollToCarat() will have no effect.  So you need at least make it the selected tab while you\'re scrolling.  You can wrap the code in a YourTab.SuspendLayout(); and YourTab.ResumeLayout(false); pair if your form flickers when you do this.End of editHope this helps!This will scroll to the end of the textbox when the text is changed, but still allows the user to scroll uptested on Visual Studio Enterprise 2017This only worked for me... txtSerialLogging->Text = "";txtSerialLogging->AppendText(s);I tried all the cases above, but the problem is in my case text s can decrease, increase and can also remain static for a long time.\nstatic means , static length(lines) but content is different.So, I was facing one line jumping situation at the end when the length(lines) remains same for some times...I use a function for this :