I have an array X of 10 elements. I would like to create a new array containing all the elements from X that begin at index 3 and ends in index 7. Sure I can easily write a loop that will do it for me but I would like to keep my code as clean as possible. Is there a method in C# that can do it for me?Something like (pseudo code):Array.Copy doesn\'t fit my needs. I need the items in the new array to be clones. Array.copy is just a C-Style memcpy equivalent, it\'s not what I\'m looking for.You could add it as an extension method:Update re cloning (which wasn\'t obvious in the original question). If you really want a deep clone; something like:This does require the objects to be serializable ([Serializable] or ISerializable), though. You could easily substitute for any other serializer as appropriate - XmlSerializer, DataContractSerializer, protobuf-net, etc.Note that deep clone is tricky without serialization; in particular, ICloneable is hard to trust in most cases.You can use Array.Copy(...) to copy into the new array after you\'ve created it, but I don\'t think there\'s a method which creates the new array and copies a range of elements.If you\'re using .NET 3.5 you could use LINQ:but that will be somewhat less efficient.See this answer to a similar question for options for more specific situations.Have you considered using ArraySegment? http://msdn.microsoft.com/en-us/library/1hsbd92d.aspxI see you want to do Cloning, not just copying references.\nIn this case you can use .Select to project array members to their clones.\nFor example, if your elements implemented IClonable you could do something like this:The following code does it in one line:Building on Marc\'s answer but adding the desired cloning behaviourAnd if implementing ICloneable is too much like hard work a reflective one using H\xc3\xa5vard Stranden\xe2\x80\x99s Copyable library to do the heavy lifting required.  Note that the OX.Copyable implementation works with any of:For the automated copy to work, though, one of the following statements must hold for instance:So this should cover almost any situation you have. If you are cloning objects where the sub graph contains things like db connections or file/stream handles you obviously have issues but that it true for any generalized deep copy.If you want to use some other deep copy approach instead this article lists several others so I would suggest not trying to write your own.You can do this fairly easially;     Array.ConstrainedCopy will work.I think that the code you are looking for is:Array.Copy(oldArray, 0, newArray, BeginIndex, EndIndex - BeginIndex)As an alternative to copying the data you can make a wrapper that gives you access to a part of the original array as if it was a copy of the part of the array. The advantage is that you don\'t get another copy of the data in memory, and the drawback is a slight overhead when accessing the data.Usage:There\'s no single method that will do what you want. You will need to make a clone method available for the class in your array. Then, if LINQ is an option:How about useing Array.ConstrainedCopy:You could use Array.CopyTo:How about this:You then need to implement the ICloneable interface on all of the classes you need to use this on but that should do it.I\'m not sure how deep it really is, but:MyArray.ToList<TSource>().GetRange(beginningIndex, endIndex).ToArray()It\'s a bit of overhead, but it might cut out an unnecessary method.As far as cloning goes, I don\'t think serialization calls your constructors. This may break class invariants if you\'re doing interesting things in the ctor\'s.It seems the safer bet is virtual clone methods calling copy constructors.Cloning elements in an array is not something that can be done in a universal way. Do you want deep cloning or a simple copy of all members?Let\'s go for the "best effort" approach: cloning objects using the ICloneable interface or binary serialization:This is not a perfect solution, because there simply is none that will work for any type of object.You can take class made by Microsoft:and then This is the optimal way, I found, to do this:Hope It Helps!