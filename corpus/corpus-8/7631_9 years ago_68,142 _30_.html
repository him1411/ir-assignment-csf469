I have just found a static nested interface in our code-base.I have never seen this before. The original developer is out of reach. Therefore I have to ask SO:What are the semantics behind a static interface? What would change, if I remove the static? Why would anyone do this?The static keyword in the above example is redundant (a nested interface is automatically "static") and can be removed with no effect on semantics; I would recommend it be removed. The same goes for "public" on interface methods and "public final" on interface fields - the modifiers are redundant and just add clutter to the source code.Either way, the developer is simply declaring an interface named Foo.Bar. There is no further association with the enclosing class, except that code which cannot access Foo will not be able to access Foo.Bar either. (From source code - bytecode or reflection can access Foo.Bar even if Foo is package-private!)It is acceptable style to create a nested interface this way if you expect it to be used only from the outer class, so that you do not create a new top-level name. For example:The question has been answered, but one good reason to use a nested interface is if its function is directly related to the class it is in. A good example of this is a Listener. If you had a class Foo and you wanted other classes to be able to listen for events on it, you could declare an interface named FooListener, which is ok, but it would probably be more clear to declare a nested interface and have those other classes implement Foo.Listener (a nested class Foo.Event isn\'t bad along with this).Member interfaces are implicitly static. The static modifier in your example can be removed without changing the semantics of the code. See also the the Java Language Specification 8.5.1. Static Member Type DeclarationsAn inner interface has to be static in order to be accessed. The interface isn\'t associated with instances of the class, but with the class itself, so it would be accessed with Foo.Bar, like so:In most ways, this isn\'t different from a static inner class.Jesse\'s answer is close, but I think that there is a better code to demonstrate why an inner interface may be useful. Look at the code below before you read on. Can you find why the inner interface is useful? The answer is that class DoSomethingAlready can be instantiated with any class that implements A and C; not just the concrete class Zoo. Of course, this can be achieved even if AC is not inner, but imagine concatenating longer names (not just A and C), and doing this for other combinations (say, A and B, C and B, etc.) and you easily see how things go out of control. Not to mention that people reviewing your source tree will be overwhelmed by interfaces that are meaningful only in one class.So to summarize,  an inner interface enables the construction of custom types and improves their encapsulation.To answer your question very directly, look at Map.Entry.Map.Entryalso this may be usefulStatic Nested Inerfaces blog EntryIf you will change class Foo into interface Foo the "public" keyword in the above example will be also redundant as well because interface defined inside another interface will implicitly public\n  static.Typically I see static inner classes. Static inner classes cannot reference the containing classes wherease non-static classes can. Unless you\'re running into some package collisions (there already is an interface called Bar in the same package as Foo) I think I\'d make it it\'s own file. It could also be a design decision to enforce the logical connection between Foo and Bar. Perhaps the author intended Bar to only be used with Foo (though a static inner interface won\'t enforce this, just a logical connection)In 1998, Philip Wadler suggested a difference between static interfaces and non-static interfaces.So far as I can see, the only difference in making an\n  interface non-static is that it can now include non-static inner\n  classes; so the change would not render invalid any existing Java\n  programs.For example, he proposed a solution to the Expression Problem, which is the mismatch between expression as "how much can your language express" on the one hand and expression as "the terms you are trying to represent in your language" on the other hand.An example of the difference between static and non-static nested interfaces can be seen in his sample code:His suggestion never made it in Java 1.5.0. Hence, all other answers are correct: there is no difference to static and non-static nested interfaces.In Java, the static interface/class allows the interface/class to be used like a top-level class, that is, it can be declared by other classes. So, you can do:Without the static, the above would fail to compile. The advantage to this is that you don\'t need a new source file just to declare the interface. It also visually associates the interface Bar to the class Foo since you have to write Foo.Bar and implies that the Foo class does something with instances of Foo.Bar.A description of class types in Java.Static means that any class part of the package(project) can acces it without using a pointer. This can be usefull or hindering depending on the situation.The perfect example of the usefullnes of "static" methods is the Math class. All methods in Math are static. This means you don\'t have to go out of your way, make a new instance, declare variables and store them in even more variables, you can just enter your data and get a result.Static isn\'t always that usefull. If you\'re doing case-comparison for instance, you might want to store data in several different ways. You can\'t create three static methods with identical signatures. You need 3 different instances, non-static, and then you can and compare, caus if it\'s static, the data won\'t change along with the input.Static methods are good for one-time returns and quick calculations or easy obtained data.