While working in a Java app, I recently needed to assemble a comma-delimited list of values to pass to another web service without knowing how many elements there would be in advance. The best I could come up with off the top of my head was something like this:I realize this isn\'t particularly efficient, since there are strings being created all over the place, but I was going for clarity more than optimization.In Ruby, I can do something like this instead, which feels much more elegant:But since Java lacks a join command, I couldn\'t figure out anything equivalent.So, what\'s the best way to do this in Java?Apache\'s commons lang is your friend here - it provides a join method very similar to the one you refer to in Ruby: StringUtils.join(java.lang.Iterable,char)Java 8 provides joining out of the box via StringJoiner and String.join(). The snippets below show how you can use them:StringJoinerString.join(CharSequence delimiter, CharSequence... elements))String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)You could write a little join-style utility method that works on java.util.ListsThen use it like so:In the case of Android, the StringUtils class from commons isn\'t available, so for this I usedhttp://developer.android.com/reference/android/text/TextUtils.htmlThe Google\'s Guava library has com.google.common.base.Joiner class which helps to solve such tasks.Samples:Here is an article about Guava\'s string utilities.In Java 8 you can use String.join():Also have a look at this answer for a Stream API example.You can generalize it, but there\'s no join in Java, as you well say.This might work better. Use an approach based on java.lang.StringBuilder!  ("A mutable sequence of characters. ")Like you mentioned, all those string concatenations are creating Strings all over.  StringBuilder won\'t do that.Why StringBuilder instead of StringBuffer?  From the StringBuilder javadoc:Where possible, it is recommended that this class be used in preference to StringBuffer as it will be faster under most implementations. I would use Google Collections.  There is a nice Join facility.\nhttp://google-collections.googlecode.com/svn/trunk/javadoc/index.html?com/google/common/base/Join.htmlBut if I wanted to write it on my own,I think it works better with an object collection, since now you don\'t have to convert your objects to strings before you join them.in Java 8 you can do this like:if list has nulls you can use:Apache commons StringUtils class has a join method.You can use Java\'s StringBuilder type for this. There\'s also StringBuffer, but it contains extra thread safety logic that is often unnecessary.If you are using Spring MVC then you can try following steps.It will result to a,b,cUse StringBuilder and class SeparatorSeparator wraps a delimiter. The delimiter is returned by Separator\'s toString method, unless on the first call which returns the empty string!Source code for class SeparatorWhy not write your own join() method?  It would take as parameters collection of Strings and a delimiter String.  Within the method iterate over the collection and build up your result in a StringBuffer.You should probably use a StringBuilder with the append method to construct your result, but otherwise this is as good of a solution as Java has to offer.Why don\'t you do in Java the same thing you are doing in ruby, that is creating the delimiter separated string only after you\'ve added all the pieces to the array?You may want to move that for loop in a separate helper method, and also use StringBuilder instead of StringBuffer...Edit: fixed the order of appends.With Java 5 variable args, so you don\'t have to stuff all your strings into a collection or array explicitly:For those who are in a Spring context their StringUtils class is useful as well:There are many useful shortcuts like:and many others. This can be helpful if you are not already using Java 8 and you are already in a Spring context.I prefer it against the Apache Commons (although very good as well) for the Collection support which is easier like this:And a minimal one (if you don\'t want to include Apache Commons or Gauva into project dependencies just for the sake of joining strings)If you\'re using Eclipse Collections, you can use makeString() or appendString().makeString() returns a String representation, similar to toString().It has three formsCode example:appendString() is similar to makeString(), but it appends to an Appendable (like StringBuilder) and is void. It has the same three forms, with an additional first argument, the Appendable.If you can\'t convert your collection to an Eclipse Collections type, just adapt it with the relevant adapter.Note: I am a committer for Eclipse collections.You can try something like this:So basically something like this:Don\'t know if this really is any better, but at least it\'s using StringBuilder, which may be slightly more efficient.Down below is a more generic approach if you can build up the list of parameters BEFORE doing any parameter delimiting.Your approach is not too bad, but you should use a StringBuffer instead of using the + sign. The + has the big disadvantage that a new String instance is being created for each single operation. The longer your string gets, the bigger the overhead. So using a StringBuffer should be the fastest way:After you have finished creating your string simply call toString() on the returned StringBuffer.Instead of using string concatenation, you should use StringBuilder if your code is not threaded, and StringBuffer if it is.You\'re making this a little more complicated than it has to be. Let\'s start with the end of your example:With the small change of using a StringBuilder instead of a String, this becomes:When you\'re done (I assume you have to check a few other conditions as well), just make sure you remove the tailing comma with a command like this:And finally, get the string you want withYou could also replace the "," in the second call to append with a generic delimiter string that can be set to anything. If you have a list of things you know you need to append (non-conditionally), you could put this code inside a method that takes a list of strings. So a couple of things you might do to get the feel that it seems like you\'re looking for:1) Extend List class - and add the join method to it.  The join method would simply do the work of concatenating and adding the delimiter (which could be a param to the join method)2) It looks like Java 7 is going to be adding extension methods to java - which allows you just to attach a specific method on to a class:  so you could write that join method and add it as an extension method to List or even to Collection.Solution 1 is probably the only realistic one, now, though since Java 7 isn\'t out yet :) But it should work just fine.To use both of these, you\'d just add all your items to the List or Collection as usual, and then call the new custom method to \'join\' them.using Dollar is simple as typing:NB: it works also for Array and other data typesInternally it uses a very neat trick:the class Separator return the empty String only the first time that it is invoked, then it returns the separator: