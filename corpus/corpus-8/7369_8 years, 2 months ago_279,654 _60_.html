This question already has an answer here:I\'ve developed a random string generator but it\'s not behaving quite as I\'m hoping.  My goal is to be able to run this twice and generate two distinct four character random strings.  However, it just generates one four character random string twice.Here\'s the code and an example of its output:...and the output looks like this:  UNTE-UNTE\n...but it should look something like this UNTE-FWNUHow can I ensure two distinctly random strings?You\'re making the Random instance in the method, which causes it to return the same values when called in quick succession. I would do something like this:(modified version of your code)You\'re instantiating the Random object inside your method.The Random object is seeded from the system clock, which means that if you call your method several times in quick succession it\'ll use the same seed each time, which means that it\'ll generate the same sequence of random numbers, which means that you\'ll get the same string.To solve the problem, move your Random instance outside of the method itself (and while you\'re at it you could get rid of that crazy sequence of calls to Convert and Floor and NextDouble)://A very Simple implementation //Now just call RandomStr() MethodAs long as you are using Asp.Net 2.0 or greater, you can also use the library call-\nSystem.Web.Security.Membership.GeneratePassword, however it will include special characters.To get 4 random characters with minimum of 0 special characters-Just for people stopping by and what to have a random string in just one single line of codePS: Please keep in mind that yourRandomStringLength cannot exceed 32 as Guid has max length of 32.Yet another version of string generator. Simple, without fancy math and magic digits. But with some magic string which specifies allowed characters.Update:\nI made generator static, so it will not return same string when called multiple times. However this code is not thread-safe and is definitely not cryptographically secure. For password generation System.Security.Cryptography.RNGCryptoServiceProvider should be used.This solution is an extension for a Random class.Here is one more option:The best solution is using the random number generator toghether with base64 conversion This is because each new instance of Random is generating the same numbers from being called so fast. Do not keep creating a new instance, just call next() and declare your random class outside of your method.A LINQ one-liner for good measure (assuming a private static Random Random)...You should have one class-level Random object initiated once in the constructor and reused on each call (this continues the same sequence of pseudo-random numbers). The parameterless constructor already seeds the generator with Environment.TickCount internally.I added the option to choose the length using the Ranvir solutionHere is my modification of the currently accepted answer, which I believe it\'s a little faster and shorter:Notice I didn\'t use all the multiplication, Math.floor(), Convert etc.EDIT: random.Next(0x41, 0x5A) can be changed to any range of Unicode characters.My RandomString() method to generate a random string.I think may be this is also acceptable and simple.If you wanted to generate a string of Numbers and Characters for a strong password.Combining the answer by "Pushcode" and the one using the seed for the random generator. I needed it to create a serie of pseudo-readable \'words\'.I created this method.It works great.And here is another idea based on GUIDs. I\'ve used it for the Visual Studio performance test to generate random string contaning only alphanumeric characters.Here is a blog post that provides a bit more robust class for generating random words, sentences and paragraphs.You also will need this:And this:Actually, a good solution is to have a static method for the random number generator that is thread-safe and doesn\'t use locks.That way, multiple users accessing your web application at the same time don\'t get the same random strings.There are 3 examples here:\nhttp://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspxI\'d use the last one:Then you can properly eliminate And just call RandomGen3.Next(), while your method can remain static.For random string generator :I found this to be more helpfull, since it is an extention, and it allows you to select the source of your code.Hope this helps.In my situation, the password must contain:Here is my code:Hello you can use WordGenerator or LoremIpsumGenerator from MMLib.RapidPrototyping nuget package.Nuget site\nCodeplex project siteIf you have access to an Intel Secure Key compatible CPU, you can generate real random numbers and strings using these libraries: https://github.com/JebteK/RdRand and https://www.rdrand.com/Just download the latest version from here, include Jebtek.RdRand and add a using statement for it. Then, all you need to do is this:Plus, you also get these additional capabilities:If you don\'t have a compatible CPU to execute the code on, just use the RESTful services at rdrand.com. With the RdRandom wrapper library included in your project, you would just need to do this (you get 1000 free calls when you signup):You can also generate random byte arrays and unsigned integers as follows:Another sample (tested in vs2013):Implemented by myself.This is my solution: