I\'m trying to learn WPF and the MVVM problem, but have hit a snag.\nThis question is similar but not quite the same as this one (handling-dialogs-in-wpf-with-mvvm)...I have a "Login" form written using the MVVM pattern.This form has a ViewModel which holds the Username and Password, which are bound to the view in the XAML using normal data bindings.\nIt also has a "Login" command which is bound to the "Login" button on the form, agan using normal databinding.When the "Login" command fires, it invokes a function in the ViewModel which goes off and sends data over the network to log in. When this function completes, there are 2 actions:The login was invalid - we just show a MessageBox and all is fineThe login was valid, we need to close the Login form and have it return true as its DialogResult...The problem is, the ViewModel knows nothing about the actual view, so how can it close the view and tell it to return a particular DialogResult?? I could stick some code in the CodeBehind, and/or pass the View through to the ViewModel, but that seems like it would defeat the whole point of MVVM entirely...In the end I just violated the "purity" of the MVVM pattern and had the View publish a Closed event, and expose a Close method. The ViewModel would then just call view.Close. The view is only known via an interface and wired up via an IOC container, so no testability or maintainability is lost.It seems rather silly that the accepted answer is at -5 votes! While I\'m well aware of the good feelings that one gets by solving a problem while being "pure", Surely I\'m not the only one that thinks that 200 lines of events, commands and behaviors just to avoid a one line method in the name of "patterns" and "purity" is a bit ridiculous....I was inspired by Thejuan\'s answer to write a simpler attached property. No styles, no triggers; instead, you can just do this:This is almost as clean as if the WPF team had gotten it right and made DialogResult a dependency property in the first place. Just put a bool? DialogResult property on your ViewModel and implement INotifyPropertyChanged, and voil\xc3\xa0, your ViewModel can close the Window (and set its DialogResult) just by setting a property. MVVM as it should be.Here\'s the code for DialogCloser:I\'ve also posted this on my blog.From my perspective the question is pretty good as same approach would be used not only for "Login" window, but for any kind of them. I\'ve passed through a lot of suggestions and no one is ok for me. Please see my kind, that was taken from the MVVM design pattern article.Each ViewModel class should be inherited from WorkspaceViewModel that has RequestClose envent, and CloseCommand property of the ICommand type. Default implementation of the CloseCommand property will raise RequestClose event.And in order to get window closed the OnLoaded method of your window should be overrided:or OnStartup method of you app:I guess that RequestClose event and CloseCommand property implementation in the WorkspaceViewModel are pretty clear, but I will show them to be consistent:And the source code of the RelayCommand:P.S. Don\'t treat me badly for those sources, If I had that yesterday that would save me few hours...P.P.S Any comments or suggestions are welcome.I used attached behaviours to close the window.\nBind a "signal" property on your ViewModel to the attached behaviour (I actually use a trigger)\nWhen it\'s set to true, the behaviour closes the window.http://adammills.wordpress.com/2009/07/01/window-close-from-xaml/There are a lot of comments arguing the pros and cons of MVVM here.  For me, I agree with Nir; it\'s a matter of using the pattern appropriately and MVVM doesn\'t always fit.  People seems to have become willing to sacrifice all of the most important principles of software design JUST to get it to fit MVVM.That said,..i think your case could be a good fit with a bit of refactoring.In most cases I\'ve come across, WPF enables you to get by WITHOUT multiple Windows.  Maybe you could try using Frames and Pages instead of Windows with DialogResults.In your case my suggestion would be have LoginFormViewModel handle the LoginCommand and if the login is invalid, set a property on LoginFormViewModel to an appropriate value (false or some enum value like UserAuthenticationStates.FailedAuthentication).  You\'d do the same for a successful login (true or some other enum value).  You\'d then use a DataTrigger which responds to the various user authentication states and could use a simple Setter to change the Source property of the Frame.  Having your login Window return a DialogResult i think is where you\'re getting confused; that DialogResult is really a property of your ViewModel.  In my, admittedly limited experience with WPF, when something doesn\'t feel right it usually because I\'m thinking in terms of how i would\'ve done the same thing in WinForms. Hope that helps.Assuming your login dialog is the first window that gets created, try this inside your LoginViewModel class:The way I would handle it is to add an event handler in my ViewModel. When the user was successfully logged in I would fire the event. In my View I would attach to this event and when it fired I would close the window. This is a simple and clean solution - You add an event to the ViewModel and instruct the Window to close itself when that event is fired.For more details see my blog post, Close window from ViewModel.Here\'s what I initially did, which does work, however it seems rather long-winded and ugly (global static anything is never good)1: App.xaml.cs2: LoginForm.xaml3: LoginForm.xaml.cs4: LoginFormViewModel.csI later on then removed all this code, and just had the LoginFormViewModel call the Close method on it\'s view. It ended up being much nicer and easier to follow. IMHO the point of patterns is to give people an easier way to understand what your app is doing, and in this case, MVVM was making it far harder to understand than if I hadn\'t used it, and was now an anti-pattern.FYI, I ran into this same problem and I think I figured out a work around that doesn\'t require globals or statics, although it may not be the best answer.  I let the you guys decide that for yourself.In my case, the ViewModel that instantiates the Window to be displayed (lets call it ViewModelMain) also knows about the LoginFormViewModel (using the situation above as an example).  So what I did was to create a property on the LoginFormViewModel that was of type ICommand (Lets call it CloseWindowCommand). Then, before I call .ShowDialog() on the Window, I set the CloseWindowCommand property on the LoginFormViewModel to the window.Close() method of the Window I instantiated.  Then inside the LoginFormViewModel all I have to do is call CloseWindowCommand.Execute() to close the window.It is a bit of a workaround/hack I suppose, but it works well without really breaking the MVVM pattern.Feel free to critique this process as much as you like, I can take it! :)This is probably very late, but I came across the same problem and I found a solution that works for me.I can\'t figure out how to create an app without dialogs(maybe it\'s just a mind block). So I was at an impasse with MVVM and showing a dialog. So I came across this CodeProject article:http://www.codeproject.com/KB/WPF/XAMLDialog.aspxWhich is a UserControl that basically allows a window to be within the visual tree of another window(not allowed in xaml). It also exposes a boolean DependencyProperty called IsShowing.You can set a style like,typically in a resourcedictionary, that basically displays the dialog whenever the Content property of the control != null via triggers:In the view where you want to display the dialog simply have this:And in your ViewModel all you have to do is set the property to a value(Note: the ViewModel class must support INotifyPropertyChanged for the view to know something happened ).like so:To match the ViewModel with the View you should have something like this in a resourcedictionary:With all of that you get a one-liner code to show dialog. The problem you get is you can\'t really close the dialog with just the above code. So that\'s why you have to put in an event in a ViewModel base class which DisplayViewModel inherits from and instead of the code above, write thisThen you can handle the result of the dialog via the callback.This may seem a little complex, but once the groundwork is laid, it\'s pretty straightforward. Again this is my implementation, I\'m sure there are others :)Hope this helps, it saved me.Ok, so this question is nearly 6 years old and I still can\'t find in here what I think it\'s the proper answer, so allow me to share my "2 cents"...I actually have 2 ways of doing it, first one is the simple one...the second on the right one, so if you are looking for the right one, just skip #1 and jump to #2:If I have just a small project I sometimes just create a CloseWindowAction in the ViewModel:And whoever crates the View, or in the View\'s code behind I just set the Method the Action will call:(remember MVVM is about separation of the View and the ViewModel...the View\'s code behins is still the View and as long as there is proper separation you are not violating the pattern)If some ViewModel creates a new window:Or if you want it in your Main Window, just place it under your View\'s constructor:when you want to close the window, just call the Action on your ViewModel.Now the proper way of doing it is using Prism (IMHO), and all about it can be found here.You can make an Interaction Request, populate it with whatever data you will need in your new Window, lunch it, close it and even receive data back. All of this encapsulated and MVVM approved. You even get a status of how the Window was closed, like if the User Canceled or Accepted (OK button) the Window and data back if you need it. It\'s a bit more complicated and Answer #1, but it\'s a lot more complete, and a Recommended Pattern by Microsoft.The link I gave have all the code snippets and examples, so I won\'t bother to place any code in here, just read the article of download the Prism Quick Start and run it, it\'s really simple to understad just a little more verbose to make it work, but the benefits are bigger than just closing a window.You could have the ViewModel expose an event that the View registers to. Then, when the ViewModel decides its time to close the view, it fires that event which causes the view to close. If you want a specific result value passed back, then you would have a property in the ViewModel for that.Why not just pass the window as a command parameter?C#:XAML:Just to add to the massive number of answers, I want to add the following. Assuming that you have a ICommand on your ViewModel, and you want that command to close its window (or any other action for that matter), you can use something like the following.It\'s not perfect, and might be difficult to test (as it is hard to mock/stub a static) but it is cleaner (IMHO) than the other solutions.ErickI implemented Joe White\'s solution, but ran into problems with occasional "DialogResult can be set only after Window is created and shown as dialog" errors.I was keeping the ViewModel around after the View was closed and occasionally I later opened a new View using the same VM.  It appears that closing the new View before the old View had been garbage collected resulted in DialogResultChanged trying to set the DialogResult property on the closed window, thus provoking the error.My solution was to change DialogResultChanged to check the window\'s IsLoaded property:After making this change any attachments to closed dialogs are ignored.Another solution is to create property with INotifyPropertyChanged in View Model like DialogResult, and then in Code Behind write this:The most important fragment is _someViewModel_PropertyChanged.\nDialogResultPropertyName can be some public const string in SomeViewModel.I use this kind of trick to make some changes in View Controls in case when this is hard to do in ViewModel. OnPropertyChanged in ViewModel you can do anything you want in View. ViewModel is still \'unit testable\' and some small lines of code in code behind makes no difference.Where you need to close the window, simply put this in the viewmodel:ta-daI ended up blending Joe White\'s answer and some code from Adam Mills\'s answer, since I needed to show a user control in a programmatically created window. So the DialogCloser need not be on the window, it can be on the user control itselfAnd the DialogCloser will find the window of the user control if it was not attached to the window itself.I would go this way:I\'ve read all the answers but I must say, most of them are just not good enough or even worse.You could handle this beatifully with DialogService class which responsibility is to show dialog window and return dialog result. I have create sample project demonstrating it\'s implementation and usage.here are most important parts:Isn\'t this just simpler? more straitforward, more readable and last but not least easier to debug than EventAggregator or other similar solutions?as you can see, In my view models I\'m  have used ViewModel first approach described in my post here: Best practice for calling View from ViewModel in WPFOf course, in real world, the DialogService.ShowDialog must have more option to configure the dialog, e.g. buttons and commands they should execute. There are different way of doing so, but its out of scope :)While this doesn\'t answer the question of how to do this via the viewmodel, this does show how to do it using only XAML + the blend SDK.I chose to download and use two files from the Blend SDK, both of which you can as a package from Microsoft through NuGet. The files are:System.Windows.Interactivity.dll and Microsoft.Expression.Interactions.dllMicrosoft.Expression.Interactions.dll gives you nice capabilities such as the ability to set property or invoke a method on your viewmodel or other target and has other widgets inside as well.Some XAML:Note that if you\'re just going for simple OK/Cancel behavior, you can get away w/ using the IsDefault and IsCancel properties as long as the window is shown w/ Window.ShowDialog().\nI personally had problems w/ a button that had the IsDefault property set to true, but it was hidden when the page is loaded. It didn\'t seem to want to play nicely after it was shown, so I just am setting the Window.DialogResult property as shown above instead and it works for me.Here is the simple bug free solution (with source code), It is working for me.Derive your ViewModel from INotifyPropertyChangedCreate a observable property CloseDialog  in ViewModel}   Attach a Handler in View for this property changeNow you are almost done. In the event handler make DialogResult = true Create a Dependency Property in your View/any UserControl(or Window you want to close). Like below:And bind it from your ViewModel\'s property:Property In VeiwModel:Now trigger the close operation by changing the CloseWindow value in ViewModel. :)Thats enough!