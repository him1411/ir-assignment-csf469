I want to wait for a Task<T> to complete with some special rules:\nIf it hasn\'t completed after X milliseconds, I want to display a message to the user.\nAnd if it hasn\'t completed after Y milliseconds, I want to automatically request cancellation.I can use Task.ContinueWith to asynchronously wait for the task to complete (i.e. schedule an action to be executed when the task is complete), but that doesn\'t allow to specify a timeout.\nI can use Task.Wait to synchronously wait for the task to complete with a timeout, but that blocks my thread.\nHow can I asynchronously wait for the task to complete with a timeout?How about this:And here\'s a great blog post "Crafting a Task.TimeoutAfter Method"  (from MS Parallel Library team) with more info on this sort of thing.Addition: at the request of a comment on my answer, here is an expanded solution that includes cancellation handling. Note that passing cancellation to the task and the timer means that there are multiple ways cancellation can be experienced in your code, and you should be sure to test for and be confident you properly handle all of them. Don\'t leave to chance various combinations and hope your computer does the right thing at runtime.Here\'s a extension method version that incorporates cancellation of the timeout when the original task completes as suggested by Andrew Arnott in a comment to his answer. You can use Task.WaitAny to wait the first of multiple tasks.You could create two additional tasks (that complete after the specified timeouts) and then use WaitAny to wait for whichever completes first. If the task that completed first is your "work" task, then you\'re done. If the task that completed first is a timeout task, then you can react to the timeout (e.g. request cancellation).What about something like this?You can use the Task.Wait option without blocking main thread using another Task.Here is a fully worked example based on the top voted answer, which is:The main advantage of the implementation in this answer is that generics have been added, so the function (or task) can return a value. This means that any existing function can be wrapped in a timeout function, e.g.:Before: After:This code requires .NET 4.5.CaveatsHaving given this answer, its generally not a good practice to have exceptions thrown in your code during normal operation, unless you absolutely have to: Only use this code if you absolutely cannot alter the function you are calling so it times out after a specific TimeSpan.This answer is really only applicable when dealing with 3rd party library libraries that you simply cannot refactor to include a timeout parameter.How to write robust codeIf you want to write robust code, the general rule is this:Every single operation that could potentially block indefinitely, must have a timeout.If you do not observe this rule, your code will eventually hit an operation that fails for some reason, then it will block indefinitely, and your app has just permanently hung. If there was a reasonable timeout after some time, then your app would hang for some extreme amount of time (e.g. 30 seconds) then it would either display an error and continue on its merry way, or retry.Use a Timer to handle the message and automatic cancellation.  When the Task completes, call Dispose on the timers so that they will never fire.  Here is an example; change taskDelay to 500, 1500, or 2500 to see the different cases: Also, the Async CTP provides a TaskEx.Delay method that will wrap the timers in tasks for you.  This can give you more control to do things like set the TaskScheduler for the continuation when the Timer fires.  Another way of solving this problem is using Reactive Extensions:Test up above using below code in your unit test, it works for meYou may need the following namespace:A generic version of @Kevan\'s answer above with Reactive Extensions.With optional Scheduler:BTW: When a Timeout happens, a timeout exception will be thrownIf you use a BlockingCollection to schedule the task, the producer can run the potentially long running task and the consumer can use the TryTake method which has timeout and cancellation token built in.