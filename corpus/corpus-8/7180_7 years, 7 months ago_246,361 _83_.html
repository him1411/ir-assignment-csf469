How can a web application detect a paste event and retrieve the data to be pasted?I would like to remove HTML content before the text is pasted into a rich text editor.Cleaning the text after being pasted afterwards works, but the problem is that all previous formatting is lost. For example, I can write a sentence in the editor and make it bold, but when I paste new text, all formatting is lost. I want to clean just the text that is pasted, and leave any previous formatting untouched.Ideally, the solution should work across all modern browsers (e.g., MSIE, Gecko, Chrome, and Safari).Note that MSIE has clipboardData.getData(), but I could not find similar functionality for other browsers.The situation has changed since writing this answer: now that Firefox has added support in version 22, all major browsers now support accessing the clipboard data in a paste event. See Nico Burns\'s answer for an example.In the past this was not generally possible in a cross-browser way. The ideal would be to be able to get the pasted content via the paste event, which is possible in recent browsers but not in some older browsers (in particular, Firefox < 22).When you need to support older browsers, what you can do is quite involved and a bit of a hack that will work in Firefox 2+, IE 5.5+ and WebKit browsers such as Safari or Chrome. Recent versions of both TinyMCE and CKEditor use this technique:Note that this will only work for keyboard paste events and not pastes from the context or edit menus. By the time the paste event fires, it\'s too late to redirect the caret into the textarea (in some browsers, at least).In the unlikely event that you need to support Firefox 2, note that you\'ll need to place the textarea in the parent document rather than the WYSIWYG editor iframe\'s document in that browser.Works for IE6+, FF 22+, Chrome, Safari, Edge\n(Only tested in IE9+, but should work for lower versions)If you need support for pasting HTML or Firefox <= 22, see Solution #2.JSFiddle: https://jsfiddle.net/swL8ftLs/12/Note that this solution uses the parameter \'Text\' for the getData function, which is non-standard. However, it works in all browsers at the time of writing.Tested in IE6+, FF 3.5+, Chrome, Safari, EdgeJSFiddle: https://jsfiddle.net/nicoburns/wrqmuabo/23/The onpaste event of the div has the handlePaste function attached to it and passed a single argument: the event object for the paste event. Of particular interest to us is the clipboardData property of this event which enables clipboard access in non-ie browsers. In IE the equivalent is window.clipboardData, although this has a slightly different API.See resources section below.The handlepaste function:This function has two branches.The first checks for the existence of event.clipboardData and checks whether it\'s types property contains \'text/html\' (types may be either a DOMStringList which is checked using the contains method, or a string which is checked using the indexOf method). If all of these conditions are fulfilled, then we proceed as in solution #1, except with \'text/html\' instead of \'text/plain\'. This currently works in Chrome and Firefox 22+.If this method is not supported (all other browsers), then weThe waitforpastedata function:This function first polls for the pasted data (once per 20ms), which is necessary because it doesn\'t appear straight away. When the data has appeared it:The processpaste function:Does arbitrary things with the pasted data. In this case we just alert the data, you can do whatever you like. You will probably want to run the pasted data through some kind of data sanitising process.Saving and restoring the cursor positionIn a real sitution you would probably want to save the selection before, and restore it afterwards (Set cursor position on contentEditable <div>). You could then insert the pasted data at the position the cursor was in when the user initiated the paste action.Thanks to Tim Down to suggesting the use of a DocumentFragment, and abligh for catching an error in Firefox due to the use of DOMStringList instead of a string for clipboardData.typesSimple version : (jQuery)Using clipboardDataDemo : http://jsbin.com/vokovividu/edit?js,outputIE Edge, Firefox, Chrome, Safari, Opera tested.Live DemoTested on Chrome / FF / IE11I\'ve written a little proof of concept for Tim Downs proposal here with off-screen textarea. And here goes the code:Just copy and paste the whole code into one html file and try to paste (using ctrl-v) text from clipboard anywhere on the document. I\'ve tested it in IE9 and new versions of Firefox, Chrome and Opera. Works quite well. Also it\'s good that one can use whatever key combination he prefers to triger this functionality. Of course don\'t forget to include jQuery sources.Feel free to use this code and if you come with some improvements or problems please post them back. Also note that I\'m no Javascript developer so I may have missed something (=>do your own testign).Based on l2aelba anwser. This was tested on FF, Safari, Chrome, IE (8,9,10 and 11)This one does not use any setTimeout().I have used this great article to achieve cross browser support.This code is extended with selection handle before paste:\ndemoFor cleaning the pasted text and replacing the currently selected text with the pasted text the matter is pretty trivial:JS:Solution that works for me is adding event listener to paste event if you are pasting to a text input.\nSince paste event happens before text in input changes, inside my on paste handler I create a deferred function inside which I check for changes in my input box that happened on paste:This should work on all browsers that support the onpaste event and the mutation observer.This solution goes a step beyond getting the text only, it actually allows you to edit the pasted content before it get pasted into an element.It works by using contenteditable, onpaste event (supported by all major browsers) en mutation observers (supported by Chrome, Firefox and IE11+)step 1Create a HTML-element with contenteditablestep 2In your Javascript code add the following eventWe need to bind pasteCallBack, since the mutation observer will be called asynchronously.step 3Add the following function to your code}What the code does:Many thanks to Tim Down\nSee this post for the answer:Get the pasted content on document on paste eventThis was too long for a comment on Nico\'s answer, which I don\'t think works on Firefox any more (per the comments), and didn\'t work for me on Safari as is.Firstly, you now appear to be able to read directly from the clipboard. Rather than code like:use:because Firefox has a types field which is a DOMStringList which does not implement test.Next Firefox will not allow paste unless the focus is in a contenteditable=true field.Finally, Firefox will not allow paste reliably unless the focus is in a textarea (or perhaps input) which is not only contenteditable=true but also:I was trying to hide the text field so I could make paste work over a JS VNC emulator (i.e. it was going to a remote client and there was no actually textarea etc to paste into). I found trying to hide the text field in the above gave symptoms where it worked sometimes, but typically failed on the second paste (or when the field was cleared to prevent pasting the same data twice) as the field lost focus and would not properly regain it despite focus(). The solution I came up with was to put it at z-order: -1000, make it display:none, make it as 1px by 1px, and set all the colours to transparent. Yuck.On Safari, you the second part of the above applies, i.e. you need to have a textarea which is not display:none.First that comes to mind is the pastehandler of google\'s closure lib\nhttp://closure-library.googlecode.com/svn/trunk/closure/goog/demos/pastehandler.htmlThis worked for me :This solution is replace the html tag, it\'s simple and cross-browser; check this jsfiddle: http://jsfiddle.net/tomwan/cbp1u2cx/1/, core code:notice: you should do some work about xss filter on the back side because this solution cannot filter strings like \'<<>>\'You can do this in this way:use this jQuery plugin for pre & post paste events:Now you can use this plugin;:ExplainationFirst set a uid for all existing elements as data attribute.Then compare all nodes POST PASTE event. So by comparing you can identify the newly inserted one because they will have a uid, then just remove style/class/id attribute from newly created elements, so that you can keep your older formatting.Just let the browser paste as usual in its content editable div and then after the paste swap any span elements used for custom text styles with the text itself.  This seems to work okay in internet explorer and the other browsers I tried...This solution assumes that you are running jQuery and that you don\'t want text formatting in any of your content editable divs.  The plus side is that it\'s super simple.This is an existing code posted above but I have updated it for IE\'s, the bug was when the existing text is selected and pasted will not delete the selected content. This has been fixed by the below codeSee complete code below