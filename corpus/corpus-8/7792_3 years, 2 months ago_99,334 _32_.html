When trying to register for push notifications under iOS 8.x:I get the following error:Any ideas what is the new way of doing it? It does work when I run this Swift app on iOS 7.x.EDITOn iOS 7.x when I include the conditional code I get (either SystemVersion conditional or #if __IPHONE_OS_VERSION_MAX_ALLOWED >= 80000)As you described, you will need to use a different method based on different versions of iOS. If your team is using both Xcode 5 (which doesn\'t know about any iOS 8 selectors) and Xcode 6 (currently in beta), then you will need to use conditional compiling as follows:If you are only using Xcode 6 (beta), you can stick with just this:The reason is here is that the way you get notification permissions has changed in iOS 8. A UserNotification is a message shown to the user, whether from remote or from local. You need to get permission to show one. This is described in the WWDC 2014 video "What\'s New in iOS Notifications"For iOS<10For iOS10https://stackoverflow.com/a/39383027/3560390Building on @Prasath\'s answer. This is how you do it in Swift:iOS 8 has changed notification registration in a non-backwards compatible way. While you need to support iOS 7 and 8 (and while apps built with the 8 SDK aren\'t accepted), you can check for the selectors you need and conditionally call them correctly for the running version.Here\'s a category on UIApplication that will hide this logic behind a clean interface for you that will work in both Xcode 5 and Xcode 6.Header:Implementation:For the Swift-inclined:I think this is the better way to keep backwards compatibility if we go with this approach, it is working for my case and hope will work for you. Also pretty easy to understand.I couldn\'t figure out what the "categories" NSSet variable should be set to, so if someone could fill me in I will gladly edit this post. The following does, however, bring up the push notification dialog.Edit: I got a push notification to send to my phone with this code, so I\'m not sure the categories parameter is necessary.So it turns out that because AnyObject is the spiritual successor to id, you can call any message you want on AnyObject. That\'s the equivalent of sending a message to id. Ok, fair enough. But now we add in the concept that all methods are optional on AnyObject, and we have something we can work with.Given the above, I was hopeful I could just cast UIApplication.sharedApplication() to AnyObject, then create a variable equal to the method signature, set that variable to the optional method, then test the variable. This didn\'t seem to work. My guess is that when compiled against the iOS 8.0 SDK, the compiler knows where it thinks that method should be, so it optimizes this all down to a memory lookup. Everything works fine until I try to test the variable, at which point I get a EXC_BAD_ACCESS.However, in the same WWDC talk where I found the gem about all methods being optional, they use Optional Chaining to call an optional method - and this seems to work. The lame part is that you have to actually attempt to call the method in order to know if it exists, which in the case of registering for notifications is a problem because you\'re trying to figure out if this method exists before you go creating a UIUserNotificationSettings object. It seems like calling that method with nil though is okay, so the solution that seems to be working for me is:After much searching related to this, the key info came from this WWDC talk https://developer.apple.com/videos/wwdc/2014/#407 right in the middle at the section about "Optional Methods in Protocols"In Xcode 6.1 beta the above code does not work anymore, the code below works:If you like to add support to IOS7 IOS8 you can apply this code into your project .After Xcode 6.1 Beta the code below works, slight edit on Tom S code that stopped working with the 6.1 beta (worked with previous beta):You can use thisSwift 2.0If all you need is the ios 8 code, this should do it. This is cleaner way I am doing and it just works greatfor iOS 8 and above