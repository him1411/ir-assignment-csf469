I\'m deleting several items from a table using Entity Framework. There isn\'t a foreign key / parent object so I can\'t handle this with OnDeleteCascade.Right now I\'m doing this:It works but the foreach bugs me. I\'m using EF4 but I don\'t want to execute SQL. I just want to make sure I\'m not missing anything - this is as good as it gets, right? I can abstract it with an extension method or helper, but somewhere we\'re still going to be doing a foreach, right?If you don\'t want to execute SQL directly calling DeleteObject in a loop is the best you can do today. However you can execute SQL and still make it completely general purpose via an extension method, using the approach I describe here.Although that answer was for 3.5. For 4.0 I would probably use the new ExecuteStoreCommand API under the hood, instead of dropping down to the StoreConnection.EntityFramework 6 has made this a bit easier with .RemoveRange().Example:this is as good as it gets, right? I can abstract it with an extension\n  method or helper, but somewhere we\'re still going to be doing a\n  foreach, right?Well, yes, except you can make it into a two-liner:I know it\'s quite late but in case someone need a simple solution, the cool thing is you can also add the where clause with it:Note: just tested with MSSQL2008.Update:\nThe solution above won\'t work when EF generates sql statement with parameters, so here\'s the update for EF5:It requires a little bit of Reflection but works well.For anyone using EF5, following extension library can be used: https://github.com/loresoft/EntityFramework.ExtendedEF 6.1Usage:For EF 4.1, If you want to delete all rows of a table, you can execute sql commandTRUNCATE TABLE (Transact-SQL) Removes all rows from a table without logging the individual row deletions. TRUNCATE TABLE is similar to the DELETE statement with no WHERE clause; however, TRUNCATE TABLE is faster and uses fewer system and transaction log resources.Still seems crazy to have to pull anything back from the server just to delete it, but at least getting back just the IDs is a lot leaner than pulling down the full entities:The quickest way to delete is using a stored procedure. I prefer stored procedures in a database project over dynamic SQL because renames will be handled correctly and have compiler errors. Dynamic SQL could refer to tables that have been deleted/renamed causing run time errors.In this example, I have two tables List and ListItems. I need a fast way to delete all the ListItems of a given list.Now the interesting part of deleting the items and updating Entity framework using an extension.The main code can now use it is asYou can also use the DeleteAllOnSubmit() method by passing it your results in a generic list rather than in  var. This way your foreach reduces to one line of code:It probably still uses a loop internally though.You can use extensions libraries for doing that like EntityFramework.Extended or Z.EntityFramework.Plus.EF6, there are available for EF 5, 6 or Core. These libraries have great performance when you have to delete or update and they use LINQ. Example for deleting (source plus):ctx.Users.Where(x => x.LastLoginDate < DateTime.Now.AddYears(-2))\n         .Delete();or (source extended)context.Users.Where(u => u.FirstName == "firstname")\n    .Delete();These use native SQL statements, so performance is great.EF 6.=>UUHHIVS\'s is a very elegant and fast way for batch delete, but it must be used with care:These issues can be circumvented by taking control of the transaction. The following code illustrates how to batch delete and bulk insert in a transactional manner:See the answer \'favorite bit of code\' that works Here is how I used it:You can execute sql queries directly as follows :For select we may useBest : in EF6 => .RemoveRange()Example: