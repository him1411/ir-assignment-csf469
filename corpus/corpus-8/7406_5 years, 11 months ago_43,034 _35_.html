I\'m trying to store in a std::tuple a varying number of values, which will later be used as arguments for a call to a function pointer which matches the stored types.I\'ve created a simplified example showing the problem I\'m struggling to solve:Normally for problems involving std::tuple or variadic templates I\'d write another template like template <typename Head, typename ...Tail> to recursively evaluate all of the types one by one, but I can\'t see a way of doing that for dispatching a function call.The real motivation for this is somewhat more complex and it\'s mostly just a learning exercise anyway. You can assume that I\'m handed the tuple by contract from another interface, so can\'t be changed but that the desire to unpack it into a function call is mine. This rules out using std::bind as a cheap way to sidestep the underlying problem.What\'s a clean way of dispatching the call using the std::tuple, or an alternative better way of achieving the same net result of storing/forwarding some values and a function pointer until an arbitrary future point?You need to build a parameter pack of numbers and unpack themThis is a complete compilable version of Johanne\'s solution to awoodland\'s question, in the hope it may be useful to somebody. This was tested with a snapshot of g++ 4.7 on Debian squeeze.One can use the following SConstruct fileOn my machine, this givesHere is a C++14 solution.This still needs one helper function (call_func). Since this is a common idiom, perhaps the standard should support it directly as std::call with possible implementationThen our delayed dispatch becomesThe C++17 solution is simply to use std::apply:Just felt that should be stated once in an answer in this thread (after it already appeared in one of the comments).The basic C++14 solution is still missing in this thread. EDIT: No, it\'s actually there in the answer of Walter.This function is given:Call it with the following snippet:Example:DEMOThis is a bit complicated to achieve (even though it is possible). I advise you to use a library where this is already implemented, namely Boost.Fusion (the invoke function). As a bonus, Boost Fusion works with C++03 compilers as well.Thinking about the problem some more based on the answer given I\'ve found another way of solving the same problem:Which requires changing the implementation of delayed_dispatch() to:This works by recursively converting the std::tuple into a parameter pack in its own right. call_or_recurse is needed as a specialization to terminate the recursion with the real call, which just unpacks the completed parameter pack.I\'m not sure this is in anyway a "better" solution, but it\'s another way of thinking about and solving it.As another alternative solution you can use enable_if, to form something arguably simpler than my previous solution:The first overload just takes one more argument from the tuple and puts it into a parameter pack. The second overload takes a matching parameter pack and then makes the real call, with the first overload being disabled in the one and only case where the second would be viable.c++14 solution.  First, some utility boilerplate:These let you call a lambda with a series of compile-time integers.and we are done.index_upto and index_over let you work with parameter packs without having to generate a new external overloads.Of course, in c++17 you justNow, if we like that, in c++14 we can write:relatively easily and get the cleaner c++17 syntax ready to ship.just replace notstd with std when your compiler upgrades and bob is your uncle.My variation of the solution from Johannes using the C++14 std::index_sequence (and function return type as template parameter RetT):