As far as I can tell, web workers need to be written in a separate JavaScript file, and called like this: I\'m using the closure compiler to combine and minify all my JavaScript source code, and I\'d rather not have to have my workers in separate files for distribution. Is there some way to do this?Given that first-class functions are so crucial to JavaScript, why does the standard way to do background work have to load a whole \'nother JavaScript file from the server?http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkersWhat if you want to create your worker script on the fly, or create a self-contained page without having to create separate worker files? With Blob(), you can "inline" your worker in the same HTML file as your main logic by creating a URL handle to the worker code as a stringThe html5rocks solution of embedding the web worker code in HTML is fairly horrible.\nAnd a blob of escaped JavaScript-as-a-string is no better, not least because it complicates work-flow (Closure compiler can\'t operate on strings).Personally I really like the toString methods, but @dan-man THAT regex!  My preferred approach:Support is the intersection of these three tables:This won\'t work for a SharedWorker however, because the URL must be an exact match, even if the optional \'name\' parameter matches. For a SharedWorker, you\'ll need a separate JavaScript file.Now there\'s an even more powerful way of solving this problem.\nAgain, store the worker code as a function, (rather than a static string) and convert using .toString(), then insert the code into CacheStorage under a static URL of your choice.There are two possible fall-backs. ObjectURL as above, or more seamlessly, put a real JavaScript file at /my_workers/worker1.jsAdvantages of this approach are:You can create a single JavaScript file that is aware of its execution context and can act as both a parent script and a worker. Let\'s start off with a basic structure for a file like this:As you can see, the script contains all code for both the parent\'s and the worker\'s point of view, checking if its own individual instance is a worker with !document. The somewhat unwieldy script_path computation is used to accurately calculate the script\'s path relative to the parent page, as the path supplied to new Worker is relative to the parent page, not the script.Using the Blob method, how about this for a worker factory:So you could use it like this...EDIT:I\'ve just extended this idea further to make it easier to do cross-thread communication: bridged-worker.js.EDIT 2: The above link is to a gist I created. Someone else later turned it into an actual repo.Web workers operate in entirely separate contexts as individual Program\'s.This means that code cannot be moved from one context to another in object form, as they would then be able to reference objects via closures belonging to the other context.\nThis is especially crucial as ECMAScript is designed to be a single threaded language, and since web workers operate in separate threads, you would then have the risk of non-thread-safe operations being performed. This again means that web workers need to be initialized with code in source form.The spec from WHATWG saysIf the origin of the resulting\n  absolute URL is not the same as the\n  origin of the entry script, then throw\n  a SECURITY_ERR exception.Thus, scripts must be external files\n  with the same scheme as the original\n  page: you can\'t load a script from a\n  data: URL or javascript: URL, and an\n  https: page couldn\'t start workers\n  using scripts with http: URLs.but unfortunately it doesn\'t really explain why one couldn\'t have allowed passing a string with source code to the constructor.a better to read way for a inline worker..Taking Adria\'s response and putting it in a copy-pastable function which works with current Chrome and FF but not IE10 (worker from blob causes a security error).And here\'s a working example http://jsfiddle.net/ubershmekel/YYzvr/Take a look at the vkThread plugin. With htis plugin you can take any function in your main code and execute it in a  thread (web worker). So, you don\'t need to create a special "web-worker file".http://www.eslinstructor.net/vkthread/--VadimDepending on your use case you can use something liketask.js Simplified interface for getting CPU intensive code to run on all cores (node.js, and web)A example would beYou can use web workers in same javascript fie using inline webworkers.The below article will address you to easily understand the webworkers and their limitations and debugging of webworkers.Mastering in webworkersTry to use jThread. https://github.com/cheprasov/jThreadhere console:https://developer.mozilla.org/es/docs/Web/Guide/Performance/Using_web_workersUse my tiny plugin https://github.com/zevero/worker-createSo I think we have another cool option for this now, thanks to template literals in ES6. That allows us to dispense with the extra worker function (and its weird scope) and just write the code that\'s intended for the worker as multiline text, much like the case where we were using  to store text, but without actually needing a document or DOM to do that in. Example: Here\'s a gist of the rest of that approach.Note that we can pull in any extra function dependencies we want into the worker just by collecting them into an array and running .toString on each of them to reduce them down into strings as well (should work as long as they are function declarations) and then just prepending that to the script string. That way we don\'t have to importScripts that we might already have bundled into the scope of the code we\'re writing.The only real downside to this particular version is that linters won\'t be able to lint the service worker code (since it\'s just a string), which is an advantage for the "separate worker function approach." This is just an addition to above - I have a nice templates for testing web workers in jsFiddle. Rather than Blob it uses jsFiddles ?js api:Normal web worker and shared worker templates are available.I think the better way to do this is using a Blob object, below you can see a simple example.I discovered that CodePen currently does not syntax-highlight inline <script> tags that are not type="text/javascript" (or which have no type attribute).So I devised a similar but slightly different solution using labeled blocks with break, which is the only way you can bail from a <script> tag without creating a wrapper function (which is unnecessary).