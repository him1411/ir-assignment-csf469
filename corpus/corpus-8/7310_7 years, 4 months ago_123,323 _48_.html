How do I break out a loop?How do I turn nested for loops into tail recursion?From Scala Talk at FOSDEM 2009 http://www.slideshare.net/Odersky/fosdem-2009-1013261\non the 22nd page:Break and continue\n  Scala does not have them. Why?\n  They are a bit imperative; better use many smaller functions\n  Issue how to interact with closures.\n  They are not needed!What is the explanation?You have three (or so) options to break out of loops.Suppose you want to sum numbers until the total is greater than 1000.  You tryexcept you want to stop when (sum > 1000).What to do?  There are several options.(1a) Use some construct that includes a conditional that you test.(warning--this depends on details of how the takeWhile test and the foreach are interleaved during evaluation, and probably shouldn\'t be used in practice!).(1b) Use tail recursion instead of a for loop, taking advantage of how easy it is to write a new method in Scala:(1c) Fall back to using a while loop(2) Throw an exception.(2a) In Scala 2.8+ this is already pre-packaged in scala.util.control.Breaks using syntax that looks a lot like your familiar old break from C/Java:(3) Put the code into a method and use return.This is intentionally made not-too-easy for at least three reasons I can think of.  First, in large code blocks, it\'s easy to overlook "continue" and "break" statements, or to think you\'re breaking out of more or less than you really are, or to need to break two loops which you can\'t do easily anyway--so the standard usage, while handy, has its problems, and thus you should try to structure your code a different way.  Second, Scala has all sorts of nestings that you probably don\'t even notice, so if you could break out of things, you\'d probably be surprised by where the code flow ended up (especially with closures).  Third, most of Scala\'s "loops" aren\'t actually normal loops--they\'re method calls that have their own loop, or they are recursion which may or may not actually be a loop--and although they act looplike, it\'s hard to come up with a consistent way to know what "break" and the like should do.  So, to be consistent, the wiser thing to do is not to have a "break" at all.Note: There are functional equivalents of all of these where you return the value of sum rather than mutate it in place.  These are more idiomatic Scala.  However, the logic remains the same.  (return becomes return x, etc.).This has changed in Scala 2.8 which has a mechanism for using breaks. You can now do the following:It is never a good idea to break out of a for loop. If you are using a for loop it means that you know how many times you want to  iterate. Use a while loop with 2 conditions. for exampleTo add Rex Kerr answer another way:(1c) You can also use a guard in your loop:Since there is no break in Scala yet, you could try to solve this problem with using a return-statement. Therefore you need to put your inner loop into a function, otherwise the return would skip the whole loop.Scala 2.8 however includes a way to breakhttp://www.scala-lang.org/api/rc/scala/util/control/Breaks.htmluse Break module\nhttp://www.tutorialspoint.com/scala/scala_break_statement.htmJust use a while loop:An approach that generates the values over a range as we iterate, up to a breaking condition, instead of generating first a whole range and then iterating over it, using Iterator, (inspired in @RexKerr use of Stream)Close to your solution would be this: The j-iteration is made without a new scope, and the product-generation as well as the condition are done in the for-statement (not a good expression - I don\'t find a better one). The condition is reversed which is pretty fast for that problem size - maybe you gain something with a break for larger loops. String.reverse implicitly converts to RichString, which is why I do 2 extra reverses. :) A more mathematical approach might be more elegant. Here is a tail recursive version. Compared to the for-comprehensions it is a bit cryptic, admittedly, but I\'d say its functional :)As you can see, the tr function is the counterpart of the outer for-comprehensions, and tr1 of the inner one. You\'re welcome if you know a way to optimize my version.Ironically the Scala break in scala.util.control.Breaks is an exception:The best advice is: DO NOT use break, continue and goto! IMO they are the same, bad practice and an evil source of all kind of problems (and hot discussions) and finally "considered be harmful". Code block structured, also in this example breaks are superfluous.\nOur Edsger W. Dijkstra\xe2\x80\xa0 wrote:The quality of programmers is a decreasing function of the density of go to statements in the programs they produce.The third-party breakable package is one possible alternativehttps://github.com/erikerlandson/breakableExample code:I got a situation like the code belowI am using a java lib and the mechanism is that ctx.read throw a Exception when it can find nothing.\nI was trapped in the situation that :I have to break the loop when a Exception was thrown, but scala.util.control.Breaks.break using Exception to break the loop ,and it was in the catch block thus it was caught.I got ugly way to solve this: do the loop for the first time and get the count of the real length. \nand use it for the second loop.take out break from Scala is not that good,when you are using some java libs.I am new to Scala, but how about this to avoid throwing exceptions and repeating methods:use it like this:if you don\xe2\x80\x99t want to break:Clever use of find method for collection will do the trick for you. 