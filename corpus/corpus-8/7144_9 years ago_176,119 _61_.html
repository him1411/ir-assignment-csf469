I need to execute a directory copy upon a user action, but the directories are quite large, so I would like to be able to perform such an action without the user being aware of the time it takes for the copy to complete.Any suggestions would be much appreciated.Assuming this is running on a Linux machine, I\'ve always handled it like this:This launches the command $cmd, redirects the command output to $outputfile, and writes the process id to $pidfile.That lets you easily monitor what the process is doing and if it\'s still running.Write the process as a server-side script in whatever language (php/bash/perl/etc) is handy and then call it from the process control functions in your php script.The function probably detects if standard io is used as the output stream and if it is then that will set the return value..if not then it ends I tested this quickly from the command line using "sleep 25s" as the command and it worked like a charm.(Answer found here)I\'d just like to add a very simple example for testing this functionality on Windows:Create the following two files and save them to a web directory:foreground.php:background.php:Give IUSR permission to write to the directory in which you created the above filesGive IUSR permission to READ and EXECUTE C:\\Windows\\System32\\cmd.exeHit foreground.php from a web browserThe following should be rendered to the browser w/the current timestamps and local resource # in the output array:You should see testoutput.php in the same directory as the above files were saved, and it should be emptyYou should see testprocesses.php in the same directory as the above files were saved, and it should contain the following text w/the current timestamps:You might want to try to append this to your commandeg.If you need to just do something in background without the PHP page waiting for it to complete, you could use another (background) PHP script that is "invoked" with wget command. This background PHP script will be executed with privileges, of course, as any other PHP script on your system.Here is an example on Windows using wget from gnuwin32 packages.The background code (file test-proc-bg.php) as an exmple ...The foreground script, the one invoking ...You must use the popen/pclose for this to work properly.The wget options:Well i found a bit faster and easier version to useand it works.You might try a queuing system like Resque. You then can generate a job, that processes the information and quite fast return with the "processing" image. With this approach you won\'t know when it is finished though.This solution is intended for larger scale applications, where you don\'t want your front machines to do the heavy lifting, so they can process user requests.\nTherefore it might or might not work with physical data like files and folders, but for processing more complicated logic or other asynchronous tasks (ie new registrations mails) it is nice to have and very scalable.Here is a function to launch a background process in PHP. Finally created one that actually works on Windows too, after a lot of reading and testing different approaches and parameters.Note 1: On windows, do not use /B parameter as suggested elsewhere. It forces process to run the same console window as start command itself, resulting in the process being processed synchronously. To run the process in a separate thread (asynchronously), do not use /B.Note 2: The empty double quotes after start "" are required if the command is a quoted path. start command interprets the first quoted parameter as window title.Can you arrange to fork off a separate process, and then run your copy in the background? It\'s been a while since I did any PHP, but the function pcntl-fork looks promising. Instead of initiating a background process, what about creating a trigger file and having a scheduler like cron or autosys periodically execute a script that looks for and acts on the trigger files? The triggers could contain instructions or even raw commands (better yet, just make it a shell script).If using PHP there is a much easier way to do this using pcntl_fork:http://www.php.net/manual/en/function.pcntl-fork.phpI am heavily using fast_cgi_finish_request()In combination with a closure and register_shutdown_function()Then register this closure to be executed before shutdown. Finally when the response was sent to the client you can close the connection to the client and continue working with the PHP process:The closure will be executed after fast_cgi_finish_request. The $message will not be visible at any time. And you can register as much closures as you want, but take care about script execution time. \nThis will only work if PHP is running as a Fast CGI module (was that right?!)Use this function to run your program in background. It cross-platform and fully customizable.Note that after command started, by default this function closes the stdin and stdout of running process. You can redirect process output into some file via $redirectStdout and $redirectStderr arguments.Note for windows users: there is no way to redirect stdout/stderr to nul device. Unfortunaly you cannot do it:So you should redirect stderr/stdin into valid file or your command should expect that is no stderr/stdout descriptor.Notes for *nix users:1) Use exec shell command if you want get actual PID:2) Use $stdin argument if you want to pass some data to the input of your program:PHP scripting is not like other desktop application developing language. In desktop application languages we can set daemon threads to run a background process but in PHP a process is occuring when user request for a page. However It is possible to set a background job using server\'s cron job functionality  which php script runs.For those of us using Windows, look at this:Reference: http://php.net/manual/en/function.exec.php#43917I too wrestled with getting a program to run in the background in\n  Windows while the script continues to execute.  This method unlike the\n  other solutions allows you to start any program minimized, maximized,\n  or with no window at all.  llbra@phpbrasil\'s solution does work but it\n  sometimes produces an unwanted window on the desktop when you really\n  want the task to run hidden.start Notepad.exe minimized in the background: start a shell command invisible in the background: start MSPaint maximized and wait for you to close it before continuing the script: For more info on the Run() method go to: \nhttp://msdn.microsoft.com/library/en-us/script56/html/wsMthRun.aspI know it is a 100 year old post, but anyway, thought it might be useful to someone. You can put an invisible image somewhere on the page pointing to the url that needs to run in the background, like this:<img src="run-in-background.php" border="0" alt="" width="1" height="1" />