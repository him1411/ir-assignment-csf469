What is the difference between the below code snippets? Won\'t both be using threadpool threads?For instance if I want to call a function for each item in a collection,The first is a much better option.Parallel.ForEach, internally, uses a Partitioner<T> to distribute your collection into work items.  It will not do one task per item, but rather batch this to lower the overhead involved.The second option will schedule a single Task per item in your collection.  While the results will be (nearly) the same, this will introduce far more overhead than necessary, especially for large collections, and cause the overall runtimes to be slower.FYI - The Partitioner used can be controlled by using the appropriate overloads to Parallel.ForEach, if so desired.  For details, see Custom Partitioners on MSDN.The main difference, at runtime, is the second will act asynchronous.  This can be duplicated using Parallel.ForEach by doing:By doing this, you still take advantage of the partitioners, but don\'t block until the operation is complete.I did a small experiment of running a method "1000000000" times with "Parallel.For" and one with "Task" objects. I measured the processor time and found Parallel more efficient. Parallel.For divides your task in to small work items and executes them on all the cores parallely in a optimal way. While creating lot of task objects ( FYI TPL will use thread pooling internally) will move every execution on each task creating more stress in the box which is evident from the experiment below. I have also created a small video which explains basic TPL and also demonstrated how Parallel.For utilizes your core more efficiently http://www.youtube.com/watch?v=No7QqSc5cl8 as compared to normal tasks and threads.Experiment 1Experiment 2Parallel.ForEach will optimize(may not even start new threads) and block until the loop is finished, and Task.Factory will explicitly create a new task instance for each item, and return before they are finished (asynchronous tasks).\nParallel.Foreach is much more efficient.