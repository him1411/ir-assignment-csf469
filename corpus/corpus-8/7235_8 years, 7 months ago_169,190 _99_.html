After a lot of trial and error, I\'m giving up and asking the question. I\'ve seen a lot of people with similar problems but can\'t get all the answers to work right.I have a UITableView which is composed of custom cells. The cells are made of 5 text fields next to each other (sort of like a grid).When I try to scroll and edit the cells at the bottom of the UITableView, I can\'t manage to get my cells properly positioned above the keyboard.I have seen many answers talking about changing view sizes,etc... but none of them has worked nicely so far.Could anybody clarify the "right" way to do this with a concrete code example?If you use UITableViewController instead of UIViewController, it will automatically do so.The function that does the scrolling could be much simpler:That\'s it. No calculations at all.I\'m doing something very similar it\'s generic, no need to compute something specific for your code.\nJust check the remarks on the code:In MyUIViewController.hIn MyUIViewController.mI had the same problem but noticed that it appears only in one view. So I began to look for the differences in the controllers.I found out that the scrolling behavior is set in - (void)viewWillAppear:(BOOL)animated of the super instance.So be sure to implement like this:And it doesn\'t matter if you use UIViewController or UITableViewController; checked it by putting a UITableView as a subview of self.view in the UIViewController. It was the same behavior. The view didn\'t allow to scroll if the call [super viewWillAppear:animated]; was missing.I think I\'ve come up with the solution to match the behaviour of Apple\'s apps.First, in your viewWillAppear: subscribe to the keyboard notifications, so you know when the keyboard will show and hide, and the system will tell you the size of the keyboard, but dont\' forget to unregister in your viewWillDisappear:.Implement the methods similar to the below so that you adjust the size of your tableView to match the visible area once the keyboard shows. Here I\'m tracking the state of the keyboard separately so I can choose when to set the tableView back to full height myself, since you get these notifications on every field change. Don\'t forget to implement keyboardWillHide: and choose somewhere appropriate to fix your tableView size.Now here\'s the scrolling bit, we work out a few sizes first, then we see where we are in the visible area, and set the rect we want to scroll to to be either the half view above or below the middle of the text field based on where it is in the view. In this case, we have an array of UITextFields and an enum that keeps track of them, so multiplying the rowHeight by the row number gives us the actual offset of the frame within this outer view.This seems to work quite nicely.i may have missed this, as i didn\'t read the whole post here, but what i came up with seems deceptively simple.  i haven\'t put this through the wringer, testing in all situations, but it seems like it should work just fine.simply adjust the contentInset of the tableview by the height of the keyboard, and then scroll the cell to the bottom:and of courseis this too simple?  am i missing something?  so far it is working for me fine, but as i said, i haven\'t put it through the wringer...If you can use UITableViewController, you get the functionality for free. Sometimes, however, this is not an option, specifically if you need multiple views not just the UITableView.Some of the solutions presented here don\'t work on iOS \xe2\x89\xa54, some don\'t work on iPad or in landscape mode, some don\'t work for Bluetooth keyboards (where we don\'t want any scrolling), some don\'t work when switching between multiple text fields. So if you choose any solution, make sure to test these cases. This is the solution we use used in InAppSettingsKit:Here\'s the full code of the class in InAppSettingsKit. To test it, use the "Complete List" child pane where you can test the scenarios mentioned above.The simplest solution for Swift 3, based on Bart\xc5\x82omiej Sema\xc5\x84czyk solution:The simplest solution for Swift:Combining and filling in the blanks from several answers (in particular Ortwin Gentz, user 98013) and another post, this will work out of the box for SDK 4.3 on an iPad in Portrait or Landscape mode:  I hope you guys already got a solution reading all those. But I found my solution as follows. I am expecting that you already have a cell with UITextField. So on preparing just keep the row index into the text field\'s tag.Create an activeTextField, instance of UITextField with global scope as below: So, now you just copy paste my code at the end. And also don\'t forget to add UITextFieldDelegateRegisters keyboard notificationsHandles Keyboard Notifications:Called when the UIKeyboardDidShowNotification is sent.Called when the UIKeyboardWillHideNotification is sentNow one thing is left, Call the registerForKeyboardNotifications method in to ViewDidLoad method as follows:You are done, hope your textFields will no longer hidden by the keyboard.THE RIGHT ANSWER is Sam Ho\'s answer:"If you use UITableViewController instead of UIViewController, it will automatically do so.".Just make sure to connect your UITableView to the TableView property of the UITableViewController (so e.g. do not add it as a subview of the View property of the UITableViewController).Also make sure to set the AutoresizingMask property of your UITableView to FlexibleHeightMy approach:I first subclass UITextField and add an indexPath property. In the cellFor... Method i hand over the indexPath property.Then I add following code:to the textFieldShould/WillBegin...etc.When the Keyboard disappears you have to reverse it with:Keyboard notifications work, but Apple\'s sample code for that assumes that the scroll view is the root view of the window. This is usually not the case. You have to compensate for tab bars, etc., to get the right offset.It is easier than it sounds. Here is the code I use in a UITableViewController. It has two instance variables, hiddenRect and keyboardShown.If you use Three20, then use the autoresizesForKeyboard property. Just set in the your view controller\'s -initWithNibName:bundle methodThis takes care of:Done and done.Use UITextField\'s delegate method :If you use a uitableview to place your textfields (from Jeff Lamarche), you can just scroll the tableview using the delegate method like so.  (Note: my text fields are stored in an array with the same index as there row in the tableview)A more stream-lined solution.  It slips into the UITextField delegate methods, so it doesn\'t require messing w/ UIKeyboard notifications.Implementation notes:kSettingsRowHeight -- the height of a UITableViewCell.offsetTarget and offsetThreshold are baed off of kSettingsRowHeight.  If you use a different row height, set those values to point\'s y property.  [alt: calculate the row offset in a different manner.]}}I ran into something like your problem (I wanted a screen similar to the iPhone\'s settings.app with a bunch of editable cells stacked on on top of another) and found that this approach worked well:sliding uitextfields around to avoidSince you have textfields in a table, the best way really is to resize the table - you need to set the tableView.frame to be smaller in height by the size of the keyboard (I think around 165 pixels) and then expand it again when the keyboard is dismissed.You can optionally also disable user interaction for the tableView at that time as well, if you do not want the user scrolling.This soluton works for me, PLEASE note the lineYou can change the 160 value to match it work with youVery interesting discussion thread, i also faced the same problem may be worse one becauseSo read the threads here and implemented my version, which helped me in pushing up my contents in iPad in landscape mode.\nHere is code ( this is not fool proof and all, but it fixed my issue)\nFirst u need to have a delegate in your custom cell class, which on editing begins, sends the textfield to ur viewcontroller and set the activefield = theTextField there// IMPLEMENTED TO HANDLE LANDSCAPE MODE ONLY// Called when the UIKeyboardWillHideNotification is sent-anoop4realAn example in Swift, using the exact point of the text field from  Get indexPath of UITextField in UITableViewCell with Swift:This works perfectly, and on iPad too.So after hours of grueling work trying to use these current solutions (and utterly failing) I finally got things working well, and updated them to use the new animation blocks. My answer is entirely based on Ortwin\'s answer above.So for whatever reason the code above was just not working for me. My setup seemed fairly similar to others, but maybe because I was on an iPad or 4.3... no idea. It was doing some wacky math and shooting my tableview off the screen.See end result of my solution: http://screencast.com/t/hjBCuRrPC  (Please ignore the photo. :-P)So I went with the gist of what Ortwin was doing, but changed how it was doing some math to add up the origin.y & size.height of my table view with the height of the keyboard. When I subtract the height of the window from that result , it tells me how much intersection I have going on. If its greater than 0 (aka there is some overlap) I perform the animation of the frame height. In addition there were some redraw issues that were solved by 1) Waiting to scroll to the cell until the animation was done and 2) using the UIViewAnimationOptionBeginFromCurrentState option when hiding the keyboard.A couple things to note. Again, I wouldn\'t have gotten near this answer if I Ortwin didn\'t provide the crux of it. Here\'s the code:Another easy method (only works with one section)If your UITableView is managed by a subclass of UITableViewController and not UITableView, and the text field delegate is the UITableViewController, it should manage all the scrolling automatically -- all these other comments are very difficult to implement in practice.For a good example see the apple example code project: TaggedLocations.You can see that it scrolls automatically, but there doesn\'t seem to be any code that does this.  This project also has custom table view cells, so if you build your application with it as a guide, you should get the desired result.Here is how I made this work, which is a mixture of Sam Ho and Marcel W\'s answers, and some of my own bug fixes made to my crappy code.  I was using a UITableViewController.  The table now resizes correctly when the keyboard is shown.1) In viewDidLoad I added:self.tableView.autoresizingMask = UIViewAutoresizingFlexibleHeight;2) I had forgotten to call the super equivalents in viewWillAppear and awakeFromNib.  I added these back in.I have just solved such a problem by myself after I referred a mass of solutions found via Google and Stack Overflow.First, please assure that you have set up an IBOutlet of your UIScrollView,\nThen please take a close look at Apple Doc: Keyboard Management.\nFinally, if you can scroll the background, but the keyboard still covers the Text Fields, please have a look at this piece of code:The main difference between this piece and Apple\'s lies in the if condition. I believe apple\'s calculation of scroll distance and condition of whether text field covered by keyboard are not accurate, so I made my modification as above.Let me know if it worksEasy and fast solution.I just scroll to the right cell whenever scrolling happens Assuming I know table now is in this mode "_keepMyCellOnTop"\n& I know selected cell "_selectedCellIndex" or scroll to selected cellThis will prevent scrolling.Placing the code in -(void) scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView\n will result a scroll up and down 