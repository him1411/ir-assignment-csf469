Whenever I pull from my remote, I get the following error about compression. When I run the manual compression, I get the same:Does anyone know, what to do about that?From cat-file I get this: And from git fsck I get this ( don\'t know if it\'s actually related):Can anyone help me decipher this?Looks like you have a corrupt tree object. You will need to get that object from someone else. Hopefully they will have an uncorrupted version.You could actually reconstruct it if you can\'t find a valid version from someone else by guessing at what files should be there. You may want to see if the dates & times of the objects match up to it. Those could be the related blobs. You could infer the structure of the tree object from those objects.Take a look at Scott Chacon\'s Git Screencasts regarding git internals. This will show you how git works under the hood and how to go about doing this detective work if you are really stuck and can\'t get that object from someone else.I had the same problem (don\'t know why).This fix requires access to an uncorrupted remote copy of the repository, and will keep your locally working copy intact.But it has some drawbacks:Execute these commands from the parent directory above your repo (replace \'foo\' with the name of your project folder):On Windows you will need to use:Now foo has its original .git subdirectory back, but all the local changes are still there. git status, commit, pull, push, etc. work again as they should.Your best bet is probably to simply re-clone from the remote repo (ie. Github or other).  Unfortunately you will lose any unpushed commits and stashed changes, however your working copy should remain intact.First make a backup copy of your local files.  Then do this from the root of your working tree:Then commit any changed files as necessary.My computer crashed while I was writing a commit message. After rebooting, the working tree was as I had left it and I was able to successfully commit my changes.However, when I tried to run git status I gotUnlike most of the other answers, I wasn\'t trying to recover any data. I just needed Git to stop complaining about the empty object file.The "object file" is git\'s hashed representation of a real file that you care about. Git thinks it should have a hashed version of some/file.whatever stored in .git/object/xx/12345, and fixing the error turned out to be mostly a matter of figuring out which file the "loose object" was supposed to represent.Possible options seemed to beThe first thing I tried was just moving the object fileThat didn\'t work - git began complaining about a broken link. On to Approach 2.Linus Torvalds has a great writeup of how to recover an object file that solved the problem for me. Key steps are summarized here.This tells you what file the empty object is supposed to be a hash of. Now you can repair it.After doing this I checked .git/objects/xx/12345, it was no longer empty, and git stopped complaining.Working on a VM, in my notebook, battery died, got this error;error: object file .git/objects/ce/theRef is empty error: object\n  file .git/objects/ce/theRef is empty fatal: loose object theRef \n  (stored in .git/objects/ce/theRef) is corruptI managed to get the repo working again with only 2 commands and without losing my work (modified files/uncommitted changes)After that I ran a git status, the repo was fine and there were my changes (waiting to be committed, do it now..).git version 1.9.1Remember to backup all changes you remember, just in case this solution doesn\'t works and a more radical approach is needed.TryThis worked for me.  It stashes anything you haven\'t committed and that got around the problem.In answer of @user1055643 missing the last step:I just experienced this - my machine crashed whilst writing to the Git repo, and it became corrupted. I fixed it as follows.I started with looking at how many commits I had not pushed to the remote repo, thus:If you don\'t use this tool it is very handy - available on all operating systems as far as I know. This indicated that my remote was missing two commits. I therefore clicked on the label indicating the latest remote commit (usually this will be /remotes/origin/master) to get the hash (the hash is 40 chars long, but for brevity I am using 10 here - this usually works anyway).Here it is:14c0fcc9b3I then click on the following commit (i.e. the first one that the remote does not have) and get the hash there:04d44c3298I then use both of these to make a patch for this commit:I then did likewise with the other missing commit, i.e. I used the hash of the commit before and the hash of the commit itself:I then moved to a new directory, cloned the repo from the remote:I then moved the patch files into the new folder, and applied them and committed them with their exact commit messages (these can be pasted from git log or the gitk window):This restored things for me (and note there\'s probably a faster way to do it for a large number of commits). However I was keen to see if the tree in the corrupted repo can be repaired, and the answer is it can. With a repaired repo available as above, run this command in the broken folder:You will get something like this:To do the repair, I would do this in the broken folder:i.e. remove the corrupted file and replace it with a good one. You may have to do this several times. Finally there will be a point where you can run fsck without errors. You will probably have "dangling commit" and "dangling blob" lines in the report, these are a consequence of your rebases and amends in this folder, and are OK. The garbage collector will remove them in due course.Thus (at least in my case) a corrupted tree does not mean unpushed commits are lost.I was getting a corrupt loose object error as well.I successfully fixed it by going into the directory of the corrupt object. I saw that the users assigned to that object was not my git user\'s. I don\'t know how it happened, but I ran a chown git:git on that file and then it worked again.This may be a potential fix for some peoples\' issues but not necessary all of them.A garbage collection fixed my problem:Takes a while to complete, but every loose object and/or corrupted index was fixed.I got this error after my (windows) machine decided to reboot itself.\nThankfully my remote repo was up to date so I just did a fresh git-clone..I followed many of the other steps here; Linus\' description of how to look at the git tree/objects and find what\'s missing was especially helpful. git-git recover corrupted blobBut in the end, for me, I had loose/corrupt tree objects caused by a partial disk failure, and tree objects are not so easily recovered/not covered by that doc.In the end, I moved the conflicting objects/<ha>/<hash> out of the way, and used git unpack-objects with a pack file from a reasonably up to date clone. It was able to restore the missing tree objects.Still left me with a lot of dangling blobs, which can be a side effect of unpacking previously archived stuff, and addressed in other questions hereRunnning git stash; git stash pop fixed my problemTo me this happened due to a power failure while doing a git push.The messages looked like this:I tried things like git fsck but that didn\'t help.\nSince the crash happened during a git push, it obviously happened during rewrite on the client side which happens after the server is updated. I looked around and figured that c2388 in my case was a commit object, because it was referred to by entries in .git/refs. So I knew that I would be able to find c2388 when I look at the history (through a web interface or second clone).On the second clone I did a git log -n 2 c2388 to identify the predecessor of c2388. Then I manually modified .git/refs/heads/master and .git/refs/remotes/origin/master to be the predecessor of c2388 instead of c2388.\nThen I could do a git fetch.\nThe git fetch failed a few times for conflicts on empty objects. I removed each of these empty objects until git fetch succeeded. That has healed the repository.I solved this way:\nI decided to simply copy the uncorrupted object file from the backup\'s clone to my original repository. This worked just as well. (By the way: If you can\'t find the object in .git/objects/ by its name, it probably has been [packed][pack] to conserve space.)I had this same problem in my bare remote git repo. After much troubleshooting, I figured out one of my coworkers had made a commit in which some files in .git/objects had permissions of 440 (r--r-----) instead of 444 (r--r--r--). After asking the coworker to change the permissions with "chmod 444 -R objects" inside the bare git repo, the problem was fixed.We just had the case here. It happened that the problem was the ownership of the corrupt file was root instead of our normal user. This was caused by a commit done on the server after someone has done a "sudo su --".First, identify your corrupt file with:You should receive a answer like this one:Go in the folder where the corrupt file is and do a:Check the ownership of the corrupt file. If that\'s different, just go back to the root of your repo and do a:Hope it helps!I just had a problem like this. My particular problem was caused by a system crash that corrupted the most recent commit (and hence also the master branch). I hadn\'t pushed, and wanted to re-make that commit. In my particular case, I was able to deal with it like this:That worked for for me. I suspect that this is a reasonably common scenario, since the most recent commit is the most likely one to be corrupted, but if you lose one further back, you can probably still use a method like this, with careful use of git cherrypick, and the reflog in .git/logs/HEAD.Just remove .git folder and add it again. This simple solution worked for me.