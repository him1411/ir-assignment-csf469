What is the purpose of a command that does nothing, being little more than a comment leader, but is actually a shell builtin in and of itself?It\'s slower than inserting a comment into your scripts by about 40% per call, which probably varies greatly depending on the size of the comment. The only possible reasons I can see for it are these:I guess what I\'m really looking for is what historical application it might have had.Historically, Bourne shells didn\'t have true and false as built-in commands. true was instead simply aliased to :, and false to something like let 0.: is slightly better than true for portability to ancient Bourne-derived shells. As a simple example, consider having neither the ! pipeline operator nor the || list operator (as was the case for some ancient Bourne shells). This leaves the else clause of the if statement as the only means for branching based on exit status:Since if requires a non-empty then clause and comments don\'t count as non-empty, : serves as a no-op.Nowadays (that is: in a modern context) you can usually use either : or true. Both are specified by POSIX, and some find true easier to read. However there is one interesting difference: : is a so-called POSIX special built-in, whereas true is a regular built-in.Special built-ins are required to be built into the shell; Regular built-ins are only "typically" built in, but it isn\'t strictly guaranteed. There usually shouldn\'t be a regular program named : with the function of true in PATH of most systems.Probably the most crucial difference is that with special built-ins, any variable set by the built-in - even in the environment during simple command evaluation - persists after the command completes, as demonstrated here using ksh93:Note that Zsh ignores this requirement, as does GNU Bash except when operating in POSIX compatibility mode, but all other major "POSIX sh derived" shells observe this including dash, ksh93, and mksh.Another difference is that regular built-ins must be compatible with exec - demonstrated here using Bash:POSIX also explicitly notes that : may be faster than true, though  this is of course an implementation-specific detail.I use it to easily enable/disable variable commands:ThusThis makes for a clean script. This cannot be done with \'#\'.Also,is one of the simplest ways to guarantee that \'afile\' exists but is 0 length.A useful application for : is if you\'re only interested in using parameter expansions for their side-effects rather than actually  passing their result to a command. In that case you use the PE as an argument to either : or false depending upon whether you want an exit status of 0 or 1. An example might be : "${var:=$1}". Since : is a builtin it should be pretty fast.: can also be for block comment (similar to /* */ in C language). For example, if you want to skip a block of code in your script, you can do this:If you\'d like to truncate a file to zero bytes, useful for clearing logs, try this:It\'s similar to pass in Python.One use would be to stub out a function until it gets written:Two more uses not mentioned in other answers:Take this example script:The first line, set -x, makes the shell print out the command before running it. It\'s quite a useful construct. The downside is that the usual echo Log message type of statement now prints the message twice. The colon method gets round that. Note that you\'ll still have to escape special characters just like you would for echo.I\'ve seen it being used in cron jobs, like this:This is a cron job that runs the script /opt/backup.sh every day at 10:45. The advantage of this technique is that it makes for better looking email subjects when the /opt/backup.sh prints some output.You could use it in conjunction with backticks (``) to execute a command without displaying its output, like this:Of course you could just do some_command > /dev/null, but the :-version is somewhat shorter.That being said I wouldn\'t recommend actually doing that as it would just confuse people. It just came to mind as a possible use-case.It\'s also useful for polyglot programs:This is now both an executable shell-script and a JavaScript program: meaning ./filename.js, sh filename.js, and node filename.js all work.(Definitely a little bit of a strange usage, but effective nonetheless.)Some explication, as requested:Shell-scripts are evaluated line-by-line; and the exec command, when run, terminates the shell and replaces it\'s process with the resultant command. This means that to the shell, the program looks like this:As long as no parameter expansion or aliasing is occurring in the word, any word in a shell-script can be wrapped in quotes without changing its\' meaning; this means that \':\' is equivalent to : (we\'ve only wrapped it in quotes here to achieve the JavaScript semantics described below)... and as described above, the first command on the first line is a no-op (it translates to : //, or if you prefer to quote the words, \':\' \'//\'. Notice that the // carries no special meaning here, as it does in JavaScript; it\'s just a meaningless word that\'s being thrown away.)Finally, the second command on the first line (after the semicolon), is the real meat of the program: it\'s the exec call which replaces the shell-script being invoked, with a Node.js process invoked to evaluate the rest of the script.Meanwhile, the first line, in JavaScript, parses as a string-literal (\':\'), and then a comment, which is deleted; thus, to JavaScript, the program looks like this:Since the string-literal is on a line by itself, it is a no-op statement, and is thus stripped from the program; that means that the entire line is removed, leaving only your program-code (in this example, the function(){ ... } body.)You can also use : to embed documentation in a function.Assume you have a library script mylib.sh, providing a variety of functions. You could either source the library (. mylib.sh) and call the functions directly after that (lib_function1 arg1 arg2), or avoid cluttering your namespace and invoke the library with a function argument (mylib.sh lib_function1 arg1 arg2).Wouldn\'t it be nice if you could also type mylib.sh --help and get a list of available functions and their usage, without having to manually maintain the function list in the help text?A few comments about the code:I saw this usage in a script and thought it was a good substitute for invoking basename within a script....\nthis is a replacement for the code: basetool=$(basename $0)