User kokos answered the wonderful Hidden Features of C# question by mentioning the using keyword.  Can you elaborate on that?  What are good uses of using?The reason for the "using" statement is to ensure that the object is disposed as soon as it goes out of scope, and it doesn\'t require explicit code to ensure that this happens.As per http://www.codeproject.com/KB/cs/tinguusingstatement.aspx, the .NET CLR convertstoSince a lot of people still do:I guess a lot of people still don\'t know that you can do:Things like this:This SqlConnection will be closed without needing to explicitly call the .Close() function, and this will happen even if an exception is thrown, without the need for a try/catch/finally.using can be used to call IDisposable.  It can also be used to alias types.using, in the sense ofIs actually shorthand for a try/finally block. It is equivalent to the code:You\'ll note, of course, that the first snippet is much more concise than the second and also that there are many kinds of things that you might want to do as cleanup even if an exception is thrown. Because of this, we\'ve come up with a class that we call Scope that allows you to execute arbitrary code in the Dispose method. So, for example, if you had a property called IsWorking that you always wanted to set to false after trying to perform an operation, you\'d do it like this:You can read more about our solution and how we derived it here.I\'ve used it a lot in the past to work with input and output streams.  You can nest them nicely and it takes away a lot of the potential problems you usually run into (by automatically calling dispose).  For example:Microsoft documentation states that using has a double function (https://msdn.microsoft.com/en-us/library/zhdeatwt.aspx), both as a directive and in statements. As a statement, as it was pointed out here in other answers, the keyword is basically syntactic sugar to determine a scope to dispose an IDisposable object. As a directive, it is routinely used to import namespaces and types. Also as a directive, you can create aliases for namespaces and types, as pointed out in the book "C# 5.0 In a Nutshell: The Definitive Guide" (http://www.amazon.com/5-0-Nutshell-The-Definitive-Reference-ebook/dp/B008E6I1K8),  by Joseph and Ben Albahari. One example:This is something to adopt wisely, since the abuse of this practice can hurt the clarity of one\'s code. There is a nice explanation on C# aliases, also mentioning pros and cons, in DotNetPearls (http://www.dotnetperls.com/using-alias).Another great use of using is when instantiating a modal dialog.Using frm as new Form1Form1.ShowDialog\' do stuff here"End Using"Interestingly, you can also use the using/IDisposable pattern for other interesting things (such as the other point of the way that Rhino Mocks uses it).  Basically, you can take advantage of the fact that the compiler will always call .Dispose on the "used" object.  If you have something that needs to happen after a certain operation ... something that has a definite start and end ... then you can simply make an IDisposable class that starts the operation in the constructor, and then finishes in the Dispose method.This allows you to use the really nice using syntax to denote the explicit start and end of said operation.  This is also how the System.Transactions stuff works.In conclusion, when you use a local variable of a type that implements IDisposable, always, without exception, use using1.If you use nonlocal IDisposable variables, then always implement the IDisposable pattern.Two simple rules, no exception1. Preventing resource leaks otherwise is a real pain in the *ss.1): The only exception is \xe2\x80\x93\xc2\xa0when you\'re handling exceptions. It might then be less code to call Dispose explicitly in the finally block.You can make use of the alias namespace by way of the following example:This is called a using alias directive as as you can see, it can be used to hide long-winded references should you want to make it obvious in your code what you are referring to\ne.g.instead ofor simplyJust adding a little something that I was surprised did not come up. The most interesting feature of using (in my opinion) is that no mater how you exit the using block, it will always dispose the object. This includes returns and exceptions.It doesn\'t matter if the exception is thrown or the list is returned. The DbContext object will always be disposed.When using ADO.NET you can use the keywork for things like your connection object or reader object. That way when the code block completes it will automatically dispose of your connection."using" can also be used to resolve name space conflicts. See http://www.davidarno.org/c-howtos/aliases-overcoming-name-conflicts/ for a short tutorial I wrote on the subject.RhinoMocks makes an intersting use for using.using is used when you have a resource that you want disposed after it\'s been used.For instance if you allocate a File resource and only need to use it in one section of code for a little reading or writing, using is helpful for disposing of the File resource as soon as your done.The resource being used needs to implement IDisposable to work properly.Example:The using keyword defines the scope for the object and then disposes of the object when the scope is complete.  For example.See here for the MSDN article on the C# using keyword.Not that it is ultra important, but using can also be used to change resources on the fly. Yes disposable as mentioned earlier, but perhaps specifically you don\'t want the resources they mismatch with other resources during the rest of your execution. So you want to dispose of it so it doesn\'t interfere elsewhere.Thanks to the comments below, I will clean this post up a bit (I shouldn\'t have used the words \'garbage collection\' at the time, apologies): \nWhen you use using, it will call the Dispose() method on the object at the end of the using\'s scope.  So you can have quite a bit of great cleanup code in your Dispose() method.  \nA bullet point here which will hopefully maybe get this un-markeddown: If you implement IDisposable, make sure you call GC.SuppressFinalize() in your Dispose() implementation, as otherwise automatic garbage collection will try to come along and Finalize it at some point, which at the least would be a waste of resources if you\'ve already Dispose()d of it.Another example of a reasonable use in which the object is immediately disposed:Everything outside the curly brackets is disposed, so it is great to dispose your objects if you are not using them. This is so because if you have a SqlDataAdapter object and you are using it only once in the application life cycle and you are filling just one dataset and you don\'t need it anymore, you can use the code:The using statement provides a convenience mechanism to correctly use IDisposable objects. As a rule, when you use an IDisposable object, you should declare and instantiate it in a using statement. The using statement calls the Dispose method on the object in the correct way, and (when you use it as shown earlier) it also causes the object itself to go out of scope as soon as Dispose is called. Within the using block, the object is read-only and cannot be modified or reassigned.This comes from: hereFor me the name "using" is a little bit confusing, because is can be a directive to import a Namespace or a statement (like the one discussed here) for error handling.A different name for error handling would\'ve been nice, and maybe a somehow more obvious one.It also can be used for creating scopes for Example:Using Clause is used to define the scope for the particular variable. \nFor example: