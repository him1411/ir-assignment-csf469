I have base64-encoded binary data in a string.I would like to create  a blob: URL containing this data and display it to the user.I haven\'t been been able to figure out how to create the Blob.In some cases I am able to avoid this by using a data: URL instead.However in most cases the data: URLs are prohibitively large.How can I decode a base64 string to a Blob object in JavaScript?The function described below is available on NPM: var b64toBlob = require(\'b64-to-blob\')The atob function will decode a base64-encoded string into a new string with a character for each byte of the binary data.Each character\'s code point (charCode) will be the value of the byte. We can create an array of byte values by applying this using the .charCodeAt method for each character in the string.You can convert this array of byte values into a real typed byte array by passing it to the Uint8Array constructor.This in turn can be converted to a Blob by wrapping it in an array passing it to the Blob constructor. The code above works. However the performance can be improved a little by processing the byteCharacters in smaller slices, rather than all at once. In my rough testing 512 bytes seems to be a good slice size. This gives us the following function.Couldn\'t avoid not posting the minimalistic method without dependency or libraries.\nIt requires the new fetch API. Can I use it?With this method you can also easily get arraybuffer, text and jsonI did a simple performance test towards Jeremy\'s es6 sync version.\nThe sync version will block UI for a while.Optimized (but less readable) implementation:For all browser support, especially on android.\nPerhaps you can add thisFor image data, I find it simpler to use canvas.toBlob (asynchronous)See this example: https://jsfiddle.net/pqhdce2L/ I noticed, that Internet Explorer 11 gets incredibly slow when slicing the data like jeremy suggested. This is true for Chrome, but IE seems to have a problem when passing the sliced data to the Blob-Constructor. On my machine, passing 5 MB of data makes IE crash and memory consumption is going through the roof. Chrome creates the blob in no time. Run this code for a comparism:So I decided to include both methods described by jeremy in one function. Credits go to him for this.