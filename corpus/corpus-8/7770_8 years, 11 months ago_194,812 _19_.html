If I do the following:I get:Apparently a cStringIO.StringIO object doesn\'t quack close enough to a file duck to suit subprocess.Popen.  How do I work around this?Popen.communicate() documentation:Note that if you want to send data to\n  the process\xe2\x80\x99s stdin, you need to\n  create the Popen object with\n  stdin=PIPE. Similarly, to get anything\n  other than None in the result tuple,\n  you need to give stdout=PIPE and/or\n  stderr=PIPE too.Replacing os.popen*Warning Use communicate() rather than\n  stdin.write(), stdout.read() or\n  stderr.read() to avoid deadlocks due\n  to any of the other OS pipe buffers\n  filling up and blocking the child\n  process.So your example could be written as follows:On the current Python 3 version, you could use subprocess.run, to pass input as a string to an external command and get its exit status, and its output as a string back in one call:I figured out this workaround:Is there a better one?I\'m a bit surprised nobody suggested creating a pipe, which is in my opinion the far simplest way to pass a string to stdin of a subprocess:I am using python3 and found out that you need to encode your string before you can pass it into stdin:"Apparently a cStringIO.StringIO object doesn\'t quack close enough to a file duck to suit subprocess.Popen":-)I\'m afraid not.  The pipe is a low-level OS concept, so it absolutely requires a file object that is represented by an OS-level file descriptor.  Your workaround is the right one.There\'s a beatiful solution if you\'re using Python 3.4 or better. Use the input argument instead of the stdin argument, which accepts a bytes argument:Beware that Popen.communicate(input=s)may give you trouble ifsis too big, because apparently the parent process will buffer it before forking the child subprocess, meaning it needs "twice as much" used memory at that point (at least according to the "under the hood" explanation and linked documentation found here). In my particular case,swas a generator that was first fully expanded and only then written tostdin so the parent process was huge right before the child was spawned, \nand no memory was left to fork it:File "/opt/local/stow/python-2.7.2/lib/python2.7/subprocess.py", line 1130, in _execute_child\n    self.pid = os.fork()\nOSError: [Errno 12] Cannot allocate memory