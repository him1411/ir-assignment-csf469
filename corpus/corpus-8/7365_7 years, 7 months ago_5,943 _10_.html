I noticed in System.Threading.TimerBase.Dipose() the method has a try{} finally{} block but the try{} is empty.Is there any value in using try{} finally{} with an empty try?http://labs.developerfusion.co.uk/SourceViewer/browse.aspx?assembly=SSCLI&namespace=System.Threading&type=TimerBaseFrom http://blog.somecreativity.com/2008/04/10/the-empty-try-block-mystery/:This methodology guards against a\n  Thread.Abort call interrupting the\n  processing. The MSDN page of\n  Thread.Abort says that \xe2\x80\x9cUnexecuted\n  finally blocks are executed before the\n  thread is aborted\xe2\x80\x9d. So in order to\n  guarantee that your processing\n  finishes even if your thread is\n  aborted in the middle by someone\n  calling Abort on your thread, you can\n  place all your code in the finally\n  block (the alternative is to write\n  code in the \xe2\x80\x9ccatch\xe2\x80\x9d block to determine\n  where you were before \xe2\x80\x9ctry\xe2\x80\x9d was\n  interrupted by Abort and proceed from\n  there if you want to).This is to guard against Thread.Abort interrupting a process. Documentation for this method says that:Unexecuted finally blocks are executed before the thread is aborted.This is because in order to recover successfully from an error, your code will need to clean up after itself. Since C# doesn\'t have C++-style destructors, finally and using blocks are the only reliable way of ensuring that such cleanup is performed reliably. Remember that using block turns into this by the compiler:In .NET 1.x, there was a chance that finally block will get aborted. This behavior was changed in .NET 2.0.Moreover, empty try blocks never get optimized away by the compiler.