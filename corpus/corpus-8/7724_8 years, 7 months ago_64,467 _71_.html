This question already has an answer here:I\'m currently working on a simple game in Java with several different modes. I\'ve extended a main Game class to put the main logic within the other classes. Despite this, the main game class is still pretty hefty.After taking a quick look at my code the majority of it was Getters and Setters (60%) compared to the rest that is truly needed for the logic of the game.A couple of Google searches have claimed that Getters and Setters are evil, whilst others have claimed that they are necessary for good OO practice and great programs.So what should I do? Which should it be? Should I be changing my Getters and Setters for my private variables, or should I stick with them?There is also the point of view that most of the time, using setters still breaks encapsulation by allowing you to set values that are meaningless. As a very obvious example, if you have a score counter on the game that only ever goes up, instead ofit should beThis is perhaps a bit of a facile example. What I\'m trying to say is that discussing getter/setters vs public fields often obscures bigger problems with objects manipulating each others\' internal state in an intimate manner and hence being too closely coupled.The idea is to make methods that directly do things you want to do. An example would be how to set enemies\' "alive" status. You might be tempted to have a setAlive(boolean alive) method. Instead you should have:The reason for this is that if you change the implementation that things no longer have an "alive" boolean but rather a "hit points" value, you can change that around without breaking the contract of the two methods you wrote earlier:It really depends on the situation though - sometimes you really do just want a dumb data object.You\'ve already had a lot of good answers on this, so I\'ll just give my two cents. Getters and setters are very, very evil. They essentially let you pretend to hide your object\'s internals when most of the time all you\'ve done is tossed in redundant code that does nothing to hide internal state. For a simple POJO, there\'s no reason why getName() and setName() can\'t be replaced with obj.name = "Tom". If the method call merely replaces assignment, then all you\'ve gained by preferring the method call is code bloat. Unfortunately, the language has enshrined the use of getters and setters in the JavaBeans specification, so Java programmers are forced to use them, even when doing so makes no sense whatsoever. Fortunately, Eclipse (and probably other IDEs as well) lets you automatically generate them. And for a fun project, I once built a code-generator for them in XSLT. But if there\'s one thing I\'d get rid of in Java, its the over-dependence on getters and setters.Getters and setters enforce the concept of encapsulation in object-oriented programming.By having the states of the object hidden from the outside world, the object is truly in charge of itself, and cannot be altered in ways that aren\'t intended. The only ways the object can be manipulated are through exposed public methods, such as getters and setters.There are a few advantages for having getters and setters:1. Allowing future changes without modification to code that uses the modified class.One of the big advantage of using a getter and setter is that once the public methods are defined and there comes a time when the underlying implementation needs to be changed (e.g. finding a bug that needs to be fixed, using a different algorithm for improving performance, etc.), by having the getters and setters be the only way to manipulate the object, it will allow existing code to not break, and work as expected even after the change.For example, let\'s say there\'s a setValue method which sets the value private variable in an object:But then, there was a new requirement which needed to keep track of the number of times value was changed. With the setter in place, the change is fairly trivial:If the value field were public, there is no easy way to come back later and add a counter that keeps track of the number of times the value was changed. Therefore, having getters and setters are one way to "future-proof" the class for changes which may come later.2. Enforcing the means by which the object can be manipulated.Another way getters and setters come in handy is to enforce the ways the object can be manipulated, therefore, the object is in control of its own state. With public variables of an object exposed, it can easily be corrupted.For example, an ImmutableArray object contains an int array called myArray. If the array were a public field, it just won\'t be immutable:To implement a truly immutable array, a getter for the array (getArray method) should be written so it returns a copy of its array:And even if the following occurs:The ImmutableArray is indeed immutable. Exposing the variables of an object will allow it to be manipulated in ways which aren\'t intended, but only exposing certain ways (getters and setters), the object can be manipulated in intended ways.I suppose having getters and setters would be more important for classes which are part of an API that is going to be used by others, as it allows keeping the API intact and unchanged while allowing changes in the underlying implementation.With all the advantages of getters and setters said, if the getter is merely returning the value of the private variable and the setter is merely accepting a value and assigning it to a private variable, it seems the getters and setter are just extraneous and really a waste. If the class is going to be just for internal use by an application that is not going to be used by others, using getters and setters extensively may not be as important as when writing a public API.They absolutely are evil.@coobird unfortunately they absolutely do not "enforce the concept of encapsulation", all they do is make you think you\'re encapsulating data when in fact you\'re exposing data via a property with delusions of method grandeur. Anything a getter/setter does a public field does better.First, if you want public data, make it public, get rid of the getter & setter methods to reduce the number of methods the client has to wade through and make it cognitively simpler for the client to change it\'s value by eg.instead of the more cognitively intensewhere the client must now check the getter/setter method to see if it has any side-effects.Second, if you really need to do something else in the method, why call it a get/set method when it\'s got more responsibilities than simply getting or setting?\nEither follow the SRP or call the method something that actually tells you what the whole method does like Zarkonnen\'s examples he mentioned eg.instead ofwhere does the setAlive(boolean) method tell the client that as a side-effect it\'ll remove the object from the world? Why should the client have any knowledge about the isAlive field? Plus what happens when the object is re-added to the world, should it be re-initialised? why would the client care about any of that?IMHO the moral is to name methods to say exactly what they do, follow the SRP and get rid of getters/setters.\nIf there\'s problems without getters/setters, tell objects to do their own dirty work inside their own class instead of trying to do things with them in other classes.here endeth my rant, sorry about that ;)It\'s a slippery slope.A simple Transfer object (or Parameter object) may have the sole purpose of holding some fields and providing their values on demand. However, even in that degenerate case one could argue that the object should be immutable -- configured in the constructor and exposing only get... methods.There\'s also the case of a class that exposes some "control knobs"; your car radio\'s UI probably can be understood as exposing something like getVolume, setVolume, getChannel, and setChannel, but its real functionality is receiving signals and emitting sound. But those knobs don\'t expose much implementation detail; you don\'t know from those interface features whether the radio is transistors, mostly-software, or vacuum tubes.The more you begin to think of an object as an active participant in a problem-domain task, the more you\'ll think in terms of asking it to do something instead of asking it to tell you about its internal state, or asking it for its data so other code can do something with those values.So... "evil"? Not really. But every time you\'re inclined to put in a value and expose both get... and set... methods on that value, ask yourself why, and what that object\'s reponsibility really is. If the only answer you can give yourself is, "To hold this value for me", then maybe something besides OO is going on here.Your Game class is probably following the god object antipattern if it exposes that many variables. There\'s nothing wrong with getters and setters (though their verbosity in Java can be a bit annoying); in a well-designed app where each class has a clearly separated functionality, you will not need dozens of them in a single class.Edit: If the main point for the getters and setters is to "configure" the game classe (I understand your comment that way), then your probably don\'t need the getters (it\'s perfectly fine for a class to access its own private variables without using get methods), and you can probably collapse many of the setters into "group setters" that set several variables which belong together conceptually.My opinion is that getters and setters are a requirement for good programs. Stick with them, but don\'t write unnecessary getters/setters - it\'s not always necessary to directly deal with all variables.The presence of getter and setters tends to indicate (a "smell" if you are into that sort of primary school language) that there is a design problem. Trivial getters and setters are barely distinguishable from public fields. Typically the code operating on the data will be in a different class - poor encapsulation, and what you would expect from programmers not at ease with OO.In some cases getters and setters are fine. But as a rule a type with both getters and setters indicates design problems. Getters work for immutability; setters work for "tell don\'t ask". Both immutability and "tell don\'t ask" are good design choices, so long as they are not applied in an overlapping style.I don\'t really think they are evil.  But I would love to live in a world where I never had to use them unless I really needed to.One example I read above was future-proofing your code.  For example:Then, the requirements change and you need to track how many times the value was set.So:This is beautiful.  I get it.  However, in Ruby, would the following not serve the same purpose?Later, you need to track the number of times my_value was set.  Well then, could you not just override the setter THEN and only THEN?I\'m all for beautiful code but I have to admit, looking through the mountains of Java classes we have and seeing literally thousands and thousands of lines of code that are NOTHING but basic getter/setters is ugly and annoying.When I was developing in C# full time, we used public properties all the time and did custom getters/setters only when needed.  Worked like a charm and it didn\'t break anything.As always the only answer is: it depends. If you are the only peron touching the code, you can do anything you\'re comfortable with, including taking shortcuts.One of the benefits of using setters is that checks need to be performed at only one location in your code.You might want to pay some closer attention to what is actually being get and set by these methods. If you\'re using them to provide access to constant values you are probably better off by using constants.This depends on the programming language in question. Your question is framed in the context of Java, where it seems that getters and setters are generally thought of as a good thing. In contrast, in the Python world, they are generally considered as bad style: they add lines to the code without actually adding functionality. When Python programmers need to, they can use metaprogramming to catch getting and/or setting of object attributes. In Java (at least the version of Java I learned slightly a decade ago), that was not possible. Thus, in Java it is usually best to use getters and setters religiously, so that if you need to, you can override access to the variables.(This doesn\'t make Python necessarily better than Java, just different.)Just FYI: In addition to all the excellent answers in this thread, remember that of all reasons you can come up with for or against getters/setters, performance isn\'t one (as some might believe). The JVM is smart enough to inline trivial getters/setters (even non-final ones, as long as they aren\'t actually overridden).You may want to replace some of your classes by value classes. This will allow you to remove the getter and avoid problems when the content is changed from under you.If you need external access to individual values of fields, use getters and/ or setters. If not, don\'t. Never use public fields. It\'s as simple as that! (Ok, it\'s never that simple, but it\'s a good rule of thumb).In general you should also find that you need to supply a setter much less often than a getter - especially if you are trying to make your objects immutable - which is a Good Thing (but not always the best choice) - but even if not.I\'ve been programming in java for few monts ago, and I\'ve learned that we should use getters & setters only when it\'s necessary for the applicationhave fun :)