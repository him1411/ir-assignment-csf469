I\'m teaching myself Python and my most recent lesson was that Python is not Java, and so I\'ve just spent a while turning all my Class methods into functions.I now realise that I don\'t need to use Class methods for what I would done with static methods in Java, but now I\'m not sure when I would use them.  All the advice I can find about Python Class methods is along the lines of newbies like me should steer clear of them, and the standard documentation is at its most opaque when discussing them.Does anyone have a good example of using a Class method in Python or at least can someone tell me when Class methods can be sensibly used?Class methods are for when you need to have methods that aren\'t specific to any particular instance, but still involve the class in some way. The most interesting thing about them is that they can be overridden by subclasses, something that\'s simply not possible in Java\'s static methods or Python\'s module-level functions.If you have a class MyClass, and a module-level function that operates on MyClass (factory, dependency injection stub, etc), make it a classmethod. Then it\'ll be available to subclasses.Factory methods (alternative constructors) are indeed a classic example of class methods.Basically, class methods are suitable anytime you would like to have a method which naturally fits into the namespace of the class, but is not associated with a particular instance of the class.As an example, in the excellent unipath module:As the current directory is process wide, the cwd method has no particular instance with which it should be associated.  However, changing the cwd to the directory of a given Path instance should indeed be an instance method.Hmmm... as Path.cwd() does indeed return a Path instance, I guess it could be considered to be a factory method...Think about it this way: normal methods are useful to hide the details of dispatch: you can type myobj.foo() without worrying about whether the foo() method is implemented by the myobj object\'s class or one of its parent classes. Class methods are exactly analogous to this, but with the class object instead: they let you call MyClass.foo() without having to worry about whether foo() is implemented specially by MyClass because it needed its own specialized version, or whether it is letting its parent class handle the call.Class methods are essential when you are doing set-up or computation that precedes the creation of an actual instance, because until the instance exists you obviously cannot use the instance as the dispatch point for your method calls. A good example can be viewed in the SQLAlchemy source code; take a look at the dbapi() class method at the following link:https://github.com/zzzeek/sqlalchemy/blob/ab6946769742602e40fb9ed9dde5f642885d1906/lib/sqlalchemy/dialects/mssql/pymssql.py#L47You can see that the dbapi() method, which a database backend uses to import the vendor-specific database library it needs on-demand, is a class method because it needs to run before instances of a particular database connection start getting created \xe2\x80\x94 but that it cannot be a simple function or static function, because they want it to be able to call other, supporting methods that might similarly need to be written more specifically in subclasses than in their parent class. And if you dispatch to a function or static class, then you "forget" and lose the knowledge about which class is doing the initializing.I recently wanted a very light-weight logging class that would output varying amounts of output depending on the logging level that could be programmatically set.  But I didn\'t want to instantiate the class every time I wanted to output a debugging message or error or warning.  But I also wanted to encapsulate the functioning of this logging facility and make it reusable without the declaration of any globals.So I used class variables and the @classmethod decorator to achieve this.With my simple Logging class, I could do the following:Then, in my code, if I wanted to spit out a bunch of debugging information, I simply had to codeErrors could be out put with In the "production" environment, I can specify and now, only the error message will be output.  The debug message will not be printed.Here\'s my class:And some code that tests it just a bit:Alternative constructors are the classic example.I think the most clear answer is AmanKow\'s one. It boils down to how u want to organize your code. You can write everything as module level functions which are wrapped in the namespace of the module i.eThe above procedural code is not well organized, as you can see after only 3 modules it gets confusing, what is each method do ? You can use long descriptive names for functions(like in java) but still  your code gets unmanageable very quick.The object oriented way is to break down your code into manageable blocks i.e Classes & objects and functions can be associated with objects instances or with classes. With class functions you gain another level of division in your code compared with module level functions.\nSo you can group related functions within a class to make them more specific to a task  that you assigned to that class. For example you can create a file utility class :This way is more flexible and more maintainable, you group functions together and its more obvious to what each function do. Also you prevent name conflicts, for example the function copy may exist in another imported module(for example network copy) that you use in your code, so when you use the full name FileUtil.copy() you remove the problem and both copy functions can be used side by side.When a user logs in on my website, a User() object is instantiated from the username and password.If I need a user object without the user being there to log in (e.g. an admin user might want to delete another users account, so i need to instantiate that user and call its delete method):I have class methods to grab the user object.I used to work with PHP and recently I was asking myself, whats going on with this classmethod? Python manual is very technical and very short in words so it wont help with understanding that feature. I was googling and googling and I found answer -> http://code.anjanesh.net/2007/12/python-classmethods.html.If you are lazy to click it. My explanation is shorter and below. :)in PHP (maybe not all of you know PHP, but this language is so straight forward that everybody should understand what I\'m talking about) we have static variables like this:The output will be in both cases 20.However in python we can add @classmethod decorator and thus it is possible to have output 10 and 20 respectively. Example:Smart, ain\'t?It allows you to write generic class methods that you can use with any compatible class.For example:If you don\'t use @classmethod you can do it with self keyword but it needs an instance of Class:Honestly?  I\'ve never found a use for staticmethod or classmethod.  I\'ve yet to see an operation that can\'t be done using a global function or an instance method.It would be different if python used private and protected members more like Java does.  In Java, I need a static method to be able to access an instance\'s private members to do stuff.  In Python, that\'s rarely necessary.Usually, I see people using staticmethods and classmethods when all they really need to do is use python\'s module-level namespaces better.Class methods provide a "semantic sugar" (don\'t know if this term is widely used) - or "semantic convenience".Example: you got a set of classes representing objects. You might want to have the class method all() or find() to write User.all() or User.find(firstname=\'Guido\'). That could be done using module level functions of course...This is an interesting topic. My take on it is that python classmethod operates like a singleton rather than a factory (which returns a produced an instance of a class). The reason it is a singleton is that there is a common object that is produced (the dictionary) but only once for the class but shared by all instances.To illustrate this here is an example. Note that all instances have a reference to the single dictionary. This is not Factory pattern as I understand it. This is probably very unique to python.What just hit me, coming from Ruby, is that a so-called class method and a so-called instance method is just a function with semantic meaning applied to its first parameter, which is silently passed when the function is called as a method of an object (i.e. obj.meth()).Normally that object must be an instance but the @classmethod method decorator changes the rules to pass a class. You can call a class method on an instance (it\'s just a function) - the first argyment will be its class. Because it\'s just a function, it can only be declared once in any given scope (i.e. class definition). If follows therefore, as a surprise to a Rubyist, that you can\'t have a class method and an instance method with the same name.Consider this:You can call foo on an instance But not on a class:Now add @classmethod:Calling on an instance now passes its class:as does calling on a class:It\'s only convention that dictates that we use self for that first argument on an instance method and cls on a class method. I used neither here to illustrate that it\'s just an argument. In Ruby, self is a keyword.Contrast with Ruby:The Python class method is just a decorated function and you can use the same techniques to create your own decorators. A decorated method wraps the real method (in the case of @classmethod it passes the additional class argument). The underlying method is still there, hidden but still accessible.footnote: I wrote this after a name clash between a class and instance method piqued my curiosity. I am far from a Python expert and would like comments if any of this is wrong.I was asking myself the same question few times. And even though the guys here tried hard to explain it, IMHO the best answer (and simplest) answer I have found is the description of the Class method in the Python Documentation.There is also reference to the Static method. And in case someone already know instance methods (which I assume), this answer might be the final piece to put it all together...Further and deeper elaboration on this topic can be found also in the documentation:\nThe standard type hierarchy (scroll down to Instance methods section)A class defines a set of instances, of course.  And the methods of a class work on the individual instances.  The class methods (and variables) a place to hang other information that is related to the set of instances over all.For example if your class defines a the set of students you might want class variables or methods which define things like the set of grade the students can be members of.You can also use class methods to define tools for working on the entire set.  For example Student.all_of_em() might return all the known students.  Obviously if your set of instances have more structure than just a set you can provide class methods to know about that structure.  Students.all_of_em(grade=\'juniors\')Techniques like this tend to lead to storing members of the set of instances into data structures that are rooted in class variables.  You need to take care to avoid frustrating the garbage collection then.