Searching on Google reveals x2 code snippets. The first result is to this code recipe which has a lot of documentation and explanation, along with some useful discussion underneath. However, another code sample, whilst not containing so much documentation, includes sample code for passing commands such as start, stop and restart. It also creates a PID file which can be handy for checking if the daemon is already running etc.These samples both explain how to create the daemon. Are there any additional things that need to be considered? Is one sample better than the other, and why?Sander Marechal\'s code sample is superior to the original, which was originally posted in 2004.  I once contributed a daemonizer for Pyro, but would probably use Sander\'s code if I had to do it over.There are many fiddly things to take care of when becoming a well-behaved daemon process:prevent core dumps (many daemons run as root, and core dumps can contain sensitive information)behave correctly inside a chroot gaolset UID, GID, working directory, umask, and other process parameters appropriately for the use caserelinquish elevated suid, sgid privilegesclose all open file descriptors, with exclusions depending on the use casebehave correctly if started inside an already-detached context, such as init, inetd, etc.set up signal handlers for sensible daemon behaviour, but also with specific handlers determined by the use caseredirect the standard streams stdin, stdout, stderr since a daemon process no longer has a controlling terminalhandle a PID file as a cooperative advisory lock, which is a whole can of worms in itself with many contradictory but valid ways to behaveallow proper cleanup when the process is terminatedactually become a daemon process without leading to zombiesSome of these are standard, as described in canonical Unix literature (Advanced Programming in the UNIX Environment, by the late W. Richard Stevens, Addison-Wesley, 1992). Others, such as stream redirection and PID file handling, are conventional behaviour most daemon users would expect but that are less standardised.All of these are covered by the PEP 3143 \xe2\x80\x9cStandard daemon process library\xe2\x80\x9d specification. The python-daemon reference implementation works on Python 2.7 or later, and Python 3.2 or later.Here\'s my basic \'Howdy World\' Python daemon that I start with, when I\'m developing a new daemon application.Note that you\'ll need the python-deaemon library.  In Ubuntu, you would:Then just start it with ./howdy.py start, and stop it with ./howdy.py stop.Note the python-daemon package which solves a lot of problems behind daemons out of the box.Among other features it enables to (from Debian package description):An alternative -- create a normal, non-daemonized Python program then externally daemonize it using supervisord.  This can save a lot of headaches, and is *nix- and language-portable.Probably not a direct answer to the question, but systemd can be used to run your application as a daemon.  Here is an example:I prefer this method because a lot of the work is done for you, and then your daemon script behaves similarly to the rest of your system.-OrbyHere is a relatively new python module that popped up in Hacker News. Looks pretty useful, can be used to convert a python script into daemon mode from inside the script. linksince python-daemon has not yet supported python 3.x, and from what can be read on the mailing list, it may never will, i have written a new implementation of PEP 3143: pep3143daemonpep3143daemon should support at least python 2.6, 2.7 and 3.xIt also contains a PidFile class.The library only depends on the standard library and on the six module.It can be used as a drop in replacement for python-daemon.Here is the documentation.One more to thing to think about when daemonizing in python:If your are using python logging and you want to continue using it after daemonizing, make sure to call close() on the handlers (particularly the file handlers).If you don\'t do this the handler can still think it has files open, and your messages will simply disappear - in other words make sure the logger knows its files are closed!This assumes when you daemonise you are closing ALL the open file descriptors indiscriminatingly - instead you could try closing all but the log files (but it\'s usually simpler to close all then reopen the ones you want).This function will transform an application to a daemon:I am afraid the daemon module mentioned by @Dustin didn\'t work for me. Instead I installed python-daemon and used the following code:Running is easyjust for completeness here is samplemodule directory contentThe content of moduleclass.py can beI modified a few lines in Sander Marechal\'s code sample (mentioned by @JeffBauer in the accepted answer) to add a quit() method that gets executed before the daemon is stopped. This is sometimes very useful.Here it is.Note: I don\'t use the "python-daemon" module because the documentation is still missing (see also many other SO questions) and is rather obscure (how to start/stop properly a daemon from command line with this module?)The easiest way to create daemon with Python is to use the Twisted event-driven framework.  It handles all of the stuff necessary for daemonization for you.  It uses the Reactor Pattern to handle concurrent requests.80% of the time, when folks say "daemon", they only want a server.  Since the question is perfectly unclear on this point, it\'s hard to say what the possible domain of answers could be.  Since a server is adequate, start there.  If an actual "daemon" is actually needed (this is rare), read up on nohup as a way to daemonize a server.Until such time as an actual daemon is actually required, just write a simple server.Also look at the WSGI reference implementation.Also look at the Simple HTTP Server."Are there any additional things that need to be considered? "  Yes.  About a million things.  What protocol?  How many requests?  How long to service each request?  How frequently will they arrive?  Will you use a dedicated process?  Threads?  Subprocesses?  Writing a daemon is a big job.  