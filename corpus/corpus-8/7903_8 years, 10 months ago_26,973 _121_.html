Is it ever acceptable to have a memory leak in your C or C++ application?What if you allocate some memory and use it until the very last line of code in your application (for example, a global object\'s destructor)? As long as the memory consumption doesn\'t grow over time, is it OK to trust the OS to free your memory for you when your application terminates (on Windows, Mac, and Linux)? Would you even consider this a real memory leak if the memory was being used continuously until it was freed by the OS.What if a third party library forced this situation on you? Would refuse to use that third party library no matter how great it otherwise might be?I only see one practical disadvantage, and that is that these benign leaks will show up with memory leak detection tools as false positives.No.As professionals, the question we should not be asking ourselves is, "Is it ever OK to do this?" but rather "Is there ever a good reason to do this?"  And "hunting down that memory leak is a pain" isn\'t a good reason.I like to keep things simple.  And the simple rule is that my program should have no memory leaks.That makes my life simple, too.  If I detect a memory leak, I eliminate it, rather than run through some elaborate decision tree structure to determine whether it\'s an "acceptable" memory leak.It\'s similar to compiler warnings \xe2\x80\x93 will the warning be fatal to my particular application? Maybe not.  But it\'s ultimately a matter of professional discipline.  Tolerating compiler warnings and tolerating memory leaks is a bad habit that will ultimately bite me in the rear.To take things to an extreme, would it ever be acceptable for a surgeon to leave some piece of operating equipment inside a patient?Although it is possible that a circumstance could arise where the cost/risk of removing that piece of equipment exceeds the cost/risk of leaving it in, and there could be circumstances where it was harmless, if I saw this question posted on SurgeonOverflow.com and saw any answer other than "no," it would seriously undermine my confidence in the medical profession.\xe2\x80\x93If a third party library forced this situation on me, it would lead me to seriously suspect the overall quality of the library in question.  It would be as if I test drove a car and found a couple loose washers and nuts in one of the cupholders \xe2\x80\x93 it may not be a big deal in itself, but it portrays a lack of commitment to quality, so I would consider alternatives.I don\'t consider it to be a memory leak unless the amount of memory being "used" keeps growing. Having some unreleased memory, while not ideal, is not a big problem unless the amount of memory required keeps growing.Let\'s get our definitions correct, first.  A memory leak is when memory is dynamically allocated, eg with malloc(), and all references to the memory are lost without the corresponding free.  An easy way to make one is like this:Note that every time around the while(1) loop, 1024 (+overhead) bytes are allocated, and the new address assigned to vp; there\'s no remaining pointer to the previous malloc\'ed blocks.  This program is guaranteed to run until the heap runs out, and there\'s no way to recover any of the malloc\'ed memory.  Memory is "leaking" out of the heap, never to be seen again.What you\'re describing, though, sound likeYou allocate the memory, work with it until the program terminates.  This is not a memory leak; it doesn\'t impair the program, and all the memory will be scavenged up automagically when the program terminates.Generally, you should avoid memory leaks. First, because like altitude above you and fuel back at the hangar, memory that has leaked and can\'t be recovered is useless; second, it\'s a lot easier to code correctly, not leaking memory, at the start than it is to find a memory leak later.In theory no, in practise it depends.It really depends on how much data the program is working on, how often the program is run and whether or not it is running constantly.If I have a quick program that reads a small amount of data makes a calculation and exits, a small memory leak will never be noticed. Because the program is not running for very long and only uses a small amount of memory, the leak will be small and freed when the program exists.On the other hand if I have a program that processes millions of records and runs for a long time, a small memory leak might bring down the machine given enough time.As for third party libraries that have leaks, if they cause a problem either fix the library or find a better alternative.  If it doesn\'t cause a problem, does it really matter?Many people seem to be under the impression that once you free memory, it\'s instantly returned to the operating system and can be used by other programs.This isn\'t true. Operating systems commonly manage memory in 4KiB pages. malloc and other sorts of memory management get pages from the OS and sub-manage them as they see fit. It\'s quite likely that free() will not return pages to the operating system, under the assumption that your program will malloc more memory later.I\'m not saying that free() never returns memory to the operating system. It can happen, particularly if you are freeing large stretches of memory. But there\'s no guarantee.The important fact: If you don\'t free memory that you no longer need, further mallocs are guaranteed to consume even more memory. But if you free first, malloc might re-use the freed memory instead.What does this mean in practice? It means that if you know your program isn\'t going to require any more memory from now on (for instance it\'s in the cleanup phase), freeing memory is not so important. However if the program might allocate more memory later, you should avoid memory leaks - particularly ones that can occur repeatedly.Also see this comment for more details about why freeing memory just before termination is bad.A commenter didn\'t seem to understand that calling free() does not automatically allow other programs to use the freed memory. But that\'s the entire point of this answer!So, to convince people, I will demonstrate an example where free() does very little good. To make the math easy to follow, I will pretend that the OS manages memory in 4000 byte pages.Suppose you allocate ten thousand 100-byte blocks (for simplicity I\'ll ignore the extra memory that would be required to manage these allocations). This consumes 1MB, or 250 pages. If you then free 9000 of these blocks at random, you\'re left with just 1000 blocks - but they\'re scattered all over the place. Statistically, about 5 of the pages will be empty. The other 245 will each have at least one allocated block in them. That amounts to 980KB of memory, that cannot possibly be reclaimed by the operating system - even though you now only have 100KB allocated!On the other hand, you can now malloc() 9000 more blocks without increasing the amount of memory your program is tying up.Even when free() could technically return memory to the OS, it may not do so. free() needs to achieve a balance between operating quickly and saving memory. And besides, a program that has already allocated a lot of memory and then freed it is likely to do so again. A web server needs to handle request after request after request - it makes sense to keep some "slack" memory available so you don\'t need to ask the OS for memory all the time.There is nothing conceptually wrong with having the os clean up after the application is run.It really depends on the application and how it will be run. Continually occurring leaks in an application that needs to run for weeks has to be taken care of, but a small tool that calculates a result without too high of a memory need should not be a problem.There is a reason why many scripting language do not garbage collect cyclical references\xe2\x80\xa6 for their usage patterns, it\'s not an actual problem and would thus be as much of a waste of resources as the wasted memory.I believe the answer is no, never allow a memory leak, and I have a few reasons which I haven\'t seen explicitly stated. There are great technical answers here but I think the real answer hinges on more social/human reasons.(First, note that as others mentioned, a true leak is when your program, at any point, loses track of memory resources that it has allocated. In C, this happens when you malloc() to a pointer and let that pointer leave scope without doing a free() first.)The important crux of your decision here is habit. When you code in a language that uses pointers, you\'re going to use pointers a lot. And pointers are dangerous; they\'re the easiest way to add all manner of severe problems to your code.When you\'re coding, sometimes you\'re going to be on the ball and sometimes you\'re going to be tired or mad or worried. During those somewhat distracted times, you\'re coding more on autopilot. The autopilot effect doesn\'t differentiate between one-off code and a module in a larger project. During those times, the habits you establish are what will end up in your code base.So no, never allow memory leaks for the same reason that you should still check your blind spots when changing lanes even if you\'re the only car on the road at the moment. During times when your active brain is distracted, good habits are all that can save you from disastrous missteps.Beyond the "habit" issue, pointers are complex and often require a lot of brain power to track mentally. It\'s best to not "muddy the water" when it comes to your usage of pointers, especially when you\'re new to programming.There\'s a more social aspect too. By proper use of malloc() and free(), anyone who looks at your code will be at ease; you\'re managing your resources. If you don\'t, however, they\'ll immediately suspect a problem.Maybe you\'ve worked out that the memory leak doesn\'t hurt anything in this context, but every maintainer of your code will have to work that out in his head too when he reads that piece of code. By using free() you remove the need to even consider the issue.Finally, programming is writing a mental model of a process to an unambiguous language so that a person and a computer can perfectly understand said process. A vital part of good programming practice is never introducing unnecessary ambiguity.Smart programming is flexible and generic. Bad programming is ambiguous.I\'m going to give the unpopular but practical answer that it\'s always wrong to free memory unless doing so will reduce the memory usage of your program. For instance a program that makes a single allocation or series of allocations to load the dataset it will use for its entire lifetime has no need to free anything. In the more common case of a large program with very dynamic memory requirements (think of a web browser), you should obviously free memory you\'re no longer using as soon as you can (for instance closing a tab/document/etc.), but there\'s no reason to free anything when the user selects clicks "exit", and doing so is actually harmful to the user experience.Why? Freeing memory requires touching memory. Even if your system\'s malloc implementation happens not to store metadata adjacent to the allocated memory blocks, you\'re likely going to be walking recursive structures just to find all the pointers you need to free.Now, suppose your program has worked with a large volume of data, but hasn\'t touched most of it for a while (again, web browser is a great example). If the user is running a lot of apps, a good portion of that data has likely been swapped to disk. If you just exit(0) or return from main, it exits instantly. Great user experience. If you go to the trouble of trying to free everything, you may spend 5 seconds or more swapping all the data back in, only to throw it away immediately after that. Waste of user\'s time. Waste of laptop\'s battery life. Waste of wear on the hard disk.This is not just theoretical. Whenever I find myself with too many apps loaded and the disk starts thrashing, I don\'t even consider clicking "exit". I get to a terminal as fast as I can and type killall -9 ... because I know "exit" will just make it worse.I think in your situation the answer may be that it\'s okay.  But you definitely need to document that the memory leak is a conscious decision.  You don\'t want a maintenance programmer to come along, slap your code inside a function, and call it a million times.  So if you make the decision that a leak is okay you need to document it (IN BIG LETTERS) for whoever may have to work on the program in the future.If this is a third party library you may be trapped.  But definitely document that this leak occurs.But basically if the memory leak is a known quantity like a 512 KB buffer or something then it is a non issue.  If the memory leak keeps growing like every time you call a library call your memory increases by 512KB and is not freed, then you may have a problem.  If you document it and control the number of times the call is executed it may be manageable.  But then you really need documentation because while 512 isn\'t much, 512 over a million calls is a lot.Also you need to check your operating system documentation.  If this was an embedded device there may be operating systems that don\'t free all the memory from a program that exits.  I\'m not sure, maybe this isn\'t true.  But it is worth looking into.I\'m sure that someone can come up with a reason to say Yes, but it won\'t be me.\nInstead of saying no, I\'m going to say that this shouldn\'t be a yes/no question.\nThere are ways to manage or contain memory leaks, and many systems have them.There are NASA systems on devices that leave the earth that plan for this.  The systems will automatically reboot every so often so that memory leaks will not become fatal to the overall operation.  Just an example of containment.If you allocate memory and use it until the last line of your program, that\'s not a leak.  If you allocate memory and forget about it, even if the amount of memory isn\'t growing, that\'s a problem.  That allocated but unused memory can cause other programs to run slower or not at all.I can count on one hand the number of "benign" leaks that I\'ve seen over time.So the answer is a very qualified yes. An example. If you have a singleton resource that needs a buffer to store a circular queue or deque but doesn\'t know how big the buffer will need to be and can\'t afford the overhead of locking or every reader, then allocating an exponentially doubling buffer but not freeing the old ones will leak a bounded amount of memory per queue/deque. The benefit for these is they speed up every access dramatically and can change the asymptotics of multiprocessor solutions by never risking contention for a lock.I\'ve seen this approach used to great benefit for things with very clearly fixed counts such as per-CPU work-stealing deques, and to a much lesser degree in the buffer used to hold the singleton /proc/self/maps state in Hans Boehm\'s conservative garbage collector for C/C++, which is used to detect the root sets, etc.While technically a leak, both of these cases are bounded in size and in the growable circular work stealing deque case there is a huge performance win in exchange for a bounded factor of 2 increase in the memory usage for the queues.If you allocate a bunch of heap at the beginning of your program, and you don\'t free it when you exit, that is not a memory leak per se. A memory leak is when your program loops over a section of code, and that code allocates heap and then "loses track" of it without freeing it.In fact, there is no need to make calls to free() or delete right before you exit. When the process exits, all of its memory is reclaimed by the OS (this is certainly the case with POSIX. On other OSes \xe2\x80\x93 particularly embedded ones \xe2\x80\x93 YMMV).The only caution I\'d have with not freeing the memory at exit time is that if you ever refactor your program so that it, for example, becomes a service that waits for input, does whatever your program does, then loops around to wait for another service call, then what you\'ve coded can turn into a memory leak.this is so domain-specific that its hardly worth answering.  use your freaking head.and there is a spectrum of intermediate situations.the opportunity cost ($$$) of delaying a product release to fix all but the worst memory leaks is usually dwarfs any feelings of being "sloppy or unprofessional".  Your boss pays you to make him money, not to get a warm, fuzzy feelings.In this sort of question context is everything. Personally I can\'t stand leaks, and in my code I go to great lengths to fix them if they crop up, but it is not always worth it to fix a leak, and when people are paying me by the hour I have on occasion told them it was not worth my fee for me to fix a leak in their code. Let me give you an example:I was triaging a project, doing some perf work and fixing a lot of bugs. There was a leak during the applications initialization that I tracked down, and fully understood. Fixing it properly would have required a day or so refactoring a piece of otherwise functional code. I could have done something hacky (like stuffing the value into a global and grabbing it some point I know it was no longer in use to free), but that would have just caused more confusion to the next guy who had to touch the code.Personally I would not have written the code that way in the first place, but most of us don\'t get to always work on pristine well designed codebases, and sometimes you have to look at these things pragmatically. The amount of time it would have taken me to fix that 150 byte leak could instead be spent making algorithmic improvements that shaved off megabytes of ram.Ultimately, I decided that leaking 150 bytes for an app that used around a gig of ram and ran on a dedicated machine was not worth fixing it, so I wrote a comment saying that it was leaked, what needed to be changed in order to fix it, and why it was not worth it at the time.While most answers concentrate on real memory leaks (which are not OK ever, because they are a sign of sloppy coding), this part of the question appears more interesting to me:What if you allocate some memory and use it until the very last line of code in your application (for example, a global object\'s deconstructor)? As long as the memory consumption doesn\'t grow over time, is it OK to trust the OS to free your memory for you when your application terminates (on Windows, Mac, and Linux)? Would you even consider this a real memory leak if the memory was being used continuously until it was freed by the OS.If the associated memory is used, you cannot free it before the program ends. Whether the free is done by the program exit or by the OS does not matter. As long as this is documented, so that change don\'t introduce real memory leaks, and as long as there is no C++ destructor or C cleanup function involved in the picture. A not-closed file might be revealed through a leaked FILE object, but a missing fclose() might also cause the buffer not to be flushed. So, back to the original case, it is IMHO perfectly OK in itself, so much that Valgrind, one of the most powerful leak detectors, will treat such leaks only if requested. On Valgrind, when you overwrite a pointer without freeing it beforehand, it gets considered as a memory leak, because it is more likely to happen again and to cause the heap to grow endlessly.Then, there are not nfreed memory blocks which are still reachable. One could make sure to free all of them at the exit, but that is just a waste of time in itself. The point is if they could be freed before. Lowering memory consumption is useful in any case.You have to first realize that there\'s a big difference between a perceived memory leak and an actual memory leak.  Very frequently analysis tools will report many red herrings, and label something as having been leaked (memory or resources such as handles etc) where it actually isn\'t.  Often times this is due to the analysis tool\'s architecture.  For example, certain analysis tools will report run time objects as memory leaks because it never sees those object freed.  But the deallocation occurs in the runtime\'s shutdown code, which the analysis tool might not be able to see.With that said, there will still be times when you will have actual memory leaks that are either very difficult to find or very difficult to fix.  So now the question becomes is it ever OK to leave them in the code?The ideal answer is, "no, never."  A more pragmatic answer may be "no, almost never."  Very often in real life you have limited number of resources and time to resolve and endless list of tasks.  When one of the tasks is eliminating memory leaks, the law of diminishing returns very often comes in to play.  You could eliminate say 98% of all memory leaks in an application in a week, but the remaining 2% might take months.  In some cases it might even be impossible to eliminate certain leaks because of the application\'s architecture without a major refactoring of code.  You have to weigh the costs and benefits of eliminating the remaining 2%.Even if you are sure that your \'known\' memory leak will not cause havoc, don\'t do it. At best, it will pave a way for you to make a similar and probably more critical mistake at a different time and place.For me, asking this is like questioning "Can I break the red light at 3 AM in the morning when no one is around?". Well sure, it may not cause any trouble at that time but it will provide a lever for you to do the same in rush hour!I\'m surprised to see so many incorrect definitions of what a memory leak actually is. Without a concrete definition, a discussion on whether it\'s a bad thing or not will go nowhere.As some commentors have rightly pointed out, a memory leak only happens when memory allocated by a process goes out of scope to the extent that the process is no longer able to reference or delete it.A process which is grabbing more and more memory is not necessarily leaking. So long as it is able to reference and deallocate that memory, then it remains under the explicit control of the process and has not leaked. The process may well be badly designed, especially in the context of a system where memory is limited, but this is not the same as a leak. Conversely, losing scope of, say, a 32 byte buffer is still a leak, even though the amount of memory leaked is small. If you think this is insignificant, wait until someone wraps an algorithm around your library call and calls it 10,000 times.I see no reason whatsoever to allow leaks in your own code, however small. Modern programming languages such as C and C++ go to great lengths to help programmers prevent such leaks and there is rarely a good argument not to adopt good programming techniques - especially when coupled with specific language facilities - to prevent leaks.As regards existing or third party code, where your control over quality or ability to make a change may be highly limited, depending on the severity of the leak, you may be forced to accept or take mitigating action such as restarting your process regularly to reduce the effect of the leak.It may not be possible to change or replace the existing (leaking) code, and therefore you may be bound to accept it. However, this is not the same as declaring that it\'s OK.I think you\'ve answered your own question.  The biggest drawback is how they interfere with the memory leak detection tools, but I think that drawback is a HUGE drawback for certain types of applications.I work with legacy server applications that are supposed to be rock solid but they have leaks and the globals DO get in the way of the memory detection tools.  It\'s a big deal.  In the book "Collapse" by Jared Diamond, the author wonders about what the guy was thinking who cut down the last tree on Easter Island, the tree he would have needed in order to build a canoe to get off the island.   I wonder about the day many years ago when that first global was added to our codebase.  THAT was the day it should have been caught.I see the same problem as all scenario questions like this: What happens when the program changes, and suddenly that little memory leak is being called ten million times and the end of your program is in a different place so it does matter?  If it\'s in a library then log a bug with the library maintainers, don\'t put a leak into your own code.I\'ll answer no.In theory, the operating system will clean up after you if you leave a mess (now that\'s just rude, but since computers don\'t have feelings it might be acceptable). But you can\'t anticipate every possible situation that might occur when your program is run. Therefore (unless you are able to conduct a formal proof of some behaviour), creating memory leaks is just irresponsible and sloppy from a professional point of view.If a third-party component leaks memory, this is a very strong argument against using it, not only because of the imminent effect but also because it shows that the programmers work sloppily and that this might also impact other metrics. Now, when considering legacy systems this is difficult (consider web browsing components: to my knowledge, they all leak memory) but it should be the norm.Historically, it did matter on some operating systems under some edge cases.  These edge cases could exist in the future.Here\'s an example, on SunOS in the Sun 3 era, there was an issue if a process used exec (or more traditionally fork and then exec), the subsequent new process would inherit the same memory footprint as the parent and it could not be shrunk.  If a parent process allocated 1/2 gig of memory and didn\'t free it before calling exec, the child process would start using that same 1/2 gig (even though it wasn\'t allocated).  This behavior was best exhibited by SunTools (their default windowing system), which was a memory hog.  Every app that it spawned was created via fork/exec and inherited SunTools footprint, quickly filling up swap space.This was already discussed ad nauseam.  Bottom line is that a memory leak is a bug and must be fixed.  If a third party library leaks memory, it makes one wonder what else is wrong with it, no?  If you were building a car, would you use an engine that is occasionally leaking oil?  After all, somebody else made the engine, so it\'s not your fault and you can\'t fix it, right?Generally a memory leak in a stand alone application is not fatal, as it gets cleaned up when the program exits.What do you do for Server programs that are designed so they don\'t exit?If you are the kind of programmer that does not design and implement code where the resources are allocated and released correctly, then I don\'t want anything to do with you or your code.  If you don\'t care to clean up your leaked memory, what about your locks?  Do you leave them hanging out there too?  Do you leave little turds of temporary files laying around in various directories?Leak that memory and let the program clean it up?  No.  Absolutely not.  It\'s a bad habit, that leads to bugs, bugs, and more bugs.Clean up after yourself. Yo momma don\'t work here no more.As a general rule, if you\'ve got memory leaks that you feel you can\'t avoid, then you need to think harder about object ownership.But to your question, my answer in a nutshell is In production code, yes. During development, no. This might seem backwards, but here\'s my reasoning:In the situation you describe, where the memory is held until the end of the program, it\'s perfectly okay to not release it. Once your process exits, the OS will clean up anyway. In fact, it might make the user\'s experience better: In a game I\'ve worked on, the programmers thought it would be cleaner to free all the memory before exiting, causing the shutdown of the program to take up to half a minute! A quick change that just called exit() instead made the process disappear immediately, and put the user back to the desktop where he wanted to be.However, you\'re right about the debugging tools: They\'ll throw a fit, and all the false positives might make finding your real memory leaks a pain. And because of that, always write debugging code that frees the memory, and disable it when you ship.No, you should not have leaks that the OS will clean for you. The reason (not mentioned in the answers above as far as I could check) is that you never know when your main() will be re-used as a function/module in another program. If your main() gets to be a frequently-called function in another persons\' software - this software will have a memory leak that eats memory over time.KIVI agree with vfilby \xe2\x80\x93 it depends. In Windows, we treat memory leaks as relatively serous bugs. But, it very much depends on the component.  For example, memory leaks are not very serious for components that run rarely, and for limited periods of time. These components run, do theire work, then exit. When they exit all their memory is freed implicitly. However, memory leaks in services or other long run components (like the shell) are very serious. The reason is that these bugs \'steal\' memory over time. The only way to recover this is to restart the components. Most people don\'t know how to restart a service or the shell \xe2\x80\x93 so if their system performance suffers, they just reboot.So, if you have a leak \xe2\x80\x93 evaluate its impact two waysForedeckerI guess it\'s fine if you\'re writing a program meant to leak memory (i.e. to test the impact of memory leaks on system performance).I only see one practical disadvantage, and that is that these benign leaks will show up with memory leak detection tools as false positives.If I understood correctly, you don\'t explicitly free memory (which can be freed because you still have a pointer) and rely on OS to free it during process termination. Though this may seem okay for simple program, consider the situation where your code is moved into a library and becomes a part of some resident daemon process running 24/7. Say this daemon spawns a thread each time it needs to do something useful using your code and say it spawns thousands of threads every hour. In this case you will get real memory leak.Unfortunately, this situation is not unlikely in the real life and consistent memory management techniques may make your life easier.