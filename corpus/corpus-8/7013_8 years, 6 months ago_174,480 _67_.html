...where each object also has references to other objects within the same array?When I first came up with this problem I just though of something like would exist and searched for info on how to clone objects in javascript. I did find a question on StackOverflow (answered by the very same @JohnResig) and he pointed out that with jQuery you could doto clone an object. I tried this though, this only copies the references of the objects in the array. So if I the value of both nodesArray[0] and clonedNodesArray[0] will turn out to be "green". Then I triedwhich deep copies an Object, but I got "too much recursion" and "control stack overflow" messages from both Firebug and Opera Dragonfly respectively.How would you do it? Is this something that shouldn\'t even be done? Is there a reusable way of doing this in Javascript?The issue with your shallow copy is that all the objects aren\'t cloned.  While the references to each object are unique in each array, once you ultimately grab onto it you\'re dealing with the same object as before.  There is nothing wrong with the way you cloned it...  the same result would occur using Array.slice().The reason your deep copy is having problems is because you\'re ending up with circular object references.  Deep will go as deep as it can go, and if you\'ve got a circle, it\'ll keep going infinitely until the browser faints.If the data structure cannot be represented as a directed acyclic graph, then I\'m not sure you\'re going to be able to find an all-purpose method for deep cloning.  Cyclic graphs provide many tricky corner cases, and since it\'s not a common operation I doubt anyone has written a full solution (if it\'s even possible - it might not be!  But I have no time to try to write a rigorous proof now.).  I found some good comments on the issue on this page.If you need a deep copy of an Array of Objects with circular references I believe you\'re going to have to code your own method to handle your specialized data structure, such that it is a multi-pass clone:C\'mon guys, it is the 21st century: as long as your objects contain JSON-serializable content (no functions, no Number.POSITIVE_INFINITY, etc.) there is no need for any loops to clone arrays or objects.  Here is a pure vanilla one-line solution.To summarize the comments below, the primary advantage of this approach is that it also clones the contents of the array, not just the array itself.  The primary downsides are its limit of only working on JSON-serializable content, and it\'s performance (which is significantly worse than a slice based approach).If all you need is a shallow copy, a really easy way is:I solved cloning of an array of objects with Object.assignconst newArray = myArray.map(a => Object.assign({}, a));or even shorter with spread syntaxconst newArray = myArray.map(a => ({...a}));Simply clone any type of array with:or, since concat may not work in some IE browsers, you can use this:This works for me:And if you need deep copy of objects in array:Best and most up to date way to do this clone is as follows:Using the "..." ES6 spread operator.Here\'s the most simple Example:This way we spread the array into individual values and put it in a new array with the [] operator.Here\'s a longer example that shows the different ways it works: I may have a simple way to do this without having to do painful recursion and not knowing all the finer details of the object in question. Using jQuery, simply convert your object to JSON using the jQuery $.toJSON(myObjectArray), then take your JSON string and evaluate it back to an object. BAM! Done, and done! Problem solved. :)I\'m answering this question because there doesn\'t seem to be a simple and explicit solution to the problem of "cloning an array of objects in Javascript":This solution iterates the array values, then iterates the object keys, saving the latter to a new object, and then pushing that new object to a new array.See jsfiddle.  Note: a simple .slice() or [].concat() isn\'t enough for the objects within the array.As Daniel Lew mentioned, cyclic graphs have some problems. If I had this problem I\'d either add special clone() methods to the problematic objects or remember which objects I\'ve already copied.I\'d do it with a variable copyCount which increases by 1 every time you copy in your code. An object that has a lower copyCount than the current copy-process is copied. If not, the copy, that exists already, should be referenced. This makes it necessary to link from the original to its copy.There is still one problem: Memory. If you have this reference from one object to the other, it\'s likely that the browser can\'t free those objects, as they are always referenced from somewhere. You\'d have to make a second pass where you set all copy-references to Null. (If you do this, you\'d not have to have a copyCount but a boolean isCopied would be enough, as you can reset the value in the second pass.)JQuery extend is working fine, just you need to specify that you are cloning an array rather than an object (note the [] instead of {} as parameter to the extend method):Array.slice can be used to copy an array or part of an array..\nhttp://www.devguru.com/Technologies/Ecmascript/Quickref/Slice.html\nThis would work with strings and numbers .. - changing a string in one array would not affect the other - but objects are still just copied by reference so changes to referenced objects in one array would have an affect on the other array.Here is an example of a JavaScript undo manager that could be useful for this :http://www.ridgway.co.za/archive/2007/11/07/simple-javascript-undo-manager-for-dtos.aspxI was pretty frustrated by this problem. Apparently the problem arises when you send in a generic Array to the $.extend method. So, to fix it, I added a little check, and it works perfectly with generic arrays, jQuery arrays, and any objects.Invoke using:My approach: gives me a nice, clean, deep clone of the original array - with none of the objects referenced back to the original :-)forget eval() (is the most misused feature of JS and makes the code slow) and slice(0) (works for simple data types only)This is the best solution for me:We can invent a simple recursive Array method to clone multidimensional arrays. While the objects within the nested arrays keep their reference to the corresponding objects in the source array, arrays won\'t.with jQuery:The following code will perform recursively a deep copying of objects and array:SourceThis deeply copies arrays, objects, null and other scalar values, and also deeply copies any properties on non-native functions (which is pretty uncommon but possible). (For efficiency, we do not attempt to copy non-numeric properties on arrays.)This method is very simple and you can modify your clone without modify the original array.I use the new ECMAScript 6 Object.assign method :the first argument of this method is the array to be update,\nwe pass an empty object because we want to have a new object.we can also use this syntax, which is the same but shorter :I think managed to write a generic method of deep cloning any JavaScript structure mainly using Object.create which is supported in all modern browsers. The code is like this:For cloning the objects as well I was just going to suggest ECMAScript 6 reduce():But frankly I like the answer of @dinodsaurus even better. I\'m just putting this version here as another option, but personally I\'ll be using map() as suggested by @dinodsaurus .Depending if you have Underscore or Babel here is a Benchmark of the different way of deep cloning an array. https://jsperf.com/object-rest-spread-vs-clone/2Look like babel is the fastest.Some elegant ways for deep cloning in javascripthttp://heyjavascript.com/4-creative-ways-to-clone-objects/#1) A vanilla Javascript method for cloning objects2) A clever exploit of the JSON library to deep-clone objects3) Using jQuery\xe2\x80\x99s $.extend() function4) Using Mootools\xe2\x80\x99 clone() function to clone objects