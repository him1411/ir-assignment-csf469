This answer to Command line command to auto-kill a command after a certain amount of time proposes a 1-line method to timeout a long-running command from the bash command line:But it\'s possible that a given "long-running" command may finish earlier than the timeout. (Let\'s call it a "typically-long-running-but-sometimes-fast" command, or tlrbsf for fun.)So this nifty 1-liner approach has a couple of problems. First, the sleep isn\'t conditional, so that sets an undesirable lower bound on the time taken for the sequence to finish. Consider 30s or 2m or even 5m for the sleep, when the tlrbsf command finishes in 2 seconds â€” highly undesirable. Second, the kill is unconditional, so this sequence will attempt to kill a non-running process and whine about it.So...Is there a way to timeout a typically-long-running-but-sometimes-fast ("tlrbsf") command that... and, for bonus points, runs the tlrbsf command in the foreground and any \'sleep\' or extra process in the background, such that the stdin/stdout/stderr of the tlrbsf command can be redirected, same as if it had been run directly?If so, please share your code. If not, please explain why.I have spent awhile trying to hack the aforementioned example but I\'m hitting the limit of my bash skills.I think this is precisely what you are asking for:http://www.bashcookbook.com/bashinfo/source/bash-4.0/examples/scripts/timeout3You are probably looking for the timeout command in coreutils. Since it\'s a part of coreutils, it is technically a C solution, but it\'s still coreutils. info timeout for more details.\nHere\'s an example:This solution works regardless of bash monitor mode. You can use the proper signal to terminate your_commandThe watcher kills your_command after given timeout; the script waits for the slow task and terminates the watcher. Note that wait does not work with processes which are children of a different shell.your_command interruptedyour_command finishedI prefer "timelimit", which has a package at least in debian.http://devel.ringlet.net/sysutils/timelimit/It is a bit nicer than the coreutils "timeout" because it prints something when killing the process, and it also sends SIGKILL after some time by default.See also the http://www.pixelbeat.org/scripts/timeout script the functionality of which has been integrated into newer coreutilsYou can do this entirely with bash 4.3 and above:Example: { while date; do sleep .3; done; } | _timeout 5 cat | lessNeeds Bash 4.3 for wait -nIf you do not need the return code, this can be made even simpler:Notes:Strictly speaking you do not need the ; in ; ), however it makes thing more consistent to the ; }-case.  And the set +b probably can be left away, too, but better safe than sorry.Except for --forground (probably) you can implement all variants timeout supports.  --preserve-status is a bit difficult, though.  This is left as an exercise for the reader ;)This recipe can be used "naturally" in the shell (as natural as for flock fd):However, as explained above, you cannot re-export environment variables into the enclosing shell this way naturally.Edit:Real world example: Time out __git_ps1 in case it takes too long (for things like slow SSHFS-Links):Edit2: Bugfix.  I noticed that exit 137 is not needed and makes _timeout unreliable at the same time.Edit3: git is a die-hard, so it needs a double-trick to work satisfyingly.Edit4: Forgot a _ in the first _timeout for the real world GIT example.There you go:you may change the SIGINT and 10 as you desire ;)Kinda hacky, but it works.  Doesn\'t work if you have other foreground processes (please help me fix this!)Actually, I think you can reverse it, meeting your \'bonus\' criteria:timeout is probably the first approach to try. You may need notification or another command to execute if it times out. After quite a bit of searching and experimenting, I came up with this bash script:If you already know the name of the program (let\'s assume program) to terminate after the timeout (as an example 3 seconds), I can contribute a simple and somewhat dirty alternative solution:This works perfectly if I call benchmark processes with system calls.There\'s also cratimeout by Martin Cracauer (written in C for Unix and Linux systems).In 99% of the cases the answer is NOT to implement any timeout logic.  Timeout logic is in nearly any situation a red warning sign that something else is wrong and should be fixed instead.Is your process hanging or breaking after n seconds sometimes?  Then find out why and fix that instead.As an aside, to do strager\'s solution right, you need to use wait "$SPID" instead of fg 1, since in scripts you don\'t have job control (and trying to turn it on is stupid).  Moreover, fg 1 relies on the fact that you didn\'t start any other jobs previously in the script which is a bad assumption to make.OS X doesn\'t use bash 4 yet, nor does it have /usr/bin/timeout, so here\'s a function that works on OS X without home-brew or macports that is similar to /usr/bin/timeout (based on Tino\'s answer).  Parameter validation, help, usage, and support for other signals are an exercise for reader.Simple script with code clarity. Save to /usr/local/bin/run:Times out a command that runs too long:Ends immediately for a command that completes:I was presented with a problem to preserve the shell context and allow timeouts, the only problem with it is it will stop script execution on the timeout - but it\'s fine with the needs I was presented:with the outputs:of course I assume there was a dir called scriptsA very simplistic way:with pkill (option -f) you can kill your specific command with arguments or specify -n to avoid kill old process.My problem was maybe a bit different : I start a command via ssh on a remote machine and want to kill the shell and childs if the command hangs.I now use the following :This way the command returns 255 when there was a timeout or the returncode of the command in case of successPlease note that killing processes from a ssh session is handled different from an interactive shell. But you can also use the -t option to ssh to allocate a pseudo terminal, so it acts like an interactive shellHere is a version that does not rely on spawning a child process - I needed a standalone script which embedded this functionality. It also does a fractional poll interval, so you can poll quicker. timeout would have been preferred - but I\'m stuck on an old server