I\'m trying to understand what makes the lock in concurrency so important if one can use synchronized (this). In the dummy code below, I can do either:Code:A ReentrantLock is unstructured, unlike synchronized constructs -- i.e.  you don\'t need to use a block structure for locking and can even hold a lock across methods. An example:Such flow is impossible to represent via a single monitor in a synchronized construct.Aside from that, ReentrantLock supports lock polling and interruptible lock waits that support time-out. ReentrantLock also has support for configurable fairness policy, allowing more flexible thread scheduling.The constructor for this class accepts an optional fairness parameter. When set true, under contention, locks favor granting access to the longest-waiting thread. Otherwise this lock does not guarantee any particular access order. Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are slower; often much slower) than those using the default setting, but have smaller variances in times to obtain locks and guarantee lack of starvation. Note however, that fairness of locks does not guarantee fairness of thread scheduling. Thus, one of many threads using a fair lock may obtain it multiple times in succession while other active threads are not progressing and not currently holding the lock. Also note that the untimed tryLock method does not honor the fairness setting. It will succeed if the lock is available even if other threads are waiting.ReentrantLock may also be more scalable, performing much better under higher contention. You can read more about this here.This claim has been contested, however; see the following comment:In the reentrant lock test, a new lock is created each time, thus there is no exclusive locking and the resulting data is invalid. Also, the IBM link offers no source code for the underlying benchmark so its impossible to characterize whether the test was even conducted correctly. When should you use ReentrantLocks? According to that developerWorks article...The answer is pretty simple -- use it when you actually need something it provides that synchronized doesn\'t, like timed lock waits, interruptible lock waits, non-block-structured locks, multiple condition variables, or lock polling. ReentrantLock also has scalability benefits, and you should use it if you actually have a situation that exhibits high contention, but remember that the vast majority of synchronized blocks hardly ever exhibit any contention, let alone high contention. I would advise developing with synchronization until synchronization has proven to be inadequate, rather than simply assuming "the performance will be better" if you use ReentrantLock. Remember, these are advanced tools for advanced users. (And truly advanced users tend to prefer the simplest tools they can find until they\'re convinced the simple tools are inadequate.) As always, make it right first, and then worry about whether or not you have to make it faster.ReentrantReadWriteLock is a specialized lock whereas synchornized(this) is a general purpose lock. They are similar but not quite the same.You are right in that you could use synchronized(this) instead of ReentrantReadWriteLock but the opposite is not always true.If you\'d like to better understand what makes ReentrantReadWriteLock special look up some information about producer-consumer thread synchronization.In general you can remember that whole-method synchronization and general purpose synchronization (using the synchronized keyword) can be used in most applications without thinking too much about the semantics of the synchronization but if you need to squeeze performance out of your code you may need to explore other more fine-grained, or special-purpose synchronization mechanisms.By the way, using synchronized(this) - and in general locking using a public class instance - can be problematic because it opens up your code to potential dead-locks because somebody else not knowingly might try to lock against your object somewhere else in the program.A reentrant lock will allow the lock holder to enter blocks of code even after it has already obtained the lock by entering other blocks of code. A non-reentrant lock would have the lock holder block on itself as it would have to release the lock it obtained from another block of code to reobtain that same lock to enter the nested lock requiring block of codeNeed to add import statement.\nNeed to wrap lock acquisitions in a try/finally block. This makes it more ugly than the synchronized keyword.\nThe synchronized keyword can be put in method definitions which avoids the need for a block which reduces nesting.For more information . From oracle documentation page about ReentrantLock:A reentrant mutual exclusion Lock with the same basic behaviour and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.A ReentrantLock is owned by the thread last successfully locking, but not yet unlocking it.  A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread. The method will return immediately if the current thread already owns the lock.The constructor for this class accepts an optional fairness parameter. When set true, under contention,  locks favor granting access to the longest-waiting thread. Otherwise this lock does not guarantee any particular access order.ReentrantLock key features as per this articleYou can use  ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock to further acquire control on granular locking on read and write operations.Have a look at this article by Benjamen on usage of different type of ReentrantLocks You can use reentrant locks with a fairness policy  or timeout to avoid thread starvation.  You can apply a  thread fairness policy.   it will help avoid a thread waiting forever to get to your resources. The "fairness policy" picks the next runnable thread to execute. It is based on priority, time since last run, blah blahalso,\nSynchronize can block indefinitely if it cant escape the block. Reentrantlock can have timeout set.  