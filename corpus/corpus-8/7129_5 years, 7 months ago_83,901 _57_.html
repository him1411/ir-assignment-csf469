From the node.js documentation:Modules are cached after the first time they are loaded. This means (among other things) that every call to require(\'foo\') will get exactly the same object returned, if it would resolve to the same file.Is there a way to invalidate this cache? i.e. for unit testing, I\'d like each test to be working on a fresh object.You can always safely delete an entry in require.cache without a problem, even when there are circular dependencies. Because when you delete, you just delete a reference to the cached module object, not the module object itself, the module object will not be GCed because in case of circular dependencies, there is still a object referencing this module object.\nsuppose you have a script a.js:and a script b.js:when you do:you will get:now if you edit your b.js:and do:you will get:Yes, you can access the cache via require.cache[moduleName] where moduleName is the name of the module you wish to access. Deleting an entry by calling delete require.cache[moduleName] will cause require to load the actual file.This is how you would remove all cached files associated with the module:Usage would be:Since this code uses the same resolver require does, just specify whatever you would for require."Unix was not designed to stop its users from doing stupid things, as\n  that would also stop them from doing clever things." \xe2\x80\x93 Doug GwynI think that there should have been a way for performing an explicit uncached module loading.If you always want to reload your module, you could add this function:and then use requireUncached(\'./myModule\') instead of require. At your own risk, of course.EDIT:I stand corrected. As seppo0010 has pointed out, you can force a reload by deleting the cached module from require.cache: http://nodejs.org/docs/latest/api/globals.html#globals_require_cacheThat said, I would still recommend against doing this for the reasons mentioned below. Then again, if you are only doing it in your unit test layer, you may be able to squeak by without any infinite dependency chains.original answer:No, there is really no way to do this. Also from the documentation:Multiple calls to require(\'foo\') may not cause the module code to be\n  executed multiple times. This is an important feature. With it,\n  "partially done" objects can be returned, thus allowing transitive\n  dependencies to be loaded even when they would cause cycles.If you want to have a module execute code multiple times, then export\n  a function, and call that function.Two points here:The reason this is necessary is to allow cycles to be resolved. You can see an example of this here: http://nodejs.org/docs/latest/api/modules.html#modules_cycles. If you could invalidate the cache somehow, you could cause an infinite loop due to circular dependencies. Even if you can be reasonably confident that your application code won\'t cause this, it could happen in any libraries you use.As the documentation points out, you can just wrap the functionality in a function that you can call in each test. This is generally a pretty good design pattern as well.We had this exact issue while testing our code (delete cached modules so they can be re-required in a fresh state) so we reviewed all the suggestions of people on the various delete cached require() (both npm packages and locally defined modules) related StackOverflow Q&A and put together a simple node/io.js module (with tests): https://www.npmjs.com/package/decache\n\n\n\nUsage is pretty simple:Install the module from npm:npm install decache --save-devIf you have any questions or need more examples, please create a GitHub issue:\nhttps://github.com/dwyl/decache/issuesThe solutions is to use:Find here some basic explanations for those who, like me, are a bit new in this:Suppose you have a dummy example.js file in the root of your directory:Then you require() like this:If you then add a line like this to example.js:And continue in the console, the module is not updated:That\'s when you can use delete require.cache[require.resolve()] indicated in luff\'s answer:So the cache is cleaned and the require() captures the content of the file again, loading all the current values.rewire is great for this use case, you get a new instance with each call. Easy dependency injection for node.js unit testing.rewire adds a special setter and getter to modules so you can modify their behaviour for better unit testing. You mayinject mocks for other modules or globals like process\nleak private variables\noverride variables within the module.\nrewire does not load the file and eval the contents to emulate node\'s require mechanism. In fact it uses node\'s own require to load the module. Thus your module behaves exactly the same in your test environment as under regular circumstances (except your modifications).Good news to all caffeine-addicts: rewire works also with Coffee-Script. Note that in this case CoffeeScript needs to be listed in your devDependencies.Yes, you can invalidate cache.  The cache is stored in an object called require.cache which you can access directly according to filenames (e.g. - /projects/app/home/index.js as opposed to ./home which you would use in a require(\'./home\') statement).  Our team has found the following module useful.  To invalidate certain groups of modules.  https://www.npmjs.com/package/node-resourceI\'d add to luff\'s answer one more line and change the parameter name:I couldn\'t neatly add code in an answer\'s comment. But I would use @Ben Barkay\'s answer then  add this to the require.uncache function.Say you\'ve required a module, then uninstalled it, then reinstalled the same module but used a different version that has a different main script in its package.json, the next require will fail because that main script does not exists because it\'s cached in Module._pathCacheFollowing two step procedure is working perfectly for me.After changing Model file i-e \'mymodule.js\' dynamically, you need to Delete precompiled model in mongoose model first then reload it using require-reload If it\'s for unit tests, another good tool to use is proxyquire. Everytime you proxyquire the module, it will invalidate the module cache and cache a new one. It also allows you to modify the modules required by the file that you are testing.