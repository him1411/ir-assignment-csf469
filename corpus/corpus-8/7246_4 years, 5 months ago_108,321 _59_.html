From time to time in Python, I see the block:What is the reason for the try-except-else to exist?I do not like that kind of programming, as it is using exceptions to perform flow control. However, if it is included in the language, there must be a good reason for it, isn\'t it?It is my understanding that exceptions are not errors, and that they should only be used for exceptional conditions (e.g. I try to write a file into disk and there is no more space, or maybe I do not have permission), and not for flow control. Normally I handle exceptions as:Or if I really do not want to return anything if an exception happens, then:"I do not know if it is out of ignorance, but I do not like that \n  kind of programming, as it is using exceptions to perform flow control."In the Python world, using exceptions for flow control is common and normal.Even the Python core developers use exceptions for flow-control and that style is heavily baked into the language (i.e.  the iterator protocol uses StopIteration to signal loop termination).In addition, the try-except-style is used to prevent the race-conditions inherent in some of the "look-before-you-leap" constructs.   For example, testing os.path.exists results in information that may be out-of-date by the time you use it.  Likewise, Queue.full returns information that may be stale.  The try-except-else style will produce more reliable code in these cases."It my understanding that exceptions are not errors, they should only\n  be used for exceptional conditions"In some other languages, that rule reflects their cultural norms as reflected in their libraries.  The "rule" is also based in-part on performance considerations for those languages.The Python cultural norm is somewhat different.  In many cases, you must use exceptions for control-flow.  Also, the use of exceptions in Python does not slow the surrounding code and calling code as it does in some compiled languages (i.e. CPython already implements code for exception checking at every step, regardless of whether you actually use exceptions or not).In other words, your understanding that "exceptions are for the exceptional" is a rule that makes sense in some other languages, but not for Python."However, if it is included in the language itself, there must be a\n  good reason for it, isn\'t it?"Besides helping to avoid race-conditions, exceptions are also very useful for pulling error-handling outside loops.   This is a necessary optimization in interpreted languages which do not tend to have automatic loop invariant code motion.Also, exceptions can simplify code quite a bit in common situations where the ability to handle an issue is far removed from where the issue arose.  For example, it is common to have top level user-interface code calling code for business logic which in turn calls low-level routines.  Situations arising in the low-level routines (such as duplicate records for unique keys in database accesses) can only be handled in top-level code (such as asking the user for a new key that doesn\'t conflict with existing keys).  The use of exceptions for this kind of control-flow allows the mid-level routines to completely ignore the issue and be nicely decoupled from that aspect of flow-control.There is a nice blog post on the indispensibility of exceptions here.Also, see this StackOverFlow answer: Are exceptions really for exceptional errors?"What is the reason for the try-except-else to exist?"The else-clause itself is interesting.  It runs when there is no exception but before the finally-clause.  That is its primary purpose.  Without the else-clause, the only option to run additional code before finalization would be the clumsy practice of adding the code to the try-clause.  That is clumsy because it risks\nraising exceptions in code that wasn\'t intended to be protected by the try-block.The use-case of running additional unprotected code prior to finalization doesn\'t arise very often.  So, don\'t expect to see many examples in published code.  It is somewhat rare.Another use-case for the else-clause is to perform actions that must occur when no exception occurs and that do not occur when exceptions are handled.  For example:Lastly, the most common use of an else-clause in a try-block is for a bit of beautification (aligning the exceptional outcomes and non-exceptional outcomes at the same level of indentation).  This use is always optional and isn\'t strictly necessary.A try block allows you to handle a expected error. The except block should only catch exceptions you are prepared to handle. If you handle an unexpected error, your code may do the wrong thing and hide bugs.An else clause will execute if there were no errors, and by not executing that code in the try block, you avoid catching an unexpected error. Again, catching an unexpected error can hide bugs.For example:The "try, except" suite has two optional clauses, else and finally. So it\'s actually try-except-else-finally.\'else\' will evaluate only if there is no exception from the try block. It allows us to simplify the more complicated code below:so if we compare an else to the alternative (which might create bugs) we see that it saves lines of code and have a more readable, maintainable, and less buggy code-base. finally will execute no matter what, even if another line is being evaluated with a return statement.It might help to break this down, in its most complex form, with comments. Assume this syntactically correct (but not runnable unless the names are defined) pseudo-code is in a function.For example:It is true that we could include the code in the else block in the try block instead, where it would run if there were no exceptions, but what if that code itself raises an exception of the kind we\'re catching? Leaving it in the try block would hide that bug.So we want to minimize lines of code in the try block\nto avoid catching exceptions we did not expect, under the principle that if our code fails, we want it to fail loudly. This is a best practice.Python doesn\'t subscribe to the idea that exceptions should only be used for exceptional cases, in fact the idiom is \'ask for forgiveness, not permission\'. This means that using exceptions as a routine part of your flow control is perfectly acceptable, and in fact, encouraged.This is generally a good thing, as working this way helps avoid some issues (as an obvious example, race conditions are often avoided), and it tends to make code a little more readable.Imagine you have a situation where you take some user input which needs to be processed, but have a default which is already processed. The try: ... except: ... else: ... structure makes for very readable code:Compare to how it might work in other languages:Note the advantages. There is no need to check the value is valid and parse it separately, they are done once. The code also follows a more logical progression, the main code path is first, followed by \'if it doesn\'t work, do this\'.The example is naturally a little contrived, but it shows there are cases for this structure.Is it a good practice to use try-except-else in python?The answer to this is that it is context dependent. If you do this:It demonstrates that you don\'t know Python very well. This functionality is encapsulated in the dict.get method:The try/except block is a much more visually cluttered and verbose way of writing what can be efficiently executing in a single line with an atomic method. There are other cases where this is true. However, that does not mean that we should avoid all exception handling. In some cases it is preferred to avoid race conditions. Don\'t check if a file exists, just attempt to open it, and catch the appropriate IOError. For the sake of simplicity and readability, try to encapsulate this or factor it out as apropos. Read the Zen of Python, understanding that there are principles that are in tension, and be wary of dogma that relies too heavily on any one of the statements in it.You should be careful about using the finally block, as it is not the same thing as using an else block in the try, except. The finally block will be run regardless of the outcome of the try except.As everyone has noted using the else block causes your code to be more readable, and only runs when an exception is not thrownWhenever you see this:Or even this:Consider this instead:OP, YOU ARE CORRECT.  The else after try/except in Python is ugly.  it leads to another flow-control object where none is needed:A totally clear equivalent is:This is far clearer than an else clause.  The else after try/except is not frequently written, so it takes a moment to figure what the implications are.Just because you CAN do a thing, doesn\'t mean you SHOULD do a thing.Lots of features have been added to languages because someone thought it might come in handy.  Trouble is, the more features, the less clear and obvious things are because people don\'t usually use those bells and whistles.Just my 5 cents here.  I have to come along behind and clean up a lot of code written by 1st-year out of college developers who think they\'re smart and want to write code in some uber-tight, uber-efficient way when that just makes it a mess to try and read / modify later.  I vote for readability every day and twice on Sundays.