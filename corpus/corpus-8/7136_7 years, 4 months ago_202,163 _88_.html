What is the difference between printf() and cout in C++?From the C++ FAQ:[15.1] Why should I use <iostream>  instead of the traditional <cstdio>?Increase type safety, reduce errors, allow extensibility, and provide inheritability.printf() is arguably not broken, and scanf() is perhaps livable despite being error prone, however both are limited with respect to what C++ I/O can do. C++ I/O (using << and >>) is, relative to C (using printf() and scanf()):On the other hand, printf is significantly faster, which may justify using it in preference to cout in very specific and limited cases. Always profile first. (See, for example, http://programming-designs.com/2009/02/c-speed-test-part-2-printf-vs-cout/)I\'m surprised that everyone in this question claims that std::cout is way better than printf, even if the question just asked for differences. Now, there is a difference - std::cout is C++, and printf is C (however, you can use it in C++, just like almost anything else from C). Now, I\'ll be honest here; both printf and std::cout have their advantages.Disclaimer: I\'m more experienced with C than C++, so if there is a problem with my answer, feel free to edit or comment.std::cout is extensible. I know that people will say that printf is extensible too, but such extension is not mentioned in the C standard (so you would have to use non-standard features - but not even common non-standard feature exists), and such extensions are one letter (so it\'s easy to conflict with an already-existing format).Unlike printf, std::cout depends completely on operator overloading, so there is no issue with custom formats - all you do is define a subroutine taking std::ostream as the first argument and your type as second. As such, there are no namespace problems - as long you have a class (which isn\'t limited to one character), you can have working std::ostream overloading for it.However, I doubt that many people would want to extend ostream (to be honest, I rarely saw such extensions, even if they are easy to make). However, it\'s here if you need it.As it could be easily noticed, both printf and std::cout use different syntax. printf uses standard function syntax using pattern string and variable-length argument lists. Actually, printf is a reason why C has them - printf formats are too complex to be usable without them. However, std::cout uses a different API - the operator << API that returns itself.Generally, that means the C version will be shorter, but in most cases it won\'t matter. The difference is noticeable when you print many arguments. If you have to write something like Error 2: File not found., assuming error number, and its description is placeholder, the code would look like this. Both examples work identically (well, sort of, std::endl actually flushes the buffer).While this doesn\'t appear too crazy (it\'s just two times longer), things get more crazy when you actually format arguments, instead of just printing them. For example, printing of something like 0x0424 is just crazy. This is caused by std::cout mixing state and actual values. I never saw a language where something like std::setfill would be a type (other than C++, of course). printf clearly separates arguments and actual type. I really would prefer to maintain the printf version of it (even if it looks kind of cryptic) compared to iostream version of it (as it contains too much noise).This is where the real advantage of printf lies. The printf format string is well... a string. That makes it really easy to translate, compared to operator << abuse of iostream. Assuming that the gettext() function translates, and you want to show Error 2: File not found., the code to get translation of the previously shown format string would look like this:Now, let\'s assume that we translate to Fictionish, where the error number is after the description. The translated string would look like %2$s oru %1$d.\\n. Now, how to do it in C++? Well, I have no idea. I guess you can make fake iostream which constructs printf that you can pass to gettext, or something, for purposes of translation. Of course, $ is not C standard, but it\'s so common that it\'s safe to use in my opinion.C has lots of integer types, and so does C++. std::cout handles all types for you, while printf requires specific syntax depending on an integer type (there are non-integer types, but the only non-integer type you will use in practice with printf is const char * (C string, can be obtained using to_c method of std::string)). For instance, to print size_t, you need to use %zd, while int64_t will require using %"PRIu64"d. The tables are available at http://en.cppreference.com/w/cpp/io/c/fprintf and http://en.cppreference.com/w/cpp/types/integer.Because printf uses C strings as opposed to C++ strings, it cannot print NUL byte without specific tricks. In certain cases it\'s possible to use %c with \'\\0\' as an argument, although that\'s clearly a hack.Update: It turns out that iostream is so slow that it\'s usually slower than your hard drive (if you redirect your program to file). Disabling synchronization with stdio may help, if you need to output lots of data. If the performance is a real concern (as opposed to writing several lines to STDOUT), just use printf.Everyone thinks that they care about performance, but nobody bothers to measure it. My answer is that I/O is bottleneck anyway, no matter if you use printf or iostream. I think that printf could be faster from a quick look into assembly (compiled with clang using the -O3 compiler option). Assuming my error example, printf example does way fewer calls than the cout example. This is int main with printf:You can easily notice that two strings, and 2 (number) are pushed as printf arguments. That\'s about it; there is nothing else. For comparison, this is iostream compiled to assembly. No, there is no inlining; every single operator << call means another call with another set of arguments.However, to be honest, this means nothing, as I/O is the bottleneck anyway. I just wanted to show that iostream is not faster because it\'s "type safe". Most C implementations implement printf formats using computed goto, so the printf is as fast as it can be, even without compiler being aware of printf (not that they aren\'t - some compilers can optimize printf in certain cases - constant string ending with \\n is usually optimized to puts).I don\'t know why you would want to inherit ostream, but I don\'t care. It\'s possible with FILE too.True, variable length argument lists have no safety, but that doesn\'t matter, as popular C compilers can detect problems with printf format string if you enable warnings. In fact, Clang can do that without enabling warnings.And I quote:In high level terms, the main differences are type safety (cstdio\n  doesn\'t have it), performance (most iostreams implementations are\n  slower than the cstdio ones) and extensibility (iostreams allows\n  custom output targets and seamless output of user defined types).People often claim that printf is much faster. This is largely a myth. I just tested it, with the following results:Conclusion: if you want only newlines, use printf; otherwise, cout is almost as fast, or even faster. More details can be found on my blog.To be clear, I\'m not trying to say that iostreams are always better than printf; I\'m just trying to say that you should make an informed decision based on real data, not a wild guess based on some common, misleading assumption.Update: Here\'s the full code I used for testing. Compiled with g++ without any additional options (apart from -lrt for the timing).One is a function that prints to stdout. The other is an object that provides several member functions and overloads of operator<< that print to stdout. There are many more differences that I could enumerate, but I\'m not sure what you are after.For me, the real differences which would make me go for \'cout\' rather than \'printf\' are:1) << operator can be overloaded for my classes.2) Output stream for cout can be easily changed to a file :\n(: copy paste :)3) I find cout more readable, especially when we have many parameters.One problem with cout is the formatting options. Formatting the data (precision, justificaton, etc.) in printf is easier.Two points not otherwise mentioned here that I find significant: 1) cout carries a lot of baggage if you\'re not already using the STL. It adds over twice as much code to your object file as printf. This is also true for string, and this is the major reason I tend to use my own string library. 2) cout uses overloaded << operators, which I find unfortunate. This can add confusion if you\'re also using the << operator for its intended purpose (shift left). I personally don\'t like to overload operators for purposes tangential to their intended use. Bottom line: I\'ll use cout (and string) if I\'m already using the STL. Otherwise, I tend to avoid it. With primitives, it probably doesn\'t matter entirely which one you use. I say where it gets usefulness is when you want to output complex objects.For example, if you have a class,Now the above might not seem all that great, but let\'s suppose you have to output this in multiple places in your code. Not only that, let\'s say you add a field "int d." With cout, you only have to change it in once place. However, with printf, you\'d have to change it in possibly a lot of places and not only that, you have to remind yourself which ones to output. With that said, with cout, you can reduce a lot of times spent with maintenance of your code and not only that if you re-use the object "Something" in a new application, you don\'t really have to worry about output.I would like say that extensibility lack of printf is not entirely true:\nIn C, it is true. But in C, there are no real classes.\nIn C++, it is possible to overload cast operator, so, overloading a char* operator and using printf like this:   can be possible, if Foo overload the good operator. Or if you made a good method. In short, printf is as extensible as cout for me.  Technical argument I can see for C++ streams (in general... not only cout.) are:Typesafety. (And, by the way, if I want to print a single \'\\n\' I use putchar(\'\\n\')... I will not use a nuke-bomb to kill an insect.).  Simpler to learn. (no "complicated" parameters to learn, just to use << and >> operators)  Work natively with std::string (for printf there is std::string::c_str(), but for scanf?)For printf I see:  Easier, or at least shorter (in term of characters written) complex formatting. Far more readable, for me (matter of taste I guess).  Better control of what the function made (Return how many characters where written and there is the %n formatter: "Nothing printed. The argument must be a pointer to a signed int, where the number of characters written so far is stored." (from printf - C++ Reference)Better debugging possibilities. For same reason as last argument.  My personal preferences go to printf (and scanf) functions, mainly because I love short lines, and because I don\'t think type problems on printing text are really hard to avoid.\nThe only thing I deplore with C-style functions is that std::string is not supported. We have to go through a char* before giving it to printf (with the std::string::c_str() if we want to read, but how to write?)  More differences:\n"printf" returns an integer value (equal to the number of characters printed) and "cout" does not return anythingAnd.cout << "y = " << 7; is not atomic.printf("%s = %d", "y", 7); is atomic.cout performs typechecking, printf doesn\'t.There\'s no iostream equivalent of "% d"Of course you can write "something" a bit better to keep maintenance:And a bit extended test of cout vs. printf, added a test of \'double\', if anyone wants to do more testing (Visual Studio 2008, release version of the executable):The result is:I\'d like to point out that if you want to play with threads in C++, if you use cout you can get some interesting results.Consider this code:Now, the output comes all shuffled. It can yield different results too, try executing several times:You can use printf to get it right, or you can use mutex.Have fun!Both are used to print values. They have completely different syntax. C++ has both, C\nonly has printf.TL;DR: Always do your own research, in regard of generated machine code size, performance, readability and coding time before trusting random comments online, including this one.I\'m no expert. I just happened to overhear two co-workers talking about how we should avoid using C++ in embedded systems because of performance issues. Well, interesting enough, I did a benchmark based on a real project task.In said task, we had to write some config to RAM. Something like:coffee=hot\n  sugar=none\n  milk=breast\n  mac=AA:BB:CC:DD:EE:FFHere\'s my benchmark programs (Yes, I know OP asked about printf(), not fprintf(). Try to capture the essence and by the way, OP\'s link points to fprintf() anyway.)C program:C++ program:I did my best to polish them before I looped them both 100,000 times. Here are the results:C program:C++ program:Object file size:Conclusion: On my very specific platform, with a very specific processor, running a very specific version of Linux kernel, to run a program which is compiled with a very specific version of GCC, in order to accomplish a very specific task, I would say the C++ approach is more suitable because it runs significantly faster and provide much better readability. On the other hand, C offers small footprint, in my opinion, means nearly nothing because program size is not of our concern.Remeber, YMMV.I\'m not a programmer, but I have been a human factors engineer. I feel a programming language should be easy to learn, understand and use, and this requires that it have a simple and consistent linguistic structure. Although all the languages is symbolic and thus, at its core, arbitrary, there are conventions and following them makes the language easier to learn and use.There are a vast number of functions in C++ and other languages written as function(parameter), a syntax that was originally used for functional relationships in mathematics in the pre-computer era. printf() follows this syntax and if the writers of C++ wanted to create any logically different method for reading and writing files they could have simply created a different function using a similar syntax.In Python we of course can print using the also fairly standard object.method syntax, i.e. variablename.print, since variables are objects, but in C++ they are not.I\'m not fond of the cout syntax because the << operator does not follow any rules. It is a method or function, i.e. it takes a parameter and does something to it. However it is written as though it were a mathematical comparison operator. This is a poor approach from a human factors standpoint.printf() is a function whereas cout is a variable.