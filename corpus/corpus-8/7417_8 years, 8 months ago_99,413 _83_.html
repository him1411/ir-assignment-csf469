In the MVVM pattern for WPF, handling dialogs is one of the more complex operations.  As your view model does not know anything about the view, dialog communication can be interesting.  I can expose an ICommand that when the view invokes it, a dialog can appear.Does anyone know of a good way to handle results from dialogs? I am speaking about windows dialogs such as MessageBox.One of the ways we did this was have an event on the viewmodel that the view would subscribe to when a dialog was required.This is OK, but it means that the view requires code which is something I would like to stay away from.I suggest forgoing the 1990\'s modal dialogs and instead implementing a control as an overlay (canvas+absolute positioning) with visibility tied to a boolean back in the VM. Closer to an ajax type control.This is very useful:as in:Here\'s how I have one implemented as a user control. Clicking on the \'x\' closes the control in a line of code in the usercontrol\'s code behind. (Since I have my Views in an .exe and ViewModels in a dll, I don\'t feel bad about code that manipulates UI.)You should use a mediator for this.\nMediator is a common design pattern also known as Messenger in some of its implementations.\nIt\'s a paradigm of type Register/Notify and enables your ViewModel and Views to communicate through a low-coupled messaging mecanism.You should check out the google WPF Disciples group, and just search for Mediator.\nYou will be much happy with the answers...You can however start with this:http://joshsmithonwpf.wordpress.com/2009/04/06/a-mediator-prototype-for-wpf-apps/Enjoy !Edit: you can see the answer to this problem with the MVVM Light Toolkit here:http://mvvmlight.codeplex.com/Thread/View.aspx?ThreadId=209338A good MVVM dialog should:Unfortunately, WPF doesn\'t provide these features. Showing a dialog requires a code-behind call to ShowDialog(). The Window class, which supports dialogs, can\'t be declared in XAML so it can\'t easily be databound to the DataContext.To solve this, I wrote a XAML stub control that sits in the logical tree and relays databinding to a Window and handles showing and hiding the dialog. You can find it here: http://www.codeproject.com/KB/WPF/XAMLDialog.aspxIt\'s really simply to use and doesn\'t require any strange changs to your ViewModel and doesn\'t require events or messages. The basic call looks like this: You probably want to add a style that sets Showing. I explain it in my article. I hope this helps you.I use this approach for dialogs with MVVM.All I have to do now is call the following from my view model.My current solution solves most of the issues you mentioned yet its completely abstracted from platform specific things and can be reused.\nAlso i used no code-behind only binding with DelegateCommands that implement ICommand. \nDialog is basically a View - a separate control that has its own ViewModel and it is shown from the ViewModel of the main screen but triggered from the UI via DelagateCommand binding.See full Silverlight 4 solution here Modal dialogs with MVVM and Silverlight 4I really struggled with this concept for a while when learning (still learning) MVVM.  What I decided, and what I think others already decided but which wasn\'t clear to me is this:My original thought was that a ViewModel should not be allowed to call a dialog box directly as it has no business deciding how a dialog should appear. Beacause of this I started thinking about how I could pass messages much like I would have in MVP (i.e. View.ShowSaveFileDialog()).  However, I think this is the wrong approach.It is OK for a ViewModel to call a dialog directly.  However, when you are testing a ViewModel , that means that the dialog will either pop up during your test, or fail all together (never really tried this).  So, what needs to happen is while testing is to use a "test" version of your dialog.  This means that for ever dialog you have, you need to create an Interface and either mock out the dialog response or create a testing mock that will have a default behaviour.You should already be using some sort of Service Locator or IoC that you can configure to provide you the correct version depending on the context.Using this approach, your ViewModel is still testable and depending on how you mock out your dialogs, you can control the behaviour.Hope this helps.Use a freezable commandThere are two good ways to do this, 1) a dialog service (easy, clean), and 2) view assisted.  View assisted provides some neat features, but is usually not worth it.a) a dialog service interface like via constructor or some dependency container:interface IDialogService\n{\n    Task ShowDialogAsync(DialogViewModel dlgVm);\n}b) Your implementation of IDialogService should open a window (or inject some control into the active window), create a view corresponding to the name of the given dlgVm type (use container registration or convention or a ContentPresenter with type associated DataTemplates).  ShowDialogAsync should create a TaskCompletionSource and return its .Task proptery.  The DialogViewModel class itself needs an event you can invoke in the derived class when you want to close, and watch in the dialog view to actually close/hide the dialog and complete the TaskCompletionSource.  b) To use, simply call await this.DialogService.ShowDialog(myDlgVm) on your instance of some DialogViewModel-derived class.  After await returns, look at properties you\'ve added on your dialog VM to determine what happened; you don\'t even need a callback.This has your view listening to an event on the viewmodel.  This could all be wrapped up into a Blend Behavior to avoid code behind and resource usage if you\'re so inclined (FMI, subclass the "Behavior" class to see a sort of Blendable attached property on steroids).  For now, we\'ll do this manually on each view:a) Create an OpenXXXXXDialogEvent with a custom payload (a DialogViewModel derived class).b) Have the view subscribe to the event in its OnDataContextChanged event.  Be sure to hide and unsubscribe if the old value != null and in the Window\'s Unloaded event.c) When the event fires, have the view open your view, which might be in a resource on your page, or you could locate it by convention elsewhere (like in the the dialog service approach).This approach is more flexible, but requires more work to use.  I don\'t use it much.  The one nice advantage are the ability to place the view physically inside a tab, for example.  I have used an algorithm to place it in the current user control\'s bounds, or if not big enough, traverse up the visual tree until a big enough container is found.  This allows dialogs to be close to the place they\'re actually used, only dim the part of the app related to the current activity, and let the user move around within the app without having to manually push dialogs away, even have multiple quasi-modal dialogs open on different tabs or sub-views.I\'ve implemented a Behavior that listens to a Message from the ViewModel. It\'s based on Laurent Bugnion solution, but since it doesn\'t use code behind and is more reusable, I think it\'s more elegant.How to make WPF behave as if MVVM is supported out of the boxI think that the handling of a dialog should be the responsibility of the view, and the view needs to have code to support that.If you change the ViewModel - View interaction to handle dialogs then the ViewModel is dependant on that implementation. The simplest way to deal with this problem is to make the View responsible for performing the task. If that means showing a dialog then fine, but could also be a status message in the status bar etc.My point is that the whole point of the MVVM pattern is to separate business logic from the GUI, so you shouldn\'t be mixing GUI logic (to display a dialog) in the business layer (the ViewModel).I had the same situation and wrapped up the MessageBox into a designer invisible control. The details are in my bloghttp://geekswithblogs.net/mukapu/archive/2010/03/12/user-prompts-messagebox-with-mvvm.aspxThe same can be extended to any modal dialogs, file browse control etc.An interesting alternative is to use Controllers which are responsible to show the views (dialogs).How this works is shown by the WPF Application Framework (WAF).Why not just raise an event in the VM and subscribe to the event in the view?  This would keep the application logic and the view seperate and still allow you to use a child window for dialogs.After spending some time with it, I finally came up with the following solution. A few key advantages of this approach are:Here\'s the implementation of IDialogService (goes into ViewModel project):Here\'s the presentation layer (goes into View project)I think the view could have code to handle the event from the view model.Depending on the event/scenario, it could also have an event trigger that subscribes to view model events, and one or more actions to invoke in response.I rolled my own window loader described in an answer to this question:Managing multiple WPF views in an applicationKarl Shifflett has created a sample application for showing dialog boxes using service approach and Prism InteractionRequest approach.I like the service approach - It\'s less flexible so users are less likely to break something :)\nIt\'s also consistent with the WinForms part of my application (MessageBox.Show)\nBut if you plan to show a lot of different dialogs, then InteractionRequest is a better way to go.http://karlshifflett.wordpress.com/2010/11/07/in-the-box-ndash-mvvm-training/I know it\'s an old question, but when I\xc2\xa0did this search, I find a lot of related question, but I did not find a really clear response. So I make my own implementation of a dialogbox/messagebox/popin, and I share it!\nI think it is "MVVM proof", and I try to make it simple and proper, but I am new to WPF, so feel free to comment, or even make pull request.https://github.com/Plasma-Paris/Plasma.WpfUtilsYou can use it like this:Or like this if you want more sophisticated popin :And it is showing things like this :I was pondering a similar problem when asking how the view model for a task or dialog should look like.My current solution looks like this:When the view model decides that user input is required, it pulls up a instance of SelectionTaskModel with the possible choices for the user. The infrastructure takes care of bringing up the corresponding view, which in proper time will call the Choose() function with the user\'s choice.EDIT: yes I agree this is not a correct MVVM approach and I am now using something similar to what is suggested by blindmeis.One of the way you could to this isIn your Main View Model (where you open the modal):And in your Modal Window View/ViewModel:XAML:ViewModel:or similar to what is posted here WPF MVVM: How to close a windowI struggled with the same problem. I have come up with a way to intercommunicate between the View and the ViewModel. You can initiate sending a message from the ViewModel to the View to tell it to show a messagebox and it will report back with the result. Then the ViewModel can respond to the result returned from the View.I demonstrate this in my blog: