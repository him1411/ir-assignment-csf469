I was curious about how other people use the this keyword. I tend to use it in constructors, but I may also use it throughout the class in other methods. Some examples:In a constructor:ElsewhereThere are several usages of this keyword in C#.You can avoid the first usage by not having member and local variables with the same name in scope, for example by following common naming conventions and using properties (Pascal case) instead of fields (camel case) to avoid colliding with local variables (also camel case). In C# 3.0 fields can be converted to properties easily by using auto-implemented properties.I don\'t mean this to sound snarky, but it doesn\'t matter.Seriously.Look at the things that are important: your project, your code, your job, your personal life. None of them are going to have their success rest on whether or not you use the "this" keyword to qualify access to fields. The this keyword will not help you ship on time. It\'s not going to reduce bugs, it\'s not going to have any appreciable effect on code quality or maintainability. It\'s not going to get you a raise, or allow you to spend less time at the office. It\'s really just a style issue. If you like "this", then use it. If you don\'t, then don\'t. If you need it to get correct semantics then use it. The truth is, every programmer has his own unique programing style. That style reflects that particular programmer\'s notions of what the "most aesthetically pleasing code" should look like. By definition, any other programmer who reads your code is going to have a different programing style. That means there is always going to be something you did that the other guy doesn\'t like, or would have done differently. At some point some guy is going to read your code and grumble about something. I wouldn\'t fret over it. I would just make sure the code is as aesthetically pleasing as possible according to your own tastes. If you ask 10 programmers how to format code, you are going to get about 15 different opinions. A better thing to focus on is how the code is factored. Are things abstracted right? Did I pick meaningful names for things? Is there a lot of code duplication? Are there ways I can simplify stuff? Getting those things right, I think, will have the greatest positive impact on your project, your code, your job, and your life. Coincidentally, it will probably also cause the other guy to grumble the least. If your code works, is easy to read, and is well factored, the other guy isn\'t going to be scrutinizing how you initialize fields. He\'s just going to use your code, marvel at it\'s greatness, and then move on to something else.I only use it when absolutely necessary, ie, when another variable is shadowing another.  Such as here:Or as Ryan Fox points out, when you need to pass this as a parameter.Personally, I try to always use this when referring to member variables.  It helps clarify the code and make it more readable.  Even if there is no ambiguity, someone reading through my code for the first time doesn\'t know that, but if they see this used consistently, they will know if they are looking at a member variable or not.I can\'t believe all of the people that say using it always is a "best practice" and such.Use "this" when there is ambiguity, as in Corey\'s example or when you need to pass the object as a parameter, as in Ryan\'s example. There is no reason to use it otherwise because being able to resolve a variable based on the scope chain should be clear enough that qualifying variables with it should be unnecessary.EDIT: The C# documentation on "this" indicates one more use, besides the two I mentioned, for the "this" keyword - for declaring indexersEDIT: @Juan: Huh, I don\'t see any inconsistency in my statements - there are 3 instances when I would use the "this" keyword (as documented in the C# documentation), and those are times when you actually need it. Sticking "this" in front of variables in a constructor when there is no shadowing going on is simply a waste of keystrokes and a waste of my time when reading it, it provides no benefit.I use it every time I refer to an instance variable, even if I don\'t need to. I think it makes the code more clear.I use it whenever StyleCop tells me to. StyleCop must be obeyed. Oh yes.Any time you need a reference to the current object.One particularly handy scenario is when your object is calling a function and wants to pass itself into it.Example:I tend to use it everywhere as well, just to make sure that it is clear that it is instance members that we are dealing with.I use it anywhere there might be ambiguity (obviously). Not just compiler ambiguity (it would be required in that case), but also ambiguity for someone looking at the code.Another somewhat rare use for the this keyword is when you need to invoke an explicit interface implementation from within the implementing class. Here\'s a contrived example:Here\'s when I use it:I don\'t use this for Private fields because I prefix private field variable names with an underscore (_). [C++]I agree with the "use it when you have to" brigade. Decorating code unnecessarily with this isn\'t a great idea because the compiler won\'t warn you when you forget to do it. This introduces potential confusion for people expecting this to always be there, i.e. they\'ll have to think about it.So, when would you use it? I\'ve just had a look around some random code and found these examples (I\'m not passing judgement on whether these are good things to do or otherwise):I use it when, in a function that accepts a reference to an object of the same type, I want to make it perfectly clear which object I\'m referring to, where.For example(vs)At a glance which AABB does right() refer to?  The this adds a bit of a clarifier.You should always use it, I use it to diferantiate private fields and parameters (because our naming conventions state that we don\'t use prefixes for member and parameter names (and they are based on information found on the internet, so I consider that a best practice))I got in the habit of using it liberally in Visual C++ since doing so would trigger IntelliSense ones I hit the \'>\' key, and I\'m lazy. (and prone to typos)But I\'ve continued to use it, since I find it handy to see that I\'m calling a member function rather than a global function.In Jakub \xc5\xa0turc\'s answer his #5 about passing data between contructors probably could use a little explanation. This is in overloading constructors and is the one case where use of this is mandatory. In the following example we can call the parameterized constructor from the parameterless constructor with a default parameter.I\'ve found this to be a particularly useful feature on occasion.I tend to underscore fields with _ so don\'t really ever need to use this. Also R# tends to refactor them away anyway...I pretty much only use this when referencing a type property from inside the same type.  As another user mentioned, I also underscore local fields so they are noticeable without needing this.I use it only when required, except for symmetric operations which due to single argument polymorphism have to be put into methods of one side:[C++]this is used in the assignment operator where most of the time you have to check and prevent strange (unintentional, dangerous, or just a waste of time for the program) things like:Your assignment operator will be written:The C++ compiler will silently lookup for a symbol if it does not find it immediately. Sometimes, most of the time, it is good:But sometimes, You just don\'t want the compiler to guess. You want the compiler to pick-up the right symbol and not another.For me, those times are when, within a method, I want to access to a member method or member variable. I just don\'t want some random symbol picked up just because I wrote printf instead of print. this->printf would not have compiled.The point is that, with C legacy libraries (\xc2\xa7), legacy code written years ago (\xc2\xa7\xc2\xa7), or whatever could happen in a language where copy/pasting is an obsolete but still active feature, sometimes, telling the compiler to not play wits is a great idea.These are the reasons I use this.(\xc2\xa7) it\'s still a kind of mystery to me, but I now wonder if the fact you include the <windows.h> header in your source, is the reason all the legacy C libraries symbols will pollute your global namespace(\xc2\xa7\xc2\xa7) realizing that "you need to include a header, but that including this header will break  your code because it uses some dumb macro with a generic name" is one of those russian roulette moments of a coder\'s lifeI use it to invoke Intellisense just like JohnMcG, but I\'ll go back and erase "this->" when I\'m done.  I follow the Microsoft convention of prefixing member variables with "m_", so leaving it as documentation would just be redundant.\'this.\' helps find members on \'this\' class with a lot of members (usually due to a deep inheritance chain).Hitting CTRL+Space doesn\'t help with this, because it also includes types; where-as \'this.\' includes members ONLY.I usually delete it once I have what I was after: but this is just my style breaking through.In terms of style, if you are a lone-ranger -- you decide; if you work for a company stick to the company policy (look at the stuff in source control and see what other people are doing). In terms of using it to qualify members, neither is right or wrong. The only wrong thing is inconsistency -- that is the golden rule of style. Leave the nit-picking others. Spend your time pondering real coding problems -- and obviously coding -- instead.It depends on the coding standard I\'m working under.  If we are using _ to denote an instance variable then "this" becomes redundant. If we are not using _ then I tend to use this to denote instance variable.@dicroce : "There IS a penalty associated with unnecessary verbosity" - what kind of a penalty? Certainly not a performance penalty.. Maybe the source file will take a larger amount of space on the hard drive? Or whaaat?1 - Common Java setter idiom:2 - When calling a function with this object as a parameterI use it every time I can.  I believe it makes the code more readable, and more readable code equals less bugs and more maintainability.When you are many developers working on the same code base, you need some code guidelines/rules. Where I work we\'ve desided to use \'this\' on fields, properties and events.To me it makes good sense to do it like this, it makes the code easier to read when you differentiate between class-variables and method-variables.There is one use that has not already been mentioned in C++, and that is not to refer to the own object or disambiguate a member from a received variable.You can use this to convert a non-dependent name into an argument dependent name inside template classes that inherit from other templates.Templates are compiled with a two pass mechanism. During the first pass, only non-argument dependent names are resolved and checked, while dependent names are checked only for coherence, without actually substituting the template arguments. At that step, without actually substituting the type, the compiler has almost no information of what base<T> could be (note that specialization  of the base template can turn it into completely different types, even undefined types), so it just assumes that it is a type. At this stage the non-dependent call f that seems just natural to the programmer is a symbol that the compiler must find as a member of derived or in enclosing namespaces --which does not happen in the example-- and it will complain.The solution is turning the non-dependent name f into a dependent name. This can be done in a couple of ways, by explicitly stating the type where it is implemented (base<T>::f --adding the base<T> makes the symbol dependent on T and the compiler will just assume that it will exist and postpones the actual check for the second pass, after argument substitution.The second way, much sorter if you inherit from templates that have more than one argument, or long names, is just adding a this-> before the symbol. As the template class you are implementing does depend on an argument (it inherits from base<T>) this-> is argument dependent, and we get the same result: this->f is checked in the second round, after template parameter substitution.