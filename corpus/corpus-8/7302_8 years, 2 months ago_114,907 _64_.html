I\'m working on a codebase that is known to only run on windows and be compiled under Visual Studio (it integrates tightly with excel so it\'s not going anywhere). I\'m wondering if I should go with the traditional include guards or use #pragma once for our code. I would think letting the compiler deal with #pragma once will yield faster compiles and is less error prone when coping and pasting. It is also slightly less ugly ;)Note: to get the faster compile times we could use Redundant Include Guards but that adds a tight coupling between the included file and the including file. Usually it\'s ok because the guard should be based on the file name and would only change if you needed to change in the include name anyways.I don\'t think it will make a significant difference in compile time but #pragma once is very well supported across compilers but not actually part of the standard.  The preprocessor may be a little faster with it as it is more simple to understand your exact intent.#pragma once is less prone to making mistakes and it is less code to type.To speed up compile time more just forward declare instead of including in .h files when you can. I prefer to use #pragma once.See this wikipedia article about the possibility of using both. I just wanted to add to this discussion that I am just compiling on VS and GCC, and used to use include guards. I have now switched to #pragma once, and the only reason for me is not performance or portability or standard as I don\'t really care what is standard as long as VS and GCC support it, and that is that:#pragma once reduces possibilities for bugs.It is all too easy to copy and paste a header file to another header file, modify it to suit ones needs, and forget to change the name of the include guard. Once both are included, it takes you a while to track down the error, as the error messages aren\'t necessarily clear.If your #include search path is sufficiently complicated, the compiler may be unable to tell the difference between two headers with the same basename (e.g. a/foo.h and b/foo.h), so a #pragma once in one of them will suppress both.  It may also be unable to tell that two different relative includes (e.g. #include "foo.h" and #include "../a/foo.h" refer to the same file, so #pragma once will fail to suppress a redundant include when it should have.This also affects the compiler\'s ability to avoid rereading files with #ifndef guards, but that is just an optimization.  With #ifndef guards, the compiler can safely read any file it isn\'t sure it has seen already; if it\'s wrong, it just has to do some extra work.  As long as no two headers define the same guard macro, the code will compile as expected.  And if two headers do define the same guard macro, the programmer can go in and change one of them.#pragma once has no such safety net -- if the compiler is wrong about the identity of a header file, either way, the program will fail to compile.  If you hit this bug, your only options are to stop using #pragma once, or to rename one of the headers.  The names of headers are part of your API contract, so renaming is probably not an option.(The short version of why this is unfixable is that neither the Unix nor the Windows filesystem API offer any mechanism that guarantees to tell you whether two absolute pathnames refer to the same file.  If you are under the impression that inode numbers can be used for that, sorry, you\'re wrong.)(Historical note: The only reason I didn\'t rip #pragma once and #import out of GCC when I had the authority to do so, ~12 years ago, was Apple\'s system headers relying on them.  In retrospect, that shouldn\'t have stopped me.)(Since this has now come up twice in the comment thread: The GCC developers did put quite a bit of effort into making #pragma once as reliable as possible; see GCC bug report 11569.  However, the implementation in current versions of GCC can still fail under plausible conditions, such as build farms suffering from clock skew.  I do not know what any other compiler\'s implementation is like, but I would not expect anyone to have done better.)Until the day #pragma once becomes standard (that\'s not currently a priority for the future standards), I suggest you use it AND use guards, this way:The reasons are :Using the two together you get the best of each compiler for this.Now, if you don\'t have some automatic script to generate the guards, it might be more convenient to just use #pragma once. Just know what that means for portable code. (I\'m using VAssistX to generate the guards and pragma once quickly)You should almost always think your code in a portable way (because you don\'t know what the future is made of) but if you really think that it\'s not meant to be compiled with another compiler (code for very specific embedded hardware for example) then you should just check your compiler documentation about #pragma once to know what you\'re really doing.If you\'re positive that you will never use this code in a compiler that doesn\'t support it (Windows/VS, GCC, and Clang are examples of compilers that do support it), then you can certainly use #pragma once without worries.You can also just use both (see example below), so that you get portability and compilation speedup on compatible systems#pragma once is shorter than an include guard, less error prone, supported by most compilers, and some say that it compiles faster (which is not true [any longer]).But I still suggest you go with standard #ifndef include guards.Consider a contrived class hierarchy like this where each of the classes A, B, and C lives inside its own file:Now let\'s assume you are writing tests for your classes and you need to simulate the behaviour of the really complex class B. One way to do this would be to write a mock class using for example google mock and put it inside a directory mocks/b.h. Note, that the class name hasn\'t changed but it\'s only stored inside a different directory. But what\'s most important is that the include guard is named exactly the same as in the original file b.h.With this approach you can mock the behaviour of class B without touching the original class or telling C about it. All you have to do is put the directory mocks/ in the include path of your complier.If you would have used #pragma once, you would get a name clash because it cannot protect you from defining the class B twice, once the original one and once the mocked version.I generally don\'t bother with #pragma once as my code sometimes does have to compile with something other than MSVC or GCC (compilers for embedded systems don\'t always have the #pragma).So I have to use #include guards anyway.  I could also use #pragma once as some answers suggest, but there doesn\'t seem to be much reason and it will often cause needless warnings on the compilers that don\'t support it.  I\'m not sure what time savings the pragma might bring.  I\'ve heard that compilers generally already recognize when a header has nothing but comments outside of the guard macros and will do the #pragma once equivalent in that case (ie., never processing the file again). But I\'m not sure if it\'s true or just a case of compilers could do this optimization.In either case, it\'s just easier for me to use #include guards which will work everywhere and not worry about it further.I think the first thing you should do is check to see if this is really going to make a difference, ie. you should first test the performance.  One of the searches in google threw up this.In the results page, the columns are sligthly off for me, but it\'s clear that at least up to VC6 microsoft was not implementing the include guard optimisations that the other tools were using.  Where the include guard was internal it took 50 times as long compared with where the include guard was external (external include guards are at least as good as #pragma).  But let\'s consider the possible affect of this:According to the tables presented, the time to open the include and check it is 50 times that of a #pragma equivalent.  But the actual time to do so was measured at 1 microsecond per file back in 1999!So, how many duplicate headers will a single TU have?  This depends on your style, but if we say that an average TU has 100 duplicates then in 1999 we\'re potentially paying 100 microseconds per TU.  With HDD improvements this is probably significantly lower by now, but even then with precompiled headers and correct dependency tracking the total cumulative cost of this for a project is almost certainly an insigificant part of your build time.Now, on the flip side, as unlikely as it may be, if you ever move to a compiler that doesn\'t support #pragma once then consider how much time will it take to update your entire source base to have include guards rather than #pragma?There is no reason that Microsoft could not implement an include guard optimisation in the same way that GCC and every other compiler does (actually can anybody confirm if their more recent versions implement this?).  IMHO, #pragma once does very little other than limit your choice of alternative compiler.There\'s an related question to which I answered:#pragma once does have one drawback (other than being non-standard) and that is if you have the same file in different locations (we have this because our build system copies files around) then the compiler will think these are different files.I\'m adding the answer here too in case someone stumbles over this question and not the other.After engaging in an extended discussion about the supposed performance tradeoff between #pragma once and #ifndef guards vs. the argument of correctness or not (I was taking the side of #pragma once based on some relatively recent indoctrination to that end), I decided to finally test the theory that #pragma once is faster because the compiler doesn\'t have to try to re-#include a file that had already been included.For the test, I automatically generated 500 header files with complex interdependencies, and had a .c file that #includes them all. I ran the test three ways, once with just #ifndef, once with just #pragma once, and once with both. I performed the test on a fairly modern system (a 2014 MacBook Pro running OSX, using XCode\'s bundled Clang, with the internal SSD).First, the test code:And now, my various test runs:As you can see, the versions with #pragma once were indeed slightly faster to preprocess than the #ifndef-only one, but the difference was quite negligible, and would be far overshadowed by the amount of time that actually building and linking the code would take. Perhaps with a large enough codebase it might actually lead to a difference in build times of a few seconds, but between modern compilers being able to optimize #ifndef guards, the fact that OSes have good disk caches, and the increasing speeds of storage technology, it seems that the performance argument is moot, at least on a typical developer system in this day and age. Older and more exotic build environments (e.g. headers hosted on a network share, building from tape, etc.) may change the equation somewhat but in those circumstances it seems more useful to simply make a less fragile build environment in the first place.The fact of the matter is, #ifndef is standardized with standard behavior whereas #pragma once is not, and #ifndef also handles weird filesystem and search path corner cases whereas #pragma once can get very confused by certain things, leading to incorrect behavior which the programmer has no control over. The main problem with #ifndef is programmers choosing bad names for their guards (with name collisions and so on) and even then it\'s quite possible for the consumer of an API to override those poor names using #undef - not a perfect solution, perhaps, but it\'s possible, whereas #pragma once has no recourse if the compiler is erroneously culling an #include.Thus, even though #pragma once is demonstrably (slightly) faster, I don\'t agree that this in and of itself is a reason to use it over #ifndef guards.EDIT: Thanks to feedback from @LightnessRacesInOrbit I\'ve increased the number of header files and changed the test to only run the preprocessor step, eliminating whatever small amount of time was being added in by the compile and link process (which was trivial before and nonexistent now). As expected, the differential is about the same.#pragma once allows the compiler to skip the file completely when it occurs again - instead of parsing the file until it reaches the #include guards.As such, the semantics are a little different, but they are identical if they are used they way they are intended to be used.Combining both is probably the safest route to go, as in the worst case (a compiler flagging unknown pragmas as actual errors, not just warnings) you would just to have to remove the #pragma\'s themselves.When you limit your platforms to, say "mainstream compilers on the desktop", you could safely omit the #include guards, but I feel uneasy on that, too.OT: if you have other tips/experiences to share on speeding up builds, I\'d be curious. For those who would like to use #pragma once and include guards together: If you are not using MSVC, then you won\'t get much optimization from #pragma once.And you shouldn\'t put "#pragma once" into a header that supposed to be included multiple times with each inclusion possibly having a different effect.Here is a detailed discussion with examples about #pragma once usage.Atop explanation by Konrad Kleine above.A brief summary:Now, compiler looks, for this code-snippet at the beginning of the file, and skips it from being included (if already included once). This definitely will reduce the compilation-time (on an average and in huge-system). However, in case of mocks/test environment, will make the test-cases implementation difficult, due to circular etc dependencies.This definitely will add to the compilation time (as needs to rectified and re-run). Also, as it works on the basis of including the file, based on the "XYZ_H" defined-state, and still complains, if not able to get all the definitions.Therefore, to avoid situations like this, we should use, as;i.e. the combination of both.