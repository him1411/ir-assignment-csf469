This question already has an answer here:I love vim, but one common gotcha is:Obviously the workflow is delete first, yank second.  But it would be reeeeeaaaaaalllly nice if I didn\'t have to.  Anyone have a trick for this? Does vim have a paste buffer that works well, or is there a .vimrc setting I can change?Pass to the _ register, the black hole.To delete a line without sticking it in the registers:See also :help registers.It\'s probably safest, if you want to paste something over and over again, to yank it into a "named" register.Yanks a line into the a register.  Paste it with "ap.Your yanked line should still be  in the register 0. So doto paste the line (and delete whenever you want)All yank and delete operations write to the unnamed register by default. However, the most recent yank and most recent delete are always stored (separately) in the numbered registers. The register 0 holds the most recent yank. The registers 1-9 hold the 9 most recent deletes (with 1 being the most recent). In other words, a delete overwrites the most recent yank in the unnamed register, but it\'s still there in the 0 register. The blackhole-register trick ("_dd) mentioned in the other answers works because it prevents overwriting the unnamed register, but it\'s not necessary.You reference a register using double quotes, so pasting the most recently yanked text can be done like this:This is an excellent reference:another possibility is:yank your lines like you would do normallygo to where you want to paste them, enter visual line mode (V)select the lines you want to replacehit p to paste your lines.this also has the added benefit, that the buffer is "swapped" with the replaced contentsI use the following mapping to make deleting to the black hole register a bit easier:This way, dd becomes Rd and d$ becomes R$. Note that R is normally bound to enter replace mode, but I found that I never used that, so it was the easisest to remember key for a "really remove" feature.For your specific question, as asked, couldn\'t you just swap the order of the last 2 steps?Granted, I usually use a named register for this type of thing, but sometimes the solution is simpler than what first comes to mind.I wrote this plugin (yankstack.vim) to solve this problem. It gives you something like Emacs\'s kill ring for vim. You can yank or delete multiple things, do a paste, and then cycle back and forth through your history of yanked/killed text. I find its easier than having to remember what register I yanked something into.In my .vimrc, I have these mappings:which let me hit ALT-p or ALT-SHIFT-p to cycle back and forth through my paste history. You can also try out the following script: ReplaceWithRegister at vim.org/scripts/I find all these key combos cumbersome.  Instead, I wrote a function to toggle on and off vim\'s "side effect" behavior of overwriting buffers from delete operations.  That way you can just toggle it off, delete freely, then toggle back on when you\'re done.  See my answer here: https://stackoverflow.com/a/12649560/778118To use it just put it in your .vimrcYou could use registers: "<register><command>E.g.:This yanks a line into register a, deletes a different line, and then pastes register aIf you are an evil user, you may consider remapping X to do the equivalent of "_d. However, perfecting the implementation was a little tricky for me. Nonetheless, I found that integrates very nicely. For example, typing XX will function analogously to dd, as will X$ to d$, X0 to d0, etc...If you are curious as to how it works, "95" represents the "_ register, so it simply reroutes your call to delete as if "_ had been the register pressed.The trick is that you know you want to grab something and move, and you are using the \'lazy\' first register (which gets replaced by whatever you just deleted).You need to learn to "cut" in vim.Before deleting, specify any register different than the " one. Tip: check out your registers with :regnow, you select a new register by pressing " before any command (in command mode, obviously)done. this also has the advantage of solving the usecase: delete 5 different things from one place, and each piece goes to a different destination... just put one in "1 another in "2 and so on... go to each destination and paste.