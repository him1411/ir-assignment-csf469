How do I get a human-readable file size in bytes abbreviation using .NET?Example:\nTake input 7,326,629 and display 6.98 MBThis is not the most efficient way to do it, but it\'s easier to read if you are not familiar with log maths, and should be fast enough for most scenarios.using Log to solve the problem....Also in c#, but should be a snap to convert. Also I rounded to 1 decimal place for readability. Basically Determine the number of decimal places in Base 1024 and then divide by 1024^decimalplaces.And some samples of use and output:Edit:\n Was pointed out that I missed a math.floor, so I incorporated it. (Convert.ToInt32 uses rounding, not truncating and that\'s why Floor is necessary.) Thanks for the catch.Edit2: \n There were a couple of comments about negative sizes and 0 byte sizes, so I updated to handle those 2 cases. From: http://www.pinvoke.net/default.aspx/shlwapi/StrFormatByteSize.htmlA tested and significantly optimized version of the requested function is posted here:C# Human Readable File Size - Optimized FunctionSource code:One more way to skin it, without any kind of loops and with negative size support (makes sense for things like file size deltas):And here is the test suite:I like to use the following method (it supports up to terabytes, which is enough for most cases, but it can easily be extended):Please keep in mind that this is written for C# 6.0 (2015), so it might need a little editing for earlier versions.Checkout the ByteSize library. It\'s the System.TimeSpan for bytes!It handles the conversion and formatting for you.It also does string representation and parsing.Mixture of all solutions :-)There is one open source project which can do that and much more. http://humanizr.net/#bytesizehttps://github.com/MehdiK/HumanizerIf you are trying to match the size as shown in Windows Explorer\'s detail view, this is the code you want:This will not only match Explorer exactly but will also provide the strings translated for you and match differences in Windows versions (for example in Win10, K = 1000 vs. previous versions K = 1024).I assume you\'re looking for "1.4 MB" instead of "1468006 bytes"?I don\'t think there is a built-in way to do that in .NET. You\'ll need to just figure out which unit is appropriate, and format it.Edit: Here\'s some sample code to do just that:http://www.codeproject.com/KB/cpp/formatsize.aspxMy 2 cents:One more approach, for what it\'s worth. I liked @humbads optimized solution referenced above, so have copied the principle, but I\'ve implemented it a little differently.I suppose it\'s debatable as to whether it should be an extension method (since not all longs are necessarily byte sizes), but I like them, and it\'s somewhere I can find the method when I next need it!Regarding the units, I don\'t think I\'ve ever said \'Kibibyte\' or \'Mebibyte\' in my life, and while I\'m skeptical of such enforced rather than evolved standards, I suppose it\'ll avoid confusion in the long term.Like @NET3\'s solution. Use shift instead of division to test the range of bytes, because division takes more CPU cost.