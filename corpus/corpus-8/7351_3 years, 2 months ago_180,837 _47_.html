I am messing around with React.js for the first time and cannot find a way to show or hide something on a page via click event.  I am not loading any other library to the page, so I am looking for some native way using the React library.  This is what I have so far.  I would like to show the results div when the click event fires.  The key is to update the state of the component in the click handler using setState. When the state changes get applied, the render method gets called again with the new state:http://jsfiddle.net/kb3gN/15084/Here is an alternative syntax for the ternary operator is equivalent toLean why.Also alternative syntax for the (arguably) more performant solution with display: none;However, if you overuse display: none, this leads to DOM pollution and ultimately slows down your application.with the newest version react 0.11 you can also just return null to have no content rendered.https://facebook.github.io/react/blog/2014/07/13/react-v0.11-rc1.html#rendering-to-nullI created a small component that handles this for you: https://www.npmjs.com/package/react-toggle-displayIt sets the style attribute to display: none !important based on the hide or show props. Example usage:Here is my approach using ES6. While accepted answer is correct, it\'s quite outdated.Demo: http://jsfiddle.net/kb3gN/16688/It\'s better to render some element only if needed rather than adding some css classes with display: none. If you set display: none - element is still rendered by react and added to DOM - that can have bad impact on performance. Imagine you have page with tabs, where every tab have a lot of content and where only 1 tab is opened at once. It\'s much better to hold in the DOM only those elements that are supposed to be displayed.In code above, to achieve this, I\'m using code like:That will render SomeElement only if opened is true. It works because of the way how JavaScript resolve logical conditions:You set a boolean value in the state (e.g. \'show)\', and then do:This is a nice way to make use of the virtual DOM:React:CSSFiddle hereIn some cases higher order component might be useful:Create higher order component:Extend your own component:Then you can use it like this:This reduces a bit boilerplate and enforces sticking to naming conventions, however please be aware of that MyComp will still be instantiated - the way to omit is was mentioned earlier:{ !hidden && <MyComp ... /> }If you would like to see how to TOGGLE the display of a component checkout this fiddle.http://jsfiddle.net/mnoster/kb3gN/16387/Best practice is below according to the documentation:Render the element only when the state is valid.I start with this statement from the React team:In React, you can create distinct components that encapsulate behavior\n  you need. Then, you can render only some of them, depending on the\n  state of your application.Conditional rendering in React works the same way conditions work in\n  JavaScript. Use JavaScript operators like if or the conditional\n  operator to create elements representing the current state, and let\n  React update the UI to match them.You basically need to show the component when the button gets clicked, you can do it two ways, using pure React or using CSS, using pure React way, you can do something like below code in your case, so in the first run, results are not showing as hideResults is true, but by clicking on the button, state gonna change and hideResults is false and the component get rendered again with the new value conditions, this is very common use of changing component view in React...If you want to do further study in conditional rendering in React, have a look here.There are several great answers already, but I don\'t think they\'ve been explained very well and several of the methods given contain some gotchas that might trip people up. So I\'m going to go over the three main ways (plus one off-topic option) to do this and explain the pros and cons. I\'m mostly writing this because Option 1 was recommended a lot and there\'s a lot of potential issues with that option if not used correctly.I don\'t like this method unless you\'re only going to render the component one time and leave it there. The issue is it will cause react to create the component from scratch every time you toggle the visibility.\nHere\'s the example. LogoutButton or LoginButton are being conditionally rendered in the parent LoginControl. If you run this you\'ll notice the constructor is getting called on each button click. https://codepen.io/Kelnor/pen/LzPdpN?editors=1111Now React is pretty quick at creating components from scratch. However, it still has to call your code when creating it. So if your constructor, componentDidMount, render, etc code is expensive, then it\'ll significantly slow down showing the component. It also means you cannot use this with stateful components where you want the state to be preserved when hidden (and restored when displayed.) The one advantage is that the hidden component isn\'t created at all until it\'s selected. So hidden components won\'t delay your initial page load. There may also be cases where you WANT a stateful component to reset when toggled. In which case this is your best option.This creates both components once. Then short circuits the rest of the render code if the component is hidden. You can also short circuit other logic in other methods using the visible prop. Notice the console.log in the codepen page. https://codepen.io/Kelnor/pen/YrKaWZ?editors=0011Now, if the initialization logic is quick and the children are stateless, then you won\'t see a difference in performance or functionality. However,  why make React create a brand new component every toggle anyway? If the initialization is expensive however, Option 1 will run it every time you toggle a component which will slow the page down when switching. Option 2 will run all of the component\'s inits on first page load. Slowing down that first load. Should note again. If you\'re just showing the component one time based on a condition and not toggling it, or you want it to reset when toggledm, then Option 1 is fine and probably the best option.If slow page load is a problem however, it means you\'ve got expensive code in a lifecycle method and that\'s generally not a good idea. You can, and probably should, solve the slow page load by moving the expensive code out of the lifecycle methods. Move it to an async function that\'s kicked off by ComponentDidMount and have the callback put it in a state variable with setState(). If the state variable is null and the component is visible then have the render function return a placeholder. Otherwise render the data. That way the page will load quickly and populate the tabs as they load. You can also move the logic into the parent and push the results to the children as props. That way you can prioritize which tabs get loaded first. Or cache the results and only run the logic the first time a component is shown.Class hiding is probably the easiest to implement. As mentioned you just create a CSS class with display: none and assign the class based on prop. The downside is the entire code of every hidden component is called and all hidden components are attached to the DOM. (Option 1 doesn\'t create the hidden components at all. And Option 2 short circuits unnecessary code when the component is hidden and removes the component from the DOM completely.) It appears this is faster at toggling visibility according some tests done by commenters on other answers but I can\'t speak to that.This one won\'t work for every application and it\'s off topic because it\'s not about hiding components, but it might be a better solution for some use cases than hiding. Let\'s say you have tabs. It might be possible to write one React Component and just use the props to change what\'s displayed in the tab. You could also save the JSX to state variables and use a prop to decide which JSX to return in the render function. If the JSX has to be generated then do it and cache it in the parent and send the correct one as a prop. Or generate in the child and cache it in the child\'s state and use props to select the active one.