I know that randomized UUIDs have a very, very, very low probability for collision in theory, but I am wondering, in practice, how good is Java 5\'s randomUUID() in terms of not having collision?  Does anybody have any experience to share? UUID uses java.security.SecureRandom, which is supposed to be "cryptographically strong". While the actual implementation is not specified and can vary between JVMs (meaning that any concrete statements made are valid only for one specific JVM), it does mandate that the output must pass a statistical random number generator test.It\'s always possible for an implementation to contain subtle bugs that ruin all this (see OpenSSH key generation bug) but I don\'t think there\'s any concrete reason to worry about Java UUIDs\'s randomness.Wikipedia has a very good answer \nhttp://en.wikipedia.org/wiki/Universally_unique_identifier#Collisionsthe number of random version 4 UUIDs which need to be generated in order to have a 50% probability of at least one collision is 2.71 quintillion, computed as follows:...This number is equivalent to generating 1 billion UUIDs per second for about 85 years, and a file containing this many UUIDs, at 16 bytes per UUID, would be about 45 exabytes, many times larger than the largest databases currently in existence, which are on the order of hundreds of petabytes....Thus, for there to be a one in a billion chance of duplication, 103 trillion version 4 UUIDs must be generated.Does anybody have any experience to share? There are 2^122 possible values for a type-4 UUID.  (The spec says that you lose 2 bits for the type, and a further 4 bits for a version number.)Assuming that you were to generate 1 million random UUIDs a second, the chances of a duplicate occurring in your lifetime would be vanishingly small.  (And to detect the duplicate, you\'d have to solve the problem of comparing 1 million new UUIDs per second against all of the UUIDs you have previously generated!)The chances that anyone has experienced (i.e. actually noticed) a duplicate in real life are even smaller than vanishingly small ... because of the practical difficulty of looking for collisions.Now of course, you will typically be using a pseudo-random number generator, not a source of truly random numbers.  But I think we can be confident that if you are using a creditable provider for your cryptographic strength random numbers, then it will be cryptographic strength, and the probability of repeats will be the same as for an ideal (non-biased) random number generator.However, if you were to use a JVM with a "broken" crypto- random number generator, all bets are off.  (And that might include some of the workarounds for "shortage of entropy" problems on some systems.  Or the possibility that someone has tinkered with your JRE, either on your system or upstream.)I\'m not an expert, but I\'d assume that enough smart people looked at Java\'s random number generator over the years. Hence, I\'d also assume that random UUIDs are good. So you should really have the theoretical collision probability (which is about 1 : 3 \xc3\x97 10^38 for all possible UUIDs. Does anybody know how this changes for random UUIDs only? Is it 1/(16*4) of the above?)From my practical experience, I\'ve never seen any collisions so far. I\'ll probably have grown an astonishingly long beard the day I get my first one ;)The original generation scheme for UUIDs was to concatenate the UUID version with the MAC address of the computer that is generating the UUID, and with the number of 100-nanosecond intervals since the adoption of the Gregorian calendar in the West. By representing a single point in space (the computer) and time (the number of intervals), the chance of a collision in values is effectively nil.I play at lottery last year, and I\'ve never won ....\nbut it seems that there lottery has winners ...doc : http://tools.ietf.org/html/rfc4122Type 1  : not implemented. collision are possible if the uuid is generated at the same moment. impl can be artificially a-synchronize in order to bypass this problem.Type 2 : never see a implementation.Type 3 : md5 hash : collision possible (128 bits-2 technical bytes)Type 4 : random : collision possible (as lottery). note that the jdk6 impl dont use a "true" secure random because the PRNG algorithm is not choose by developer and you can force system to use a "poor" PRNG algo. So your UUID is predictable.Type 5 : sha1 hash : not implemented : collision possible (160 bit-2 technical  bytes)At a former employer we had a unique column that contained a random uuid. We got a collision the first week after it was deployed. Sure, the odds are low but they aren\'t zero.  That is why Log4j 2 contains UuidUtil.getTimeBasedUuid. It will generate a UUID that is unique for 8,925 years so long as you don\'t generate more than 10,000 UUIDs/millisecond on a single server.We have been using the Java\'s random UUID in our application for more than one year and that to very extensively. But we never come across of having collision.I\'m not an expert but since everyone talked about theory I think I can add something to the discussion by giving a practical example. In my database I have around 4.5 million UUIDs generated using Java 8 UUID.randomUUID(). The following ones are just some I found out:"c0f55f62-b990-47bc-8caa-f42313669948""c0f55f62-e81e-4253-8299-00b4322829d5""c0f55f62-4979-4e87-8cd9-1c556894e2bb"\n"b9ea2498-fb32-40ef-91ef-0ba00060fe64""be87a209-2114-45b3-9d5a-86d00060fe64"\n"4a8a74a6-e972-4069-b480-bdea1177b21f""12fb4958-bee2-4c89-8cf8-edea1177b21f"If it was truly random, the probability of having these kind of similar UUIDs would be considerably low, since we\'re considering only 4.5 million entries. So, although this function is good, in terms of not having collisions, for me it doesn\'t seem that good as it would be in theory.If you really want to be sure that there will be absolutely no collision just add the current milliseconds since epoch in front of the UUID-String e.g.So in order to have a 50% chance of collision per millisecond you would need to create 2.71 quintillion in just one millisecond which is very, very unlikely!In fact, it would still be relatively secure to just use some of the first digits of the UUID. I have tested the security of following string:I have tested, how many of these Strings I would need to create to get a collision. At average a collision would occur after creating about 5163 Strings! The minimal number of Strings I needed to create to produce a collision was 53 (I have tested it 100000 times). However, if I wanted to do the same test with a String of length 8, I couldn\'t even compute it once (I gave it 20min time).