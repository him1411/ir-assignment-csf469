I have a problem with a Java application running under Linux.When I launch the application, using the default maximum heap size (64mb), I see using the tops application that 240 MB of virtual Memory are allocated to the application.  This creates some issues with some other software on the computer, which is relatively resource-limited.The reserved virtual memory will not be used anyway, as far as I understand, because once we reach the heap limit an OutOfMemoryError is thrown.  I ran the same application under windows and I see that the Virtual Memory size and the Heap size are similar.Is there anyway that I can configure the Virtual Memory in use for a Java process under Linux?Edit 1: The problem is not the Heap.  The problem is that if I set a Heap of 128M, for example, still linux allocates 210 MB of Virtual Memory, which is not needed, ever.**Edit 2: Using ulimit -v allows limiting the amount of virtual memory.  If the size set is below 204 MB, then the application won\'t run even though it doesn\'t need 204MB, only 64MB.  So I want to understand why java requires so much virtual memory.  Can this be changed?Edit 3: There are several other applications running in the system, which is embedded. And the system does have a virtual memory limit. (from comments, important detail)This has been a long-standing complaint with Java, but it\'s largely meaningless, and usually based on looking at the wrong information. The usual phrasing is something like "Hello World on Java takes 10 megabytes! Why does it need that?" Well, here\'s a way to make Hello World on a 64-bit JVM claim to take over 4 gigabytes ... at least by one form of measurement.On Linux, the top command gives you several different numbers for memory. Here\'s what it says about the Hello World example:The situation for Windows Task Manager is a bit more complicated. Under Windows XP, there are "Memory Usage" and "Virtual Memory Size" columns, but the official documentation is silent on what they mean. Windows Vista and Windows 7 add more columns, and they\'re actually documented. Of these, the "Working Set" measurement is the most useful; it roughly corresponds to the sum of RES and SHR on Linux.The virtual memory consumed by a process is the total of everything that\'s in the process memory map. This includes data (eg, the Java heap), but also all of the shared libraries and memory-mapped files used by the program. On Linux, you can use the pmap command to see all of the things mapped into the process space (from here on out I\'m only going to refer to Linux, because it\'s what I use; I\'m sure there are equivalent tools for Windows). Here\'s an excerpt from the memory map of the "Hello World" program; the entire memory map is over 100 lines long, and it\'s not unusual to have a thousand-line list.A quick explanation of the format: each row starts with the virtual memory address of the segment. This is followed by the segment size, permissions, and the source of the segment. This last item is either a file or "anon", which indicates a block of memory allocated via mmap.Starting from the top, we haveThe shared libraries are particularly interesting: each shared library has at least two segments: a read-only segment containing the library code, and a read-write segment that contains global per-process data for the library (I don\'t know what the segment with no permissions is; I\'ve only seen it on x64 Linux). The read-only portion of the library can be shared between all processes that use the library; for example, libc has 1.5M of virtual memory space that can be shared.The virtual memory map contains a lot of stuff. Some of it is read-only, some of it is shared, and some of it is allocated but never touched (eg, almost all of the 4Gb of heap in this example). But the operating system is smart enough to only load what it needs, so the virtual memory size is largely irrelevant.Where virtual memory size is important is if you\'re running on a 32-bit operating system, where you can only allocate 2Gb (or, in some cases, 3Gb) of process address space. In that case you\'re dealing with a scarce resource, and might have to make tradeoffs, such as reducing your heap size in order to memory-map a large file or create lots of threads.But, given that 64-bit machines are ubiquitous, I don\'t think it will be long before Virtual Memory Size is a completely irrelevant statistic.Resident Set size is that portion of the virtual memory space that is actually in RAM. If your RSS grows to be a significant portion of your total physical memory, it might be time to start worrying. If your RSS grows to take up all your physical memory, and your system starts swapping, it\'s well past time to start worrying.But RSS is also misleading, especially on a lightly loaded machine. The operating system doesn\'t expend a lot of effort to reclaiming the pages used by a process. There\'s little benefit to be gained by doing so, and the potential for an expensive page fault if the process touches the page in the future. As a result, the RSS statistic may include lots of pages that aren\'t in active use. Unless you\'re swapping, don\'t get overly concerned about what the various memory statistics are telling you. With the caveat that an ever-growing RSS may indicate some sort of memory leak.With a Java program, it\'s far more important to pay attention to what\'s happening in the heap. The total amount of space consumed is important, and there are some steps that you can take to reduce that. More important is the amount of time that you spend in garbage collection, and which parts of the heap are getting collected.Accessing the disk (ie, a database) is expensive, and memory is cheap. If you can trade one for the other, do so.There is a known problem with Java and glibc >= 2.10 (includes  Ubuntu >= 10.04, RHEL >= 6).The cure is to set this env. variable:\n\nexport MALLOC_ARENA_MAX=4\n\nIf you are running Tomcat, you can add this to TOMCAT_HOME/bin/setenv.sh file.There is an IBM article about setting MALLOC_ARENA_MAX \nhttps://www.ibm.com/developerworks/community/blogs/kevgrig/entry/linux_glibc_2_10_rhel_6_malloc_may_show_excessive_virtual_memory_usage?lang=enThis blog post saysresident memory has been known to creep in a manner similar to a\n  memory leak or memory fragmentation.search for MALLOC_ARENA_MAX on Google or SO for more references.You might want to tune also other malloc options to optimize for low fragmentation of allocated memory:The amount of memory allocated for the Java process is pretty much on-par with what I would expect. I\'ve had similar problems running Java on embedded/memory limited systems. Running any application with arbitrary VM limits or on systems that don\'t have adequate amounts of swap tend to break. It seems to be the nature of many modern apps that aren\'t design for use on resource-limited systems.You have a few more options you can try and limit your JVM\'s memory footprint. This might reduce the virtual memory footprint:-XX:ReservedCodeCacheSize=32m Reserved code cache size (in bytes) - maximum\n  code cache size. [Solaris 64-bit,\n  amd64, and -server x86: 48m; in\n  1.5.0_06 and earlier, Solaris 64-bit and and64: 1024m.]-XX:MaxPermSize=64m Size of the Permanent Generation.  [5.0 and newer:\n  64 bit VMs are scaled 30% larger; 1.4\n  amd64: 96m; 1.3.1 -client: 32m.]Also, you also should set your -Xmx (max heap size) to a value as close as possible to the actual peak memory usage of your application. I believe the default behavior of the JVM is still to double the heap size each time it expands it up to the max. If you start with 32M heap and your app peaked to 65M, then the heap would end up growing 32M -> 64M -> 128M.You might also try this to make the VM less aggressive about growing the heap:-XX:MinHeapFreeRatio=40 Minimum percentage of heap free after GC to\n  avoid expansion.Also, from what I recall from experimenting with this a few years ago, the number of native libraries loaded had a huge impact on the minimum footprint. Loading java.net.Socket added more than 15M if I recall correctly (and I probably don\'t).The Sun JVM requires a lot of memory for HotSpot and it maps in the runtime libraries in shared memory.If memory is an issue consider using another JVM suitable for embedding.  IBM has j9, and there is the Open Source "jamvm" which uses GNU classpath libraries.  Also Sun has the Squeak JVM running on the SunSPOTS so there are alternatives.Just a thought, but you may check the influence of a ulimit -v option.That is not an actual solution since it would limit address space available for all process, but that would allow you to check the behavior of your application with a limited virtual memory.One way of reducing the heap sice of a system with limited resources may be to play around with the -XX:MaxHeapFreeRatio variable. This is usually set to 70, and is the maximum percentage of the heap that is free before the GC shrinks it. Setting it to a lower value, and you will see in eg the jvisualvm profiler that a smaller heap sice is usually used for your program. EDIT: To set small values for -XX:MaxHeapFreeRatio you must also set -XX:MinHeapFreeRatio\nEg EDIT2: Added an example for a real application that starts and does the same task, one with default parameters and one with 10 and 25 as parameters. I didn\'t notice any real speed difference, although java in theory should use more time to increase the heap in the latter example.At the end, max heap is 905, used heap is 378At the end, max heap is 722, used heap is 378This actually have some inpact, as our application runs on a remote desktop server, and many users may run it at once.Sun\'s java 1.4 has the following arguments to control memory size:-Xmsn\n      Specify the initial size, in bytes, of the memory allocation pool.\n  This value must be a multiple of 1024\n  greater than 1MB. Append the letter k\n  or K to indicate kilobytes, or m or M\n  to indicate megabytes. The default\n  value is 2MB. Examples:-Xmxn\n      Specify the maximum size, in bytes, of the memory allocation pool.\n  This value must a multiple of 1024\n  greater than 2MB. Append the letter k\n  or K to indicate kilobytes, or m or M\n  to indicate megabytes. The default\n  value is 64MB. Examples:http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html Java 5 and 6 have some more.  See http://java.sun.com/javase/technologies/hotspot/vmoptions.jspNo, you can\'t configure memory amount needed by VM. However, note that this is virtual memory, not resident, so it just stays there without harm if not actually used.Alernatively, you can try some other JVM then Sun one, with smaller memory footprint, but I can\'t advise here.