I want a version of str_replace() that only replaces the first occurrence of $search in the $subject. Is there an easy solution to this, or do I need a hacky solution?Can be done with preg_replace:The magic is in the optional fourth parameter [Limit]. From the documentation:[Limit] - The maximum possible\n  replacements for each pattern in each\n  subject string. Defaults to -1 (no\n  limit).Though, see zombat\'s answer for a more efficient method (roughly, 3-4x faster).There\'s no version of it, but the solution isn\'t hacky at all.Pretty easy, and saves the performance penalty of regular expressions.Bonus: If you want to replace last occurrence, just use strrpos in place of strpos.Edit: both answers have been updated and are now correct. I\'ll leave the answer since the function timings are still useful.The answers by \'zombat\' and \'too much php\' are unfortunately not correct. This is a revision to the answer zombat posted (as I don\'t have enough reputation to post a comment):Note the strlen($needle), instead of strlen($replace). Zombat\'s example will only work correctly if needle and replace are the same length. Here\'s the same functionality in a function with the same signature as PHP\'s own str_replace:This is the revised answer of \'too much php\':Note the 2 at the end instead of 1. Or in function format:I timed the two functions and the first one is twice as fast when no match is found. They are the same speed when a match is found.I wondered which one was the fastest, so I tested them all.Below you will find:All functions were tested with the same settings:Functions that only replace the first occurrence of a string within a string:substr_replace($string, $replace, 0, strlen($search));replace_first($search, $replace, $string);preg_replace($search, $replace, $string, 1);str_replace_once($search, $replace, $string);str_replace_limit($search, $replace, $string, $count, 1);str_replace_limit($search, $replace, $string, 1);str_replace_limit($string, $search, $replace, 1, 0);Functions that only replace the last occurrence of a string within a string:substr_replace($string, $replace, strrpos($string, $search), strlen($search));strrev(implode(strrev($replace), explode(strrev($search), strrev($string), 2)));Unfortunately, I don\'t know of any PHP function which can do this.\nYou can roll your own fairly easily like this:I created this little function that replaces string on string (case-sensitive) with limit, without the need of Regexp. It works fine.Example usage:The easiest way would be to use regular expression.The other way is to find the position of the string with strpos() and then an substr_replace()But i would really go for the RegExp.Replacing the first \'o\' to \'ea\' for example:The function:To expand on @renocor\'s answer, I\'ve written a function that is 100% backward-compatible with str_replace(). That is, you can replace all occurrences of str_replace() with str_replace_limit() without messing anything up, even those using arrays for the $search, $replace, and/or $subject.The function could be completely self-contained, if you wanted to replace the function call with ($string===strval(intval(strval($string)))), but I\'d recommend against it since valid_integer() is a rather useful function when dealing with integers provided as strings.Note: Whenever possible, str_replace_limit() will use str_replace() instead, so all calls to str_replace() can be replaced with str_replace_limit() without worrying about a hit to performance.2 replacements -- bbcbbc1 replacements -- bbcabc2 replacements -- bbcbbcIn PHP you can iterate over the letters of a string or access the letters as it is possible to access elements of an array. The snippet which replces only first letter of the string:You can also access each letter using curly brackets.\nI use following code for replacing lowercase polish accented chars to uppercase one. According to my test result, I\'d like to vote the regular_express one provided by karim79. (I don\'t have enough reputation to vote it now!)The solution from zombat uses too many function calls, I even simplify the codes. I\'m using PHP 5.4 to run both solutions for 100,000 times, and here\'s the result:==> 1.85 sec==> 1.35 secAs you can see. The performance of preg_replace is not so bad as many people think. So I\'d suggest the classy solution if your regular express is not complicated.To expand on zombat\'s answer (which I believe to be the best answer), I created a recursive version of his function that takes in a $limit parameter to specify how many occurrences you want to replace.For a stringFor a single characterComplementing what people said, remember that the entire string is an array:"Borem ipsum l\xc3\xa1 l\xc3\xa1 l\xc3\xa1"You can use this:Found this example from php.netUsage:Output:This may reduce the performance a little bit, but the easiest solution.This function is heavily inspired by the answer by @renocor.\nIt makes the function multi byte safe.Here\'s a simple class I created to wrap our slightly modified str_replace() functions.Our php::str_rreplace() function also allows you to carry out a reverse, limited str_replace() which can be very handy when trying to replace only the final X instance(s) of a string.These examples both use preg_replace().Its easy to find a solution to replace only the first or first couple of instances (by giving the count value).\nThere are not many solutions to replace the last or last couple of instance.Maybe something like str_replace($find, $replace, $subject, -3) should replace last three instances.Anyways just a suggestion.this is my first answer here, I hope to do it correctly.\nWhy not use the fourth argument of the str_replace function for this problem?count: If passed, this will be set to the number of replacements performed.\nedit: This answer is wrong, because the 4th parameter of str_replace is a variable that gets assigned the number of replacements done. This is inconsistent with preg_replace, which has a 4th parameter $limit and a 5th parameter &$count.