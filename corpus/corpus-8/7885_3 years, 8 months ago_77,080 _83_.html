I just got started with ReactJS and am a little stuck on a problem that I have.My application is essentially a list with filters and a button to change the layout.\nAt the moment I\'m using three components: <list />, < Filters /> and <TopBar />, now obviously when I change settings in < Filters /> I want to trigger some method in <list /> to update my view.How can I make those 3 components interact with each other, or do I need some sort of global data model where I can just make changes to?The best approach would depend on how you plan to arrange those components. A few example scenarios that come to mind right now:There may be other scenarios that I\'m not thinking of. If yours doesn\'t fit within these, then let me know. Here are some very rough examples of how I\'ve been handling the first two scenarios:You could pass a handler from <List /> to <Filters />, which could then be called on the onChange event to filter the list with the current value.JSFiddle for #1 →Similar to scenario #1, but the parent component will be the one passing down the handler function to <Filters />, and will pass the filtered list to <List />. I like this method better since it decouples the <List /> from the <Filters />.JSFiddle for #2 →When the components can\'t communicate between any sort of parent-child relationship, the documentation recommends setting up a global event system.If the 2 components are close enough in the tree, you can simply use functions like already described in other answersUse a portal when you\'d like to keep 2 components close together to make them communicate with simple functions, like in normal parent / child, but you don\'t want these 2 components to have a parent/child relationship in the DOM, because of visual / CSS constraints it implies (like z-index, opacity...).In this case you can use a "portal". There are different react libraries using portals, usually used for modals, popups, tooltips... Consider the following:Could produce the following DOM when rendered inside reactAppContainer:More details hereAs stated in the React documentation:For communication between two components that don\'t have a parent-child relationship, you can set up your own global event system. Subscribe to events in componentDidMount(), unsubscribe in componentWillUnmount(), and call setState() when you receive an event.There are many things you can use to setup an event bus. You can just create an array of listeners, and on event publish, all listeners would receive the event. Or you can use something like EventEmitter or PostalJsFlux is basically an event bus, except the event receivers are stores. This is similar to the basic event bus system except the state is managed outside of ReactOriginal Flux implementation looks like an attempt to do Event-sourcing in a hacky way.Redux is for me the Flux implementation that is the closest from event-sourcing, an benefits many of event-sourcing advantages like the ability to time-travel. It is not strictly linked to React and can also be used with other functional view libraries.Egghead\'s Redux video tutorial is really nice and explains how it works internally (it really is simple).Cursors are coming from ClojureScript/Om and widely used in React projects. They permit to manage the state outside of React, and let multiple components have read/write access to the same part of the state, without needing to know anything about the component tree.Many implementations exists, including ImmutableJS, React-cursors and OmniscientEdit 2016: it seems that people agree cursors work fine for smaller apps but it does not scale well on complex apps. Om Next does not have cursors anymore (while it\'s Om that introduced the concept initially)The Elm architecture is an architecture proposed to be used by the Elm language. Even if Elm is not ReactJS, the Elm architecture can be done in React as well.Dan Abramov, the author of Redux, did an implementation of the Elm architecture using React.Both Redux and Elm are really great and tend to empower event-sourcing concepts on the frontend, both allowing time-travel debugging, undo/redo, replay...The main difference between Redux and Elm is that Elm tend to be a lot more strict about state management. In Elm you can\'t have local component state or mount/unmount hooks and all DOM changes must be triggered by global state changes. Elm architecture propose a scalable approach that permits to handle ALL the state inside a single immutable object, while Redux propose an approach that invites you to handle MOST of the state in a single immutable object.While the conceptual model of Elm is very elegant and the architecture permits to scale well on large apps, it can in practice be difficult or involve more boilerplate to achieve simple tasks like giving focus to an input after mounting it, or integrating with an existing library with an imperative interface (ie JQuery plugin). Related issue.Also, Elm architecture involves more code boilerplate. It\'s not that verbose or complicated to write but I think the Elm architecture is more suited to statically typed languages.Libraries like RxJS, BaconJS or Kefir can be used to produce FRP streams to handle communication between components.You can try for example Rx-ReactI think using these libs is quite similar to using what the ELM language offers with signals.CycleJS framework does not use ReactJS but uses vdom. It share a lot of similarities with the Elm architecture (but is more easy to use in real life because it allows vdom hooks) and it uses RxJs extensively instead of functions, and can be a good source of inspiration if you want to use FRP with React. CycleJs Egghead videos are nice to understand how it works.CSP (Communicating Sequential Processes) are currently popular (mostly because of Go/goroutines and core.async/ClojureScript) but you can use them also in javascript with JS-CSP.James Long has done a video explaining how it can be used with React.A saga is a backend concept that comes from the DDD / EventSourcing / CQRS world, also called "process manager". \nIt is being popularized by the redux-saga project, mostly as a replacement to redux-thunk for handling side-effects (ie API calls etc). Most people currently think it only services for side-effects but it is actually more about decoupling components. It is more of a compliment to a Flux architecture (or Redux) than a totally new communication system, because the saga emit Flux actions at the end. The idea is that if you have widget1 and widget2, and you want them to be decoupled, you can\'t fire action targeting widget2 from widget1. So you make widget1 only fire actions that target itself, and the saga is a "background process" that listens for widget1 actions, and may dispatch actions that target widget2. The saga is the coupling point between the 2 widgets but the widgets remain decoupled.If you are interested take a look at my answer hereIf you want to see an example of the same little app using these different styles, check the branches of this repository. I don\'t know what is the best option in the long term but I really like how Flux looks like event-sourcing. If you don\'t know event-sourcing concepts, take a look at this very pedagogic blog: Turning the database inside out with apache Samza, it is a must-read to understand why Flux is nice (but this could apply to FRP as well)I think the community agrees that the most promising Flux implementation is Redux, which will progressively allow very productive developer experience thanks to hot reloading. Impressive livecoding ala Bret Victor\'s Inventing on Principle video is possible!This is the way I handled this.\nLet\'s say you have a <select> for Month and a <select> for Day.\nThe number of days depends on the selected month.Both lists are owned by a third object, the left panel. Both <select> are also children of the leftPanel <div>\nIt\'s a game with the callbacks and the handlers in the LeftPanel component.To test it, just copy the code into two separated files and run the index.html. Then select a month and see how the number of days changes.dates.jsAnd the HTML for running the left panel component\nindex.htmlI saw that the question is already answered, but if you\'d like to learn more details, there are a total of 3 cases of communication between components:I summarized them in this ReactJS Documentation topic. Examples included!There is such possibility even if they are not Parent - Child relationship - and that\'s Flux. There is pretty good (for me personally) implementation for that called Alt.JS (with Alt-Container).For example you can have Sidebar that is dependent on what is set in component Details. Component Sidebar is connected with SidebarActions and SidebarStore, while Details is DetailsActions and DetailsStore.You could use then AltContainer like thatWhich would keep stores (well I could use "store" instead of "stores" prop). Now, {this.props.content} CAN BE Details depending on the route. Lets say that /Details redirect us to that view.\nDetails would have for example a checkbox that would change Sidebar element from X to Y if it would be checked.Technically there is no relationship between them and it would be hard to do without flux. BUT WITH THAT it is rather easy.Now let\'s get to DetailsActions. We will create thereand DetailsStoreAnd now, this is the place where magic begin.As You can see there is bindListener to SidebarActions.ComponentStatusChanged which will be used IF setSiteComponent will be used.now in SidebarActionsWe have such thing. It will dispatch that object on call. And it will be called if setSiteComponent in store will be used (that you can use in component for example during onChange on Button ot whatever)Now in SidebarStore we will haveNow here you can see, that it will wait for DetailsStore. What does it mean? more or less it means that this method need to wait for DetailsStoreto update before it can update itself.tl;dr\nOne Store is listening on methods in a store, and will trigger an action from component action, which will update its own store.I hope it can help you somehow.If you want to explore options of communicating between components and feel like it is getting harder and harder, then you might consider adopting a good design pattern: Flux.It is simply a collection of rules that defines how you store and mutate application wide state, and use that state to render components.There are many Flux implementations, and Facebook\'s official implementation is one of them. Although it is considered the one that contains most boilerplate code, but it is easier to understand since most of the things are explicit.Some of Other alternatives are flummox fluxxor fluxible and redux.Extending answer of @MichaelLaCroix when a scenario is that the components can\'t communicate between any sort of parent-child relationship, the documentation recommends setting up a global event system.In the case of <Filters /> and <TopBar /> don\'t have any of the above relationship, a simple global emitter could be used like this:componentDidMount - Subscribe to eventcomponentWillUnmount - Unsubscribe from eventReact.js and EventSystem codeEventSystem.jsNotificationComponent.jsI once was where you are right now, as a beginner you sometimes feel out of place on how the react way to do this. I\'m gonna try to tackle the same way I think of it right now. Usually what it comes down to is the way that you alter the states in this component in your case you point out three components.<List /> : Which probably will display a list of items depending on a filter\n<Filters />: Filter options that will alter your data.\n<TopBar />: List of options.To orchestrate all of this interaction you are going to need a higher component let\'s call it App, that will pass down actions and data to each one of this components so for instance can look like thisSo when setFilter is called it will affect the filteredItem and re-render both component;. In case this is not entirely clear I made you an example with checkbox that you can check in a single file: