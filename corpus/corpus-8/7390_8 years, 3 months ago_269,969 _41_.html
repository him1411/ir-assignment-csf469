I need a different random number for each row in my table.  The following seemingly obvious code uses the same random value for each row.I\'d like to get a INT or a FLOAT out this.  The rest of the story is I\'m going to use the random number to create an random date offset from a know date, e.g. 1-14 days offset from a start date.This is for Microsoft SQL Server 2000.Take a look at SQL Server - Set based random numbers which has a very detailed explanation.To summarize, the following code generates a random number between 0 and 13 inclusive with a normalized distribution:To change your range, just change the number at the end of the expression. Be extra careful if you need a range that includes both positive and negative numbers. If you do it wrong, it\'s possible to double-count the number 0.A small warning for the math nuts in the room: there is a very slight bias in this code. CHECKSUM() results in numbers that are normalized across the entire range of the sql Int datatype, or at least as near so as my (the editor) testing can show. However, there will be some bias when CHECKSUM() produces a number at the very top end of that range. Any time you get a number between the maximum possible integer and the last exact multiple of the size of your desired range (14 in this case) before that maximum integer, those results are favored over the remaining portion of your range that cannot be produced from that last multiple of 14. As an example, imagine the entire range of the Int type is only 19. 19 is the largest possible integer you can hold. When CHECKSUM() results in 14-19, these correspond to results 0-5. Those numbers would be heavily favored over 6-13, because CHECKSUM() is twice as likely to generate them. It\'s easier to demonstrate this visually. Below is the entire possible set of results for our imaginary integer range:You can see here that there are more chances to produce some numbers than others: bias. Thankfully, the actual range of the Int type is much larger... so much so that in most cases the bias is nearly undetectable. However, it is something to be aware of if you ever find yourself doing this for serious security code.When called multiple times in a single batch, rand() returns the same number.I\'d suggest using convert(varbinary,newid()) as the seed argument:newid() is guaranteed to return a different value each time it\'s called, even within the same batch, so using it as a seed will prompt rand() to give a different value each time.Edited to get a random whole number from 1 to 14.The above will generate a (pseudo-) random number between 0 and 1, exclusive.  If used in a select, because the seed value changes for each row, it will generate a new random number for each row (it is not guaranteed to generate a unique number per row however).Example when combined with an upper limit of 10 (produces numbers 1 - 10):RAND(): http://msdn.microsoft.com/en-us/library/ms177610.aspxCHECKSUM(): http://msdn.microsoft.com/en-us/library/ms189788.aspxRandom number generation between 1000 and 9999:The Rand() function will generate the same random number, if used in a table SELECT query. Same applies if you use a seed to the Rand function. An alternative way to do it, is using this:Got the information from here, which explains the problem very well.Do you have an integer value in each row that you could pass as a seed to the RAND function?To get an integer between 1 and 14 I believe this would work:Answering the old question, but this answer has not been provided previously, and hopefully this will be useful for someone finding this results through a search engine.With SQL Server 2008, a new function has been introduced, CRYPT_GEN_RANDOM(8), which uses CryptoAPI to produce a cryptographically strong random number, returned as VARBINARY(8000). Here\'s the documentation page: https://docs.microsoft.com/en-us/sql/t-sql/functions/crypt-gen-random-transact-sqlSo to get a random number, you can simply call the function and cast it to the necessary type:or to get a float between -1 and +1, you could do something like this:try using a seed value in the RAND(seedInt).  RAND() will only execute once per statement that is why you see the same number each time.If you don\'t need it to be an integer, but any random unique identifier, you can use newid()You would need to call RAND() for each row. Here is a good examplehttps://web.archive.org/web/20090216200320/http://dotnet.org.za/calmyourself/archive/2007/04/13/sql-rand-trap-same-value-per-row.aspxIf you need to preserve your seed so that it generates the "same" random data every time, you can do the following:1. Create a view that returns select rand()2. Create a UDF that selects the value from the view.3. Before selecting your data, seed the rand() function, and then use the UDF in your select statement.select newid()or possibly this  select binary_checksum(newid())The problem I sometimes have with the selected "Answer" is that the distribution isn\'t always even. If you need a very even distribution of random 1 - 14 among lots of rows, you can do something like this (my database has 511 tables, so this works. If you have less rows than you do random number span, this does not work well):This kind of does the opposite of normal random solutions in the sense that it keeps the numbers sequenced and randomizes the other column.Remember, I have 511 tables in my database (which is pertinent only b/c we\'re selecting from the information_schema). If I take the previous query and put it into a temp table #X, and then run this query on the resulting data:I get this result, showing me that my random number is VERY evenly distributed among the many rows: