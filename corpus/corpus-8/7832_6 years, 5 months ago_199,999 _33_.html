I am on the stage of development, where I have two modules and from one I got output as a OutputStream and second one, which accepts only InputStream. Do you know how to convert OutputStream to InputStream (not vice versa, I mean really this way) that I will be able to connect these two parts?ThanksAn OutputStream is one where you write data to. If some module exposes an OutputStream, the expectation is that there is something at the other end that is reading.Something that exposes an InputStream on the other hand is indicating that you will need to listen to this stream, and there will be data that you can read. So it is possible to connect an InputStream to an OutputStreamInputStream----read---> intermediateBytes[n] ----write----> OutputStreamAs someone metioned, this is what the copy() method from IOUtils lets you do. It does not make sense to go the other way... hopefully this makes some senseUPDATE:Of course the more I think of this, the more I can see how this actually would be a requirement. I know some of the comments mentioned Piped input/ouput streams, but there is another possibility.If the output stream that is exposed is a ByteArrayOutputStream, then you can always get the full contents by calling the toByteArray() method. Then you can create an input stream wrapper by using the ByteArrayInputStream sub-class. These two are pseudo-streams, they both basically just wrap an array of bytes. Using the streams this way, therefore, is technically possible, but to me it is still very strange...There seem to be many links and other such stuff, but no actual code using pipes. The advantage of using java.io.PipedInputStream and java.io.PipedOutputStream is that there is no additional consumption of memory. ByteArrayOutputStream.toByteArray() returns a copy of the original buffer, so that means that whatever you have in memory, you now have two copies of it. Then writing to an InputStream means you now have three copies of the data.The code:This code assumes that the originalByteArrayOutputStream is a ByteArrayOutputStream as it is usually the only usable output stream, unless you\'re writing to a file. I hope this helps! The great thing about this is that since it\'s in a separate thread, it also is working in parallel, so whatever is consuming your input stream will be streaming out of your old output stream too. That is beneficial because the buffer can remain smaller and you\'ll have less latency and less memory usage.You will need an intermediate class which will buffer between. Each time InputStream.read(byte[]...) is called, the buffering class will fill the passed in byte array with the next chunk passed in from OutputStream.write(byte[]...). Since the sizes of the chunks may not be the same, the adapter class will need to store a certain amount until it has enough to fill the read buffer and/or be able to store up any buffer overflow.This article has a nice breakdown of a few different approaches to this problem:http://blog.ostermiller.org/convert-java-outputstream-inputstreamThe easystream open source library has direct support to convert an OutputStream to an InputStream: http://io-tools.sourceforge.net/easystream/tutorial/tutorial.htmlThey also list other options: http://io-tools.sourceforge.net/easystream/OutputStream_to_InputStream.htmlAs input and output streams are just start and end point, the solution is to temporary store data in byte array. So you must create intermediate ByteArrayOutputStream, from which you create byte[] that is used as input for new ByteArrayInputStream. Hope it helps.I encountered the same problem with converting a ByteArrayOutputStream to a ByteArrayInputStream and solved it by using a derived class from ByteArrayOutputStream which is able to return a ByteArrayInputStream that is initialized with the internal buffer of the ByteArrayOutputStream. This way no additional memory is used and the \'conversion\' is very fast:I put the stuff on github: https://github.com/nickrussler/ByteArrayInOutStreamIf you want to make an OutputStream from an InputStream there is one basic problem. A method writing to an OutputStream blocks until it is done. So the result is available when the writing method is finished. This has 2 consequences:Variant 1 can be implemented using byte arrays or filed.\nVariant 1 can be implemented using pipies (either directly or with extra abstraction - e.g. RingBuffer or the google lib from the other comment).Indeed with standard java there is no other way to solve the problem. Each solution is an implementataion of one of these.There is one concept called "continuation" (see wikipedia for details). In this case basically this means:While some languages have this concept built in, for java you need some "magic". For example "commons-javaflow" from apache implements such for java. The disadvantage is that this requires some special bytecode modifications at build time. So it would make sense to put all the stuff in an extra library whith custom build scripts.Though you cannot convert an OutputStream to an InputStream, java provides a way using PipedOutputStream and PipedInputStream that you can have data written to a  PipedOutputStream to become available through an associated PipedInputStream.  Sometime back I faced a similar situation when dealing with third party libraries that required an InputStream instance to be passed to them instead of an OutputStream instance. The way I fixed this issue is to use the PipedInputStream and PipedOutputStream. By the way they are tricky to use and you must use multithreading to achieve what you want. I recently published an implementation on github which you can use. Here is the link . You can go through the wiki to understand how to use it.Old post but might help others, Use this way:I think the best way to connect InputStream to an OutputStream is through piped streams - available in java.io package, as follow:In my opinion there are two main advantages for this code:1 - There is no additional consumption of memory except for the buffer.2 - You don\'t need to handle data queuing manually