I have this script, but I do not know how to get the last element in the printout:The last element should be the number of CPUs, minus 1.or simplywhich will count number of lines starting with "processor" in /proc/cpuinfoProcessing the contents of /proc/cpuinfo is needlessly baroque. Use nproc which is part of coreutils, so it should be available on most Linux installs.Command nproc prints the number of processing units available to the current process, which may be less than the number of online processors.To find the number of all installed cores/processors use nproc --allOn my 8-core machine:The most portable solution I have found is the getconf command:This works on both Linux and Mac OS X. Another benefit of this over some of the other approaches is that getconf has been around for a long time. Some of the older Linux machines I have to do development on don\'t have the nproc or lscpu commands available, but they have getconf.Editor\'s note: While the getconf utility is POSIX-mandated, the specific _NPROCESSORS_ONLN and _NPROCESSORS_CONF values are not. \nThat said, as stated, they work on Linux platforms as well as on macOS; on FreeBSD/PC-BSD, you must omit the leading _.Preface: The problem with the /proc/cpuinfo-based answers is that they parse information that was meant for human consumption and thus lacks a stable format designed for machine parsing: the output format can differ across platforms and runtime conditions; using lscpu -p on Linux (and sysctl on OSX) bypasses that problem.getconf _NPROCESSORS_ONLN / getconf NPROCESSORS_ONLN doesn\'t distinguish between logical and physical CPUs.Here\'s a bash snippet that works on Linux and macOS for determining the number of - online - logical or physical CPUs; see the comments for details.Uses lscpu for Linux, and sysctl for macOS.Terminology note: CPU refers to the smallest processing unit as seen by the OS. Non-hyper-threading cores each correspond to 1 CPU, whereas hyper-threading cores contain more  than 1 (typically: 2) - logical - CPU.\nLinux uses the following taxonomy, starting with the smallest unit: CPU < core < socket < book < node, with each level comprising 1 or more instances of the next lower level.\nMy knowledge is somewhat shaky here - do let me know if I\'m wrong.\nDoes anyone know what a "book" is in this context?[1] macOS sysctl (3) documentationNote that BSD-derived systems other than macOS - e.g., FreeBSD - only support the hw.ncpu key for sysctl, which are deprecated on macOS; I\'m unclear on which of the new keys hw.npu corresponds to: hw.(logical|physical)cpu_[max].Tip of the hat to @teambob for helping to correct the physical-CPU-count lscpu command.Caveat: lscpu -p output does NOT include a "book" column (the man page mentions "books" as an entity between socket and node in the taxonomic hierarchy). If "books" are in play on a given Linux system (does anybody know when and how?), the physical-CPU-count command may under-report (this is based on the assumption that lscpu reports IDs that are non-unique across higher-level entities; e.g.: 2 different cores from 2 different sockets could have the same ID).This worked for me. tail -nX allows you to grab only the last X lines.If you have hyperthreading, this should work for grabbing the number of physical cores.For the total number of physical cores:On multiple-socket machines (or always), multiply the above result by the number of sockets:@mklement0 has quite a nice answer below using lscpu. I have written a more succinct version in the commentsUsing getconf is indeed the most portable way, however the variable has different names in BSD and Linux to getconf, so you have to test both, as this gist suggests:\nhttps://gist.github.com/jj1bdx/5746298\n(also includes a Solaris fix using ksh)I personally use:And if you want this in python you can just use the syscall getconf uses by importing the os module:As for nproc, it\'s part of GNU Coreutils, so not available in BSD by default. It uses sysconf() as well after some other methods.If you want to do this so it works on linux and OS X, you can do:You can also use Python! To get the number of physical cores:To get the number of hyperthreaded cores:The following should give you the number of "real" cores on both a hyperthreaded and non-hyperthreaded system. At least it worked in all my tests. You can use one of the following methods to determine the number of physical CPU cores.Count the number of unique core ids (roughly equivalent to grep -P \'^core id\\t\' /proc/cpuinfo | sort -u | wc -l).awk \'/^core id\\t/ {cores[$NF]++} END {print length(cores)}\' /proc/cpuinfoMultiply the number of \'cores per socket\' by the number of sockets.lscpu | awk \'/^Core\\(s\\) per socket:/ {cores=$NF}; /^Socket\\(s\\):/ {sockets=$NF}; END{print cores*sockets}\'Count the number of unique logical CPU\'s as used by the Linux kernel. The -p option generates output for easy parsing and is compatible with earlier versions of lscpu.lscpu -p | awk -F, \'$0 !~ /^#/ {cores[$1]++} END {print length(cores)}\'Just to reiterate what others have said, there are a number of related properties.To determine the number of processors available:To determine the number of processing units available (not necessarily the same as the number of cores). This is hyperthreading-aware.I don\'t want to go too far down the rabbit-hole, but you can also determine the number of configured processors (as opposed to simply available/online processors) via getconf _NPROCESSORS_CONF. To determine total number of CPU\'s (offline and online) you\'d want to parse the output of lscpu -ap.Count "core id" per "physical id" method using awk with fall-back on "processor" count if "core id" are not available (like raspberry)Not my web page, but this command from http://www.ixbrian.com/blog/?p=64&cm_mc_uid=89402252817914508279022&cm_mc_sid_50200000=1450827902 works nicely for me on centos. It will show actual cpus even when hyperthreading is enabled.cat /proc/cpuinfo | egrep "core id|physical id" | tr -d "\\n" | sed s/physical/\\\\nphysical/g | grep -v ^$ | sort | uniq | wc -l