I\'m learning how to make OOP with JavaScript. Does it have the interface concept (such as Java\'s interface)? So I would be able to create a listener...There\'s no notion of "this class must have these functions" (that is, no interfaces per se), because:Instead, JavaScript uses what\'s called duck typing. (If it walks like a duck, and quacks like a duck, as far as JS cares, it\'s a duck.) If your object has quack(), walk(), and fly() methods, code can use it wherever it expects an object that can walk, quack, and fly, without requiring the implementation of some "Duckable" interface. The interface is exactly the set of functions that the code uses (and the return values from those functions), and with duck typing, you get that for free.Now, that\'s not to say your code won\'t fail halfway through, if you try to call some_dog.quack(); you\'ll get a TypeError.  Frankly, if you\'re telling dogs to quack, you have slightly bigger problems; duck typing works best when you keep all your ducks in a row, so to speak, and aren\'t letting dogs and ducks mingle together unless you\'re treating them as generic animals.  In other words, even though the interface is fluid, it\'s still there; it\'s often an error to pass a dog to code that expects it to quack and fly in the first place.But if you\'re sure you\'re doing the right thing, you can work around the quacking-dog problem by testing for the existence of a particular method before trying to use it. Something likeSo you can check for all the methods you can use before you use them. The syntax is kind of ugly, though. There\'s a slightly prettier way:This is standard JavaScript, so it should work in any JS interpreter worth using.  It has the added benefit of reading like English.For modern browsers (that is, pretty much any browser other than IE 6-8), there\'s even a way to keep the property from showing up in for...in:The problem is that IE7 objects don\'t have .defineProperty at all, and in IE8, it allegedly only works on host objects (that is, DOM elements and such).  If compatibility is an issue, you can\'t use .defineProperty.  (I won\'t even mention IE6, because it\'s rather irrelevant anymore outside of China.)Another issue is that some coding styles like to assume that everyone writes bad code, and prohibit modifying Object.prototype in case someone wants to blindly use for...in. If you care about that, or are using (IMO broken) code that does, try a slightly different version:Pick up a copy of \'JavaScript design patterns\' by Dustin Diaz. There\'s a few chapters dedicated to implementing JavaScript interfaces through Duck Typing. It\'s a nice read as well. But no, there\'s no language native implementation of an interface, you have to Duck Type.JavaScript (ECMAScript edition 3) has an implements reserved word saved up for future use. I think this is intended exactly for this purpose, however, in a rush to get the specification out the door they didn\'t have time to define what to do with it, so, at the present time, browsers don\'t do anything besides let it sit there and occasionally complain if you try to use it for something.It is possible and indeed easy enough to create your own Object.implement(Interface) method with logic that baulks whenever a particular set of properties/functions are not implemented in a given object.I wrote an article on object-orientation where use my own notation as follows:There are many ways to skin this particular cat, but this is the logic I used for my own Interface implementation. I find I prefer this approach, and it is easy to read and use (as you can see above). It does mean adding an \'implement\' method to Function.prototype which some people may have a problem with, but I find it works beautifully.Though JavaScript does not have the interface type, it is often times needed. For reasons relating to JavaScript\'s dynamic nature and use of Prototypical-Inheritance, it is difficult to ensure consistent interfaces across classes -- however, it is possible to do so; and frequently emulated.At this point, there are handfuls of particular ways to emulate Interfaces in JavaScript; variance on approaches usually satisfies some needs, while others are left unaddressed. Often times, the most robust approach is overly cumbersome and stymies the implementor (developer).Here is an approach to Interfaces / Abstract Classes that is not very cumbersome, is explicative, keeps implementations inside of Abstractions to a minimum, and leaves enough room for dynamic or custom methodologies:Precept ResolverThe resolvePrecept function is a utility & helper function to use inside of your Abstract Class. Its job is to allow for customized implementation-handling of encapsulated Precepts (data & behavior). It can throw errors or warn -- AND -- assign a default value to the Implementor class.iAbstractClassThe iAbstractClass defines the interface to be used. Its approach entails a tacit agreement with its Implementor class. This interface assigns each precept to the same exact precept namespace -- OR -- to whatever the Precept Resolver function returns. However, the tacit agreement resolves to a context -- a provision of Implementor.ImplementorThe Implementor simply \'agrees\' with an Interface (iAbstractClass in this case) and applies it by the use of Constructor-Hijacking: iAbstractClass.apply(this). By defining the data & behavior above, and then hijacking the Interface\'s constructor -- passing Implementor\'s context to the Interface constructor -- we can ensure that Implementor\'s overrides will be added, and that Interface will explicate warnings and default values.This is a very non-cumbersome approach which has served my team & I very well for the course of time and different projects. However, it does have some caveats & drawbacks.DrawbacksThough this helps implement consistency throughout your software to a significant degree, it does not implement true interfaces -- but emulates them. Though definitions, defaults, and warnings or errors are explicated, the explication of use is enforced & asserted by the developer (as with much of JavaScript development).This is seemingly the best approach to "Interfaces in JavaScript", however, I would love to see the following resolved:That said, I hope this helps you as much as it has my team and I.bob.js supports some sort of interfaces.1. Check if an object implements an interface:2. Extract interface from an object:You need interfaces in Java since it is statically typed and the contract between classes should be known during compilation. In JavaScript it is different. JavaScript is dynamically typed; it means that when you get the object you can just check if it has a specific method and call it.I know this is an old one, but I\'ve recently found myself needing more and more to have a handy API for checking objects against interfaces. So I wrote this: https://github.com/tomhicks/methodicalIt\'s also available via NPM: npm install methodicalIt basically does everything suggested above, with some options for being a bit more strict, and all without having to do loads of if (typeof x.method === \'function\') boilerplate.Hopefully someone finds it useful.Javascript does not have interfaces. But it can be duck-typed, an example can be found here:http://reinsbrain.blogspot.com/2008/10/interface-in-javascript.htmlThere\'s also jQuery.isFunction(method), if you\'d rather that than cHao\'s code.Hope, that anyone who\'s still looking for an answer finds it helpful.You can try out using a Proxy (It\'s standard since ECMAScript 2015): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ProxyThen you can easily say: