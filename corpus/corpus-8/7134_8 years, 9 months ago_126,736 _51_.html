I\'d like to do base64 encoding and decoding, but I could not find any support from the iPhone SDK. How can I do base64 encoding and decoding with or without a library?There\'s a nice code sample at the bottom of this post. Very self-contained...BaseSixtyFourThis is a good use case for Objective C categories.For Base64 encoding:For Base64 decoding:A really, really fast implementation which was ported (and modified/improved) from the PHP Core library into native Objective-C code is available in the QSStrings Class from the QSUtilities Library.  I did a quick benchmark: a 5.3MB image (JPEG) file took < 50ms to encode, and about 140ms to decode.The code for the entire library (including the Base64 Methods) are available on GitHub.Or alternatively, if you want the code to just the Base64 methods themselves, I\'ve posted it here:First, you need the mapping tables:To Encode:To Decode:Historically we would have directed you to one of the many third-party base 64 libraries (as discussed in the other answers) for converting from binary data to base 64 string (and back), but iOS 7 now has native base 64 encoding (and exposes the previously private iOS 4 methods, in case you need to support earlier versions of iOS).Thus to convert NSData to NSString base 64 representation you can use base64EncodedStringWithOptions. If you have to support iOS versions prior to 7.0 as well, you can do:And to convert base 64 NSString back to NSData you can use initWithBase64EncodedString. Likewise, if you need to support iOS versions prior to 7.0, you can do:Obviously, if you don\'t need backward compatibility with iOS versions prior to 7.0, it\'s even easier, just use base64EncodedStringWithOptions or initWithBase64EncodedString, respectively, and don\'t bother with the run-time check for earlier iOS versions. In fact, if you use the above code when your minimum target is iOS 7 or greater, you\'ll actually get a compiler warning about the deprecated methods. So, in iOS 7 and greater, you would simply convert to base 64 string with:and back again with:iOS includes built in support for base64 encoding and decoding. If you look at resolv.h you should see the two functions b64_ntop and b64_pton . The Square SocketRocket library provides a reasonable example of how to use these functions from objective-c.These functions are pretty well tested and reliable - unlike many of the implementations you may find in random internet postings.\nDon\'t forget to link against libresolv.dylib. Since this seems to be the number one google hit on base64 encoding and iphone, I felt like sharing my experience with the code snippet above.It works, but it is extremely slow. A benchmark on a random image (0.4 mb) took 37 seconds on native iphone. The main reason is probably all the OOP magic - single char NSStrings etc, which are only autoreleased after the encoding is done.Another suggestion posted here (ab)uses the openssl library, which feels like overkill as well.The code below takes 70 ms - that\'s a 500 times speedup. This only does base64 encoding (decoding will follow as soon as I encounter it)I left out the line-cutting since I didn\'t need it, but it\'s trivial to add.For those who are interested in optimizing: the goal is to minimize what happens in the main loop. Therefore all logic to deal with the last 3 bytes is treated outside the loop.Also, try to work on data in-place, without additional copying to/from buffers. And reduce any arithmetic to the bare minimum.Observe that the bits that are put together to look up an entry in the table, would not overlap when they were to be orred together without shifting. A major improvement could therefore be to use 4 separate 256 byte lookup tables and eliminate the shifts, like this:Of course you could take it a whole lot further, but that\'s beyond the scope here.In mvds\'s excellent improvement, there are two problems. Change code to this:Better solution :There is a built in function in NSDataGlad people liked it. The end-game was a little flawed I must admit. Besides rightly setting inp=0 you should either also increase tmpbuf\'s size to 3, likeor leave out the orring of raw[inp+2]; if we would have a raw[inp+2] != 0 for this chunk we would still be in the loop of course...Either way works, you might consider keeping the final table lookup block identical to the one in the loop for clarity. In the final version I used I didTo add the ==Sorry I didn\'t check RFC\'s and stuff, should have done a better job!Under iOS8 and later use - (NSString *)base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options of NSDataFor an update to use the NSData (NSDataBase64Encoding) category methods in iOS7 see my answer here: https://stackoverflow.com/a/18927627/1602729Here\'s a compact Objective-C version as a Category on NSData. It takes some thinking about...Padding can be added if required by making the scope of \'byt\' wider and appending \'dest\' with (2-byt) "=" characters before returning.A Category can then be added to NSString, thus:iOS has had built-in Base64 encoding and decoding methods (without using libresolv) since iOS 4. However, it was only declared in the iOS 7 SDK. Apple documentation states that you can use it when targeting iOS 4 and above.Here is an example to convert an NSData object to Base 64. It also shows how to go the other way (decode a base 64 encoded NSData object):in iOS 7 I have done it using the following class..While calling call That\'s it...I Think This will be helpful}Download Base64Do following code to convert an image to base64