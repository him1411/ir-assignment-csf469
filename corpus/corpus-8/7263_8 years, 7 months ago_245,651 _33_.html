First off, here is some code:Is there a way to find out the size of the array that ptr is pointing to (instead of just giving its size, which is four bytes on a 32-bit system)? No, you can\'t.  The compiler doesn\'t know what the pointer is pointing to.  There are tricks, like ending the array with a known out-of-band value and then counting the size up until that value, but that\'s not using sizeof.  Another trick is the one mentioned by Zan, which is to stash the size somewhere.  For example, if you\'re dynamically allocating the array, allocate a block one int bigger than the one you need, stash the size in the first int, and return ptr+1 as the pointer to the array.  When you need the size, decrement the pointer and peek at the stashed value.  Just remember to free the whole block starting from the beginning, and not just the array.The answer is, "No."What C programmers do is store the size of the array somewhere.  It can be part of a structure, or the programmer can cheat a bit and malloc() more memory than requested in order to store a length value before the start of the array.For dynamic arrays (malloc or C++ new) you need to store the size of the array as mentioned by others or perhaps build an array manager structure which handles add, remove, count, etc. Unfortunately C doesn\'t do this nearly as well as C++ since you basically have to build it for each different array type you are storing which is cumbersome if you have multiple types of arrays that you need to manage.For static arrays, such as the one in your example, there is a common macro used to get the size, but it is not recommended as it does not check if the parameter is really a static array. The macro is used in real code though, e.g. in the Linux kernel headers although it may be slightly different than the one below:You can google for reasons to be wary of macros like this. Be careful.If possible, the C++ stdlib such as vector which is much safer and easier to use.There is a clean solution with C++ templates, without using sizeof(). The following getSize() function returns the size of any static array:Here is an example with a foo_t structure:Output:For this specific example, yes, there is, IF you use typedefs (see below). Of course, if you do it this way, you\'re just as well off to use SIZEOF_DAYS, since you know what the pointer is pointing to. If you have a (void *) pointer, as is returned by malloc()  or the like, then, no, there is no way to determine what data structure the pointer is pointing to and thus, no way to determine its size.Output:As all the correct answers have stated, you cannot get this information from the decayed pointer value of the array alone. If the decayed pointer is the argument received by the function, then the size of the originating array has to be provided in some other way for the function to come to know that size.Here\'s a suggestion different from what has been provided thus far,that will work: Pass a pointer to the array instead. This suggestion is similar to the C++ style suggestions, except that C does not support templates or references:But, this suggestion is kind of silly for your problem, since the function is defined to know exactly the size of the array that is passed in (hence, there is little need to use sizeof at all on the array). What it does do, though, is offer some type safety. It will prohibit you from passing in an array of an unwanted size.If the function is supposed to be able to operate on any size of array, then you will have to provide the size to the function as additional information.There is no magic solution. C is not a reflective language. Objects don\'t automatically know what they are.But you have many choices:My solution to this problem is to save the length of the array into a struct Array as a meta-information about the array.But you have to care about set the right length of the array you want to store, because the is no way to check this length, like our friends massively explained.No, you can\'t use sizeof(ptr) to find the size of array ptr is pointing to.Though allocating extra memory(more than the size of array) will be helpful if you want  to store the length in extra space.Size of days[] is 20 which is no of elements * size of it\'s data type.\nWhile the size of pointer is 4 no matter what it is pointing to.\nBecause a pointer points to other element by storing it\'s address. It\'s not possible to find the sizeof value of the pointer, because the compiler doesn\'t know how long that pointer is poiting. The sizeof pointer should be 2 or 4 (depending on the compiler).array_size is passing to the size variable:Usage is:some functions that might help to get around the problem, but I have to mention that Zan Lynx and Paul Tomblin is correct in what they says.\nhi in strings there is a \'\\0\' character at the end so one can get the size\nof a string with functions like strlen the problem with an integer array for example is that u can\'t use any value as an end value so one possible solution is to address the array and use as an end value the NULL pointerNo, the reason comes from the array degeneration into pointer rule. When you reference the array, it\'s implicitly converted into a pointer. But this throws away information about the array: while you can know the contents and stored size of the array, you only know a pointer\'s address and its size. The solution is to work with the tuple pointer + size: degenerate the array and also store its capacity.