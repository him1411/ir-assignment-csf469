I would like to remove selected commit log entries from a linear commit tree, so that the entries do not show in the commit log.My commit tree looks something like:I would like to remove the B and C entries so that they do not show in the commit log, but changes from A to D should be preserved. Maybe by introducing a single commit, so that B and C become BC and the tree looks like.Or, ideally, after A comes D directly. D\' representing changes from A to B, B to C and C to D.Is this possible? if yes, how?This is a fairly new project so has no branches as of now, hence no merges as well.git-rebase(1) does exactly that. git awsome-ness [git rebase --interactive] contains an example.If you are lost, type:Here is a way to remove a specific commit id knowing only the commit id you would like to remove.Note that this actually removes the change that was introduced by the commit.To expand on J.F. Sebastian\'s answer:You can use git-rebase to easily make all kinds of changes to your commit history.After running git rebase --interactive you get the following in your $EDITOR:You can move lines to change the order of commits and delete lines to remove that commit. Or you can add a command to combine (squash) two commits into a single commit (previous commit is the above commit), edit commits (what was changed), or reword commit messages.I think pick just means that you want to leave that commit alone.(Example is from here)You can non-interactively remove B and C in your example with:or symbolically,Note that the changes in B and C will not be in D; they will be gone.I find this process much safer and easier to understand by creating another branch from the SHA1 of A and cherry-picking the desired changes so I can make sure I\'m satisfied with how this new branch looks. After that, it is easy to remove the old branch and rename the new one.One more way,pick the hash that you want to use it as a base, and the above command should make it interactive so you can squash all the top messages ( you need to leave the oldest )You can use git cherry-pick for this. \'cherry-pick\' will apply a commit onto the branch your on now.then do then apply the D and E commits.This will skip out the B and C commit. Having said that it might be impossible to apply the D commit to the branch without B, so YMMV.