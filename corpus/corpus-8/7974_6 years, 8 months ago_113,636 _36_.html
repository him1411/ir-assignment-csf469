I am working on catching errors in my app, and I am looking into using NSError.  I am slightly confused about how to use it, and how to populate it.Could someone provide an example on how I populate then use NSError?Well, what I usually do is have my methods that could error-out at runtime take a reference to a NSError pointer. If something does indeed go wrong in that method, I can populate the NSError reference with error data and return nil from the method.Example:We can then use the method like this. Don\'t even bother to inspect the error object unless the method returns nil:We were able to access the error\'s localizedDescription because we set a value for NSLocalizedDescriptionKey. The best place for more information is Apple\'s documentation. It really is good.There is also a nice, simple tutorial on Cocoa Is My Girlfriend. I would like to add some more suggestions based on my most recent implementation. I\'ve looked at some code from Apple and I think my code behaves in much the same way.The posts above already explain how to create NSError objects and return them, so I won\'t bother with that part. I\'ll just try to suggest a good way to integrate errors (codes, messages) in your own app.I recommend creating 1 header that will be an overview of all the errors of your domain (i.e. app, library, etc..). My current header looks like this:FSError.hFSError.mNow when using the above values for errors, Apple will create some basic standard error message for your app. An error could be created like the following:The standard Apple-generated error message (error.localizedDescription) for the above code will look like the following:Error Domain=com.felis.myapp Code=1002 "The operation couldn\xe2\x80\x99t be completed. (com.felis.myapp error 1002.)"The above is already quite helpful for a developer, since the message displays the domain where the error occured and the corresponding error code. End users will have no clue what error code 1002 means though, so now we need to implement some nice messages for each code.For the error messages we have to keep localisation in mind (even if we don\'t implement localized messages right away). I\'ve used the following approach in my current project:1) create a strings file that will contain the errors. Strings files are easily localizable. The file could look like the following:FSError.strings2) Add macros to convert integer codes to localized error messages. I\'ve used 2 macros in my Constants+Macros.h file. I always include this file in the prefix header (MyApp-Prefix.pch) for convenience.Constants+Macros.h3) Now it\'s easy to show a user friendly error message based on an error code. An example:Great answer Alex.  One potential issue is the NULL dereference. Apple\'s reference on Creating and Returning NSError objectsObjective-CSwift 3Please refer following tutorial i hope it will helpful for you but prior you have to read documentation of NSErrorThis is very interesting link i found recently ErrorHandlingI\'ll try summarize the great answer by Alex and the jlmendezbonini\'s point, adding a modification that will make everything ARC compatible (so far it\'s not since ARC will complain since you should return id, which means "any object", but BOOL is not an object type).Now instead of checking for the return value of our method call, we check whether error is still nil. If it\'s not we have a problem.Another design pattern that I have seen involves using blocks, which is especially useful when a method is being run asynchronously.Say we have the following error codes defined:You would define your method that can raise an error like so:And then when you call it, you don\'t need to worry about declaring the NSError object (code completion will do it for you), or checking the returning value. You can just supply two blocks: one that will get called when there is an exception, and one that gets called when it succeeds:Well it\'s a little bit out of question scope but in case you don\'t have an option for NSError you can always display the Low level error: