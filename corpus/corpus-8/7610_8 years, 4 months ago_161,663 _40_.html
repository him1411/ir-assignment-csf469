In a b-tree you can store both keys and data in the internal and leaf nodes, but in a b+ tree you have to store the data in the leaf nodes only.Is there any advantage of doing the above in a b+ tree?Why not use b-trees instead of b+ trees everywhere, as intuitively they seem much faster? I mean, why do you need to replicate the key(data) in a b+ tree?The image below helps show the differences between B+ trees and B trees.Advantages of B+ trees:Advantage of B trees:The principal advantage of B+ trees over B trees is they allow you to pack in more pointers to other nodes by removing pointers to data, thus increasing the fanout and potentially decreasing the depth of the tree.The disadvantage is that there are no early outs when you might have found a match in an internal node.  But since both data structures have huge fanouts, the vast majority of your matches will be on leaf nodes anyway, making on average the B+ tree more efficient.B+Trees are much easier and higher performing to do a full scan, as in look at every piece of data that the tree indexes, since the terminal nodes form a linked list.  To do a full scan with a B-Tree you need to do a full tree traversal to find all the data.B-Trees on the other hand can be faster when you do a seek (looking for a specific piece of data by key) especially when the tree resides in RAM or other non-block storage.  Since you can elevate commonly used nodes in the tree there are less comparisons required to get to the data.Define "much faster".  Asymptotically they\'re about the same.  The differences lie in how they make use of secondary storage.  The Wikipedia articles on B-trees and B+trees look pretty trustworthy.Example from Database system concepts  5th B+-tree\ncorresponding B-tree\nAdegoke A, AmitI guess one crucial point you people are missing is difference between data and pointers as explained in this section.Pointer : pointer to other nodes.Data :- In context of database indexes, data is just another pointer to real data (row) which reside somewhere else.Hence in case of B tree each node has three information keys, pointers to data associated with the keys and pointer to child nodes.In B+ tree internal node keep keys and pointers to child node while leaf node keep keys and pointers to associated data. This allows more number of key for a given size of node. Size of node is determined mainly by block size. Advantage of having more key per node is explained well above so I will save my typing effort.In B+ Tree, since only pointers are stored in the internal nodes, their size becomes significantly smaller than the internal nodes of B tree (which store both data+key).\nHence, the indexes of the B+ tree can be fetched from the external storage in a single disk read, processed to find the location of the target. If it has been a B tree, a disk read is required for each and every decision making process. Hope I made my point clear! :)B+ Trees are especially good in block-based storage (eg: hard disk). with this in mind, you get several advantages, for example (from the top of my head): high fanout / low depth: that means you have to get less blocks to get to the data.  with data intermingled with the pointers, each read gets less pointers, so you need more seeks to get to the datasimple and consistent block storage: an inner node has N pointers, nothing else, a leaf node has data, nothing else.  that makes it easy to parse, debug and even reconstruct.high key density means the top nodes are almost certainly on cache, in many cases all inner nodes get quickly cached, so only the data access has to go to disk.The primary distinction between B-tree and B+tree is that B-tree eliminates the redundant storage of search key values.Since search keys are not repeated in the B-tree,we may not be able to store the index using fewer tree nodes than in corresponding B+tree index.However,since search key that appear in non-leaf nodes appear nowhere else in B-tree,we are forced to include an additional pointer field for each search key in a non-leaf node.\nTheir are space advantages for B-tree, as repetition does not occur and can be used for large indices.**The major drawback of B-Tree is the difficulty of Traversing the keys\n  sequentially. The B+ Tree retains the rapid random access property of\n  the B-Tree while also allowing rapid sequential access**\nref: Data Structures Using C// Author:  Aaro M Tenenbaumhttp://books.google.co.in/books?id=X0Cd1Pr2W0gC&pg=PA456&lpg=PA456&dq=drawback+of+B-Tree+is+the+difficulty+of+Traversing+the+keys+sequentially&source=bl&ots=pGcPQSEJMS&sig=F9MY7zEXYAMVKl_Sg4W-0LTRor8&hl=en&sa=X&ei=nD5AUbeeH4zwrQe12oCYAQ&ved=0CDsQ6AEwAg#v=onepage&q=drawback%20of%20B-Tree%20is%20the%20difficulty%20of%20Traversing%20the%20keys%20sequentially&f=falseA B+tree is a balanced tree in which every path from the root of the tree to a leaf is of the same length, and each nonleaf node of the tree has between [n/2] and [n] children, where n is fixed for a particular tree. It contains index pages and data pages.\nBinary trees only have two children per parent node, B+ trees can have a variable number of children for each parent node Take one example - you have a table with huge data per row. That means every instance of the object is Big.If you use B tree here then most of the time is spent scanning the pages with data - which is of no use. In databases that is the reason of using B+ Trees to avoid scanning object data.B+ Trees separate keys from data. But if your data size is less then you can store them with key which is what B tree does.One possible use of B+ tress is that it is suitable for situations \nwhere the tree grows so large that it need not fit into available \nmemory. Thus, you\'d generally expect to be doing multiple I/O\'s. Often \nit does happen that a B+ tree is used even when it in fact fits into \nmemory, and then your cache manager might keep it there permanently. But \nthis is a special case, not the general one, and caching policy is a \nseparate from B+ tree maintenance as such.Also, in a B+ tree, the leaf pages are linked together in\na linked list (or doubly-linked list), which optimizes traversals\n(for range searches, sorting, etc.).  So the number of pointers is\na function of the specific algorithm that is used.