I have this scenario:How do I configure my association with fluent API? Or is there a better way to create the association table?It\'s not possible to create a many-to-many relationship with a customized join table. In a many-to-many relationship EF manages the join table internally and hidden. It\'s a table without an Entity class in your model. To work with such a join table with additional properties you will have to create actually two one-to-many relationships. It could look like this:If you now want to find all comments of members with LastName = "Smith" for example you can write a query like this:...or...Or to create a list of members with name "Smith" (we assume there is more than one) along with their comments you can use a projection:If you want to find all comments of a member with MemberId = 1:Now you can also filter by the properties in your join table (which would not be possible in a many-to-many relationship), for example: Filter all comments of member 1 which have a 99 in property Something:Because of lazy loading things might become easier. If you have a loaded Member you should be able to get the comments without an explicite query:I guess that lazy loading will fetch the comments automatically behind the scenes.EditJust for fun a few examples more how to add entities and relationships and how to delete them in this model:1) Create one member and two comments of this member:2) Add a third comment of member1:3) Create new member and relate it to the existing comment2:4) Create relationship between existing member2 and comment3:5) Delete this relationship again:6) Delete member1 and all its relationsships to the comments:This deletes the relationships in MemberComments too because the one-to-many relationships between Member and MemberComments and between Comment and MemberComments are setup with cascading delete by convention. And this is the case because MemberId and CommentId in MemberComment are detected as foreign key properties for the Member and Comment navigation properties and since the FK properties are of type non-nullable int the relationship is required which finally causes the cascading-delete-setup. Makes sense in this model, I think.Excellent answer by Slauma.I\'ll just post the code to do this using the fluent API mapping.On your DbContext derived class you could do this:It has the same effect as the accepted answer, with a different approach, which is no better nor worse.EDIT:\nI\'ve changed CreatedDate from bool to DateTime.EDIT 2:\nDue to lack of time I\'ve placed an example from an application I\'m working on to be sure this works.@Esteban, the code you provided is right, thanks, but incomplete, I\'ve tested it. There are missing properties in "UserEmail" class:I post the code I\'ve tested if someone is interested.\nRegardsTLDR; (semi-related to an EF editor bug in EF6/VS2012U5) if you generate the model from DB and you cannot see the attributed m:m table: Delete the two related tables -> Save .edmx -> Generate/add from database -> Save.For those who came here wondering how to get a many-to-many relationship with attribute columns to show in the EF .edmx file (as it would currently not show and be treated as a set of navigational properties), AND you generated these classes from your database table (or database-first in MS lingo, I believe.)Delete the 2 tables in question (to take the OP example, Member and Comment) in your .edmx and add them again through \'Generate model from database\'. (i.e. do not attempt to let Visual Studio update them - delete, save, add, save)It will then create a 3rd table in line with what is suggested here.This is relevant in cases where a pure many-to-many relationship is added at first, and the attributes are designed in the DB later.This was not immediately clear from this thread/Googling. So just putting it out there as this is link #1 on Google looking for the issue but coming from the DB side first.