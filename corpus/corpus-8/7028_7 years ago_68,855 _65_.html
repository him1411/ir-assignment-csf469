Yesterday I saw a presentation on Java Server Faces 2.0 which looked truly impressive, even though I am currently a happy ASP.NET MVC / jQuery developer. What I liked most about JSF was the huge amount of AJAX-Enabled UI components which seem to make development much faster than with ASP.NET MVC, especially on AJAX-heavy sites. Integration testing looked very nice too.  Since the presentation only emphasized the advantages of JSF, I\'d like to hear about the other side as well. So my questions are: JSF 2.0 disadvantages? Honestly, apart from the relative steep learning curve when you don\'t have a solid background knowledge about basic Web Development (HTML/CSS/JS, server side versus client side, etc) and the basic Java Servlet API (request/response/session, forwarding/redirecting, etc), no serious disadvantages comes to mind. JSF in its current release still needs to get rid of the negative image it gained during the early ages, during which there were several serious disadvantages.This was the initial release. It was cluttered with bugs in both the core and performance areas you don\'t want to know about. Your webapplication didn\'t always work as you\'d intuitively expect. You as developer would run hard away crying.This was the bugfix release. The performance was still not much improved. There was also one major disadvantage: you can\'t inline HTML in the JSF page flawlessly. All plain vanilla HTML get rendered before the JSF component tree. You need to wrap all plain vanilla in <f:verbatim> tags so that they get included in the JSF component tree. Although this was as per the specification, this has received a lot of criticism. See also a.o. JSF/Facelets: why is it not a good idea to mix JSF/Facelets with HTML tags?This was the first release of the new JSF development team lead by Ryan Lubke. The new team did a lot of great work. There were also changes in the spec. The major change was the improvement of the view handling. This not only fully detached JSF from JSP, so one could use a different view technology than JSP, but it also allowed developers to inline plain vanilla HTML in the JSF page without hassling with <f:verbatim> tags. Another major focus of the new team was improving the performance. During the lifetime of the Sun JSF Reference Implementation 1.2 (which was codenamed Mojarra since build 1.2_08, around 2008), practically every build got shipped with (major) performance improvements next to the usual (minor) bugfixes.The only serious disadvantage of JSF 1.x (including 1.2) is the lack of a scope in between the request and session scope, the so-called conversation scope. This forced developers to hassle with hidden input elements, unnecessary DB queries and/or abusing the session scope whenever one want to retain the initial model data in the subsequent request in order to successfully process validations, conversions, model changes and action invocations in the more complex webapplications. The pain could be softened by adopting a 3rd party library which retains the necessary data in the subsequent request like MyFaces Tomahawk <t:saveState> component, JBoss Seam conversation scope and MyFaces Orchestra conversation framework.Another disadvantage for HTML/CSS purists is that JSF uses the colon : as ID separator character to ensure uniqueness of the HTML element id in the generated HTML output, especially when a component is reused more than once in the view (templating, iterating components, etc). Because this is an illegal character in CSS identifiers, you would need to use the \\ to escape the colon in CSS selectors, resulting in ugly and odd-looking selectors like #formId\\:fieldId {} or even #formId\\3A fieldId {}. See also How to use JSF generated HTML element ID with colon ":" in CSS selectors? However, if you\'re not a purist, read also By default, JSF generates unusable ids, which are incompatible with css part of web standards.Also, JSF 1.x didn\'t ship with Ajax facilities out of the box. Not really a technical disadvantage, but due to the Web 2.0 hype during that period, it became a functional disadvantage. Exadel was early to introduce Ajax4jsf, which was thoroughly developed during the years and became the core part of JBoss RichFaces component library. Another component libraries were shipped with builtin Ajax powers as well, the well known one being ICEfaces.About halfway the JSF 1.2 lifetime, a new XML based view technology was introduced: Facelets. This offered enormous advantages above JSP, especially in the area of templating.This was the second major release, with Ajax as buzzword. There were a lot of technical and functional changes. JSP is replaced by Facelets as the default view technology and Facelets was expanded with capabilities to create custom components using pure XML (the so-called composite components). See also Why Facelets is preferred over JSP as the view definition language from JSF2.0 onwards?Ajax powers were introduced in flavor of the <f:ajax> component which has much similarities with Ajax4jsf. Annotations and convention-over-configuration enhancements were introduced to kill the verbose faces-config.xml file as much as possible. Also, the default naming container ID separator character : became configurable, so HTML/CSS purists could breathe relieved. All you need to do is to define it as init-param in web.xml with the name javax.faces.SEPARATOR_CHAR and ensuring that you aren\'t using the character yourself anywhere in client ID\'s, such as -.Last but not least, a new scope was introduced, the view scope. It eliminated another major JSF 1.x disadvantage as described before. You just declare the bean @ViewScoped to enable the conversation scope without hassling all ways to retain the data in subsequent (conversational) requests. A @ViewScoped bean will live as long as you\'re subsequently submitting and navigating to the same view (independently of the opened browser tab/window!), either synchronously or asynchronously (Ajax). See also Difference between View and Request scope in managed beans and How to choose the right bean scope?Although practically all disadvantages of JSF 1.x were eliminated, there are JSF 2.0 specific bugs which might become a showstopper. The @ViewScoped fails in tag handlers due to a chicken-egg issue in partial state saving. This is fixed in JSF 2.2 and backported in Mojarra 2.1.18. Also passing custom attributes like the HTML5 data-xxx is not supported. This is fixed in JSF 2.2 by new passthrough elements/attributes feature. Further the JSF implementation Mojarra has its own set of issues. Relatively a lot of them are related to the sometimes unintuitive behaviour of <ui:repeat>, the new partial state saving implementation and the poorly implemented flash scope. Most of them are fixed in a Mojarra 2.2.x version.Around the JSF 2.0 time, PrimeFaces was introduced, based on jQuery and jQuery UI. It became the most popular JSF component library.With the introduction of JSF 2.2, HTML5 was used as buzzword even though this was technically just supported in all older JSF versions. See also JavaServer Faces 2.2 and HTML5 support, why is XHTML still being used. Most important new JSF 2.2 feature is the support for custom component attributes, hereby opening a world of possibilities, such as custom tableless radio button groups. Apart from implementation specific bugs and some "annoying little things" such as inability to inject an EJB in a validator/converter (already fixed in JSF 2.3), there are not really major disadvantages in the JSF 2.2 specification. Some may opt that the major disadvantage of JSF is that it allows very little fine-grained control over the generated HTML/CSS/JS. That\'s not JSF\'s own, that\'s just because it\'s a component based MVC framework, not a request (action) based MVC framework. If a high degree of controlling the HTML/CSS/JS is your major requirement when considering a MVC framework, then you should already not be looking at a component based MVC framework, but at a request based MVC framework like Spring MVC. You only need to take into account that you\'ll have to write all that HTML/CSS/JS boilerplate yourself. See also Difference between Request MVC and Component MVC.After 5 years of working with JSF, I think that I can add my 2 cents.Two major JSF drawbacks:\n And minor drawbacks that come to my mind:\n Don\'t get me wrong. As a component framework JSF in version 2 is really good, but it\'s still component-based, and always will be...Please take a look at the low popularity of Tapestry, Wicket and low enthusiasm of experienced JSF developers (what is even more meaningful). \nAnd for contrast, take a look at the success of Rails, Grails, Django, Play! Framework - they all are action-based and don\'t try to hide from the programmer true request/response and stateless nature of the web.For me it\'s major JSF disadvantage. IMHO JSF can suits some type of applications (intranet, forms-intensive), but for real-life web application it\'s not a good way to go.  Hope it helps somebody with his/her choices that regards to front-end.A few drawbacks that pop to mind:To sum up: The time you will save with JSF, from avoiding to write the JSP/servlet/bean boilerplate code, you\'ll spent it x10 to make it scale and do exactly what you want it to do.To me the biggest disadvantage of JSF 2.0 is the learning curve not only of JSF, but the component libraries that you have to use in order to get it to do useful work.   Consider the staggering number of specifications and standards you have deal with to really be proficient:Now, once you are done with that you can get on with the proprietary specifications, namely the component libraries and provider libraries you will pick up along the way:And don\'t forget the container!  And all those configuration files:So -- THIS IS MAKING IT EASY?   Sure, JSF 2.0 is "easy" as long as all you want to do is the most basic web pages with the simplest interactions.  Simply put, JSF 2.0 is the most complicated and cumbersome mishmash of glued together technologies as exists in the software universe today.  And I can\'t think of anything I would rather use."JSF will output View-layer HTML and JavaScript that you cannot control or change without going into Controller code."Actually JSF gives you the flexibility, you can either use standard/third-party components or create your own which you have full control over what is rendered. It is just one xhtml you need to create your custom components with JSF 2.0.So in short my drawbacks would be: Complexity, Not very smooth development progress, buggy, inflexible.Of course there are advantages too, but that\'s not what you asked. Anyway that\'s my experience with framework others might have different opinions, so best way is to just try it for a while to see if its for you (just something more complex - not naive examples - JSF really shines there:) IMHO best use case for JSF is business applications, like CRMs etc... We developed a sample project with JSF (It was a three week research so we may have lose some things!)We try to use core jsf, if a component is needed we used PrimeFaces.The project was a web site with navigation. Each page should be loaded via ajax when the menu is clicked. The site has two usecases:We found that:If you change the above sample to a non Ajax project ( or at least less ajax project) you will not face lots of above issues.We summarize our research as:JSF is not working well in an fully ajax base website.Of course we find lots of nice features in JSF which may be very helpful in some projects, so consider your project needs. Please refer to JSF technical documents to review JSF advantages, and in my opinion the biggest advantage of JSF, is the COMPLETE AND HUGE support from @BalusC ;-)I\'m not a Java Server Faces expert at all. But IMHO the main disadvantage is that it\'s server side. I\'m tired of learning and using server side web presentation layer frameworks like ASP.NET Web Forms, ASP.NET MVC, Java Server Faces, Struts, php frameworks and ruby on rails frameworks. I said goodbye to all of them, and I said hello to Angularjs and TypeScript. My presentation layer runs on the browser. I doesn\'t matter if it is served by Windows IIS running php or ASP.NET, or if it is served by an Apache web server running on Linux. I just need to learn just one framework that works everywhere.Just my two cents.For me the biggest shortcoming of JSF is poor support for programmatically (dynamically) generated pages.\nIf you want to construct your page (create page component model) dynamically from java code. For example if you are working on WYSIWYG web page constructor. Adequate documentation of this use case in not generally available. There are many points where you have to experiment and development is quiet slow. Many things just don\'t work how you would expect. But generally its possible hack it somehow.\nGood thing is that it\'s not problem in philosophy or architecture of JSF. It\'s simply not elaborated enough (as far as I know).JSF 2 brought Composite Components which should make component development easy, but their support for dynamic (programmatic) construction is very poor. If you overcome quiet complicated and almost undocumented process of dynamic Composite Component construction, you will find out that If you nest few Composite components little deeper, they stop working, throwing some exceptions. But It seems that JSF community is aware of this shortcomings. They are working on this as you can see from these two bugs\nhttp://java.net/jira/browse/JAVASERVERFACES-1309\nhttp://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-599 Situation should be better with JSF 2.2 at least if we are talking about specification.Commenting on my last few months of Primefaces/JSF experience:The promise of JSF to avoid writing javascript turned into writing more javascript than we would have if not using Primefaces--and that javascript to is fix what Primefaces breaks.It\'s a time sink--unless you again use "off the shelf" stuff.  Also really ugly (Primefaces) when having to work with Selenium.  It can all be done--but again--there\'s only so much time.Definitely avoid this if you\'re working with a UX/design team and need to rapidly iterate on the UI--you can save time by learning jquery/writing straight HTML--or looking at react/angular.  Among all the "mainstream" frameworks (Spring MVC, Wicket, Tapestry, etc. etc.) the JSF of Java EE with its composite components is the most elaborated presentation layer component-oriented technology provided. It is a bit cumbersome and a bit not complete compared to solution provided by HybridJava though.  JSF has many advantages, question being on disadvantage let me add couple of points on it.On a practical scenario of implementing a web project with in a time frame you need to keep an eye on the following factors.Do you have the bandwidth to accommodate the initial learning curve?Do you have enough expertise in your team who can review the JSF\nstuff produces by the developers?If your answer is \'No\' for the questions, you may end up in a non-maintainable codebase.JSF has only one disadvantage: before starting JSF development you should clearly understand web development, core java and frontend architecture.Now days "new" js frameworks just try to copy/paste JSF component based model . 