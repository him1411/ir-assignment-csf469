I\'m writing an iOS app with a table view inside a tab view. In my UITableViewController, I implemented -tableView:didSelectRowAtIndexPath:, but when I select a row at runtime, the method isn\'t being called.  The table view is being populated though, so I know that other tableView methods in my controller are being called.Does anyone have any ideas what I may have screwed up to make this happen?It sounds like perhaps the class is not the UITableViewDelegate for that table view, though UITableViewController is supposed to set that automatically.Any chance you reset the delegate to some other class?Just in case someone made the same stupid mistake as I did:Check out if the method name of what you expect of being didSelect may accidentally be gotten didDeselect in some way. It took about two hours for me to find out ...Another thing that might lead to the issue is not selected selection kind:Should be Single Selection for normal selection, should not be No Selection.Another possibility is that a UITapGestureRecognizer could be eating the events, as was the case here: https://stackoverflow.com/a/9248827/214070I didn\'t suspect this cause, because the table cells would still highlight blue as if the taps were getting through.All good answers, but there\'s one more to look out for...(Particularly when creating a UITableView programmatically)Make sure the tableView can respond to selection by setting [tableView setAllowsSelection:YES]; or removing any line that sets it to NO.If the problem arise with UITapGestureRecognizer you can fix this:in code with Objective-C:in code with Swift:I have encountered two things in this situations.You may have forgot to implement UITableViewDelegate protocol, or there\'s no delegation outlet between your class and your table view.You might have a UIView inside your row that is a first responder and takes your clicks away. Say a UIButton or something similar.I have had the same problem. And it was hard to find. But somewhere in my code\nwas this:It must be return indexPath, else -tableView:didSelectRowAtIndexPath: is not being called.I\'ve ran into a problem where after months of not looking at my code I forgot that I implemented the following method due to some requirements which were not necessaryIt should be returning YES for a row in order to make it selected. If you added a gestureRecognizer on top of the UITableView, didSelectRowAtIndexPath is not called. if so you need to use gestureRecognizer delegate method to avoid touch in particular view.YOU MUST select these options but if you want to make uitableview not highlighted on clicking then you should make changes in UITableViewCell properties... Choose None option for Selection.. just like... In case you have the same problem as me: \nApparently, this method won\'t be called if your tableView is in edit mode. You have to set allowsSelectionDuringEditing to true.Via this question: When editing, `UITableView` does not call didSelectRowAtIndexPath ??I had put a UITapGestureRecognizer on my table view to dismiss the keyboard which prevented didSelectRowAtIndexPath: from being called. Hope it helps someone.I had the same problem, The reason was using of UITapGestureRecognizer. I wanted the keyboard to dismiss when I tapped anywhere else. I realized that this overrides all tap actions, that is why, didSelectRowAtIndexPath function did not called.When I comment the rows related with UITapGestureRecognizer, it works. Moreover you can check in the function of UITapGestureRecognizer selector if the tapped is UITableViewCell or not.For Xcode 6.4, Swift 1.2 . The selection "tag" had been changed in IB. I don\'t know how and why. Setting it to "Single Selection" made my table view cells selectable again.  Even though another answer has been accepted, I\'ll add one more possible problem and solution for people who observe this issue:If you have automatic reference counting (ARC) turned on, you may find that even after assigning your controller as a delegate of the view, the view\'s messages to the controller are not being received because ARC is deleting the controller.  Apparently the UITableView\'s delegate pointer does not count as a reference for the ARC, so if that is the only reference to it, the controller will be dealloc\'d.  You can verify whether or not this is happening by implementing the dealloc method on the controller and setting a breakpoint or NSLog call there.The solution is to keep track of the controller with a strong reference somewhere else, until you are sure you won\'t need it anymore.My problem was none of the above.  And so lame.  But I thought I would list it here in case it helps someone. I have a tableViewController that is my "base" controller and then I create subclasses of this controller.  I was writing all my code in the tableView:didSelectRowAtIndexPath routine in the "base" class.  Completely forgetting that by default this routine had also been created (albeit with no code that did anything) in all of my subclasses as well.  So when I ran my app, it ran the subclass version of the code, did nothing, and made me sad.  So of course, once I removed the routine from the subclasses, it used mt "base" class routine and I\'m in business.I know.  Don\'t laugh.  But maybe this will save someone the hour I lost...Giving my 2 cents on this.I had a Custom UITableViewCell and there was a button covering the whole cell, so when the touch happened, the button was selected and not the cell.Either remove the button or in my case, I set User Interation Enable to false on the button, that way the cell was the one selected.I just had this and as has happened to me in the past it didn\'t work because I didn\'t pay attention to the autocomplete when trying to add the method and I actually end up implementing tableView:didDeselectRowAtIndexPath: instead of tableView:didSelectRowAtIndexPath:.If you read this, so still doesn\'t solve the problem. I have custom cell, where checkbox "User Interaction Enabled" was disable. So, I Just switch on it. Good luck. Remember to set the datasource and delegate in the viewDidLoad method as follows:I know is old and the problem was resolved, but a had similar problem, I thought that the problem was with my custom UITableViewCell, but the solution was completely different - I restart XCode :) and then works ok ! almost like Windows :)None of these answers worked for me. After about an hour, I figured out something very insidious:I have a table view inside a cell of another table view. I decided to make an enclosing view that contains the inner table view, among other things. I called this view contentView and hooked it up in the xib.Turns out that UITableViewCell already has a contentView and does weird things with it. The issue resolved itself when I renamed the property to mainContentView and reconnected the view to this renamed property.Ok, updating here as I just ran into this problem, and my issue was slightly different than found here.  I looked in IB and saw that my delegate WAS set, but it was set incorrectly to VIEW instead of File\'s Owner (right click on table view to see where delegate is pointing to).Hope that helps someoneAnother mistake you could\'ve done (as I did): if you set a segue at the cell, didSelectRowAtIndexPath is not called. You should set your segues at the view controller instead.Take care about the UITableView properties in the storyboard, what happened in my case was that I had the combox in the storyboard selected as "Selection: Single Selection", that does not allow the method didSelectRowAtIndexPath run.This was probably only in my case, but I had reloaded some files from a backup and things were not working, including this. After doing a full clean (Product > Clean or Shift + Command + K) it worked. Probably something got messed up in a precompiled header. Chances are that\'s not the problem for you, but it\'s worth a shot.If You have a custom cell, remember to set UserInteractionEnabled in the Xib (or via code) for the cell.Check if -heightForRowAtIndexPath doesnt return 0.In my case, I dynamically calculate the height of the TableView\'s SuperView at load time. Due to a miscalculation, the TableView was positioned outside of the SuperView. The TableView was drawn fine, however all interaction was disabled (and didSelectRowAtIndexPath was never called). Very hard to detect, since there is no visual indication that the TableView is not "accessible".