What is the recommended way of handling settings for local development and the production server? Some of them (like constants, etc) can be changed/accessed in both, but some of them (like paths to static files) need to remain different, and hence should not be overwritten every time the new code is deployed.Currently, I am adding all constants to settings.py. But every time I change some constant locally, I have to copy it to the production server and edit the file for production specific changes... :( Edit: looks like there is no standard answer to this question, I\'ve accepted the most popular method.In settings.py:You can override what needed in local_settings.py; it should stay out of your version control then. But since you mention copying I\'m guessing you use none ;)Two Scoops of Django: Best Practices for Django 1.5 suggests using version control for your settings files and storing the files in a separate directory:The base.py file contains common settings (such as MEDIA_ROOT or ADMIN), while local.py and production.py have site-specific settings:In the base file settings/base.py:In the local development settings file settings/local.py:In the file production settings file settings/production.py:Then when you run django, you add the --settings option:The authors of the book have also put up a sample project layout template on Github.Instead of settings.py, use this layout:common.py is where most of your configuration lives.prod.py imports everything from common, and overrides whatever it needs to override:Similarly, dev.py imports everything from common.py and overrides whatever it needs to override.Finally, __init__.py is where you decide which settings to load, and it\'s also where you store secrets (therefore this file should not be versioned):What I like about this solution is:I use a slightly modified version of the "if DEBUG" style of settings that Harper Shelby posted.  Obviously depending on the environment (win/linux/etc.) the code might need to be tweaked a bit.I was in the past using the "if DEBUG" but I found that occasionally I needed to do testing with DEUBG set to False.  What I really wanted to distinguish if the environment was production or development, which gave me the freedom to choose the DEBUG level.I\'d still consider this way of settings a work in progress. I haven\'t seen any one way to handling Django settings that covered all the bases and at the same time wasn\'t a total hassle to setup (I\'m not down with the 5x settings files methods).I use a settings_local.py and a settings_production.py. After trying several options I\'ve found that it\'s easy to waste time with complex solutions when simply having two settings files feels easy and fast.When you use mod_python/mod_wsgi for your Django project you need to point it to your settings file. If you point it to app/settings_local.py on your local server and app/settings_production.py on your production server then life becomes easy. Just edit the appropriate settings file and restart the server (Django development server will restart automatically).The problem with most of these solutions is that you either have your local settings applied before the common ones, or after them.So it\'s impossible to override things likeat the same time.One solution can be implemented using "ini"-style config files with the ConfigParser class. It supports multiple files, lazy string interpolation, default values and a lot of other goodies.\nOnce a number of files have been loaded, more files can be loaded and their values will override the previous ones, if any.You load one or more config files, depending on the machine address, environment variables and even values in previously loaded config files. Then you just use the parsed values to populate the settings. One strategy I have successfully used has been:As an example of something you can achieve with this, you can define a "subdomain" value per-env, which is then used in the default settings (as hostname: %(subdomain).whatever.net) to define all the necessary hostnames and cookie things django needs to work.This is as DRY I could get, most (existing) files had just 3 or 4 settings. On top of this I had to manage customer configuration, so an additional set of configuration files (with things like database names, users and passwords, assigned subdomain etc) existed, one or more per customer.One can scale this as low or as high as necessary, you just put in the config file the keys you want to configure per-environment, and once there\'s need for a new config, put the previous value in the default config, and override it where necessary.This system has proven reliable and works well with version control. It has been used for long time managing two separate clusters of applications (15 or more separate instances of the django site per machine), with more than 50 customers, where the clusters were changing size and members depending on the mood of the sysadmin...I manage my configurations with the help of django-split-settings. It is a drop-in replacement for the default settings. It is simple, yet configurable. And refactoring of your exisitng settings is not required.Here\'s a small example (file example/settings/__init__.py):That\'s it.I wrote a blog post about managing django\'s settings with django-split-sttings. Have a look!Remember that settings.py is a live code file. Assuming that you don\'t have DEBUG set on production (which is a best practice), you can do something like:Pretty basic, but you could, in theory, go up to any level of complexity based on just the value of DEBUG - or any other variable or code check you wanted to use.I am also working with Laravel and I like the implementation there. I tried to mimic it and combining it with the solution proposed by T. Stone (look above):Maybe something like this would help you.My solution to that problem is also somewhat of a mix of some solutions already stated here:I then base all my environment-dependent settings on that one:I prefer this to having two separate settings.py files that I need to maintain as I can keep my settings structured in a single file easier than having them spread across several files. Like this, when I update a setting I don\'t forget to do it for both environments.Of course that every method has its disadvantages and this one is no exception. The problem here is that I can\'t overwrite the local_settings.py file whenever I push my changes into production, meaning I can\'t just copy all files blindly, but that\'s something I can live with.For most of my projects I use following pattern:(To run manage.py with custom settings file you simply use --settings command option: manage.py <command> --settings=settings_you_wish_to_use.py)I use a variation of what jpartogi mentioned above, that I find a little shorter:Basically on each computer (development or production) I have the appropriate hostname_settings.py file that gets dynamically loaded.There is also Django Classy Settings. I personally am a big fan of it. It\'s built by one of the most active people on the Django IRC. You would use environment vars to set things.http://django-classy-settings.readthedocs.io/en/latest/I differentiate it in manage.py and created two separate settings file: local_settings.py and prod_settings.py. In manage.py I check whether the server is local server or production server. If it is a local server it would load up local_settings.py and it is a production server it would load up prod_settings.py. Basically this is how it would look like:I found it to be easier to separate the settings file into two separate file instead of doing lots of ifs inside the settings file.As an alternative to maintain different file if you wiil:\nIf you are using git or any other VCS to push codes from local to server, what you can do is add the settings file to .gitignore.This will allow you to have different content in both places without any problem. SO on server you can configure an independent version of settings.py and any changes made on the local wont reflect on server and vice versa.In addition, it will remove the settings.py file from github also, the big fault, which i have seen many newbies doing.In order to use different settings configuration on different environment, create different settings file. And in your deployment script, start the server using --settings=<my-settings.py> parameter, via which you can use different settings on different environment.Benefits of using this approach:Your settings will be modular based on each environmentYou may import the master_settings.py containing the base configuration in the environmnet_configuration.py and override the values that you want to change in that environment.If you have huge team, each developer may have their own local_settings.py which they can add to the code repository without any risk of modifying the server configuration. You can add these local settings to .gitnore if you use git or .hginore if you Mercurial for Version Control (or any other). That way local settings won\'t even be the part of actual code base keeping it clean.TL;DR: The trick is to modify os.environment before you import settings/base.py in any settings/<purpose>.py, this will greatly simplify things.Just thinking about all these intertwining files gives me a headache. \nCombining, importing (sometimes conditionally), overriding, patching of what was already set in case DEBUG setting changed later on. \nWhat a nightmare!Through the years I went through all different solutions. They all somewhat work, but are so painful to manage. \nWTF! Do we really need all that hassle? We started with just one settings.py file. \nNow we need a documentation just to correctly combine all these together in a correct order!I hope I finally hit the (my) sweet spot with the solution below.Keep secrets a secret \xe2\x80\x94 don\'t store them in a repo.Set/read keys and secrets through environment settings, 12 factor style.Have sensible fallback defaults. Ideally for local development you don\'t need anything more beside defaults.\xe2\x80\xa6but try to keep defaults production safe. It\'s better to miss a setting override locally, \nthan having to remember to adjust default settings safe for production.Have the ability to switch DEBUG on/off in a way that can have an effect on other settings (eg. using javascript compressed or not).Switching between purpose settings, like local/testing/staging/production, should be based only on DJANGO_SETTINGS_MODULE, nothing more.\xe2\x80\xa6but allow further parametrization through environment settings like DATABASE_URL.\xe2\x80\xa6also allow them to use different purpose settings and run them locally side by side, eg. production setup on local developer machine, to access production database or smoke test compressed style sheets.Fail if an environment variable is not explicitly set (requiring an empty value at minimum), especially in production, eg. EMAIL_HOST_PASSWORD.Respond to default DJANGO_SETTINGS_MODULE set in manage.py during django-admin startprojectKeep conditionals to a minimum, if the condition is the purposed environment type (eg. for production set log file and it\'s rotation), override settings in associated purposed settings file.   Do not let django read DJANGO_SETTINGS_MODULE setting form a file.\nUgh! Think of how meta this is. If you need to have a file (like docker\nenv) read that into the environment before staring up a django process.Do not override DJANGO_SETTINGS_MODULE in your project/app code, eg. based on hostname or process name.\nIf you are lazy to set environment variable (like for setup.py test) do it in tooling just before you run your project code.Avoid magic and patching of how django reads it\'s settings, preprocess the settings but do not interfere afterwards. No complicated logic based nonsense. Configuration should be fixed and materialized not computed on the fly. \nProviding a fallback defaults is just enough logic here.\nDo you really want to debug, why locally you have correct set of settings but in production on a remote server, \non one of hundred machines, something computed differently? Oh! Unit tests? For settings? Seriously?      My strategy consists of excellent django-environ used with ini style files, \nproviding os.environment defaults for local development, some minimal and short settings/<purpose>.py files that have an \nimport settings/base.py AFTER the os.environment was set from an INI file. This effectively give us a kind of settings injection.The trick here is to modify os.environment before you import settings/base.py.To see the full example go do the repo: https://github.com/wooyek/django-settings-strategyA defaults for local development. A secret file, to mostly set required environment variables. \nSet them to empty values if they are not required in local development. \nWe provide defaults here and not in settings/base.py to fail on any other machine if the\'re missing from the environment.What happens in here, is loading environment from settings/.env, then importing common settings \nfrom settings/base.py. After that we can override a few to ease local development.For production we should not expect an environment file, but it\'s easier to have one if we\'re testing something. \nBut anyway, lest\'s provide few defaults inline, so settings/base.py can respond accordingly. The main point of interest here are DEBUG and ASSETS_DEBUG overrides, \nthey will be applied to the python os.environ ONLY if they are MISSING from the environment and the file. These will be our production defaults, no need to put them in the environment or file, but they can be overridden if needed. Neat!These are your mostly vanilla django settings, with a few conditionals and lot\'s of reading them from the environment. \nAlmost everything is in here, keeping all the purposed environments consistent and as similar as possible.The main differences are below (I hope these are self explanatory):The last bit shows the power here. ASSETS_DEBUG has a sensible default, \nwhich can be overridden in settings/production.py and even that that can be overridden by an environment setting! Yay! In effect we have a mixed hierarchy of importance:1 - Create a new folder inside your app and name settings to it.2 - Now create a new init.py file in it and inside it writefrom .local import *passfrom .production import *pass3 - Create three new files in the settings folder name local.py and production.py and base.py4 - Inside base.py copy all the content of previous settings.p folder and rename it with something different let say old_settings.py5 - In base.py change your BASE_DIR path to point to your new path of settingOld path-> BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(file)))New path -> BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(file)))now in this way the project dir can be structured and can be manageable among production and local development.I had my settings split as follows  We have 3 environments  Now obviously staging and production should have the maximum possible similar environment. So we kept prod.py for both.But there was a case where I had to identify running server is a production server. @T. Stone \'s answer helped me write check as follows.  I found the responses here very helpful. (Has this been more definitively solved? The last response was a year ago.) After considering all the approaches listed, I came up with a solution that I didn\'t see listed here. My criteria were:I thought switching on the host machine made some sense, but then figured the real issue here is different settings for different environments, and had an aha moment. I put this code at the end of my settings.py file:This way, the app defaults to production settings, which means you are explicitly "whitelisting" your development environment. It is much safer to forget to set the environment variable locally than if it were the other way around and you forgot to set something in production and let some dev settings be used. When developing locally, either from the shell or in a .bash_profile or wherever:(Or if you\'re developing on Windows, set via the Control Panel or whatever its called these days... Windows always made it so obscure that you could set environment variables.)With this approach, the dev settings are all in one (standard) place, and simply override the production ones where needed. Any mucking around with development settings should be completely safe to commit to source control with no impact on production. 