Is there any way to tell whether a string represents an integer (e.g., \'3\', \'-17\' but not \'3.14\' or \'asfasfas\') Without using a try/except mechanism?If you\'re really just annoyed at using try/excepts all over the place, please just write a helper function:It\'s going to be WAY more code to exactly cover all the strings that Python considers integers.  I say just be pythonic on this one.with positive integers you could use .isdigit:it doesn\'t work with negative integers though. suppose you could try the following:it won\'t work with \'16.0\' format, which is similar to int casting in this sense.edit:You know, I\'ve found (and I\'ve tested this over and over) that try/except does not perform all that well, for whatever reason.  I frequently try several ways of doing things, and I don\'t think I\'ve ever found a method that uses try/except to perform the best of those tested, in fact it seems to me those methods have usually come out close to the worst, if not the worst.  Not in every case, but in many cases.  I know a lot of people say it\'s the "Pythonic" way, but that\'s one area where I part ways with them.  To me, it\'s neither very performant nor very elegant, so, I tend to only use it for error trapping and reporting.I was going to gripe that PHP, perl, ruby, C, and even the freaking shell have simple functions for testing a string for integer-hood, but due diligence in verifying those assumptions tripped me up!  Apparently this lack is a common sickness.  Here\'s a quick and dirty edit of Richard\'s post:Here\'s the interesting part of the output:As you can see, the string method is the fastest.  It is almost twice as fast as the regex method that avoids relying on any globals, and more than half again faster than the try:except method.  The regex method that relies on some globals (or, well, module attributes) is a close second.I think of these, my choice would beBut eh.. this is copying and recopying and recopying the entire string!  (And yet it\'s the fastest method!?)  A C method could scan it Once Through, and be done.  A C method that scans the string once through would be the Right Thing to do, I think?  I guess there might be some string encoding issues to deal with..  Anyway, I\'d try and work one out now, but I\'m out of time for this.  =(  Maybe I\'ll come back to it later.  Use a regular expression:If you must accept decimal fractions also:For improved performance if you\'re doing this often, compile the regular expression only once using re.compile().The proper RegEx solution would combine the ideas of Greg Hewgill and Nowell, but not use a global variable. You can accomplish this by attaching an attribute to the method. Also, I know that it is frowned upon to put imports in a method, but what I\'m going for is a "lazy module" effect like http://peak.telecommunity.com/DevCenter/Importing#lazy-importsedit: My favorite technique so far is to use exclusively methods of the String object.And for the less adventurous members of the class, here is the output:Greg Hewgill\'s approach was missing a few components: the leading "^" to only match the start of the string, and compiling the re beforehand. But this approach will allow you to avoid a try: exept:I would be interested why you are trying to avoid try: except?So your function would be:I thinkwould be better to rewrite to:because s[1:] also creates a new stringBut much better solution isThis is probably the most straightforward and pythonic way to approach it in my opinion. I didn\'t see this solution and it\'s basically the same as the regex one, but without the regex. Here is a function that parses without raising errors. It handles obvious cases returns None on failure (handles up to 2000 \'-/+\' signs by default on CPython!):Some tests:Results:For your needs you can use:I have one possibility that doesn\'t use int at all, and should not raise an exception unless the string does not represent a numberIt should work for any kind of string that float accepts, positive, negative, engineering notation...Uh.. Try this: This works if you don\'t put a string that\'s not a number.And also (I forgot to put the number check part. ), there is a function checking if the string is a number or not. It is str.isdigit(). Here\'s an example: If you call a.isdigit(), it will return True. 