I am working on a project and have to compare two files and see if they match eachother excatly.My first draft before alot of error checking and validation came up with:It seems a little odd to have nested using statements.Is there a better way to do this?The preferred way to do this is to only put an opening brace { after the last using statement, like this:If the objects are of the same type you can do the followingWhen the IDisposables are of the same type, you can do the following:The MSDN page on using has documentation on this language feature.You can do the following whether or not the IDisposables are of the same type:if you don\'t mind declaring the variables for your using block before the using block, you could declare them all in the same using statement. That way, x and y are just placeholder variables of type IDisposable for the using block to use and you use t and u inside your code. Just thought i\'d mention.If you want to compare the files efficiently, don\'t use StreamReaders at all, and then the usings aren\'t necessary - you can use low level stream reads to pull in buffers of data to compare.You can also compare things like the file size first to quickly detect different files to save yourself having to read all the data, too.You can also say:But some people might find that hard to read. BTW, as an optimization to your problem, why dont you check that the file sizes are the same size first, before going line by line?The using statement works off of the IDisposable interface so another option could be to create some type of composite class that implements IDisposable and has references to all of the IDisposable objects you would normally put in your using statement. The down side to this is that you have to declare your variables first and outside of the scope for them to be useful within the using block requiring more lines of code than some of the other suggestions would require.The constructor for DisposableCollection is a params array in this case so you can feed in as many as you like.There\'s nothing odd about it.  using is a shorthand way of ensuring the disposal of the object once the code block is finished.  If you have a disposable object in your outer block that the inner block needs to use, this is perfectly acceptable.Edit: Too slow on the typing to show consolidated code example.  +1 to everyone else.You could omit the brackets on all but the inner-most using:I think this is cleaner than putting several of the same type in the same using, as others have suggested, but I\'m sure many people will think this is confusingAnd to just add to the clarity, in this case, since each successive statement is a single statement, (and not a block), you can omit all the brackets :You can group multiple disposable objects in one using-statement with commas:These come up time to time when I code as well. You could consider move the second using statement into another function?Are you also asking if there is a better way to compare to files?\nI prefer calculating a CRC or MD5 for both files and compare those.For example you could use the following extension method:Once you\'ve done that it\'s pretty easy to compare files:You could use the built in System.Security.Cryptography.MD5 class,\nbut the calculated hash is a byte[] so you\'d still have to compare those two arrays.Also, if you already know the paths, there\'s no point is scanning the directory.Instead, I would recommend something like this:Path.Combine will add a folder or filename to a path and make sure that there is exactly one backslash between the path and the name.File.OpenText will open a file and create a StreamReader in one go.By prefixing a string with @, you can avoid having to escape every backslash (eg, @"a\\b\\c")I think I may have found a syntactically cleaner way of declaring this using statement, and it appears to work for me? using var as your type in the using statement instead of IDisposable seems to dynamically infer type on both objects and allows me to instantiate both of my objects and call their properties and methods of the class they are allocated with, as in using(var uow = new UnitOfWorkType1(), uow2 = new UnitOfWorkType2()){}. If anyone knows why this isn\'t right, please let me know