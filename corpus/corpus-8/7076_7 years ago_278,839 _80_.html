In Bash, what is the simplest way to test if an array contains a certain value?    Edit: With help from the answers and the comments, after some testing, I came up with this:I\'m not sure if it\'s the best solution, but it seems to work.There is sample code that shows how to replace a substring from an array.  You can make a copy of the array and try to remove the target value from the copy.  If the copy and original are then different, then the target value exists in the original string.The straightforward (but potentially more time-consuming) solution is to simply iterate through the entire array and check each item individually.  This is what I typically do because it is easy to implement and you can wrap it in a function (see this info on passing an array to a function).Below is a small function for achieving this. The search string is the first argument and the rest are the array elements:A test run of that function could look like:This approach has the advantage of not needing to loop over all the elements (at least not explicitly).  But since array_to_string_internal() in array.c still loops over array elements and concatenates them into a string, it\'s probably not more efficient than the looping solutions proposed, but it\'s more readable.Note that in cases where the value you are searching for is one of the words in an array element with spaces, it will give false positives.  For exampleThe regex will see Jack as being in the array even though it isn\'t.  So you\'ll have to change IFS and the separator characters on your regex if you want still to use this solution, like thisFor strings:I typically just use:non zero value indicates a match was found.If you need performance, you don\'t want to loop over your whole array every time you search.In this case, you can create an associative array (hash table, or dictionary) that represents an index of that array. I.e. it maps each array element into its index in the array:Then you can use it like this:And test membership like so:Or also:Notice that this solution does the right thing even if the there are spaces in the tested value or in the array values.As a bonus, you also get the index of the value within the array with:Here is a small contribution :Note: this way doesn\'t distinguish the case "two words" but this is not required in the question.Now handles empty arrays correctly.If you want to do a quick and dirty test to see if it\'s worth iterating over the whole array to get a precise match, Bash can treat arrays like scalars. Test for a match in the scalar, if none then skipping the loop saves time. Obviously you can get false positives.This will output "Checking" and "Match". With array=(word "two words" something) it will only output "Checking". With array=(word "two widgets" something) there will be no output.Another one liner without a function:Thanks @Qwerty for the heads up regarding spaces!If you prefer you can use equivalent long options:This is working for me:Example call:given :then a simple check of :where(The reason for assigning p separately, rather than using the expression directly inside [[ ]] is to maintain compatibility for bash 4)I generally write these kind of utilities to operate on the name of the variable, rather than the variable value, primarily because bash can\'t otherwise pass variables by reference.Here\'s a version that works with the name of the array:With this, the question example becomes:etc.Here\'s my take on this.I\'d rather not use a bash for loop if I can avoid it, as that takes time to run. If something has to loop, let it be something that was written in a lower level language than a shell script.This works by creating a temporary associative array, _arr, whose indices are derived from the values of the input array. (Note that associative arrays are available in bash 4 and above, so this function won\'t work in earlier versions of bash.) We set $IFS to avoid word splitting on whitespace.The function contains no explicit loops, though internally bash steps through the input array in order to populate printf. The printf format uses %q to ensure that input data are escaped such that they can safely be used as array keys.Note that everything this function uses is a built-in to bash, so there are no external pipes dragging you down, even in the command expansion.And if you don\'t like using eval ... well, you\'re free to use another approach. :-)Borrowing from Dennis Williamson\'s answer, the following solution combines arrays, shell-safe quoting, and regular expressions to avoid the need for: iterating over loops; using pipes or other sub-processes; or using non-bash utilities.The above code works by using Bash regular expressions to match against a stringified version of the array contents.  There are six important steps to ensure that the regular expression match can\'t be fooled by clever combinations of values within the array:Here is my take on this problem. Here is the short version:And the long version, which I think is much easier on the eyes.Examples:Format each array member on a new line, then grep the lines.  Note that this has no problems with delimeters and spaces.After having answered, I read another answer that I particularly liked, but it was flawed and downvoted. I got inspired and here are two new approaches I see viable.For not_found results add || <run_your_if_notfound_command_here>Combining a few of the ideas presented here you can make an elegant if statment without loops that does exact word matches.This will not trigger on word or val, only whole word matches. It will break if each array value contains multiple words.The following code checks if a given value is in the array and returns its zero-based offset:The match is done on the complete values, therefore setting VALUE="three" would not match.This could be worth investigating if you don\'t want to iterate:Snippet adapted from: http://www.thegeekstuff.com/2010/06/bash-array-tutorial/\nI think it is pretty clever.EDIT:\nYou could probably just do:But the latter only works if the array contains unique values. Looking for 1 in "143" will give false positive, methinks.Although there were several great and helpful answers here, I didn\'t find one that seemed to be the right combination of performant, cross-platform, and robust; so I wanted to share the solution I wrote for my code:Expanding on the above answer from Sean DiSanti, I think the following is a simple and elegant solution that avoids having to loop over the array and won\'t give false positives due to partial matchesfunction is_in_array {\n    local ELEMENT="${1}"\n    local DELIM=","\n    printf "${DELIM}%s${DELIM}" "${@:2}" | grep -q "${DELIM}${ELEMENT}${DELIM}"\n}Which can be called like so:$ haystack=("needle1" "needle2" "aneedle" "spaced needle")\n$ is_in_array "needle" "${haystack[@]}"\n$ echo $?\n1\n$ is_in_array "needle1" "${haystack[@]}"\n$ echo $?\n0My version of the regular expressions technique that\'s been suggested already:What\'s happening here is that you\'re expanding the entire array of supported values into words and prepending a specific string, "X-" in this case, to each of them, and doing the same to the requested value. If this one is indeed contained in the array, then the resulting string will at most match one of the resulting tokens, or none at all in the contrary. In the latter case the || operator triggers and you know you\'re dealing with an unsupported value. Prior to all of that the requested value is stripped of all leading and trailing whitespace through standard shell string manipulation.It\'s clean and elegant, I believe, though I\'m not too sure of how performant it may be if your array of supported values is particularly large.A combination of answers by Beorn Harris and loentar gives one more interesting one-liner test:This one does not use extra functions, does not make replacements for testing and adds extra protection against occasional false matches using a control code as a delimiter.A little late, but you could use this:I came up with this one, which turns out to work only in zsh, but I think the general approach is nice.You take out your pattern from each element only if it starts ${arr[@]/#pattern/} or ends ${arr[@]/%pattern/} with it. These two substitutions work in bash, but both at the same time ${arr[@]/#%pattern/} only works in zsh.If the modified array is equal to the original, then it doesn\'t contain the element.Edit:This one works in bash:After the substitution it compares the length of both arrays. Obly if the array contains the element the substitution will completely delete it, and the count will differ.save as file => build.shRun command sh build.sh docker