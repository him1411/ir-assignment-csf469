Ive got a bunch of rectangular objects which I need to pack into the smallest space possible (the dimensions of this space should be powers of two).I\'m aware of various packing algorithms that will pack the items as well as possible into a given space, however in this case I need the algorithm to work out how large that space should be as well.Eg say Ive got the following rectanglesThey can be packed into a 128*128 spaceHowever if there was also a 160*32 and a 64*64 one it would need a 256*128 spaceWhat algorithms are there that are able to pack a bunch of rectangles and determine the required size for the container (to a power of 2, and within a given maximum size for each dimension)?The quick and dirty first pass solution is always a great one to start with, as a comparison if nothing else.Greedy placement from large to small.Put the largest rectangle remaining into your packed area. If it can\'t fit anywhere, place it in a place that extends the pack region as little as possible. Repeat until you finish with the smallest rectangle.It\'s not perfect at all but it\'s easy and a nice baseline. It would still pack your original example perfectly, and give you an equivalent answer for the second as well.See this page on the ARC project for a survey of solutions, there is a trade-off between implementation complexity/time and optimality, but there is a wide range of algorithms to choose from.Here\'s an extract of the algorithms:First-Fit Decreasing Height (FFDH) algorithm\nFFDH packs the next item R (in non-increasing height) on the first level where R fits. If no level can accommodate R, a new level is created.\nTime complexity of FFDH: O(n\xc2\xb7log n).\nApproximation ratio: FFDH(I)<=(17/10)\xc2\xb7OPT(I)+1; the asymptotic bound of 17/10 is tight.Next-Fit Decreasing Height (NFDH) algorithm\nNFDH packs the next item R (in non-increasing height) on the current level if R fits. Otherwise, the current level is "closed" and a new level is created.\nTime complexity: O(n\xc2\xb7log n).\nApproximation ratio: NFDH(I) <= 2\xc2\xb7OPT(I)+1; the asymptotic bound of 2 is tight.Best-Fit Decreasing Height (BFDH) algorithm\nBFDH packs the next item R (in non-increasing height) on the level, among those that can accommodate R, for which the residual horizontal space is the minimum. If no level can accommodate R, a new level is created. Bottom-Left (BL) Algorithm\nBL first order items by non-increasing width. BL packs the next item as near to the bottom as it will fit and then as close to the left as it can go without overlapping with any packed item. Note that BL is not a level-oriented packing algorithm.\nTime complexity: O(n^2).\nApproximation ratio: BL(I) <= 3\xc2\xb7OPT(I).  Baker\'s Up-Down (UD) algorithm\nUD uses a combination of BL and a generalization of NFDH. The width of the strip and the items are normalized so that the strip is of unit width. UD orders the items in non-increasing width and then divides the items into five groups, each with width in the range (1/2, 1], (1/3,1/2], (1/4,1/3], (1/5,1/4], (0,1/5]. The strip is also divided into five regions R1, \xc2\xb7\xc2\xb7\xc2\xb7 , R5. Basically, some items of width in the range (1/i+1, 1/i], for 1 <= i <= 4, are packed to region Ri by BL. Since BL leaves a space of increasing width from top to bottom at the right side of the strip, UD takes this advantage by first packing the item to Rj for j = 1, \xc2\xb7\xc2\xb7\xc2\xb7 , 4 (in order) from top to bottom. If there is no such space, the item is packed to Ri by BL. Finally, items of size at most 1/5 are packed to the spaces in R1, \xc2\xb7\xc2\xb7\xc2\xb7 , R4 by the (generalized) NFDH algorithm. Again if there is no space in these regions, the item is packed to R5 using NFDH.\nApproximation ratio: UD(I) <= (5/4) \xc2\xb7 OPT(I)+(53/8)H, where H is the maximum height of the items; the asymptotic bound of 5/4 is tight.Reverse-fit (RF) algorithm\nRF also normalizes the width of the strip and the items so that the strip is of unit width. RF first stacks all items of width greater than 1/2. Remaining items are sorted in non-increasing height and will be packed above the height H0 reached by those greater than 1/2. Then RF repeats the following process. Roughly speaking, RF packs items from left to right with their bottom along the line of height H0 until there is no more room. Then packs items from right to left and from top to bottom (called reverse-level) until the total width is at least 1/2. Then the reverse-level is dropped down until (at least) one of them touches some item below. The drop down is somehow repeated.\nApproximation ratio: RF(I) <= 2\xc2\xb7OPT(I).Steinberg\'s algorithm\nSteinberg\'s algorithm, denoted as M in the paper, estimates an upper bound of the height H required to pack all the items such that it is proved that the input items can be packed into a rectangle of width W and height H. They then define seven procedures (with seven conditions), each to divide a problem into two smaller ones and solve them recursively. It has been showed that any tractable problem satisfies one of the seven conditions.\nApproximation ratio: M(I) <= 2\xc2\xb7OPT(I).Split-Fit algorithm (SF)\nSF divides items into two groups, L1 with width greater than 1/2 and L2 at most 1/2. All items of L1 are first packed by FFDH. Then they are arranged so that all items with width more than 2/3 are below those with width at most 2/3. This creates a rectangle R of space with width 1/3. Remaining items in L2 are then packed to R and the space above those packed with L1 using FFDH. The levels created in R are considered to be below those created above the packing of L1.\nApproximation ratio: SF(I) <= (3/2) \xc2\xb7OPT(I) + 2; the asymptotic bound of 3/2 is tight.Sleator\'s algorithm\nSleater\'s algorithm consists of four steps:All items of width greater than 1/2 are packed on top of one another in the bottom of the strip. Suppose h0 is the height of the resulting packing All subsequent packing will occur above h0.Remaining items are ordered by non-increasing height. A level of items are packed (in non-increasing height order) from left to right along the line of height h0. A vertical line is then drawn in the middle to cut the strip into two equal halves (note this line may cut an item that is packed partially in the right half). Draw two horizontal line segments of length one half, one across the left half (called the left baseline) and one across the right half (called the right baseline) as low as possible such that the two lines do not cross any item.Choose the left or right baseline which is of a lower height and pack a level of items into the corresponding half of the strip until the next item is too wide.A new baseline is formed and Step (4) is repeated on the lower baseline until all items are packed.\nTime complexity: O(n \xc2\xb7log n).\nThe approximation ratio of Sleator\'s algorithm is 2.5 which is tight.Have a look at packing problems. I think yours falls under \'2D bin packing.\' You should be able to learn a lot from solutions to that and other packing problems.Also see: Packing rectangular image data into a square texture.There is extensive literature on this problem. A good greedy heuristic is to place rectangles from largest area to smallest in the first available position towards the bottom and left of the container. Think of gravity pulling all of the items down to the lower left corner. For a description of this google "Chazelle bottom left packing".For optimal solutions, the state-of-the-art techniques can pack over 20 rectangles in a few seconds. Huang has an algorithm that separates the problem of finding the smallest enclosing bounding box from the problem of deciding whether or not a set of rectangle can fit in a bounding box of a specific size. You give his program a set of rectangles, and it tells you the smallest enclosing bounding box required to pack them.For your case, your outer loop should iterate from the smallest possible bounding box upward (with the width and height successively increasing by powers of two). For each of these bounding boxes, test to see if you can find a packing for your rectangles. You will get a bunch of "no" answers, until the first "yes" answer, which will be guaranteed to be the optimal solution.For the inner loop of your algorithm -- the one that answers "yes" or "no" to a bounding box of specific size, I would look up the Huang reference and just implement his algorithm. He includes a lot of optimizations on top of the basic algorithm, but you only really need the basic meat and potatoes. Since you want to handle rotations, at every branch point during your search, simply try both rotations and backtrack when both rotations do not result in a solution.I\'m fairly certain that this is an NP-hard problem, so, for an optimal solution, you\'d have to implement a backtracking algorithm that tries every possible combination.The good news is that because of the need to pack 2D rectangles in a limited 2D space, you can prune a lot of possibilities early on, so it might not be THAT bad.What you need is at\nhttps://github.com/nothings/stb/blob/master/stb_rect_pack.hsample:A general solution is non-trivial (math speak for completely ****ing impossible)\nGenerally people use a genetic algorithm to try possible combinations but you can do reasonably well by justing putting the largest shape in first and then trying different places for the next largest and so on.