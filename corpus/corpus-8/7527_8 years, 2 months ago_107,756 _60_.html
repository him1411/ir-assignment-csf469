I have four projects in my Visual Studio solution (everyone targeting .NET 3.5) - for my problem only these two are important:I added the elmah.dll reference to MyBaseProject in Visual studio 2008 by clicking "Add reference..." \xe2\x86\x92 "Browse" tab \xe2\x86\x92 selecting the "elmah.dll".The Properties of the Elmah Reference are as follows:In MyWebProject1 I added the reference to Project MyBaseProject by:\n"Add reference..." \xe2\x86\x92 "Projects" tab \xe2\x86\x92 selecting the "MyBaseProject". The Properties of this reference are the same except the following members:If I run the build in Visual Studio the elmah.dll file is copied to my MyWebProject1\'s bin directory, along with MyBaseProject.dll!However if I clean and run MSBuild for the solution (via D:\\webs\\CMS> C:\\WINDOWS\\Microsoft.NET\\Framework\\v3.5\\MSBuild.exe /t:ReBuild /p:Configuration=Debug MyProject.sln)\nthe elmah.dll is missing in MyWebProject1\'s bin directory - although the build itself contains no warning or errors!I already made sure that the .csproj of MyBaseProject contains the private element with the value "true" (that should be an alias for "copy local" in Visual Studio):(The private tag didn\'t appear in the .csproj\'s xml by default, although Visual Studio said "copy local" true. I switched "copy local" to false - saved - and set it back to true again - save!)What is wrong with MSBuild? How do I get the (elmah.dll) reference copied to MyWebProject1\'s bin?I do NOT want to add a postbuild copy action to every project\'s postbuild command! (Imagine I would have many projects depend on MyBaseProject!)I\'m not sure why it is different when building between Visual Studio and MsBuild, but here is what I have found when I\'ve encountered this problem in MsBuild and Visual Studio.For a sample scenario let\'s say we have project X, assembly A, and assembly B.  Assembly A references assembly B, so project X includes a reference to both A and B.  Also, project X includes code that references assembly A (e.g. A.SomeFunction()). Now, you create a new project Y which references project X.So the dependency chain looks like this: Y => X => A => BVisual Studio / MSBuild tries to be smart and only bring references over into project Y that it detects as being required by project X; it does this to avoid reference pollution in project Y. The problem is, since project X doesn\'t actually contain any code that explicitly uses assembly B (e.g. B.SomeFunction()), VS/MSBuild doesn\'t detect that B is required by X, and thus doesn\'t copy it over into project Y\'s bin directory; it only copies the X and A assemblies.You have two options to solve this problem, both of which will result in assembly B being copied to project Y\'s bin directory:Personally I prefer option 2 for a couple reasons.Here is a sample of the "dummy code" that I typically add when I encounter this situation.I just deal with it like this.  Go to the properties of your reference and do this:and that\'s it.Visual Studio 2010 doesn\'t initially put:\n            <private>True</private>     in the reference tag and setting "copy local" to false causes it to create the tag.  Afterwards it will set it to true and false accordingly.If you are not using the assembly directly in code then Visual Studio whilst trying to be helpful detects that it is not used and doesn\'t include it in the output. I\'m not sure why you are seeing different behaviour between Visual Studio and MSBuild. You could try setting the build output to diagnostic for both and compare the results see where it diverges.As for your elmah.dll reference if you are not referencing it directly in code you could add it as an item to your project and set the Build Action to Content and the Copy to Output Directory to Always.Take a look at:This MSBuild forum thread I startedYou will find my temporary solution / workaround there!(MyBaseProject needs some code that is referencing some classes (whatever) from the elmah.dll for elmah.dll being copied to MyWebProject1\'s bin!)I had the same problem.Check if the framework version of your project is the same of the framework version of the dll that you put on reference.In my case, my client was compiled using "Framework 4 Client" and the DLL was in "Framework 4".The issue I was facing was I have a project that is dependent on a library project. In order to build I was following these steps:That of course meant I was missing my library\'s dll files in bin and most importantly in the package zip file. I found this works perfectly:I have no idea why this work or why it didn\'t in the first place. But hope that helps.As Alex Burtsev mentioned in a comment anything that\xe2\x80\x99s only used in a XAML resource dictionary, or in my case, anything that\xe2\x80\x99s only used in XAML and not in code behind, isn\'t deemed to be \'in use\' by MSBuild. So simply new-ing up a dummy reference to a class/component in the assembly in some code behind was enough convince MSBuild that the assembly was actually in use.Changing the target framework from .NET Framework 4 Client Profile to .NET Framework 4 fixed this problem for me.So in your example: set the target framework on MyWebProject1 to .NET Framework 4I just had the exact same problem and it turned out to be caused by the fact that 2 projects in the same solution were referencing a different version of the 3rd party library. Once I corrected all the references everything worked perfectly.I had the same problem and the dll was a dynamically loaded reference.\nTo solve the problem I have added an "using" with the namespace of the dll.\nNow the dll is copied in the output folder.This requires adding a .targets file to your project and setting it to be included in the project\'s includes section.See my answer here for the procedure.Referencing assemblies that are not used during build is not the correct practice. You should augment your build file so it will copy the additional files. Either by using a post build event or by updating the property group. Some examples can be found in other postUsing deadlydog\'s scheme, Y => X => A => B, my problem was when I built Y, the assemblies (A and B, all 15 of them) from X were not showing up in Y\'s bin folder.I got it resolved by removing the reference X from Y, save, build, then re-add X reference (a project reference), and save, build, and A and B started showing up in Y\'s bin folder.Another scenario where this shows up is if you are using the older "Web Site" project type in Visual Studio.  For that project type, it is unable to reference .dlls that are outside of it\'s own directory structure (current folder and down).  So in the answer above, let\'s say your directory structure looks like this:Where ProjectX and ProjectY are parent/child directories, and ProjectX references A.dll which in turn references B.dll, and B.dll is outside the directory structure, such as in a Nuget package on the root (Packages), then A.dll will be included, but B.dll will not.  I just ran into a very similar issue. When compiling using Visual Studio 2010, the DLL file was included in the bin folder. But when compiling using MSBuild the third-party DLL file was not included.Very frustrating. The way I solved it was to include the NuGet reference to the package in my web project even though I\'m not using it directly there.I had a similar issue today, and this is most certainly not the answer to your question. But I\'d like to inform everyone, and possibly provide a spark of insight.I have a ASP.NET application. The build process is set to clean and then build.I have two Jenkins CI scripts. One for production and one for staging. I deployed my application to staging and everything worked fine. Deployed to production and was missing a DLL file that was referenced. This DLL file was just in the root of the project. Not in any NuGet repository. The DLL was set to do not copy.The CI script and the application was the same between the two deployments. Still after the clean and deploy in the staging environment the DLL file was replaced in the deploy location of the ASP.NET application (bin/). This was not the case for the production environment.It turns out in a testing branch I had added a step to the build process to copy over this DLL file to the bin directory. Now the part that took a little while to figure out. The CI process was not cleaning itself. The DLL was left in the working directory and was being accidentally packaged with the ASP.NET .zip file. The production branch never had the DLL file copied in the same way and was never accidentally deploying this.TLDR; Check and make sure you know what your build server is doing.Including all referenced DLL files from your projectreferences in the Website project is not always a good idea, especially when you\'re using dependency injection: your web project just want to add a reference to the interface DLL file/project, not any concrete implementation DLL file. Because if you add a reference directly to an implementation DLL file/project, you can\'t prevent your developer from calling a "new" on concrete classes of the implementation DLL file/project instead of via the interface. It\'s also you\'ve stated a "hardcode" in your website to use the implementation.