I\'m wanting to parse a string into a nullable int in C#.  ie. I want to get back either the int value of the string or null if it can\'t be parsed.I was kind of hoping that this would workBut that won\'t work, so the way I\'m doing it now is I\'ve written this extension methodIs there a better way of doing this?EDIT:  Thanks for the TryParse suggestions, I did know about that, but it worked out about the same.  I\'m more interested in knowing if there is a built-in framework method that will parse directly into a nullable int?int.TryParse is probably a tad easier:Edit @Glenn int.TryParse is "built into the framework". It and int.Parse are the way to parse strings to ints.You can do this in one line, using the conditional operator and the fact that you can cast null to a nullable type (two lines, if you don\'t have a pre-existing int you can reuse for the output of TryParse):Sorry, couldn\'t resist - had this problem and Google brought me here, but I ended up with this (after all, an if and 2 returns is soo long-winded!):On a more serious note, try not to mix int, which is a C# keyword, with Int32, which is a .NET Framework BCL type - although it works, it just makes code look messy.Glenn Slaven: I\'m more interested in knowing if\n  there is a built-in framework method\n  that will parse directly into a\n  nullable int?There is this approach that will parse directly to a nullable int (and not just int) if the value is valid like null or empty string, but does throw an exception for invalid values so you will need to catch the exception and return the default value for those situations:This approach can still be used for non-nullable parses as well as nullable:NB: There is an IsValid method on the converter you can use instead of capturing the exception (thrown exceptions does result in unnecessary overhead if expected). Unfortunately it only works since .NET 4 but there\'s still an issue where it doesn\'t check your locale when validating correct DateTime formats, see bug 93559.Try this:You can forget all other answers - there is a great generic solution:\nhttp://cleansharp.de/wordpress/2011/05/generischer-typeconverter/This allows you to write very clean code like this:and also:Old topic, but how about:I like this better as the requriement where to parse null, the TryParse version would not throw an error on e.g. ToNullableInt32(XXX). That may introduce unwanted silent errors.The following should work for any struct type. It is based off code by Matt Manela from MSDN forums. As Murph points out the exception handling could be expensive compared to using the Types dedicated TryParse method.These were the basic test cases I used.I feel my solution is a very clean and nice solution:This is of course a generic solution which only require that the generics argument has a static method "Parse(string)".  This works for numbers, boolean, DateTime, etc.This solution is generic without reflection overhead.I\'m more interested in knowing if there is a built-in framework method that will parse directly into a nullable int?There isn\'t.I felt I should share mine which is a bit more generic.Usage:Solution:First version is a slower since it requires a try-catch but it looks cleaner. If it won\'t be called many times with invalid strings, it is not that important.\nIf performance is an issue, please note that when using TryParse methods, you need to specify the type parameter of ParseBy as it can not be inferred by the compiler. I also had to define a delegate as out keyword can not be used within Func<>, but at least this time compiler does not require an explicit instance.Finally, you can use it with other structs as well, i.e. decimal, DateTime, Guid, etc. I found and adapted some code for a Generic NullableParser class.  The full code is on my blog Nullable TryParseI\'ve come up with this one, which has satisfied my requirements (I wanted my extension method to emulate as close as possible the return of the framework\'s TryParse, but without try{} catch{} blocks and without the compiler complaining about inferring a nullable type within the framework method)You should never use an exception if you don\'t have to - the overhead is horrible.The variations on TryParse solve the problem - if you want to get creative (to make your code look more elegant) you could probably do something with an extension method in 3.5 but the code would be more or less the same.Using delegates, the following code is able to provide reusability if you find yourself needing the nullable parsing for more than one structure type. I\'ve shown both the .Parse() and .TryParse() versions here.This is an example usage:And here is the code that gets you there...I suggest code bellow. You may work with exception, when convert error occured.Use this extension method in code (fill int? Age property of a person class):ORI realise this is an old topic, but can\'t you simply:?