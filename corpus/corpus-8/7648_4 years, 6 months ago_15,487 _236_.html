I have an n x m matrix consisting of non-negative integers. For example:"Dropping a bomb" decreases by one the number of the target cell and all eight of its neighbours, to a minimum of zero.What is an algorithm that would determine the minimum number of bombs required to reduce all the cells to zero?B Option (Due to me not being a careful reader)Actually the first version of problem is not the one I\'m seeking answer for. I didn\'t carefully read whole task, there\'s additional constraints, let us say:What about simple problem, when sequence in row must be non-increasing:8 7 6 6 5 is possible input sequence7 8 5 5 2 is not possible since 7 -> 8 growing in a sequence.Maybe finding answer for "easier" case would help in finding solution for harder one.PS: I believe that when we have several same situations require minimum bombs to clear upper line, we choose one that use most bombs on "left side" of the row. Still any proof that might be correct?There is a way to reduce this to a simple sub-problem.There are 2 parts to the explanation, the algorithm, and the reason the algorithm \nprovides an optimal solution.  The first won\'t make sense without the second, so I\'ll \nstart with the why.If you think of bombing the rectangle (assume a big rectangle - no edge cases yet) \nyou can see that the only way to reduce the hollow rectangle of squares on the\nperimeter to 0 is to bomb either the perimeter or to bomb the hollow rectangle of \nsquares just inside the perimeter.  I\'ll call the perimeter layer 1, and the rectangle inside it layer 2.An important insight is that there is no point bombing layer 1, because the \n"blast radius" you get from doing so is always contained within the blast radius of \nanother square from layer 2.  You should be able to easily convince yourself of this.So, we can reduce the problem to finding an optimal way to bomb away the perimeter, then we can repeat that until all squares are 0.But of course, that won\'t always find an optimal solution if it\'s possible to bomb \naway the perimeter in a less than optimal fashion, but by using X extra bombs make \nthe problem of reducing the inner layer simpler by >X bombs.  So, if we call \nthe permiter layer one, if we place an extra X bombs somewhere in layer 2 (just \ninside layer 1), can we reduce the effort of later bombing away layer 2 by more than \nX?  In other words, we have to prove we can be greedy in reducing the outer \nperimeter.But, we do know we can be greedy.  Because no bomb in layer 2 can ever be more \nefficient in reducing layer 2 to 0 than a strategically placed bomb in layer 3.  And \nfor the same reason as before - there is always a bomb we can place in layer 3 that \nwill affect every square of layer 2 that a bomb placed in layer 2 can.  So, it can \nnever harm us to be greedy (in this sense of greedy).So, all we have to do is find the optimal way to reduce the permiter to 0 by bombing \nthe next inner layer.  We are never hurt by first bombing the corner to 0, because only the corner of the inner layer can reach it, so we really have no choice (and, any bomb on the perimeter that can reach the corner has a blast radius contained in the blast radius from the corner of the inner layer).Once we have done so, the squares on the perimeter adjacent to the 0 corner can only be reached by 2 squares from the inner layer:At this point the perimeter is effectively a closed 1 dimensional loop, because any bomb will reduce 3 adjacent squares.  Except for some weirdness near the corners - X can "hit" A,B,C,and D.Now we can\'t use any blast radius tricks - the situation of each square is symmetric, except for the weird corners, and even there no blast radius is a subset of another.  Note that if this were a line (as Colonel Panic discusses) instead of a closed loop  the solution is trivial.  The end points must be reduced to 0, and it never harms you to bomb the points adjacent to the end points, again because the blast radius is a superset.  Once you have made your endpoint 0, you still have a new endpoint, so repeat (until the line is all 0).  So, if we can optimally reduce a single square in the layer to 0 we have an algorithm (because we have cut the loop and now have a straight line with endpoints).  I believe bombing adjacent to the square with the lowest value (giving you 2 options) such that the highest value within 2 squares of that lowest value is the minimum possible (you may have to split your bombing to manage this) will be optimal but I don\'t (yet?) have a proof.  P\xc3\xb3lya says "If you can\'t solve a problem, then there is an easier problem you can solve: find it."The obvious simpler problem is the 1-dimensional problem (when the grid is a single row). Let\'s start with the simplest algorithm - greedily bombing the biggest target. When does this go wrong?Given 1 1 1, the greedy algorithm is indifferent to which cell it bombs first. Of course, the centre cell is better - it zeros all three cells at once. This suggests a new algorithm A, "bomb to minimise the sum remaining". When does this algorithm go wrong?Given 1 1 2 1 1, algorithm A is indifferent between bombing the 2nd, 3rd or 4th cells. But bombing the 2nd cell to leave 0 0 1 1 1 is better than bombing the 3rd cell to leave 1 0 1 0 1. How to fix that? The problem with bombing the 3rd cell is that it leaves us work to the left and work to the right which must be done separately.How about "bomb to minimise the sum remaining, but maximise the minimum to the left (of where we bombed) plus the minimum to the right". Call this algorithm B. When does this algorithm go wrong?Edit: After reading the comments, I agree a much more interesting problem would be the one dimensional problem changed so that the ends join up. Would love to see any progress on that.I had to stop at only a partial solution since I was out of time, but hopefully even this partial solution provides some insights on one potential approach to solving this problem.When faced with a hard problem, I like to come up with simpler problems to develop an intuition about the problem space. Here, the first step I took was to reduce this 2-D problem into a 1-D problem. Consider a line:Somehow or another, you know you will need to bomb at or around the 4 spot 4 times to get it down to 0. Since left of the spot is a lower number, there is no benefit to bombing the 0 or the 4 over bombing the 2. In fact, I believe (but lack a rigorous proof) that bombing the 2 until the 4 spot goes down to 0 is at least as good as any other strategy to get that 4 down to 0. One can proceed down the line left to right in a strategy like this:A couple sample bombing orders:The idea of starting with a number that needs to go down some way or another is an appealing one because it suddenly becomes attainable to find a solution that as some claim to being at least as good as all other solutions.The next step up in complexity where this search of at least as good is still feasible is on the edge of the board. It is clear to me that there is never any strict benefit to bomb the outer edge; you\'re better off bombing the spot one in and getting three other spaces for free. Given this, we can say that bombing the ring one inside of the edge is at least as good as bombing the edge. Moreover, we can combine this with the intuition that bombing the right one inside of the edge is actually the only way to get edge spaces down to 0. Even more, it is trivially simple to figure out the optimal strategy (in that it is at least as good as any other strategy) to get corner numbers down to 0. We put this all together and can get much closer to a solution in the 2-D space.Given the observation about corner pieces, we can say for sure that we know the optimal strategy to go from any starting board to a board with zeros on all corners. This is an example of such a board (I borrowed the numbers from the two linear boards above). I\'ve labelled some spaces differently, and I\'ll explain why.One will notice at the top row really closely resembles the linear example we saw earlier. Recalling our earlier observation that the optimal way to get the top row all down to 0 is to bomb the second row (the x row). There is no way to clear the top row by bombing any of the y rows and no additional benefit to bombing the top row over bombing the corresponding space on the x row.We could apply the linear strategy from above (bombing the corresponding spaces on the x row), concerning ourselves only with the top row and nothing else. It would go something like this:The flaw in this approach becomes very obvious in the final two bombings. It is clear, given that the only bomb sites that reduce the 4 figure in the first column in the second row are the first x and the y. The final two bombings are clearly inferior to just bombing the first x, which would have done the exact same (with regard to the first spot in the top row, which we have no other way of clearing). Since we have demonstrated that our current strategy is suboptimal, a modification in strategy is clearly needed.At this point, I can take a step back down in complexity and focus just one one corner. Let\'s consider this one:It is clear the only way to get the spaces with 4 down to zero are to bomb some combination of x, y, and z. With some acrobatics in my mind, I\'m fairly sure the optimal solution is to bomb x three times and then a then b. Now it\'s a matter of figuring out how I reached that solution and if it reveals any intuition we can use to even solve this local problem. I notice that there\'s no bombing of y and z spaces. Attempting to find a corner where bombing those spaces makes sense yields a corner that looks like this:For this one, it is clear to me that the optimal solution is to bomb y 5 times and z 5 times. Let\'s go one step further.Here, it feels similarly intuitive that the optimal solution is to bomb a and b 6 times and then x 4 times.Now it becomes a game of how to turn those intuitions into principles we can build on.Hopefully to be continued!For updated question a simple greedy algorithm gives optimal result.Drop A[0,0] bombs to cell A[1,1], then drop A[1,0] bombs to cell A[2,1], and continue this process downwards. To clean bottom left corner, drop max(A[N-1,0], A[N-2,0], A[N-3,0]) bombs  to the cell A[N-2,1]. This will completely clean up first 3 columns.With the same approach clean columns 3,4,5, then columns 6,7,8, etc.Unfortunately this does not help finding solution for the original problem."Larger" problem (without "nonicreasing" constraint) may be proven to be NP-hard. Here is sketch of a proof.Suppose we have a planar graph of degree up to 3. Let\'s find minimum vertex cover for this graph. According to Wikipedia article this problem is NP-hard for planar graphs of degree up to 3. This could be proven by reduction from Planar 3SAT. And hardness of Planar 3SAT - by reduction from 3SAT. Both these proofs are presented in recent lectures in "Algorithmic Lower Bounds" by prof. Erik Demaine (lectures 7 and 9).If we split some edges of the original graph (left graph on the diagram), each one with even number of additional nodes, the resulting graph (right graph on the diagram) should have exactly the same minimum vertex cover for original vertices. Such transformation allows to align graph vertices to arbitrary positions on the grid.If we place graph vertices only to even rows and columns (in such a way that no two edges incident to one vertex form an acute angle), insert "ones" wherever there is an edge, and insert "zeros" to other grid positions, we could use any solution for the original problem to find minimum vertex cover.You can represent this problem as integer programming problem. (this is just one of possible solutions to approach this problem)Having points:one can write 16 equations where for point f for example holdsminimaised over sum of all indexes and integer solution.Solution is of course sum of this indexes.This can be further simplified by setting all xi on boundaries  0, so you end up having 4+1 equation in this example.Problem is that there is no trivial algorhitm for solving such problems. tI am not expert on this, but solving this problem as linear programming is NP hard.This is a partial answer, I\'m trying to find a lower bound and upper bound that could be the possible number of bombs. In 3x3 and smaller board, the solution is trivially always the largest numbered cell.In boards larger than 4x4, the first obvious lower bound is the sum of the corners:however you arrange the bomb, it is impossible to clear this 4x4 board with less than 2+1+6+4=13 bombs. It has been mentioned in other answers that placing the bomb on the second-to-corner to eliminate the corner is never worse than placing the bomb on the corner itself, so given the board:We can zero the corners out by placing bombs on the second-to-corner to give a new board:So far so good. We need 13 bombs to clear the corners.Now observe the number 6, 4, 3, and 2 marked below:There is no way to bomb any two of those cells using a single bomb, so the minimum bomb has increased by 6+4+3+2, so adding to the number of bombs we used to clear the corners, we get that the minimum number of bombs required for this map has become 28 bombs. It is impossible to clear this map with less than 28 bombs, this is the lower bound for this map.You can use greedy algorithm to establish an upper bound. Other answers have shown that a greedy algorithm produces a solution that uses 28 bombs. Since we\'ve proven earlier that no optimal solution can have less than 28 bombs, therefore 28 bombs is indeed an optimal solution.When greedy and the method to find the minimal bound I\'ve mentioned above does not converge though, I guess you do have to go back to checking all combinations.The algorithm for finding the lower bound is the following:This would be a greedy approach:Calculate a "score" matrix of order n X m, where score[i][j] is the total deduction of points in the matrix if position (i,j) is bombed. (Max score of a point is 9 and min score is 0)Moving row wise, find and pick the first position with highest score (say (i,j)). Bomb (i,j). Increase bomb count.If all elements of the original matrix are not zero, then goto 1.I have my doubts that this is the optimal solution though.Edit:The Greedy approach I posted above, while it works, most probably doesn\'t give us the optimal solution. So I figured should add some elements of DP to it. I think we can agree that at any point of time, one of the positions with the highest "score" (score[i][j] = total deduction of points if (i,j) is bombed) must be targeted. Starting with this assumption, here\'s the new approach:NumOfBombs(M): (returns the minimum number of bombings required)Given a Matrix M of order n X m. If all elements of M are zero, then return 0.Calculate the "score" matrix M. Let the k distinct positions P1,P2,...Pk (1 <= k <= n*m), be the positions in M with the highest scores. return (1 + min( NumOfBombs(M1), NumOfBombs(M2), ..., NumOfBombs(Mk) ) ) where M1,M2,...,Mk are the resulting matrices if we bomb positions P1, P2, ..., Pk respectively.Also, if we want the order of positions to nuke in addition to this, we would have to keep track of the results of "min".Your new problem, with the nondecreasing values across rows, is quite easy to solve.Observe that the left column contains the highest numbers. Therefore, any optimal solution must first reduce this column to zero. Thus, we can perform a 1-D bombing run over this column, reducing every element in it to zero. We let the bombs fall on the second column so they do maximum damage. There are many posts here dealing with the 1D case, I think, so I feel safe in skipping that case. (If you want me to describe it, I can.). Because of the decreasing property, the three leftmost columns will all be reduced to zero. But, we will provably use a minimum number of bombs here because the left column must be zeroed.Now, once the left column is zeroed, we just trim off the three leftmost columns that are now zeroed and repeat with the now-reduced matrix. This must give us an optimal solution since at each stage we use a provably minimum number of bombs.There is no need to transform the problem to linear sub-problems.Instead use a simple greedy heuristic, which is to bomb the corners, starting with the largest one.In the given example there are four corners, { 2, 1, 6, 4 }. For each corner there is no better move than to bomb the cell diagonal to the corner, so we know for a fact our first 2+1+6+4 = 13 bombings must be in these diagonal cells. After doing the bombing we are left with a new matrix:After the first 13 bombings we use the heuristic to eliminate 3 0 2 via three bombings. Now, we have 2 new corners, { 2, 1 } in the 4th row. We bomb those, another 3 bombings. We have reduced the matrix to 4 x 4 now. There is one corner, the upper left. We bomb that. Now we have 2 corners left, { 5, 3 }. Since 5 is the largest corner we bomb that first, 5 bombings, then finally bomb the 3 in the other corner. The total is 13+3+3+1+5+3 = 28.This does a breadth-search for the shortest path (a series of bombings) through this "maze" of positions.  No, I cannot prove that there is no faster algorithm, sorry.It seems that a linear programming approach can be very helpful here. Let Pm x n be the matrix with the values of the positions:Now let define a bomb matrix B(x, y)m x n,with 1 \xe2\x89\xa4 x \xe2\x89\xa4 m, 1 \xe2\x89\xa4 y \xe2\x89\xa4 n as below in such a way thatFor example:So we are looking to a matrix Bm x n = [bij] thatCan be defined as a sum of bomb matrices:(qij would be then the quantity of bombs we would drop in position pij)pij - bij \xe2\x89\xa4 0  (to be more succint, let us say it as P - B \xe2\x89\xa4 0)Also, B should minimize the sum .We can also write B as the ugly matrix ahead:and since P - B \xe2\x89\xa4 0 (which means P \xe2\x89\xa4 B) we have the following pretty linear inequality system below:Being qmn x 1 defined aspmn x 1 defined asWe can say we have a system The system below represented as product of matrices http://latex.codecogs.com/gif.download?S%5Cmathbf%7Bq%7D&space;%5Cge&space;%5Cmathbf%7Bp%7D being Smn x mn the matrix to be reversed to solve the system. I did not expand it myself but I believe it should be easy to do it in code.Now, we have a minimum problem which can be stated asI believe it is something easy, almost trivial to be solved with something like the simplex algorithm (there is this rather cool doc about it). However, I do know almost no linear programming (I will take a course about it on Coursera but it is just in the future...), I had some headaches trying to understand it and I have a huge freelance job to finish so I just give up here. It can be that I did something wrong at some point, or that it can\'t go any further, but I believe this path can eventually lead to the solution. Anyway, I am anxious for your feedback.(Special thanks for this amazing site to create pictures from LaTeX expressions)This greedy solution seems to be correct:As pointed in comments, it\'ll fail in 2D. But maybe you may improve it.For 1D:\n   If there is at least 2 numbers you don\'t need to shoot to the leftmost one because shooting to the second is not worse. So shoot to the second, while first isn\'t 0, because you have to do it. Move to the next cell. Don\'t forget about last cell.C++ code:So for 2D:\n  Again: you don\'t need to shoot in the first row (if there is the second). So shoot to the second one. Solve 1D task for first row. (because you need to make it null). Go down. Don\'t forget last row.To minimize the number of bombs, we have to maximize effect of every bomb. To achive this, on every step we have to select the best target. For each point summing it and it\'s eight neighbours - could be used as an efficiency quantity of bombing this point. This will provide close to optimal sequence of bombs.UPD: We should also take number of zeros into account, becouse bombin them is inefficiently. In fact the problem is to minimize number of hitted zeros. But we can not know how any step gets us closer to this aim. I agree with idea that the problem is NP-complete. I sugest a greedy approach, which will give an answer close to real.I believe that to minimize the amount of bombs you simply need maximize the amount of damage..\nfor that to happen need to check the area that has the strongest force.. so you first analyze the field with a 3x3 kernel and check where the sum is stronger.. and bomb there.. and do until the field is flat.. for this filed the answer is 28Here is a solution that generalizes the good properties of the corners.Let\'s assume that we could find a perfect drop point for a given field, that is, a best way to decrease the value in it. Then to find the minimum number of bombs to be dropped, a first draft of an algorithm could be (the code is copy-pasted from a ruby implementation):The challenge is choose_a_perfect_drop_point. First, let\'s define what a perfect drop point is.If there is a perfect drop point for (x, y), you cannot decrease the value at (x, y) more effectively than to drop a bomb on one of the perfect drop points for (x, y). A perfect drop point for a given field is a perfect drop point for any of its cells.Here are few examples:The perfect drop point for the cell (0, 0) (zero-based index) is (1, 1). All other drop points for (1, 1), that is (0, 0), (0, 1), and (1, 0), decrease less cells.A perfect drop point for the cell (2, 2) (zero-based index) is (2, 2), and also all the surrounding cells (1, 1), (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2), and (3, 3).a perfect drop points for the cell (2, 2) is (3, 1): It decreases the value in (2, 2), and the value in (4, 0). All other drop points for (2, 2) are not maximal, as they decrease one cell less. The perfect drop point for (2, 2) is also the perfect drop point for (4, 0), and it is the only perfect drop point for the field. It leads to the perfect solution for this field (one bomb drop).There is no perfect drop point for (2, 2): Both (1, 1) and (1, 3) decrease (2, 2) and another cell (they are maximal drop points for (2, 2)), but they are not equivalent. However, (1, 1) is a perfect drop point for (0, 0), and (1, 3) is a perfect drop point for (0, 4).With that definition of perfect drop points and a certain order of checks, I get the following result for the example in the question:However, the algorithm only works if there is at least one perfect drop point after each step. It is possible to construct examples where there are no perfect drop points:For these cases, we can modify the algorithm so that instead of a perfect drop point, we choose a coordinate with a minimal choice of maximal drop points, then calculate the minimum for each choice. In the case above, all cells with values have two maximal drop points. For example, (0, 1) has the maximal drop points (1, 1) and (1, 2). Choosing either one and then calcualting the minimum leads to this result:Here\'s another idea:Let\'s start by assigning a weight to each space on the board for how many numbers would be reduced by dropping a bomb there.  So if the space has a non-zero number, it gets a point, and if any space adjacent to it has a non-zero number, it gets an additional point.  So if there is a 1000-by-1000 grid, we have a weight assigned to each of the 1 million spaces.Then sort the list of spaces by weight, and bomb the one with the highest weight.  This is getting the most bang for our buck, so to speak.After that, update the weight of every space whose weight is affected by the bomb.  This will be the space you bombed, and any space immediately adjacent to it, and any space immediately adjacent to those.  In other words, any space which could have had its value reduced to zero by the bombing, or the value of a neighboring space reduced to zero.Then, re-sort the list spaces by weight.  Since only a small subset of spaces had their weight changed by the bombing, you won\'t need to resort the whole list, just move those ones around in the list.Bomb the new highest weight space, and repeat the procedure.This guarantees that every bombing reduces as many spaces as possible (basically, it hits as few spaces which are already zero as possible), so it would be optimal, except that their can be ties in weights.  So you may need to do some back tracking when there is a tie for the top weight.  Only a tie for the top weight matters, though, not other ties, so hopefully it\'s not too much back-tracking.Edit:\nMysticial\'s counterexample below demonstrates that in fact this isn\'t guaranteed to be optimal, regardless of ties in weights.  In some cases reducing the weight as much as possible in a given step actually leaves the remaining bombs too spread out to achieve as high a cummulative reduction after the second step as you could have with a slightly less greedy choice in the first step.  I was somewhat mislead by the notion that the results are insensitive to the order of bombings.  They are insensitive to the order in that you could take any series of bombings and replay them from the start in a different order and end up with the same resulting board.  But it doesn\'t follow from that that you can consider each bombing independently.  Or, at least, each bombing must be considered in a way that takes into account how well it sets up the board for subsequent bombings.As it has already been mentioned, this problem can be solved using integer linear programming (which is NP-Hard). Mathematica already has ILP built in. "To solve an integer linear programming problem Mathematica first solves the equational constraints, reducing the problem to one containing inequality constraints only. Then it uses lattice reduction techniques to put the inequality system in a simpler form. Finally, it solves the simplified optimization problem using a branch-and-bound method." [see Constrained Optimization Tutorial in Mathematica.. ]I\'ve written the following code that utilizes ILP libraries of Mathematica. It is surprisingly fast. For the example provided in the problem:OutputsTry your code on the following 10x10 problem:Here it is comma-seperated: For this problem, my solution contains 208 bombs. Here\'s a possible solution (I was able to solve this in about 12 seconds).As a way to test the results Mathematica is producing, see if your greedy algorithm can do any better.Well, suppose we number the board positions 1, 2, ..., n x m.  Any sequence of bomb drops can be represented by a sequence of numbers in this set, where numbers can repeat.  However, the effect on the board is the same regardless of what order you drop the bombs in, so really any choice of bomb drops can be represented as a list of n x m numbers, where the first number represents the number of bombs dropped on position 1, the second number represents the number of bombs dropped on position 2, etc.  Let\'s call this list of n x m numbers the "key".You could try first calculating all board states resulting from 1 bomb drop, then use these to calculate all board states resulting from 2 bomb drops, etc until you get all zeros.  But at each step you would cache the states using the key I defined above, so you can use these results in calculating the next step (a "dynamic programming" approach).But depending on the size of n, m, and the numbers in the grid, the memory requirements of this approach might be excessive.  You can throw away all the results for N bomb drops once you\'ve calculated all the results for N + 1, so there\'s some savings there.  And of course you could not cache anything at the cost of having it take a lot longer -- the dynamic programming approach trades memory for speed.If you want the absolute optimal solution to clean the board you will have to use classic backtracking, but if the matrix is very big it will take ages to find the best solution, if you want an "possible" optimal solution you can use greedy algorithm, if you need help writing the algorithm i can help youCome to think of it that is the best way. Make another matrix there you store the points you remove by dropping a bomb there then chose the cell with maximum points and drop the bomb there update the points matrix and continue. Example:cell value +1 for every adjacent cell with a value higher than 0Brute Force !I know it is not efficient, but even if you find a faster algorithm, you can always test against this result to know how accurate it is.Use some recursion, like this:You can make this more efficient by caching, if different way lead to same result, you shouldn\'t repeat the same steps.To elaborate:if bombing cell 1,3,5 leads to the same result as bombing cell 5,3,1 , then, you shouldn\'t re-do all the next steps again for both cases, only 1 is enough, you should store somewhere all table states and use its results. A hash of table stats can be used to do fast comparison.Edit: did not notice that Kostek suggested almost same approach, so now I make stronger claim:\nIf corners to clear are chosen to be always on outermost layer, then it is optimal.In OP\'s example: dropping 2 (as 1+1 or 2) on anything else than on 5 does not leads to hitting any square that dropping on 5 would hit. So we simply must drop 2 on 5 (and 6 on lower left 1 ...)After this, there is only one way how to clear (in top left) corner what was originaly 1 (now 0), and that is by dropping 0 on B3 (excel like notation).\nAnd so on.Only after clearing whole A and E columns and 1 and 7 rows, start clearing one layer deeper.Consider cleared only those intentionaly cleared, clearing 0 value corners costs nothing and simplifies thinking about it.Because all bombs dropped this way must be dropped and this leads to cleared fields, it is optimal solution.After good sleep I realized that this is not true.\nConsiderMy approach would drop bombs on B3 and C2, when dropping on B2 would be enoughHere\'s my solution.. I won\'t write it out in code yet since I don\'t have time, but I believe this should produce an optimal number of moves each time - though I\'m not sure how efficient it would be at finding the points to bomb.Firstly, as @Luka Rahne stated in one of the comments, the order in which you bomb is not important- only the combination.Secondly, as many others have stated, bombing 1-off the diagonal from the corners is optimal because it touches more points than the corners.This generates the basis for my version of the algorithm: \nWe can bomb the \'1-off from the corners\' first or last, it doesn\'t matter (in theory)\nWe bomb those first because it makes later decisions easier (in practice)\nWe bomb the point which affects the most points, while simultaneously bombing those corners.Let\'s define Points Of Resistance to be the points in the board with the most non-bombable points + largest number of 0\'s around themnon-bombable points can be defined as points which don\'t exist in our current scope of the board we\'re looking at.I\'ll also define 4 bounds which will handle our scope:\nTop=0, Left=0, Bottom=k,right=j.\n(values to start)Finally, I\'ll define optimal bombs as bombs which are dropped on points that are adjacent to points of resistance and are touching (1) the highest valued point of resistance and (2) the largest number of points possible.Regarding the approach- it\'s obvious we\'re working from the outside in. We will be able to work with 4 \'bombers\' at the same time.The first points of resistance are obviously our corners. The \'out of bound\' points are not bombable (there are 5 points outside the scope for each corner). So we bomb the points diagonally one off the corners first.Algorithm:repeat until TOP=BOTTOM and LEFT=RIGHTI will try to write the actual code laterYou could use state space planning.\nFor example, using A* (or one of its variants) coupled with an heuristic f = g + h like this:I got 28 moves as well. I used two tests for the best next move: first the move producing the minimum sum for the board. Second, for equal sums, the move producing the maximum density, defined as: This is Haskell. "solve board" shows the engine\'s solution. You can play the game by typing "main", then enter a target point, "best" for a recommendation, or "quit" to quit.OUTPUT:\n*Main> solve board\n[(4,4),(3,6),(3,3),(2,2),(2,2),(4,6),(4,6),(2,6),(3,2),(4,2),(2,6),(3,3),(4,3),(2,6),(4,2),(4,6),(4,6),(3,6),(2,6),(2,6),(2,4),(2,4),(2,6),(3,6),(4,2),(4,2),(4,2),(4,2)]There seems to be a nonbipartite matching substructure here.  Consider the following instance:The optimal solution to this case has size 5 since that\'s the size of a minimum cover of the vertices of a 9-cycle by its edges.This case, in particular, shows that the linear programming relaxation a few people have posted isn\'t exact, doesn\'t work, and all those other bad things.  I\'m pretty sure I can reduce "cover the vertices of my planar cubic graph by as few edges as possible" to your problem, which makes me doubt whether any of the greedy/hill-climbing solutions are going to work.I don\'t see a way to solve this in polynomial time in the worst case.  There might be a very clever binary-search-and-DP solution that I\'m not seeing.EDIT:  I see that the contest (http://deadline24.pl) is language-agnostic; they send you a bunch of input files and you send them outputs.  So you don\'t need something that runs in worst-case polynomial time.  In particular, you get to look at the input!There are a bunch of small cases in the input.  Then there\'s a 10x1000 case, a 100x100 case, and a 1000x1000 case.  The three large cases are all very well-behaved.  Horizontally adjacent entries typically have the same value.  On a relatively beefy machine, I\'m able to solve all of the cases by brute-forcing using CPLEX in just a couple of minutes.  I got lucky on the 1000x1000; the LP relaxation happens to have an integral optimal solution.  My solutions agree with the .ans files provided in the test data bundle.I\'d bet you can use the structure of the input in a much more direct way than I did if you took a look at it; seems like you can just pare off the first row, or two, or three repeatedly until you\'ve got nothing left.  (Looks like, in the 1000x1000, all of the rows are nonincreasing?  I guess that\'s where your "part B" comes from?  )I can\'t think of a way to calculate the actual number without just computing the bombing campaign using my best heuristic and hope I get a reasonable result.So my method is to compute a bombing efficiency metric for each cell, bomb the cell with the highest value, .... iterate the process until I\'ve flattened everything. Some have advocated using simple potential damage (i.e. score from 0 to 9) as a metric, but that falls short by pounding high value cells and not making use of damage overlap. I\'d calculate cell value - sum of all neighbouring cells, reset any positive to 0 and use the absolute value of anything negative. Intuitively this metric should make a selection that help maximise damage overlap on cells with high counts instead of pounding those directly.The code below reaches total destruction of the test field in 28 bombs (note that using potential damage as metric yields 31!).The resulting bombing pattern is output as follows (field values on the left, metric on the right)This can be solved using a tree of depth O(3^(n)). Where n is the sum of all of the squares.First consider that it is trivial to solve the problem with a tree of O(9^n), simply consider all of the possible bombing locations.  For an example see Alfe\'s implementation.Next realize that we can work to bomb from the bottom up and still get a minimum bombing pattern.This algorithm is correct because In practice this algorithm will regularly do better than its theoretical maximum because it will regularly bomb out neighbors and reduce the size of the search.  If we assume that each bombing decreases the value of 4 additional targets, then our algorithm will run in O(3^(n/4)) or approximately O(1.3^n).Because this algorithm is still exponential, it would be wise to limit the depth of the search.  We might limit the number of branches allowed to some number, X, and once we are this deep we force the algorithm to choose the best path it has identified so far (the one that has the minimum total board sum in one of its terminal leaves).  Then our algorithm is guaranteed to run in O(3^X) time, but it is not guaranteed to get the correct answer.  However, we can always increase X and test empirically if the trade off between increased computation and better answers is worthwhile.evaluation function, total sum:objective function:destroy function:goal function:linear maximization function:This is not optimal, but can be optimized through finding a better evaluation function .... but thinking about this problem, I was thinking that one of the main issues is getting abandoned figures in the middle of zeroes at some point, so I\'d take another approach .. which is dominate minimal values into zero, then try to escape zeroes as possible, which lead to general minimization of minimal existing value(s) or soAll this problem boils down to is computing an edit distance.  Simply calculate a variant of the Levenshtein distance between the given matrix and the zero matrix, where edits are replaced with bombings, using dynamic programming to store the distances between intermediate arrays.  I suggest using a hash of the matrices as a key.  In pseudo-Python:This was an answer to the first asked question. I hadn\'t noticed that he changed the parameters.Create a list of all targets. Assign a value to the target based on the number of positive values impacted by a drop (itself, and all neighbors). Highest value would be a nine.Sort the targets by the number of targets impacted (Descending), with a secondary descending sort on the sum of each impacted target.Drop a bomb on the highest ranked target, then re-calculate targets and repeat until all target values are zero.Agreed, this is not always the most optimal. For example, This approach would take 5 bombs to clear. Optimally, though, you could do it in 4. Still, pretty \ndarn close and there is no backtracking. For most situations it will be optimal, or very close.Using the original problem numbers, this approach solves in 28 bombs.Adding code to demonstrate this approach (using a form with a button):A class you will need: