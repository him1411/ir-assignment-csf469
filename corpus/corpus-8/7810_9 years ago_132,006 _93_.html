I\'m trying to do something like the following:which the compiler rejects.  I\'ve had a quick look on Google and the consensus seems to be "you can\'t do it", but I can\'t understand why.  Can anyone explain?  Many thanks.Clarification 2: I\'m doing this as I have private methods in a class that take said enum, and I do not want the enum\'s values exposed - so, for example, I do not want anyone to know that E is defined asas project X is not something I want my users to know about.So, I wanted to forward declare the enum so I could put the private methods in the header file, declare the enum internally in the cpp, and distribute the built library file and header to people.As for the compiler - it\'s GCC.The reason the enum can\'t be forward declared is that without knowing the values, the compiler can\'t know the storage required for the enum variable.  C++ Compiler\'s are allowed to specify the actual storage space based on the size necessary to contain all the values specified.  If all that is visible is the forward declaration, the translation unit can\'t know what storage size will have been chosen - it could be a char or an int, or something else.From Section 7.2.5 of the ISO C++ Standard:The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of sizeof() applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of sizeof() applied to the underlying type.Since the caller to the function must know the sizes of the parameters to correctly setup the call stack, the number of enumerations in an enumeration list must be known before the function prototype.Update:\nIn C++0X a syntax for foreward declaring enum types has been proposed and accepted.  You can see the proposal at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf Forward declaration of enums is also possible in C++0x. Previously, the reason enum types could not be forward declared is because the size of the enumeration depends on its contents. As long as the size of the enumeration is specified by the application, it can be forward declared:I\'m adding an up-to-date answer here, given recent developments.You can forward-declare an enum in C++11, so long as you declare its storage type at the same time.  The syntax looks like this:In fact, if the function never refers to the values of the enumeration, you don\'t need the complete declaration at all at that point.This is supported by G++ 4.6 and onwards (-std=c++0x or -std=c++11 in more recent versions).  Visual C++ 2013 supports this; in earlier versions it has some sort of non-standard support that I haven\'t figured out yet - I found some suggestion that a simple forward declaration is legal, but YMMV.Forward declaring things in C++ is very useful because it dramatically speeds up compilation time.  You can forward declare several things in C++ including: struct, class, function, etc...But can you forward declare an enum in C++?No you can\'t.  But why not allow it?  If it were allowed you could define your enum type in your header file, and your enum values in your source file.  Sounds like it should be allowed right?Wrong.In C++ there is no default type for enum like there is in C# (int).  In C++ your enum type will be determined by the compiler to be any type that will fit the range of values you have for your enum. What does that mean? It means that your enum\'s underlying type cannot be fully determined until you have all of the values of the enum defined.  Which mans you cannot separate the declaration and definition of your enum.  And therefore you cannot forward declare an enum in C++.The ISO C++ standard S7.2.5:The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of sizeof() applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of sizeof() applied to the underlying type.You can determine the size of an enumerated type in C++ by using the sizeof operator.  The size of the enumerated type is the size of its underlying type.   In this way you can guess which type your compiler is using for your enum.   What if you specify the type of your enum explicitly like this:Can you then forward declare your enum? No.  But why not?Specifying the type of an enum is not actually part of the current C++ standard.  It is a VC++ extension.   It will be part of C++0x though.Source[My answer is wrong, but I\'ve left it here because the comments are useful].Forward declaring enums is non-standard, because pointers to different enum types are not guaranteed to be the same size. The compiler may need to see the definition to know what size pointers can be used with this type.In practice, at least on all the popular compilers, pointers to enums are a consistent size. Forward declaration of enums is provided as a language extension by Visual C++, for example.There is indeed no such thing as a forward declaration of enum. As an enum\'s definition doesn\'t contain any code that could depend on other code using the enum, it\'s usually not a problem to define the enum completely when you\'re first declaring it.If the only use of your enum is by private member functions, you can implement encapsulation by having the enum itself as a private member of that class. The enum still has to be fully defined at the point of declaration, that is, within the class definition. However, this is not a bigger problem as declaring private member functions there, and is not a worse exposal of implementation internals than that.If you need a deeper degree of concealment for your implementation details, you can break it into an abstract interface, only consisting of pure virtual functions, and a concrete, completely concealed, class implementing (inheriting) the interface. Creation of class instances can be handled by a factory or a static member function of the interface. That way, even the real class name, let alone its private functions, won\'t be exposed.I\'d do it this way:[in the public header][in the internal header]By adding FORCE_32BIT we ensure that Econtent compiles to a long, so it\'s interchangeable with E.Just noting that the reason actually is that the size of the enum is not yet known after forward declaration. Well, you use forward declaration of a struct to be able to pass a pointer around or refer to an object from a place that\'s refered to in the forward declared struct definition itself too. Forward declaring an enum would not be too useful, because one would wish to be able to pass around the enum by-value. You couldn\'t even have a pointer to it, because i recently got told some platforms use pointers of different size for char than for int or long. So it all depends on the content of the enum. The current C++ Standard explicitly disallows doing something like (in 7.1.5.3/1). But the next C++ Standard due to next year allows the following, which convinced me the problem actually has to do with the underlying type:It\'s known as a "opaque" enum declaration. You can even use X by value in the following code. And its enumerators can later be defined in a later redeclaration of the enumeration. See 7.2 in the current working draft. Seems it can not be forward-declared in GCC!Interesting discussion hereIf you really don\'t want your enum to appear in your header file AND ensure that it is only used by private methods, then one solution can be to go with the pimpl principle.It\'s a technique that ensure to hide the class internals in the headers by just declaring:Then in your implementation file (cpp), you declare a class that will be the representation of the internals.You must dynamically create the implementation in the class constructor and delete it in the destructor and when implementing public method, you must use:There are pros for using pimpl, one is that it decouple your class header from its implementation, no need to recompile other classes when changing one class implementation. Another is that is speeds up your compilation time because your headers are so simple.But it\'s a pain to use, so you should really ask yourself if just declaring your enum as private in the header is that much a trouble.You can wrap the enum in a struct, adding in some constructors and type conversions, and forward declare the struct instead.This appears to work:\nhttp://ideone.com/TYtP2My solution to your problem would be to either:1 - use int instead of enums: Declare your ints in an anonymous namespace in your CPP file (not in the header):As your methods are private, no one will mess with the data. You could even go further to test if someone sends you an invalid data:2 : create a full class with limited const instantiations, like done in Java. Forward declare the class, and then define it in the CPP file, and instanciate only the enum-like values. I did something like that in C++, and the result was not as satisfying as desired, as it needed some code to simulate an enum (copy construction, operator =, etc.).3 : As proposed before, use the privately declared enum. Despite the fact an user will see its full definition, it won\'t be able to use it, nor use the private methods. So you\'ll usually be able to modify the enum and the content of the existing methods without needing recompiling of code using your class.My guess would be either the solution 3 or 1.There\'s some dissent since this got bumped (sort of), so here\'s some relevant bits from the standard.  Research shows that the standard doesn\'t really define forward declaration, nor does it explicitly state that enums can or can\'t be forward declared.First, from dcl.enum, section 7.2:The underlying type of an enumeration\n  is an integral type that can represent\n  all the enumerator values defined in\n  the enumeration. It is\n  implementation-defined which integral\n  type is used as the underlying type\n  for an enumeration except that the\n  underlying type shall not be larger\n  than int unless the value of an\n  enumerator cannot fit in an int or\n  unsigned int. If the enumerator-list\n  is empty, the underlying type is as if\n  the enumeration had a single\n  enumerator with value 0. The value of\n  sizeof() applied to an enumeration\n  type, an object of enumeration type,\n  or an enumerator, is the value of\n  sizeof() applied to the underlying\n  type.So the underlying type of an enum is implementation-defined, with one minor restriction.Next we flip to the section on "incomplete types" (3.9), which is about as close as we come to any standard on forward declarations:A class that has been declared but not defined, or an array of unknown size or of \n  incomplete element type, is an incompletely-defined object type.A class type (such as "class X") might be incomplete at one point in a translation \n  unit and complete later on; the type "class X" is the same type at both points. The \n  declared type of an array object might be an array of incomplete class type and \n  therefore incomplete; if the class type is completed later on in the translation unit, \n  the array type becomes complete; the array type at those two points is the same type. \n  The declared type of an array object might be an array of unknown size and therefore be \n  incomplete at one point in a translation unit and complete later on; the array types at \n  those two points ("array of unknown bound of T" and "array of N T") are different \n  types. The type of a pointer to array of unknown size, or of a type defined by a typedef \n  declaration to be an array of unknown size, cannot be completed. So there, the standard pretty much laid out the types that can be forward declared.  Enum wasn\'t there, so compiler authors generally regard forward declaring as disallowed by the standard due to the variable size of its underlying type.It makes sense, too.  Enums are usually referenced in by-value situations, and the compiler would indeed need to know the storage size in those situations.  Since the storage size is implementation defined, many compilers may just choose to use 32 bit values for the underlying type of every enum, at which point it becomes possible to forward declare them.  An interesting experiment might be to try forward declaring an enum in visual studio, then forcing it to use an underlying type greater than sizeof(int) as explained above to see what happens.For VC, here\'s the test about forward declaration and specifying underlying type:But got the warning for /W4(/W3 not incur this warning)warning C4480: nonstandard extension used: specifying underlying type for enum \'T\'VC(Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.30729.01 for 80x86)\nlooks buggy in the above case:The above assembly code is extracted from /Fatest.asm directly, not my personal guess.\nDo you see the \nmov DWORD PTR[eax], 305419896       ; 12345678H\nline?the following code snippet proves it:the result is:\n0x78, 0x56, 0x34, 0x12the above key instruction becomes:mov BYTE PTR [eax], 120         ; 00000078Hthe final result is:\n0x78, 0x1, 0x1, 0x1Note the value is not being overwrittenSo using of the forward-declaration of enum in VC is considered harmful.BTW, to not surprise, the syntax for declaration of the underlying type is same as its in C#. In pratice I found it\'s worth to save 3 bytes by specifying the underlying type as char when talk to the embedded system, which is memory limited.In my projects, I adopted the Namespace-Bound Enumeration technique to deal with enums from legacy and 3rd-party components. Here is an example:Note that the foo.h header does not have to know anything about legacy::evil. Only the files that use the legacy type legacy::evil (here: main.cc) need to include enum.h.Because the enum can be an integral size of varying size (the compiler decides which size a given enum has), the pointer to the enum can also have varying size, since it\'s an integral type (chars have pointers of a different size on some platforms for instance).So the compiler can\'t even let you forward-declare the enum and user a pointer to it, because even there, it needs the size of the enum.In answer to the clarification: If you use the enum internally only, why not declare it inside the class as private?You define an enumeration to restrict the possible values of elements of the type to a limited set.  This restriction is to be enforced at compile time.When forward declaring the fact that you will use a \'limited set\' later on doesn\'t add any value: subsequent code needs to know the possible values in order to benefit from it.Although the compiler is concerned about the size of the enumerated type, the intent of the enumeration gets lost when you forward declare it.