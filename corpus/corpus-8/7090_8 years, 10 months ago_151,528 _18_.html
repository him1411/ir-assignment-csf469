I\'m having some trouble navigating Java\'s rule for inferring generic type parameters. Consider the following class, which has an optional list parameter: My Java compiler gives the following error:But Collections.emptyList() returns type <T> List<T>, not List<Object>. Adding a cast doesn\'t helpyieldsUsing EMPTY_LIST instead of emptyList() yields Whereas the following change makes the error go away:Can anyone explain what type-checking rule I\'m running up against here, and the best way to work around it? In this example, the final code example is satisfactory, but with larger classes, I\'d like to be able to write methods following this "optional parameter" pattern without duplicating code.For extra credit: when is it appropriate to use EMPTY_LIST as opposed to emptyList()?The issue you\'re encountering is that even though the method emptyList() returns List<T>, you haven\'t provided it with the type, so it defaults to returning List<Object>.  You can supply the type parameter, and have your code behave as expected, like this:Now when you\'re doing straight assignment, the compiler can figure out the generic type parameters for you.  It\'s called type inference.  For example, if you did this:then the emptyList() call would correctly return a List<String>.You want to use:If you look at the source for what emptyList does you see that it actually just does a the emptyList method has this signature:That <T> before the word List means that it infers the value of the generic parameter T from the type of variable the result is assigned to. So in this case:The return value is then referenced explicitly by a variable of type List<String>, so the compiler can figure it out. In this case:There\'s no explicit return variable for the compiler to use to figure out the generic type, so it defaults to Object.