I\'ve come across the term \'Functor\' a few times while reading various articles on functional programming, but the authors typically assume the reader already understands the term. Looking around on the web has provided either excessively technical descriptions (see the Wikipedia article) or incredibly vague descriptions (see the section on Functors at this ocaml-tutorial website).Can someone kindly define the term, explain its use, and perhaps provide an example of how Functors are created and used?Edit: While I am interested in the theory behind the term, I am less interested in the theory than I am in the implementation and practical use of the concept.Edit 2: Looks like there is some cross-terminoligy going on: I\'m specifically referring to the Functors of functional programming, not the function objects of C++.The word "functor" comes from category theory, which is a very general, very abstract branch of mathematics.  It has been borrowed by designers of functional languages in at least two different ways.In the ML family of languages, a functor is a module that takes one or more other modules as a parameter.  It\'s considered an advanced feature, and most beginning programmers have difficulty with it.As an example of implementation and practical use, you could define your favorite form of balanced binary search tree once and for all as a functor, and it would take as a parameter a module that provides:The type of key to be used in the binary treeA total-ordering function on keysOnce you\'ve done this, you can use the same balanced binary tree implementation forever.  (The type of value stored in the tree is usually left polymorphicâ€”the tree doesn\'t need to look at values other than to copy them around, whereas the tree definitely needs to be able to compare keys, and it gets the comparison function from the functor\'s parameter.)Another application of ML functors is layered network protocols.  The link is to a really terrific paper by the CMU Fox group; it shows how to use functors to build more complex protocol layers (like TCP) on type of simpler layers (like IP or even directly over Ethernet).  Each layer is implemented as a functor that takes as a parameter the layer below it.  The structure of the software actually reflects the way people think about the problem, as opposed to the layers existing only in the mind of the programmer.  In 1994 when this work was published, it was a big deal.For a wild example of ML functors in action, you could see the paper ML Module Mania, which contains a publishable (i.e., scary) example of functors at work.  For a brilliant, clear, pellucid explanation of the ML modules system (with comparisons to other kinds of modules), read the first few pages of Xavier Leroy\'s brilliant 1994 POPL paper Manifest Types, Modules, and Separate Compilation.In Haskell, and in some related pure functional language, Functor is a type class.  A type belongs to a type class (or more technically, the type "is an instance of" the type class) when the type provides certain operations with certain expected behavior.  A type T can belong to class Functor if it has certain collection-like behavior:The type T is parameterized over another type, which you should think of as the element type of the collection.  The type of the full collection is then something like T Int, T String, T Bool, if you are containing integers, strings, or Booleans respectively.  If the element type is unknown, it is written as a type parameter a, as in T a.Examples include lists (zero or more elements of type a), the Maybe type (zero or one elements of type a), sets of elements of type a, arrays of elements of type a, all kinds of search trees containing values of type a, and lots of others you can think of.The other property that T has to satisfy is that if you have a function of type a -> b (a function on elements), then you have to be able to take that function and product a related function on collections.  You do this with the operator fmap, which is shared by every type in the Functor type class.   The operator is actually overloaded, so if you have a function even with type Int -> Bool, thenis an overloaded function that can do many wonderful things:Convert a list of integers to a list of BooleansConvert a tree of integers to a tree of BooleansConvert Nothing to Nothing and Just 7 to Just FalseIn Haskell, this property is expressed by giving the type of fmap:where we now have a small t, which means "any type in the Functor class."To make a long story short, in Haskell a functor is a kind of collection for which if you are given a function on elements, fmap will give you back a function on collections.  As you can imagine, this is an idea that can be widely reused, which is why it is blessed as part of Haskell\'s standard library.As usual, people continue to invent new, useful abstractions, and you may want to look into applicative functors, for which the best reference may be a paper called Applicative Programming with Effects by Conor McBride and Ross Paterson.Other answers here are complete, but I\'ll try another explanation of the FP use of functor. Take this as analogy: A functor is a container of type a that, when subjected to a function that maps from a\xe2\x86\x92b, yields a container of type b.Unlike the abstracted-function-pointer use in C++, here the functor is not the function; rather, it\'s something that behaves consistently when subjected to a function.There are three different meanings, not much related!In Ocaml it is a parametrized module. See manual. I think the best way to grok them is by example: (written quickly, might be buggy)You can now add quickly many possible orders, ways to form new orders, do a binary or linear search easily over them. Generic programming FTW.In functional programming languages like Haskell, it means some type constructors (parametrized types like lists, sets) that can be "mapped". To be precise, a functor f is equipped with (a -> b) -> (f a -> f b). This has origins in category theory. The Wikipedia article you linked to is this usage.So, this is a special kind of a type constructors, and has little to do with functors in Ocaml!In OCaml, it\'s a parameterised module.If you know C++, think of an OCaml functor as a template. C++ only has class templates, and functors work at the module scale.An example of functor is Map.Make; module StringMap = Map.Make (String);; builds a map module that works with String-keyed maps.You couldn\'t achieve something like StringMap with just polymorphism; you need to make some assumptions on the keys. The String module contains the operations (comparison, etc) on a totally ordered string type, and the functor will link against the operations the String module contains. You could do something similar with object-oriented programming, but you\'d have method indirection overhead.You got quite a few good answers.  I\'ll pitch in:A functor, in the mathematical sense, is a special kind of function on an algebra.  It is a minimal function which maps an algebra to another algebra.  "Minimality" is expressed by the functor laws.There are two ways to look at this.  For example, lists are functors over some type.  That is, given an algebra over a type \'a\', you can generate a compatible algebra of lists containing things of type \'a\'.  (For example: the map that takes an element to a singleton list containing it:  f(a) = [a]) Again, the notion of compatibility is expressed by the functor laws.  On the other hand, given a functor f "over" a type a, (that is, f a is the result of applying the functor f to the algebra of type a), and function from g: a -> b, we can compute a new functor F = (fmap g) which maps f a to f b.  In short, fmap is the part of F that maps "functor parts" to "functor parts", and g is the part of the function that maps "algebra parts" to "algebra parts".  It takes a function, a functor, and once complete, it IS a functor too.It might seem that different languages are using different notions of functors, but they\'re not.  They\'re merely using functors over different algebras.  OCamls has an algebra of modules, and functors over that algebra let you attach new declarations to a module in a "compatible" way.A Haskell functor is NOT a type class.  It is a data type with a free variable which satisfies the type class.  If you\'re willing to dig into the guts of a datatype (with no free variables), you can reinterpret a data type as a functor over an underlying algebra.  For example:data F = F Intis isomorphic to the class of Ints.  So F, as a value constructor, is a function that maps Int to F Int, an equivalent algebra.  It is a functor. On the other hand, you don\'t get fmap for free here.  That\'s what pattern matching is for.Functors are good for "attaching" things to elements of algebras, in an algebraically compatible way.There is a pretty good example in the O\'Reilly OCaml book that\'s on Inria\'s website (which as of writing this is unfortunately down).  I found a very similar example in this book used by caltech: Introduction to OCaml (pdf link).  The relevant section is the chapter on functors (Page 139 in the book, page 149 in the PDF).In the book they have a functor called MakeSet which creates a data structure that consists of a list, and functions to add an element, determine if an element is in the list, and to find the element.  The comparison function that is used to determine if it\'s in/not in the set has been parametrized (which is what makes MakeSet a functor instead of a module).They also have a module that implements the comparison function so that it does a case insensitive string compare.Using the functor and the module that implements the comparison they can create a new module in one line:that creates a module for a set data structure that uses case insensitive comparisons.  If you wanted to create a set that used case sensitive comparisons then you would just need to implement a new comparison module instead of a new data structure module.Tobu compared functors to templates in C++ which I think is quite apt.The best answer to that question is found in "Typeclassopedia" by Brent Yorgey.This issue of Monad Reader contain a precise definition of what a functor is as well as many definition of other concepts as well as a diagram. (Monoid, Applicative, Monad and other concept are explained and seen in relation to a functor).http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdfexcerpt from Typeclassopedia for Functor:\n"A simple intuition is that a Functor represents a \xe2\x80\x9ccontainer\xe2\x80\x9d of some \nsort, along with the ability to apply a function uniformly to every element in the \ncontainer"But really the whole typeclassopedia is a highly recommended reading that is surprisingly easy. In a way you can see the typeclass presented there as a parallel to design pattern in object in the sense that they give you a vocabulary for given behavior or capability.CheersHere\'s an article on functors from a programming POV, followed up by more specifically how they surface in programming languages.The practical use of a functor is in a monad, and you can find many tutorials on monads if you look for that.Given the other answers and what I\'m going to post now, I\'d say that it\'s a rather heavily overloaded word, but anyway...For a hint regarding the meaning of the word \'functor\' in Haskell, ask GHCi:So, basically, a functor in Haskell is something that can be mapped over. Another way to say it is that a functor is something which can be regarded as a container which can be asked to use a given function to transform the value it contains; thus, for lists, fmap coincides with map, for Maybe, fmap f (Just x) = Just (f x), fmap f Nothing = Nothing etc.The Functor typeclass subsection and the section on Functors, Applicative Functors and Monoids of Learn You a Haskell for Great Good give some examples of where this particular concept is useful. (A summary: lots of places! :-))Note that any monad can be treated as a functor, and in fact, as Craig Stuntz points out, the most often used functors tend to be monads... OTOH, it is convenient at times to make a type an instance of the Functor typeclass without going to the trouble of making it a Monad. (E.g. in the case of ZipList from Control.Applicative, mentioned on one of the aforementioned pages.)In a comment to the top-voted answer, user Wei Hu asks:I understand both ML-functors and Haskell-functors, but lack the\n  insight to relate them together. What\'s the relationship between these\n  two, in a category-theoretical sense?Note: I don\'t know ML, so please forgive and correct any related mistakes.Let\'s initially assume that we are all familiar with the definitions of \'category\' and \'functor\'.A compact answer would be that "Haskell-functors" are (endo-)functors F : Hask -> Hask while "ML-functors" are functors G : ML -> ML\'.Here, Hask is the category formed by Haskell types and functions between them, and similarly ML and ML\' are categories defined by ML structures.Note: There are some technical issues with making Hask a category, but there are ways around them.From a category theoretic perspective, this means that a Hask-functor is a map F of Haskell types:along with a map fmap of Haskell functions: ML is pretty much the same, though there is no canonical fmap abstraction I am aware of, so let\'s define one:That is f maps ML-types and fmap maps ML-functions, sois a functor F: StructA -> StructB."Functor is mapping of objects and morphisms that preserves composition and identity of a category."Lets define what is a category ?It\'s a bunch of objects!Draw a few dots (for now 2 dots, one is \'a\' another is \'b\') inside a\n  circle and name that circle A(Category) for now.What does the category holds ?Composition between objects and Identity function for every object.So, we have to map the objects and preserve the composition after applying our Functor.Lets imagine \'A\' is our category which has objects [\'a\', \'b\'] and there exists a morphism a -> bNow, we have to define a functor which can map these objects and morphisms into another category \'B\'.Lets say the functor is called \'Maybe\'So, The category \'B\' looks like this. Please draw another circle but this time with \'Maybe a\' and \'Maybe b\' instead of \'a\' and \'b\'.Everything seems good and all the objects are mapped \'a\' became \'Maybe a\' and \'b\' became \'Maybe b\'. But the problem is we have to map the morphism from \'a\' to \'b\' as well.That means morphism a -> b in \'A\' should map to morphism \'Maybe a\' -> \'Maybe b\'morphism from a -> b is called f, then morphism from \'Maybe a\' -> \'Maybe b\' is called \'fmap f\'Now lets see what function \'f\' was doing in \'A\' and see if we can replicate it in \'B\'function definition of \'f\' in \'A\':f takes a and returns bfunction definition of \'f\' in \'B\' :f takes Maybe a and return Maybe blets see how to use fmap to map the function \'f\' from \'A\' to function \'fmap f\' in \'B\'definition of fmapSo, what are we doing here ?We are applying the function \'f\' to \'x\' which is of type \'a\'. Special pattern matching of \'Nothing\' comes from the definition of Functor Maybe.So, we mapped our objects [a, b] and morphisms [ f ] from category \'A\' to category \'B\'.Thats Functor!Not to contradict the previous theoretical or mathematical answers, but a Functor is also an Object (in an Object-Oriented programming language) that has only one method and is effectively used as a function.An example is the Runnable interface in Java, which has only one method: run.Consider this example, first in Javascript, which has first-class functions:Output:\n[1, 4, 25, 100]The map method takes a function and returns a new array with each element being the result of the application of that function to the value at the same position in the original array.To do the same thing is Java, using a Functor, you would first need to define an interface, say:Then, if you add a collection class which had a map function, you could do:This uses an in-line subclass of IntMapFunction to create a Functor, which is the OO equivalent of the function from the earlier JavaScript example.Using Functors let you apply functional techniques in an OO language.  Of course, some OO languages also have support for functions directly, so this isn\'t required.Reference: http://en.wikipedia.org/wiki/Function_objectArrays in JavaScript implement map and are therefore functors. Promises, Streams and Trees often implement map in functional languages, and when they do, they are considered functors. The map method of the functor takes it\xe2\x80\x99s own contents and transforms each of them using the transformation callback passed to map, and returns a new functor, which contains the structure as the first functor, but with the transformed values.src: https://www.youtube.com/watch?v=DisD9ftUyCk&feature=youtu.be&t=76In functional programming, a functor is essentially a construction of lifting ordinary unary functions (i.e. those with one argument) to functions between variables of new types. It is much easier to write and maintain simple functions between plain objects and use functors to lift them, then to manually write functions between complicated container objects. Further advantage is to write plain functions only once and then re-use them via different functors.Examples of functors include arrays, "maybe" and "either" functors, futures (see e.g. https://github.com/Avaq/Fluture), and many others.Consider the function constructing the full person\'s name from the first and last names. We could define it like fullName(firstName, lastName) as function of two arguments, which however would not be suitable for functors that only deal with functions of one arguments. To remedy, we collect all the arguments in a single object name, which now becomes the function\'s single argument:Now what if we have many people in an array? Instead of manually go over the list, we can simply re-use our function fullName via the map method provided for arrays with short single line of code:and use it likeThat will work, whenever every entry in our nameList is an object providing both firstName and lastName properties. But what if some objects don\'t (or even aren\'t objects at all)? To avoid the errors and make the code safer, we can wrap our objects into the Maybe type (se e.g. https://sanctuary.js.org/#maybe-type):where Just(name) is a container carrying only valid names and Nothing() is the special value used for everything else. Now instead of interrupting (or forgetting) to check the validity of our arguments, we can simply reuse (lift) our original fullName function with another single line of code, based again on the map method, this time provided for the Maybe type:and use it likeA Functor in Category Theory is a map between two categories respecting composition of their morphisms. In a Computer Language, the main Category of interest is the one whose objects are types (certain sets of values), and whose morphisms are functions f:a->b from one type a to another type b. For example, take a to be the String type, b the Number type, and f is the function mapping a string into its length:Here a = String represents the set of all strings and b = Number the set of all numbers. In that sense, both a and b represent objects in the Set Category (which is closely related to the category of types, with the difference being inessential here). In the Set Category, morphisms between two sets are precisely all functions from the first set into the second. So our length function f here is a morphism from the set of strings into the set of numbers.As we only consider the set category, the relevant Functors from it into itself are maps sending objects to objects and morphisms to morphisms, that satisfy certain algebraic laws. Array can mean many things, but only one thing is a Functor -- the type construct, mapping a type a into the type [a] of all arrays of type a. For instance, the Array functor maps the type String  into the type [String] (the set of all arrays of strings of arbitrary length), and set type Number into the corresponding type [Number] (the set of all arrays of numbers).It is important not to confuse the Functor map with a morphism a -> [a]. The functor simply maps (associates) the type a into the type [a] as one thing to another. That each type is actually a set of elements, is of no relevance here. In contrast, a morphism is an actual function between those sets. For instance, there is a natural morphism (function)which sends a value into the 1-element array with that value as single entry. That function is not a part of the Array Functor! From the point of view of this functor, pure is just a function like any other, nothing special.On the other hand, the Array Functor has its second part -- the morphism part. Which maps a morphism f :: a -> b into a morphism [f] :: [a] -> [b]:Here arr is any array of arbitrary length with values of type a, and arr.map(f) is the array of the same length with values of type b, whose entries are results of applying f to the entries of arr. To make it a functor, the mathematical laws of mapping identity to identity and compositions to compositions must hold, which are easy to check in this Array example. In practice, functor means an object that implements the call operator in C++. In ocaml I think functor refers to something that takes a module as input and output another module.Put simply, a functor, or function object, is a class object that can be called just like a function.In C++:This is how you write a functionThis is how you write a functorNow you can do this:What makes these so great is that you can keep state in the class - imagine if you wanted to ask a function how many times it has been called. There\'s no way to do this in a neat, encapsulated way. With a function object, it\'s just like any other class: you\'d have some instance variable that you increment in operator () and some method to inspect that variable, and everything\'s neat as you please.Functor is not specifically related to functional programming. It\'s just a "pointer" to a function or some kind of object, that can be called as it would be a function.