How can I navigate through all my text fields with the "Next" Button on the iPhone Keyboard?The last text field should close the Keyboard.I\'ve setup the IB the Buttons (Next / Done) but now I\'m stuck.I implemented the textFieldShouldReturn action but now the Next and Done Buttons close the Keyboard.In Cocoa for Mac OS X, you have the next responder chain, where you can ask the text field what control should have focus next. This is what makes tabbing between text fields work. But since iOS devices do not have a keyboard, only touch, this concept has not survived the transition to Cocoa Touch.This can be easily done anyway, with two assumptions:Assuming this you can override textFieldShouldReturn: as this:Add some more code, and the assumptions can be ignored as well.UPDATE:- SWIFT 2.0If the superview of the text field will be a UITableViewCell then next responder will beThere is a much more elegant solution which blew me away the first time I saw it. Benefits:Create a UITextField subclass which has an IBOutlet property called nextField. Here\'s the header:And here\'s the implementation:In your view controller, you\'ll create the -textFieldShouldReturn: delegate method:In IB, change your UITextFields to use the SOTextField class. Next, also in IB, set the delegate for each of the \'SOTextFields\'to \'File\'s Owner\' (which is right where you put the code for the delegate method - textFieldShouldReturn). The beauty of this design is that now you can simply right-click on any textField and assign the nextField outlet to the next SOTextField object you want to be the next responder. Moreover, you can do cool things like loop the textFields so that after the last one loses focus, the first one will receive focus again.This can easily be extended to automatically assign the returnKeyType of the SOTextField to a UIReturnKeyNext if there is a nextField assigned -- one less thing manually configure.Here is my solution for this problem.To solve this (and because I hate relying on tags to do stuff) I decided to add a custom property to the UITextField object. In other words I created a category on UITextField like this :UITextField+Extended.hUITextField+Extended.mNow, here is how I use it :And implement the textFieldShouldReturn method :I now have kind of a linked list of UITextField, each one knowing who\'s next in the line.Hope it\'ll help.Here\'s one without delegation:Works using the (mostly unknown) UIControlEventEditingDidEndOnExit UITextField action.You can also easily hook this up in the storyboard, so no delegation or code is required.Edit: actually I cannot figure out how to hook this up in storyboard. becomeFirstResponder does not seem to be a offered action for this control-event, which is a pity. Still, you can hook all your textfields up to a single action in your ViewController which then determines which textField to becomeFirstResponder based on the sender (though then it is not as elegant as the above programmatic solution so IMO do it with the above code in viewDidLoad).A swift extension that applies mxcl\'s answer to make this particularly easy (adapted to swift 2.3 by Traveler):It\'s easy to use:The extension will set the return button to "Next" for all but the last field and to "Done" for the last field, and shift focus / dismiss the keyboard when these are tapped.Swift < 2.3SWIFT 3:\nuse like this - A more consistent and robust way is to use NextResponderTextField\nYou can configure it totally from interface builder with no need for setting the delegate or using view.tag.All you need to do is Here is the library in action:I like the OO solutions that have already been suggested by Anth0 and Answerbot. However, I was working on a quick and small POC, so I didn\'t want to clutter things with subclasses and categories.Another simple solution is to create an NSArray of fields and lookup the next field when you press next. Not an OO solution, but quick, simple, and easy to implement. Also, you can see and modify the ordering at a glance. Here\'s my code (built upon other answers in this thread):Here is an implementation of tabbing using a category on UIControl. This solution has all of the advantages of the methods from Michael and Anth0, but works for all UIControls, not just UITextFields. It also works seamlessly with Interface Builder and storyboards.Source and sample app: GitHub repository for UIControlsWithTabbingUsage:Header:Implementation:After you exit from one text field, you call [otherTextField becomeFirstResponder] and the next field gets focus.This can actually be a tricky problem to deal with since often you\'ll also want to scroll the screen or otherwise adjust the position of the text field so it\'s easy to see when editing.  Just make sure to do a lot of testing with coming into and out of the text fields in different ways and also leaving early (always give the user an option to dismiss the keyboard instead of going to the next field, usually with "Done" in the nav bar) A very easy method for dismissing the keyboard when the \'Done\' button is pressed is:Create a new IBAction in the headerIn the implementation file (.m file) add the following method:Then, when you come to link the IBAction to the textfield - link to the \'Did End On Exit\' event.First set keyboard return key in xib, otherwise you can write code in viewdidload:I am surprised by how many answers here fail to understand one simple concept: navigating through controls in your app is not something the views themselves should do. It\'s the controller\'s job to decide which control to make the next first responder.Also most answers only applied to navigating forward, but users may also want to go backwards.So here\'s what I\'ve come up with. Your form should be managed by a view controller, and view controllers are part of the responder chain. So you\'re perfectly free to implement the following methods:Additional logic for scrolling offscreen responders visible beforehand may apply.Another advantage of this approach is that you don\'t need to subclass all kinds of controls you may want to display (like UITextFields) but can instead manage the logic at controller level, where, let\'s be honest, is the right place to do so.I have tried many codes and finally, this worked for me in Swift 3.0 Latest [March 2017]The ViewController class should be inherited the UITextFieldDelegate for making this code working.Add the Text field with the Proper Tag number and this tag number is used to take the control to appropriate text field based on incremental tag number assigned to it.In the above code, the returnKeyType = UIReturnKeyType.next where will make the Key pad return key to display as Next you also have other options as Join/Go etc, based on your application change the values.This  textFieldShouldReturn is a method of  UITextFieldDelegate controlled and here we have next field selection based on the Tag value incrementationI have added to PeyloW\'s answer in case you\'re looking to implement a previous/next button functionality:Where you subclass the UIView like this:Hi to everyone please see this oneI tried to solve this problem using a more sophisticated approach based on assigning each cell (or UITextField) in a UITableView a unique tag value that can be later retrieved:\nactivate-next-uitextfield-in-uitableview-iosI hope this helps!This worked for me in Xamarin.iOS / Monotouch.\nChange the keyboard button to Next, pass the control to the next UITextField and hide the keyboard after the last UITextField.Inside the ViewDidLoad you\'ll have:If your TextFields haven\'t a Tag set it now:and just the callI rather prefer to:In the NIB file I hook the textFields in the desired order into this inputFields array. After that I do a simple test for the index of the UITextField that reports that the user tapped return:I had about 10+ UITextField in my story board and the way I enabled next functionality was by creating an array of UITextField and making the next UITextField the firstResponder. Here\'s the implementation file:I\'ve just created new Pod when dealing with this stuff GNTextFieldsCollectionManager. It automatically handles next/last textField problem and is very easy to use:Grabs all textfields sorted by appearing in view hierarchy (or by tags), or you can specify your own array of textFields.in textFieldShouldReturn you should check that the textfield you are currently on is not the last one when they click next and if its n ot dont dismiss the keyboard..This is an old post, but has a high page rank so I\'ll chime in with my solution.I had a similar issue and ended up creating a subclass of UIToolbar to manage the next/previous/done functionality in a dynamic tableView with sections: https://github.com/jday001/DataEntryToolbarYou set the toolbar as inputAccessoryView of your text fields and add them to its dictionary. This allows you to cycle through them forwards and backwards, even with dynamic content. There are delegate methods if you want to trigger your own functionality when textField navigation happens, but you don\'t have to deal with managing any tags or first responder status.There are code snippets & an example app at the GitHub link to help with the implementation details. You will need your own data model to keep track of the values inside the fields.Without usings tags and without adding a property for nextField/nextTextField, you can try this to emulate TAB, where "testInput" is your current active field:I\'ve been using Michael G. Emmons\' answer for about a year now, works great. I did notice recently that calling resignFirstResponder and then becomeFirstResponder immediately can cause the keyboard to "glitch", disappearing and then appearing immediately. I changed his version slightly to skip the resignFirstResponder if the nextField is available.you can use IQKeyboardManager library to do this. it handle every thing, you don\'t need any additional setup.IQKeyboardManager is available through CocoaPods, to install it simply add the following line to your Podfile:or\nJust drag and drop IQKeyBoardManager directory from demo project to your project. That\'s it.\nyou can find IQKeyBoardManager directory from https://github.com/hackiftekhar/IQKeyboardManagerThis is a simple solution in swift, with no tag using, no storyboard tricks...Just use this extension :And call it like this (for example) with your textfield delegate:Here is a Swift 3 version of Anth0\'s answer. I\'m posting it here to help any swift developers in wanting to take advantage of his great answer! I took the liberty of adding a return key type of "Next" when you set the associated object.Here is another extension that shows a possibility of using the above code to cycle through a list of UITextFields.And then in your ViewController or wherever, you can setup your textfields like so...Solution in Swift 3.1, After connecting your textfields IBOutlets set your textfields delegate in viewDidLoad, And then navigate your action in textFieldShouldReturn