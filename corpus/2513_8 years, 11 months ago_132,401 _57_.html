I have read the documentation on this and I think I understand. An AutoResetEvent resets when the code passes through event.WaitOne(), but a ManualResetEvent does not.Is this correct?Yes. It\'s like the difference between a tollbooth and a door. The ManualResetEvent is the door, which needs to be closed (reset) manually. The AutoResetEvent is a tollbooth, allowing one car to go by and automatically closing before the next one can get through.Just imagine that the AutoResetEvent executes WaitOne() and Reset() as a single atomic operation.The short answer is yes. The most important difference is that an AutoResetEvent will only allow one single waiting thread to continue. A ManualResetEvent on the other hand will keep allowing threads, several at the same time even, to continue until you tell it to stop (Reset it).Taken from C# 3.0 Nutshell book, by\n  Joseph AlbahariThreading in C# - Free E-BookA ManualResetEvent is a variation on AutoResetEvent. It differs in that it doesn\'t automatically reset after a thread is let through on a WaitOne call, and so functions like a gate: calling Set opens the gate, allowing any number of threads that WaitOne at the gate through; calling Reset closes the gate, causing, potentially, a queue of waiters to accumulate until its next opened.One could simulate this functionality with a boolean "gateOpen" field (declared with the volatile keyword) in combination with "spin-sleeping" \xe2\x80\x93 repeatedly checking the flag, and then sleeping for a short period of time.ManualResetEvents are sometimes used to signal that a particular operation is complete, or that a thread\'s completed initialization and is ready to perform work.I created simple examples to clarify understanding of ManualResetEvent vs AutoResetEvent.AutoResetEvent: lets assume you have 3 workers thread. If any of those threads will call WaitOne() all other 2 threads will stop execution and wait for signal. I am assuming they are using WaitOne(). It is like; if I do not work, nobody works. In first example you can see thatWhen you call Set(); all threads will work and wait for signal. After 1 sec I am sending second signal and they execute and wait (WaitOne();). Think about these guys are soccer team players and if one player says I will wait until manager calls me, and others will wait until manager tells them to continue (Set();)In this example you can clearly see that when you first hit Set(); it will let all threads go, then after 1 sec it signals all threads to wait! As soon as you set them again regardless they are calling WaitOne() inside, they will keep running because you have to manually call Reset() to stop them all. It is more about Referee/Players relationship there regardless of any of the player is injured and wait for playing others will continue to work. If Referee says wait (Reset();) then all players will wait until next signal.Yes, thats right.You can get an idea by the usage of these two.If you need to tell that you are finished with some work and other (threads) waiting for this can now proceed, you should use ManualResetEvent.If you need to have mutual exclusive access to any resource, you should use AutoResetEvent.autoResetEvent.WaitOne() is similar toas an atomic operationYes. This is absolutely correct.You could see ManualResetEvent as a way to indicate state. Something is on (Set) or off (Reset). An occurrence with some duration.  Any thread waiting for that state to happen can proceed.An AutoResetEvent is more comparable to a signal. A one shot indication that something has happened. An occurrence without any duration. Typically but not necessarily the "something" that has happened is small and needs to be handled by a single thread - hence the automatic reset after a single thread have consumed the event. AutoResetEvent maintains a boolean variable in memory. If the boolean variable is false then it blocks the thread and if the boolean variable is true it unblocks the thread.When we instantiate an AutoResetEvent object, we pass the default value of boolean value in the constructor. Below is the syntax of instantiate an AutoResetEvent object.WaitOne methodThis method blocks the current thread and wait for the signal by other thread. WaitOne method puts the current thread into a Sleep thread state. WaitOne method returns true if it receives the signal else returns false.Second overload of WaitOne method wait for the specified number of seconds. If it does not get any signal thread continues its work.We called WaitOne method by passing the 2 seconds as arguments. In the while loop, it wait for the signal for 2 seconds then it continues its work. When the thread got the signal WaitOne returns true and exits the loop and print the "Thread got signal".Set methodAutoResetEvent Set method sent the signal to the waiting thread to proceed its work. Below is the syntax of calling Set method.ManualResetEvent maintains a boolean variable in memory. When the boolean variable is false then it blocks all threads and when the boolean variable is true it unblocks all threads.When we instantiate a ManualResetEvent, we initialize it with default boolean value.In the above code, we initialize the ManualResetEvent with false value, that means all the threads which calls the WaitOne method will block until some thread calls the Set() method.If we initialize ManualResetEvent with true value, all the threads which calls the WaitOne method will not block and free to proceed further.WaitOne MethodThis method blocks the current thread and wait for the signal by other thread. It returns true if its receives a signal else returns false.Below is the syntax of calling WaitOne method.In the second overload of WaitOne method, we can specify the time interval till the current thread wait for the signal. If within time internal, it does not receives a signal it returns false and goes into the next line of method.Below is the syntax of calling WaitOne method with time interval.We have specify 5 seconds into the WaitOne method. If the manualResetEvent object does not receives a signal between 5 seconds, it set the isSignalled variable to false.Set MethodThis method is used for sending the signal to all waiting threads. Set() Method set the ManualResetEvent object boolean variable to true. All the waiting threads are unblocked and proceed further.Below is the syntax of calling Set() method.Reset MethodOnce we call the Set() method on the ManualResetEvent object, its boolean remains true. To reset the value we can use Reset() method. Reset method change the boolean value to false.Below is the syntax of calling Reset method.We must immediately call Reset method after calling Set method if we want to send signal to threads multiple times.OK, normally it does not a good practice to add 2 answers in same thread, but I did not want to edit/delete my previous answer, since it can help on another manner.Now, I created, much more comprehensive, and easy to understand, run-to-learn console app snippet below.Just run the examples on two different consoles, and observe behaviour. You will get much more clear idea there what is happening behind the scenes.Manual Reset EventAuto Reset Event