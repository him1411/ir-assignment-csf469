I\'m working on a small iPhone app, and I am using NSUserDefaults as my data persistence.  It only has to keep track of a few things, such as some names and some numbers so I figure I might as well keep it simple.I found this page for some reference, but I don\'t think it can answer my question.  Basically, I want to be able to check if a value (or a key) already exists in the NSUserDefaults and then do something accordingly.Some examples: The app starts up, if this is the first time it starts up it outputs an alert saying welcome.  To tell if this is first time it has opened it reads the UserDefaults and checks.Example 2:  It says, "Hello [Name]", where Name is something you have entered.  If you have opened the app and there is no name, it should say "Hello World."  I need to check if you have entered a name already and act accordingly.  The name would be stored in NSUserDefaults.Some help here?  I\'d really appreciate it!objectForKey: will return nil if it doesn\'t exist.As mentioned above it wont work for primitive types where 0/NO could be a valid value. I am using this code.The objectForKey: method will return nil if the value does not exist. Here\'s a simple IF / THEN test that will tell you if the value is nil:"objectForKey will return nil if it doesn\'t exist."  It will also return nil if it does exist and it is either an integer or a boolean with a value of zero (i.e. FALSE or NO for the boolean).I\'ve tested this in the simulator for both 5.1 and 6.1.  This means that you cannot really test for either integers or booleans having been set by asking for "the object".  You can get away with this for integers if you don\'t mind treating "not set" as if it were "set to zero".The people who already tested this appear to have been fooled by the false negative aspect, i.e. testing this by seeing if objectForKey returns nil when you know the key hasn\'t been set but failing to notice that it also returns nil if the key has been set but has been set to NO.For my own problem, that sent me here, I just ended up changing the semantics of my boolean so that my desired default was in congruence with the value being set to NO.  If that\'s not an option, you\'ll need to store as something other than a boolean and make sure that you can tell the difference between YES, NO, and "not set."Try this little crumpet:Treat everything as an object.  Seems to work for me.I just went through this, and all of your answers helped me toward a good solution, for me. I resisted going the route suggested by, just because I found it hard to read and comprehend.Here\'s what I did. I had a BOOL being carried around in a variable called "_talkative".When I set my default (NSUserDefaults) object, I set it as an object, as I could then test to see if it was nil:Then when I went to see if it existed, I used:Then I used the object as a BOOL:This seems to work in my case. It just made more visual sense to me.Swift version to get Bool?Extend UserDefaults once to don\'t copy-paste this solution:Swift 3:I was scratching my head why int/double/float/bool aren\'t treated as optionals in the same way that, for example, String is (returns nil if key doesn\'t exist, otherwise returns the stored string value).So here is a simple extension for the four core types that mimic the behavior of the other types you interact with through UserDefaults.They are now more consistent alongside the other built-in get methods (string, data, etc.). Just use the get methods in place of the old ones.In Swift3, I have used in this wayThe answer is great if you are to use that multiple times.I hope it helps :)Swift 3.0   