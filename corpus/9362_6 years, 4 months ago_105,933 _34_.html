Can somebody please explain with examples (of code) what is the difference between deadlock and livelock?Taken from http://en.wikipedia.org/wiki/Deadlock:In concurrent computing, a deadlock is a state in which each member of a group of actions, is waiting for some other member to release a lockA livelock is similar to a deadlock,\n  except that the states of the\n  processes involved in the livelock\n  constantly change with regard to one\n  another, none progressing. Livelock is\n  a special case of resource starvation;\n  the general definition only states\n  that a specific process is not\n  progressing.A real-world example of\n  livelock occurs when two people meet\n  in a narrow corridor, and each tries\n  to be polite by moving aside to let\n  the other pass, but they end up\n  swaying from side to side without\n  making any progress because they both\n  repeatedly move the same way at the\n  same time.Livelock is a risk with\n  some algorithms that detect and\n  recover from deadlock. If more than\n  one process takes action, the deadlock\n  detection algorithm can be repeatedly\n  triggered. This can be avoided by\n  ensuring that only one process (chosen\n  randomly or by priority) takes action.LivelockA thread often acts in response to the action of another thread. If\n  the other thread\'s action is also a response to the action of another\n  thread, then livelock may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked \xe2\x80\x94 they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphonse moves to his right, while Gaston moves to his left. They\'re still blocking each other, and so on...The main difference between livelock and deadlock is that threads are not going to be blocked, instead they will try to respond to each other continuously. In this image, both circles (threads or processes) will try to give space to the other by moving left and right. But they can\'t move any further.All the content and examples here are fromOperating Systems: Internals and Design Principles\nWilliam Stallings\n8\xc2\xba EditionDeadlock: A situation in which two or more processes are unable to proceed because each is waiting for one the others to do something.For example, consider two processes, P1 and P2, and two resources, R1 and R2. Suppose that each process needs access to both resources to perform part of its function. Then it is possible to have the following situation: the OS assigns R1 to P2, and R2 to P1. Each process is waiting for one of the two resources. Neither will release the resource that it already owns until it has acquired\nthe other resource and performed the function requiring both resources. The two\nprocesses are deadlockedLivelock: A situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work:Starvation: A situation in which a runnable process is overlooked indefinitely by the scheduler; although it is able to proceed, it is never chosen.Suppose that three processes (P1, P2, P3) each require periodic access to resource R. Consider the situation in which P1 is in possession of the resource, and both P2 and P3 are delayed, waiting for that resource. When P1 exits its critical section, either P2 or P3 should be allowed access to R. Assume that the OS grants access to P3 and that P1 again requires access before P3 completes its critical section. If the OS grants access to P1 after P3 has finished, and subsequently alternately grants access to P1 and P3, then P2 may indefinitely be denied access to the resource, even though there is no deadlock situation.APPENDIX A - TOPICS IN CONCURRENCYDeadlock ExampleIf both processes set their flags to true before either has executed the while statement, then each will think that the other has entered its critical section, causing deadlock.Livelock Example[...] consider the following sequence of events:This sequence could be extended indefinitely, and neither process could enter its critical section. Strictly speaking, this is not deadlock, because any alteration in the relative speed of the two processes will break this cycle and allow one to enter the critical section. This condition is referred to as livelock. Recall that deadlock occurs when a set of processes wishes to enter their critical sections but no process can succeed. With livelock, there are possible sequences of executions that succeed, but it is also possible to describe one or more execution sequences in which no process ever enters its critical section.DEADLOCK\nDeadlock is a condition in which a task waits\nindefinitely for conditions that can never be\nsatisfied\n- task claims exclusive control over shared\nresources\n- task holds resources while waiting for other\nresources to be released\n- tasks cannot be forced to relinguish resources\n- a circular waiting condition existsLIVELOCK\nLivelock conditions can arise when two or\nmore tasks depend on and use the some\nresource causing a circular dependency\ncondition where those tasks continue\nrunning forever, thus blocking all lower\npriority level tasks from running (these\nlower priority tasks experience a condition\ncalled starvation)Maybe these two examples illustrate you the difference between a deadlock and a livelock:Java-Example for a deadlock:Sample output:Java-Example for a livelock:Sample output:Both examples force the threads to aquire the locks in different orders.\nWhile the deadlock waits for the other lock,\nthe livelock does not really wait - it desperately tries to acquire the lock without the chance of getting it. Every try consumes CPU cycles.With Reference : http://operatingsystemgeeks.blogspot.in/\nExample of deadlock : \nMutual exclusion condition applies, since only one vehicle can be on a section of the street at a time.\nHold-and-wait condition applies, since each vehicle is occupying a section of the street, and waiting to move on to the next section of the street.\nNo-preemptive condition applies, since a section of the street that is a section of the street that is occupied by a vehicle cannot be taken away from it.\nCircular wait condition applies, since each vehicle is waiting on the next vehicle to move. That is, each vehicle in the traffic is waiting for a section of street held by the next vehicle in the traffic.