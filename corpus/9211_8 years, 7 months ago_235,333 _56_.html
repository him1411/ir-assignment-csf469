I need a regular expression to select all the text between two outer brackets.Example: some text(text here(possible text)text(possible text(more text)))end textResult: (text here(possible text)text(possible text(more text)))I\'ve been trying for hours, mind you my regular expression knowledge isn\'t what I\'d like it to be :-) so any help will be gratefully received.Regular expressions are the wrong tool for the job because you are dealing with nested structures, i.e. recursion.But there is a simple algorithm to do this, which I described in this answer to a previous question. You can use regex recursion:I want to add this answer for quickreference. Feel free to update..NET Regex using balancing groups.Where c is used as the depth counter.Demo at Regexstorm.comPCRE using a recursive pattern.Demo at regex101; Or without alternation:Demo at regex101. The pattern is pasted at (?R) which represents (?0).Perl, PHP, Notepad++, R: perl=TRUE, Python: Regex package with (?V1) for Perl behaviour.Ruby using subexpression calls.With Ruby 2.0 \\g<0> can be used to call full pattern.Demo at Rubular; Ruby 1.9 only supports capturing group recursion:Demo at Rubular  (atomic grouping since Ruby 1.9.3)JavaScript  API :: XRegExp.matchRecursiveJS, Java and other regex flavors without recursion up to 2 levels of nesting:Demo at regex101. Deeper nesting needs to be added to pattern.\nTo fail faster on unbalanced parenthesis drop the + quantifier.Reference - What does this regex mean?[^\\(]* matches everything that isn\'t an opening bracket at the beginning of the string, (\\(.*\\)) captures the required substring enclosed in brackets, and [^\\)]* matches everything that isn\'t a closing bracket at the end of the string. Note that this expression does not attempt to match brackets; a simple parser (see dehmann\'s answer) would be more suitable for that. It is actually possible to do it using .NET regular expressions, but it is not trivial, so read carefully.  You can read a nice article here. You also may need to read up on .NET regular expressions. You can start reading here.Angle brackets <> were used because they do not require escaping.The regular expression looks like this:If you want to select text between two matching parentheses, you are out of luck with regular expressions. This is impossible(*).This regex just returns the text between the first opening and the last closing parentheses in your string.(*) Unless your regex engine has features like balancing groups or recursion. The number of engines that support such features is slowly growing, but they are still not a commonly available. The regular expression using Ruby (version 1.9.3 or above):Demo on rubularThis is the definitive regex:Example:note that the \'(pip\' is correctly managed as string.\n(tried in regulator: http://sourceforge.net/projects/regulator/) The answer depends on whether you need to match matching sets of brackets, or merely the first open to the last close in the input text.If you need to match matching nested brackets, then you need something more than regular expressions. - see @dehmannIf it\'s just first open to last close see @ZachDecide what you want to happen with:You need to decide what your code needs to match in this case.I have written a little javascript library called balanced to help with this task, you can accomplish this by doing you can even do replacementsheres a more complex and interactive example JSFiddleso you need first and last parenthess, use smth like this\nstr.indexOf(\'(\'); - it will give you first occurance\nstr.lastIndexOf(\')\'); - last oneso u need string between, \nString searchedString = str.substring(str1.indexOf(\'(\'),str1.lastIndexOf(\')\');Here is a customizable solution allowing single character literal delimiters in Java:Sample usage:Regular expressions can not do this. Regular expressions are based on a computing model known as Finite State Automata (FSA). As the name indicates, a FSA can remember only the current state, it has no information about the previous states.In the above diagram, S1 and S2 are two states where S1 is the starting and final step. So if we try with the string 0110 , the transition goes as follows:In the above steps, when we are are at second S2 i.e. after parsing 01 of 0110, the FSA has no information about the previous 0 in 01 as it can only remember the current state and the next input symbol.In the above problem, we need to know the no of opening parenthesis; this means it has to be stored at some place. But since FSAs can not do that, a regular expression can not be written.However, an algorithm can be written to achieve the goal. Algorithms are generally falls under Pushdown Automata (PDA). PDA is one level above of FSA. PDA has an additional stack to store something. PDAs can be used to solve the above problem, because we can \'push\' the opening parenthesis in the stack and \'pop\' them once we encounter a closing parenthesis. If at the end, stack is empty, then opening parenthesis and closing parenthesis matches. Otherwise not. A detailed discussion can be found here. 