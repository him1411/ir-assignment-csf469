Possible Duplicate:\n  How do I calculate the elapsed time of an event in java? I want to have something like this:Which types to use in order to accomplish this in Java?\n(Also it is important that for example if the startTime it\'s 23:00 and endTime 1:00 to get a duration of 2:00.)Unfortunately, none of the ten answers posted so far are quite right.If you are measuring elapsed time, and you want it to be correct, you must use System.nanoTime().  You cannot use System.currentTimeMillis(), unless you don\'t mind your result being wrong.The purpose of nanoTime is to measure elapsed time, and the purpose of currentTimeMillis is to measure wall-clock time. You can\'t use the one for the other purpose. The reason is that no computer\'s clock is perfect; it always drifts and occasionally needs to be corrected.  This correction might either happen manually, or in the case of most machines, there\'s a process that runs and continually issues small corrections to the system clock ("wall clock"). These tend to happen often. Another such correction happens whenever there is a leap second.Since nanoTime\'s purpose is to measure elapsed time, it is unaffected by any of these small corrections. It is what you want to use. Any timings currently underway with currentTimeMillis will be off -- possibly even negative.You may say, "this doesn\'t sound like it would ever really matter that much," to which I say, maybe not, but overall, isn\'t correct code just better than incorrect code?  Besides, nanoTime is shorter to type anyway.Previously posted disclaimers about nanoTime usually having only microsecond precision are valid. Also it can take more than a whole microsecond to invoke, depending on circumstances (as can the other one), so don\'t expect to time very very small intervals correctly.Which types to use in order to accomplish this in Java?The short answer is a long. Now, more on how to measure...The "traditional" way to do this is indeed to use System.currentTimeMillis():Note that Commons Lang has a StopWatch class that can be used to measure execution time in milliseconds. It has methods methods like split(), suspend(), resume(), etc that allow to take measure at different points of the execution and that you may find convenient. Have a look at it.You may prefer to use System.nanoTime() if you are looking for extremely precise measurements of elapsed time. From its javadoc: Another option would be to use JAMon, a tool that gathers statistics (execution time, number of hit, average execution time, min, max, etc) for any code that comes between start() and stop() methods. Below, a very simple example:Check out this article on www.javaperformancetunning.com for a nice introduction.Finally, if you don\'t want to clutter your code with these measurement (or if you can\'t change existing code), then AOP would be a perfect weapon. I\'m not going to discuss this very deeply but I wanted at least to mention it. Below, a very simple aspect using AspectJ and JAMon (here, the short name of the pointcut will be used for the JAMon monitor, hence the call to thisJoinPoint.toShortString()):The pointcut definition could be easily adapted to monitor any method based on the class name, the package name, the method name, or any combination of these. Measurement is really a perfect use case for AOP.Your new class:Usage:Afterwards, the time passed can be converted to whatever format you like, with a calender for exampleGreetz,\nGHadIf the purpose is to simply print coarse timing information to your program logs, then the easy solution for Java projects is not to write your own stopwatch or timer classes, but just use the org.apache.commons.lang.time.StopWatch class that is part of Apache Commons Lang.We have new technology for this now built into Java 8 and later, the java.time framework. The java.time framework is defined by JSR 310, inspired by the highly successful Joda-Time project, extended by the ThreeTen-Extra project, and described in the Oracle Tutorial.The old date-time classes such as java.util.Date/.Calendar bundled with the earliest versions of Java have proven to be poorly designed, confusing, and troublesome. They are supplanted by the java.time classes.Other answers discuss resolution.The java.time classes have nanosecond resolution, up to nine digits of a decimal fraction of a second. For example, 2016-03-12T04:29:39.123456789Z.Both the old java.util.Date/.Calendar classes and the Joda-Time classes have millisecond resolution (3 digits of fraction). For example, 2016-03-12T04:29:39.123Z.In Java 8, the current moment is fetched with up to only millisecond resolution because of a legacy issue. In Java 9 and later, the current time can be determined up to nanosecond resolution provided your computer\xe2\x80\x99s hardware clock runs so finely.If you truly want to work with only the time-of-day lacking any date or time zone, use the LocalTime class. A Duration represents a span of time it terms of a count of seconds plus nanoseconds.Dump to console.sooner: 17:00 | later: 19:00 | duration: PT2HNotice the default output of Duration::toString is in standard ISO 8601 format. In this format, the P marks the beginning (as in \'Period\'), and the T separates any years-months-days portion from the hours-minutes-seconds portion.Unfortunately, working with time-of-day only gets tricky when you wrap around the clock crossing midnight. The LocalTime class handles this by assuming you want to go backwards to an earlier point in the day. Using the same code as above but going from 23:00 to 01:00 results in a negative twenty-two hours (PT-22H).sooner: 23:00 | later: 01:00 | duration: PT-22HIf you intend to cross midnight, it probably makes sense for you to be working with date-time values rather than time-of-day-only values. Time zone is crucial to dates. So we specify three items: (1) the desired date, (2) desired time-of-day, and (3) the time zone as a context by which to interpret that date and time. Here we arbitrarily choose the time zone of the Montr\xc3\xa9al area.If you define the date by only an offset-from-UTC, use a ZoneOffset with a OffsetDateTime. If you have a full time zone (offset plus rules for handling anomalies such as Daylight Saving Time), use a ZoneId with a ZonedDateTime.We specify the later time as next day at 1:00 AM.We calculate the Duration in the same manner as seen above. Now we get the two hours expected by this Question.Dump to console.sooner: 2016-01-23T23:00-05:00[America/Montreal] | later: 2016-01-24T01:00-05:00[America/Montreal] | duration: PT2HIf the date-times at hand had involved Daylight Saving Time (DST) or other such anomaly, the java.time classes would adjust as needed. Read class doc for details.Java provides the static method System.currentTimeMillis(). And that\'s returning a long value, so it\'s a good reference. A lot of other classes accept a \'timeInMillis\' parameter which is long as well.And a lot of people find it easier to use the Joda Time library to do calculations on dates and times.Which types to use in order to accomplish this in Java?Answer: longUsage:That\'s my direct answer for your first question. For the last "note" I would suggest you to use Joda Time. It contains an interval class suitable for what you need.It is worth noting thatIf you are writing an application that must deal with durations of time, then please take a look at Joda-Time which has class specifically for handling Durations, Intervals, and Periods.  Your getDuration() method looks like it could return a Joda-Time Interval:If you prefer using Java\'s Calendar API you can try this,If you\'re getting your timestamps from System.currentTimeMillis(), then your time variables should be longs.i found this code to be useful when timing things:Use this:(Also it is important that for example if the startTime it\'s 23:00 and endTime 1:00 to get a duration of 2:00.)the "else" part can get it correct