Is there a simple way to delete all local branches which do not have a remote equivalent?Example:Branches (local and remote)Locally, I only have a master branch. Now I need to work on bug-fix-a, so I check it out, work on it, and push changes to the remote. Next I do the same with bug-fix-b.Branches (local and remote)Now I have local branches master, bug-fix-a, bug-fix-b. The Master branch maintainer will merge my changes into master and delete all branches he has already merged.So the current state is now:Branches (local and remote)Now I would like to call some command to delete branches (in this case bug-fix-a, bug-fix-b), which are no longer represented in the remote repository.It would be something like the existing command git remote prune origin, but more like git local prune origin.git remote prune origin prunes tracking branches not on the remote.git branch --merged lists branches that have been merged into the current branch.xargs git branch -d deletes branches listed on standard input.Be careful deleting branches listed by git branch --merged. The list could include master or other branches you\'d prefer not to delete.To give yourself the opportunity to edit the list before deleting branches, you could do the following in one line:git branch --merged >/tmp/merged-branches && vi /tmp/merged-branches && xargs git branch -d </tmp/merged-branchesAfter the commandremoves the remote references, when you runit will show \'gone\' as the remote status. For example,So you can write a simple script to remove local branches that have gone remotes:Most of these answers (including 5 of the top 6) do not actually answer the original question. I looked through a bunch of threads and this answer seems to be the cleanest. Here is a slightly more thorough version of that answer:git fetch -p && git branch -vv | awk \'/: gone]/{print $1}\' | xargs git branch -dExplanation:Works by pruning your tracking branches then deleting the local ones that show they are "gone" in git branch -vv.Notes:Branches that are local only will not be touched. Branches that have been deleted on remote but were not merged will show a notification but not be deleted on local. If you want to delete those as well change -d to -D.Seems solution is here \xe2\x80\x93 https://stackoverflow.com/a/1072178/133986In short, git remote prune does the magic I found the answer here:\nHow can I delete all git branches which have been merged?You can ensure that master, or any other branch for that matter, doesn\'t get removed by adding another grep after the first one. In that case you would go:So if we wanted to keep master, develop and staging for instance, we would go:Since it\'s a bit long, you might want to add an alias to your .zshrc or .bashrc. Mine is called gbpurge (for git branches purge):Then reload your .bashrc or .zshrc:orThis will delete all branches that are not tracked remotely.Remove all branches that have been merged into master, but don\'t try to remove master itself:git checkout master && git pull origin master && git fetch -p && git branch -d $(git branch --merged | grep master -v)or add an alias:alias gitcleanlocal="git checkout master && git pull origin master && git fetch -p && git branch -d $(git branch --merged | grep master -v)"Explanation:git checkout master  checkout master branchgit pull origin master  ensure local branch has all remote changes mergedgit fetch -p remove references to remote branches that have been deletedgit branch -d $(git branch master --merged | grep master -v)  delete all branches that have been merged into master, but don\'t try to remove master itselfI don\'t think there is a built-in command to do this, but it is safe to do the following:When you use -d, git will refuse to delete the branch unless it is completely merged into HEAD or its upstream remote-tracking branch.  So, you could always loop over the output of git for-each-ref and try to delete each branch.  The problem with that approach is that I suspect that you probably don\'t want bug-fix-d to be deleted just because origin/bug-fix-d contains its history.  Instead, you could create a script something like the following:Warning: I haven\'t tested this script - use only with care...This will delete all the merged local branched except local master reference and the one currently being used:And this will delete all the branches having already been removed from the remote repository referenced by "origin", but are still locally available in "remotes/origin".Based on info above, this worked for me:It removes all local branches with are \': gone] \' on remote.I am not sure for how long, but I do use git-up now, which takes care of that.I do git up and it starts to track new branches and deletes the old ones.Just to make it clear, it is not out-of-box git command \xe2\x80\x94 https://github.com/aanand/git-upBTW it also stashes dirty tree and makes rebases still with just git up.Hope it\'ll be useful for someoneI came up with this bash script. It always keep the branches develop, qa, master.Here\'s a solution that I use for the fish shell. Tested on Mac OS X 10.11.5, fish 2.3.0 and git 2.8.3.A few notes:Make sure to set the correct base_branch.  In this case I use develop as the base branch, but it could be anything.This part is very important: grep -v "\\(master\\|$base_branch\\|\\*\\)".  It ensures that you don\'t delete master or your base branch.  I use git branch -d <branch> as an extra precaution, so as to not delete any branch that has not been fully merged with upstream or current HEAD.An easy way to test is to replace git branch -d $f with echo "will delete $f".I suppose I should also add: USE AT YOUR OWN RISK!I use this method so I can have more control. git branch -D $(git branch | grep -v "master" | grep -v "develop")\nThis is remove any branches not named: master or develop.This is gonna delete all the remote branches that are not present locally (in ruby):Explained: