I always mess up how to use const int*, const int * const, and int const * correctly. Is there a set of rules defining what you can and cannot do?I want to know all the do\'s and all don\'ts in terms of assignments, passing to the functions, etc.Read it backwards (as driven by Clockwise/Spiral Rule)... Now the first const can be on either side of the type so:If you want to go really crazy you can do things like this:And to make sure we are clear on the meaning of constfoo is a variable pointer to a constant int. This lets you change what you point to but not the value that you point to. Most often this is seen with cstrings where you have a pointer to a const char. You may change which string you point to but you can\'t change the content of these strings. This is important when the string itself is in the data segment of a program and shouldn\'t be changed.bar is a const or fixed pointer to a value that can be changed. This is like a reference without the extra syntactic sugar. Because of this fact, usually you would use a reference where you would use a T* const pointer unless you need to allow null pointers.For those who don\'t know about Clockwise/Spiral Rule:\nStart from the name of the variable, move clockwisely (in this case, move backward) to the next pointer or type. Repeat until expression ends.here is a demo:I think everything is answered here already, but I just want to add that you should beware of typedefs!  They\'re not just text replacements.  For example:The type of astring is char * const, not const char *.  This is one reason I always tend to put const to the right of the type, and never at the start.Like pretty much everyone pointed out:What\xe2\x80\x99s the difference between const X* p, X* const p and const X* const p?You have to read pointer declarations\n  right-to-left.const X* p means "p points to an X that is const": the X object can\'t be changed via p.X* const p means "p is a const pointer to an X that is non-const": you can\'t change the pointer p itself, but you can change the X object via p.const X* const p means "p is a const pointer to an X that is const": you can\'t change the pointer p itself, nor can you change the X object via p.Constant reference:A reference to a variable (here int), which is constant. We pass the variable as a reference mainly, because references are smaller in size than the actual value, but there is a side effect and that is because it is like an alias to the actual variable. We may accidentally change the main variable through our full access to the alias, so we make it constant to prevent this side effect.Constant pointersOnce a constant pointer points to a variable then it cannot point to any other variable. Pointer to constantA pointer through which one cannot change the value of a variable it points is known as a pointer to constant.Constant pointer to a constantA constant pointer to a constant is a pointer that can neither change the address it\'s pointing to and nor can it change the value kept at that address.Simple Use of \xe2\x80\x98const\xe2\x80\x99The simplest use is to declare a named constant. To do this, one declares a constant as if it was a variable but add \xe2\x80\x98const\xe2\x80\x99 before it. One has to initialise it immediately in the constructor because, of course, one cannot set the value later as that would be altering it. For example,will create an integer constant, unimaginatively called \xe2\x80\x98Constant1\xe2\x80\x99, with the value 96.Such constants are useful for parameters which are used in the program but are do not need to be changed after the program is compiled. It has an advantage for programmers over the C preprocessor \xe2\x80\x98#define\xe2\x80\x99 command in that it is understood & used by the compiler itself, not just substituted into the program text by the preprocessor before reaching the main compiler, so error messages are much more helpful.It also works with pointers but one has to be careful where \xe2\x80\x98const\xe2\x80\x99 to determine whether the pointer or what it points to is constant or both. For example,declares that Constant2 is variable pointer to a constant integer andis an alternative syntax which does the same, whereasdeclares that Constant3 is constant pointer to a variable integer anddeclares that Constant4 is constant pointer to a constant integer. Basically \xe2\x80\x98const\xe2\x80\x99 applies to whatever is on its immediate left (other than if there is nothing there in which case it applies to whatever is its immediate right).ref: http://duramecho.com/ComputerInformation/WhyHowCppConst.htmlThis question shows precisely why I like to do things the way I mentioned in my question is const after type id acceptable?In short, I find the easiest way to remember the rule is that the "const" goes after the thing it applies to. So in your question, "int const *" means that the int is constant, while "int * const" would mean that the pointer is constant.If someone decides to put it at the very front (eg: "const int *"), as a special exception in that case it applies to the thing after it.Many people like to use that special exception because they think it looks nicer. I dislike it, because it is an exception, and thus confuses things.Rule is "const" apply to what preceed it immediately.  Exception, a starting const applies to what follow.const int* is the same as int const* and means "pointer to constant int".const int* const is the same as int const* const and means "constant pointer to constant int"Edit:  for the do and don\'t, if this answer isn\'t enough, could you be more precise about what you want?I had the same doubt as you until I came across this book by the C++ Guru Scott Meyers. Refer the third Item in this book where he talks in details about using const.Just follow this adviceThere are many other subtle points surrounding const correctness in C++.  I suppose the question here has simply been about C, but I\'ll give some related examples since the tag is C++ :You often pass large arguments like strings as TYPE const & which prevents the object from being either modified or copied.  Example :TYPE& TYPE::operator=(const TYPE &rhs) { ... return *this; }But TYPE &  const is meaningless because references are always const.You should always label class methods that do not modify the class as const, otherwise you cannot call the method from a TYPE const & reference.  Example :bool TYPE::operator==(const TYPE &rhs) const { ... }There are common situations where both the return value and the method should be const.  Example :const TYPE TYPE::operator+(const TYPE &rhs) const { ... }In fact, const methods must not return internal class data as a reference-to-non-const.As a result, one must often create both a const and a non-const method using const overloading.  For example, if you define T const& operator[] (unsigned i) const;, then you\'ll probably also want the non-const version given by :inline T& operator[] (unsigned i) {\n  return const_cast<char&>( \n     static_cast<const TYPE&>(*this)[](i)\n  );\n}Afaik, there are no const functions in C, non-member functions cannot themselves be const in C++, const methods might have side effects, and the compiler cannot use const functions to avoid duplicate function calls.  In fact, even a simple int const & reference might witness the value to which it refers be changed elsewhere.It\'s simple but tricky. Please note that we can swap the const qualifier with any data type (int, char, float, etc.).Let\'s see the below examples.const int *p ==> *p is read-only [p is a pointer to a constant integer]int const *p ==> *p is read-only [p is a pointer to a constant integer]int *p const ==> Wrong Statement. Compiler throws a syntax error.int *const p ==> p is read-only [p is a constant pointer to an integer].\nAs pointer p here is read-only, the declaration and definition should be in same place.const int *p const  ==> Wrong Statement. Compiler throws a syntax error.const int const *p  ==> *p is read-onlyconst int *const p1  ==> *p and p are read-only [p is a constant pointer to a constant integer]. As pointer p here is read-only, the declaration and definition should be in same place.int const *p const  ==> Wrong Statement. Compiler throws a syntax error.int const int *p    ==> Wrong Statement. Compiler throws a syntax error.int const const *p  ==> *p is read-only and is equivalent to int const *pint const *const p  ==> *p and p are read-only [p is a constant pointer to a constant integer]. As pointer p here is read-only, the declaration and definition should be in same place.The C and C++ declaration syntax has repeatedly been described as a failed experiment, by the original designers.Instead, let\'s name the type “pointer to Type”; I’ll call it Ptr_:Now Ptr_<char> is a pointer to char.Ptr_<const char> is a pointer to const char.And const Ptr_<const char> is a const pointer to const char.There.