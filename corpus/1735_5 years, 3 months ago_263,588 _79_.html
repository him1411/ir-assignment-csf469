I have a JavaScript array like:How would I go about making this just:You can use concat to merge arrays:Using the apply method of concat will just take the second parameter as an array, so the last line is identical to this:Here\'s a short function that uses some of the newer JavaScript array methods to flatten an n-dimensional array.Usage:Here\'s a simple and performant functional solution:No imperative mess.It can be best done by javascript reduce function.Or, with ES2015:js-fiddleMozilla docsUpdate: it turned out that this solution doesn\'t work with large arrays. It you\'re looking for a better, faster solution, check out this answer.Is simply expands arr and passes it as arguments to concat(), which merges all the arrays into one. It\'s equivalent to [].concat.apply([], arr).You can also try this for deep flattening:See demo on JSBin.References for ECMAScript 6 elements used in this answer:Side note: methods like find() and arrow functions are not supported by all browsers, but it doesn\'t mean that you can\'t use these features right now. Just use Babel \xe2\x80\x94 it transforms ES6 code into ES5.You can use Underscore:A solution for the more general case, when you may have some non-array elements in your array.Most of the answers here don\'t work on huge (e.g. 200 000 elements) arrays, and even if they do, they\'re slow. polkovnikov.ph\'s answer has the best performance, but it doesn\'t work for deep flattening.Here is the fastest solution, which works also on arrays with multiple levels of nesting:I don\'t think it needs explanation; anyone with basic knowledge of JavaScript should be able to understand it.It handles huge arrays just fine. On my machine this code takes about 30 ms to execute.It works with nested arrays. This code produces [1, 1, 1, 1, 1, 1, 1, 1].It doesn\'t have any problems with flattening arrays like this one.Generic procedures mean we don\'t have to rewrite complexity each time we need to utilize a specific behaviour.It concerns me that no one is identifying this as a concatMap because concatMap is exactly what you need in this situation.And yes, you guessed it correctly, it only flattens one level, which is exactly how it should workImagine some data set like thisOk, now say we want to print a roster that shows all the players that will be participating in game …If our flatten procedure flattened nested arrays too, we\'d end up with this garbage result …That\'s not to say sometimes you don\'t want to flatten nested arrays, too \xe2\x80\x93 only that shouldn\'t be the default behaviour.We can make a deepFlatten procedure with ease …There. Now you have a tool for each job \xe2\x80\x93 one for squashing one level of nesting, flatten, and one for obliterating all nesting deepFlatten.Maybe you can call it obliterate or nuke if you don\'t like the name deepFlatten.Another ECMAScript 6 solution in functional style:Declare function: and use it:Please note: When Function.prototype.apply ([].concat.apply([], arrays)) or the spread operator ([].concat(...arrays)) is used in order to flatten an array, both can cause stack overflows for large arrays, because every argument of a function is stored on the stack.Here is a stack-safe implementation in functional style that weighs up the most important requirements against one another:As soon as you get used to small arrow functions in curried form, function composition and higher order functions, this code reads like prose. Programming then merely consists of putting together small building blocks that always work as expected, because they don\'t contain any side effects.What about using reduce(callback[, initialValue]) method of JavaScript 1.8To flatten an array of single element arrays, you don\'t need to import a library, a simple loop is both the simplest and most efficient solution :To downvoters: please read the question, don\'t downvote because it doesn\'t suit your very different problem. This solution is both the fastest and simplest for the asked question.(I\'m just writing this as a separate answer, based on comment of @danhbear.)It looks like this looks like a job for RECURSION!Code:Usage:I have done it using recursion and closuresIf you only have arrays with 1 string element:will do the job. Bt that specifically matches your code example.I would rather transform the whole array, as-is, to a string, but unlike other answers, would do that using JSON.stringify and not use the toString() method, which produce an unwanted result.With that JSON.stringify output, all that\'s left is to remove all brackets, wrap the result with start & ending brackets yet again, and serve the result with JSON.parse which brings the string back to "life".That\'s not hard, just iterate over the arrays and merge them:just the best solution without lodashI was goofing with ES6 Generators the other day and wrote this gist. Which contains...Basically I\'m creating a generator that loops over the original input array, if it finds an array it uses the yield* operator in combination with recursion to continually flatten the internal arrays. If the item is not an array it just yields the single item. Then using the ES6 Spread operator (aka splat operator) I flatten out the generator into a new array instance.I haven\'t tested the performance of this, but I figure it is a nice simple example of using generators and the yield* operator.But again, I was just goofing so I\'m sure there are more performant ways to do this.Here\'s another deep flatten for modern browsers:if your array only consists out of integers or strings you can use this dirty hack:Works, in FF, IE and Chrome didn\'t test the other browsers yet.I\'m aware that this is hacky, but the must succinct way I know of to flatten an array(of any depth!) of strings(without commas!) is to turn the array into a string and then split the string on commas:This should work on any depth of nested arrays containing only strings and numbers(integers and floating points) with the caveat that numbers will be converted to strings in the process. This can be solved with a little mapping:To flatten a two-dimensional array in one line:I propose two short solutions without recursion. They are not optimal from a computational complexity point of view, but work fine in average cases:The logic here is to convert input array to string and remove all brackets([]) and parse output to array. I\'m using ES6 template feature for this.Per request, Breaking down the one line is basically having this. I recommend a space-efficient generator function:If desired, create an array of flattened values as follows:A Haskellesque approach