This has been something that has bothered me for ages now.We are all taught in school (at least, I was) that you MUST free every pointer that is allocated.  I\'m a bit curious, though, about the real cost of not freeing memory.  In some obvious cases, like when malloc is called inside a loop or part of a thread execution, it\'s very important to free so there are no memory leaks.  But consider the following two examples:First, if I have code that\'s something like this:What\'s the real result here?  My thinking is that the process dies and then the heap space is gone anyway so there\'s no harm in missing the call to free (however, I do recognize the importance of having it anyway for closure, maintainability, and good practice).  Am I right in this thinking?Second, let\'s say I have a program that acts a bit like a shell.  Users can declare variables like aaa = 123 and those are stored in some dynamic data structure for later use.  Clearly, it seems obvious that you\'d use some solution that will calls some *alloc function (hashmap, linked list, something like that).  For this kind of program, it doesn\'t make sense to ever free after calling malloc because these variables must be present at all times during the program\'s execution and there\'s no good way (that I can see) to implement this with statically allocated space.  Is it bad design to have a bunch of memory that\'s allocated but only freed as part of the process ending?  If so, what\'s the alternative?Just about every modern operating system will recover all the allocated memory space after a program exits.  The only exception I can think of might be something like Palm OS where the program\'s static storage and runtime memory are pretty much the same thing, so not freeing might cause the program to take up more storage.  (I\'m only speculating here.)So generally, there\'s no harm in it, except the runtime cost of having more storage than you need.  Certainly in the example you give, you want to keep the memory for a variable that might be used until it\'s cleared.However, it\'s considered good style to free memory as soon as you don\'t need it any more, and to free anything you still have around on program exit.  It\'s more of an exercise in knowing what memory you\'re using, and thinking about whether you still need it.  If you don\'t keep track, you might have memory leaks.On the other hand, the similar admonition to close your files on exit has a much more concrete result - if you don\'t, the data you wrote to them might not get flushed, or if they\'re a temp file, they might not get deleted when you\'re done.  Also, database handles should have their transactions committed and then closed when you\'re done with them.  Similarly, if you\'re using an object oriented language like C++ or Objective C, not freeing an object when you\'re done with it will mean the destructor will never get called, and any resources the class is responsible might not get cleaned up.Yes you are right, your example doesn\'t do any harm (at least not on most modern operating systems). All the memory allocated by your process will be recovered by the operating system once the process exits. Source: Allocation and GC Myths (PostScript alert!)Allocation Myth 4: Non-garbage-collected programs\n  should always deallocate all memory\n  they allocate. The Truth: Omitted\n  deallocations in frequently executed\n  code cause growing leaks. They are\n  rarely acceptable. but Programs that\n  retain most allocated memory until\n  program exit often perform better\n  without any intervening deallocation.\n  Malloc is much easier to implement if\n  there is no free.In most cases, deallocating memory\n  just before program exit is pointless.\n  The OS will reclaim it anyway. Free\n  will touch and page in the dead\n  objects; the OS won\'t.Consequence: Be careful with "leak\n  detectors" that count allocations.\n  Some "leaks" are good!That said, you should really try to avoid all memory leaks! Second question: your design is ok. If you need to store something until your application exits then its ok to do this with dynamic memory allocation. If you don\'t know the required size upfront, you can\'t use statically allocated memory.=== What about future proofing and code reuse? ===If you don\'t write the code to free the objects, then you are limiting the code to only being safe to use when you can depend on the memory being free\'d by the process being closed ... i.e. small projects.If you do write the code that free()s all your dynamically allocated memory, then you are future proofing the code and letting others use it in a larger project.There are various reasons for this:All desktop and server environments simply release the entire memory space on exit(). They are unaware of program-internal data structures such as heaps.Almost all free() implementations do not ever return memory to the operating system anyway.More importantly, it\'s a waste of time when done right before exit(). At exit, memory pages and swap space are simply released. By contrast, a series of free() calls will burn CPU time and can result in disk paging operations, cache misses, and cache evictions.Regarding the possiblility of future code reuse justifing the certainty of pointless ops: that\'s a consideration but it\'s arguably not the Agile way. YAGNI!I typically free every allocated block once I\'m sure that I\'m done with it. Today, my program\'s entry point might be main(int argc, char *argv[]) , but tomorrow it might be foo_entry_point(char **args, struct foo *f) and typed as a function pointer.So, if that happens, I now have a leak. Regarding your second question, if my program took input like a=5, I would allocate space for a, or re-allocate the same space on a subsequent a="foo". This would remain allocated until:I can not think of any modern OS that does not reclaim memory after a process exits. Then again, free() is cheap, why not clean up? As others have said, tools like valgrind are great for spotting leaks that you really do need to worry about. Even though the blocks you example would be labeled as \'still reachable\' , its just extra noise in the output when you\'re trying to ensure you have no leaks.Another myth is "If its in main(), I don\'t have to free it", this is incorrect. Consider the following:If that came prior to forking / daemonizing (and in theory running forever), your program has just leaked an undetermined size of t 255 times.A good, well written program should always clean up after itself. Free all memory, flush all files, close all descriptors, unlink all temporary files, etc. This cleanup function should be reached upon normal termination, or upon receiving various kinds of fatal signals, unless you want to leave some files laying around so you can detect a crash and resume.Really, be kind to the poor soul who has to maintain your stuff when you move on to other things .. hand it to them \'valgrind clean\' :)I completely disagree with everyone who says OP is correct or there is no harm.Everyone is talking about a modern and/or legacy OS\'s.But what if I\'m in an environment where I simply have no OS?\nWhere there isn\'t anything?Imagine now you are using thread styled interrupts and allocate memory.\nIn the C standard ISO/IEC:9899 is the lifetime of memory stated as:7.20.3 Memory management functions1 The order and contiguity of storage allocated by successive calls to the calloc,\n  malloc, and realloc functions is unspecified. The pointer returned if the allocation\n  succeeds is suitably aligned so that it may be assigned to a pointer to any type of object\n  and then used to access such an object or an array of such objects in the space allocated\n  (until the space is explicitly deallocated). The lifetime of an allocated object extends\n  from the allocation until the deallocation.[...]So it has not to be given that the environment is doing the freeing job for you.\nOtherwise it would be added to the last sentence: "Or until the program terminates."So in other words:\nNot freeing memory is not just bad practice. It produces non portable and not C conform code.\nWhich can at least be seen as \'correct, if the following is supported by environment\'.But in cases where you have no OS at all, no one is doing the job for you \n(I know generally you don\'t allocate and reallocate memory on embedded systems,\n but there are cases where you may want to.)So speaking in general plain C (as which the OP is tagged),\n this is simply producing erroneous and non portable code.It is completely fine to leave memory unfreed when you exit; malloc() allocates the memory from the memory area called "the heap", and the complete heap of a process is freed when the process exits.That being said, one reason why people still insist that it is good to free everything before exiting is that memory debuggers (e.g. valgrind on Linux) detect the unfreed blocks as memory leaks, and if you have also "real" memory leaks, it becomes more difficult to spot them if you also get "fake" results at the end.This code will usually work alright, but consider the problem of code reuse.You may have written some code snippet which doesn\'t free allocated memory, it is run in such a way that memory is then automatically reclaimed. Seems allright.Then someone else copies your snippet into his project in such a way that it is executed one thousand times per second. That person now has a huge memory leak in his program. Not very good in general, usually fatal for a server application.Code reuse is typical in enterprises. Usually the company owns all the code its employees produce and every department may reuse whatever the company owns. So by writing such "innocently-looking" code you cause potential headache to other people. This may get you fired.If you\'re using the memory you\'ve allocated, then you\'re not doing anything wrong. It becomes a problem when you write functions (other than main) that allocate memory without freeing it, and without making it available to the rest of your program.  Then your program continues running with that memory allocated to it, but no way of using it. Your program and other running programs are deprived of that memory.Edit: It\'s not 100% accurate to say that other running programs are deprived of that memory. The operating system can always let them use it at the expense of swapping your program out to virtual memory (</handwaving>). The point is, though, that if your program frees memory that it isn\'t using then a virtual memory swap is less likely to be necessary.There\'s no real danger in not freeing your variables, but if you assign a pointer to a block of memory to a different block of memory without freeing the first block, the first block is no longer accessible but still takes up space. This is what\'s called a memory leak, and if you do this with regularity then your process will start to consume more and more memory, taking away system resources from other processes.If the process is short-lived you can often get away with doing this as all allocated memory is reclaimed by the operating system when the process completes, but I would advise getting in the habit of freeing all memory you have no further use for.What\'s the real result here?Your program leaked the memory. Depending on your OS, it may have been recovered.Most modern desktop operating systems do recover leaked memory at process termination, making it sadly common to ignore the problem, as can be seen by many other answers here.)But you are relying on a safety feature you should not rely upon, and your program (or function) might run on a system where this behaviour does result in a "hard" memory leak, next time.You might be running in kernel mode, or on vintage / embedded operating systems which do not employ memory protection as a tradeoff. (MMUs take up die space, memory protection costs additional CPU cycles, and it is not too much to ask from a programmer to clean up after himself).You can use and re-use memory any way you like, but make sure you deallocated all resources before exiting.You are correct, memory is automatically freed when the process exits.  Some people strive not to do extensive cleanup when the process is terminated, since it will all be relinquished to the operating system.  However, while your program is running you should free unused memory.  If you don\'t, you may eventually run out or cause excessive paging if your working set gets too big.You are absolutely correct in that respect. In small trivial programs where a variable must exist until the death of the program, there is no real benefit to deallocating the memory.In fact, I had once been involved in a project where each execution of the program was very complex but relatively short-lived, and the decision was to just keep memory allocated and not destabilize the project by making mistakes deallocating it. That being said, in most programs this is not really an option, or it can lead you to run out of memory. If you\'re developing an application from scratch, you can make some educated choices about when to call free. Your example program is fine: it allocates memory, maybe you have it work for a few seconds, and then closes, freeing all the resources it claimed.If you\'re writing anything else, though -- a server/long-running application, or a library to be used by someone else, you should expect to call free on everything you malloc.Ignoring the pragmatic side for a second, it\'s much safer to follow the stricter approach, and force yourself to free everything you malloc. If you\'re not in the habit of watching for memory leaks whenever you code, you could easily spring a few leaks. So in other words, yes -- you can get away without it; please be careful, though.I think that your two examples are actually only one: the free() should occur only at the end of the process, which as you point out is useless since the process is terminating.In you second example though, the only difference is that you allow an undefined number of malloc(), which could lead to running out of memory. The only way to handle the situation is to check the return code of malloc() and act accordingly.