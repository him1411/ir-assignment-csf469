I have a basic dict as follows:When I try to do jsonify(sample) I get:TypeError: datetime.datetime(2012, 8, 8, 21, 46, 24, 862000) is not JSON serializableWhat can I do such that my dictionary sample can overcome the error above?Note: Though it may not be relevant, the dictionaries are generated from the retrieval of records out of mongodb where when I print out str(sample[\'somedate\']), the output is 2012-08-08 21:46:24.862000.As you are using mongoengine (per comments) and pymongo is a dependency, pymongo has built-in utilities to help with json serialization:\nhttp://api.mongodb.org/python/1.10.1/api/bson/json_util.htmlExample usage (serialization):Example usage (deserialization):Building on other answers, a simple solution based on a specific serializer that just converts datetime.datetime and datetime.date objects to strings.As seen, the code just checks to find out if object is of class datetime.datetime or datetime.date, and then uses .isoformat() to produce a serialized version of it, according to ISO 8601 format, YYYY-MM-DDTHH:MM:SS (which is easily decoded by JavaScript). If more complex serialized representations are sought, other code could be used instead of str() (see other answers to this question for examples). The code ends by raising an exception, to deal with the case it is called with a non-serializable type.This json_serial function can be used as follows:The details about how the default parameter to json.dumps works can be found in Section Basic Usage of the json module documentation. Convert the date to a stringI have just encountered this problem and my solution is to subclass json.JSONEncoder:In your call do something like: json.dumps(yourobj, cls=DateTimeEncoder) The .isoformat() I got from one of the answers above.My quick & dirty JSON dump that eats dates and everything:For others who do not need or want to use the pymongo library for this.. you can achieve datetime JSON conversion easily with this small snippet:Then use it like so:output:Â I have an application with a similar issue; my approach was to JSONize the datetime value as a 6-item list (year, month, day, hour, minutes, seconds); you could go to microseconds as a 7-item list, but I had no need to:produces:Here is my solution:Then you can use it like that:My solution (with less verbosity, I think):Then use jsondumps instead of json.dumps. It will print:I you want, later you can add other special cases to this with a simple twist of the default method. Example:  This Q repeats time and time again - a simple way to patch the json module such that serialization would support datetime.  Than use json serialization as you always do - this time with datetime being serialized as isoformat.Resulting in: \'{"created": "2015-08-26T14:21:31.853855"}\'See more details and some words of caution at:\nStackOverflow: JSON datetime between Python and JavaScriptHere is a simple solution to over come "datetime not JSON serializable"\nproblem. Output:-> {"date": "2015-12-16T04:48:20.024609"} You have to supply a custom encoder class with the cls parameter of json.dumps. To quote from the docs:This uses complex numbers as the example, but you can just as easily create a class to encode dates (except I think JSON is a little fuzzy about dates)The simplest way to do this is to change the part of the dict that is in datetime format to isoformat. That value will effectively be a string in isoformat which json is ok with.Here is my full solution for converting datetime to JSON and back..OutputJSON FileThis has enabled me to import and export strings, ints, floats and datetime objects.\nIt shouldn\'t be to hard to extend for other types.If you are using the result in a view be sure to return a proper response. According to the API, jsonify does the following:Creates a Response with the JSON representation of the given arguments\n  with an application/json mimetype.To mimic this behavior with json.dumps you have to add a few extra lines of code.You should also return a dict to fully replicate jsonify\'s response. So, the entire file will look like thisMy solution ...Ok, now some tests.I got the same error message while writing the serialize decorator inside a Class  with sqlalchemy. So instead of :I  simply borrowed jgbarah\'s idea of using isoformat() and appended the original value with isoformat(), so that it now looks like:Convert the date  to  stringA quick fix if you want your own formattingGenerally there are several ways to serialize datetimes, like:If you\'re okay with the last way, the json_tricks package handles dates, times and datetimes including timezones.which gives:So all you need to do isand then import from json_tricks instead of json.The advantage of not storing it as a single string, int or float comes when decoding: if you encounter just a string or especially int or float, you need to know something about the data to know if it\'s a datetime. As a dict, you can store metadata so it can be decoded automatically, which is what json_tricks does for you. It\'s also easily editable for humans.Disclaimer: it\'s made by me. Because I had the same problem.I had encountered same problem when externalizing django model object to dump as JSON.\nHere is how you can solve it.Either make both the dates in mysql as well as in python code json as String or both date or datetime.\nIt worked for me as I converted mysql type to String.My solution was just to use EPOCH time (which is a number) since my use case didn\'t require an end user to read the time in the JSON. It was SO MUCH EASIER to work with epoch time.I may not 100% correct but,\nthis is the simple way to do serialize