For example:\nsizeof(char*) returns 4.  As does int*, long long*, everything that I\'ve tried.  Are there any exceptions to this?The guarantee you get is that sizeof(char) == 1.  There are no other guarantees, including no guarantee that sizeof(int *) == sizeof(double *).In practice, pointers will be size 2 on a 16-bit system (if you can find one), 4 on a 32-bit system, and 8 on a 64-bit system, but there\'s nothing to be gained in relying on a given size.Even on a plain x86 32 bit platform, you can get a variety of pointer sizes, try this out for an example:Under Visual C++ 2008, I get 4, 12 and 8 for the sizes of the pointers-to-member-function.Raymond Chen talked about this here.if you are compiling for a 64-bit machine, then it may be 8.Just another exception to the already posted list. On 32-bit platforms, pointers can take 6, not 4, bytes:If you compile this program with Open Watcom and run it, you\'ll get 6, because far pointers that it supports consist of 32-bit offset and 16-bit segment valuesTechnically speaking, the C standard only guarantees that sizeof(char) == 1, and the rest is up to the implementation. But on modern x86 architectures (e.g. Intel/AMD chips) it\'s fairly predictable.You\'ve probably heard processors described as being 16-bit, 32-bit, 64-bit, etc. This usually means that the processor uses N-bits for integers. Since pointers store memory addresses, and memory addresses are integers, this effectively tells you how many bits are going to be used for pointers. sizeof is usually measured in bytes, so code compiled for 32-bit processors will report the size of pointers to be 4 (32 bits / 8 bits per byte), and code for 64-bit processors will report the size of pointers to be 8 (64 bits / 8 bits per byte). This is where the limitation of 4GB of RAM for 32-bit processors comes from -- if each memory address corresponds to a byte, to address more memory you need integers larger than 32-bits.In addition to the 16/32/64 bit differences even odder things can occur.There have been machines where sizeof(int *) will be one value, probably 4 but where sizeof(char *) is larger.  Machines that naturally address words instead of bytes have to "augment" character pointers to specify what portion of the word you really want in order to properly implement the C/C++ standard.This is now very unusual as hardware designers have learned the value of byte addressability.In addition to what people have said about 64-bit (or whatever) systems, there are other kinds of pointer than pointer-to-object. A pointer-to-member might be almost any size, depending how they\'re implemented by your compiler: they aren\'t necessarily even all the same size. Try a pointer-to-member of a POD class, and then a pointer-to-member inherited from one of the base classes of a class with multiple bases. What fun.8 bit and 16 bit pointers are used in most low profile microcontrollers. That means every washing machine, micro, fridge, older TVs, and even cars.You could say these have nothing to do with real world programming.\nBut here is one real world example:\nArduino with 1-2-4k ram (depending on chip) with 2 byte pointers.It\'s recent, cheap, accessible for everyone and worths coding for.The size of the pointer basically depends on the architecture of the system in which it is implemented. For example the size of a pointer in 32 bit is 4 bytes (32 bit ) and 8 bytes(64 bit )  in a 64 bit machines. The bit types in a machine are nothing but memory address, that it can have. 32 bit machines can have 2^32 address space and 64 bit machines can have upto 2^64 address spaces. So a pointer (variable which points to a memory location) should be able to point to any of the memory address (2^32 for 32 bit and 2^64 for 64 bit) that a machines holds.Because of this reason we see the size of a pointer to be 4 bytes in 32 bit machine and 8 bytes in a 64 bit machine.From what I recall, it\'s based on the size of a memory address. So on a system with a 32-bit address scheme, sizeof will return 4, since that\'s 4 bytes.In general, sizeof(pretty much anything) will change when you compile on different platforms. On a 32 bit platform, pointers are always the same size. On other platforms (64 bit being the obvious example) this can change.No, the size of a pointer may vary depending on the architecture. There are numerous exceptions.Size of pointer and int is 2 bytes in Turbo C compiler on windows 32 bit machine. So size of pointer is compiler specific. But generally most of the compilers are implemented to support 4 byte pointer variable in 32 bit and 8 byte pointer variable in 64 bit machine). So size of pointer is not same in all machines.The reason the size of your pointer is 4 bytes is because you are compiling for a 32-bit architecture.  As FryGuy pointed out, on a 64-bit architecture you would see 8.A pointer is just a container for an address.  On a 32 bit machine, your address range is 32 bits, so a pointer will always be 4 bytes.  On a 64 bit machine were you have an address range of 64 bits, a pointer will be 8 bytes.Just for completeness and historic interest, in the 64bit world there were different platform conventions on the sizes of long and long long types, named LLP64 and LP64, mainly between Unix-type systems and Windows. An old standard named ILP64 also made int = 64-bit wide.Microsoft maintained LLP64 where longlong = 64 bit wide, but long remained at 32, for easier porting.Source: https://stackoverflow.com/a/384672/48026It will always be equal to sizeof size_t.On 32-bit machines this tends to be 4.  On 64-bit machines this tends to be 8.