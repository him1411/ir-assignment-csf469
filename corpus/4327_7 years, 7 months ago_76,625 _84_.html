Yes, I know this subject has been covered before (here, here, here, here), but as far as I know, all solutions, except for one, fail on a list like this:Where the desired output isOr perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found in this question:Is this the best model? Did I overlook something? Any problems?Using generator functions can make your example a little easier to read and probably boost the performance.I used the Iterable ABC added in 2.6.In Python 3, the basestring is no more, but you can use a tuple of str and bytes to get the same effect there.The yield from operator returns an item from a generator one at a time. This syntax for delegating to a subgenerator was added in 3.3My solution:A little more concise, but pretty much the same.Generator version of @unutbu\'s non-recursive solution, as requested by @Andrew in a comment:Slightly simplified version of this generator:Generator using recursion and duck typing (updated for Python 3):This version of flatten avoids python\'s recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).Here are some examples demonstrating its use:Although flatten can handle infinite generators, it can not handle infinite nesting:Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:Usage:Here\'s another answer that is even more interesting...Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:It will flatten datatypes that you might want left alone (like bytearray, bytes, and str objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a TypeError.Edit:I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.Testing the generator works fine with the list that was provided. However, the new code will raise a TypeError when a non-iterable object is given to it. Example are shown below of the new behavior.Although an elegant and very pythonic answer has been selected I would present my solution just for the review:Please tell how good or bad this code is?I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:This works with two lists: an inner for loop and an outer while loop.  The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.  Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.  The flattened list is then returned.Test-run   [1, 2, 3, 4, 100, 200, 300, 1000, 2000, 3000]Here\'s the compiler.ast.flatten implementation in 2.7.5:There are better, faster methods (If you\'ve reached here, you have seen them already)Also note:Deprecated since version 2.6: The compiler package has been removed in Python 3.Here\'s a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.I didn\'t go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp\'s way of first and rest list processing here is one simple and one not-so-simple case -I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :output:You could use deepflatten from the 3rd party package iteration_utilities:It\'s an iterator so you need to iterate it (for example by wrapping it with list or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it\'s written as C extension so it can be faster than pure python approaches:I\'m the author of the iteration_utilities library.totally hacky but I think it would work (depending on your data_type)Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn\'t bounded by python recursion depth since the function calls are happening in C, though this doesn\'t mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you\'ll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using str, unicode so use it with caution ...tests:Using itertools.chain:Or without chaining:I used recursive to solve nested list with any depthSo after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.resultIf you like recursion, this might be a solution of interest to you:I actually adapted this from some practice Scheme code that I had written a while back. Enjoy!I\'m new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):Seems to work. Test:returns:I don\'t see anything like this posted around here and just got here from a closed question on the same subject, but why not just do something like this(if you know the type of the list you want to split):You would need to know the type of the elements but I think this can be generalised and in terms of speed I think it would be faster.Without using any library:Shamelessly taken from my own answer to another question.This functionCode below:I\'m surprised no one has thought of this. Damn recursion I don\'t get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it\'s very specific to the OP\'s use caseoutput:The easiest way is to use the morph library using pip install morph.The code is:We can also use the \'type\' function of python. When iterating the list we check if the item is a list or not. If not we \'append\' it else we \'extend\' it. Here is a sample code - Output:For more info on append() and extend() check this website :\nhttps://docs.python.org/2/tutorial/datastructures.htmlthis might be an old question i\'d like to take a shot at this.I am a dumb guy so I\'ll give a "dumb" solution. all that recursion hurts my brain.I get that it\'s using a side effect but well thats to the best of my comprehension of recursion can goThis will flatten a list or dictionary (or list of lists or dictionaries of dictionaries etc). It assumes that the values are strings and it creates a string that concatenates each item with a separator argument. If you wanted you could use the separator to split the result into a list object afterward. It uses recursion if the next value is a list or a string. Use the key argument to tell whether you want the keys or the values (set key to false) from the dictionary object. yields:just, a, test, to, try, right, now, or, later, today, dictionary_test, dictionary_test_two, my power is 9000