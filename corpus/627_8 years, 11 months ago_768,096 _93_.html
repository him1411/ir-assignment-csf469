What is the technical difference between a process and a thread?I get the feeling a word like \'process\' is overused and there are also hardware and software threads. How about light-weight processes in languages like Erlang? Is there a definitive reason to use one term over the other?Both processes and threads are independent sequences of execution. The typical difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.I\'m not sure what "hardware" vs "software" threads you might be referring to. Threads are an operating environment feature, rather than a CPU feature (though the CPU typically has operations that make threads efficient).Erlang uses the term "process" because it does not expose a shared-memory multiprogramming model. Calling them "threads" would imply that they have shared memory.Process\nEach process provides the resources needed to execute a program. A process has a virtual address space, executable code, open handles to system objects, a security context, a unique process identifier, environment variables, a priority class, minimum and maximum working set sizes, and at least one thread of execution. Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.Thread\nA thread is an entity within a process that can be scheduled for execution. All threads of a process share its virtual address space and system resources. In addition, each thread maintains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled. The thread context includes the thread\'s set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread\'s process. Threads can also have their own security context, which can be used for impersonating clients.Found this on MSDN here:\n About Processes and Threads Microsoft Windows supports preemptive multitasking, which creates the effect of simultaneous execution of multiple threads from multiple processes. On a multiprocessor computer, the system can simultaneously execute as many threads as there are processors on the computer.Taken from "Parallel and Distributed Programming Using C++" by Cameron Hughes and Tracey Hughes, Table 4-1:What is the difference between threads and processes?The major differences between threads and processes are:Process:Thread:I borrowed the above info from the Knowledge Quest! blog.First, let\'s look at the theoretical aspect.  You need to understand what a process is conceptually to understand the difference between a process and a thread and what\'s shared between them.We have the following from section 2.2.2 The Classical Thread Model in Modern Operating Systems 3e by Tanenbaum:The process model is based on two independent concepts: resource\n  grouping and execution. Sometimes it is use\xc2\xadful to separate them;\n  this is where threads come in.... He continues:One way of looking at a process is that it is a way to \n  group related resources together. A process has an address space\n  containing program text and data, as well as other resources. These\n  resource may include open files, child processes, pending alarms,\n  signal handlers, accounting information, and more. By putting them\n  together in the form of a process, they can be managed more easily.\n  The other concept a process has is a thread of execution, usually\n  shortened to just thread. The thread has a program counter that keeps\n  track of which instruc\xc2\xadtion to execute next. It has registers, which\n  hold its current working variables. It has a stack, which contains the\n  execution history, with one frame for each proce\xc2\xaddure called but not\n  yet returned from. Although a thread must execute in some process, the\n  thread and its process are different concepts and can be treated\n  sepa\xc2\xadrately. Processes are used to group resources together; threads\n  are the entities scheduled for execution on the CPU.Further down he provides the following table:Let\'s deal with the hardware multithreading issue.  Classically, a CPU would support a single thread of execution, maintaining the thread\'s state via a single program counter, and set of registers.  But what happens if there\'s a cache miss?  It takes a long time to fetch data from main memory, and while that\'s happening the CPU is just sitting there idle.  So someone had the idea to basically have two sets of thread state ( PC + registers ) so that another thread ( maybe in the same process, maybe in a different process ) can get work done while the other thread is waiting on main memory.  There are multiple names and implementations of this concept, such as HyperThreading and Simultaneous Multithreading ( SMT for short ).  Now let\'s look at the software side.  There are basically three ways that threads can be implemented on the software side.All you need to implement threads is the ability to save the CPU state and maintain multiple stacks, which can in many cases be done in user space.  The advantage of user space threads is super fast thread switching since you don\'t have to trap into the kernel and the ability to schedule your threads the way you like.  The biggest drawback is the inability to do blocking I/O ( which would block the entire process and all it\'s user threads ),  which is one of the big reasons we use threads in the first place.  Blocking I/O using threads greatly simplifies program design in many cases. Kernel threads have the advantage of being able to use blocking I/O, in addition to leaving all the scheduling issues to the OS.  But each thread switch requires trapping into the kernel which is potentially relatively slow.  However, if you\'re switching threads because of blocked I/O this isn\'t really an issue since the I/O operation probably trapped you into the kernel already anyway.Another approach is to combine the two, with multiple kernel threads each having multiple user threads.So getting back to your question of terminology, you can see that a process and a thread of execution are two different concepts and your choice of which term to use depends on what you\'re talking about.  Regarding the term "light weight process", I don\'t personally see the point in it since it doesn\'t really convey what\'s going on as well as the term "thread of execution".An application consists of one or more processes. A process, in the simplest terms, is an executing program. One or more threads run in the context of the process. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the process code, including parts currently being executed by another thread. A fiber is a unit of execution that must be manually scheduled by the application. Fibers run in the context of the threads that schedule them.Stolen from here.A process is a collection of code, memory, data and other resources. A thread is a sequence of code that is executed within the scope of the process. You can (usually) have multiple threads executing concurrently within the same process.A process is an executing instance of an application. What does that mean? Well, for example, when you double-click the Microsoft Word icon, you start a process that runs Word. A thread is a path of execution within a process. Also, a process can contain multiple threads. When you start Word, the operating system creates a process and begins executing the primary thread of that process.It\xe2\x80\x99s important to note that a thread can do anything a process can do. But since a process can consist of multiple threads, a thread could be considered a \xe2\x80\x98lightweight\xe2\x80\x99 process. Thus, the essential difference between a thread and a process is the work that each one is used to accomplish. Threads are used for small tasks, whereas processes are used for more \xe2\x80\x98heavyweight\xe2\x80\x99 tasks \xe2\x80\x93 basically the execution of applications.Another difference between a thread and a process is that threads within the same process share the same address space, whereas different processes do not. This allows threads to read from and write to the same data structures and variables, and also facilitates communication between threads. Communication between processes \xe2\x80\x93 also known as IPC, or inter-process communication \xe2\x80\x93 is quite difficult and resource-intensive. To explain more with respect to concurrent programmingA process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.Threads exist within a process \xe2\x80\x94 every process has at least one. Threads share the process\'s resources, including memory and open files. This makes for efficient, but potentially problematic, communication.Keeping average person in mind,On your computer, open Microsoft Word and web browser. We call these two processes.In Microsoft word, you type some thing and it gets automatically saved. Now, you would have observed editing and saving happens in parallel. This is called a thread.Both processes and threads are independent sequences of execution. The typical difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.            ProcessIs a program in execution. it has text section i.e the program code, current activity as represented by the value of program counter & content of processors register. It also includes the process stack that contains temporary data(such as function parameters, return addressed and local variables), and a data section, which contains global variables. A process may also include a heap, which is memory that is dynamically allocated during process run time.ThreadA thread is a basic unit of CPU utilisation; it comprises a thread ID, a program counter, register set, and a stack. it shared with other threads belonging to the same process its code section, data section and other operating system resources such as open files and signals.-- Taken from Operating System by GalvinTrying to answer this question relating to Java world.A process is an execution of a program but a thread is a single execution sequence within the process. A process can contain multiple threads. A thread is sometimes called a lightweight process.For example:Example 1:\nA JVM runs in a single process and threads in a JVM share the heap belonging to that process. That is why several threads may access the same object. Threads share the heap and have their own stack space. This is how one thread\xe2\x80\x99s invocation of a method and its local variables are kept thread safe from other threads. But the heap is not thread-safe and must be synchronized for thread safety.Example 2:\nA program might not be able to draw pictures by reading keystrokes. The program must give its full attention to the keyboard input and lacking the ability to handle more than one event at a time will lead to trouble. The ideal solution to this problem is the seamless execution of two or more sections of a program at the same time. Threads allows us to do this. Here Drawing picture is a process and reading keystroke is sub process (thread). Difference between Thread and Process?A process is an executing instance of an application and A thread is a path of execution within a process. Also, a process can contain multiple threads.It\xe2\x80\x99s important to note that a thread can do anything a process can do. But since a process can consist of multiple threads, a thread could be considered a \xe2\x80\x98lightweight\xe2\x80\x99 process. Thus, the essential difference between a thread and a process is the work that each one is used to accomplish. Threads are used for small tasks, whereas processes are used for more \xe2\x80\x98heavyweight\xe2\x80\x99 tasks \xe2\x80\x93 basically the execution of applications.Another difference between a thread and a process is that threads within the same process share the same address space, whereas different processes do not. This allows threads to read from and write to the same data structures and variables, and also facilitates communication between threads. Communication between processes \xe2\x80\x93 also known as IPC, or inter-process communication \xe2\x80\x93 is quite difficult and resource-intensive.Here\xe2\x80\x99s a summary of the differences between threads and processes:Threads are easier to create than processes since they \ndon\'t require a separate address space.Multithreading requires careful programming since threads \nshare data strucures that should only be modified by one thread\nat a time.  Unlike threads, processes don\'t share the same \naddress space.Threads are considered lightweight because they use far \nless resources than processes.Processes are independent of each other.  Threads, since they \nshare the same address space are interdependent, so caution \nmust be taken so that different threads don\'t step on each other.\nThis is really another way of stating #2 above.A process can consist of multiple threads.Both threads and processes are atomic units of OS resource allocation (i.e. there is a concurrency model describing how CPU time is divided between them, and the model of owning other OS resources). There is a difference in:Greg Hewgill above was correct about the Erlang meaning of the word "process", and here there\'s a discussion of why Erlang could do processes lightweight.From the point of view of an interviewer, there are basically just 3 main things that I want to hear, besides obvious things like a process can have multiple threads:If you want more, Scott Langham\'s response pretty much covers everything.\nAll these are from the perspective of an operating system. Different languages can implement different concepts, like tasks, light-wigh threads and so on, but they are just ways of using threads (of fibers on Windows).\nThere are no hardware and software threads. There are hardware and software exceptions and interrupts, or user-mode and kernel threads.The following is what I got from one of the articles on The Code Project. I guess it explains everything needed clearly.A thread is another mechanism for splitting the workload into separate\n  execution streams. A thread is lighter weight than a process. This\n  means, it offers less flexibility than a full blown process, but can\n  be initiated faster because there is less for the Operating System to\n  set up. When a program consists of two or more threads, all the\n  threads share a single memory space. Processes are given separate address spaces.\n  all the threads share a single heap. But each thread is given its own stack.Trying to answer it from Linux Kernel\'s OS ViewA program becomes a process when launched into memory. A process has its own address space meaning having various segments in memory such as .text segement for storing compiled code, .bss for storing uninitialized static or global variables, etc. Each process would have its own program counter and user-spcae stack. Inside kernel, each process would have its own kernel stack (which is separated from user space stack for security issues) and a structure named task_struct which is generally abstracted as the process control block, storing all the information regarding the process such as its priority, state,(and a whole lot of other chunk). A process can have multiple threads of execution.Coming to threads, they reside inside a process and share the address space of the parent process along with other resources which can be passed during thread creation such as filesystem resources, sharing pending signals, sharing data(variables and instructions) therefore making threads lightweight and hence allowing faster context switching. Inside kernel, each thread has its own kernel stack along with the task_struct structure which defines the thread. Therefore kernel views threads of same process as different entities and are schedulable in themselves. Threads in same process share a common id called as thread group id(tgid), also they have a unique id called as the process id (pid).Real world example for Process and Thread\nThis will give you the basic idea about thread and process\nI borrowed the above info from Scott Langham\'s Answer - thanksWhile building an algorithm in Python (interpreted language) that incorporated multi-threading I was surprised to see that execution time was not any better when compared to the sequential algorithm I had previously built. In an effort to understand the reason for this result I did some reading, and believe what I learned offers an interesting context from which to better understand the differences between multi-threading and multi-processes. Multi-core systems may exercise multiple threads of execution, and so Python should support multi-threading. But Python is not a compiled language and instead is an interpreted language1. This means that the program must be interpreted in order to run, and the interpreter is not aware of the program before it begins execution. What it does know, however, are the rules of Python and it then dynamically applies those rules. Optimizations in Python must then be principally optimizations of the interpreter itself, and not the code that is to be run. This is in contrast to compiled languages such as C++, and has consequences for multi-threading in Python. Specifically, Python uses the Global Interpreter Lock to manage multi-threading.On the other hand a compiled language is, well, compiled. The program is processed "entirely", where first it is interpreted according to its syntactical definitions, then mapped to a language agnostic intermediate representation, and finally linked into an executable code. This process allows the code to be highly optimized because it is all available at the time of compilation. The various program interactions and relationships are defined at the time the executable is created and robust decisions about optimization can be made.In modern environments Python\'s interpreter must permit multi-threading, and this must both be safe and efficient. This is where the difference between being an interpreted language versus a compiled language enters the picture. The interpreter must not to disturb internally shared data from different threads, while at the same time optimizing the use of processors for computations.As has been noted in the previous posts both a process and a thread are independent sequential executions with the primary difference being that memory is shared across multiple threads of a process, while processes isolate their  memory spaces.In Python data is protected from simultaneous access by different threads by the Global Interpreter Lock. It requires that in any Python program only one thread can be executed at any time. On the other hand it is possible to run multiple processes since the memory for each process is isolated from any other process, and processes can run on multiple cores.1 Donald Knuth has a good explanation of interpretive routines in The Art of Computer Programming: Fundamental Algorithms.Coming from the embedded world, I would like to add that the concept of processes only exists in "big" processors (desktop CPUs, ARM Cortex A-9) that have MMU (memory management unit) , and operating systems that support using MMUs (such as Linux). With small/old processors and microcontrollers and small RTOS operating system (real time operating system), such as freeRTOS, there is no MMU support and thus no processes but only threads.Threads can access each others memory, and they are scheduled by OS in an interleaved manner so they appear to run in parallel (or with multi-core they really run in parallel).Processes, on the other hand, live in their private sandbox of virtual memory, provided and guarded by MMU. This is handy because it enables: Process:A process has separate virtual address space. \nTwo processes running on the same system at the same time do not overlap each other.Every process has its own data segment as well as separate memory offset.Thread:Threads within the same process share the Memory, but each thread has its own stack and registers, and threads store thread-specific data in the heap. Threads never execute independently, so the inter-thread communication is much faster when compared to inter-process communication.Processes never share the same memory. When a child process creates it duplicates the memory location of the parent process. Process communication is done by using pipe, shared memory, and message parsing. Context switching between threads is very slow.They are almost as same... But the key difference is a thread is lightweight and a process is heavy-weight in terms of context switching, work load and so on.What is the difference between a thread and a process? is a good write-up of process vs. threads.Example 1: A JVM runs in a single process and threads in a JVM share the heap belonging to that process. That is why several threads may access the same object. Threads share the heap and have their own stack space. This is how one thread\xe2\x80\x99s invocation of a method and its local variables are kept thread safe from other threads. But the heap is not thread-safe and must be synchronized for thread safety.Process: Example: \nSay, opening any browser (mozilla, Chrome, IE). At this point new process will start to execute.Threads:Example: \nOpening multiple tabs in the browser. 