Does anybody know how to easily undo a git rebase?The only way that comes to mind is to go at it manually:In my current situation this is gonna work because I can easily spot commits from both branches (one was my stuff, the other was my colleague\'s stuff).However my approach strikes me as suboptimal and error-prone (let\'s say I had just rebased with 2 of my own branches).Any ideas?Clarification: I\'m talking about a rebase during which a bunch of commits were replayed. Not only one.The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the reflog...and to reset the current branch to it (with the usual caveats about being absolutely sure before reseting with the --hard option).Suppose the old commit was HEAD@{5} in the ref log:In Windows, you may need to quote the reference:You can check the history of the candidate old head by just doing a git log HEAD@{5} (Windows: git log "HEAD@{5}").If you\'ve not disabled per branch reflogs you should be able to simply do git reflog branchname@{1} as a rebase detaches the branch head before reattaching to the final head. I would double check this, though as I haven\'t verified this recently.Per default, all reflogs are activated for non-bare repositories:Actually, rebase saves your starting point to ORIG_HEAD so this is usually as simple as:However, the reset, rebase and merge all save your original HEAD pointer into ORIG_HEAD so, if you\'ve done any of those commands since the rebase you\'re trying to undo then you\'ll have to use the reflog.Charles\'s answer works, but you may want to do this:to clean up after the reset. Otherwise, you may get the message \xe2\x80\x9cInteractive rebase already started\xe2\x80\x9d.Resetting the branch to the dangling commit object of its old tip is of course the best solution, because it restores the previous state without expending any effort. But if you happen to have lost those commits (f.ex. because you garbage-collected your repository in the meantime, or this is a fresh clone), you can always rebase the branch again. The key to this is the --onto switch.Let\xe2\x80\x99s say you had a topic branch imaginatively called topic, that you branched off master when the tip of master was the 0deadbeef commit. At some point while on the topic branch, you did git rebase master. Now you want to undo this. Here\xe2\x80\x99s how:This will take all commits on topic that aren\xe2\x80\x99t on master and replay them on top of 0deadbeef.With --onto, you can rearrange your history into pretty much any shape whatsoever.Have fun. :-)I actually put a backup tag on the branch before I do any nontrivial operation (most rebases are trivial, but I\'d do that if it looks anywhere complex).Then, restoring is as easy as git reset --hard BACKUP.In case you haven\'t completed the rebase and in the middle of it, the following works:In case you had pushed your branch to remote repository (usually it\'s origin) and then you\'ve done a succesfull rebase (without merge) (git rebase --abort gives "No rebase in progress") you can easily reset branch using \ncommand:git reset --hard origin/{branchName}Example:For multiple commits, remember that any commit references all the history leading up to that commit. So in Charles\' answer, read "the old commit" as "the newest of the old commits". If you reset to that commit, then all the history leading up to that commit will reappear. This should do what you want.Using reflog didn\'t work for me.What worked for me was similar to as described here. Open the file in .git/logs/refs named after the branch that was rebased and find the line that contains "rebase finsihed", something like:Checkout the second commit listed on the line.Once confirmed this contained my lost changes I branched and let out a sigh of relief.Following the solution of @Allan and @Zearin, I wish I could simply do a comment though but I don\'t enough reputation, so I have used the following command:Instead of doing git rebase -i --abort  (note the -i) I had to simply do git rebase --abort (without the -i).Using both -i and --abort at the same time causes Git to show me a list of usage/options.So my previous and current branch status with this solution is:If you successfully rebased against remote branch and can not git rebase --abort you still can do some tricks to save your work and don\'t have forced pushes.\nSuppose your current branch that was rebased by mistake is called your-branch and is tracking origin/your-branchLet\'s say I rebase master to my feature branch and I get 30 new commits which break something. I\'ve found that often it\'s easiest to just remove the bad commits.Interactive rebase for the last 31 commits (it doesn\'t hurt if you pick way too many).Simply take the commits that you want to get rid of and mark them with "d" instead of "pick". Now the commits are deleted effectively undoing the rebase (if you remove only the commits you just got when rebasing).If you mess something up within a git rebase, e.g. git rebase --abort, while you have uncommited files, they will be lost and git reflog will not help. This happened to me and you will need to think outside the box here. If you are lucky like me and use IntelliJ Webstorm you can right-click->local history and can revert to a previous state of your file/folders no matter what mistakes you have done with versioning software. It is always good to have another failsafe running.In order to cancel, you may enter the following command: