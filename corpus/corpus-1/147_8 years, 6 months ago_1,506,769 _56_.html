I\'ve used the following script to see if a file exists:What\'s the correct syntax to use if I only want to check if the file does not exist?The test command ([ here) has a "not" logical operator which is the exclamation point (similar to many other languages). Try this:Bash File Testing-b filename - Block special file\n-c filename - Special character file\n-d directoryname - Check for directory Existence\n-e filename - Check for file existence, regardless of type (node, directory, socket, etc.)\n-f filename - Check for regular file existence not a directory\n-G filename - Check if file exists and is owned by effective group ID\n-G filename set-group-id - True if file exists and is set-group-id\n-k filename - Sticky bit\n-L filename - Symbolic link\n-O filename - True if file exists and is owned by the effective user id\n-r filename - Check if file is a readable\n-S filename - Check if file is socket\n-s filename - Check if file is nonzero size\n-u filename - Check if file set-user-id bit is set\n-w filename - Check if file is writable\n-x filename - Check if file is executableHow to use:A test expression can be negated by using the ! operatorYou can negate an expression with "!":The relevant man page is man test or, equivalently, man [ -- or help test or help [ for the built-in bash command.Also, it\'s possible that the file is a broken symbolic link, or a non-regular file, like e.g. a socket, device or fifo. For example, to add a check for broken symlinks:It\'s worth mentioning that if you need to execute a single command you can abbreviatetoorI prefer to do the following one-liner, in POSIX shell compatible format:For a couple of commands, like I would do in a script:Once I started doing this, I rarely use the fully typed syntax anymore!!To test file existence, the parameter can be any one of the following:All the tests below apply to regular files, directories, and symlinks:Example script:You should be careful about running test for an unquoted variable, because it might produce unexpected results:The recommendation is usually to have the tested variable surrounded by double quotation marks:There are three distinct ways to do this:Negate the exit status with bash (no other answer has said this):Or:Negate the test inside the test command [ (that is the way most answers before have presented):Or:Act on the result of the test being negative (|| instead of &&):Only:This looks silly (IMO), don\'t use it unless your code has to be portable to the Bourne shell (like the /bin/sh of Solaris 10 or earlier) that lacked the pipeline negation operator (!):To reverse a test, use "!".\nThat is equivalent to the "not" logical operator in other languages. Try this:Or written in a slightly different way:Or you could use:Or, presing all together:Which may be written (using then "and" operator: &&) as:Which looks shorter like this:The test thing may count too. It worked for me (based on Bash Shell: Check File Exists or Not):This code also working .Inthe [ command does a stat() (not lstat()) system call on the path stored in $file and returns true if that system call succeeds and the type of the file as returned by stat() is "regular".So if [ -f "$file" ] returns true, you can tell the file does exist and is a regular file or a symlink eventually resolving to a regular file (or at least it was at the time of the stat()).However if it returns false (or if [ ! -f "$file" ] or ! [ -f "$file" ] return true), there are many different possibilities:In short, it should be:To know for sure that the file doesn\'t exist, we\'d need the stat() system call to return with an error code of ENOENT (ENOTDIR tells us one of the path components is not a directory is another case where we can tell the file doesn\'t exist by that path). Unfortunately the [ command doesn\'t let us know that. It will return false whether  the error code is ENOENT, EACCESS (permission denied), ENAMETOOLONG or anything else.The [ -e "$file" ] test can also be done with ls -Ld -- "$file" > /dev/null. In that case, ls will tell you why the stat() failed, though the information can\'t easily be used programmatically:At least ls tells me it\'s not because the file doesn\'t exist that it fails. It\'s because it can\'t tell whether the file exists or not. The [ command just ignored the problem.With the zsh shell, you can query the error code with the $ERRNO special variable after the failing [ command, and decode that number using the $errnos special array in the zsh/system module:(beware the $errnos support is broken with some versions of zsh when built with recent versions of gcc).You can use Bash specific:orIn this case you won\'t need to quote $FILE to prevent word splitting.If you want to check for file and folder both, then use -e option instead of -f.The simplest way This shell script also works for finding a file in a directory:sometimes it may be handy to use && and || operators.Like in (if you have command "test"):or 