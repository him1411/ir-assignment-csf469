What is the difference between a wait() and sleep() in Threads?Is my understanding that a wait()-ing Thread is still in running mode and uses CPU cycles but a sleep()-ing does not consume any CPU cycles correct?Why do we have both wait() and sleep(): how does their implementation vary at a lower level?A wait can be "woken up" by another thread calling notify on the monitor which is being waited on whereas a sleep cannot. Also a wait (and notify) must happen in a block synchronized on the monitor object whereas sleep does not:At this point the currently executing thread waits and releases the monitor. Another thread may do(On the same mon object) and the first thread (assuming it is the only thread waiting on the monitor) will wake up. You can also call notifyAll if more than one thread is waiting on the monitor - this will wake all of them up. However, only one of the threads will be able to grab the monitor (remember that the wait is in a synchronized block) and carry on - the others will then be blocked until they can acquire the monitor\'s lock.Another point is that you call wait on Object itself (i.e. you wait on an object\'s monitor) whereas you call sleep on Thread.Yet another point is that you can get spurious wakeups from wait (i.e. the thread which is waiting resumes for no apparent reason). You should always wait whilst spinning on some condition as follows:  One key difference not yet mentioned is that while sleeping a Thread does not release the locks it holds, while waiting releases the lock on the object that wait() is called on.I found this link helpful (which references this post). It puts the difference between sleep(), wait(), and yield() in human terms. (in case the links ever go dead I\'ve included the post below with additional markup)It all eventually makes its way down to the OS\xe2\x80\x99s scheduler, which\n  hands out timeslices to processes and threads.sleep(n) says \xe2\x80\x9cI\xe2\x80\x99m done with my timeslice, and please don\xe2\x80\x99t give me\n  another one for at least n milliseconds.\xe2\x80\x9d The OS doesn\xe2\x80\x99t even try to\n  schedule the sleeping thread until requested time has passed.yield() says \xe2\x80\x9cI\xe2\x80\x99m done with my timeslice, but I still have work to\n  do.\xe2\x80\x9d The OS is free to immediately give the thread another timeslice,\n  or to give some other thread or process the CPU the yielding thread\n  just gave up..wait() says \xe2\x80\x9cI\xe2\x80\x99m done with my timeslice. Don\xe2\x80\x99t give me another\n  timeslice until someone calls notify().\xe2\x80\x9d As with sleep(), the OS won\xe2\x80\x99t\n  even try to schedule your task unless someone calls notify() (or one of\n  a few other wakeup scenarios occurs).Threads also lose the remainder of their timeslice when they perform\n  blocking IO and under a few other circumstances. If a thread works\n  through the entire timeslice, the OS forcibly takes control roughly as\n  if yield() had been called, so that other processes can run.You rarely need yield(), but if you have a compute-heavy app with\n  logical task boundaries, inserting a yield() might improve system\n  responsiveness (at the expense of time \xe2\x80\x94 context switches, even just\n  to the OS and back, aren\xe2\x80\x99t free). Measure and test against goals you\n  care about, as always.There are a lot of answers here but I couldn\'t find the semantic distinction mentioned on any.It\'s not about the thread itself; both methods are required as they support very different use-cases.sleep() sends the Thread to sleep as it was before, it just packs the context and stops executing for a predefined time. So in order to wake it up before the due time, you need to know the Thread reference. This is not a common situation in a multi-threaded environment. It\'s mostly used for time-synchronization (e.g. wake in exactly 3.5 seconds) and/or hard-coded fairness (just sleep for a while and let others threads work).wait(), on the contrary, is a thread (or message) synchronization mechanism that allows you to notify a Thread of which you have no stored reference (nor care). You can think of it as a publish-subscribe pattern (wait == subscribe and notify() == publish). Basically using notify() you are sending a message (that might even not be received at all and normally you don\'t care).To sum up, you normally use sleep() for time-syncronization and wait() for multi-thread-synchronization.They could be implemented in the same manner in the underlying OS, or not at all (as previous versions of Java had no real multithreading; probably some small VMs doesn\'t do that either). Don\'t forget Java runs on a VM, so your code will be transformed in something different according to the VM/OS/HW it runs on.There are some difference key notes i conclude after working on wait and sleep, first take a look on sample using wait() and sleep():Example1: using wait() and sleep():Let clarity some key notes:you normally use sleep() for time-syncronization and wait() for\n  multi-thread-synchronization.Please correct me if i\'m wrong.Here are few important differences between wait() and sleep() methods.wait() method needs to be called from a loop in order to deal with false alarm.wait() method must be called from synchronized context (i.e.  synchronized method or block), otherwise  it will throw IllegalMonitorStateExceptionRef: Difference between Wait and SleepCode snippet for calling wait and sleep methodDifference between wait() and sleep()The fundamental difference is wait() is from Object and sleep() is static method of Thread.The major difference is that wait() releases the lock while sleep() doesn\xe2\x80\x99t releas any lock while waiting. The wait() is used for inter-thread communication while sleep() is used to introduce pause on execution, generally.The wait() should call from inside synchronise or else we get IllegalMonitorStateException  while sleep()  can call anywhere.Similarities which helps understand This is a very simple question, because both these methods have a totally different use. The major difference is to wait to release the lock or monitor while sleep doesn\'t release any lock or monitor while waiting. Wait is used for inter-thread communication while sleep is used to introduce pause on execution. This was just a clear and basic explanation, if you want more than that then continue reading.In case of wait() method thread goes in waiting state and it won\'t come back automatically until we call the notify() method (or notifyAll() if you have more then one thread in waiting state and you want to wake all of those thread). And you need synchronized or object lock or class lock to access the wait() or notify() or notifyAll() methods. And one more thing, the wait() method is used for inter-thread communication because if a thread goes in waiting state you\'ll need another thread to wake that thread.But in case of sleep() this is a method which is used to hold the process for few seconds or the time you wanted. Because you don\'t need to provoke any notify() or notifyAll() method to get that thread back. Or you don\'t need any other thread to call back that thread. Like if you want something should happen after few seconds like in a game after user\'s turn you want the user to wait until the computer plays then you can mention the sleep() method.And one more important difference which is asked often in interviews: sleep() belongs to Thread class and wait() belongs to Object class.These are all the differences between sleep() and wait().And there is a similarity between both methods: they both are checked statement so you need try catch or throws to access these methods.I hope this will help you.source : http://www.jguru.com/faq/view.jsp?EID=47127Thread.sleep() sends the current thread into the "Not Runnable" state\n  for some amount of time. The thread keeps the monitors it has aquired\n  -- i.e. if the thread is currently in a synchronized block or method no other thread can enter this block or method. If another thread calls t.interrupt() it will wake up the sleeping thread.Note that sleep is a static method, which means that it always affects\n  the current thread (the one that is executing the sleep method). A\n  common mistake is to call t.sleep() where t is a different thread;\n  even then, it is the current thread that will sleep, not the t thread.t.suspend() is deprecated. Using it is possible to halt a thread other\n  than the current thread. A suspended thread keeps all its monitors and\n  since this state is not interruptable it is deadlock prone.object.wait() sends the current thread into the "Not Runnable" state,\n  like sleep(), but with a twist. Wait is called on an object, not a\n  thread; we call this object the "lock object." Before lock.wait() is\n  called, the current thread must synchronize on the lock object; wait()\n  then releases this lock, and adds the thread to the "wait list"\n  associated with the lock. Later, another thread can synchronize on the\n  same lock object and call lock.notify(). This wakes up the original,\n  waiting thread. Basically, wait()/notify() is like\n  sleep()/interrupt(), only the active thread does not need a direct\n  pointer to the sleeping thread, but only to the shared lock object.Wait and sleep are two different things: sleep is a method of Thread, wait is a method of Object, so wait/notify is a technique of synchronizing shared data in Java (using monitor), but sleep is a simple method of thread to pause itself.sleep() is a method which is used to hold the process for few seconds or the time you wanted but in case of wait() method thread goes in waiting state and it won\xe2\x80\x99t come back automatically until we call the notify() or notifyAll().The major difference is that wait() releases the lock or monitor while sleep() doesn\xe2\x80\x99t releases any lock or monitor while waiting. Wait is used for inter-thread communication while sleep is used to introduce pause on execution, generally.Thread.sleep() sends the current thread into the \xe2\x80\x9cNot Runnable\xe2\x80\x9d state for some amount of time. The thread keeps the monitors it has acquired \xe2\x80\x94 i.e. if the thread is currently in a synchronized block or method no other thread can enter this block or method. If another thread calls t.interrupt() it will wake up the sleeping thread. Note that sleep is a static method, which means that it always affects the current thread (the one that is executing the sleep method). A common mistake is to call t.sleep() where t is a different thread; even then, it is the current thread that will sleep, not the t thread.object.wait() sends the current thread into the \xe2\x80\x9cNot Runnable\xe2\x80\x9d state, like sleep(), but with a twist. Wait is called on an object, not a thread; we call this object the \xe2\x80\x9clock object.\xe2\x80\x9d Before lock.wait() is called, the current thread must synchronize on the lock object; wait() then releases this lock, and adds the thread to the \xe2\x80\x9cwait list\xe2\x80\x9d associated with the lock. Later, another thread can synchronize on the same lock object and call lock.notify(). This wakes up the original, waiting thread. Basically, wait()/notify() is like sleep()/interrupt(), only the active thread does not need a direct pointer to the sleeping thread, but only to the shared lock object.Let categorize all above points :Call on:Synchronized:Hold lock:Wake-up condition:Usage:Ref:diff sleep and waitwait and sleep methods are very different:Come to think about it, the names are confusing in that respect; however sleep is a standard name and wait is like the WaitForSingleObject or WaitForMultipleObjects in the Win API.In simple words, wait is wait Until some other thread invokes you whereas sleep is "dont execute next statement" for some specified period of time.Moreover sleep is static method in Thread class and it operates on thread, whereas wait() is in Object class and called on an object.Another point, when you call wait on some object, the thread involved synchronize the object and then waits. :)From this post : http://javaconceptoftheday.com/difference-between-wait-and-sleep-methods-in-java/1) The thread which calls wait() method releases the lock it holds.2) The thread regains the lock after other threads call either notify() or notifyAll() methods on the same lock.3) wait() method must be called within the synchronized block.4) wait() method is always called on objects.5) Waiting threads can be woken up by other threads by calling notify() or notifyAll() methods.6) To call wait() method, thread must have object lock.1) The thread which calls sleep() method doesn\xe2\x80\x99t release the lock it holds.2) sleep() method can be called within or outside the synchronized block.3) sleep() method is always called on threads.4) Sleeping threads can not be woken up by other threads. If done so, thread will throw InterruptedException.5) To call sleep() method, thread need not to have object lock.sleepWaitwait() is a method of Object class.\nsleep() is a method of Thread class.sleep() allows the thread to go to sleep state for x milliseconds. \nWhen a thread goes into sleep state it doesn\xe2\x80\x99t release the lock. wait() allows thread to release the lock and goes to suspended state. \nThis thread will be active when a notify() or notifAll() method is \ncalled  for the same object.One potential big difference between sleep/interrupt and wait/notify is thatGenerating an exception when not needed is inefficient.  If you have threads communicating with each other at a high rate, then it would be generating a lot of exceptions if you were calling interrupt all the time, which is a total waste of CPU.You are correct - Sleep() causes that thread to "sleep" and the CPU will go off and process other threads (otherwise known as context switching) wheras I believe Wait keeps the CPU processing the current thread.We have both because although it may seem sensible to let other people use the CPU while you\'re not using it, actualy there is an overhead to context switching - depending on how long the sleep is for, it can be more expensive in CPU cycles to switch threads than it is to simply have your thread doing nothing for a few ms.Also note that sleep forces a context switch.  Also - in general it\'s not possible to control context switching - during the Wait the OS may (and will for longer waits) choose to process other threads.The methods are used for different things.Thread.sleep(n) can be interrupted, but Object.wait() must be notified.\nIt\'s possible to specify the maximum time to wait: Object.wait(5000) so it would be possible to use wait to, er, sleep but then you have to bother with locks.Neither of the methods uses the cpu while sleeping/waiting. The methods are implemented using native code, using similar constructs but not in the same way.Look for yourself: Is the source code of native methods available? The file /src/share/vm/prims/jvm.cpp is the starting point...Here wait() will be in the waiting state till it notify by another Thread but where as sleep() will be having some time..after that it will automatically transfer to the Ready state...Wait() and sleep() Differences?Thread.sleep()\n     Once its work completed then only its release the lock to everyone. until its never release the lock to anyone.Object.wait()\n    When  its going to waiting stage, its will be release the key and its waiting for some of the seconds based on the parameter. For Example:you are take the coffee in yours right hand, you can take another anyone of the same hand, when will your put down then only take another object same type here. also. this is sleep()\n you sleep time you didn\'t any work, you are doing only sleeping.. same here also.wait(). when you are put down and take another one mean while you are waiting , that\'s waityou are play movie or anything in yours system same as player you can\'t play more than one at a time right, thats its here, when you close and choose another anyone movie or song mean while is called waitIn my opinion, the main difference between both mechanisms is that sleep/interrupt is the most basic way of handling threads, whereas wait/notify is an abstraction aimed to do thread inter-communication easier. This means that sleep/interrupt can do anything, but that this specific task is harder to do.Why is wait/notify more suitable? Here are some personal considerations:It enforces centralization. It allows to coordinate the communication between a group of threads with a single shared object. This simplifies the work a lot.It enforces synchronization. Because it makes the programmer wrap the call to wait/notify in a synchronized block.It\'s independent of the thread origin and number. With this approach you can add more threads arbitrarily without editing the other threads or keeping a track of the existing ones. If you used sleep/interrupt, first you would need to keep the references to the sleeping threads, and then interrupt them one by one, by hand.An example from the real life that is good to explain this is a classic restaurant and the method that the personnel use to communicate among them: The waiters leave the customer requests in a central place (a cork board, a table, etc.), ring a bell, and the workers from the kitchen come to take such requests. Once that there is any course ready, the kitchen personnel ring the bell again so that the waiters are aware and take them to the customers.Example about sleep doesn\xe2\x80\x99t release lock and wait doesHere there are two classes :Singleton : This is singleton class with two static methods getInstance() and getInstance(boolean isWait).andNow run this example you will get below output :Here Singleton instances created by threadA and threadB are same. It means threadB is waiting outside until threadA release it\xe2\x80\x99s lock.Now change the Singleton.java by commenting Thread.sleep(500); method and uncommenting Singleton.class.wait(500); . Here because of Singleton.class.wait(500); method threadA will release all acquire locks and moves into the \xe2\x80\x9cNon Runnable\xe2\x80\x9d state, threadB will get change to enter in synchronized block.Now run again :Here Singleton instances created by threadA and threadB are NOT same because of threadB got change to enter in synchronised block and after 500 milliseconds threadA started from it\xe2\x80\x99s last position and created one more Singleton object.Should be called from synchronized block : wait() method is always called from synchronized block i.e. wait() method needs to lock object monitor before object on which it is called.  But sleep() method can be called from outside synchronized block i.e. sleep() method doesn\xe2\x80\x99t need any object monitor.IllegalMonitorStateException : if wait() method is called without acquiring object lock than IllegalMonitorStateException is thrown at runtime, but sleep() method never throws such exception.Belongs to which class : wait() method belongs to java.lang.Object class but sleep() method belongs to java.lang.Thread class.Called on object or thread : wait() method is called on objects but sleep() method is called on Threads not objects.Thread state : when wait() method is called on object, thread that holded object\xe2\x80\x99s monitor goes from running to waiting state and can return to runnable state only when notify() or notifyAll() method is called on that object. And later thread scheduler schedules that thread to go from from runnable to running state. \nwhen sleep() is called on thread it goes from running to waiting state and can return to runnable state when sleep time is up.When called from synchronized block : when wait() method is called thread leaves the object lock.  But sleep() method when called from synchronized block or method thread doesn\xe2\x80\x99t leaves object lock.For More ReferenceFrom oracle documentation page on wait() method of Object:This method throwsIllegalMonitorStateException - if the current thread is not the owner of the object\'s monitor.InterruptedException - if any thread interrupted the current thread before or while the current thread was waiting for a notification. The interrupted status of the current thread is cleared when this exception is thrown.From oracle documentation page on sleep() method of Thread class:This method throws:IllegalArgumentException - if the value of millis is negativeInterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.Other key difference:wait() is a non-static method (instance method) unlike static method sleep() (class method). wait releases the lock and sleep doesn\'t. A thread in waiting state is eligible for waking up as soon as notify or notifyAll is called. But in case of sleep the thread keeps the lock and it\'ll only be eligible once the sleep time is over.Lets assume you are hearing songs.As long as the current song is running, the next song wont play, i.e Sleep() called by next songIf you finish the song it will stop and until you select play button(notify()) it wont play, i.e wait() called by current song.In this both cases songs going to Wait states.wait() is given inside a synchronized method \nwhereas sleep() is given inside a non-synchronized method because wait() method release the lock on the object but sleep() or yield() does release the lock().sleep() method causes the current thread to move from running state to block state for a specified time. If the current thread has the lock of any object then it keeps holding it, which means that other threads cannot execute any synchronized method in that class object.wait() method causes the current thread to go into block state either for a specified time or until notify, but in this case the thread releases the lock of the object (which means that other threads can execute any synchronized methods of the calling object.