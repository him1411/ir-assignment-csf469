When removing an element with standard JavaScript, you must go to its parent first:Having to go to the parent node first seems a bit odd to me, is there a reason JavaScript works like this?I know that augmenting native DOM functions isn\'t always the best or most popular solution, but this works fine for modern browsers.And then you can remove elements like this  orNote: this solution doesn\'t work for IE 7 and below. For more info about extending the DOM read this article.Crossbrowser:You could make a remove function so that you wouldn\'t have to think about it every time:It\'s what the DOM supports. Search that page for "remove" or "delete" and removeChild is the only one that removes a node.The DOM is organized in a tree of nodes, where each node has a value, along with a list of references to its child nodes. So element.parentNode.removeChild(element) mimics exactly what is happening internally: First you go the the parent node, then remove the reference to the child node.As of DOM4, a helper function is provided to do the same thing: element.remove(). This works in 87% of browsers (as of 2016), but not IE 11. If you need to support older browsers, you can:For removing one element:For removing all the elements with for example a certain class name:you can just use element.remove()Functions that use ele.parentNode.removeChild(ele) won\'t work for elements you\'ve created but not yet inserted into the HTML.  Libraries like jQuery and Prototype wisely use a method like the following to evade that limitation.I think JavaScript works like that because the DOM\'s original designers held parent/child and previous/next navigation as a higher priority than the DHTML modifications that are so popular today.  Being able to read from one <input type=\'text\'> and write to another by relative location in the DOM was useful in the mid 90s, a time when the dynamic generation of entire HTML forms or interactive GUI elements was barely a twinkle in some developer\'s eye.The ChildNode.remove() method removes the object from the tree it belongs to.https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/removeHere is a fiddle that shows how you can call document.getElementById(\'my-id\').remove()https://jsfiddle.net/52kp584L/There is no need to extend NodeList. It has been implemented already.From what I understand, removing a node directly does not work in Firefox, only Internet Explorer. So, to support Firefox, you have to go up to the parent to remove it\'s child.Ref: http://chiragrdarji.wordpress.com/2007/03/16/removedelete-element-from-page-using-javascript-working-in-firefoxieopera/According to DOM level 4 specs, which is the current version in development, there are some new handy mutation methods available: append(), prepend(), before(), after(), replace(), and remove().http://red-team-design.com/removing-an-element-with-plain-javascript-remove-method/Having to go to the parent node first seems a bit odd to me, is there\n  a reason JavaScript works like this?IMHO: The reason for this is the same as I\'ve seen in other environments: You are performing an action based on your "link" to something. You can\'t delete it while you\'re linked to it.Like cutting a tree limb. Sit on the side closest to the tree while cutting or the result will be ... unfortunate (although funny).This one actually comes from FireFox... for once, IE was ahead of  the pack and allowed the removal of an element directly.This is just my assumption, but I believe the reason that you must remove a child through the parent is due to an issue with the way FireFox handled the reference.If you call an object to commit hari-kari directly, then immediately after it dies, you are still holding that reference to it.  This has the potential to create several nasty bugs... such as failing to remove it, removing it but keeping references to it that appear valid, or simply a memory leak.I believe that when they realized the issue, the work around was to remove an element through its parent because when the element is gone, you are now simply holding a reference to the parent.  This would stop all that unpleasantness, and (if closing down a tree node by node, for example) would \'zip-up\' rather nicely.It should be an easily fixable bug, but as with many other things in web programming, the release was probably rushed, leading to this... and by the time the next version came around, enough people were using it that changing this would lead to breaking a bunch of code.Again, all of this is simply my guesswork.I do, however, look forward to the day when web programming finally gets a full spring cleaning, all these strange little idiosynchracies get cleaned up, and everyone starts playing by the same rules.Probably the day after my robot servant sues me for back wages.This is the best function to remove an element without script error:Note to EObj=document.getElementById(EId).This is ONE equal sign not ==.if element EId exists then the function removes it, otherwise it returns false, not error.You may want to try the following code:Please refer to http://api.jquery.com/remove/ for details.