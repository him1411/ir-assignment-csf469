How can an int be cast to an enum in C#?From a string:From an int:Update:From number you can alsoJust cast it:You can check if it\'s in range using Enum.IsDefined:Alternatively, use an extension method instead of a one-liner:Usage:ORI think to get a complete answer, people have to know how enums work internally in .NET. How stuff worksAn enum in .NET is a structure that maps a set of values (fields) to a basic type (the default is int). However, you can actually choose the integral type that your enum maps to:In this case the enum is mapped to the short data type, which means it will be stored in memory as a short and will behave as a short when you cast and use it. If you look at it from a IL point of view, a (normal, int) enum looks like this:What should get your attention here is that the value__ is stored separately from the enum values. In the case of the enum Foo above, the type of value__ is int16. This basically means that you can store whatever you want in an enum, as long as the types match.At this point I\'d like to point out that System.Enum is a value type, which basically means that BarFlag will take up 4 bytes in memory and Foo will take up 2 -- e.g. the size of the underlying type (it\'s actually more complicated than that, but hey...).The answerSo, if you have an integer that you want to map to an enum, the runtime only has to do 2 things: copy the 4 bytes and name it something else (the name of the enum). Copying is implicit because the data is stored as value type - this basically means that if you use unmanaged code, you can simply interchange enums and integers without copying data.To make it safe, I think it\'s a best practice to know that the underlying types are the same or implicitly convertible and to ensure the enum values exist (they aren\'t checked by default!).To see how this works, try the following code:Note that casting to e2 also works! From the compiler perspective above this makes sense: the value__ field is simply filled with either 5 or 6 and when Console.WriteLine calls ToString(), the name of e1 is resolved while the name of e2 is not.If that\'s not what you intended, use Enum.IsDefined(typeof(MyEnum), 6) to check if the value you are casting maps to a defined enum.Also note that I\'m explicit about the underlying type of the enum, even though the compiler actually checks this. I\'m doing this to ensure I don\'t run into any surprises down the road. To see these surprises in action, you can use the following code (actually I\'ve seen this happen a lot in database code):Take the following example:I am using this piece of code to cast int to my enum:I find it the best solution.Below is a nice utility class for EnumsFor numeric values, this is safer as it will return an object no matter what:If you\'re ready for the 4.0 .NET Framework, there\'s a new Enum.TryParse() function that\'s very useful and plays well with the [Flags] attribute. See Enum.TryParse Method (String, TEnum%)If you have an integer that acts as a bitmask and could represent one or more values in a [Flags] enumeration, you can use this code to parse the individual flag values into a list:Sometimes you have an object to the MyEnum type. LikeThen:To convert a string to ENUM or int to ENUM constant we need to use Enum.Parse function. Here is a youtube video https://www.youtube.com/watch?v=4nhx4VwdRDk  which actually demonstrate\'s with string and the same applies for int.The code goes as shown below where "red" is the string and "MyColors" is the color ENUM which has the color constants.Slightly getting away from the original question, but I found an answer to StackÂ Overflow question Get int value from enum useful. Create a static class with public const int properties, allowing you to easily collect together a bunch of related int constants, and then not have to cast them to int when using them.Obviously, some of the enum type functionality will be lost, but for storing a bunch of database id constants, it seems like a pretty tidy solution.This parses integers or strings to a target enum with partial matching in dot.NET 4.0 using generics like in Tawani\'s utility class above.  I am using it to convert command-line switch variables which may be incomplete.  Since an enum cannot be null, you should logically provide a default value.  It can be called like this:Here\'s the code:FYI:  The question was about integers, which nobody mentioned will also explicitly convert in Enum.TryParse()From a string: (Enum.Parse is out of Date, use Enum.TryParse) This is an flags enumeration aware safe convert method:In my case, I needed to return the enum from a WCF service.  I also needed a friendly name, not just the enum.ToString().Here\'s my WCF Class.Here\'s the Extension method that gets the Description from the Enum.Implementation:Different ways to cast to and from EnumI don\'t know anymore where I get the part of this enum extension, but it is from stackoverflow. I am sorry for this! But I took this one and modified it for enums with Flags. \nFor enums with Flags I did this:Example:  Following is slightly better extension method It can help you to convert any input data to user desired enum. Suppose you have an enum like below which by default int. Please add a Default value at first of your enum. Which is used at helpers medthod when there is no match found with input value.N.B: Here I try to parse value into int, because enum is by default int\nIf you define enum like this which is byte type.You need to change parsing at helper method from tobyte.TryParse(value.ToString(), out  tempType) I check my method for following inputssorry for my english