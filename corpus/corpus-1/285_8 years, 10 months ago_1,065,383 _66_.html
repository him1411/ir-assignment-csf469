Can I convert a string representing a boolean value (e.g., \'true\', \'false\') into a intrinsic type in JavaScript?I have a hidden form in HTML that is updated based upon a user\'s selection within a list. This form contains some fields which represent boolean values and are dynamically populated with an intrinsic boolean value. However, once this value is placed into the hidden input field it becomes a string.The only way I could find to determine the field\'s boolean value, once it was converted into a string, was to depend upon the literal value of its string representation.Is there a better way to accomplish this?You could make it stricter by using the identity operator (===), which doesn\'t make any implicit type conversions when the compared variables have different types, instead of the equality operator (==), which does:You should probably be cautious about using these two methods for your specific needs:Any string which isn\'t the empty string will evaluate to true by using them. Although they\'re the cleanest methods I can think of concerning to boolean conversion, I think they\'re not what you\'re looking for.How about?or with jQueryFor those (see the comments) that would like to extend the String object to get this but are worried about enumerability and are worried about clashing with other code that extends the String object:(Won\'t work in older browsers of course and Firefox shows false while Opera, Chrome, Safari and IE show true. Bug 720760)    Remember to match case:Also, if it\'s a form element checkbox, you can also detect if the checkbox is checked:Assuming that if it is checked, it is "set" equal to true. This evaluates as true/false.I think this is much universal:if (String(a) == "true") ...It goes:Wood-eye be careful. \nAfter seeing the consequences after applying the the top answer with 500+ upvotes, I feel obligated to post something that is actually useful:Let\'s start with the shortest, but very strict way:And end with a proper, more tolerant way:Testing:Your solution is fine.Using === would just be silly in this case, as the field\'s value will always be a String.Universal solution with JSON parse:UPDATE (without JSON):I also created fiddle to test it http://jsfiddle.net/remunda/2GRhG/I thought that @Steven \'s answer was the best one, and took care of a lot more cases than if the incoming value was just a string. I wanted to extend it a bit and offer the following:It\'s not necessary to cover all the false cases if you already know all of the true cases you\'d have to account for. You can pass anything into this method that could pass for a true value (or add others, it\'s pretty straightforward), and everything else would be considered falseThis returns false for every falsy value and true for every truthy value except for \'false\', \'f\', \'no\', \'n\', and \'0\' (case-insensitive).The Boolean object doesn\'t have a \'parse\' method. Boolean(\'false\') returns true, so that won\'t work. !!\'false\' also returns true, so that won\'t work also.If you want string \'true\' to return boolean true and string \'false\' to return boolean false, then the simplest solution is to use eval(). eval(\'true\') returns true and eval(\'false\') returns false. Keep in mind the performance implications when using eval() though.I use the following:This function performs the usual Boolean coercion with the exception of the strings "false" (case insensitive) and "0".The expression you\'re looking for simply isas inThis tests myValue against a regular expression , case-insensitive, and doesn\'t modify the prototype.Examples:There are a lot of answers and it\'s hard to pick one. In my case, I prioritise the performance when choosing, so I create this jsPerf that I hope can throw some light here.Brief of results (the higher the better):They are linked to the related answer where you can find more information (pros and cons) about each one; specially in the comments.There are already so many answers available. But following can be useful in some scenarios.This can be useful where one examples with non-boolean values.Hands down the easiest way (assuming you string will be \'true\' or \'false\') is:Always use the === operator instead of the == operator for these types of conversions!Like @Shadow2531 said, you can\'t just convert it directly. I\'d also suggest that you consider string inputs besides "true" and "false" that are \'truthy\' and \'falsey\' if your code is going to be reused/used by others. This is what I use:To convert both string("true", "false") and boolean to booleanWhere flag can be I\'m using this oneYou need to separate (in your thinking) the value of your selections and the representation of that value. Pick a point in the JavaScript logic where they need to transition from string sentinels to native type and do a comparison there, preferably where it only gets done once for each value that needs to be converted. Remember to address what needs to happen if the string sentinel is not one the script knows (i.e. do you default to true or to false?)In other words, yes, you need to depend on the string\'s value. :-)My take on this question is that it aims to satisfy three objectives:The problem with using JSON is that it fails by causing a Javascript error. This solution is not resilient (though it satisfies 1 and 3):This solution is not concise enough:I am working on solving this exact problem for Typecast.js. And the best solution to all three objectives is this one:It works for many cases, does not fail when values like {} are passed in, and is very concise. Also it returns false as the default value rather than undefined or throwing an Error, which is more useful in loosely-typed Javascript development. Bravo to the other answers that suggested it!I\'m a little late, but I have a little snippet to do this, it essentially maintains all of JScripts truthey/falsey/filthy-ness but includes "false" as an acceptible value for false.I prefer this method to the ones mentioned because it doesn\'t rely on a 3rd party to parse the code (i.e: eval/JSON.parse), which is overkill in my mind, it\'s short enough to not require a utility function and maintains other truthey/falsey conventions.another solution.  jsFiddletest cases run in nodeI wrote a function to match PHP\'s filter_var which does this nicely. Available in a gist: https://gist.github.com/CMCDragonkai/7389368this has been taken from the accepted answer, but really it has very weak point, and I am shocked how it got that count of upvotes, the problem with it that you have to consider the case of the string, because this is case senstiveIf you are not sure of the input, the above works for boolean and as well any string.I\'ve found that using \'1\' and an empty value \'\' for boolean values works far more predictably than \'true\' or \'false\' string values... specifically with html forms since uninitialized/empty values in Dom elements will consistently evaluate to false whereas any value within them evaluates to true. For instance:Just seemed like an easier road, so far it\'s been very consistent/easy... perhaps someone can determine a way to break this?