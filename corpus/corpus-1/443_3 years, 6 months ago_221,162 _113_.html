I\'m coming from a Java background and have started working with objects in C++. But one thing that occurred to me is that people often use pointers to objects rather than the objects themselves, for example this declaration:rather than:Or instead of using a function, let\'s say testFunc(), like this:we have to write:But I can\'t figure out why should we do it this way. I would assume it has to do with efficiency and speed since we get direct access to the memory address. Am I right?It\'s very unfortunate that you see dynamic allocation so often. That just shows how many bad C++ programmers there are.In a sense, you have two questions bundled up into one. The first is when should we use dynamic allocation (using new)? The second is when should we use pointers?The important take-home message is that you should always use the appropriate tool for the job. In almost all situations, there is something more appropriate and safer than performing manual dynamic allocation and/or using raw pointers.In your question, you\'ve demonstrated two ways of creating an object. The main difference is the storage duration of the object. When doing Object myObject; within a block, the object is created with automatic storage duration, which means it will be destroyed automatically when it goes out of scope. When you do new Object(), the object has dynamic storage duration, which means it stays alive until you explicitly delete it. You should only use dynamic storage duration when you need it. \nThat is, you should always prefer creating objects with automatic storage duration when you can.The main two situations in which you might require dynamic allocation:When you do absolutely require dynamic allocation, you should encapsulate it in a smart pointer or some other type that performs RAII (like the standard containers). Smart pointers provide ownership semantics of dynamically allocated objects. Take a look at std::unique_ptr and std::shared_ptr, for example. If you use them appropriately, you can almost entirely avoid performing your own memory management (see the Rule of Zero).However, there are other more general uses for raw pointers beyond dynamic allocation, but most have alternatives that you should prefer. As before, always prefer the alternatives unless you really need pointers.You need reference semantics. Sometimes you want to pass an object using a pointer (regardless of how it was allocated) because you want the function to which you\'re passing it to have access that that specific object (not a copy of it). However, in most situations, you should prefer reference types to pointers, because this is specifically what they\'re designed for. Note this is not necessarily about extending the lifetime of the object beyond the current scope, as in situation 1 above. As before, if you\'re okay with passing a copy of the object, you don\'t need reference semantics.You need polymorphism. You can only call functions polymorphically (that is, according to the dynamic type of an object) through a pointer or reference to the object. If that\'s the behaviour you need, then you need to use pointers or references. Again, references should be preferred.You want to represent that an object is optional by allowing a nullptr to be passed when the object is being omitted. If it\'s an argument, you should prefer to use default arguments or function overloads. Otherwise, you should prefer use a type that encapsulates this behaviour, such as std::optional (introduced in C++17 - with earlier C++ standards, use boost::optional).You want to decouple compilation units to improve compilation time. The useful property of a pointer is that you only require a forward declaration of the pointed-to type (to actually use the object, you\'ll need a definition). This allows you to decouple parts of your compilation process, which may significantly improve compilation time. See the Pimpl idiom.You need to interface with a C library or a C-style library. At this point, you\'re forced to use raw pointers. The best thing you can do is make sure you only let your raw pointers loose at the last possible moment. You can get a raw pointer from a smart pointer, for example, by using its get member function. If a library performs some allocation for you which it expects you to deallocate via a handle, you can often wrap the handle up in a smart pointer with a custom deleter that will deallocate the object appropriately.There are many use cases for pointers. Polymorphic behavior. For polymorphic types, pointers (or references) are used to avoid slicing:Reference semantics and avoiding copying. For non-polymorphic types, a pointer (or a reference) will avoid copying a potentially expensive objectNote that C++11 has move semantics that can avoid many copies of expensive objects into function argument and as return values. But using a pointer will definitely avoid those and will allow multiple pointers on the same object (whereas an object can only be moved from once).Resource acquisition. Creating a pointer to a resource using the new operator is an anti-pattern in modern C++. Use a special resource class (one of the Standard containers) or a smart pointer (std::unique_ptr<> or std::shared_ptr<>). Consider:   vs. A raw pointer should only be used as a "view" and not in any way involved in ownership, be it through direct creation or implicitly through return values. See also this Q&A from the C++ FAQ.More fine-grained life-time control Every time a shared pointer is being copied (e.g. as a function argument) the resource it points to is being kept alive. Regular objects (not created by new, either directly by you or inside a resource class) are destroyed when going out of scope.There are many excellent answers to this question, including the important use cases of forward declarations, polymorphism etc. but I feel a part of the "soul" of your question is not answered - namely what the different syntaxes mean across Java and C++.Let\'s examine the situation comparing the two languages:The closest equivalent to this, is:Let\'s see the alternative C++ way:The best way to think of it is that -- more or less -- Java (implicitly) handles pointers to objects, while C++ may handle either pointers to objects, or the objects themselves.\nThere are exceptions to this -- for example, if you declare Java "primitive" types, they are actual values that are copied, and not pointers.\nSo,That said, using pointers is NOT necessarily either the correct or the wrong way to handle things; however other answers have covered that satisfactorily. The general idea though is that in C++ you have much more control on the lifetime of the objects, and on where they will live.Take home point -- the Object * object = new Object() construct is actually what is closest to typical Java (or C# for that matter) semantics.Another good reason to use pointers would be for forward declarations. In a large enough project they can really speed up compile time. Java is nothing like C++, contrary to hype. The Java hype machine would like you to believe that because Java has C++ like syntax, that the languages are similar. Nothing can be further from the truth. This misinformation is part of the reason why Java programmers go to C++ and use Java-like syntax without understanding the implications of their code.But I can\'t figure out why should we do it this way. I would assume it\n  has to do with efficiency and speed since we get direct access to the\n  memory address. Am I right?To the contrary, actually. The heap is much slower than the stack, because the stack is very simple compared to the heap. Automatic storage variables (aka stack variables) have their destructors called once they go out of scope. For example:On the other hand, if you use a pointer dynamically allocated, its destructor must be called manually. delete calls this destructor for you.This has nothing to do with the new syntax prevalent in C# and Java. They are used for completely different purposes. 1. You don\'t have to know the size of the array in advanceOne of the first problems many C++ programmers run into is that when they are accepting arbitrary input from users, you can only allocate a fixed size for a stack variable. You cannot change the size of arrays either. For example:Of course if you used an std::string instead, std::string internally resizes itself so that shouldn\'t be a problem. But essentially the solution to this problem is dynamic allocation. You can allocate dynamic memory based on input of the user, for example:Side note: One mistake many beginners make is the usage of\n  variable length arrays. This is a GNU extension and also one in Clang\n  because they mirror many of GCC\'s extensions. So the following \n  int arr[n] should not be relied on.Because the heap is much bigger than the stack, one can arbitrary allocate/reallocate as much memory as he/she needs, whereas the stack has a limitation. 2. Arrays are not pointersHow is this a benefit you ask? The answer will become clear once you understand the confusion/myth behind arrays and pointers. It is commonly assumed that they are the same, but they are not. This myth comes from the fact that pointers can be subscripted just like arrays and because arrays decay to pointers at the top level in a function declaration. However, once an array decays to a pointer, the pointer loses its sizeof information. So sizeof(pointer) will give the size of the pointer in bytes, which is usually 8 bytes on a 64-bit system. You cannot assign to arrays, only initialize them. For example:On the other hand, you can do whatever you want with pointers. Unfortunately because the distinction between pointers and arrays are hand-waved in Java and C#, beginners don\'t understand the difference. 3. PolymorphismJava and C# have facilities that allow you to treat objects as another, for example using the as keyword. So if somebody wanted to treat an Entity object as a Player object, one could do Player player = Entity as Player; This is very useful if you intend to call functions on a homogeneous container that should only apply to a specific type. The functionality can be achieved in a similar fashion below:So say if only Triangles had a Rotate function, it would be a compiler error if you tried to call it on all objects of the class. Using dynamic_cast, you can simulate the as keyword. To be clear, if a cast fails, it returns an invalid pointer. So !test is essentially a shorthand for checking if test is NULL or an invalid pointer, which means the cast failed.After seeing all the great things dynamic allocation can do, you\'re probably wondering why wouldn\'t anyone NOT use dynamic allocation all the time? I already told you one reason, the heap is slow. And if you don\'t need all that memory, you shouldn\'t abuse it. So here\'s some disadvantages in no particular order:It is error prone. Manual memory allocation is dangerous and you are prone to leaks. If you are not proficient at using the debugger or valgrind (a memory leak tool), you may pull your hair out of your head. Luckily RAII idioms and smart pointers alleviate this a bit, but you must be familiar with practices such as The Rule Of Three and The Rule Of Five. It is a lot of information to take in, and beginners who either don\'t know or don\'t care will fall into this trap.It is not necessary. Unlike Java and C# where it is idiomatic to use the new keyword everywhere, in C++, you should only use it if you need to. The common phrase goes, everything looks like a nail if you have a hammer. Whereas beginners who start with C++ are scared of pointers and learn to use stack variables by habit, Java and C# programmers start by using pointers without understanding it! That is literally stepping off on the wrong foot. You must abandon everything you know because syntax is one thing, learning the language is another.1. (N)RVO - Aka, (Named) Return Value OptimizationOne optimization many compilers make are things called elision and return value optimization. These things can obviate unnecessary copys which is useful for objects that are very large, such as a vector containing many elements. Normally the common practice is to use pointers to transfer ownership rather than copying the large objects to move them around. This has lead to the inception of move semantics and smart pointers.If you are using pointers, (N)RVO does NOT occur. It is more beneficial and less error-prone to take advantage of (N)RVO rather than returning or passing pointers if you are worried about optimization. Error leaks can happen if the caller of a function is responsible for deleteing a dynamically allocated object and such. It can be difficult to track the ownership of an object if pointers are being passed around like a hot potato. Just use stack variables because it is simpler and better.C++ gives you three ways to pass an object: by pointer, by reference, and by value. Java limits you with the latter one (the only exception is primitive types like int, boolean etc). If you want to use C++ not just like a weird toy, then you\'d better get to know the difference between these three ways.Java pretends that there is no such problem as \'who and when should destroy this?\'. The answer is: The Garbage Collector, Great and Awful. Nevertheless, it can\'t provide 100% protection against memory leaks (yes, java can leak memory). Actually, GC gives you a false sense of safety. The bigger your SUV, the longer your way to the evacuator.C++ leaves you face-to-face with object\'s lifecycle management. Well, there are means to deal with that (smart pointers family, QObject in Qt and so on), but none of them can be used in \'fire and forget\' manner like GC: you should always keep in mind memory handling. Not only should you care about destroying an object, you also have to avoid destroying the same object more than once.Not scared yet? Ok: cyclic references - handle them yourself, human. And remember: kill each object precisely once, we C++ runtimes don\'t like those who mess with corpses, leave dead ones alone.So, back to your question.When you pass your object around by value, not by pointer or by reference, you copy the object (the whole object, whether it\'s a couple of bytes or a huge database dump - you\'re smart enough to care to avoid latter, aren\'t you?) every time you do \'=\'. And to access the object\'s members, you use \'.\' (dot).When you pass your object by pointer, you copy just a few bytes (4 on 32-bit systems, 8 on 64-bit ones), namely - the address of this object. And to show this to everyone, you use this fancy \'->\' operator when you access the members. Or you can use the combination of \'*\' and \'.\'.When you use references, then you get the pointer that pretends to be a value. It\'s a pointer, but you access the members through \'.\'.And, to blow your mind one more time: when you declare several variables separated by commas, then (watch the hands):Example:In C++, objects allocated on the stack (using Object object; statement within a block) will only live within the scope they are declared in. When the block of code finishes execution, the object declared are destroyed. \nWhereas if you allocate memory on heap, using Object* obj = new Object(), they continue to live in heap until you call delete obj.I would create an object on heap when I like to use the object not only in the block of code which declared/allocated it.But I can\'t figure out why should we use it like this?I will compare how it works inside function body, if you use:inside function, your myObject will get destroyed once this function returns. So this is usefull if you dont need your object outside your function. This object will be put on current thread stack.If you write inside function body:then Object class instance pointed by myObject will not get destroyed once function ends, and allocation is on heap.Now if you are java programmer, then the second example is closer to how object allocation works under java. This line: Object *myObject = new Object; is equivalent to java: Object myObject = new Object();. The difference is that under java myObject will get garbage collected, while under c++ it will not get freed, you must somewhere explicitly call `delete myObject;\' otherwise you will introduce memory leaks.Since c++11 you can use safe ways of dynamic allocations: new Object, by storing values in shared_ptr/unique_ptr.also, objects are very often stored in containers, like map-s or vector-s, they will automatically manage lifetime of your objects.Technically it is a memory allocation issue, however here are two more practical aspects of this.\nIt has to do with two things:\n1) Scope, when you define an object without a pointer you will no longer be able to access it after the code block it is defined in, whereas if you define a pointer with "new" then you can access it from anywhere you have a pointer to this memory until you call "delete" on the same pointer.\n2) If you want to pass arguments to a function you want to pass a pointer or a reference in order to be more efficient. When you pass an Object then the object is copied, if this is an object that uses a lot of memory this might be CPU consuming (e.g. you copy a vector full of data). When you pass a pointer all you pass is one int (depending of implementation but most of them are one int).Other than that you need to understand that "new" allocates memory on the heap that needs to be freed at some point. When you don\'t have to use "new" I suggest you use a regular object definition "on the stack".There are many benefits of using pointers to object - Let\'s say that you have class A that contain class B When you want to call some function of class B outside class A you will simply obtain a pointer to this class and you can do whatever you want and it will also change context of class B in your class ABut be careful with dynamic objectThis is has been discussed at length, but in Java everything is a pointer. It makes no distinction between stack and heap allocations (all objects are allocated on the heap), so you don\'t realize you\'re using pointers. In C++, you can mix the two, depending on your memory requirements. Performance and memory usage is more deterministic in C++ (duh).  Well the main question is Why should I use a pointer rather than the object itself? And my answer, you should (almost) never use pointer instead of object, because C++ has references, it is safer then pointers and guarantees the same performance as pointers.Another thing you mentioned in your question:How does it work? It creates pointer of Object type, allocates memory to fit one object and calls default constructor, sounds good, right? But actually it isn\'t so good, if you dynamically allocated memory (used keyword new), you also have to free memory manually, that means in code you should have:This calls destructor and frees memory, looks easy, however in big projects may be difficult to detect if one thread freed memory or not, but for that purpose you can try shared pointers, these slightly decreases performance, but it is much easier to work with them.And now some introduction is over and go back to question.You can use pointers instead of objects to get better performance while transferring data between function.Take a look, you have std::string (it is also object) and it contains really much data, for example big XML, now you need to parse it, but for that you have function void foo(...) which can be declarated in different ways:What more I want to mention, you can use these 5 ways to pass data no matter which allocation way you have chosen (with new or regular).Another thing to mention, when you create object in regular way, you allocate memory in stack, but while you create it with new you allocate heap. It is much faster to allocate stack, but it is kind a small for really big arrays of data, so if you need big object you should use heap, because you may get stack overflow, but usually this issue is solved using STL containers and remember std::string is also container, some guys forgot it :)Suppose you want to visit your friends home, \nTell him to bring his home to your place. This is Passing object itself.Then ask him his home address, he will give you the address. Now you can visit his home this is Pass by Pointer. getting address from your friend is easier than copying his home everywhere.\nthis is why you should use pointers to objects.A pointer directly references the memory location of an object. Java has nothing like this. Java has references that reference the location of object through hash tables. You cannot do anything like pointer arithmetic in Java with these references.To answer your question, it\'s just your preference. I prefer using the Java-like syntax.You shouldn\'t. People (many people, sadly) write it out of ignorance.Sometimes dynamic allocation has its place but, in the examples you give, it is wrong.If you want to think about efficiency, then this is worse, because it introduces indirection for no good reason. This sort of programming is slower and more error-prone."Necessity is the mother of invention."\nThe most of important difference that I would like to point out is the outcome of my own experience of coding.\nSometimes you need to pass objects to  functions . In that case if your object is  of a very  big class then passing it as an object will copy its state  (which you might not want ..AND CAN BE BIG OVERHEAD) thus resulting in overhead of copying object .while pointer is fixed 4 byte size (assuming 32 bit).Other reasons are already mentioned above...With pointers , can directly talk to the memory. can prevent lot of memory leaks of a program by manipulating pointers.One reason for using pointers is to interface with C functions. Another reason is to save memory; for example: instead of passing an object which contains a lot of data and has a processor-intensive copy-constructor to a function, just pass a pointer to the object, saving memory and speed especially if you\'re in a loop, however a reference would be better in that case, unless you\'re using an C-style array.Doing this will create a reference to an Object (on the heap) which has to be deleted explicitly to avoid memory leak.Doing this will create an object(myObject) of the automatic type (on the stack) that will be automatically deleted when the object(myObject) goes out of scope.There are many excellent answers already, but let me give you one example:I have an simple Item class:I make a vector to hold a bunch of them.std::vector<Item> inventory;I create one million Item objects, and push them back onto the vector. I sort the vector by name, and then do a simple iterative binary search for a particular item name. I test the program, and it takes over 8 minutes to finish executing. Then I change my inventory vector like so:std::vector<Item *> inventory;...and create my million Item objects via new. The ONLY changes I make to my code are to use the pointers to Items, excepting a loop I add for memory cleanup at the end. That program runs in under 40 seconds, or better than a 10x speed increase.\nEDIT: The code is at http://pastebin.com/DK24SPeW\nWith compiler optimizations it shows only a 3.4x increase on the machine I just tested it on, which is still considerable.