Do Android devices have a unique ID, and if so, what is a simple way to access it using Java?Settings.Secure#ANDROID_ID returns the Android ID as an unique for each user 64-bit hex string.UPDATE: As of recent versions of Android, many of the issues with ANDROID_ID have been resolved, and I believe this approach is no longer necessary. Please take a look at Anthony\'s answer.Full disclosure: my app that the below approach was originally used in no longer uses this approach, and we now use the approach outlined in the Android Developer Blog entry that emmby\'s answer links to (namely, generating and saving a UUID#randomUUID()).There are many answers to this question, most of which will only work "some" of the time, and unfortunately that\'s not good enough.Based on my tests of devices (all phones, at least one of which is not activated):So if you want something unique to the device itself, TM.getDeviceId() should be sufficient.  Obviously some users are more paranoid than others, so it might be useful to hash 1 or more of these identifiers, so that the string is still virtually unique to the device, but does not explicitly identify the user\'s actual device.  For example, using String.hashCode(), combined with a UUID:might result in something like: 00000000-54b3-e7c7-0000-000046bffd97It works well enough for me.As Richard mentions below, don\'t forget that you need permission to read the TelephonyManager properties, so add this to your manifest:import libsAfter reading every Stack Overflow post about creating a unique ID, the Google developer blog and Android documentation, I feel as if the \'Pseudo ID\' is the best possible option.Psuedo code:Thanks to @stansult for posting all of our options (in this Stack Overflow question).User Email - SoftwareUser Phone Number - SoftwareIMEI - Hardware (only phones, needs android.permission.READ_PHONE_STATE)Android ID - Hardware (can be null, can change upon factory reset, can be altered on a rooted device)WLAN MAC Address - Hardware (needs android.permission.ACCESS_WIFI_STATE)Bluetooth MAC Address - Hardware (devices with Bluetooth, needs android.permission.BLUETOOTH)Pseudo-Unique ID - Software (for all Android devices)I know there isn\'t any \'perfect\' way of getting a unique ID without using permissions; however, sometimes we only really need to do is track the device installation. When it comes to creating a unique ID, we can create a \'pseudo unique id\' based solely off of information that the Android API gives us without using extra permissions. This way, we can show the user respect and try to offer a good user experience as well.With a pseudo-unique id, you really only run into the fact that there may be duplicates based on the fact that there are similar devices. You can tweak the combined method to make it more unique; however, some developers need to track device installs and this will do the trick or performance based on similar devices.If their Android device is API 9 or over, this is guaranteed to be unique because of the \'Build.SERIAL\' field.REMEMBER, you are technically only missing out on around 0.5% of users who have API < 9. So you can focus on the rest: This is 99.5% of the users!If the user\'s Android device is lower than API 9; hopefully, they have not done a factory reset and their \'Secure.ANDROID_ID\' will be preserved or not \'null\'. (see http://developer.android.com/about/dashboards/index.html)If all else fails, if the user does have lower than API 9 (lower than Gingerbread), has reset their device or \'Secure.ANDROID_ID\' returns \'null\', then simply the ID returned will be solely based off their Android device information. This is where the collisions can happen.Changes:Please take a look at the method below:From the Google Play Developer\'s console:Beginning August 1st, 2014, the Google Play Developer Program Policy\n  requires all new app uploads and updates to use the advertising ID in\n  lieu of any other persistent identifiers for any advertising purposes.\n  Learn moreImplementation:Permission:Code:Source/Docs:http://developer.android.com/google/play-services/id.html\nhttp://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.htmlIt is intended that the advertising ID completely replace existing\n  usage of other identifiers for ads purposes (such as use of ANDROID_ID\n  in Settings.Secure) when Google Play Services is available. Cases\n  where Google Play Services is unavailable are indicated by a\n  GooglePlayServicesNotAvailableException being thrown by\n  getAdvertisingIdInfo().http://en.kioskea.net/faq/34732-android-reset-your-advertising-idI have tried to reference every link that I took information from. If you are missing and need to be included, please comment!https://developers.google.com/instance-id/As Dave Webb mentions, the Android Developer Blog has an article that covers this.  Their preferred solution is to track app installs rather than devices, and that will work well for most use cases.  The blog post will show you the necessary code to make that work, and I recommend you check it out.However, the blog post goes on to discuss solutions if you need a device identifier rather than an app installation identifier.  I spoke with someone at Google to get some additional clarification on a few items in the event that you need to do so.  Here\'s what I discovered about device identifiers that\'s NOT mentioned in the aforementioned blog post:Based on Google\'s recommendations, I implemented a class that will generate a unique UUID for each device, using ANDROID_ID as the seed where appropriate, falling back on TelephonyManager.getDeviceId() as necessary, and if that fails, resorting to a randomly generated unique UUID that is persisted across app restarts (but not app re-installations).Note that for devices that have to fallback on the device ID, the unique ID WILL persist across factory resets.  This is something to be aware of.  If you need to ensure that a factory reset will reset your unique ID, you may want to consider falling back directly to the random UUID instead of the device ID.Again, this code is for a device ID, not an app installation ID.  For most situations, an app installation ID is probably what you\'re looking for.  But if you do need a device ID, then the following code will probably work for you.Here is the code that Reto Meier used in the Google I/O presentation this year to get a unique id for the user:If you couple this with a backup strategy to send preferences to the cloud (also described in Reto\'s talk, you should have an id that ties to a user and sticks around after the device has been wiped, or even replaced. I plan to use this in analytics going forward (in other words, I have not done that bit yet :).Also you might consider the Wi-Fi adapter\'s MAC address. Retrieved thusly:Requires permission android.permission.ACCESS_WIFI_STATE in the manifest.Reported to be available even when Wi-Fi is not connected. If Joe from the answer above gives this one a try on his many devices, that\'d be nice.On some devices, it\'s not available when Wi-Fi is turned off.NOTE: From Android 6.x, it returns consistent fake mac address: 02:00:00:00:00:00There\xe2\x80\x99s rather useful info here.It covers five different ID types:The official Android Developers Blog now has a full article just about this very subject, Identifying App Installations.At Google I/O Reto Meier released a robust answer to how to approach this which should meet most developers needs to track users across installations. Anthony Nolan shows the direction in his answer, but I thought I\'d write out the full approach so that others can easily see how to do it (it took me a while to figure out the details).This approach will give you an anonymous, secure user ID which will be persistent for the user across different devices (based on the primary Google account) and across installs. The basic approach is to generate a random user ID and to store this in the apps\' shared preferences. You then use Google\'s backup agent to store the shared preferences linked to the Google account in the cloud.Let\'s go through the full approach. First, we need to create a backup for our SharedPreferences using the Android Backup Service. Start by registering your app via http://developer.android.com/google/backup/signup.html.Google will give you a backup service key which you need to add to the manifest. You also need to tell the application to use the BackupAgent as follows:Then you need to create the backup agent and tell it to use the helper agent for sharedpreferences:To complete the backup you need to create an instance of BackupManager in your main Activity:Finally create a user ID, if it doesn\'t already exist, and store it in the SharedPreferences:This User_ID will now be persistent across installations, even if the user moves device.For more information on this approach see Reto\'s talk.And for full details of how to implement the backup agent see Data Backup. I particularly recommend the section at the bottom on testing as the backup does not happen instantaneously and so to test you have to force the backup.The following code returns the device serial number using a hidden Android API. But, this code don\'t works on Samsung Galaxy Tab because "ro.serialno" isn\'t set on this device.I think this is sure fire way of building a skeleton for a unique ID...  check it out.Pseudo-Unique ID, that works on all Android devices\nSome devices don\'t have a phone (eg. Tablets) or for some reason you don\'t want to include the READ_PHONE_STATE permission. You can still read details like ROM Version, Manufacturer name, CPU type, and other hardware details, that will be well suited if you want to use the ID for a serial key check, or other general purposes. The ID computed in this way won\'t be unique: it is possible to find two devices with the same ID (based on the same hardware and rom image) but the chances in real world applications are negligible. For this purpose you can use the Build class:Most of the Build members are strings, what we\'re doing here is to take their length and transform it via modulo in a digit. We have 13 such digits and we are adding two more in front (35) to have the same size ID like the IMEI (15 digits). There are other possibilities here are well, just have a look at these strings.\nReturns something like: 355715565309247 . No special permission are required, making this approach very convenient.(Extra info: The technique given above was copied from an article on Pocket Magic.)Using the code below, you can get the unique device ID of an Android OS device as a string.A Serial field was added to the Build class in API level 9 (Android 2.3 - Gingerbread). Documentation says it represents the hardware serial number. Thus it should be unique, if it exists on the device. I don\'t know whether it is actually supported (=not null) by all devices with API level >= 9 though.One thing I\'ll add - I have one of those unique situations.Using:Turns out that even though my Viewsonic G Tablet reports a DeviceID that is not Null, every single G Tablet reports the same number.Makes it interesting playing "Pocket Empires" which gives you instant access to someone\'s account based on the "unique" DeviceID.My device does not have a cell radio.For detailed instructions on how to get a unique identifier for each Android device your application is installed from, see the official Android Developers Blog posting Identifying App Installations.It seems the best way is for you to generate one yourself upon installation and subsequently read it when the application is re-launched.I personally find this acceptable but not ideal. No one identifier provided by Android works in all instances as most are dependent on the phone\'s radio states (Wi-Fi on/off, cellular on/off, Bluetooth on/off). The others, like Settings.Secure.ANDROID_ID must be implemented by the manufacturer and are not guaranteed to be unique.The following is an example of writing data to an installation file that would be stored along with any other data the application saves locally.Add Below code in class file:Add in AndroidManifest.xml:Adding to what others have said, there is a new Best practices for unique identifiers guide in the official Android documentation: http://developer.android.com/training/articles/user-data-ids.htmlBut I strongly recommend a method suggested by Google, see Identifying App Installations.There are a lot of different approaches to work around those ANDROID_ID issues (may be null sometimes or devices of a specific model always return the same ID) with pros and cons:I myself prefer using an existing OpenUDID implementation (see https://github.com/ylechelle/OpenUDID) for Android (see https://github.com/vieux/OpenUDID). It is easy to integrate and makes use of the ANDROID_ID with fallbacks for those issues mentioned above.How about the IMEI. That is unique for Android or other mobile devices.My two cents - NB this is for a device (err) unique ID - not the installation one as discussed in the Android developers\'s blog.Of note that the solution provided by @emmby falls back in a per application ID as the SharedPreferences are not synchronized across processes (see here and here). So I avoided this altogether.Instead, I encapsulated the various strategies for getting a (device) ID in an enum - changing the order of the enum constants affects the priority of the various ways of getting the ID. The first non-null ID is returned or an exception is thrown (as per good Java practices of not giving null a meaning). So for instance I have the TELEPHONY one first - but a good default choice would be the ANDROID_ID\nbeta:For hardware recognition of a specific Android device you could check the MAC Addresses.you can do it that way:in AndroidManifest.xml<uses-permission android:name="android.permission.INTERNET" />now in your code:In every Android device their is at least a "wlan0" Interface witch is the WI-FI chip.\nThis code works even when WI-FI is not turned on.P.S.\nTheir are a bunch of other Interfaces you will get from the list containing MACS But this can change between phones.Here is how I am generating the unique id:Another way is to use /sys/class/android_usb/android0/iSerial in an app without any permissions whatsoever.To do this in Java one would just use a FileInputStream to open the iSerial file and read out the characters. Just be sure you wrap it in an exception handler, because not all devices have this file. At least the following devices are known to have this file world-readable:You can also see my blog post Leaking Android hardware serial number to unprivileged apps where I discuss what other files are available for information.More specifically, Settings.Secure.ANDROID_ID. This is a 64-bit quantity that is generated and stored when the device first boots. It is reset when the device is wiped.ANDROID_ID seems a good choice for a unique device identifier. There are downsides: First, it is not 100% reliable on releases of Android prior to 2.2 (\xe2\x80\x9cFroyo\xe2\x80\x9d). Also, there has been at least one widely-observed bug in a popular handset from a major manufacturer, where every instance has the same ANDROID_ID.Android device mac id also a unique id, it won\'t change suppose if we format the device itself so using the following code to get mac idAlso do not forget to add the appropriate permissions into your \nAndroidManifest.xmlThere are 30+ answers here and some are same and some are unique. This answer is based on few of those answers. One of them being @Lenn Dolling\'s answer.It combines 3 IDs and creates a 32-digit hex string. It has worked very well for me.  3 IDs are:\nPseudo-ID - It is generated based on physical device specifications\nANDROID_ID - Settings.Secure.ANDROID_ID\nBluetooth Address - Bluetooth adapter addressIt will return something like this:  551F27C060712A72730B0A0F734064B1Note: You can always add more IDs to the longId string. For example, Serial #. wifi adapter address. IMEI. This way you are making it more unique per device.I found a library on Github that seems to bundle a few of the approaches discussed in this thread: https://github.com/thomashaertel/android-device-identificationHaven\'t tried it, but maybe it helps.Google Instance IDReleased at I/O 2015; on Android requires play services 7.5.https://developers.google.com/instance-id/\nhttps://developers.google.com/instance-id/guides/android-implementationIt seems that Google intends for this ID to be used to identify installations across Android, Chrome, and iOS.It identifies an installation rather then a device, but then again, ANDROID_ID (which is the accepted answer) now no longer identifies devices either.  With the ARC runtime a new ANDROID_ID is generated for every installation (details here), just like this new instance ID.  Also, I think that identifying installations (not devices) is what most of us are actually looking for.The advantages of instance IDIt appears to me that Google intends for it to be used for this purpose (identifying your installations), it is cross-platform, and can be used for a number of other purposes (see the links above).If you use GCM, then you will eventually need to use this instance ID because you need it in order to get the GCM token (which replaces the old GCM registration ID).The disadvantages/issuesIn the current implementation (GPS 7.5) the instance ID is retrieved from a server when your app requests it.  This means that the call above is a blocking call - in my unscientific testing it takes 1-3 seconds if the device is online, and 0.5 - 1.0 seconds if off-line (presumably this is how long it waits before giving up and generating a random ID).  This was tested in North America on Nexus 5 with Android 5.1.1 and GPS 7.5.If you use the ID for the purposes they intend - eg. app authentication, app identification, GCM - I think this 1-3 seconds could be a nuisance (depending on your app, of course).I use the following code to get the IMEI or use Secure.ANDROID_ID as an alternative, when the device doesn\'t have phone capabilities: