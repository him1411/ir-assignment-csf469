How can one parse HTML/XML and extract information from it?I prefer using one of the native XML extensions since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup. The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C\'s Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.DOM is capable of parsing and modifying real world (broken) HTML and it can do XPath queries. It is based on libxml. It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you\'ll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language\'s DOM API then.A basic usage example can be found in Grabbing the href attribute of an A element and a general conceptual overview can be found at DOMDocument in phpHow to use the DOM extension has been covered extensively on StackOverflow, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way. XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml\'s HTML Parser Module.A basic usage example can be found at getting all values from h1 tags using phpThis extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.The XML Parser library is also based on libxml, and implements a SAX style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators. SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don\'t even consider SimpleXml because it will choke.A basic usage example can be found at A simple program to CRUD node and node values of xml file and there is lots of additional examples in the PHP Manual.If you prefer to use a 3rd-party lib, I\'d suggest using a lib that actually uses DOM/libxml underneath instead of string parsing.FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.Wa72\\HtmlPageDom` is a PHP library for easy manipulation of HTML\n  documents using  It requires DomCrawler from Symfony2\n  components for traversing  the\n  DOM tree and extends it by adding methods for manipulating the DOM\n  tree of HTML documents.phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library written in PHP5 and provides additional Command Line Interface (CLI). Also see: https://github.com/electrolinux/phpqueryZend_Dom provides tools for working with DOM documents and structures. Currently, we offer Zend_Dom_Query, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors. QueryPath is a PHP library for manipulating XML and HTML. It is designed to work not only with local files, but also with web services and database resources. It implements much of the jQuery interface (including CSS-style selectors), but it is heavily tuned for server-side use.  Can be installed via Composer.fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple "xml to object/array" mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.FluidXML is a PHP library for manipulating XML with a concise and fluent API.\n  It leverages XPath and the fluent programming pattern to be fun and effective.The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route.  Some of them listed belowI generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as child selectors) are possible. Any of the libxml based libraries should outperform this easily.PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrap html, whether it\'s valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.Never used it. Can\'t tell if it\'s any good.You can use the above for parsing HTML5, but there can be quirks due to the markup HTML5 allows. So for HTML5 you want to consider using a dedicated parser, likehtml5libA Python and PHP implementations of a HTML parser based on the WHATWG HTML5 specification for maximum compatibility with major desktop web browsers. We might see more dedicated parsers once HTML5 is finalized. There is also a blogpost by the W3\'s titled How-To for html 5 parsing that is worth checking out.If you don\'t feel like programming PHP, you can also use web services. In general, I found very little utility for these, but that\'s just me and my use cases.The YQL Web Service enables applications to query, filter, and combine data from different sources across the Internet. YQL statements have a SQL-like syntax, familiar to any developer with database experience.ScraperWiki\'s external interface allows you to extract data in the form you want for use on the web or in your own applications. You can also extract information about the state of any scraper.Last and least recommended, you can extract data from HTML with regular expressions. In general using Regular Expressions on HTML is discouraged. Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding or changing attributes in a tag, can make the regex fails when it\'s not properly written. You should know what you are doing before using regex on HTML.HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new regex you write. Regex are fine in some cases, but it really depends on your use-case.You can write more reliable parsers, but writing a complete and reliable custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.Also see Parsing Html The Cthulhu WayIf you want to spend some money, have a look atI am not affiliated with PHP Architect or the authors.Try Simple HTML DOM Parser\nExamples:Just use DOMDocument->loadHTML() and be done with it. libxml\'s HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.phpQuery and QueryPath are extremely similar in replicating the fluent jQuery API. That\'s also why they\'re two of the easiest approaches to properly parse HTML in PHP.Examples for QueryPathBasically you first create a queryable DOM tree from an HTML string:The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:Mostly you want to use simple #id and .class or DIV tag selectors for ->find(). But you can also use XPath statements, which sometimes are faster. Also typical jQuery methods like ->children() and ->text() and particularly ->attr() simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)QueryPath also allows injecting new tags into the stream (->append), and later output and prettify an updated document (->writeHTML). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard)..phpQuery or QueryPath?Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).  For further information on the differences see this comparison on the wayback machine from tagbyte.org. (Original source went missing, so here\'s an internet archive link. Yes, you can still locate missing pages, people.)And here\'s a comprehensive QueryPath introduction.AdvantagesWhy you shouldn\'t and when you should use regular expressions?First off, a common misnomer: Regexps are not for "parsing" HTML. Regexes can however "extract" data. Extracting is what they\'re made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.Consider that making a somewhat dependable HTML extraction regex:is way less readable than a simple phpQuery or QueryPath equivalent:There are however specific use cases where they can help.It\'s sometimes even advisable to pre-extract a snippet of HTML using regular expressions /<!--CONTENT-->(.+?)<!--END-->/ and process the remainder using the simpler HTML parser frontends.Note: I actually have this app, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can\'t explain it myself. But so it happened.\nSo please don\'t vote real-world considerations down, just because it doesn\'t match the regex=evil meme. But let\'s also not vote this up too much. It\'s just a sidenote for this topic.Simple HTML DOM is a great open-source parser:  simplehtmldom.sourceforgeIt treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you\'d see in JavaScript, such as the "find" function, which will return all instances of elements of that tag name.  I\'ve used this in a number of tools, testing it on many different types of web pages, and I think it works great.One general approach I haven\'t seen mentioned here is to run HTML through Tidy, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.But to your specific problem, you should take a look at this project: http://fivefilters.org/content-only/ -- it\'s a modified version of the Readability algorithm, which is designed to extract just the textual content (not headers and footers) from a page. For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( DomCrawler ).\nThis class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: news-of-the-symfony2-world.The component is designed to work standalone and can be used without Symfony.The only drawback is that it will only work with PHP 5.3 or newer.This is commonly referred to as screen scraping, by the way. The library I have used for this is Simple HTML Dom Parser.We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid HTML/XHTML structures, which would fail, if loaded via most of the parsers.I recommend PHP Simple HTML DOM Parser.It really has nice features, like:This sounds like a good task description of W3C XPath technology. It\'s easy to express queries like "return all href attributes in img tags that are nested in <foo><bar><baz> elements." Not being a PHP buff, I can\'t tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.\nFor a quick intro, see http://en.wikipedia.org/wiki/XPath.Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: phpQuery, Zend_Dom, QueryPath and FluentDom.Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scrapping and have found it to be too vulnerable. It does the basic job but I won\'t recommend it anyways. I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.Kindly check out this link:scraping-websites-with-curlQueryPath is good, but be careful of "tracking state" cause if you didn\'t realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn\'t work.What it means is that each call on the result set modifies the result set in the object, it\'s not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it\'ll mirror what happens in jquery much more closely.$results now contains the result set for input[name=\'forename\'] NOT the original query "div p" this tripped me up a lot, what I found was that QueryPath tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this insteadthen $results won\'t be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it\'s basically like this from what I\'ve found.I have written a general purpose XML parser that can easily handle GB files. It\'s based on XMLReader and it\'s very easy to use:Here\'s the github repo: XmlExtractorFor HTML5, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is html5-php which was just brought to beta 1.0 a little over a week ago.You could try using something like HTML Tidy to cleanup any "broken" HTML and convert the HTML to XHTML, which you can then parse with a XML parser.Another option you can try is QueryPath. It\'s inspired by jQuery, but on the server in PHP and used in Drupal.I created a library named PHPPowertools/DOM-Query, which allows you to crawl HTML5 and XML documents just like you do with jQuery.Under the hood, it uses symfony/DomCrawler for conversion of CSS selectors to XPath selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won\'t make any attempt to list those myself.I merely want to add that I personally prefer using the DOM extension and why :And while I miss the ability to use CSS selectors for DOMDocument, there is a rather simple and convenient way to add this feature: subclassing the DOMDocument and adding JS-like querySelectorAll and querySelector methods to your subclass.For parsing the selectors, I recommend using the very minimalistic CssSelector component from the Symfony framework. This component just translates CSS selectors to XPath selectors, which can then be fed into a DOMXpath to retrieve the corresponding Nodelist.You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.The code below comes straight out my DOM-Query library and uses the technique I described.For HTML parsing :See also Parsing XML documents with CSS selectors by Symfony\'s creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.XML_HTMLSax is rather stable - even if it\'s not maintained any more. Another option could be to pipe you HTML through Html Tidy and then parse it with standard XML tools.The Symfony framework has bundles which can parse the HTML, and you can use CSS style to select the DOMs instead of using XPath.Advanced Html Dom is a simple HTML DOM replacement that offers the same interface, but it\'s DOM-based which means none of the associated memory issues occur.It also has full CSS support, including jQuery extensions.With FluidXML you can query and iterate XML using XPath and CSS Selectors.https://github.com/servo-php/fluidxmlThere are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.Above it\'s a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don\'t want to install libraries, give this a shot:JSON and array from XML in three lines:Ta da!