I feel a bit thick at this point. I\'ve spent days trying to fully wrap my head around suffix tree construction, but because I don\'t have a mathematical background, many of the explanations elude me as they start to make excessive use of mathematical symbology. The closest to a good explanation that I\'ve found is Fast String Searching With Suffix Trees, but he glosses over various points and some aspects of the algorithm remain unclear.A step-by-step explanation of this algorithm here on StackÂ Overflow would be invaluable for many others besides me, I\'m sure.For reference, here\'s Ukkonen\'s paper on the algorithm: http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdfMy basic understanding, so far:The basic algorithm appears to be O(n2), as is pointed out in most explanations, as we need to step through all of the prefixes, then we need to step through each of the suffixes for each prefix. Ukkonen\'s algorithm is apparently unique because of the suffix pointer technique he uses, though I think that is what I\'m having trouble understanding.I\'m also having trouble understanding:Here is the completed source code. It not only works correctly, but supports automatic canonization and renders a nicer looking text graph of the output. Source code and sample output is at:https://gist.github.com/2373868The following is an attempt to describe the Ukkonen algorithm by first showing what it does when the string is simple (i.e. does not contain any repeated characters), and then extending it to the full algorithm.First, a few preliminary statements.What we are building, is basically like a search trie. So there\nis a root node, edges going out of it leading to new nodes, and\nfurther edges going out of those, and so forthBut: Unlike in a search trie, the edge labels are not single\ncharacters. Instead, each edge is labeled using a pair of integers\n[from,to]. These are pointers into the text. In this sense, each\nedge carries a string label of arbitrary length, but takes only O(1)\nspace (two pointers).I would like to first demonstrate how to create the suffix tree of a\nparticularly simple string, a string with no repeated characters:The algorithm works in steps, from left to right. There is one step for every character of the string. Each step might involve more than one individual operation, but we will see (see the final observations at the end) that the total number of operations is O(n).So, we start from the left, and first insert only the single character\na by creating an edge from the root node (on the left) to a leaf,\nand labeling it as [0,#], which means the edge represents the\nsubstring starting at position 0 and ending at the current end. I\nuse the symbol # to mean the current end, which is at position 1\n(right after a).So we have an initial tree, which looks like this:And what it means is this:Now we progress to position 2 (right after b). Our goal at each step\nis to insert all suffixes up to the current position. We do this\nbyIn our representation this looks likeAnd what it means is:We observe two things:Next we increment the position again and update the tree by appending\na c to every existing edge and inserting one new edge for the new\nsuffix c.In our representation this looks likeAnd what it means is:We observe:Of course this works so nicely only because our string does not\ncontain any repetitions. We now look at a more realistic string:It starts with abc as in the previous example, then ab is repeated\nand followed by x, and then abc is repeated followed by d.Steps 1 through 3: After the first 3 steps we have the tree from the previous example:Step 4: We move # to position 4. This implicitly updates all existing\nedges to this:and we need to insert the final suffix of the current step, a, at\nthe root.Before we do this, we introduce two more variables (in addition to\n#), which of course have been there all the time but we haven\'t used\nthem so far:The exact meaning of these two will become clear soon, but for now\nlet\'s just say:Now this is going to change. When we insert the current final\ncharacter a at the root, we notice that there is already an outgoing\nedge starting with a, specifically: abca. Here is what we do in\nsuch a case:Observation: When the final suffix we need to insert is found to\nexist in the tree already, the tree itself is not changed at all (we only update the active point and remainder). The tree\nis then not an accurate representation of the suffix tree up to the\ncurrent position any more, but it contains all suffixes (because the final\nsuffix a is contained implicitly). Hence, apart from updating the\nvariables (which are all of fixed length, so this is O(1)), there was\nno work done in this step.Step 5: We update the current position # to 5. This\nautomatically updates the tree to this:And because remainder is 2, we need to insert two final\nsuffixes of the current position: ab and b. This is basically because:In practice this means that we go to the active point (which points to\nbehind the a on what is now the abcab edge), and insert the\ncurrent final character b. But: Again, it turns out that b is\nalso already present on that same edge.So, again, we do not change the tree. We simply:To be clear: We had to insert ab and b in the current step, but\nbecause ab was already found, we updated the active point and did\nnot even attempt to insert b. Why? Because if ab is in the tree,\nevery suffix of it (including b) must be in the tree,\ntoo. Perhaps only implicitly, but it must be there, because of the\nway we have built the tree so far.We proceed to step 6 by incrementing #. The tree is\nautomatically updated to:Because remainder is 3, we have to insert abx, bx and\nx. The active point tells us where ab ends, so we only need to\njump there and insert the x. Indeed, x is not there yet, so we\nsplit the abcabx edge and insert an internal node:The edge representations are still pointers into the text, so\nsplitting and inserting an internal node can be done in O(1) time.So we have dealt with abx and decrement remainder to 2. Now we\nneed to insert the next remaining suffix, bx. But before we do that\nwe need to update the active point. The rule for this, after splitting\nand inserting an edge, will be called Rule 1 below, and it applies whenever the\nactive_node is root (we will learn rule 3 for other cases further\nbelow). Here is rule 1:After an insertion from root,Hence, the new active-point triple (root,\'b\',1) indicates that the\nnext insert has to be made at the bcabx edge, behind 1 character,\ni.e. behind b. We can identify the insertion point in O(1) time and\ncheck whether x is already present or not. If it was present, we\nwould end the current step and leave everything the way it is. But x\nis not present, so we insert it by splitting the edge:Again, this took O(1) time and we update remainder to 1 and the\nactive point to (root,\'x\',0) as rule 1 states.But there is one more thing we need to do. We\'ll call this Rule 2:If we split an edge and insert a new node, and if that is not the\n  first node created during the current step, we connect the previously\n  inserted node and the new node through a special pointer, a suffix\n  link. We will later see why that is useful. Here is what we get, the\n  suffix link is represented as a dotted edge:We still need to insert the final suffix of the current step,\nx. Since the active_length component of the active node has fallen\nto 0, the final insert is made at the root directly. Since there is no\noutgoing edge at the root node starting with x, we insert a new\nedge:As we can see, in the current step all remaining inserts were made.We proceed to step 7 by setting #=7, which automatically appends the next character,\na, to all leaf edges, as always. Then we attempt to insert the new final\ncharacter to the active point (the root), and find that it is there\nalready. So we end the current step without inserting anything and\nupdate the active point to (root,\'a\',1).In step 8, #=8, we append b, and as seen before, this only\nmeans we update the active point to (root,\'a\',2) and increment remainder without doing\nanything else, because b is already present. However, we notice (in O(1) time) that the active point\nis now at the end of an edge. We reflect this by re-setting it to\n(node1,\'\\0x\',0). Here, I use node1 to refer to the\ninternal node the ab edge ends at.Then, in step #=9, we need to insert \'c\' and this will help us to\nunderstand the final trick:As always, the # update appends c automatically to the leaf edges\nand we go to the active point to see if we can insert \'c\'. It turns\nout \'c\' exists already at that edge, so we set the active point to\n(node1,\'c\',1), increment remainder and do nothing else.Now in step #=10, remainder is 4, and so we first need to insert\nabcd (which remains from 3 steps ago) by inserting d at the active\npoint.Attempting to insert d at the active point causes an edge split in\nO(1) time:The active_node, from which the split was initiated, is marked in\nred above. Here is the final rule, Rule 3:After splitting an edge from an active_node that is not the root\n  node, we follow the suffix link going out of that node, if there is\n  any, and reset the active_node to the node it points to. If there is\n  no suffix link, we set the active_node to the root. active_edge\n  and active_length remain unchanged.So the active point is now (node2,\'c\',1), and node2 is marked in\nred below:Since the insertion of abcd is complete, we decrement remainder to\n3 and consider the next remaining suffix of the current step,\nbcd. Rule 3 has set the active point to just the right node and edge\nso inserting bcd can be done by simply inserting its final character\nd at the active point.Doing this causes another edge split, and because of rule 2, we\nmust create a suffix link from the previously inserted node to the new\none:We observe: Suffix links enable us to reset the active point so we\n  can make the next remaining insert at O(1) effort. Look at the\n  graph above to confirm that indeed node at label ab is linked to\n  the node at b (its suffix), and the node at abc is linked to\n  bc.The current step is not finished yet. remainder is now 2, and we\nneed to follow rule 3 to reset the active point again. Since the\ncurrent active_node (red above) has no suffix link, we reset to\nroot. The active point is now (root,\'c\',1).Hence the next insert occurs at the one outgoing edge of the root node\nwhose label starts with c: cabxabcd, behind the first character,\ni.e. behind c. This causes another split:And since this involves the creation of a new internal node,we follow\nrule 2 and set a new suffix link from the previously created internal\nnode:(I am using Graphviz Dot for these little\ngraphs. The new suffix link caused dot to re-arrange the existing\nedges, so check carefully to confirm that the only thing that was\ninserted above is a new suffix link.)With this, remainder can be set to 1 and since the active_node is\nroot, we use rule 1 to update the active point to (root,\'d\',0). This\nmeans the final insert of the current step is to insert a single d\nat root:That was the final step and we are done. There are number of final\nobservations, though:In each step we move # forward by 1 position. This automatically\nupdates all leaf nodes in O(1) time.But it does not deal with a) any suffixes remaining from previous\nsteps, and b) with the one final character of the current step.remainder tells us how many additional inserts we need to\nmake. These inserts correspond one-to-one to the final suffixes of\nthe string that ends at the current position #. We consider one\nafter the other and make the insert. Important: Each insert is\ndone in O(1) time since the active point tells us exactly where to\ngo, and we need to add only one single character at the active\npoint. Why? Because the other characters are contained implicitly\n(otherwise the active point would not be where it is).After each such insert, we decrement remainder and follow the\nsuffix link if there is any. If not we go to root (rule 3). If we\nare at root already, we modify the active point using rule 1. In\nany case, it takes only O(1) time.If, during one of these inserts, we find that the character we want\nto insert is already there, we don\'t do anything and end the\ncurrent step, even if remainder>0. The reason is that any\ninserts that remain will be suffixes of the one we just tried to\nmake. Hence they are all implicit in the current tree. The fact\nthat remainder>0 makes sure we deal with the remaining suffixes\nlater.What if at the end of the algorithm remainder>0? This will be the\ncase whenever the end of the text is a substring that occurred\nsomewhere before. In that case we must append one extra character\nat the end of the string that has not occurred before. In the\nliterature, usually the dollar sign $ is used as a symbol for\nthat. Why does that matter? --> If later we use the completed suffix tree to search for suffixes, we must accept matches only if they end at a leaf. Otherwise we would get a lot of spurious matches, because there are many strings implicitly contained in the tree that are not actual suffixes of the main string. Forcing remainder to be 0 at the end is essentially a way to ensure that all suffixes end at a leaf node. However, if we want to use the tree to search for general substrings, not only suffixes of the main string, this final step is indeed not required, as suggested by the OP\'s comment below.So what is the complexity of the entire algorithm? If the text is n\ncharacters in length, there are obviously n steps (or n+1 if we add\nthe dollar sign). In each step we either do nothing (other than\nupdating the variables), or we make remainder inserts, each taking O(1)\ntime. Since remainder indicates how many times we have done nothing\nin previous steps, and is decremented for every insert that we make\nnow, the total number of times we do something is exactly n (or\nn+1). Hence, the total complexity is O(n).However, there is one small thing that I did not properly explain:\nIt can happen that we follow a suffix link, update the active\npoint, and then find that its active_length component does not\nwork well with the new active_node. For example, consider a situation\nlike this:(The dashed lines indicate the rest of the tree. The dotted line is a\nsuffix link.)Now let the active point be (red,\'d\',3), so it points to the place\nbehind the f on the defg edge. Now assume we made the necessary\nupdates and now follow the suffix link to update the active point\naccording to rule 3. The new active point is (green,\'d\',3). However,\nthe d-edge going out of the green node is de, so it has only 2\ncharacters. In order to find the correct active point, we obviously\nneed to follow that edge to the blue node and reset to (blue,\'f\',1).In a particularly bad case, the active_length could be as large as\nremainder, which can be as large as n. And it might very well happen\nthat to find the correct active point, we need not only jump over one\ninternal node, but perhaps many, up to n in the worst case. Does that\nmean the algorithm has a hidden O(n2) complexity, because\nin each step remainder is generally O(n), and the post-adjustments\nto the active node after following a suffix link could be O(n), too?No. The reason is that if indeed we have to adjust the active point\n(e.g. from green to blue as above), that brings us to a new node that\nhas its own suffix link, and active_length will be reduced. As\nwe follow down the chain of suffix links we make the remaining inserts, active_length can only\ndecrease, and the number of active-point adjustments we can make on\nthe way can\'t be larger than active_length at any given time. Since\nactive_length can never be larger than remainder, and remainder\nis O(n) not only in every single step, but the total sum of increments\never made to remainder over the course of the entire process is\nO(n) too, the number of active point adjustments is also bounded by\nO(n).I tried to implement the Suffix Tree with the approach given in jogojapan\'s answer, but it didn\'t work for some cases due to wording used for the rules. Moreover, I\'ve mentioned that nobody managed to implement an absolutely correct suffix tree using this approach. Below I will write an "overview" of jogojapan\'s answer with some modifications to the rules. I will also describe the case when we forget to create important suffix links.Additional variables usedLet\'s use a concept of an internal node - all the nodes, except the root and the leafs are internal nodes.Observation 1When the final suffix we need to insert is found to exist in the tree already, the tree itself is not changed at all (we only update the active point and remainder).Observation 2If at some point active_length is greater or equal to the length of current edge (edge_length), we move our active point down until edge_length is strictly greater than active_length.Now, let\'s redefine the rules:Rule 1If after an insertion from the active node = root, the active length is greater than 0, then:Rule 2If we create a new internal node OR make an inserter from an internal node, and this is not the first SUCH internal node at current step, then we link the previous SUCH node with THIS one through a suffix link.This definition of the Rule 2 is different from jogojapan\', as here we take into account not only the newly created internal nodes, but also the internal nodes, from which we make an insertion.Rule 3After an insert from the active node which is not the root node, we must follow the suffix link and set the active node to the node it points to. If there is no a suffix link, set the active node to the root node. Either way, active edge and active length stay unchanged.In this definition of Rule 3 we also consider the inserts of leaf nodes (not only split-nodes).And finally, Observation 3:When the symbol we want to add to the tree is already on the edge, we, according to Observation 1, update only active point and remainder, leaving the tree unchanged. BUT if there is an internal node marked as needing suffix link, we must connect that node with our current active node through a suffix link.Let\'s look at the example of a suffix tree for cdddcdc if we add a suffix link in such case and if we don\'t:If we DON\'T connect the nodes through a suffix link:If we DO connect the nodes through a suffix link:Seems like there is no significant difference: in the second case there are two more suffix links. But these suffix links are correct, and one of them - from the blue node to the red one - is very important for our approach with active point. The problem is that if we don\'t put a suffix link here, later, when we add some new letters to the tree, we might omit adding some nodes to the tree due to the Rule 3, because, according to it, if there\'s no a suffix link, then we must put the active_node to the root.When we were adding the last letter to the tree, the red node had already existed before we made an insert from the blue node (the edge labled \'c\'). As there was an insert from the blue node, we mark it as needing a suffix link. Then, relying on the active point approach, the active node was set to the red node. But we don\'t make an insert from the red node, as the letter \'c\' is already on the edge. Does it mean that the blue node must be left without a suffix link? No, we must connect the blue node with the red one through a suffix link. Why is it correct? Because the active point approach guarantees that we get to a right place, i.e., to the next place where we must process an insert of a shorter suffix.Finally, here are my implementations of the Suffix Tree:Hope that this "overview" combined with jogojapan\'s detailed answer will help somebody to implement his own Suffix Tree.I have had quite a lot problems to implement this data structure myself. In the end I found this article and managed to implement it. A great plus for it is that you have a step-by-step example for a quite long string so you get to see what you should do. Please take a look at the article and I will be more then happy to give tips where needed. I am hesitant to gove yet another full-blown explanation as there are alredy quite a few round the internet.My intuition is as follows:After k iterations of the main loop you have constructed a suffix tree which contains all suffixes of the complete string that start in the first k characters.At the start, this means the suffix tree contains a single root node that represents the entire string (this is the only suffix that starts at 0).After len(string) iterations you have a suffix tree that contains all suffixes.During the loop the key is the active point.  My guess is that this represents the deepest point in the suffix tree that corresponds to a proper suffix of the first k characters of the string. (I think proper means that the suffix cannot be the entire string.)For example, suppose you have seen characters \'abcabc\'.  The active point would represent the point in the tree corresponding to the suffix \'abc\'.The active point is represented by (origin,first,last).\nThis means that you are currently at the point in the tree that you get to by starting at node origin and then feeding in the characters in string[first:last]When you add a new character you look to see whether the active point is still in the existing tree.  If it is then you are done.\nOtherwise you need to add a new node to the suffix tree at the active point, fallback to the next shortest match, and check again.Note 1:\nThe suffix pointers give a link to the next shortest match for each node.Note 2:\nWhen you add a new node and fallback you add a new suffix pointer for the new node.\nThe destination for this suffix pointer will be the node at the shortened active point.\nThis node will either already exist, or be created on the next iteration of this fallback loop.Note 3: The canonization part simply saves time in checking the active point.\nFor example, suppose you always used origin=0, and just changed first and last.\nTo check the active point you would have to follow the suffix tree each time along all the intermediate nodes.\nIt makes sense to cache the result of following this path by recording just the distance from the last node.Can you give a code example of what you mean by "fix" bounding variables?Health warning: I also found this algorithm particularly hard to understand so please realise that this intuition is likely to be incorrect in all important details...Hi i have tried to implement the above explained implementation in ruby , please check it out.\nit seems to work fine.the only difference in the implementation is that , i have tried to use the edge object instead of just using symbols.its also present at https://gist.github.com/suchitpuri/9304856Thanks for the well explained tutorial by @jogojapan, I implemented the algorithm in Python. A couple of minor problems mentioned by @jogojapan turns out to be more sophisticated than I have expected, and need to be treated very carefully. It cost me several days to get my implementation robust enough (I suppose). Problems and solutions are listed below:End with Remainder > 0 It turns out this situation can also happen during the unfolding step, not just the end of the entire algorithm. When that happens, we can leave the remainder, actnode, actedge, and actlength unchanged, end the current unfolding step, and start another step by either keep folding or unfolding depending on if the next char in the original string is on the current path or not.Leap Over Nodes: When we follow a suffix link, update the active point, and then find that its active_length component does not work well with the new active_node. We have to move forward to the right place to split, or insert a leaf. This process might be not that straightforward because during the moving the actlength and actedge keep changing all the way, when you have to move back to the root node, the actedge and actlength could be wrong because of those moves. We need additional variable(s) to keep that information.The other two problems have somehow been pointed out by @managonovSplit Could Degenerate When trying to split an edge, sometime you\'ll find the split operation is right on a node. That case we only need add a new leaf to that node, take it as a standard edge split operation, which means the suffix links if there\'s any, should be maintained correspondingly.Hidden Suffix Links There is another special case which is incurred by problem 1 and problem 2. Sometimes we need to hop over several nodes to the right point for split, we might surpass the right point if we move by comparing the remainder string and the path labels. That case the suffix link will be neglected unintentionally, if there should be any. This could be avoided by remembering the right point when moving forward. The suffix link should be maintained if the split node already exists, or even the problem 1 happens during a unfolding step.Finally, my implementation in Python is as follows:Tips: It includes a naive tree printing function in the code above, which is very important while debugging. It saved me a lot of\n  time and is convenient for locating special cases.@jogojapan you brought awesome explanation and visualisation. But as @makagonov mentioned it\'s missing some rules regarding setting suffix links. It\'s visible in nice way when going step by step on http://brenden.github.io/ukkonen-animation/ through word \'aabaaabb\'. When you go from step 10 to step 11, there is no suffix link from node 5 to node 2 but active point suddenly moves there.@makagonov since I live in Java world I also tried to follow your implementation to grasp ST building workflow but it was hard to me because of:So I ended up with such implementation in Java which I hope reflects all steps in clearer way and will reduce learning time for other Java people: