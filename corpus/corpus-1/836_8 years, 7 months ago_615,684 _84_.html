How would you initialise a static Map in Java?Method one: static initialiser \nMethod two: instance initialiser (anonymous subclass)\nor\nsome other method?What are the pros and cons of each?Here is an example illustrating two methods:The instance initialiser is just syntactic sugar in this case, right? I don\'t see why you need an extra anonymous class just to initialize. And it won\'t work if the class being created is final.You can create an immutable map using a static initialiser too:I like the Guava way of initialising a static, immutable map:As you can see, it\'s very concise (because of the convenient factory methods in ImmutableMap).If you want the map to have more than 5 entries, you can no longer use ImmutableMap.of(). Instead, try ImmutableMap.builder() along these lines:To learn more about the benefits of Guava\'s immutable collection utilities, see Immutable Collections Explained in Guava User Guide.(A subset of) Guava used to be called Google Collections. If you aren\'t using this library in your Java project yet, I strongly recommend trying it out! Guava has quickly become one of the most popular and useful free 3rd party libs for Java, as fellow SO users agree. (If you are new to it, there are some excellent learning resources behind that link.)Update (2015): As for Java 8, well, I would still use the Guava approach because it is way cleaner than anything else. If you don\'t want Guava dependency, consider a plain old init method. The hack with two-dimensional array and Stream API is pretty ugly if you ask me, and gets uglier if you need to create a Map whose keys and values are not the same type (like Map<Integer, String> in the question).As for future of Guava in general, with regards to Java 8, Louis Wasserman said this back in 2014, and [update] in 2016 it was announced that Guava 21 will require and properly support Java 8.Update (2016): As Tagir Valeev points out, Java 9 will finally make this clean to do using nothing but pure JDK, by adding convenience factory methods for collections:I would use:Java 5 provides this more compact syntax:One advantage to the second method is that you can wrap it with Collections.unmodifiableMap() to guarantee that nothing is going to update the collection later:Here\'s a Java 8 one-line static map initializer:Edit: to initialize a Map<Integer, String> as in the question, you\'d need something like this:With Eclipse Collections (formerly GS Collections), all of the following will work:You can also statically initialize primitive maps with Eclipse Collections.Note: I am a committer for Eclipse Collections In Java 9:See JEP 269 for details. Java 9 general availability is set to July 2017. Download JDK 9 early access builds here.I would never create an anonymous subclass in this situation. Static initializers work equally well, if you would like to make the map unmodifiable for example:Maybe it\'s interesting to check out Google Collections, e.g. the videos that they have on their page. They provide various ways to initialize maps and sets, and provide immutable collections as well.Update: This library is now named Guava.I like anonymous class, because it is easy to deal with it:If we declare more than one constant then that code will be written in static block and that is hard to maintain in future. So it is better to use anonymous class.And it is suggested to used unmodifiableMap for constants other wise it can\'t be treated as constant.There is an answer proposed by Luke which initializes a map using Java 8 but IMHO it looks ugly and difficult to read. We can create a Stream of map entries. We already have two implementations of Entry in java.util.AbstractMap which are SimpleEntry and SimpleImmutableEntry. For this example we can make use of former as:For Java 9 we can also make use of Map.of as suggested by Tagir in his answer here.I could strongly suggest the "double brace initialization" style over static block style.Someone may comment that they don\'t like anonymous class, overhead, performance, etc.But that I more consider is the code readability and maintainability. In this point of view, I stand a double brace is a better code style rather then static method.In addition, it you aware the GC of the anonymous class, you can always convert it to a normal HashMap by using new HashMap(Map map).You can do this until you faced another problem. If you do, you should use complete another coding style (e.g. no static, factory class) for it.As usual apache-commons has proper method MapUtils.putAll(Map, Object[]):For example, to create a color map: The anonymous class you\'re creating works well. However you should be aware that this is an inner class and as such, it\'ll contain a reference to the surrounding class instance. So you\'ll find you can\'t do certain things with it (using XStream for one). You\'ll get some very strange errors.Having said that, so long as you\'re aware then this approach is fine. I use it most of the time for initialising all sorts of collections in a concise fashion. EDIT: Pointed out correctly in the comments that this is a static class. Obviously I didn\'t read this closely enough. However my comments do still apply to anonymous inner classes.If you want something terse and relatively safe, you can just shift compile-time type checking to run-time:This implementation should catch any errors:I prefer using a static initializer to avoid generating anonymous classes (which would have no further purpose), so I\'ll list tips initializing with a static initializer. All listed solutions / tips are type-safe.Note: The question doesn\'t say anything about making the map unmodifiable, so I will leave that out, but know that it can easily be done with Collections.unmodifiableMap(map).First tipThe 1st tip is that you can make a local reference to the map and you give it a SHORT name:Second tipThe 2nd tip is that you can create a helper method to add entries; you can also make this helper method public if you want to:The helper method here is not re-usable though because it can only add elements to myMap2. To make it re-usable, we could make the map itself a parameter of the helper method, but then initialization code would not be any shorter. Third tipThe 3rd tip is that you can create a re-usable builder-like helper class with the populating functionality. This is really a simple, 10-line helper class which is type-safe:You may use StickyMap and MapEntry from Cactoos:I do not like Static initializer syntax and I\'m not convinced to anonymous subclasses. Generally, I agree with all cons of using Static initializers and all cons of using anonymous subclasses that were mentioned in previus answers. On the other hand - pros presented in these posts are not enough for me. I prefer to use static initialization method:Because Java does not support map literals, map instances must always be explicitly instantiated and populated.Fortunately, it is possible to approximate the behavior of map literals in Java using factory methods. For example:Output:{a=1, b=2, c=3}It is a lot more convenient than creating and populating the map an element at a time.With Java 8 I\'ve come to use the following pattern:It\'s not the most terse and a bit roundabout, butHere\'s my favorite when I don\'t want to (or cannot) use Guava\'s ImmutableMap.of(), or if I need a mutable Map:It\'s very compact, and it ignores stray values (i.e. a final key without a value).Usage:The second method could invoke protected methods if needed. This can be useful for initializing classes which are immutable after construction.I like the anonymous class syntax; it\'s just less code. However, one major con I have found is that you won\'t be able to serialize that object via remoting. You will get an exception about not being able to find the anonymous class on the remote side.I\'ve done something a bit different. Not the best, but it works for me. Maybe it could be "genericized".Now that Java 8 is out, this question warrants revisiting. I took a stab at it -- looks like maybe you can exploit lambda expression syntax to get a pretty nice and concise (but type-safe) map literal syntax that looks like this:Untested sample code at https://gist.github.com/galdosd/10823529\nWould be curious on the opinions of others on this (it\'s mildly evil...)I like using the static initializer "technique" when I have a concrete realization of an abstract class that has defined an initializing constructor but no default constructor but I want my subclass to have a default constructor.For example:and my concrete realization of this class -- but it wants/needs a default constructor:then to use this default constructor, we simply do:I have not seen the approach I use (and have grown to like) posted in any answers, so here it is:I don\'t like using static initializers because they are clunky,\nand I don\'t like anonymous classes because it is creating a new class for each instance.instead, I prefer initialization that looks like this:unfortunately, these methods are not part of the standard Java library,\nso you will need to create (or use) a utility library that defines the following methods:(you can use \'import static\' to avoid needing to prefix the method\'s name)I found it useful to provide similar static methods for the other collections (list, set, sortedSet, sortedMap, etc.)Its not quite as nice as json object initialization, but it\'s a step in that direction, as far as readability is concerned.In Java 8, procedural approach can also be wrapped in Supplier:It\'s only hypothetical way but can come handy if you really need one-liner.