What exactly is the difference between an interface and abstract class?An interface is a contract: The guy writing the interface says, "hey, I accept things looking that way", and the guy using the interface says "OK, the class I write looks that way".An interface is an empty shell. There are only the signatures of the methods, which implies that the methods do not have a body. The interface can\'t do anything. It\'s just a pattern.For example (pseudo code):Implementing an interface consumes very little CPU, because it\'s not a class, just a bunch of names, and therefore there isn\'t any expensive look-up to do. It\'s great when it matters, such as in embedded devices.Abstract classes, unlike interfaces, are classes. They are more expensive to use, because there is a look-up to do when you inherit from them.Abstract classes look a lot like interfaces, but they have something more: You can define a behavior for them. It\'s more about a guy saying, "these classes should look like that, and they have that in common, so fill in the blanks!".For example:While abstract classes and interfaces are supposed to be different concepts, the implementations make that statement sometimes untrue. Sometimes, they are not even what you think they are.In Java, this rule is strongly enforced, while in PHP, interfaces are abstract classes with no method declared.In Python, abstract classes are more a programming trick you can get from the ABC module and is actually using metaclasses, and therefore classes. And interfaces are more related to duck typing in this language and it\'s a mix between conventions and special methods that call descriptors (the __method__ methods).As usual with programming, there is theory, practice, and practice in another language :-)The key technical differences between an abstract class and an interface are:Abstract classes can have constants, members, method stubs (methods without a body) and defined methods, whereas interfaces can only have constants and methods stubs.Methods and members of an abstract class can be defined with any visibility, whereas all methods of an interface must be defined as public (they are defined public by default).When inheriting an abstract class, a concrete child class must define the abstract methods, whereas an abstract class can extend another abstract class and abstract methods from the parent class don\'t have to be defined.Similarly, an interface extending another interface is not responsible for implementing methods from the parent interface. This is because interfaces cannot define any implementation.A child class can only extend a single class (abstract or concrete), whereas an interface can extend or a class can implement multiple other interfaces.A child class can define abstract methods with the same or less restrictive visibility, whereas a class implementing an interface must define the methods with the exact same visibility (public).An Interface contains only the definition / signature of functionality, and if we have some common functionality as well as common signatures, then we need to use an abstract class. By using an abstract class, we can provide behavior as well as functionality both in the same time. Another developer inheriting abstract class can use this functionality easily, as they would only need to fill in the blanks.Taken from:http://www.dotnetbull.com/2011/11/difference-between-abstract-class-and.htmlhttp://www.dotnetbull.com/2011/11/what-is-abstract-class-in-c-net.html\nhttp://www.dotnetbull.com/2011/11/what-is-interface-in-c-net.htmlAn explanation can be found here: http://www.developer.com/lang/php/article.php/3604111/PHP-5-OOP-Interfaces-Abstract-Classes-and-the-Adapter-Pattern.htmAn abstract class is a class that is\n  only partially implemented by the\n  programmer. It may contain one or more\n  abstract methods. An abstract method\n  is simply a function definition that\n  serves to tell the programmer that the\n  method must be implemented in a child\n  class.An interface is similar to an abstract\n  class; indeed interfaces occupy the\n  same namespace as classes and abstract\n  classes. For that reason, you cannot\n  define an interface with the same name\n  as a class. An interface is a fully\n  abstract class; none of its methods\n  are implemented and instead of a class\n  sub-classing from it, it is said to\n  implement that interface.Anyway I find this explanation of interfaces somewhat confusing. A more common definition is: An interface defines a contract that implementing classes must fulfill. An interface definition consists of signatures of public members, without any implementing code.Some important differences:In the form of a table:As stated by Joe from javapapers: 1.Main difference is methods of a Java interface are implicitly abstract and cannot have implementations. A Java abstract class can\n  have instance methods that implements a default behavior.2.Variables declared in a Java interface is by default final. An  abstract class may contain non-final variables.3.Members of a Java interface are public by default. A Java abstract class can have the usual flavors of class members like private,\n  protected, etc..4.Java interface should be implemented using keyword \xe2\x80\x9cimplements\xe2\x80\x9d; A Java abstract class should be extended using keyword \xe2\x80\x9cextends\xe2\x80\x9d.5.An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java\n  interfaces.6.A Java class can implement multiple interfaces but it can extend only one abstract class.7.Interface is absolutely abstract and cannot be instantiated; A Java abstract class also cannot be instantiated, but can be invoked if a\n  main() exists.8.In comparison with java abstract classes, java interfaces are slow as it requires extra indirection.I don\'t want to highlight the differences, which have been already said in many answers ( regarding public static final modifiers for variables in interface & support for protected, private methods in abstract classes)In simple terms, I would like to say:interface: To implement a contract by multiple unrelated objectsabstract class: To implement the same or different behaviour among multiple related objectsFrom the Oracle documentationConsider using abstract classes if :Consider using interfaces if :abstract class establishes "is a" relation with concrete classes. interface provides "has a" capability for classes.If you are looking for Java as programming language, here are a few more updates:Java 8 has reduced the gap between interface and abstract classes to some extent by providing a default method feature. An interface does not have an implementation for a method is no longer valid now. Refer to this documentation page for more details. Have a look at this SE question for code examples to understand better.How should I have explained the difference between an Interface and an Abstract class?Let\'s work on this question again: The first thing to let you know is that 1/1 and 1*1 results in the same, but it does not mean that multiplication and division are same. Obviously, they hold some good relationship, but mind you both are different. I will point out main differences, and the rest have already been explained:Abstract classes are useful for modeling a class hierarchy. At first glance of any requirement, we are partially clear on what exactly is to be built, but we know what to build. And so your abstract classes are your base classes.Interfaces are useful for letting other hierarchy or classes to know that what I am capable of doing. And when you say I am capable of something, you must have that capacity. Interfaces will mark it as compulsory for a class to implement the same functionalities.The main point is that:When you want to provide polymorphic behaviour in an inheritance hierarchy, use abstract classes. When you want polymorphic behaviour for classes which are completely unrelated, use an interface.I am constructing a building of 300 floorsThe building\'s blueprint interfaceBuilding constructed up to 200 floors - partially completed---abstractBuilding construction completed-concreteInterfaceAbstractTaken from DurgaJobs WebsiteAn Abstract class without any implementation just looks like an Interface; however there are lot of differences than similarities between an Abstract class and an Interface. Let\'s explain both concepts and compare their similarities and differences.What is an Abstract Class?An abstract class is a special kind of class that cannot be instantiated. So the question is why we need a class that cannot be instantiated? An abstract class is only to be sub-classed (inherited from). In other words, it only allows other classes to inherit from it but cannot be instantiated. The advantage is that it enforces certain hierarchies for all the subclasses. In simple words, it is a kind of contract that forces all the subclasses to carry on the same hierarchies or standards.What is an Interface?An interface is not a class. It is an entity that is defined by the word Interface. An interface has no implementation; it only has the signature or in other words, just the definition of the methods without the body. As one of the similarities to Abstract class, it is a contract that is used to define hierarchies for all subclasses or it defines specific set of methods and their arguments. The main difference between them is that a class can implement more than one interface but can only inherit from one abstract class. Since C# doesn\xe2\x80\x99t support multiple inheritance, interfaces are used to implement multiple inheritance.Both TogetherWhen we create an interface, we are basically creating a set of methods without any implementation that must be overridden by the implemented classes. The advantage is that it provides a way for a class to be a part of two classes: one from inheritance hierarchy and one from the interface.When we create an abstract class, we are creating a base class that might have one or more completed methods but at least one or more methods are left uncompleted and declared abstract. If all the methods of an abstract class are uncompleted then it is same as an interface. The purpose of an abstract class is to provide a base class definition for how a set of derived classes will work and then allow the programmers to fill the implementation in the derived classes.There are some similarities and differences between an interface and an abstract class.\nIt\'s pretty simple actually.You can think of an interface as a class which is only allowed to have abstract methods and nothing else. So an interface can only "declare" and not define the behavior you want the class to have.An abstract class allows you to do both declare (using abstract methods) as well as define (using full method implementations) the behavior you want the class to have.And a regular class only allows you to define, not declare, the behavior/actions you want the class to have.One last thing,In Java, you can implement multiple interfaces, but you can only extend one (Abstract Class or Class)...This means inheritance of defined behavior is restricted to only allow one per class... ie if you wanted a class that encapsulated behavior from Classes A,B&C you would need to do the following: Class A extends B, Class C extends A .. its a bit of a round about way to have multiple inheritance...Interfaces on the other hand, you could simply do: interface C implements A, BSo in effect Java supports multiple inheritance only in "declared behavior" ie interfaces, and only single inheritance with defined behavior.. unless you do the round about way I described...Hopefully that makes sense.What is the difference between an interface and abstract class?Abstract ClassFor an abstract class, a method must be declared as abstract. An abstract\nmethod doesn\'t have an implementation.The Abstract methods can be declared with Access modifiers like public,\ninternal, protected, etc. When implementing these methods in a subclass, you must define them with the same (or a less restricted) visibility.Abstract classes can contain variables and concrete methods.A class can Inherit only one Abstract classMultiple inheritance is not possible for an Abstract class.InterfaceFor an interface, all the methods are abstract by default.\nSo one cannot declare variables or concrete methods in interfaces.All methods declared in an interface must be public.Interfaces cannot contain variables and concrete methods except\nconstants.A class can implement many interfacesMultiple interface inheritance is possible.An explanation can be found in Interface VS Abstract Class in PHP.Abstract classes are used to share functions. The interfaces are used to share how you have to do something.The comparison of interface vs. abstract class is wrong. There should be two other comparisons instead: 1) interface vs. class and 2) abstract vs. final class.Interface is a contract between two objects. E.g., I\'m a Postman and you\'re a Package to deliver. I expect you to know your delivery address. When someone gives me a Package, it has to know its delivery address:Class is a group of objects that obey the contract. E.g., I\'m a box from "Box" group and I obey the contract required by the Postman. At the same time I obey other contracts:Abstract class is a group of incomplete objects. They can\'t be used, because they miss some parts. E.g., I\'m an abstract GPS-aware box - I know how to check my position on the map:This class, if inherited/extended by another class, can be very useful. But by itself - it is useless, since it can\'t have objects. Abstract classes can be building elements of final classes.Final class is a group of complete objects, which can be used, but can\'t be modified. They know exactly how to work and what to do. E.g., I\'m a Box that always goes to the address specified during its construction:In most languages, like Java or C++, it is possible to have just a class, neither abstract nor final. Such a class can be inherited and can be instantiated. I don\'t think this is strictly in line with object-oriented paradigm, though.Again, comparing interfaces with abstract classes is not correct.The only difference is that one can participate in multiple inheritance and other cannot.The definition of an interface has changed over time. Do you think an interface just has method declarations only and are just contracts? What about static final variables and what about default definitions after Java 8?Interfaces were introduced to Java because of the diamond problem with multiple inheritance and that\'s what they actually intend to do.Interfaces are the constructs that were created to get away with the multiple inheritance problem and can have abstract methods, default definitions and static final variables.See Why does Java allow static final variables in interfaces when they are only intended to be contracts?.Interface: Turn ( Turn Left, Turn Right.)Abstract Class: Wheel.Class: Steering Wheel, derives from Wheel, exposes Interface TurnOne is for categorizing behavior that can be offered across a diverse range of things, the other is for modelling an ontology of things.Inheritance is used for two purposes:To allow an object to regard parent-type data members and method implementations as its own.To allow a reference to an objects of one type to be used by code which expects a reference to supertype object.In languages/frameworks which support generalized multiple inheritance, there is often little need to classify a type as either being an "interface" or an "abstract class".  Popular languages and frameworks, however, will allow a type to regard one other type\'s data members or method implementations as its own even though they allow a type to be substitutable for an arbitrary number of other types.Abstract classes may have data members and method implementations, but can only be inherited by classes which don\'t inherit from any other classes.  Interfaces put almost no restrictions on the types which implement them, but cannot include any data members or method implementations.There are times when it\'s useful for types to be substitutable for many different things; there are other times when it\'s useful for objects to regard parent-type data members and method implementations as their own.  Making a distinction between interfaces and abstract classes allows each of those abilities to be used in cases where it is most relevant.Key Points:Advantage:find details here...\nhttp://pradeepatkari.wordpress.com/2014/11/20/interface-and-abstract-class-in-c-oops/Here is a very basic understanding over interface vs abstract class.Not really the answer to the original question, but once you have the answer to the difference between them, you will enter the when-to-use-each dilemma:\nWhen to use interfaces or abstract classes? When to use both?I\'ve limited knowledge of OOP, but seeing interfaces as an equivalent of an adjective in grammar has worked for me until now (correct me if this method is bogus!). For example, interface names are like attributes or capabilities you can give to a class, and a class can have many of them: ISerializable, ICountable, IList, ICacheable, IHappy, ...In short the differences are the following:Syntactical Differences Between Interface and Abstract Class:The shortest way to sum it up is that an interface is:Meanwhile, an abstract class is:Or, if we want to boil it all down to a single sentence: An interface is what the implementing class has, but an abstract class is what the subclass is.Many junior developers make the mistake of thinking of interfaces, abstract and concrete classes as slight variations of the same thing, and choose one of them purely on technical grounds: Do I need multiple inheritance? Do I need some place to put common methods? Do I need to bother with something other than just a concrete class? This is wrong, and hidden in these questions is the main problem: "I". When you write code for yourself, by yourself, you rarely think of other present or future developers working on or with your code.Interfaces and abstract classes, although apparently similar from a technical point of view, have completely different meanings and purposes.An interface defines a contract that some implementation will fulfill for you.An abstract class provides a default behavior that your implementation can reuse.A concrete class does the actual work, in a very specific way. For example, an ArrayList uses a contiguous area of memory to store a list of objects in a compact manner which offers fast random access, iteration, and in-place changes, but is terrible at insertions, deletions, and occasionally even additions; meanwhile, a LinkedList uses double-linked nodes to store a list of objects, which instead offers fast iteration, in-place changes, and insertion/deletion/addition, but is terrible at random access. These two types of lists are optimized for different use cases, and it matters a lot how you\'re going to use them. When you\'re trying to squeeze performance out of a list that you\'re heavily interacting with, and when picking the type of list is up to you, you should carefully pick which one you\'re instantiating.On the other hand, high level users of a list don\'t really care how it is actually implemented, and they should be insulated from these details. Let\'s imagine that Java didn\'t expose the List interface, but only had a concrete List class that\'s actually what LinkedList is right now. All Java developers would have tailored their code to fit the implementation details: avoid random access, add a cache to speed up access, or just reimplement ArrayList on their own, although it would be incompatible with all the other code that actually works with List only. That would be terrible... But now imagine that the Java masters actually realize that a linked list is terrible for most actual use cases, and decided to switch over to an array list for their only List class available. This would affect the performance of every Java program in the world, and people wouldn\'t be happy about it. And the main culprit is that implementation details were available, and the developers assumed that those details are a permanent contract that they can rely on. This is why it\'s important to hide implementation details, and only define an abstract contract. This is the purpose of an interface: define what kind of input a method accepts, and what kind of output is expected, without exposing all the guts that would tempt programmers to tweak their code to fit the internal details that might change with any future update.An abstract class is in the middle between interfaces and concrete classes. It is supposed to help implementations share common or boring code. For example, AbstractCollection provides basic implementations for isEmpty based on size is 0, contains as iterate and compare, addAll as repeated add, and so on. This lets implementations focus on the crucial parts that differentiate between them: how to actually store and retrieve data.Interfaces are low-cohesion gateways between different parts of code. They allow libraries to exist and evolve without breaking every library user when something changes internally. It\'s called Application Programming Interface, not Application Programming Classes. On a smaller scale, they also allow multiple developers to collaborate successfully on large scale projects, by separating different modules through well documented interfaces.Abstract classes are high-cohesion helpers to be used when implementing an interface, assuming some level of implementation details. Alternatively, abstract classes are used for defining SPIs, Service Provider Interfaces.The difference between an API and an SPI is subtle, but important: for an API, the focus is on who uses it, and for an SPI the focus is on who implements it.Adding methods to an API is easy, all existing users of the API will still compile. Adding methods to an SPI is hard, since every service provider (concrete implementation) will have to implement the new methods. If interfaces are used to define an SPI, a provider will have to release a new version whenever the SPI contract changes. If abstract classes are used instead, new methods could either be defined in terms of existing abstract methods, or as empty throw not implemented exception stubs, which will at least allow an older version of a service implementation to still compile and run.Although Java 8 introduced default methods for interfaces, which makes the line between interfaces and abstract classes even blurrier, this wasn\'t so that implementations can reuse code, but to make it easier to change interfaces that serve both as an API and as an SPI (or are wrongly used for defining SPIs instead of abstract classes).A corollary: the other way around is often wrongly done: when using a thing, always try to use the most generic class/interface that you actually need. In other words, don\'t declare your variables as ArrayList theList = new ArrayList(), unless you actually have a very strong dependency on it being an array list, and no other type of list would cut it for you. Use List theList = new ArrayList instead, or even Collection theCollection = new ArrayList if the fact that it\'s a list, and not any other type of collection doesn\'t actually matter.By definition, interfaces cannot have an implementation for any methods, and member variables cannot be initialized.However, abstract classes can have methods implementated and member variables initialized.Use abstract classes when you expect changes in your contract, i.e., say in future you might need to add a new method.In this situation, if you decide to use an interface, when the interface is changed to include interface, your application will break when you dumped the new interface dll.To read in detail, visit difference between abstract class and a interface I\'d like to add one more difference which makes sense.\nFor example, you have a framework with thousands of lines of code. Now if you want to add a new feature throughout the code using a method enhanceUI(), then it\'s better to add that method in abstract class rather in interface. Because, if you add this method in an interface then you should implement it in all the implemented class but it\'s not the case if you add the method in abstract class.Differences between abstract class and interface on behalf of real implementation.Interface: It is a keyword and it is used to define the template or blue print of an object and it forces all the sub classes would follow the same prototype,as for as implementation, all the sub classes are free to implement the functionality as per it\'s requirement.Some of other use cases where we should use interface.Communication between two external objects(Third party integration in our application) done through Interface here Interface works as Contract.Abstract Class: Abstract,it is a keyword and when we use this keyword before any class then it becomes abstract class.It is mainly used when we need to define the template as well as some default functionality of an object that is followed by all the sub classes and this way it removes the redundant code and one more use cases where we can use abstract class, such as we want no other classes can directly instantiate an object of the class, only derived classes can use the functionality.Example of Abstract Class:Example Of Interface:You can find clear difference between interface and abstract class.InterfaceAbstract classAbstract class contains abstract and non-abstract methods.Does not force users to implement all methods when inherited the\nabstract class.Contains all kinds of variables including primitive and non-primitiveDeclare using abstract keyword.Methods and members of an abstract class can be defined with any\nvisibility.A child class can only extend a single class (abstract or concrete).Interfaces are generally the classes without logic just a signature. Whereas abstract classes are those having logic. Both support contract as interface all method should be implemented in the child class but in abstract only the abstract method should be implemented. When to use interface and when to abstract? Why use Interface?We would simply doFew days later we would need the area of rectangle, Square, Quadrilateral and so on. If so do we have to change the code every time and check if the instance is of square or circle or rectangle? Now what OCP says is CODE TO AN INTERFACE NOT AN IMPLEMENTATION. \nSolution would be:Now for area calculatorIsn\'t that more flexible? If we would code without interface we would check the instance for each shape redundant code.Now when to use abstract?Now abstract should be used when one doesn\'t need instance of that class, having similar logic, having need for the contract.An abstract class is a class whose object cannot be created or a class which cannot be instantiated.\nAn abstract method makes a class abstract. \nAn abstract class needs to be inherited in order to override the methods that are declared in the abstract class. \nNo restriction on access specifiers. \nAn abstract class can have constructor and other concrete(non abstarct methods ) methods in them but interface cannot have.An interface is a blueprint/template of methods.(eg. A house on a paper is given(interface house) and different architects will use their ideas to build it(the classes of architects implementing the house interface) . \nIt is a collection of abstract methods , default methods , static methods , final variables and nested classes.\nAll members will be either final or public , protected and private access specifiers are not allowed.No object creation is allowed. \nA class has to be made in order to use the implementing interface and also to  override the abstract method declared in the interface. An interface is a good example of loose coupling(dynamic polymorphism/dynamic binding)\nAn interface implements polymorphism and abstraction.It tells what to do but how to do is defined by the implementing class. \nFor Eg. There\'s a car company and it wants that some features to be same for all the car it is manufacturing so for that the company would be making an interface vehicle which will have those features and different classes of car(like Maruti Suzkhi , Maruti 800) will override those features(functions).Why interface when we already have abstract class?\nJava supports only multilevel and hierarchal inheritance but with the help of interface we can implement multiple inheritance. 