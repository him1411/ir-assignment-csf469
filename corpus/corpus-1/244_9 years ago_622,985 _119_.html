I want to do something like:And then make changes to the new object that are not reflected in the original object.I don\'t often need this functionality, so when it\'s been necessary, I\'ve resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.How can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?Whilst the standard practice is to implement the ICloneable interface (described here, so I won\'t regurgitate), here\'s a nice deep clone object copier I found on The Code Project a while ago and incorporated it in our stuff.As mentioned elsewhere, it does require your objects to be serializable.The idea is that it serializes your object and then deserializes it into a fresh object. The benefit is that you don\'t have to concern yourself about cloning everything when an object gets too complex.And with the use of extension methods (also from the originally referenced source):In case you prefer to use the new extension methods of C# 3.0, change the method to have the following signature:Now the method call simply becomes objectBeingCloned.Clone();.EDIT (January 10 2015) Thought I\'d revisit this, to mention I recently started using (Newtonsoft) Json to do this, it should be lighter, and avoids the overhead of [Serializable] tags. (NB @atconway has pointed out in the comments that private members are not cloned using the JSON method)The reason not to use ICloneable is not because it doesn\'t have a generic interface.  The reason not to use it is because it\'s vague.  It doesn\'t make clear whether you\'re getting a shallow or a deep copy; that\'s up to the implementer.Yes, MemberwiseClone makes a shallow copy, but the opposite of MemberwiseClone isn\'t Clone; it would be, perhaps, DeepClone, which doesn\'t exist.  When you use an object through its ICloneable interface, you can\'t know which kind of cloning the underlying object performs.  (And XML comments won\'t make it clear, because you\'ll get the interface comments rather than the ones on the object\'s Clone method.)What I usually do is simply make a Copy method that does exactly what I want.I wanted a cloner for very simple objects of mostly primitives and lists.  If your object is out of the box JSON serializable then this method will do the trick.  This requires no modification or implementation of interfaces on the cloned class, just a JSON serializer like JSON.NET.I prefer a copy constructor to a clone. The intent is clearer.After much much reading about many of the options linked here, and possible solutions for this issue, I believe all the options are summarized pretty well at Ian P\'s link (all other options are variations of those) and the best solution is provided by Pedro77\'s link on the question comments.So I\'ll just copy relevant parts of those 2 references here. That way we can have:First and foremost, those are all our options:Mr Venkat Subramaniam (redundant link here) explains in much detail why.All his article circles around an example that tries to be applicable for most cases, using 3 objects: Person, Brain and City. We want to clone a person, which will have its own brain but the same city. You can either picture all problems any of the other methods above can bring or read the article.This is my slightly modified version of his conclusion:Copying an object by specifying New followed by the class name often leads to code that is not extensible. Using clone, the application of prototype pattern, is a better way to achieve this. However, using clone as it is provided in C# (and Java) can be quite problematic as well. It is better to provide a protected (non-public) copy constructor and invoke that from the clone method. This gives us the ability to delegate the task of creating an object to an instance of a class itself, thus providing extensibility and also, safely creating the objects using the protected copy constructor.Hopefully this implementation can make things clear:Now consider having a class derive from Person.You may try running the following code:The output produced will be:Observe that, if we keep a count of the number of objects, the clone as implemented here will keep a correct count of the number of objects.Simple extension method to copy all the public properties. Works for any objects and does not require class to be [Serializable]. Can be extended for other access level.Well I was having problems using ICloneable in Silverlight, but I liked the idea of seralization, I can seralize XML, so I did this:If you\'re already using a 3rd party application like ValueInjecter or Automapper, you can do something like this:Using this method you don\'t have to implement ISerializable or ICloneable on your objects.  This is common with the MVC/MVVM pattern, so simple tools like this have been created.see the valueinjecter deep cloning solution on CodePlex.I\'ve just created CloneExtensions library project. It performs fast, deep clone using simple assignment operations generated by Expression Tree runtime code compilation.How to use it?Instead of writing your own Clone or Copy methods with a tone of assignments between fields and properties make the program do it for yourself, using Expression Tree. GetClone<T>() method marked as extension method allows you to simply call it on your instance:You can choose what should be copied from source to newInstance using CloningFlags enum:What can be cloned?Following class/struct members are cloned internally:How fast it is?The solution is faster then reflection, because members information has to be gathered only once, before GetClone<T> is used for the first time for given type T.It\'s also faster than serialization-based solution when you clone more then couple instances of the same type T.and more...Read more about generated expressions on documentation.Sample expression debug listing for List<int>:}what has the same meaning like following c# code:Isn\'t it quite like how you\'d write your own Clone method for List<int>?The short answer is you inherit from the ICloneable interface and then implement the .clone function. Clone should do a memberwise copy and perform a deep copy on any member that requires it, then return the resulting object. This is a recursive operation ( it requires that all members of the class you want to clone are either value types or implement ICloneable and that their members are either value types or implement ICloneable, and so on).For a more detailed explanation on Cloning using ICloneable, check out this article.The long answer is "it depends". As mentioned by others, ICloneable is not supported by generics, requires special considerations for circular class references, and is actually viewed by some as a "mistake" in the .NET Framework. The serialization method depends on your objects being serializable, which they may not be and you may have no control over. There is still much debate in the community over which is the "best" practice. In reality, none of the solutions are the one-size fits all best practice for all situations like ICloneable was originally interpreted to be.See the this Developer\'s Corner article for a few more options (credit to Ian).If you want true cloning to unknown types you can take a look at\nfastclone.That\'s expression based cloning working about 10 times faster than binary serialization and maintaining complete object graph integrity.That means: if you refer multiple times to the same object in your hierachy, the clone will also have a single instance beeing referenced.There is no need for interfaces, attributes or any other modification to the objects being cloned.Cheers.The best is to implement an extension method likeand then use it anywhere in the solution byWe can have the following three implementations:All linked methods are well working and were deeply tested.I came up with this to overcome a .NET shortcoming having to manually deep copy List<T>.I use this:And at another place:I tried to come up with oneliner that does this, but it\'s not possible, due to yield not working inside anonymous method blocks.Better still, use generic List<T> cloner:Here is a deep copy implementation:In other words, go with another answer unless you have a performance bottleneck that needs fixing, and you can prove it with a profiler.The following method of performing a deep clone is:For ultimate speed, you can use Nested MemberwiseClone to do a deep copy. Its almost the same speed as copying a value struct, and is much faster than (a) reflection or (b) serialization (as described in other answers on this page).Note that if you use Nested MemberwiseClone for a deep copy, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code below.Here is the output of the code showing the relative performance difference for 100,000 clones:Using Nested MemberwiseClone on a class almost as fast as copying a struct, and copying a struct is pretty darn close to the theoretical maximum speed .NET is capable of.To understand how to do a deep copy using MemberwiseCopy, here is the demo project that was used to generate the times above:Then, call the demo from main:Again, note that if you use Nested MemberwiseClone for a deep copy, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code above.Note that when it comes to cloning an object, there is is a big difference between a "struct" and a "class":See differences between value types and references types.One excellent use case for this code is feeding clones of a nested class or struct into a queue, to implement the producer / consumer pattern. This works extremely well in practice, and allows us to decouple many threads (the producers) from one or more threads (the consumers).And this method is blindingly fast too: if we use nested structs, it\'s 35x faster than serializing/deserializing nested classes, and allows us to take advantage of all of the threads available on the machine.Apparently, ExpressMapper is as fast, if not faster, than hand coding such as above. I might have to see how they compare with a profiler. Keep things simple and use AutoMapper as others mentioned, it\'s a simple little library to map one object to another... To copy an object to another with the same type, all you need is three lines of code:The target object is now a copy of the source object.\nNot simple enough? Create an extension method to use everywhere in your solution:By using the extension method, the three lines become one line:In general, you implement the ICloneable interface and implement Clone yourself.\nC# objects have a built-in MemberwiseClone method that performs a shallow copy that can help you out for all the primitives.For a deep copy, there is no way it can know how to automatically do it.I\'ve seen it implemented through reflection as well. Basically there was a method that would iterate through the members of an object and appropriately copy them to the new object. When it reached reference types or collections I think it did a recursive call on itself. Reflection is expensive, but it worked pretty well.As I couldn\'t find a cloner that meets all my requirements in different projects, I created a deep cloner that can be configured and adapted to different code structures instead of adapting my code to meet the cloners requirements. Its achieved by adding annotations to the code that shall be cloned or you just leave the code as it is to have the default behaviour. It uses reflection, type caches and is based on fasterflect. The cloning process is very fast for a huge amount of data and a high object hierarchy (compared to other reflection/serialization based algorithms). https://github.com/kalisohn/CloneBehaveAlso available as a nuget package:\nhttps://www.nuget.org/packages/Clone.Behave/1.0.0For example: The following code will deepClone Address, but only perform a shallow copy of the _currentJob field. This method solved the problem for me:Use it like this: MyObj a = DeepCopy(b);I like Copyconstructors like that:If you have more things to copy add themWe have seen a lot of ideas from serialization over manual implementation to reflection and I want to propose a totally different approach using the CGbR Code Generator. The generate clone method is memory and CPU efficient and therefor 300x faster as the standard DataContractSerializer.All you need is a partial class definition with ICloneable and the generator does the rest:Note: Latest version has a more null checks, but I left them out for better understanding.Here a solution fast and easy that worked for me without relaying on Serialization/Deserialization. EDIT:\nrequires That\'s How I used itI think you can try this.Follow these steps:For maximum inheritance versatility, classes exposing public cloning functionality should be sealed, but derive from a base class which is otherwise identical except for the lack of cloning.  Rather than passing variables of the explicit clonable type, take a parameter of type ICloneable<theNonCloneableType>.  This will allow a routine that expects a cloneable derivative of  Foo to work with a cloneable derivative of DerivedFoo, but also allow the creation of non-cloneable derivatives of Foo.I have created a version of the accepted answer that works with both \'[Serializable]\' and \'[DataContract]\'. It has been a while since I wrote it, but if I remember correctly [DataContract] needed a different serializer.Requires System, System.IO, System.Runtime.Serialization, System.Runtime.Serialization.Formatters.Binary, System.Xml;To clone your class object you can use the Object.MemberwiseClone method,just add this function to your class :then to perform a deep independant copy, just call the DeepCopy method :hope this helps.Ok, there are some obvious example with reflection in this post, BUT reflection is usually slow, until you start to cache it properly.if you\'ll cache it properly, than it\'ll deep clone 1000000 object by 4,6s (measured by Watcher).than you take cached properties or add new to dictionary and use them simplyfull code check in my post in another answerhttps://stackoverflow.com/a/34365709/4711853If your Object Tree is Serializeable you could also use something like thisbe informed that this Solution is pretty easy but it\'s not as performant as other solutions may be.And be sure that if the Class grows, there will still be only those fields cloned, which also get serialized.