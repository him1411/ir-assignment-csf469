I know references are syntactic sugar, so code is easier to read and write.But what are the differences?Summary from answers and links below:To clarify a misconception:The C++ standard is very careful to avoid dictating how a compiler must\n  implement references, but every C++ compiler implements\n  references as pointers. That is, a declaration such as:if it\'s not optimized away entirely, allocates the same amount of storage\n  as a pointer, and places the address\n  of i into that storage.So, a pointer and a reference both occupy the same amount of memory.As a general rule,Interesting read:A pointer can be re-assigned: A reference cannot, and must be assigned at initialization:A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on stack vs heap.  This implies that there is a real address of a reference that the compiler will not tell you. You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection. Pointer can be assigned nullptr directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference nullptr.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain nullptr.Pointers can iterate over an array, you can use ++ to go to the next item that a pointer is pointing to, and + 4 to go to the 5th element.  This is no matter what size the object is that the pointer points to.A pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses -> to access it\'s members whereas a reference uses a ..A pointer is a variable that holds a memory address.  Regardless of how a reference is implemented, a reference has the same memory address as the item it references.References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)Const references can be bound to temporaries. Pointers cannot (not without some indirection):This makes const& safer for use in argument lists and so forth.A reference can be thought of as a constant pointer (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the * operator for you.All references must be initialized with a non-null value or compilation will fail. It\'s neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.C++ programmers might dislike using pointers as they are considered unsafe - although references aren\'t really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.Consider the following statement from the C++ FAQ:Even though a reference is often implemented using an address in the\n  underlying assembly language, please do not think of a reference as a\n  funny looking pointer to an object. A reference is the object. It is\n  not a pointer to the object, nor a copy of the object. It is the\n  object.But if a reference really were the object, how could there be dangling references? In unmanaged languages, it\'s impossible for references to be any \'safer\' than pointers - there generally just isn\'t a way to reliably alias values across scope boundaries!Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection is convenient, and references become especially useful when dealing with RAII - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you\'d have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.If you want to be really pedantic, there is one thing you can do with a reference that you can\'t do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It\'s really a reference to a temporary object that now has the same lifetime as the reference. If you try this without the const it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.You forgot the most important part:member-access with pointers uses -> \nmember-access with references uses .foo.bar is clearly superior to foo->bar in the same way that vi is clearly superior to Emacs :-)Contrary to popular opinion, it is possible to have a reference that is NULL.Granted, it is much harder to do with a reference - but if you manage it, you\'ll tear your hair out trying to find it.Edit: a few clarifications.Technically, this is an invalid reference, not a null reference.  C++ doesn\'t support null references as a concept, as you might find in other languages.  There are other kinds of invalid references as well.The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I\'m not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That\'s what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn\'t take much debugging to figure it out.My example above is short and contrived. Here\'s a more real-world example.Edit: Some further thoughts.I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you\'re getting undefined behavior. It never makes sense to check for a null reference; for example you can try if(&bar==NULL)... but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler\'s view the comparison is always false - this is the essence of undefined behavior.The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here\'s an automated way to accomplish this.Apart from syntactic sugar, a reference is a const pointer (not pointer to a const thing, a const pointer). You must establish what it refers to when you declare the reference variable, and you cannot change it later.Actually, a reference is not really like a pointer.A compiler keeps "references" to variables, associating a name with a memory address; that\'s its job to translate any variable name to a memory address when compiling.When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that\'s why references cannot "point to null", because a variable cannot be, and not be.Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.Now some explanation of real code:Here you are not creating another variable that points to a; you are just adding another name to the memory content holding the value of a. This memory now has two names, a and b, and it can be addressed using either name.When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.As an example:An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no "reference" arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.Now do the same thing with pointersThe behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.A reference can never be NULL.While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.Consider these two program fragments. In the first, we assign one pointer to another:After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.At the highest-level, the idea of references is that they are transparent "aliases". Your computer may use an address to make them work, but you\'re not supposed to worry about that: you\'re supposed to think of them as "just another name" for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot "re-seat" references, have references to nothingness, or have pointers to references.A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself. This is based on the tutorial. What is written makes it more clear:Simply to remember that,What\'s more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.Look at the following statement,alias_Tom can be understood as an alias of a variable (different with typedef, which is alias of a type) Tom. It is also OK to forget the terminology of such statement is to create a reference of Tom.It doesn\'t matter how much space it takes up since you can\'t actually see any side effect (without executing code) of whatever space it would take up.On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.For example:will print:This is the language mechanism that allows ScopeGuard to work.A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn\'t possible. A reference to a pointer provides a cleaner syntax to modify the pointer.\nLook at this example:And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.Visit the following for more information about reference to pointer:As I said, a pointer to a reference isn\'t possible. Try the following program:There is one fundamental difference between pointers and references that I didn\'t see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in this article.Regards,\n&rzejAt the risk of adding to confusion, I want to throw in some input, I\'m sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:Which outputs this:If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:Which outputs this:Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout << str_ref; AFTER calling delete &str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it\'s no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up \'.\' and \'->\', etc.), assuming you don\'t try any nonsense like my examples above ;)Now regardless of how a compiler handles references, it will always have some kind of pointer under the hood, because a reference must refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term \'reference\').The only major rule that\'s important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it\'s contained in is constructed it\'s too late to define it).Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the headA reference is not another name given to some memory. It\'s a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:It internally becomesI use references unless I need either of these:Null pointers can be used as a\nsentinel value, often a cheap way to\navoid function overloading or use of\na bool.You can do arithmetic on a pointer.\nFor example, p += offset;This program might help in comprehending the answer of the question. This is a simple program of a reference "j" and a pointer "ptr" pointing to variable "x".Run the program and have a look at the output and you\'ll understand.Also, spare 10 minutes and watch this video: https://www.youtube.com/watch?v=rlJrrGV0iOgAnother difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.I can\'t say I\'m really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.Both references and pointers can be used to change local variables of one function inside another function. Both of them can also be used to save copying of big objects when passed as arguments to functions or returned from functions, to get efficiency gain.\nDespite above similarities, there are following differences between references and pointers.References are less powerful than pointers1) Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.3) A reference must be initialized when declared. There is no such restriction with pointersDue to the above limitations, references in C++ cannot be used for implementing data structures like Linked List, Tree, etc. In Java, references don\xe2\x80\x99t have above restrictions, and can be used to implement all data structures. References being more powerful in Java, is the main reason Java doesn\xe2\x80\x99t need pointers.References are safer and easier to use:1) Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don\xe2\x80\x99t refer to a valid location 2) Easier to use: References don\xe2\x80\x99t need dereferencing operator to access the value. They can be used like normal variables. \xe2\x80\x98&\xe2\x80\x99 operator is needed only at the time of declaration. Also, members of an object reference can be accessed with dot operator (\xe2\x80\x98.\xe2\x80\x99), unlike pointers where arrow operator (->) is needed to access members.Together with the above reasons, there are few places like copy constructor argument where pointer cannot be used. Reference must be used pass the argument in copy constructor. Similarly references must be used for overloading some operators like ++.Like a pointer, a reference is an alias for an object, is usually\n  implemented to hold a machine address of an object, and does not\n  impose performance overhead compared to pointers, but it differs from\n  a pointer in that:\xe2\x80\xa2 You access a reference with exactly the same syntax as the name of\n  an object.\xe2\x80\xa2 A reference always refers to the object to which it was initialized.\xe2\x80\xa2 There is no \xe2\x80\x98\xe2\x80\x98null reference,\xe2\x80\x99\xe2\x80\x99 and we may assume that a reference\n  refers to an object.The main use of references is for specifying arguments and return\n  values for functions in general and for overloaded operators in\n  particular.For example:Also, a reference that is a parameter to a function that is inlined may be handled differently than a pointer.Many compilers when inlining the pointer version one will actually force a write to memory (we are taking the address explicitly).  However, they will leave the reference in a register which is more optimal.Of course, for functions that are not inlined the pointer and reference generate the same code and it\'s always better to pass intrinsics by value than by reference if they are not modified and returned by the function.Maybe some metaphors will help; \nIn the context of your desktop screenspace -   Another interesting use of references is to supply a default argument of a user-defined type:The default flavor uses the \'bind const reference to a temporary\' aspect of references.The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&,*) operators, while references can be set upon initialization only(that\'s why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn\'t point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let\'s say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:But we can\xe2\x80\x99t have int& p = 0; and also int& p=5 ;.In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.Another difference is that pointer can point to another object however reference is always referencing to the same object, let\xe2\x80\x99s take this example:Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:I feel like there is yet another point that hasn\'t been covered here.  Unlike the pointers, references are syntactically equivalent to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).  While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:  Templates. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both T and T&.\n(or std::reference_wrapper<T> which still relies on an implicit cast\nto T&)\nTemplates that cover both T& and T&& are even more common.   Lvalues. Consider the statement str[0] = \'X\'; Without references it would only work for c-strings (char* str). Returning the character by reference allows user-defined classes to have the same notation.  Copy constructors. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.  Operator overloads. With references it is possible to introduce indirection to an operator call - say, operator+(const T& a, const T& b) while retaining the same infix notation. This also works for regular overloaded functions.  These points empower a considerable part of C++ and the standard library so this is quite a major property of references.A reference points to the place where the object is now. In applications that use managed memory this may not be where you saw it last. So for example using .Net CLR you could create an object (by reference) on the short term heap, and when you next look it\'s shifted in physical memory to the long-term heap. You won\'t see this happen as it\'s done by the garbage collector on a separate thread, and will usually take place between one application clock cycle and the next. You cannot get this address because it is not guarenteed as valid for use at any future time, and as pointed out elsewhere, it may not even exist for an integer or pointer held in a register.