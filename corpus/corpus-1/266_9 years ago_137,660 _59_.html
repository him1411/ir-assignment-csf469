I have been running StyleCop over some C# code, and it keeps reporting that my using statements should be inside the namespace.Is there a technical reason for putting the using statements inside instead of outside the namespace?There is actually a (subtle) difference between the two. Imagine you have the following code in File1.cs:Now imagine that someone adds another file (File2.cs) to the project that looks like this:The compiler searches Outer before looking at those using statements outside the namespace, so it finds Outer.Math instead of System.Math. Unfortunately (or perhaps fortunately?), Outer.Math has no PI member, so File1 is now broken.This changes if you put the using inside your namespace declaration, as follows:Now the compiler searches System before searching Outer, finds System.Math, and all is well.Some would argue that Math might be a bad name for a user-defined class, since there\'s already one in System; the point here is just that there is a difference, and it affects the maintainability of your code.It\'s also interesting to note what happens if Foo is in namespace Outer, rather than Outer.Inner. In that case, adding Outer.Math in File2 breaks File1 regardless of where the using goes. This implies that the compiler searches the innermost enclosing namespace before it looks at any using statements.This thread already has some great answers, but I feel I can bring a little more detail with this additional answer.First, remember that a namespace declaration with periods, like:is entirely equivalent to:If you wanted to, you could put using directives on all of these levels. (Of course, we want to have usings in only one place, but it would be legal according to the language.)The rule for resolving which type is implied, can be loosely stated like this: First search the inner-most "scope" for a match, if nothing is found there go out one level to the next scope and search there, and so on, until a match is found. If at some level more than one match is found, if one of the types are from the current assembly, pick that one and issue a compiler warning. Otherwise, give up (compile-time error).Now, let\'s be explicit about what this means in a concrete example with the two major conventions.(1) With usings outside:In the above case, to find out what type Ambiguous is, the search goes in this order:The other convention:(2) With usings inside:Now, search for the type Ambiguous goes in this order:(Note that MyCorp.TheProduct was a part of "3." and was therefore not needed between "4." and "5.".)Concluding remarksNo matter if you put the usings inside or outside the namespace declaration, there\'s always the possibility that someone later adds a new type with identical name to one of the namespaces which have higher priority.Also, if a nested namespace has the same name as a type, it can cause problems.It is always dangerous to move the usings from one location to another because the search hierarchy changes, and another type may be found. Therefore, choose one convention and stick to it, so that you won\'t have to ever move usings.Visual Studio\'s templates, by default, put the usings outside of the namespace (for example if you make VS generate a new class in a new file).One (tiny) advantage of having usings outside is that you can then utilize the using directives for a global attribute, for example [assembly: ComVisible(false)] instead of [assembly: System.Runtime.InteropServices.ComVisible(false)].Putting it inside the namespaces makes the declarations local to that namespace for the file (in case you have multiple namespaces in the file) but if you only have one namespace per file then it doesn\'t make much of a difference whether they go outside or inside the namespace.According to Hanselman - Using Directive and Assembly Loading... and other such articles there is technically no difference.My preference is to put them outside of namespaces.According the to StyleCop Documentation:SA1200: UsingDirectivesMustBePlacedWithinNamespace Cause \nA C# using directive is placed outside of a namespace element.Rule Description \nA violation of this rule occurs when a using directive or a using-alias directive is placed outside of a namespace element, unless the file does not contain any namespace elements.For example, the following code would result in two violations of this rule.The following code, however, would not result in any violations of this rule:This code will compile cleanly, without any compiler errors. However, it is unclear which version of the Guid type is being allocated. If the using directive is moved inside of the namespace, as shown below, a compiler error will occur:The code fails on the following compiler error, found on the line containing Guid g = new Guid("hello"); CS0576: Namespace \'Microsoft.Sample\' contains a definition conflicting with alias \'Guid\'The code creates an alias to the System.Guid type called Guid, and also creates its own type called Guid with a matching constructor interface. Later, the code creates an instance of the type Guid. To create this instance, the compiler must choose between the two different definitions of Guid. When the using-alias directive is placed outside of the namespace element, the compiler will choose the local definition of Guid defined within the local namespace, and completely ignore the using-alias directive defined outside of the namespace. This, unfortunately, is not obvious when reading the code.When the using-alias directive is positioned within the namespace, however, the compiler has to choose between two different, conflicting Guid types both defined within the same namespace. Both of these types provide a matching constructor. The compiler is unable to make a decision, so it flags the compiler error.Placing the using-alias directive outside of the namespace is a bad practice because it can lead to confusion in situations such as this, where it is not obvious which version of the type is actually being used. This can potentially lead to a bug which might be difficult to diagnose.Placing using-alias directives within the namespace element eliminates this as a source of bugs. Placing multiple namespace elements within a single file is generally a bad idea, but if and when this is done, it is a good idea to place all using directives within each of the namespace elements, rather than globally at the top of the file. This will scope the namespaces tightly, and will also help to avoid the kind of behavior described above.It is important to note that when code has been written with using directives placed outside of the namespace, care should be taken when moving these directives within the namespace, to ensure that this is not changing the semantics of the code. As explained above, placing using-alias directives within the namespace element allows the compiler to choose between conflicting types in ways that will not happen when the directives are placed outside of the namespace.How to Fix Violations\nTo fix a violation of this rule, move all using directives and using-alias directives within the namespace element.There is an issue with placing using statements inside the namespace when you wish to use aliases. The alias doesn\'t benefit from the earlier using statements and has to be fully qualified.Consider:versus:This can be particularly pronounced if you have a long-winded alias such as the following (which is how I found the problem):With using statements inside the namespace, it suddenly becomes:Not pretty.As Jeppe Stig Nielsen said, this thread already has great answers, but I thought this rather obvious subtlety was worth mentioning too.using directives specified inside namespaces can make for shorter code since they don\'t need to be fully qualified as when they\'re specified on the outside.The following example works because the types Foo and Bar are both in the same global namespace, Outer.Presume the code file Foo.cs:And Bar.cs:That may omit the outer namespace in the using directive, for short:It is a better practice if those default using i.e. "references" used in your source solution should be outside the namespaces and those that are "new added reference" is a good practice is you should put it inside the namespace. This is to distinguish what references are being added.