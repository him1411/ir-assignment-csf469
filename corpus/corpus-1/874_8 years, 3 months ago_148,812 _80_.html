I am running into some issues regarding the Authenticity Token in Rails, as I have many times now.But I really don\'t want to just solve this problem and go on. I would really like to understand the Authenticity token.\nWell, my question is, do you have some complete source of information on this subject or would you spend your time to explain in details here?When the user views a form to create, update, or destroy a resource, the Rails app creates a random authenticity_token, stores this token in the session, and places it in a hidden field in the form. When the user submits the form, Rails looks for the authenticity_token, compares it to the one stored in the session, and if they match the request is allowed to continue.Since the authenticity token is stored in the session, the client cannot know its value. This prevents people from submitting forms to a Rails app without viewing the form within that app itself.\nImagine that you are using service A, you logged into the service and everything is ok. Now imagine that you went to use service B, and you saw a picture you like, and pressed on the picture to view a larger size of it. Now, if some evil code was there at service B, it might send a request to service A (which you are logged into), and ask to delete your account, by sending a request to http://serviceA.com/close_account. This is what is known as CSRF (Cross Site Request Forgery).If service A is using authenticity tokens, this attack vector is no longer applicable, since the request from service B would not contain the correct authenticity token, and will not be allowed to continue.API docs describes details about meta tag:CSRF protection is turned on with the protect_from_forgery method,\n  which checks the token and resets the session if it doesn\'t match what\n  was expected. A call to this method is generated for new Rails\n  applications by default.\n  The token parameter is named authenticity_token by default. The name\n  and value of this token must be added to every layout that renders\n  forms by including csrf_meta_tags in the HTML head.Keep in mind, Rails only verifies not idempotent methods (POST, PUT/PATCH and DELETE). GET request are not checked for authenticity token. Why? because the HTTP specification states that GET requests is idempotent and should not create, alter, or destroy resources at the server, and the request should be idempotent (if you run the same command multiple times, you should get the same result every time).Also the real implementation is a bit more complicated as defined in the beginning, ensuring better security. Rails does not issue the same stored token with every form. Neither does it generate and store a different token every time. It generates and stores a cryptographic hash in a session and issues new cryptographic tokens, which can be matched against the stored one, every time a page is rendered. See request_forgery_protection.rbUse authenticity_token to protect your not idempotent methods (POST, PUT/PATCH, and DELETE). Also make sure not to allow any GET requests that could potentially modify resources on the server.EDIT: Check the comment by @erturne regarding GET requests being idempotent. He explains it in a better way than I have done here.The authenticity token is designed so that you know your form is being submitted from your website. It is generated from the machine on which it runs with a unique identifier that only your machine can know, thus helping prevent cross-site request forgery attacks.If you are simply having difficulty with rails denying your AJAX script access, you can useto generate the correct token when you are creating your form.You can read more about it in the documentation.The Authenticity Token is a countermeasure to Cross-Site Request Forgery (CSRF). What is CSRF, you ask?It\'s a way that an attacker can potentially hijack sessions without even knowing session tokens. Scenario:CSRF solution:The Authenticity Token is rails\' method to prevent \'cross-site request forgery (CSRF or XSRF) attacks\'.To put it simple, it makes sure that the PUT / POST / DELETE (methods that can modify content) requests to your web app are made from the client\'s browser and not from a third party (an attacker) that has access to a cookie created on the client side.since Authenticity Token is so important, and in Rails 3.0+ you can useto create anywhereMinimal attack example that would be preventedOn my website evil.com I convince you to submit the following form:If you are logged into your bank through session cookies, then the cookies would be sent and the transfer would be made without you even knowing it.That is were the CSRF token comes into play:So the form on an authentic browser would look like:Thus, my attack would fail, since it was not sending the authenticity_token parameter, and there is no way I could have guessed it since it is a huge random number.This prevention technique is called Synchronizer Token Pattern.The synchronizer token pattern works because of the Same Origin Policy: if I could make an XHR GET request to your bank from evil.com, and read the result, I would be able to just read a token and then make the request later. I have explained this further at: https://security.stackexchange.com/a/72569/53321I highly recommend you to read the OWASP guide, on this and any other security matter.How Rails sends the tokensCovered at: Rails: How Does csrf_meta_tag Work?Basically:HTML helpers like form_tag add a hidden field to the form for you if it\'s not a GET formAJAX is dealt with automatically by jquery-ujs, which reads the token from the meta elements added to your header by csrf_meta_tags (present in the default template), and adds it to any request made.uJS also tries to update the token in forms in outdated cached fragments.Other prevention approachesBeware the Authenticity Token mechanism can result in race conditions if you have multiple, concurrent requests from the same client. In this situation your server can generate multiple authenticity tokens when there should only be one, and the client receiving the earlier token in a form will fail on it\'s next request because the session cookie token has been overwritten.\nThere is a write up on this problem and a not entirely trivial solution here:\nhttp://www.paulbutcher.com/2007/05/race-conditions-in-rails-sessions-and-how-to-fix-them/Methods Where authenticity_token is requiredauthenticity_token is required in case of idempotent methods like post, put and delete, Because Idempotent methods are affecting to data.Why It is RequiredIt is required to prevent from evil actions. authenticity_token is stored in session, whenever a form is created on web pages for creating or updating to resources then a authenticity token is stored in hidden field and it sent with form on server. Before executing action user sent authenticity_token is cross checked with authenticity_token stored in session. If authenticity_token is same then process is continue otherwise it does not perform actions.The authenticity token is used to prevent Cross-Site Request Forgery attacks (CSRF). To understand the authenticity token, you must first understand CSRF attacks.Suppose that you are the author of bank.com. You have a form on your site that is used to transfer money to a different account with a GET request:A hacker could just send an HTTP request to the server saying GET /transfer?amount=$1000000&account-to=999999, right?Wrong. The hackers attack won\'t work. The server will basically think?Huh? Who is this guy trying to initiate a transfer. It\'s not the owner of the account, that\'s for sure.How does the server know this? Because there\'s no session_id cookie authenticating the requester.When you sign in with your username and password, the server sets a session_id cookie on your browser. That way, you don\'t have to authenticate each request with your username and password. When your browser sends the session_id cookie, the server knows:Oh, that\'s John Doe. He signed in successfully 2.5 minutes ago. He\'s good to go.A hacker might think:Hmm. A normal HTTP request won\'t work, but if I could get my hand on that session_id cookie, I\'d be golden.The users browser has a bunch of cookies set for the bank.com domain. Every time the user makes a request to the bank.com domain, all of the cookies get sent along. Including the session_id cookie.So if a hacker could get you to make the GET request that transfers money into his account, he\'d be successful. How could he trick you into doing so?\n With Cross Site Request Forgery.It\'s pretty simply, actually. The hacker could just get you to visit his website. On his website, he could have the following image tag:When the users browser comes across that image tag, it\'ll be making a GET request to that url. And since the request comes from his browser, it\'ll send with it all of the cookies associated with bank.com. If the user had recently signed in to bank.com... the session_id cookie will be set, and the server will think that the user meant to transfer $1,000,000 to account 999999!Well, just don\'t visit dangerous sites and you\'ll be fine.That isn\'t enough. What if someone posts that image to Facebook and it appears on your wall? What if it\'s injected into a site your visiting with a XSS attack?It\'s not so bad. Only GET requests are vulnerable.Not true. A form that sends a POST request can be dynamically generated. Here\'s the example from the Rails Guide on Security:When your ApplicationController has this:This:Is compiled into this:In particular, the following is generated:To protect against CSRF attacks, if Rails doesn\'t see the authenticity token sent along with a request, it won\'t consider the request safe.How is an attacker supposed to know what this token is? A different value is generated randomly each time the form is generated:A Cross Site Scripting (XSS) attack - that\'s how. But that\'s a different vulnerability for a different day.What is an authentication_token ?This is a random string used by rails application to make sure that the user is requesting or performing an action from the app page, not from another app or site.Why is an authentication_token is necessary ?To protect your app or site from cross-site request forgery.How to add an authentication_token to a form ?If you are generating a form using form_for tag an authentication_token is automatically added else you can use <%= csrf_meta_tag %>.