How does this C program work?It compiles as it is (tested on gcc 4.6.3). It prints the time when compiled. On my system:Source: sykes2 - A clock in one line, sykes2 author hintsSome hints: No compile warnings per default. Compiled with -Wall, the following warnings are emitted:Let\'s de-obfuscate it.Indenting:Introducing variables to untangle this mess:Note that -~i == i+1 because of twos-complement. Therefore, we haveNow, note that a[b] is the same as b[a], and apply the -~ == 1+ change again:Converting the recursion to a loop and sneaking in a bit more simplification:This outputs one character per iteration. Every 64th character, it outputs a newline. Otherwise, it uses a pair of data tables to figure out what to output, and puts either character 32 (a space) or character 33 (a !). The first table (">\'txiZ^(~z?") is a set of 10 bitmaps describing the appearance of each character, and the second table (";;;====~$::199") selects the appropriate bit to display from the bitmap.Let\'s start by examining the second table, int shift = ";;;====~$::199"[(i*2&8) | (i/64)];. i/64 is the line number (6 to 0) and i*2&8 is 8 iff i is 4, 5, 6 or 7 mod 8.if((i & 2) == 0) shift /= 8; shift = shift % 8 selects either the high octal digit (for i%8 = 0,1,4,5) or the low octal digit (for i%8 = 2,3,6,7) of the table value. The shift table ends up looking like this:or in tabular formNote that the author used the null terminator for the first two table entries (sneaky!).This is designed after a seven-segment display, with 7s as blanks. So, the entries in the first table must define the segments that get lit up.__TIME__ is a special macro defined by the preprocessor. It expands to a string constant containing the time at which the preprocessor was run, in the form "HH:MM:SS". Observe that it contains exactly 8 characters. Note that 0-9 have ASCII values 48 through 57 and : has ASCII value 58. The output is 64 characters per line, so that leaves 8 characters per character of __TIME__.7 - i/8%8 is thus the index of __TIME__ that is presently being output (the 7- is needed because we are iterating i downwards). So, t is the character of __TIME__ being output.a ends up equalling the following in binary, depending on the input t:Each number is a bitmap describing the segments that are lit up in our seven-segment display. Since the characters are all 7-bit ASCII, the high bit is always cleared. Thus, 7 in the segment table always prints as a blank. The second table looks like this with the 7s as blanks:So, for example, 4 is 01101010 (bits 1, 3, 5, and 6 set), which prints asTo show we really understand the code, let\'s adjust the output a bit with this table:This is encoded as "?;;?==? \'::799\\x07". For artistic purposes, we\'ll add 64 to a few of the characters (since only the low 6 bits are used, this won\'t affect the output); this gives "?{{?}}?gg::799G" (note that the 8th character is unused, so we can actually make it whatever we want). Putting our new table in the original code:we getjust as we expected. It\'s not as solid-looking as the original, which explains why the author chose to use the table he did.Let\'s format this for easier reading:So, running it with no arguments, _ (argc conventionally) is 1.  main() will recursively call itself, passing the result of -(~_) (negative bitwise NOT of _), so really it\'ll go 448 recursions (Only condition where _^448 == 0).Taking that, it\'ll print 7 64-character wide lines (the outer ternary condition, and 448/64 == 7).  So let\'s rewrite it a little cleaner:Now, 32 is decimal for ASCII space.  It either prints a space or a \'!\' (33 is \'!\', hence the \'&1\' at the end).  Let\'s focus on the blob in the middle:As another poster said, __TIME__ is the compile time for the program, and is a string, so there\'s some string arithmetic going on, as well as taking advantage of an array subscript being bidirectional:  a[b] is the same as b[a] for character arrays.This will select one of the first 8 characters in __TIME__.  This is then indexed into [">\'txiZ^(~z?"-48] (0-9 characters are 48-57 decimal).  The characters in this string must have been chosen for their ASCII values.  This same character ASCII code manipulation continues through the expression, to result in the printing of either a \' \' or \'!\' depending on the location within the character\'s glyph.Adding to the other solutions, -~x is equal to x+1 because ~x is equivalent to (0xffffffff-x). This is equal to (-1-x) in 2s complement, so -~x is -(-1-x) = x+1.I de-obfuscated  the modulo arithmetics as much as I could and removed the reccursionExpanding it a bit more: