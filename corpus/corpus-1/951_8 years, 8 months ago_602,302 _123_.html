I have the following enumeration:The problem however is that I need the word "FORMS" when I ask for AuthenticationMethod.FORMS and not the id 1.I have found the following solution for this problem (link):First I need to create a custom attribute called "StringValue":Then I can add this attribute to my enumerator:And of course I need something to retrieve that StringValue:Good now I\'ve got the tools to get a string value for an enumerator.\nI can then use it like this:Okay now all of these work like a charm but I find it a whole lot of work. I was wondering if there is a better solution for this.I also tried something with a dictionary and static properties but that wasn\'t better either.Try type-safe-enum pattern.Update\nExplicit (or implicit) type conversion can be done byadding static field with mappingfilling this mapping in instance constructorand adding user-defined type conversion operatorUse methodas in (Assume Shipper is a defined Enum)There are a bunch of other static methods on the Enum class worth investigating too... You can reference the name rather than the value by using ToString()The documentation is here:http://msdn.microsoft.com/en-us/library/16c1xs4z.aspx...and if you name your enums in Pascal Case (as I do - such as ThisIsMyEnumValue = 1 etc.) then you could use a very simple regex to print the friendly form:which can easily be called from any string:Outputs:Convert My Crazy Pascal Case Sentence To Friendly CaseThat saves running all the way around the houses creating custom attributes and attaching them to your enums or using lookup tables to marry an enum value with a friendly string and best of all it\'s self managing and can be used on any Pascal Case string which is infinitely more reusable. Of course, it doesn\'t allow you to have a different friendly name than your enum which your solution does provide.I do like your original solution though for more complex scenarios though.  You could take your solution one step further and make your GetStringValue an extension method of your enum and then you wouldn\'t need to reference it like StringEnum.GetStringValue...You could then access it easily straight from your enum instance:Unfortunately reflection to get attributes on enums is quite slow:See this question: Anyone know a quick way to get to custom attributes on an enum value?The .ToString() is quite slow on enums too.You can write extension methods for enums though:This isn\'t great, but will be quick and not require the reflection for attributes or field name.C#6 UpdateIf you can use C#6 then the new nameof operator works for enums, so nameof(MyEnum.WINDOWSAUTHENTICATION) will be converted to "WINDOWSAUTHENTICATION" at compile time, making it the quickest way to get enum names.Note that this will convert the explicit enum to an inlined constant, so it doesn\'t work for enums that you have in a variable. So:But...I use an extension method: Now decorate the enum with: When you call AuthenticationMethod.FORMS.ToDescription() you will get "FORMS".Just use the ToString() methodTo reference the string Tomato, just useI use the Description attribute from the System.ComponentModel namespace.  Simply decorate the enum and then use this code to retrieve it:As an example:This code nicely caters for enums where you don\'t need a "Friendly name" and will return just the .ToString() of the enum.I really like Jakub \xc5\xa0turc\'s answer, but it\'s shortcoming is that you cannot use it with a switch-case statement.  Here\'s a slightly modified version of his answer that can be used with a switch statement:So you get all of the benefits of Jakub \xc5\xa0turc\'s answer, plus we can use it with a switch statement like so:Very simple solution to this with .Net 4.0 and above. No other code is needed.To get the string about just use:  orThe value will be "Active" or "Archived".I use a combination of several of the suggestions above, combined with some caching.  Now, I got the idea from some code that I found somewhere on the net, but I can neither remember where I got it or find it.  So if anyone ever finds something that looks similar please comment with the attribution.Anyway, the usage involves the type converters, so if you are binding to the UI it \'just works\'.  You can extended with Jakub\'s pattern for quick code lookup by initializing from the type converter into the static methods.The base usage would look like thisThe code for the custom enum type converter follows:}I agree with Keith, but I can\'t vote up (yet).I use a static method and swith statement to return exactly what I want. In the database I store tinyint and my code only uses the actual enum, so the strings are for UI requirements. After numerous testing this resulted in the best performance and most control over the output.However, by some accounts, this leads to a possible maintenance nightmare and some code smell. I try to keep an eye for enums that are long and a lot of enums, or those that change frequently. Otherwise, this has been a great solution for me.As most of you, I really liked the selected answer by Jakub \xc5\xa0turc, but I also really hate to copy-paste code, and try to do it as little as I can.So I decided I wanted an EnumBase class from which most of the functionality is inherited/built-in, leaving me to focus on the content instead of behavior.The main problem with this approach is based on the fact that although Enum values are type-safe instances, the interaction is with the Static implementation of the Enum Class type.\nSo with a little help of generics magic, I think I finally got the correct mix.\nHope someone finds this as useful as I did.I\'ll start with Jakub\'s example, but using inheritance and generics:And here is the base class:How I solved this as an extension method:Enum:Usage (where o.OrderType is a property with the same name as the enum):Which gives me a string of "New Card" or "Reload" instead of the actual enum value NewCard and Refill.In your question you never said that you actually need the numeric value of the enum anywhere.If you do not and just need an enum of type string (which is not an integral type so can not be a base of enum) here is a way:you can use the same syntax as enum to reference itIt will be a bit slower than with numeric values (comparing strings instead of numbers) but on the plus side it is not using reflection (slow) to access the string.When I\'m confronted with this problem, there are a couple of questions that I try to find the answers to first:The simplest way to do this is with Enum.GetValue (and support round-tripping using Enum.Parse).  It\'s also often worth building a TypeConverter, as Steve Mitcham suggests, to support UI binding.  (It\'s not necessary to build a TypeConverter when you\'re using property sheets, which is one of the nice things about property sheets.  Though lord knows they have their own issues.)In general, if the answers to the above questions suggest that\'s not going to work, my next step is to create and populate a static Dictionary<MyEnum, string>, or possibly a Dictionary<Type, Dictionary<int, string>>.  I tend to skip the intermediate decorate-the-code-with-attributes step because what\'s usually coming down the pike next is the need to change the friendly values after deployment (often, but not always, because of localization).I wanted to post this as a comment to the post quoted below but couldn\'t because I don\'t have enough rep - so please don\'t down-vote. The code contained an error and I wanted to point this out to individuals trying to use this solution:should be Brillant!Option 1:and thenOption 2:If you think about the problem we\'re trying to solve, it\'s not an enum we need at all.  We need an object that allows a certain number of values to be associated with eachother; in other words, to define a class.Jakub \xc5\xa0turc\'s type-safe enum pattern is the best option I see here.Look at it:My variantCode looks a bit ugly, but usages of this struct are pretty presentative.Also, I think, if a lot of such enums required, code generation (e.g. T4) might be used.for me, the pragmatic approach is class inside class, sample:Here is yet another way to accomplish the task of associating strings with enums:This method is called like this:You can group related enums in their own struct. Since this method uses the enum type, you can use Intellisense to display the list of enums when making the GetString() call.You can optionally use the new operator on the DATABASE struct. Not using it means the strings List is not allocated until the first GetString() call is made.If I\'m understanding you correctly, you can simply use .ToString() to retrieve the name of the enum from the value (Assuming it\'s already cast as the Enum);\nIf you had the naked int (lets say from a database or something) you can first cast it to the enum.\nBoth methods below will get you the enum name.Keep in mind though, the second technique assumes you are using ints and your index is 1 based (not 0 based). The function GetNames also is quite heavy by comparison, you are generating a whole array each time it\'s called.\nAs you can see in the first technique, .ToString() is actually called implicitly.\nBoth of these are already mentioned in the answers of course, I\'m just trying to clarify the differences between them.old post but...The answer to this may actually be very simple. Use Enum.ToString() functionThere are 6 overloads of this function, you can use Enum.Tostring("F") or Enum.ToString() to return the string value. No need to bother with anything else. Here is a working DemoNote that this solution may not work for all compilers (this demo does not work as expected) but at least it works for the latest compiler.If you\'ve come here looking to implement a simple "Enum" but whose values are strings instead of ints, here is the simplest solution:Implementation:based on the MSDN: http://msdn.microsoft.com/en-us/library/cc138362.aspx str will be the names of the fieldsWell, after reading all of the above I feel that the guys have over complicated the issue of transforming enumerators into strings.\nI liked the idea of having attributes over enumerated fields but i think that attributes are mainly used for Meta-data, but in your case i think that all you need is some sort of localization.Now if we try to call the above method we can call it this way All you need to do is just create a resource file containing all the enumerator values and the corresponding stringsWhat is actually very nice about that is that it will be very helpful if you need your application to be localized, since all you need to do is just create another resource file with your new language! and Voe-la! When I am in a situation like that I propose the solution below.And as a consuming class you could have And using a bidirectional dictionary: \nBased on this (https://stackoverflow.com/a/255638/986160) assuming that the keys will be associated with single values in the dictionary and similar to (https://stackoverflow.com/a/255630/986160) but a bit more elegant. This dictionary is also enumerable and you can go back and forth from ints to strings. Also you don\'t have to have any string in your codebase with the exception of this class.A lot of great answers here but in my case did not solve what I wanted out of an "string enum", which was:1,2 & 4 can actually be solved with a C# Typedef of a string (since strings are switchable in c#)3 can be solved by static const strings. So if you have the same needs, this is the simplest approach:This allows for example:and Where CreateType can be called with a string or a type. However the downside is that any string is automatically a valid enum, this could be modified but then it would require some kind of init function...or possibly make they explicit cast internal?Now if an int value was important to you (perhaps for comparison speed), you could use some ideas from Jakub \xc5\xa0turc fantastic answer and do something a bit crazy, this is my stab at it:but of course "Types bob = 4;" would be meaningless unless you had initialized them first which would sort of defeat the point... But in theory TypeA == TypeB would be quicker...Use object Enum.Parse(System.Type enumType, string value, bool ignoreCase); got it from http://blogs.msdn.com/b/tims/archive/2004/04/02/106310.aspxMy answer, working on @user29964 \'s answer (which is by far the simplest and closest to a Enum) isusageExamplethis will return\n"vi,rank"