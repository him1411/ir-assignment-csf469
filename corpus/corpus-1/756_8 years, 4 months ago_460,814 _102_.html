How do I create a namespace in JavaScript so that my objects and functions aren\'t overwritten by other same-named objects and functions? I\'ve used the following:Is there a more elegant or succinct way of doing this?I like this:I use the approach found on the Enterprise jQuery site:Here is their example showing how to declare private & public properties and functions. Everything is done as a self-executing anonymous function.So if you want to access one of the public members you would just go skillet.fry() or skillet.ingredients.What\'s really cool is that you can now extend the namespace using the exact same syntax.The third, undefined argument is the source of the variable of value undefined. I\'m not sure if it\'s still relevant today, but while working with older browsers / JavaScript standards (ecmascript 5, javascript < 1.8.5 ~ firefox 4), the global-scope variable undefined is writable, so anyone could rewrite its value. The third argument (when not passed a value) creates a variable named undefined which is scoped to the namespace/function. Because no value was passed when you created the name space, it defaults to the value undefined.Another way to do it, which I consider it to be a little bit less restrictive than the object literal form, is this:The above is pretty much like the module pattern and whether you like it or not, it allows you to expose all your functions as public, while avoiding the rigid structure of an object literal.Is there a more elegant or succinct way of doing this?Yes. For example:then you can have I normally build it in a closure:My style over the years has had a subtle change since writing this, and I now find myself writing the closure like this:In this way I find the public API and implementation easier to understand. Think of the return statement as being a public interface to the implementation.Because you may write different files of JavaScript and later combine or not combine them in an application, each needs to be able to recover or construct the namespace object without damaging the work of other files...One file might intend to use the namespace namespace.namespace1:Another file might want to use the namespace namespace.namespace2:These two files can live together or apart without colliding.Here\'s how Stoyan Stefanov does it in his JavaScript Patterns book which I found to be very good (it also shows how he does comments that allows for auto-generated API documentation, and how to add a method to a custom object\'s prototype):I use this approach:External code can then be:This is a follow-up to user106826\'s link to Namespace.js. It seems the project moved to GitHub. It is now smith/namespacedotjs.I have been using this simple JavaScript helper for my tiny project and so far it seems to be light yet versatile enough to handle namespacing and loading modules/classes. It would be great if it would allow me to import a package into a namespace of my choice, not just the global namespace... sigh, but that\'s besides the point.It allows you to declare the namespace then define objects/modules in that namespace:Another option is to declare the namespace and its contents at once:For more usage examples, look at the example.js file in the source.Sample:You can optionally declare a local variable, same, like self and assign local.onTimeout if you want it to be private.You can declare a simple function to provide namespaces.I created namespace which is inspired by Erlang\'s modules. It is a very functional approach, but that is how I write my JavaScript code these days.It gives a closure a global namespace and exposes a defined set functions within that closure.I use the following syntax for the namespace.jsfiddle: http://jsfiddle.net/rpaul/4dngxwb3/1/After porting several of my libraries to different projects, and having to constantly be changing the top level (statically named) namespace, I\'ve switched to using this small (open source) helper function for defining namespaces.Description of the benefits are at my blog post.  You can grab the source code here.One of the benefits I really like is isolation between modules with respect to load order.  You can refer to an external module BEFORE it is loaded.  And the object reference you get will be filled in when the code is available.The Module pattern was originally defined as a way to provide both private and public encapsulation for classes in conventional software engineering.When working with the Module pattern, we may find it useful to define a simple template that we use for getting started with it. Here\'s one that covers name-spacing, public and private variables.In JavaScript, the Module pattern is used to further emulate the concept of classes in such a way that we\'re able to include both public/private methods and variables inside a single object, thus shielding particular parts from the global scope. What this results in is a reduction in the likelihood of our function names conflicting with other functions defined in additional scripts on the page.Advantageswhy is the Module pattern a good choice? For starters, it\'s a lot cleaner for developers coming from an object-oriented background than the idea of true encapsulation, at least from a JavaScript perspective.Secondly, it supports private data - so, in the Module pattern, public parts of our code are able to touch the private parts, however the outside world is unable to touch the class\'s private parts.DisadvantagesThe disadvantages of the Module pattern are that as we access both public and private members differently, when we wish to change visibility, we actually have to make changes to each place the member was used.We also can\'t access private members in methods that are added to the object at a later point. That said, in many cases the Module pattern is still quite useful and when used correctly, certainly has the potential to improve the structure of our application.The Revealing Module PatternNow that we\'re a little more familiar with the module pattern, let\xe2\x80\x99s take a look at a slightly improved version - Christian Heilmann\xe2\x80\x99s Revealing Module pattern.The Revealing Module pattern came about as Heilmann was frustrated with the fact that he had to repeat the name of the main object when we wanted to call one public method from another or access public variables.He also disliked the Module pattern\xe2\x80\x99s requirement for having to switch to object literal notation for the things he wished to make public.The result of his efforts was an updated pattern where we would simply define all of our functions and variables in the private scope and return an anonymous object with pointers to the private functionality we wished to reveal as public.An example of how to use the Revealing Module pattern can be found belowAdvantagesThis pattern allows the syntax of our scripts to be more consistent. It also makes it more clear at the end of the module which of our functions and variables may be accessed publicly which eases readability.DisadvantagesA disadvantage of this pattern is that if a private function refers to a public function, that public function can\'t be overridden if a patch is necessary. This is because the private function will continue to refer to the private implementation and the pattern doesn\'t apply to public members, only to functions.Public object members which refer to private variables are also subject to the no-patch rule notes above.You have got to check Namespace.js out!I\'m 7 years late to the party, but did quite a bit of work around this 8 years ago:It is important to be able to easily and efficiently create multiple nested namespaces to keep a complex web application organized and manageable, while respecting the JavaScript global namespace (preventing namespace pollution), and with not clobbering any existing objects in the namespace path while doing so.From the above, this was my circa-2008 solution:This isn\'t creating a namespace, but provides a function for creating namespaces.This can be condensed to a minified one-liner:Example of use:Or, as one statement:Either is then executed as:If you don\'t need support for legacy browsers, an updated version:Now, I\'d be leery of exposing namespace to the global namespace itself.  (Too bad the base language doesn\'t provide this for us!)  So I\'d typically use this myself in a closure, such as:In a larger application, this only needs to be defined once at the beginning of a page load (for client-based web apps).  Additional files can then reuse the namespace function if kept (included as "optional" in the above).  At worst, if this function is re-declared a few times - it\'s only a few lines of code, and less if minified.If you need the private scope:else if you won\'t ever use the private scope:My favorite pattern has become lately this:Of course, return can be at the end, but if only function declarations follow it, it\'s much easier to see what\'s the namespace all about, and what API is exposed.The pattern of using function expressions in such cases results in not being able to know what methods are exposed without going over the entire code.Quite a follow-up of Ionu\xc8\x9b G. Stan\'s answer, but showing the benefits of uncluttered code by using var ClassFirst = this.ClassFirst = function() {...}, which takes advantage of JavaScript\'s closure scoping for less namespace cluttering for classes in the same namespace.Output:I like Jaco Pretorius\' solution, but I wanted to make the "this" keyword a bit more useful by pointing it to the module/namespace object.\nMy version of skillet:We can use it independently in this way:If using a Makefile you can do this.I prefer to use a Makefile anyway once I get to about 1000 lines because I can effectively comment out large swaths of code by removing a single line in the makefile. It makes it easy to fiddle with stuff. Also, with this technique the namespace only appears once in the prelude so it\'s easy to change and you don\'t have to keep repeating it inside the library code.A shell script for live development in the browser when using a makefile:Add this as a make task \'go\' and you can \'make go\' to keep your build updated as you code.I\'ve written another namespacing library that works a bit more like packages / units do in other languages. It allows you to create a package of JavaScript code and the reference that package from other code:Only the second file needs to be included in the page. Its dependencies (file hello.js in this example) will automatically be loaded and the objects exported from those dependencies will be used to populate the arguments of the callback function.You can find the related project in Packages JS.My habit is to use function myName() as property storage, and then var myName as "method" holder...Whether this is legitimate enough or not, beat me! I am relying on my PHP logic all the time, and things simply work. :Dif (this !== that) myObj.fName1(); else myObj.fName2();You can also do it in a \'vice versa\' way to check before object creation which is much better:Reference to this: JavaScript: Creating Object with Object.create()In javascript there are no pre defined methods to use namespaces. In JavaScript we have to create our own methods to define NameSpaces. Here is a procedure we follow in Oodles technologies.Register a NameSpace\nFollowing is the function to register a name spaceTo register a Namespace just call the above function with the argument as name space separated by .(dot).\nFor Example\nLet your application name is oodles. You can make a namespace by following methodrBasically it will create your NameSpaces structure like below in backend:In the above function you have register a namespace calles "oodles.HomeUtilities" and "oodles.GlobalUtilities". To call these namespaces we make an variable i.e. var $OHU and var $OGU.These variables are nothing but an alias to Intializing the namespace.\nNow, Whenever you declare a function that belong to HomeUtilities you will declare it like following:Above is the function name initialization and it is put into an namespace $OHU. and to call this function anywhere in the script files. Just use following code.Similarly, with the another NameSpaces.Hope it helps.