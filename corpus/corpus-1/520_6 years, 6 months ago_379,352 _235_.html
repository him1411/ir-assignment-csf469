I\'m new to iOS and, Objective-C and the whole MVC paradigm and I\'m stuck with the following:I have a view that acts as a data entry form and I want to give the user the option to select multiple products. The products are listed on another view with a UITableView controller and I have enabled multiple selections.My question is, how do I transfer the data from one view to another? I will be holding the selections on the UITableView in an array, but how do I then pass that back to the previous data entry form view so it can be saved along with the other data to core data on submission of the form?I have surfed around and seen some people declare an array in the app delegate. I read something about Singletons but don\'t understand what these are and I read something about creating a data model.What would be the correct way of performing this and how would I go about it?This question seems to be very popular here on stackoverflow so I thought I would try and give a better answer to help out people starting in the world of iOS like me.I hope this answer is clear enough for people to understand and that I have not missed anything.Passing Data ForwardPassing data forward to a view controller from another view controller. You would use this method if you wanted to pass an object/value from one view controller to another view controller that you may be pushing on to a navigation stack.For this example we will have ViewControllerA and ViewControllerBTo pass a BOOL value from ViewControllerA to ViewControllerB we would do the following.in ViewControllerB.h create a property for the BOOLin ViewControllerA you need to tell it about ViewControllerB so use an Then where you want to load the view eg. didSelectRowAtIndex or some IBAction you need to set the property in ViewControllerB before you push it onto nav stack.This will set isSomethingEnabled in ViewControllerB to BOOL value YES.Passing Data Forward using SeguesIf you are using Storyboards you are most likely using segues and will need this procedure to pass data forward. This is similar to the above but instead of passing the data before you push the view controller, you use a method calledSo to pass a BOOL from ViewControllerA to ViewControllerB we would do the following:in ViewControllerB.h create a property for the BOOLin ViewControllerA you need to tell it about ViewControllerB so use anCreate a the segue from ViewControllerA to ViewControllerB on the storyboard and give it an identifier, in this example we\'ll call it "showDetailSegue"Next we need to add the method to ViewControllerA that is called when any segue is performed, because of this we need to detect which segue was called and then do something. In our example we will check for "showDetailSegue" and if thats performed we will pass our BOOL value to ViewControllerBIf you have your views embedded in a navigation controller you need to change the method above slightly to the followingThis will set isSomethingEnabled in ViewControllerB to BOOL value YES.Passing Data BackTo pass data back from ViewControllerB to ViewControllerA you need to use Protocols and Delegates or Blocks, the latter can be used as a loosely coupled mechanism for callbacks.To do this we will make ViewControllerA a delegate of ViewControllerB. This allows ViewControllerB to send a message back to ViewControllerA enabling us to send data back.For ViewControllerA to be delegate of ViewControllerB it must conform to ViewControllerB\'s protocol which we have to specify. This tells ViewControllerA which methods it must implement.In ViewControllerB.h, below the #import, but above @interface you specify the protocol.next still in the ViewControllerB.h you need to setup a delegate property and synthesize in ViewControllerB.mIn ViewControllerB we call a message on the delegate when we pop the view controller.That\'s it for ViewControllerB. Now in ViewControllerA.h, tell ViewControllerA to import ViewControllerB and conform to its protocol.In ViewControllerA.m implement the following method from our protocolBefore pushing viewControllerB to navigation stack we need to tell  ViewControllerB that ViewControllerA is its delegate, otherwise we will get an error.The M in MVC is for "Model" and in the MVC paradigm the role of model classes is to manage a program\'s data. A model is the opposite of a view -- a view knows how to display data, but it knows nothing about what to do with data, whereas a model knows everything about how to work with data, but nothing about how to display it. Models can be complicated, but they don\'t have to be -- the model for your app might be as simple as an array of strings or dictionaries.The role of a controller is to mediate between view and model. Therefore, they need a reference to one or more view objects and one or more model objects. Let\'s say that your model is an array of dictionaries, with each dictionary representing one row in your table. The root view for your app displays that table, and it might be responsible for loading the array from a file. When the user decides to add a new row to the table, they tap some button and your controller creates a new (mutable) dictionary and adds it to the array. In order to fill in the row, the controller creates a detail view controller and gives it the new dictionary. The detail view controller fills in the dictionary and returns. The dictionary is already part of the model, so nothing else needs to happen.Updated for Swift 3There are tons and tons of explanations here and around StackOverflow, but if you are a beginner just trying to get something basic to work, try watching this YouTube tutorial (It\'s what helped me to finally understand how to do it).The following is an example based on the video. The idea is to pass a string from the text field in the First View Controller to the label in the Second View Controller.Create the storyboard layout in the Interface Builder. To make the segue, you just Control click on the button and drag over to the Second View Controller.First View ControllerThe code for the First View Controller isSecond View ControllerAnd the code for the Second View Controller isDon\'t forgetTo pass data back from the second view controller to the first view controller, you use a protocol and a delegate. This video is a very clear walk though of that process:The following is an example based on the video (with a few modifications).Create the storyboard layout in the Interface Builder. Again, to make the segue, you just Control drag from the button to the Second View Controller. Set the segue identifier to showSecondViewController. Also, don\'t forget to hook up the outlets and actions using the names in the following code.First View ControllerThe code for the First View Controller isNote the use of our custom DataEnteredDelegate protocol.Second View Controller and ProtocolThe code for the second view controller isNote that the protocol is outside of the View Controller class.That\'s it. Running the app now you should be able to send data back from the second view controller to the first.There are various ways by which a data can be received to a different class in iOS. For example - But for the simple scenario of passing a value to a different class whose allocation is done in the current class, the most common and preferred method would be the direct setting of values after allocation. This is done as follows:-We can understand it using two controllers - Controller1 and Controller2 Suppose in Controller1 class you want to create the Controller2 object and push it with a String value being passed. This can be done as this:-In the implementation of the Controller2 class there will be this function as- You can also directly set the properties of the Controller2 class in the similar way as this:To pass multiple values you can use the multiple parameters like :-Or if you need to pass more than 3 parameters which are related to a common feature you can store the values to a Model class and pass that modelObject to the next classSo in-short if you want to -Hope this helpsAfter more research it seemed that Protocols and Delegates is the correct/Apple prefered way of doing this.I ended up using this exampleSharing data between view controllers and other objects @ iPhone Dev SDKWorked fine and allowed me to pass a string and an array forward and back between my views.Thanks for all your helpI find simplest and most elegant version with passing blocks.\nLet\'s name view controller that waits for returned data as "A" and returning view controller as "B". In this example we want to get 2 values: first of Type1 and second of Type2.Assuming we use Storyboard, first controller sets callback block, for example during segue preparation:and "B" view controller should declare callback property, BViewController.h:Than in implementation file BViewController.m after we have desired values to return our callback should be called:One thing to remember is that using block often needs to manage strong and __weak references  like explained hereThere is some good information in many of the answers given, but none address the question fully.The question asks about passing information between view controllers. The specific example given asks about passing information between views, but given the self-stated newness to iOS, the original poster likely meant between viewControllers, not between views (without any involvement from the ViewControllers). It seems that all the answers focus on two view controllers, but what if the app evolves to need to involve more than two view controllers in the information exchange? The original poster also asked about Singletons and the use of the AppDelegate. These questions need to be answered.To help anyone else looking at this question, who wants a full answer, I\'m going to attempt to provide it.Application ScenariosRather than having a highly hypothetical, abstract discussion, it helps to have concrete applications in mind. To help define a two-view-controller situation and a more-than-two-view-controller situation, I am going to define two concrete application scenarios.Scenario one: maximum two view controllers ever need to share information.\nSee diagram one. There are two view controllers in the application. There is a ViewControllerA (Data Entry Form), and View Controller B (Product List). The items selected in the product list must match the items displayed in the text box in the data entry form. In this scenario, ViewControllerA and ViewControllerB must communicate directly with each other and no other view controllers. Scenario two: more than two view controllers need to share the same information.\nSee diagram two.There are four view controllers in the application. It is a tab-based application for managing home inventory. Three view controllers present differently filtered views of the same data:Any time an individual item is created or edited, it must also synchronize with the other view controllers. For example, if we add a boat in ViewControllerD, but it is not yet insured, then the boat must appear when the user goes to ViewControllerA (Luxury Items), and also ViewControllerC (Entire Home Inventory), but not when the user goes to ViewControllerB (Non-insured Items). We need be concerned with not only adding new items, but also deleting items (which may be allowed from any of the four view controllers), or editing existing items (which may be allowed from the "Add New Item Form", repurposing the same for for editing).Since all the view controllers do need to share the same data, all four view controllers need to remain in synchronization, and therefore there needs to be some sort of communication to all other view controllers, whenever any single view controller changes the underlying data. It should be fairly obvious that we do not want each view controller communicating directly with each other view controller in this scenario. In case it is not obvious, consider if we had 20 different view controllers (rather than just 4). How difficult and error prone would it be to notify each of the other 19 view controllers any time one view controller made a change?The Solutions: Delegates and the Observer Pattern, and SingletonsIn scenario one, we have several viable solutions, as other answers have givenIn scenario two, we have other viable solutions:A singleton is an instance of a class, that instance being the only instance in existence during its lifetime. A singleton gets its name from the fact that it is the single instance. Normally developers who use singletons have special class methods for accessing them. Now that we understand what a singleton is, let\'s discuss how a singleton fits into the observer pattern. The observer pattern is used for one object to respond to changes by another object. In the second scenario, we have four different view controllers, who all want to know about changes to the underlying data. The "underlying data" should belong to a single instance, a singleton. The "know about changes" is accomplished by observing changes made to the singleton.The home inventory application would have a single instance of a class which is designed to manage a list of inventory items. The manager would manage a collection of household items. The following is a class definition for the data manager:When the collection of home inventory items changes, the view controllers need to be made aware of this change. The class definition above does not make it obvious how this will happen. We need to follow the observer pattern. The view controllers must formally observe the sharedManager. There are two ways to observe another object:In scenario two, we do not have a single property of the HouseholdInventoryManager which could be observed using KVO. Because we do not have a single property which is easily observable, the observer pattern in this case must be implemented using NSNotificationCenter. Each of the four view controllers would subscribe to notifications, and the sharedManager would send notifications to the notification center when appropriate. The inventory manager does not need to know anything about the view controllers or instances of any other classes which may be interested in knowing when the collection of inventory items changes; the NSNotificationCenter takes care of these implementation details. The View Controllers simply subscribe to notifications, and the data manager simply posts notifications.Many beginner programmers take advantage of the fact that there is always exactly one Application Delegate in the lifetime of the application, which is globally accessible. Beginning programmers use this fact to stuff objects and functionality into the appDelegate as a convenience for access from anywhere else in the application. Just because the AppDelegate is a singleton doesn\'t mean it should replace all other singletons. This is a poor practice as it places too much burden on one class, breaking good object oriented practices. Each class should have a clear role that is easily explained, often just by the name of the class.Any time your Application Delegate starts to get bloated, start to remove functionality into singletons. For example, the Core Data Stack should not be left in the AppDelegate, but should instead be put in its own class, a coreDataManager class. ReferencesThere are multiple methods for sharing data.You can always share data using NSUserDefaults. Set the value you want to share with respect to a key of your choice and get the value from NSUserDefault associated to that key in the next view controller. You can just create a property in viewcontrollerA. Create an object of viewcontrollerA in viewcontrollerB and assign the desired value to that property.You can also create custom delegates for this.Passing data back from ViewController 2(destination) to viewController 1(Source) is the more interesting thing.\nAssuming you use storyBoard those are all the ways i found out:Those were  discussed here already.I found there are more ways:-Using Block callbacks:use it in the prepareForSegue method in the VC1-Using storyboards Unwind (Exit)Implement a method with a    UIStoryboardSegue argument in  VC 1,    like this one:In the storyBoard hook the "return" button to the green Exit\nbutton(Unwind) of the vc.\n Now you have a segue that "goes back" so u can use the\ndestinationViewController property in the prepareForSegue of VC2 and\nchange any property of VC1 before it goes back.Another option of using storyboards Undwind (Exit)  - you can\nuse the method you wrote in VC1And in the prepareForSegue of VC1 you can change any property you want to share.In both unwind options you can set the tag property of the button and check it in\n        the prepareForSegue. Hope i added something to the discussion. :) Cheers.The OP didn\'t mention view controllers but so many of the answers do, that I wanted to chime in with what some of the new features of the LLVM allow to make this easier when wanting to pass data from one view controller to another and then getting some results back.Storyboard segues, ARC and LLVM blocks make this easier than ever for me.  Some answers above mentioned storyboards and segues already but still relied on delegation.  Defining delegates certainly works but some people may find it easier to pass pointers or code blocks.With UINavigators and segues, there are easy ways of passing information to the subservient controller and getting the information back.  ARC makes passing pointers to things derived from NSObjects simple so if you want the subservient controller to add/change/modify some data for you, pass it a pointer to a mutable instance.  Blocks make passing actions easy so if you want the subservient controller to invoke an action on your higher level controller, pass it a block.  You define the block to accept any number of arguments that makes sense to you.  You can also design the API to use multiple blocks if that suits things better.Here are two trivial examples of the segue glue.  The first is straightforward showing one parameter passed for input, the second for output.This second example shows passing a callback block for the second argument.  I like using blocks because it keeps the relevant details close together in the source - the higher level source.If you want to pass data from one controller to other try this codeFirstViewController.hSecondViewController.hFirstViewController.mI was searching this solution for long time, Atlast I found it. First of all declare all the objects in your SecondViewController.h file likeNow in your implementation file allocate the memory for those objects like thisNow you have allocated the memory for Array and object. now you can fill that memory before pushing this ViewControllerGo to your SecondViewController.h and write two methodsin implementation file you can implement the function expecting that your CustomObject must have a setter function with it.now your basic work is done. go to the place where you want to push the SecondViewController and do the following stuffTake care for spelling mistakes. This is not the way to do it, you should use delegates, I\'ll assume we have two view controllers ViewController1 and ViewController2 and this check thing is in the first one and when its state changes, you want to do something in ViewController2, to achieve that in the proper way, you should do the below:Add a new file to your project (Objective-C Protocol) File -> New, now name it ViewController1Delegate or whatever you want and write these between the @interface and @end directivesNow go to ViewController2.h and addthen change its definition toNow go to ViewController2.m and inside the implementation add:Now go to ViewController1.h and add the following property:Now if you are creating ViewController1 inside ViewController2 after some event, then you should do it this way using NIB files:Now you are all set, whenever you detect the event of check changed in ViewController1, all you have to do is the belowPlease tell me if there\'s anything that\'s not clear of if I didn\'t understand your question properly.If you want to send data from one to another viewController, here\'s a way to it:Say we have viewControllers: viewControllerA and viewControllerBNow in viewControllerB.hIn viewControllerB.mIn viewControllerA.m So this is how you can pass data from viewControllerA to viewControllerB without setting any delegate. ;)1. Create the instance of first View Controller in the second View Controller and make its property @property (nonatomic,assign).2. Assign the SecondviewController instance of this view controller.2. When you finish the selection operation copy the array to first View Controller,When u unload the SecondView ,FirstView will hold the Array Data.Hope This Helps.Passing Data between FirstViewController to SecondViewController as belowFor example: FirstViewController String value asso we can pass this value in second class using below step1>We need to crate string object in SecondViewController.h file2>Need to declare property as below below declaration in .h file 3>Need synthesize that value in FirstViewController.m file below header declarationand in FirstViewController.h :4>In FirstViewController,From which method we navigate to second view please write below code in that method. I am currently contributing to an open source solution to this problem through a project called MCViewFactory, which may be found here:https://github.com/YetiHQ/manticore-iosviewfactoryThe idea is imitate Android\'s intent paradigm, using a global factory to manage which view you are looking at and using "intents" to switch and pass data between views. All the documentation is on the github page, but here are some highlights:You setup all your views in .XIB files and register them in the app delegate, while initializing the factory.Now, in your VC, anytime you want to move to a new VC and pass data, you create a new intent and add data to its dictionary (savedInstanceState). Then, just set the current intent of factory:All of your views that conform to this need to be subclasses of MCViewController, which allow you to override the new onResume: method, allowing you access to the data you\'ve passed in.Hope some of you find this solution useful/interesting.  In my case I used a singleton class which can work as a global object allowing accesses to the data from almost everywhere in the app. First thing is to build a singleton class. Please refer to the page," What should my Objective-C singleton look like? "\nAnd what I did to make the object globally accessible was simply import it in appName_Prefix.pch which is for applying import statement in every classes.\nTo access this object and to use, I simply implemented class method to return the shared instance, which contains its own variablesCreate the property on next view controller .h and define getter and setter.Add this property in NextVC.h on nextVCAdd @synthesize  indexNumber;           in NextVC.mAnd lastI know this is a beaten subject but for those looking to answer this question with a SWIFT slant and want a bare-bones example, here my go-to method for passing data if you are using a segue to get around.It is similar to the above but without the buttons, labels and such.  Just simply passing data from one view to the next.Setup The StoryboardThere are three parts.  This is a very simple view layout with a segue between them.Here is the setup for the senderHere is the setup for the receiver.Lastly, the setup for the segue.The View ControllersWe are keeping this simple so no buttons, not actions, we are simply moving data from the sender to the receiver when the application loads and then outputting the transmitted value to the console.This page takes the initially loaded value and passes it along.This page just sends the value of the variable to the console when it loads.  By this point our favorite movie should be in that variable.That is how you can tackle it if you want to use a segue and you don\'t have your pages under a navigation controller.Once it is run it should switch to the receiver view automatically and pass the value from the sender to the receiver, displaying the value in the console.NewsViewControllerNewsDetailViewController.hNewsDetailViewController.mDelegation is the only one solution to perform such operations when you are using .xib files however all answers described above are for storyboard for .xibs files you need to use delegation. that\'s only solution you can. Another solution is use singleton class pattern initialize it once and use it in your entire app.  if you wants to pass data from ViewControlerOne to ViewControllerTwo try these.. do these in ViewControlerOne.hdo these in ViewControllerTwo.hSynthesize str2 in ViewControllerTwo.mdo these in ViewControlerOne.mon the buttons click event do this..do these in ViewControllerTwo.mYou can save data in App delegate to access it across view controllers in your application. All you have to do is create a shared instance of app delegateFor Exampleif you declare a NSArray object *arrayXYZ then you can access it in any view controller by appDelegate.arrayXYZThere are tons of ways to do this and its important to pick the right one. Probably one of the biggest architectural decisions lies on how model code will be shared or accessed throughout the app.I wrote a blog post about this a while back: Sharing Model Code. Here\'s a brief summary:One approach is to share pointers to the model objects between view controllers. Since prepare for segue is the most common here is an example:Another approach is to handle a screen full of data at a time and instead of coupling the view controllers to each other couple each view controller to single data source that they can get to independently. The most common way I\'ve seen this done is through a singleton instance. So if your singleton object was dataAccess you could do the following in the viewDidLoad method of UIViewController:There are addition tools that also help pass along data:The nice thing about Core Data is that it has inverse relationships. So if you want to just give a NotesViewController the notes object you can because it\'ll have an inverse relationship to something else like notebook. If you need data on the notebook in the NotesViewController you can walk back up the object graph by doing the following:Read more about this on my blog post: Sharing Model CodeIf you want to send data from one to another viewController, here\'s a way to it:Say we have viewControllers: ViewController and NewViewController.in ViewController.hin ViewController.mIn NewViewController.hIn NewViewController.mSo this way we can pass the data from one viewcontroller to another view controller...I like the idea of Model objects and Mock objects based on NSProxy to commit or discard data if what user selects can be cancelled. It\'s easy to pass data around since it\'s single object or couple of objects and if you have let\'s say UINavigationController controller, you can keep the reference to model inside and all pushed view controllers can access it directly from navigation controller.I have seen a lot of people over complicating this using the didSelectRowAtPath method. I am using Core Data in my example.4 lines of code inside the method and you are done. There are many answers to this questions offering many different ways to perform view controller communication that would indeed work, but I don\'t see anywhere mentioned which one are actually best to use and which ones to avoid.These solutions, although working in the short term, introduce too many dependencies that will garble the architecture of the app and create more problems later.For those interested, I wrote some articles that address these points more in depth and highlight the various drawbacks:This is a really great tutorial for anyone that wants one. Here is the example code: