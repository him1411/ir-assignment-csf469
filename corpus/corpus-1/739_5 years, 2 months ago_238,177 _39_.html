In the "Create Components" section of AngularJS\'s homepage, there is this example:Notice how the select method is added to $scope, but the addPane method is added to this. If I change it to $scope.addPane, the code breaks.The documentation says that there in fact is a difference, but it doesn\'t mention what the difference is:Previous versions of Angular (pre 1.0 RC) allowed you to use this interchangeably with the $scope method, but this is no longer the case. Inside of methods defined on the scope this and $scope are interchangeable (angular sets this to $scope), but not otherwise inside your controller constructor.How does this and $scope work in AngularJS controllers?"How does this and $scope work in AngularJS controllers?"Short answer:Long answer:A controller function is a JavaScript constructor function.  When the constructor function executes (e.g., when a view loads), this (i.e., the "function context") is set to the controller object. So in the "tabs" controller constructor function, when the addPane function is createdit is created on the controller object, not on $scope.  Views cannot see the addPane function -- they only have access to functions defined on $scope.  In other words, in the HTML, this won\'t work:After the "tabs" controller constructor function executes, we have the following:The dashed black line indicates prototypal inheritance -- an isolate scope prototypically inherits from Scope.  (It does not prototypically inherit from the scope in effect where the directive was encountered in the HTML.)Now, the pane directive\'s link function wants to communicate with the tabs directive (which really means it needs to affect the tabs isolate $scope in some way).  Events could be used, but another mechanism is to have the pane directive require the tabs controller.  (There appears to be no mechanism for the pane directive to require the tabs $scope.)So, this begs the question: if we only have access to the tabs controller, how do we get access to the tabs isolate $scope (which is what we really want)?Well, the red dotted line is the answer.  The addPane() function\'s "scope" (I\'m referring to JavaScript\'s function scope/closures here) gives the function access to the tabs isolate $scope.  I.e., addPane() has access to the "tabs IsolateScope" in the diagram above because of a closure that was created when addPane() was defined.  (If we instead defined addPane() on the tabs $scope object, the pane directive would not have access to this function, and hence it would have no way to communicate with the tabs $scope.)To answer the other part of your question: how does $scope work in controllers?:Within functions defined on $scope, this is set to "the $scope in effect where/when the function was called".  Suppose we have the following HTML:And the ParentCtrl (Solely) hasClicking the first link will show that this and $scope are the same, since "the scope in effect when the function was called" is the scope associated with the ParentCtrl.Clicking the second link will reveal this and $scope are not the same, since "the scope in effect when the function was called" is the scope associated with the ChildCtrl.  So here, this is set to ChildCtrl\'s $scope.  Inside the method, $scope is still the ParentCtrl\'s $scope.FiddleI try to not use this inside of a function defined on $scope, as it becomes confusing which $scope is being affected, especially considering that ng-repeat, ng-include, ng-switch, and directives can all create their own child scopes.The reason \'addPane\' is assigned to this is because of the <pane> directive.The pane directive does require: \'^tabs\', which puts the tabs controller object from a parent directive, into the link function.addPane is assigned to this so that the pane link function can see it.  Then in the pane link function, addPane is just a property of the tabs controller, and it\'s just tabsControllerObject.addPane.  So the pane directive\'s linking function can access the tabs controller object and therefore access the addPane method.I hope my explanation is clear enough.. it\'s kind of hard to explain.I just read a pretty interesting explanation on the difference between the two, and a growing preference to attach models to the controller and alias the controller to bind models to the view. http://toddmotto.com/digging-into-angulars-controller-as-syntax/ is the article. He doesn\'t mention it but when defining directives, if you need to share something between multiple directives and don\'t want a service (there are legitimate cases where services are a hassle) then attach the data to the parent directive\'s controller. The $scope service provides plenty of useful things, $watch being the most obvious, but if all you need to to bind data to the view, using the plain controller and \'controller as\' in the template is fine, and arguably preferable.In this course(https://www.codeschool.com/courses/shaping-up-with-angular-js) they explain how to use "this" and many other stuff.If you add method to the controller through "this" method, you have to call it in the view with controller\'s name "dot" your property or method.For example using your controller in the view you may have code like this:I recommend you to read the following post:\nhttp://codetunnel.io/angularjs-controller-as-or-scope/it describes very well the advantages of using "Controller as" to expose variables over "$scope".I know you asked specifically about methods and not variables, but I think that it\'s better to stick to one technique and be consistent with it. So for my opinion, because of the variables issue discussed in the post, it\'s better to just use the "Controller as" technique and also apply it to the methods.Previous versions of Angular (pre 1.0 RC) allowed you to use this\n  interchangeably with the $scope method, but this is no longer the\n  case. Inside of methods defined on the scope this and $scope are\n  interchangeable (angular sets this to $scope), but not otherwise\n  inside your controller constructor.To bring back this behaviour (does anyone know why was it changed?) you can add:at the end of your controller function (provided that $scope was injected to this controller function).This has a nice effect of having access to parent scope via controller object that you can get in child with require: \'^myParentDirective\'