I\'ve read around about const and static readonly fields. We have some classes which contains only constant values. Used for various things around in our system. So I am wondering if my observation is correct:Should these kind of constant values always be static readonly for everything that is public? And only use const for internal/protected/private values?What do you recommend? Should I maybe even not use static readonly fields, but rather use properties maybe?Public static readonly fields are a little unusual; public static properties (with only a get) would be more common (perhaps backed by a private static readonly field).Const values are burned directly into the call-site; this is double edged:If the value will never change, then const is fine - Zero etc make reasonable consts ;-p Other than that, static properties are more common.I would use static readonly if the Consumer is in a different assembly. Having the const and the Consumer in two different assemblies is a nice way to shoot yourself in the foot.Some other thingsconst int a readonly int aThis is just a supplement to the other answers. I will not repeat them (now four years later).There are situations where a const and a non-const have different semantics. For example:prints out True, whereas:writes False.The reason is that the method x.Equals has two overloads, one that takes in a short (System.Int16) and one that takes an object (System.Object). Now the question is whether one or both apply with my y argument.When y is a compile-time constant (literal), the const case, it becomes important that there does exist an implicit conversion from int to short provided that the int is a constant, and provided that the C# compiler verifies that its value is within the range of a short (which 42 is). See Implicit constant expression conversions in the C# Language Specification. So both overloads have to be considered. The overload Equals(short) is preferred (any short is an object, but not all object are short). So y is converted to short, and that overload is used. Then Equals compares two short of identical value, and that gives true.When y is not a constant, no implicit conversion from int to short exists. That\'s because in general an int may be too huge to fit into a short. (An explicit conversion does exist, but I didn\'t say Equals((short)y), so that\'s not relevant.) We see that only one overload applies, the Equals(object) one. So y is boxed to object. Then Equals is going to compare a System.Int16 to a System.Int32, and since the run-time types do not even agree, that will yield false.We conclude that in some (rare) cases, changing a const type member to a static readonly field (or the other way, when that is possible) can change the behavior of the program.One thing to note is const is restricted to primitive/value types (the exception being strings)The readonly keyword is different from the const keyword. A const field can only be initialized at the declaration of the field. A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields can have different values depending on the constructor used. Also, while a const field is a compile-time constant, the readonly field can be used for runtime constantsShort and clear MSDN reference hereConst and readonly are similar, but they are not exactly the same. A const field is a compile-time constant, meaning that that value can be computed at compile-time. A readonly field enables additional scenarios in which some code must be run during construction of the type. After construction, a readonly field cannot be changed.For instance, const members can be used to define members like:since values like 3.14 and 0 are compile-time constants. However, consider the case where you define a type and want to provide some pre-fab instances of it. E.g., you might want to define a Color class and provide "constants" for common colors like Black, White, etc. It isn\'t possible to do this with const members, as the right hand sides are not compile-time constants. One could do this with regular static members:but then there is nothing to keep a client of Color from mucking with it, perhaps by swapping the Black and White values. Needless to say, this would cause consternation for other clients of the Color class. The "readonly" feature addresses this scenario. By simply introducing the readonly keyword in the declarations, we preserve the flexible initialization while preventing client code from mucking around.It is interesting to note that const members are always static, whereas a readonly member can be either static or not, just like a regular field.It is possible to use a single keyword for these two purposes, but this leads to either versioning problems or performance problems. Assume for a moment that we used a single keyword for this (const) and a developer wrote:and a different developer wrote code that relied on A:Now, can the code that is generated rely on the fact that A.C is a compile-time constant? I.e., can the use of A.C simply be replaced by the value 0? If you say "yes" to this, then that means that the developer of A cannot change the way that A.C is initialized -- this ties the hands of the developer of A without permission. If you say "no" to this question then an important optimization is missed. Perhaps the author of A is positive that A.C will always be zero. The use of both const and readonly allows the developer of A to specify the intent. This makes for better versioning behavior and also better performance.My preference is to use const whenever I can, which as mentioned above is limited to literal expressions or something that does not require evaluation.  If I hot up against that limitation, then I fallback to static readonly, with one caveat.  I would generally use a public static property with a getter and a backing private static readonly field as Marc mentions here.Static Read Only : \nValue can be changed through static constructor at runtime. But not through member FunctionConstant : \nBy default static. Value cannot be changed from anywhere (Ctor, Function, runtime etc no-where)Read Only : \nValue can be changed through constructor at runtime. But not through member FunctionYou can have a look at my repo : C# property typesA static readonly field is advantageous when exposing to\nother assemblies a value that might change in a later version.For instance, suppose assembly X exposes a constant as follows:If assembly Y references X and uses this constant, the value 2.3\nwill be baked into assembly Y when compiled. This means that\nif X is later recompiled with the constant set to 2.4, Y will still\nuse the old value of 2.3 until Y is recompiled. A static\nreadonly field avoids this problem.Another way of looking at this is that any value that might\nchange in the future is not constant by definition, and so should\nnot be represented as one.Const: Const is nothing but "constant", a variable of which the value is constant but at compile time. And it\'s mandatory to assign a value to it. By default a const is static and we cannot change the value of a const variable throughout the entire program.Static ReadOnly: A Static Readonly type variable\'s value can be assigned at runtime or assigned at compile time and changed at runtime. But this variable\'s value can only be changed in the static constructor. And cannot be changed further. It can change only once at runtimeReference: c-sharpcornerconst:readonly:There is a minor difference between const and static readonly fields in C#.Netconst must be initialized with value at compile time.const is by default static and needs to be initialized with constant value, which can not be modified later on. \nIt can not be used with all datatypes. For ex- DateTime. It can not be used with DateTime datatype.readonly can be declared as static, but not necessary. No need to initialize at the time of declaration. Its value can be assigned or changed using constructor once. So there is a possibility to change value of readonly field once (does not matter, if it is static or not), which is not possible with const.Constants are like the name implies, fields which don\'t change and are usually defined statically at compile time in the code.Read only variables are fields that can change under specific conditions. They can be either initialized when you first declare them like a constant, but usually they are initialized during object construction inside the constructor. They cannot be changed after the initialization took place, in the conditions mentioned above.Static read-only sounds like a poor choice to me since, if it\'s static and it never changes, so just use it public const, if it can change then it\'s not a constant and then, depending on your needs, you can either use read-only or just a regular variable.Also, another important distinction is that a constant belongs to the class, while the read-only variable belongs to the instance!