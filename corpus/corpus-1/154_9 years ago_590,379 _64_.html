Someone posted in a comment to another question about the meaning of the explicit keyword in C++. So, what does it mean?The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a single parameter to convert from one type to another in order to get the right type for a parameter. Here\'s an example class with a constructor that can be used for implicit conversions:Here\'s a simple function that takes a Foo object:and here\'s where the DoBar function is called.The argument is not a Foo object, but an int. However, there exists a constructor for Foo that takes an int so this constructor can be used to convert the parameter to the correct type.The compiler is allowed to do this once for each parameter.Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call DoBar (42).  It is now necessary to call for conversion explicitly with  DoBar (Foo (42))The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:Suppose you have a class String:Now if you trythe char \'x\' will be implicitly converted to int and then will call the String(int) constructor. But this is not what the user might have intended. So to prevent such conditions, we shall define the constructor as explicit:In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.For example, if you have a string class with constructor String(const char* s), that\'s probably exactly what you want.  You can pass a const char* to a function expecting a String, and the compiler will automatically construct a temporary String object for you.On the other hand, if you have a buffer class whose constructor Buffer(int size) takes the size of the buffer in bytes, you probably don\'t want the compiler to quietly turn ints into Buffers.  To prevent that, you declare the constructor with the explicit keyword:That way,becomes a compile-time error.  If you want to pass a temporary Buffer object, you have to do so explicitly:In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don\'t want to use the explicit keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as explicit to prevent the compiler from surprising you with unexpected conversions.This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.Consider the following class without an explicit constructor:Objects of class Foo can be created in 2 ways:Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the explicit keyword to the constructor would generate a compiler error at Foo bar2 = 20;.It is usually good practice to declare single-argument constructors as explicit, unless your implementation specifically prohibits it.Note also that constructors withcan both be used as single-argument constructors. So you may want to make these also explicit.An example when you would deliberately not want to make your single-argument constructor explicit is if you\'re creating a functor (look at the \'add_x\' struct declared in this answer). In such a case, creating an object as add_x add30 = 30; would probably make sense.Here is a good write-up on explicit constructors.The explicit keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone. C++ [class.conv.ctor]1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization\n  (8.5).C++ [class.conv.fct]2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments\n  and initializations.Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.Let\'s look at a small setup of structures and functions to see the difference between explicit and non-explicit conversions.Conversion of a function argument:Object initialization:Conversion of a function argument:Object initialization:Conversion constructors and non-explicit conversion functions may introduce ambiguity.Consider a structure V, convertible to int, a structure U implicitly constructible from V and a function f overloaded for U and bool respectively.A call to f is ambiguous if passing an object of type V.The compiler does not know wether to use the constructor of U or the conversion function to convert the V object into a type for passing to f. If either the constructor of U or the conversion function of V would be explicit, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to f using an object of type V would have to be done using an explicit conversion or cast operation.Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.Consider a function printing some vector:If the size-constructor of the vector would not be explicit it would be possible to call the function like this:What would one expect from such a call? One line containing 3 or three lines containing 0? (Where the second one is what happens.)As Bjarne Stroustrup  puts it (in "The C++ Programming Language", 4th Ed., 35.2.1, pp. 1011) on the question why std::duration cannot be implicitly constructed from a plain number:If you know what you mean, be explicit about it.The explicit-keyword can be used to enforce a constructor to be called explicitly.the explicit-keyword in front of the constructor C(void) tells the compiler that only explicit call to this constructor is allowed.The explicit-keyword can also be used in user-defined type cast operators:Here, explicit-keyword enforces only explicit casts to be valid, so bool b = c; would be an invalid cast in this case. In situations like these explicit-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in C++11.This has already been discussed (what is explicit constructor). But I must say, that it lacks the detailed descriptions found here.Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. \nLike always with C++: if you don\'t - you\'ll wish you did...Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.Cpp Reference is always helpful!!! Details about explicit specifier can be found here.  You may need to look at implicit conversions and copy-initialization too.Quick lookThe explicit specifier specifies that a constructor or conversion function (since C++11) doesn\'t allow implicit conversions or copy-initialization. Example as follows:Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.In C++11 you can also specify an "operator type()" with such keyword http://en.cppreference.com/w/cpp/language/explicit With such specification you can use operator in terms of explicit conversions, and direct initialization of object.P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.\nBut you can combine this conversions with other language conversions