What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn\'t possible prior to their introduction?A few examples, and use cases would be useful. C++ includes useful generic functions like std::for_each and std::transform, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the functor you would like to apply is unique to the particular function.If you only use f once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.In C++03 you might be tempted to write something like the following, to keep the functor local:however this is not allowed, f cannot be passed to a template function in C++03.C++11 introduces lambdas allow you to write an inline, anonymous functor to replace the struct f. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:Lambda functions are just syntactic sugar for anonymous functors.In simple cases the return type of the lambda is deduced for you, e.g.:however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:To resolve this you are allowed to explicitly specify a return type for a lambda function, using -> T:So far we\'ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the [] of the expression), which has so far been unused in these examples, e.g.:You can capture by both reference and value, which you can specify using & and = respectively:The generated operator() is const by default, with the implication that captures will be const when you access them by default. This has the effect that each call with the same input would produce the same result, however you can mark the lambda as mutable to request that the operator() that is produced is not const.The C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.In C++ a lambda function is defined like thisor in all its glory[] is the capture list, () the argument list and {} the function body.The capture list defines what from the outside of the lambda should be available inside the function body and how.\nIt can be either:You can mix any of the above in a comma separated list [x, &y].The argument list is the same as in any other C++ function. The code that will be executed when the lambda is actually called.If a lambda has only one return statement, the return type can be omitted and has the implicit type of decltype(return_statement).If a lambda is marked mutable (e.g. []() mutable { }) it is allowed to mutate the values that have been captured by value.The library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don\'t have to clutter their code with small functors in some accessible scope.In C++14 lambdas have been extended by various proposals.An element of the capture list can now be initialized with =. This allows renaming of variables and to capture by moving. An example taken from the standard:and one taken from Wikipedia showing how to capture with std::move:Lambdas can now be generic (auto would be equivalent to T here if\nT were a type template argument somewhere in the surrounding scope):C++14 allows deduced return types for every function and does not restrict it to functions of the form return expression;. This is also extended to lambdas.Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function.  However, it is possible to execute a lambda immediately upon definition:is functionally equivalent toThis makes lambda expressions a powerful tool for refactoring complex functions.  You start by wrapping a code section in a lambda function as shown above.  The process of explicit parameterization can then be performed gradually with intermediate testing after each step.  Once you have the code-block fully parameterized (as demonstrated by the removal of the &), you can move the code to an external location and make it a normal function.Similarly, you can use lambda expressions to initialize variables based on the result of an algorithm...As a way of partitioning your program logic, you might even find it useful to pass a lambda expression as an argument to another lambda expression...Lambda expressions also let you create named nested functions, which can be a convenient way of avoiding duplicate logic.  Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function.  Note: don\'t forget the semicolon after the closing curly brace.If subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.AnswersQ: What is a lambda expression in C++11?A: Under the hood it is object of autogenerated class with overloading operator() const. Such object is called closure and created by compiler.\nThis \'closure\' concept is near with the bind concept from C++11. \nBut lambdas typically generate better code. And calls through closures allow full inlining.Q: When would I use one?A: To define "simple and small logic" and ask compiler perform generation from previous question. You give a compiler some expressions which you want to be inside operator(). All other stuff compiler will generate to you.Q: What class of problem do they solve that wasn\'t possible prior to their introduction?A: It is some kind of syntax sugar like operators overloading instead of functions for custom add, subrtact operations...But it save more lines of unneeded code to wrap 1-3 lines of real logic to some classes, and etc.! Some engineers think that if the number of lines is smaller then there is a less chance to make errors in it (I\'m also think so)Example of usageExtras about lambdas, not covered by question. Ignore this section if you\'re not interest1. Captured values. What you can to capture1.1. You can reference to variable with static storage duration in lamdas. They all are captured.1.2. You can use lamda for capture values "by value". In such case captured vars will be copied to function object (closure).1.3. You can capture be reference. & -- in this context mean reference, not pointers.1.4. It is exist notation to capture all non-static vars by value, or by reference1.5.  It is exist notation to capture all non-static vars by value, or by reference and specify smth. more.\nExamples:\nCapture all not-static vars by value, but by reference capture Param2Capture all not-static vars by reference, but by value capture Param22. Return type deduction2.1. Lambda return type can be deduced if lamda is one expression. Or you can explicitly specify it.If lambda has more then one expression, then return type must be specified via trailing return type. \n  Also similar syntax can be applied to auto functions and member-functions3. Captured values. What you can not to capture3.1. You can capture only local vars, not member variable of object.4. \xd0\xa1onversions4.1. lambda is not a function pointer and it is not an anonymous function, but can be implicitly converted to function pointer.p.s. More about lambda grammar information information can be found in Working draft for Programming Language C++ #337, 2012-01-16, 5.1.2. Lambda Expressions, p.88In C++14 the extra feature which has named as "init capture" have been added. It allow to perform arbitarily declaration of closure data members:A lambda function is an anonymous function that you create in-line. It can capture variables as some have explained, (e.g. http://www.stroustrup.com/C++11FAQ.html#lambda) but there are some limitations. For example, if there\'s a callback interface like this, you can write a function on the spot to use it like the one passed to apply below:But you can\'t do this:because of limitations in the C++11 standard. If you want to use captures, you have to rely on the library and (or some other STL library like algorithm to get it indirectly) and then work with std::function instead of passing normal functions as parameters like this:One of the best explanation of lambda expression is given from author of C++ Bjarne Stroustrup in his book ***The C++ Programming Language*** chapter 11 (ISBN-13: 978-0321563842):What is a lambda expression? A lambda expression, sometimes also referred to as a lambda\n  function or (strictly speaking incorrectly, but colloquially) as a\n  lambda, is a simplified notation for defining and using an anonymous function object. Instead of defining a named class with an operator(), later making an object of that class, and finally\n  invoking it, we can use a shorthand.When would I use one?This is particularly useful when we want to pass an operation as an\n  argument to an algorithm. In the context of graphical user interfaces\n  (and elsewhere), such operations are often referred to as callbacks.What class of problem do they solve that wasn\'t possible prior to their introduction?Here i guess every action done with lambda expression can be solved without them, but with much more code and much bigger complexity. Lambda expression this is the way of optimization for your code and a way of making it more attractive. As sad by Stroustup :effective ways of optimizingSome examplesvia lambda expressionor via functionor evenif u need u can name lambda expression like below:Or assume another simple samplewill generate next01010101010 sortedx - 1;x - 3;x - 4;x - 5;x - 6;x - 7;x - 33;[] - this is capture list or lambda introducer: if lambdas require no access to their local environment we can use it.Quote from book:The first character of a lambda expression is always [. A lambda\n  introducer can take various forms:\xe2\x80\xa2 []: an empty capture list. This\n  implies that no local names from the surrounding context can be used\n  in the lambda body. For such lambda expressions, data is obtained from\n  arguments or from nonlocal variables. \xe2\x80\xa2 [&]: implicitly capture by\n  reference. All local names can be used. All local variables are\n  accessed by reference.\xe2\x80\xa2 [=]: implicitly capture by value. All local\n  names can be used. All names refer to copies of the local variables\n  taken at the point of call of the lambda expression.\xe2\x80\xa2 [capture-list]:  explicit capture; the capture-list is the list of names of local  variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by & are captured by\n  reference. Other variables are captured by value. A capture list can\n  also contain this and names followed by ... as elements. \xe2\x80\xa2 [&,  capture-list]: implicitly capture by reference all local variables  with names not men- tioned in the list. The capture list can contain  this. Listed names cannot be preceded by &. Variables named in the\n  capture list are captured by value. \xe2\x80\xa2 [=, capture-list]: implicitly capture by value all local variables with names not mentioned in the  list. The capture list cannot contain this. The listed names must be preceded by &. Vari- ables named in the capture list are captured by  reference. Note that a local name preceded by & is always captured by\n  reference and a local name not pre- ceded by & is always captured by\n  value. Only capture by reference allows modification of variables in\n  the calling environment.AdditionalLambda expression formatAdditional references:One problem it solves: Code simpler than lambda for a call in constructor that uses an output parameter function for initializing a const memberYou can initialize a const member of your class, with a call to a function that sets its value by giving back its output as an output parameter.Well, one practical use I\'ve found out is reducing boiler plate code. For example:Without lambda, you may need to do something for different bsize cases. Of course you could create a function but what if you want to limit the usage within the scope of the soul user function? the nature of lambda fulfills this requirement and I use it for that case.