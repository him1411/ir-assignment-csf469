What are the differences between a Service, Provider and Factory in AngularJS?From the AngularJS mailing list I got an amazing thread that explains service vs factory vs provider and their injection usage. Compiling the answers:Syntax: module.service( \'serviceName\', function ); \nResult: When declaring serviceName as an injectable argument you will be provided with an instance of the function. In other words new FunctionYouPassedToService().Syntax: module.factory( \'factoryName\', function ); \nResult: When declaring factoryName as an injectable argument you will be provided with the value that is returned by invoking the function reference passed to module.factory.Syntax: module.provider( \'providerName\', function ); \nResult: When declaring providerName as an injectable argument you will be provided with (new ProviderFunction()).$get(). The constructor function is instantiated before the $get method is called - ProviderFunction is  the function reference passed to module.provider.Providers have the advantage that they can be configured during the module configuration phase.See here for the provided code.Here\'s a great further explanation by Misko:In this case the injector simply returns the value as is. But what if you want to compute the value? Then use a factorySo factory is a function which is responsible for creating the value. Notice that the factory function can ask for other dependencies.But what if you want to be more OO and have a class called Greeter?Then to instantiate you would have to writeThen we could ask for \'greeter\' in controller like thisBut that is way too wordy. A shorter way to write this would be provider.service(\'greeter\', Greeter);But what if we wanted to configure the Greeter class before the injection? Then we could writeThen we can do this: As a side note, service, factory, and value are all derived from provider.TL;DR \n1) When you\xe2\x80\x99re using a Factory you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.\n2) When you\xe2\x80\x99re using Service, AngularJS instantiates it behind the scenes with the \xe2\x80\x98new\xe2\x80\x99 keyword. Because of that, you\xe2\x80\x99ll add properties to \xe2\x80\x98this\xe2\x80\x99 and the service will return \xe2\x80\x98this\xe2\x80\x99. When you pass the service into your controller, those properties on \xe2\x80\x98this\xe2\x80\x99 will now be available on that controller through your service.\n3) Providers are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.\nNon TL;DR1) Factory \nFactories are the most popular way to create and configure a service. There\xe2\x80\x99s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below.Now whatever properties we attach to \xe2\x80\x98service\xe2\x80\x99 will be available to us when we pass \xe2\x80\x98myFactory\xe2\x80\x99 into our controller.Now let\xe2\x80\x99s add some \xe2\x80\x98private\xe2\x80\x99 variables to our callback function. These won\xe2\x80\x99t be directly accessible from the controller, but we will eventually set up some getter/setter methods on \xe2\x80\x98service\xe2\x80\x99 to be able to alter these \xe2\x80\x98private\xe2\x80\x99 variables when needed.Here you\xe2\x80\x99ll notice we\xe2\x80\x99re not attaching those variables/function to \xe2\x80\x98service\xe2\x80\x99. We\xe2\x80\x99re simply creating them in order to either use or modify them later.Now that our helper/private variables and function are in place, let\xe2\x80\x99s add some properties to the \xe2\x80\x98service\xe2\x80\x99 object. Whatever we put on \xe2\x80\x98service\xe2\x80\x99 can be directly used inside whichever controller we pass \xe2\x80\x98myFactory\xe2\x80\x99 into.We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven\xe2\x80\x99t had much experience using promises in AngularJS, I highly recommend doing a deep dive on them.Below setArtist accepts an artist and allows you to set the artist. getArtist returns the artist. callItunes first calls makeUrl() in order to build the URL we\xe2\x80\x99ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying \xe2\x80\x98There was an error\xe2\x80\x99.Now our factory is complete. We are now able to inject \xe2\x80\x98myFactory\xe2\x80\x99 into any controller and we\xe2\x80\x99ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes).In the controller above we\xe2\x80\x99re injecting in the \xe2\x80\x98myFactory\xe2\x80\x99 service. We then set properties on our $scope object with data from \xe2\x80\x98myFactory\xe2\x80\x99. The only tricky code above is if you\xe2\x80\x99ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You\xe2\x80\x99ll notice our controller is very \xe2\x80\x98thin\xe2\x80\x99 (This is a good coding practise). All of our logic and persistent data is located in our service, not in our controller.\n\n2) Service \nPerhaps the biggest thing to know when dealing with creating a Service is that that it\xe2\x80\x99s instantiated with the \xe2\x80\x98new\xe2\x80\x99 keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren\xe2\x80\x99t too familiar with what the \xe2\x80\x98new\xe2\x80\x99 keyword actually does, let\xe2\x80\x99s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service.To really see the changes that occur when you invoke a function with the \xe2\x80\x98new\xe2\x80\x99 keyword, let\xe2\x80\x99s create a function and invoke it with the \xe2\x80\x98new\xe2\x80\x99 keyword, then let\xe2\x80\x99s show what the interpreter does when it sees the \xe2\x80\x98new\xe2\x80\x99 keyword. The end results will both be the same.First let\xe2\x80\x99s create our Constructor.This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the \xe2\x80\x98new\xe2\x80\x99 keyword, \xe2\x80\x98this\xe2\x80\x99 will be bound to the newly created object.Now let\xe2\x80\x99s add a method onto our Person\xe2\x80\x99s prototype so it will be available on every instance of our Person \xe2\x80\x98class\xe2\x80\x99.Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance\xe2\x80\x99s name.Now that we have our Person constructor function and our sayName function on its prototype, let\xe2\x80\x99s actually create an instance of Person then call the sayName function.So all together the code for creating a Person constructor, adding a function to it\xe2\x80\x99s prototype, creating a Person instance, and then calling the function on its prototype looks like this.Now let\xe2\x80\x99s look at what actually is happening when you use the \xe2\x80\x98new\xe2\x80\x99 keyword in JavaScript. First thing you should notice is that after using \xe2\x80\x98new\xe2\x80\x99 in our example, we\xe2\x80\x99re able to call a method (sayName) on \xe2\x80\x98tyler\xe2\x80\x99 just as if it were an object - that\xe2\x80\x99s because it is. \nSo first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says \xe2\x80\x9cOK, I\xe2\x80\x99m going to look on the \xe2\x80\x98tyler\xe2\x80\x99 object we just created, locate the sayName function, then call it. Wait a minute, I don\xe2\x80\x99t see it here - all I see is name and age, let me check the prototype. Yup, looks like it\xe2\x80\x99s on the prototype, let me call it.\xe2\x80\x9d.Below is code for how you can think about what the \xe2\x80\x98new\xe2\x80\x99 keyword is actually doing in JavaScript. It\xe2\x80\x99s basically a code example of the above paragraph. I\xe2\x80\x99ve put the \xe2\x80\x98interpreter view\xe2\x80\x99 or the way the interpreter sees the code inside of notes.Now having this knowledge of what the \xe2\x80\x98new\xe2\x80\x99 keyword really does in JavaScript, creating a Service in AngularJS should be easier to understand.The biggest thing to understand when creating a Service is knowing that Services are instantiated with the \xe2\x80\x98new\xe2\x80\x99 keyword. Combining that knowledge with our examples above, you should now recognize that you\xe2\x80\x99ll be attaching your properties and methods directly to \xe2\x80\x98this\xe2\x80\x99 which will then be returned from the Service itself. Let\xe2\x80\x99s take a look at this in action.Unlike what we originally did with the Factory example, we don\xe2\x80\x99t need to create an object then return that object because, like mentioned many times before, we used the \xe2\x80\x98new\xe2\x80\x99 keyword so the interpreter will create that object, have it delegate to it\xe2\x80\x99s prototype, then return it for us without us having to do the work.First things first, let\xe2\x80\x99s create our \xe2\x80\x98private\xe2\x80\x99 and helper function. This should look very familiar since we did the exact same thing with our factory. I won\xe2\x80\x99t explain what each line does here because I did that in the factory example, if you\xe2\x80\x99re confused, re-read the factory example.Now, we\xe2\x80\x99ll attach all of our methods that will be available in our controller to \xe2\x80\x98this\xe2\x80\x99.Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here\xe2\x80\x99s the myService controller (which is almost exactly the same as our factory controller).Like I mentioned before, once you really understand what \xe2\x80\x98new\xe2\x80\x99 does, Services are almost identical to factories in AngularJS.\n\n3) ProviderThe biggest thing to remember about Providers is that they\xe2\x80\x99re the only service that you can pass into the app.config portion of your application. This is of huge importance if you\xe2\x80\x99re needing to alter some portion of your service object before it\xe2\x80\x99s available everywhere else in your application. Although very similar to Services/Factories, there are a few differences which we\xe2\x80\x99ll discuss.First we set up our Provider in a similar way we did with our Service and Factory. The variables below are our \xe2\x80\x98private\xe2\x80\x99 and helper function.*Again if any portion of the above code is confusing, check out the Factory section where I explain what it all does it greater details.You can think of Providers as having three sections. The first section is the \xe2\x80\x98private\xe2\x80\x99 variables/functions that will be modified/set later (shown above). The second section is the variables/functions that will be available in your app.config function and are therefore available to alter before they\xe2\x80\x99re available anywhere else (also shown above). It\xe2\x80\x99s important to note that those variables need to be attached to the \xe2\x80\x98this\xe2\x80\x99 keyword. In our example, only \xe2\x80\x98thingFromConfig\xe2\x80\x99 will be available to alter in the app.config. The third section (shown below) is all the variables/functions that will be available in your controller when you pass in the \xe2\x80\x98myProvider\xe2\x80\x99 service into that specific controller.When creating a service with Provider, the only properties/methods that will be available in your controller are those properties/methods which are returned from the $get() function. The code below puts $get on \xe2\x80\x98this\xe2\x80\x99 (which we know will eventually be returned from that function). Now, that $get function returns all the methods/properties we want to be available in the controller. Here\xe2\x80\x99s a code example.Now the full Provider code looks like thisNow just like in our factory and Service, setArtist, getArtist, and callItunes will be available in whichever controller we pass myProvider into. Here\xe2\x80\x99s the myProvider controller (which is almost exactly the same as our factory/Service controller).As mentioned before, the whole point of creating a service with Provider is to be able to alter some variables through the app.config function before the final object is passed to the rest of the application. Let\xe2\x80\x99s see an example of that.Now you can see how \xe2\x80\x98thingFromConfig\xe2\x80\x99 is as empty string in our provider, but when that shows up in the DOM, it will be \xe2\x80\x98This sentence was set\xe2\x80\xa6\xe2\x80\x99.All Services are singletons; they get instantiated once per app. They can be of any type, whether it be a primitive, object literal, function, or even an instance of a custom type.The value, factory, service, constant, and provider methods are all providers. They teach the Injector how to instantiate the Services.The most verbose, but also the most comprehensive one is a Provider\n  recipe. The remaining four recipe types \xe2\x80\x94 Value, Factory, Service and\n  Constant \xe2\x80\x94 are just syntactic sugar on top of a provider recipe.You should use the Provider recipe only when you want to expose an API\n  for application-wide configuration that must be made before the\n  application starts. This is usually interesting only for reusable\n  services whose behavior might need to vary slightly between\n  applications.Understanding AngularJS Factory, Service and ProviderAll of these are used to share reusable singleton objects. It helps to share reusable code across your app/various components/modules.From Docs Service/Factory:A factory is function where you can manipulate/add logic before creating an object, then the newly created object gets returned.UsageIt can be just a collection of functions like a class. Hence, it can be instantiated in different controllers when you are injecting it inside your controller/factory/directive functions. It is instantiated only once per app.Simply while looking at the services think about the array prototype. A service is a function which instantiates a new object using the \'new\' keyword. You can add properties and functions to a service object by using the this keyword. Unlike a factory, it doesn\'t return anything (it returns an object which contains methods/properties).UsageUse it when you need to share a single object throughout the application. For example, authenticated user details, share-able methods/data, Utility functions etc.A provider is used to create a configurable service object. You can configure the service setting from config function. It returns a value by using the $get() function. The $get function gets executed on the run phase in angular.UsageWhen you need to provide module-wise configuration for your service object before making it available, eg. suppose you want to set your API URL on basis of your Environment like dev, stage or prodNOTE Only provider will be available in config phase of angular, while\n  service & factory are not.Hope this has cleared up your understanding about Factory, Service and Provider.For me, the revelation came when I realized that they all work the same way: by running something once, storing the value they get, and then cough up that same stored value when referenced through dependency injection.Say we have:The difference between the three is that:Which means there\xe2\x80\x99s something like a cache object inside AngularJS, whose value of each injection is only assigned once, when they\'ve been injected the first time, and where:This is why we use this in services, and define a this.$get in providers.Service vs provider vs factory:I am trying to keep it simple. It\'s all about basic JavaScript concept.First of all, let\'s talk about services in AngularJS!What is Service:\nIn AngularJS, Service is nothing but a singleton JavaScript object which can store some useful methods or properties. This singleton object is created per ngApp(Angular app) basis and it is shared among all the controllers within current app. When Angularjs instantiate a service object, it register this service object with a unique service name. So each time when we need service instance, Angular search the registry for this service name, and it returns the reference to service object. Such that we can invoke method, access properties etc on the service object.\nYou may have question whether you can also put properties, methods on scope object of controllers! So why you need service object? Answers is: services are shared among multiple controller scope. If you put some properties/methods in a controller\'s scope object , it will be available to current scope only. But when you define methods, properties on service object, it will be available globally and can be accessed in any  controller\'s scope by injecting that service.So if there are three controller scope, let it be controllerA, controllerB and controllerC, all will share same service instance.How to create a service?AngularJS provide different methods to register a service. Here we will concentrate on three methods factory(..),service(..),provider(..);Use this link for code referenceWe can define a factory function as below.AngularJS provides \'factory(\'serviceName\', fnFactory)\' method which takes two parameter, serviceName and a JavaScript function. Angular creates service instance by invoking the function fnFactory() such as below.The passed function can define a object and return that object. AngularJS simply stores this object reference to a variable which is passed as first argument. Anything which is returned from fnFactory will be bound to serviceInstance . Instead of returning object , we can also return function, values etc, Whatever we will return , will be available to service instance.Example:It\'s the another way, we can register a service. The only difference is the way AngularJS tries to instantiate the service object. This time angular uses \'new\' keyword and call the constructor function something like below.In the constructor function we can use \'this\' keyword for adding properties/methods to the service object.\nexample:Provider() function is the another way for creating services. Let we are interested to create a service which just display some greeting message to the user. But we also want to provide a functionality such that user can set their own greeting message. In technical terms we want to create configurable services. How can we do this ? There must be a way, so that app could pass their custom greeting messages and Angularjs would make it available to factory/constructor function which create our services instance.\nIn such a case provider() function do the job. using provider() function we can create configurable services.We can create configurable services using provider syntax as given below.1.Provider object is created using constructor function we defined in our provider function.2.The function we passed in app.config(), get executed. This is called config phase, and here we have a chance to customize our service.3.Finally service instance is created by calling $get method of serviceProvider.Working DemoSummary:Factory use a factory function which return a service instance.\nserviceInstance = fnFactory();Service use a constructor function and Angular invoke this constructor function using \'new\' keyword for creating the service instance.\nserviceInstance = new fnServiceConstructor();Provider defines a providerConstructor function, this providerConstructor function defines a factory function $get . Angular calls $get() to create the service object. Provider syntax has an added advantage of configuring the service object before it get instantiated.\nserviceInstance = $get();As pointed out by several people here correctly a factory, provider, service, and even value and constant are versions of the same thing. You can dissect the more general provider into all of them. Like so:Here\'s the article this image is from:http://www.simplygoodcode.com/2015/11/the-difference-between-service-provider-and-factory-in-angularjs/You give AngularJS a function, AngularJS will cache and inject the return value when the factory is requested.Example:Usage:You give AngularJS a function, AngularJS will call new to instantiate it. It is the instance that AngularJS creates that will be cached and injected when the service is requested. Since new was used to instantiate the service, the keyword this is valid and refers to the instance.Example:Usage:You give AngularJS a function, and AngularJS will call its $get function. It is the return value from the $get function that will be cached and injected when the service is requested.Providers allow you to configure the provider before AngularJS calls the $get method to get the injectible.Example:Usage (as an injectable in a controller)Usage (configuring the provider before $get is called to create the injectable)I noticed something interesting when playing around with providers.Visibility of injectables is different for providers than it is for services and factories. If you declare an AngularJS "constant" (for example, myApp.constant(\'a\', \'Robert\');), you can inject it into services, factories, and providers.But if you declare an AngularJS "value" (for example., myApp.value(\'b\', {name: \'Jones\'});), you can inject it into services and factories, but NOT into the provider-creating function. You can, however, inject it into the $get function that you define for your provider. This is mentioned in the AngularJS documentation, but it\'s easy to miss. You can find it on the %provide page in the sections on the value and constant methods.http://jsfiddle.net/R2Frv/1/This is very confusing part for newbie and I have tried to clarify it in easy wordsAngularJS Service: is used for sharing utility functions with the service reference in the controller. Service is singleton in nature so for one service only one instance is created in the browser and the same reference is used throughout the page.In the service, we create function names as property with this object.AngularJS Factory: the purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.AngularJS Provider: the purpose of this is again same however Provider gives the output of it\'s $get function.Defining and using Service, Factory and Provider are explained at http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider For me the best and the simplest way of understanding the difference is:How AngularJS instantiates particular components (simplified):So, for the service, what becomes the AngularJS component is the object instance of the class which is represented by service declaration function. For the factory, it is the result returned from the factory declaration function. The factory may behave the same as the service:The simplest way of thinking is the following one:The factory \'class\' example is provided in the comments around, as well as provider difference.My clarification on this matter:Basically all of the mentioned types (service, factory, provider, etc.) are just creating and configuring global variables (that are of course global to the entire application), just as old fashioned global variables were.While global variables are not recommended, the real usage of these global variables is to provide dependency injection, by passing the variable to the relevant controller.There are many levels of complications in creating the values for the "global variables":My understanding is very simple below. Factory:\n  You simply create an object inside of the factory and return it.Service:You just have a standard function that uses this keyword to define a function.Provider:There is a $get object that you define and it can be used to get the object that returns data.Summary from Angular docs:Best answers from SO:https://stackoverflow.com/a/26924234/165673  (<-- GOOD)\nhttps://stackoverflow.com/a/27263882/165673\nhttps://stackoverflow.com/a/16566144/165673An additional clarification is that factories can create functions/primitives, while services cannot. Check out this jsFiddle based on Epokk\'s: http://jsfiddle.net/skeller88/PxdSP/1351/.The factory returns a function that can be invoked:The factory can also return an object with a method that can be invoked:The service returns an object with a method that can be invoked:For more details, see a post I wrote on the difference: http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/There are good answers already, but I just want to share this one.First of all: Provider is the way/recipe to create a service (singleton object) that suppose to be injected by $injector (how AngulaJS goes about IoC pattern). And Value, Factory, Service and Constant (4 ways) - the syntactic sugar over Provider way/recepie.There is Service vs Factory part has been covered:\nhttps://www.youtube.com/watch?v=BLzNCkPn3ao Service is all about new keyword actually which as we know does 4 things: And Factory is all about Factory Pattern - contains functions that return Objects like that Service.And this simple/short video: covers also Provider: https://www.youtube.com/watch?v=HvTZbQ_hUZY (there you see can see how they go from factory to provider)Provider recipe is used mostly in the app config, before the app has fully started/initialized.Here is some broilerplate code I\'ve come up with as a code-template for object factory in AngularjS.  I\'ve used a Car/CarFactory as an example to illustrate.  Makes for simple implementation code in the controller.Here is a simpler example.  I\'m using a few third party libraries that expect a "Position" object exposing latitude and longitude, but via different object properties.  I didn\'t want to hack the vendor code, so I adjusted the "Position" objects I was passing around.;Using as reference this page and the documentation (which seems to have greatly improved since the last time I looked), I put together the following real(-ish) world demo which uses 4 of the 5 flavours of provider; Value, Constant, Factory and full blown Provider.HTML:appWorking demo.I know a lot of excellent answer but I have to share my experience of using\n1. service for most cases of default\n2. factory used to create the service that specific instance and using:This answer address the topic/questionORbasically what happens isWhen you make a factory() it sets you function provided in second argument to provider\'s $get and return it(provider(name, {$get:factoryFn })), all you get is provider but there is no property/method other than $get of that provider(means you can\'t configure this)Source code of factoryWhen making a service() it return you providing a factory() with a function that injects the constructor (return the instance of the constructor you provided in your service) and returns itSource code of serviceSo basically in both cases you eventually get a providers $get set to your function you provided , but you can give anything extra than $get as you can originally provide in provider() for config blockLittle late to the party.  But I thought this is more helpful for who would like to learn (or have clarity) on developing Angular JS Custom Services using factory, service and provider methodologies.  I came across this video which explains clearly about factory, service and provider methodologies for developing AngularJS Custom Services:https://www.youtube.com/watch?v=oUXku28ex-MSource Code: http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-serviceCode posted here is copied straight from the above source, to benefit readers.The code for "factory" based custom service is as follows (which goes with both sync and async versions along with calling http service):The code for "service" methodology for Custom Services (this is pretty similar to \'factory\', but different from syntax point of view):The code for "provider" methodology for Custom Services (this is necessary, if you would like to develop service which could be configured):Finally the UI which works with any of the above services:Just to clarify things, from the AngularJS source, you can see a service just calls the factory function which in turn calls the provider function:Let\'s discuss the three ways of handling business logic in AngularJS in a simple way: (Inspired by Yaakov\'s Coursera AngularJS course)SERVICE:Syntax:app.jsindex.htmlFeatures of Service:FACTORYFirst let\'s have a look at the syntax:app.js:Now using the above two in the controller:Features of Factory:PROVIDER Let\'s again have a look at the Syntax first:Features of Provider:Factory: The factory you actually create an object inside of the factory and return it.\nservice: The service you just have a standard function that uses the this keyword to define function.\nprovider: The provider there\xe2\x80\x99s a $get you define and it can be used to get the object that returns the data.Essentially, Provider, Factory, and Service are all Services. A Factory is a special case of a Service when all you need is a $get() function, allowing you to write it with less code.The major differences among Services, Factories, and Providers are their complexities. Services are the simplest form, Factories are a little more robust, and Providers are configurable at runtime.Here is a summary of when to use each:Factory: The value you are providing needs to be calculated based on other data.Service: You are returning an object with methods.Provider: You want to be able to configure, during the config phase, the object that is going to be created before it\xe2\x80\x99s created. Use the Provider mostly in the app config, before the app has fully initialized.After reading all these post It created more confuse for me.. But still all is worthfull information.. finally I found following table which will give information with simple comparision And for beginner understand:- This may not correct use case but in high level this is what usecase for these three.For basic scenarios factory&Service behaves same. 1.Services are singleton objects that are created when necessary and are never cleaned up until the end of the application life-cycle (when the browser is closed). Controllers are destroyed and cleaned up when they are no longer needed.2.The easiest way to create a service is by using the factory() method.\nThe factory() method allows us to define a service by returning an object that contains service functions and service data. The service definition function is where we place our injectable services, such as $http and $q.\nEx: Using the factory() in our appIt\xe2\x80\x99s easy to use the factory in our application as we can simply inject it where we need it at run-time.Syntactic Sugar is the difference. Only provider is needed. Or in other words only provider is the real angular, all other ones are derived(to reduce code). There is a simple version as well, called Value()  which returns just the value, no calculation or function. Even Value is derived from provider!So why such complications, why can\'t we just use provider and forget everything else? It is supposed to help us write code easily and communicate better. And toungue-in-cheek reply would be, the more complex it gets the better selling a framework will be.Angular injection gives us the first hint in reaching this conclusion. "$injector is used to retrieve object instances as defined by provider" not service, not factory but provider. And a better answer would be this:\n"An Angular service is created by a service factory. These service factories are functions which, in turn, are created by a service provider. The service providers are constructor functions. When instantiated they must contain a property called $get, which holds the service factory function."So master provider and injector and all will fall in place :) . And it gets interesting in Typescript when $get can be implemented in a provider by inheriting from IServiceProvider. 