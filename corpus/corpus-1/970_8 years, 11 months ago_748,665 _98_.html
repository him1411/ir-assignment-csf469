Is there a way to include all the jar files within a directory in the classpath?I\'m trying java -classpath lib/*.jar:. my.package.Program and it is not able to find class files that are certainly in those jars.  Do I need to add each jar file to the classpath separately? Using Java 6 or later, the classpath option supports wildcards. Note the following:Windowsjava -cp "Test.jar;lib/*" my.package.MainClassUnixjava -cp "Test.jar:lib/*" my.package.MainClassThis is similar to Windows, but uses : instead of ;. If you cannot use wildcards, bash allows the following syntax (where lib is the directory containing all the Java archive files):java -cp $(echo lib/*.jar | tr \' \' \':\')(Note that using a classpath is incompatible with the -jar option. See also: Execute jar file with multiple classpath libraries from command prompt)Understanding WildcardsFrom the Classpath document:Class path entries can contain the basename wildcard character *, which is considered equivalent to specifying a list of all the files\n  in the directory with the extension .jar or .JAR. For example, the\n  class path entry foo/* specifies all JAR files in the directory named\n  foo. A classpath entry consisting simply of * expands to a list of all\n  the jar files in the current directory.A class path entry that contains * will not match class files. To\n  match both classes and JAR files in a single directory foo, use either\n  foo;foo/* or foo/*;foo. The order chosen determines whether the\n  classes and resources in foo are loaded before JAR files in foo, or\n  vice versa.Subdirectories are not searched recursively. For example, foo/* looks\n  for JAR files only in foo, not in foo/bar, foo/baz, etc.The order in which the JAR files in a directory are enumerated in the\n  expanded class path is not specified and may vary from platform to\n  platform and even from moment to moment on the same machine. A\n  well-constructed application should not depend upon any particular\n  order. If a specific order is required then the JAR files can be\n  enumerated explicitly in the class path.Expansion of wildcards is done early, prior to the invocation of a\n  program\'s main method, rather than late, during the class-loading\n  process itself. Each element of the input class path containing a\n  wildcard is replaced by the (possibly empty) sequence of elements\n  generated by enumerating the JAR files in the named directory. For\n  example, if the directory foo contains a.jar, b.jar, and c.jar, then\n  the class path foo/* is expanded into foo/a.jar;foo/b.jar;foo/c.jar,\n  and that string would be the value of the system property\n  java.class.path.The CLASSPATH environment variable is not treated any differently from\n  the -classpath (or -cp) command-line option. That is, wildcards are\n  honored in all these cases. However, class path wildcards are not\n  honored in the Class-Path jar-manifest header.Under windows this works:and this does not work:notice the *.jar, so the * wildcard should be used alone.On Linux, the following works:The separators are colons instead of semicolons.We get around this problem by deploying a main jar file myapp.jar which contains a manifest (Manifest.mf) file specifying a classpath with the other required jars, which are then deployed alongside it. In this case, you only need to declare java -jar myapp.jar when running the code. So if you deploy the main jar into some directory, and then put the dependent jars into a lib folder beneath that, the manifest looks like:NB: this is platform-independent - we can use the same jars to launch on a UNIX server or on a Windows PC.My solution on Ubuntu 10.04 using java-sun 1.6.0_24 having all jars in "lib" directory:If this fails, the following command should work (prints out all *.jars in lib directory to the classpath param)Short answer: java -classpath lib/*:. my.package.ProgramOracle provides documentation on using wildcards in classpaths here for Java 6 and here for Java 7, under the section heading Understanding class path wildcards. (As I write this, the two pages contain the same information.) Here\'s a summary of the highlights:In general, to include all of the JARs in a given directory, you can use the wildcard * (not *.jar).The wildcard only matches JARs, not class files; to get all classes in a directory, just end the classpath entry at the directory name.The above two options can be combined to include all JAR and class files in a directory, and the usual classpath precedence rules apply. E.g. -cp /classes;/jars/*The wildcard will not search for JARs in subdirectories.The above bullet points are true if you use the CLASSPATH system property or the -cp or -classpath command line flags. However, if you use the Class-Path JAR manifest header (as you might do with an ant build file), wildcards will not be honored.Yes, my first link is the same one provided in the top-scoring answer (which I have no hope of overtaking), but that answer doesn\'t provide much explanation beyond the link. Since that sort of behavior is discouraged on Stack Overflow these days, I thought I\'d expand on it.For me this works in windows .For linuxI am using Java 6Correct:Incorrect:You can try java -Djava.ext.dirs=jarDirectory \nhttp://docs.oracle.com/javase/6/docs/technotes/guides/extensions/spec.htmlDirectory for external jars when running javaWindows:\n java -cp file.jar;dir/* my.app.ClassNameLinux:\njava -cp file.jar:dir/* my.app.ClassNameRemind:\n- Windows path separator is ";"\n- Linux path separator is ":"\n- In Windows if cp argument does not contains white space, the "quotes" is optionalIf you really need to specify all the .jar files dynamically you could use shell scripts, or Apache Ant. There\'s a commons project called Commons Launcher which basically lets you specify your startup script as an ant build file (if you see what I mean).Then, you can specify something like:In your launch build file, which will launch your application with the correct classpath.If you are using Java 6, then you can use wildcards in the classpath.Now it is possible to use wildcards in classpath definition:Ref: http://www.rekk.de/bloggy/2008/add-all-jars-in-a-directory-to-classpath-with-java-se-6-using-wildcards/Please note that wildcard expansion is broken for Java 7 on Windows.Check out this StackOverflow issue for more information.The workaround is to put a semicolon right after the wildcard. java -cp "somewhere/*;"All the above solutions work great if you develop and run the Java application outside any IDE like Eclipse or Netbeans.If you are on Windows 7 and used Eclipse IDE for Development in Java, you might run into issues if using Command Prompt to run the class files built inside Eclipse.E.g. Your source code in Eclipse is having the following package hierarchy:\nedu.sjsu.myapp.Main.javaYou have json.jar as an external dependency for the Main.javaWhen you try running Main.java from within Eclipse, it will run without any issues.But when you try running this using Command Prompt after compiling Main.java in Eclipse, it will shoot some weird errors saying "ClassNotDef Error blah blah".I assume you are in the working directory of your source code !!Use the following syntax to run it from command prompt:javac -cp ".;json.jar" Main.javajava -cp ".;json.jar" edu.sjsu.myapp.Main[Don\'t miss the . above]This is because you have placed the Main.java inside the package edu.sjsu.myapp and java.exe will look for the exact pattern.Hope it helps !!For windows quotes are required and ; should be used as separator. e.g.:To whom it may concern,I found this strange behaviour on Windows under an MSYS/MinGW shell.Works:Doesn\'t work:I am quite sure that the wildcard is not expanded by the shell, because e.g.(Tried it with another program too, rather than the built-in echo, with the same result.)I believe that it\'s javac which is trying to expand it, and it behaves differently whether there is a semicolon in the argument or not. First, it may be trying to expand all arguments that look like paths. And only then it would parse them, with -cp taking only the following token. (Note that com.comsol.aco_1.0.0.jar is the second JAR in that directory.) That\'s all a guess.This is Short Form: If your main is within a jar, you\'ll probably need an additional \'-jar pathTo/yourJar/YourJarsName.jar \'  explicitly declared to get it working (even though \'YourJarsName.jar\' was on the classpath)\n(or, expressed to answer the original question that was asked 5 years ago: you don\'t need to redeclare each jar explicitly, but does seem, even with java6 you need to redeclare your own jar ...) Long Form: \n(I\'ve made this explicit to the point that I hope even interlopers to java can make use of this) Like many here I\'m using eclipse to export jars: (File->Export-->\'Runnable JAR File\'). There are three options on \'Library handling\' eclipse (Juno) offers:Typically I\'d use opt2 (and opt1 was definitely breaking), however native code in one of the jars I\'m using I discovered breaks with the handy "jarinjar" trick that eclipse leverages when you choose that option. Even after realizing I needed opt3, and then finding this StackOverflow entry, it still took me some time to figure it out how to launch my main outside of eclipse, so here\'s what worked for me, as it\'s useful for others...If  you named your jar: "fooBarTheJarFile.jar" \nand all is set to export to the  dir:     "/theFully/qualifiedPath/toYourChosenDir". (meaning the  \'Export destination\' field will read:   \'/theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile.jar\' )After you hit finish, you\'ll find eclipse then puts all the libraries into a folder named \'fooBarTheJarFile_lib\' within that export directory, giving you something like:You can then launch from anywhere on your system with: (For Java Newbies:  \'package.path_to.the_class_with.your_main\' is the declared package-path that you\'ll find at the top of the \'TheClassWithYourMain.java\' file that contains the \'main(String[] args){...}\' that you wish to run from outside java)The pitfall to notice: is that having \'fooBarTheJarFile.jar\' within the list of jars on your declared classpath is not enough.  You need to explicitly declare \'-jar\', and redeclare the location of that jar. e.g. this breaks:  restated with relative paths:(using java version "1.6.0_27"; via  OpenJDK 64-Bit Server VM  on ubuntu 12.04)The only way I know how is to do it individually, for example:Hope that helps!Not a direct solution to being able to set /* to -cp but I hope you could use the following script to ease the situation a bit for dynamic class-paths and lib directories.Scripted for Linux, could have a similar one for windows too. If proper directory is provided as input to the "libDir2Scan4jars"; the script will scan all the jars and create a classpath string and export it to a env variable "tmpCLASSPATH". You need to add them all separately.  Alternatively, if you really need to just specify a directory, you can unjar everything into one dir and add that to your classpath.  I don\'t recommend this approach however as you risk bizarre problems in classpath versioning and unmanagability.Think of a jar file as the root of a directory structure. Yes, you need to add them all separately.class from wepapp:Set the classpath in a way suitable multiple jars and current directory\'s class files. 