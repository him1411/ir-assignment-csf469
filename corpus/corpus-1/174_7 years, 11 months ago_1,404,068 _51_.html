How do I reset my local branch to be just like the branch on the remote repository?I did:But when I run a git status,Can you please tell me why I have these \'modified\'? I haven\'t touched these files? If I did, I want to remove those.Setting your branch to exactly match the remote branch can be done in two steps:If you want to save your current branch\'s state before doing this (just in case), you can do:Now your work is saved on the branch "my-saved-work" in case you decide you want it back (or want to look at it later or diff it against your updated branch).Note that the first example assumes that the remote repo\'s name is "origin" and that the branch named "master" in the remote repo matches the currently checked-out branch in your local repo.BTW, this situation that you\'re in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it\'s not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular).I needed to do (the solution in the accepted answer):Followed by:to remove local filesTo see what files will be removed (without actually removing them):git reset --hard HEAD actually only resets to the last committed state. In this case HEAD refers to the HEAD of your branch. If you have several commits, this won\'t work..What you probably want to do, is reset to the head of origin or whatever you remote repository is called. I\'d probably just do something like Be careful though. Hard resets cannot easily be undone. It is better to do as Dan suggests, and branch off a copy of your changes before resetting. First, reset to the previously fetched HEAD of the corresponding upstream branch:The advantage of specifying @{u} or its verbose form @{upstream} is that the name of the remote repo and branch don\'t have to be explicitly specified.Next, get the latest changes:All of the above suggests are right, but often to really reset your project, you also need to remove even files that are in your .gitignore.To get the moral equivalent of erasing your project directory and re-cloning from the remote is:Warning: git clean -x -d -f is irreversible and you may loose files and data (e.g. things you have ignored using .gitignore).The question mixes two issues here:The one-stop-answer is:This is something I face regularly, & I\'ve generalised the script Wolfgang provided above to work with any branchI also added an "are you sure" prompt, & some feedback outputHere is a script that automates what the most popular answer suggests ...\nSee https://stackoverflow.com/a/13308579/1497139 for an improved version that supports branchesI did:to totally reset branchnote, you should checkout to another branch to be able to delete required branchIf you had a problem as me, that you have already committed some changes, but now, for any reason you want to get rid of it, the quickest way is to use git reset like this:I had 2 not needed commits, hence the number 2. You can change it to your own number of commits to reset.So answering your question - if you\'re 5 commits ahead of remote repository HEAD, you should run this command:Notice that you will lose the changes you\'ve made, so be careful!Provided that the remote repository is origin, and that you\'re interested in branch_name:How it works:git fetch origin downloads the latest from remote without trying to merge or rebase anything.Then the git reset resets the master branch to what you just fetched. The --hard option changes all the files in your working tree to match the files in origin/branch_name.If you want to go back to the HEAD state for both the working directory and the index, then you should git reset --hard HEAD, rather than to HEAD^. (This may have been a typo, just like the single versus double dash for --hard.)As for your specific question as to why those files appear in the status as modified, it looks like perhaps you did a soft reset instead of a hard reset.  This will cause the files that were changed in the HEAD commit to appear as if they were staged, which is likely what you are seeing here.Previous answers assume that the branch to be reset is the current branch (checked out). In comments, OP hap497 clarified that the branch is indeed checked out, but this is not explicitly required by the original question. Since there is at least one "duplicate" question, Reset branch completely to repository state, which does not assume that the branch is checked out, here\'s an alternative:If branch "mybranch" is not currently checked out, to reset it to remote branch "myremote/mybranch"\'s head, you can use this low-level command:This method leaves the checked out branch as it is, and the working tree untouched. It simply moves mybranch\'s head to another commit, whatever is given as the second argument. This is especially helpful if multiple branches need to be updated to new remote heads.Use caution when doing this, though, and use gitk or a similar tool to double check source and destination. If you accidentally do this on the current branch (and git will not keep you from this), you may become confused, because the new branch content does not match the working tree, which did not change (to fix, update the branch again, to where it was before).No amount of reset and cleaning seemed to have any effect on untracked and modified files in my local git repo (I tried all the options above). My only solution to this was to rm the local repo and re-clone it from the remote.Fortunately I didn\'t have any other branches I cared about.If you don\'t mind saving your local changes, yet still want to update your repository to match origin/HEAD, you can simply stash your local changes and then pull:The only solution that works in all cases that I\'ve seen is to delete and reclone. Maybe there\'s another way, but obviously this way leaves no chance of old state being left there, so I prefer it. Bash one-liner you can set as a macro if you often mess things up in git:* assumes your .git files aren\'t corruptIf you want the current changes to be used later then stash the changes other wise you can use these two commands,