I want to match a portion of a string using a regular expression and then access that parenthesized substring:What am I doing wrong?I\'ve discovered that there was nothing wrong with the regular expression code above: the actual string which I was testing against was this:Reporting that "%A" is undefined seems a very strange behaviour, but it is not directly related to this question, so I\'ve opened a new one, Why is a matched substring returning "undefined" in JavaScript?.The issue was that console.log takes its parameters like a printf statement, and since the string I was logging ("%A") had a special value, it was trying to find the value of the next parameter.You can access capturing groups like this:And if there are multiple matches you can iterate over them:Here\xe2\x80\x99s a method you can use to get the n\xe2\x80\x8bth capturing group for each match:The \\b isn\'t exactly the same thing. (It works on --format_foo/, but doesn\'t work on format_a_b) But I wanted to show an alternative to your expression, which is fine. Of course, the match call is the important thing.Your syntax probably isn\'t the best to keep. FF/Gecko defines RegExp as an extension of Function.\n(FF2 went as far as typeof(/pattern/) == \'function\')It seems this is specific to FF -- IE, Opera, and Chrome all throw exceptions for it.Instead, use either method previously mentioned by others: RegExp#exec or String#match.\nThey offer the same results:In regards to the multi-match parentheses examples above, I was looking for an answer here after not getting what I wanted from:After looking at the slightly convoluted function calls with while and .push() above, it dawned on me that the problem can be solved very elegantly with mystring.replace() instead (the replacing is NOT the point, and isn\'t even done, the CLEAN, built-in recursive function call option for the second parameter is!):After this, I don\'t think I\'m ever going to use .match() for hardly anything ever again.A one liner that is practical only if you have a single pair of parenthesis:Last but not least, i found that one line code that worked fine for me (JS ES6) :this will return : [fiestasdefindea\xc3\xb1o, PadreHijo, buenosmomentos, france, paris]Using your code:Edit: Safari 3, if it matters.Your code works for me (FF3 on Mac) even if I agree with PhiLo that the regex should probably be:(But, of course, I\'m not sure because I don\'t know the context of the regex.)There is no need to invoke the exec method! You can use "match" method directly on the string. Just don\'t forget the parentheses.Position 0 has a string with all the results. Position 1 has the first match represented by parentheses, and position 2 has the second match isolated in your parentheses. Nested parentheses are tricky, so beware!To get access to the matched groups, in each of the matched patterns, you need a function or something similar to iterate over the match. There are a number of ways you can do this, as many of the other answers show. Most other answers use a while loop to iterate over all matched patterns, but I think we all know the potential dangers with that approach. It is necessary to match against a new RegExp() instead of just the pattern itself, which only got mentioned in a comment. This is because the .exec() method behaves similar to a generator function \xe2\x80\x93 it stops every time there is a match, but keeps its .lastIndex to continue from there on the next .exec() call.Below is an example of a function searchString which returns an Array of all matched patterns, where each match is an Array with all the containing matched groups. Instead of using a while loop, I have provided examples using both the Array.prototype.map() function as well as a more performant way \xe2\x80\x93 using a plain for-loop.These are less performant since they basically implement a forEach-loop instead of the faster for-loop.I have yet to compare these alternatives to the ones previously mentioned in the other answers, but I doubt this approach is less performant and less fail-safe than the others.Have a look at this link on lesson 12: You can group characters using the special ( and ) (parentheses). To capture the image file write the expression ^(IMG(\\d+))\\.png$.