How can I loop through all the entries in an array using JavaScript?I thought it was something like this:Where theArray is my array, but this seems to be incorrect.TL;DRYour best bets are usuallyBut there\'s lots more to explore, read on...JavaScript has powerful semantics for looping through arrays and array-like objects. I\'ve split the answer into two parts: Options for genuine arrays, and options for things that are just array-like, such as the arguments object, other iterable objects (ES2015+), DOM collections, and so on.I\'ll quickly note that you can use the ES2015 options now, even on ES5 engines, by transpiling ES2015 to ES5. Search for "ES2015 transpiling" / "ES6 transpiling" for more...Okay, let\'s look at our options:You have three options in ECMAScript 5 ("ES5"), the version most broadly supported at the moment, and will soon have two more in ECMAScript 2015 ("ES2015", "ES6"), the latest version of JavaScript that vendors are working on supporting:Details:If you\'re using an environment that supports the Array features of ES5 (directly or using a shim), you can use the new forEach (spec | MDN):forEach accepts an iterator function and, optionally, a value to use as this when calling that iterator function (not used above). The iterator function is called for each entry in the array, in order, skipping non-existent entries in sparse arrays. Although I only used one argument above, the iterator function is called with three: The value of each entry, the index of that entry, and a reference to the array you\'re iterating over (in case your function doesn\'t already have it handy).Unless you\'re supporting obsolete browsers like IE8 (which NetApps shows at just over 4% market share as of this writing in September 2016), you can happily use forEach in a general-purpose web page without a shim. If you do need to support obsolete browsers, shimming/polyfilling forEach is easily done (search for "es5 shim" for several options).forEach has the benefit that you don\'t have to declare indexing and value variables in the containing scope, as they\'re supplied as arguments to the iteration function, and so nicely scoped to just that iteration.If you\'re worried about the runtime cost of making a function call for each array entry, don\'t be; details.Additionally, forEach is the "loop through them all" function, but ES5 defined several other useful "work your way through the array and do things" functions, including:Sometimes the old ways are the best:If the length of the array won\'t change during the loop, and it\'s in performance-sensitive code (unlikely), a slightly more complicated version grabbing the length up front might be a tiny bit faster:And/or counting backward:But with modern JavaScript engines, it\'s rare you need to eke out that last bit of juice.In ES2015 and higher, you can make your index and value variables local to the for loop:And when you do that, not just value but also index is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the index (and value) created for that specific iteration:If you had five divs, you\'d get "Index is: 0" if you clicked the first and "Index is: 4" if you clicked the last. This does not work if you use var instead of let.You\'ll get people telling you to use for-in, but that\'s not what for-in is for. for-in loops through the enumerable properties of an object, not the indexes of an array. The order is not guaranteed, not even in ES2015 (ES6). ES2015 does define an order to object properties (via [[OwnPropertyKeys]], [[Enumerate]], and things that use them like Object.getOwnPropertyKeys), but it does not define that for-in will follow that order. (Details in this other answer.)Still, it can be useful, particularly for sparse arrays, if you use appropriate safeguards:Note the two checks:That the object has its own property by that name (not one it inherits from its prototype), andThat the key is a base-10 numeric string in its normal string form and its value is <= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It\'s part of the definition of an array index in the specification. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it\'s 2^32 - 2 is that that makes the greatest index value one lower than 2^32 - 1, which is the maximum value an array\'s length can have. (E.g., an array\'s length fits in a 32-bit unsigned integer.) (Props to RobG for pointing out in a comment on my blog post that my previous test wasn\'t quite right.)That\'s a tiny bit of added overhead per loop iteration on most arrays, but if you have a sparse array, it can be a more efficient way to loop because it only loops for entries that actually exist. E.g., for the array above, we loop a total of three times (for keys "0", "10", and "10000" — remember, they\'re strings), not 10,001 times.Now, you won\'t want to write that every time, so you might put this in your toolkit:And then we\'d use it like this:Or if you\'re interested in just a "good enough for most cases" test, you could use this, but while it\'s close, it\'s not quite correct:ES2015 adds iterators to JavaScript. The easiest way to use iterators is the new for-of statement. It looks like this:Output:Under the covers, that gets an iterator from the array and loops through it, getting the values from it. This doesn\'t have the issue that using for-in has, because it uses an iterator defined by the object (the array), and arrays define that their iterators iterate through their entries (not their properties). Unlike for-in in ES5, the order in which the entries are visited is the numeric order of their indexes.Sometimes, you might want to use an iterator explicitly. You can do that, too, although it\'s a lot clunkier than for-of. It looks like this:The iterator is a function (specifically, a generator) that returns a new object each time you call next. The object returned by the iterator has a property, done, telling us whether it\'s done, and a property value with the value for that iteration.The meaning of value varies depending on the iterator; arrays support (at least) three functions that return iterators:(As of this writing, Firefox 29 supports entries and keys but not values.)Aside from true arrays, there are also array-like objects that have a length property and properties with numeric names: NodeList instances, the arguments object, etc. How do we loop through their contents?At least some, and possibly most or even all, of the array approaches above frequently apply equally well to array-like objects:Use forEach and related (ES5+)The various functions on Array.prototype are "intentionally generic" and can usually be used on array-like objects via Function#call or Function#apply. (See the Caveat for host-provided objects at the end of this answer, but it\'s a rare issue.)Suppose you wanted to use forEach on a Node\'s childNodes property. You\'d do this:If you\'re going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:Use a simple for loopObviously, a simple for loop applies to array-like objects.Use for-in correctlyfor-in with the same safeguards as with an array should work with array-like objects as well; the caveat for host-provided objects on #1 above may apply.Use for-of (use an iterator implicitly) (ES2015+)for-of will use the iterator provided by the object (if any); we\'ll have to see how this plays with the various array-like objects, particularly host-provided ones.Use an iterator explicitly (ES2015+)See #4, we\'ll have to see how iterators play out.Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:Use the slice method of arraysWe can use the slice method of arrays, which like the other methods mentioned above is "intentionally generic" and so can be used with array-like objects, like this:So for instance, if we want to convert a NodeList into a true array, we could do this:See the Caveat for host-provided objects below. In particular, note that this will fail in IE8 and earlier, which don\'t let you use host-provided objects as this like that.Use spread notation (...)It\'s also possible to use ES2015\'s spread notation (MDN currently calls it an operator; it isn\'t one), with JavaScript engines that support this feature:So for instance, if we want to convert a NodeList into a true array, with spread syntax this becomes quite succinct:Use Array.from (spec) | (MDN)Array.from (ES2015, but shimmable) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:Or if you wanted to get an array of the tag names of the elements with a given class, you\'d use the mapping function:If you use Array.prototype functions with host-provided array-like objects (DOM lists and other things provided by the browser rather than the JavaScript engine), you need to be sure to test in your target environments to make sure the host-provided object behaves properly. Most do behave properly (now), but it\'s important to test. The reason is that most of the Array.prototype methods you\'re likely to want to use rely on the host-provided object giving an honest answer to the abstract [[HasProperty]] operation. As of this writing, browsers do a very good job of this, but the ES5 spec did allow for the possibility a host-provided object may not be honest; it\'s in \xc2\xa78.6.2 (several paragraphs below the big table near the beginning of that section), where it says:Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that [[Get]] and [[Put]] for a particular host object indeed fetch and store property values but [[HasProperty]] always generates false.(I couldn\'t find the equivalent verbiage in the ES2015 spec, but it\'s bound to still be the case.) Again, as of this writing the common host-provided array-like objects in modern browsers (NodeList instances, for instance) do handle [[HasProperty]] correctly, but it\'s important to test.Edit: This answer is hopelessly out-of-date. For a more modern approach, look at the methods available on an array. Methods of interest might be:The standard way to iterate an array in JavaScript is a vanilla for-loop:Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not really exist in the array. In this case, a for .. in-loop might be a better idea. However, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the for..in-loop will also be enumerated in legacy browsers, or if the additional properties are defined as enumerable.In ECMAScript 5 there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, Node.js for server side JavaScript), or use a "Polyfill". The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.If you\xe2\x80\x99re using the jQuery library, you can use jQuery.each:EDIT : As per question, user want code in javascript instead of jquery so the edit isI think the reverse for loop deserves a mention here:Some developers use the reverse for loop by default, unless there is a good reason to loop forwards.Although the performance gains are usually insignificant, it sort of screams:"Just do this to every item in the list, I don\'t care about the order!"However in practice that is not actually a reliable indication of intent, since it is indistinguishable from those occasions when you do care about the order, and really do need to loop in reverse.  So in fact another construct would be needed to accurately express the "don\'t care" intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, forEachUnordered().If order doesn\'t matter, and efficiency is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code does not necessarily mean that the order irrelevant!In general for higher level code where clarity and safety are greater concerns, I would recommend using Array::forEach as your default pattern:Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford\'s lecture on Programming Style & Your Brain.)You will notice that i-- is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see i++).  That means that i-- is also used as the condition for continuation.  Crucially, it is executed and checked before each iteration.How can it start at array.length without exploding?Because i-- runs before each iteration, on the first iteration we will actually be accessing the item at array.length - 1 which avoids any issues with Array-out-of-bounds undefined items.Why doesn\'t it stop iterating before index 0?The loop will stop iterating when the condition i-- evaluates to a falsey value (when it yields 0).The trick is that unlike --i, the trailing i-- operator decrements i but yields the value before the decrement.  Your console can demonstrate this:> var i = 5; [i, i--, i];[5, 5, 4]So on the final iteration, i was previously 1 and the i-- expression changes it to 0 but actually yields 1 (truthy), and so the condition passes.  On the next iteration i-- changes i to -1 but yields 0 (falsey), causing execution to immediately drop out of the bottom of the loop.In the traditional forwards for loop, i++ and ++i are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with i-- if we want to process the item at index 0.Some people like to draw a little arrow in the reverse for loop, and end with a wink:Credits go to WYL for showing me the benefits and horrors of the reverse for loop.Some C-style languages use foreach to loop through enumerations. In JavaScript this is done with the for..in loop structure:There is a catch. for..in will loop through each of the object\'s enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object\'s prototype, simply check if the property belongs to the object:Additionally, ECMAScript 5 has added a forEach method to Array.prototype which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):It\'s important to note that Array.prototype.forEach doesn\'t break when the callback returns false. jQuery and Underscore.js provide their own variations on each to provide loops that can be short-circuited.If you want to loop over an array, use the standard three-part for loop.You can get some performance optimisations by caching myArray.length or iterating over it backwards.A forEach implementation (see in jsFiddle):If you don\'t mind emptying the array:x will contain the last value of y and it will be removed from the array. You can also use shift() which will give and remove the first item from y.I know this is an old post, and there are so many great answers already. For a little more completeness I figured I\'d throw in another one using AngularJS. Of course, this only applies if you\'re using Angular, obviously, nonetheless I\'d like to put it anyway.angular.forEach takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as \'this\'.There are different ways to use the forEach loop of angular. The simplest and probably most used isAnother way that is useful for copying items from one array to another isThough, you don\'t have to do that, you can simply do the following and it\'s equivalent to the previous example:Now there are pros and cons of using the angular.forEach function as opposed to the built in vanilla-flavored for loop.ProsConsider the following 2 nested loops, which do exactly the same thing. Let\'s say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that\'s a string (or whatever). And let\'s say we need to iterate over each of the results and if they\'re equal then perform some action: Granted this is a very simple hypothetical example, but I\'ve written triple embedded for loops using the second approach and it was very hard to read, and write for that matter.ConsI\'m sure there\'s various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native for loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an angular.forEach in that bad boy.An easy solution now would be to use the underscore.js library. It\'s providing many useful tools, such as each and will automatically delegate the job to the native forEach if available.A CodePen example of how it works is:Probably the for(i = 0; i < array.length; i++) loop is not the best choice. Why? If you have this:The method will call from array[0] to array[2]. First, this will first reference variables you don\'t even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it\'s what I use:And if you want it to be a function, you can do this:If you want to break, a little more logic:Example:It returns:There are three implementations of foreach in jQuery as follows.There isn\'t any for each loop in native JavaScript. You can either use libraries to get this functionality (I recommend Underscore.js), use a simple for in loop.However, note that there may be reasons to use an even simpler for loop (see Stack Overflow question Why is using \xe2\x80\x9cfor\xe2\x80\xa6in\xe2\x80\x9d with array iteration such a bad idea?)As of ES6:Where of avoids the oddities associated with in and makes it work like the for loop of any other language, and let binds i within the loop as opposed to within the function.The braces ({}) can be omitted when there is only one command (e.g. in the example above).This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)Examples of usage:Example #1Example #2Each p tag gets class="blue"Example #3Every other p tag gets class="red">Example #4And finally the first 20 blue p tags are changed to greenCaution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive.There\'s no inbuilt ability to break in forEach. To interrupt execution use the Array#some like below:This works because some returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. \nOriginal Answer\nsee Array prototype for somejQuery way using $.map:ECMAScript5 (the version on Javascript) to work with Arrays.forEach - Iterates through every item in the array and do whatever you need with each item.In case , more interested on operation on array using some inbuilt feature.map - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.reduce - As the name says it reduces the array to a single value by calling the given function passing in the currenct element and the result of the previous execution.every - Returns true or false if all the elements in the array pass the test in the callback function.filter - Very similar to every except that filter return an array with the elements that return true to the given function.Hope this will be useful.There are a few ways to loop through an array in JavaScript, as below:for - it\'s the most common one. Full block of code for loopingwhile - loop while a condition is through. It seems to be the fastest loopdo/while - also loop through a block of code while the condition is trueAsynchronous loops - forEach, map function, filter, also reduce (they loop through the function, but used if you need to do something with your arraym, etc.For more information and examples about asynchronous functions on arrays, look at the blog post Functional programming in JavaScript: map, filter and reduce.I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.Pros:The benefit for this: You have the reference already in the first like that won\'t need to be declared later with another line. It is handy when looping trough the object array.Cons:This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read.