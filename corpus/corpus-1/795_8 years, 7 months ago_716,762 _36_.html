I need to keep a session alive for 30 minutes and then destroy it. You should implement a session timeout of your own. Both options mentioned by others (session.gc_maxlifetime and session.cookie_lifetime) are not reliable. I\'ll explain the reasons for that.First:session.gc_maxlifetime\n  session.gc_maxlifetime specifies the number of seconds after which data will be seen as \'garbage\' and cleaned up. Garbage collection occurs during session start.But the garbage collector is only started with a probability of session.gc_probability divided by session.gc_divisor. And using the default values for those options (1 and 100 respectively), the chance is only at 1%.Well, you could simply adjust these values so that the garbage collector is started more often. But when the garbage collector is started, it will check the validity for every registered session. And that is cost-intensive.Furthermore, when using PHP\'s default session.save_handler files, the session data is stored in files in a path specified in session.save_path. With that session handler, the age of the session data is calculated on the file\'s last modification date and not the last access date:Note: If you are using the default file-based session handler, your filesystem must keep track of access times (atime). Windows FAT does not so you will have to come up with another way to handle garbage collecting your session if you are stuck with a FAT filesystem or any other filesystem where atime tracking is not available. Since PHP 4.2.3 it has used mtime (modified date) instead of atime. So, you won\'t have problems with filesystems where atime tracking is not available.So it additionally might occur that a session data file is deleted while the session itself is still considered as valid because the session data was not updated recently.And second:session.cookie_lifetime\n  session.cookie_lifetime specifies the lifetime of the cookie in seconds which is sent to the browser. [\xe2\x80\xa6]Yes, that\'s right. This only affects the cookie lifetime and the session itself may still be valid. But it\'s the server\'s task to invalidate a session, not the client. So this doesn\'t help anything. In fact, having session.cookie_lifetime set to 0 would make the session\xe2\x80\x99s cookie a real session cookie that is only valid until the browser is closed.Conclusion / best solution:The best solution is to implement a session timeout of your own. Use a simple time stamp that denotes the time of the last activity (i.e. request) and update it with every request:Updating the session data with every request also changes the session file\'s modification date so that the session is not removed by the garbage collector prematurely.You can also use an additional time stamp to regenerate the session ID periodically to avoid attacks on sessions like session fixation:Notes:Note : if you want to change the time, just change the 30 with your desired time and do not change * 60: this will gives the minutes.In minutes : (30 * 60) \nIn days : (n * 24 * 60 * 60 ) n = no of days  Is this to log the user out after a set time? Setting the session creation time (or an expiry time) when it is registered, and then checking that on each page load could handle that.E.g.:Edit: I\'ve got a feeling you mean something else though.You can scrap sessions after a certain lifespan by using the session.gc_maxlifetime ini setting:Edit:\n    ini_set(\'session.gc_maxlifetime\', 60*30);This post shows a couple of ways of controlling the session timeout: http://bytes.com/topic/php/insights/889606-setting-timeout-php-sessionsIMHO the second option is a nice solution:Well i understand the aboves answers are correct but they are on application level, why don\'t we simply use .htaccess file to set the expire time ?It\'s actually easy with a function like the following. It uses database table name \'sessions\' with fields \'id\' and \'time\'.Every time when the user visits your site or service again you should invoke this function to check if its return value is TRUE. If it\'s FALSE the user has expired and the session will be destroyed (Note: This function uses a database class to connect and query the database, of course you could also do it inside your function or something like that):Use the session_set_cookie_paramsfunciton for make this.Is necessary calling this function before session_start() call.Try this:See more in: http://php.net/manual/function.session-set-cookie-params.phpStore a timestamp in the sessionNow, Check if the timestamp is within the allowed time window (1800 seconds is 30 minutes)Please use following block of code in your include file which loaded in every pages.