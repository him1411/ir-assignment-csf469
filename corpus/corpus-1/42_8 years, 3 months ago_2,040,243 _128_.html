Is there something in JavaScript similar to @import in CSS that allows you to include a JavaScript file inside another JavaScript file?The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.But recent versions of JavaScript have standards like ES6 modules to import modules, although this is not supported yet by most browsers.  Many people using modules with browser applications use build and/or transpilation tools to make it practical to use new syntax with features like modules.Note that currently, browser support for ES6 Modules is not particularly great, but it is on it\'s way. According to this StackOverflow answer, they are supported (but behind flags) in Chrome 60, Firefox 54 and MS Edge 15, with only Safari 10.1 providing support without flags.Thus, you will currently still need to use build and/or transpilation tools to valid JavaScript that will run in without any requirement for the user to use those browser versions or enable any flags.Once ES6 Modules are commonplace, here is how you would go about using them:Node.js is currently using a module.exports/require system.  You can use babel to transpile if you want the import syntax.    There are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.You could load an additional script with an AJAX call and then use eval to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using eval also opens the door to bugs, hacks and security issues.The jQuery library provides loading functionality in one line:You could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.The script can even reside on a different server. Furthermore, the browser evaluates the code. The <script> tag can be injected into either the web page <head>, or inserted just before the closing </body> tag.Here is an example of how this could work:This function will add a new <script> tag to end of the head section of the page, where the src attribute is set to the URL which is given to the function as the first parameter.Both of these solutions are discussed and illustrated in JavaScript Madness: Dynamic Script Loading.Now, there is a big issue you must know about. Doing that implies that you remotely load the code. Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)It means that if you use these tricks directly, you won\'t be able to use your newly loaded code the next line after you asked it to be loaded, because it will be still loading.For example: my_lovely_script.js contains MySuperObject:Then you reload the page hitting F5. And it works! Confusing...So what to do about it ?Well, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:Then you write the code you want to use AFTER the script is loaded in a lambda function:Then you run all that:Note that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line script.async = false;. There\'s a great article on Javascript loading in general which discusses this.As mentioned at the top of this answer, many developers now use build/transpilation tool(s) like WebPack, Babel, or Gulp in their projects, allowing them to use new syntax and support modules better, combine files, minify, etc.If anyone is looking for something more advanced, try out RequireJS. You\'ll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).You can write your JavaScript files in "modules" and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple "go get this script" solution.Example:Define dependencies as modules:some-dependency.jsimplementation.js is your "main" JavaScript file that depends on some-dependency.jsExcerpt from the GitHub README:RequireJS loads plain JavaScript files as well as more defined\n  modules. It is optimized for in-browser use, including in a Web\n  Worker, but it can be used in other JavaScript environments, like\n  Rhino and Node. It implements the Asynchronous Module API.RequireJS uses plain script tags to load modules/files, so it should\n  allow for easy debugging. It can be used simply to load existing\n  JavaScript files, so you can add it to your existing project without\n  having to re-write your JavaScript files.... There actually is a way to load a JavaScript file not asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.You need to use jQuery.append() on the <head> element of your page, that is:However, this method also has a problem: if an error happens in the imported JavaScript file, Firebug (and also Firefox Error Console and Chrome Developer Tools as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn\'t know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main HTML file, and you will have trouble finding out the real reason for the error.But if that is not a problem for you, then this method should work.I have actually written a jQuery plugin called $.import_js() which uses this method:So all you would need to do to import JavaScript is:$.import_js(\'/path_to_project/scripts/somefunctions.js\');I also made a simple test for this at http://www.kipras.com/dev/import_js_test/.It includes a main.js file in the main HTML and then the script in main.js uses $.import_js() to import an additional file called included.js, which defines this function:And right after including included.js, the hello() function is called, and you get the alert.(This answer is in response to e-satis\' comment).Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a <script> tag. Which is also how Node.js handles includes.Here\'s an example using jQuery:You can then use it in your code as you\'d usually use an include:And be able to call a function from the required script in the next line:There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself. You simply have to write import cond from \'cond.js\'; to load a macro named cond from a file cond.js.So you don\'t have to rely upon any JavaScript framework nor do you have to explicitly make Ajax calls.Refer to:Static module resolutionModule loadersIt is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.Statement import is in ECMAScript 6.SyntaxMaybe you can use this function that I found on this page How do I include a JavaScript file in a JavaScript file?:Here is a synchronous version without jQuery:Note that to get this working cross-domain, the server will need to set allow-origin header in its response.I just wrote this JavaScript code (using Prototype for DOM manipulation):Usage:Gist: http://gist.github.com/284442.This is perhaps the biggest weakness of JavaScript in my opinion. It\'s caused me no end of problems over the years with dependency tracing. Anyhow, it does appear that the only practical solution is to use script includes in the HTML file and thus horribly making your JavaScript code dependent upon the user including the source you need and making reuse unfriendly.Sorry if this comes across as a lecture ;) It\'s a (bad) habit of mine, but I want to make this point.The problem comes back to the same as everything else with the web, the history of JavaScript. It really wasn\'t designed to be used in the widespread manner it\'s used in today. Netscape made a language that would allow you to control a few things, but they didn\'t envisage its widespread use for so many things as it is put to now and for one reason or another it\'s expanded from there, without addressing some of the fundamental weaknesses of the original strategy.It\'s not alone of course. HTML wasn\'t designed for the modern webpage; it was designed to be a way of expressing the logic of a document, so that readers (browsers in the modern world) could display this in an applicable form that was within the capabilities of the system, and it took years for a solution (other than the hacks of MS and Netscape) to come along. CSS solves this problem, but it was a long time coming and even longer to get people to use it rather than the established BAD techniques. It happened though, praise be.Hopefully JavaScript (especially now it\'s part of the standard) will develop to take on board the concept of proper modularity (as well as some other things) as every other (extant) programming language in the world does and this stupidity will go away. Until then you just have to not like it and lump it, I\'m afraid.Here\'s the generalized version of how Facebook does it for their ubiquitous Like button:If it works for Facebook, it will work for you.The reason why we look for the first script element instead of head or body is because some browsers don\'t create one if missing, but we\'re guaranteed to have a script element - this one. Read more at http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/.You can also assemble your scripts using PHP:File main.js.php:Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as Less/Sass preprocessors deal with the CSS @import at-rule. Since I didn\'t find anything decent of this sort, I wrote a simple tool solving the issue.So here is the compiler, https://github.com/dsheiko/jsic, which replaces $import("file-path") with the requested file content securely. Here is the corresponding Grunt plugin: https://github.com/dsheiko/grunt-jsic.On the jQuery master branch, they simply concatenate atomic source files into a single one starting with intro.js and ending with outtro.js. That doesn\'t suits me as it provides no flexibility on the source code design. Check out how it works with jsic:src/main.jssrc/Form/Input/Tel.jsNow we can run the compiler:And get the combined filebuild/main.jsIf you want in pure JavaScript, you can use document.write.If you use the jQuery library, you can use the $.getScript method.This should do:Or rather than including at run time, use a script to concatenate prior to upload.I use Sprockets (I don\'t know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...See also:If your intention to load the JavaScript file is using the functions from the imported/included file, you can also define a global object and set the functions as object items. For instance:You just need to be careful when you are including scripts in an HTML file. The order should be as in below:In case you are using Web Workers and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the head tag, etc. will not work for you.Fortunately, Web Workers have their own importScripts function which is a global function in the scope of the Web Worker, native to the browser itself as it is part of the specification.Alternatively, as the second highest voted answer to your question highlights, RequireJS can also handle including scripts inside a Web Worker (likely calling importScripts itself, but with a few other useful features).I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post JavaScript require / import / include modules.I had a simple issue, but I was baffled by responses to this question.I had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).For this I did as below:Loaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:File: myvariables.jsFile: main.jsAs you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn\'t need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file\'s variables are accessible in the second JavaScript file, automatically.This saved my day. I hope this helps.There is also Head.js. It is very easy to deal with:As you see, it\'s easier than Require.js and as convenient as jQuery\'s $.getScript method. It also has some advanced features, like conditional loading, feature detection and much more.The @import syntax for achieving CSS-like JavaScript importing is possible using a tool such as Mixture via their special .mix file type (see here). I imagine the application simply uses one of the aforementioned methods interally, though I don\'t know. From the Mixture documentation on .mix files: Mix files are simply .js or .css files with .mix. in the file name. A\n  mix file simply     extends the functionality of a normal style or\n  script file and allows you to import and combine.Here\'s an example .mix file that combines multiple .js files into one:Mixture outputs this as scripts-global.js and also as a minified version (scripts-global.min.js).Note: I\'m not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a .mix JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it ("you can do this?" I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.UPDATE: Mixture is now free. I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:1) Set up a file called "plugins.js" (or extentions.js or what have you). Keep your plugin files together with that one master file.2) plugins.js will have an array called "pluginNames[]" that we will iterate over each(),\nthen append a  tag to the head for each plugin3) manually call just the one file in your head:\n<script src="js/plugins/plugins.js"></script>UPDATE: I found that even though all of the plugins were getting dropped into the head tag the way they ought to, they weren\'t always being run by the browser when you click into the page or refresh.I found it\'s more reliable to just write the script tags in a PHP include. You only have to write it once and that\'s just as much work as calling the plugin using JavaScript.I have created a function that will allow you to use similar verbiage to C#/Java to include a JavaScript file. I\'ve tested it a little bit even from inside of another JavaScript file and it seems to work. It does require jQuery though for a bit of "magic" at the end.I put this code in a file at the root of my script directory (I named it global.js, but you can use whatever you want. Unless I\'m mistaken this and jQuery should be the only required scripts on a given page. Keep in mind this is largely untested beyond some basic usage, so there may or may not be any issues with the way I\'ve done it; use at your own risk yadda yadda I am not responsible if you screw anything up yadda yadda:Better use the jQuery way. To delay the ready event, first call $.holdReady(true).\nExample (source):This script will add a JavaScript file to the top of any other <script> tag:My usual method is:It works great and uses no page-reloads for me. I\'ve tried the AJAX method (one of the other answers) but it doesn\'t seem to work as nicely for me.Here\'s an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn\'t block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to \'loaded\'.Here is a Grunt plugin allowing you to use @import "path/to/file.js"; syntax in any file including JavaScript files. It can be paired with uglify or watch or any other plugin.It can be installed with npm install: https://npmjs.org/package/grunt-import