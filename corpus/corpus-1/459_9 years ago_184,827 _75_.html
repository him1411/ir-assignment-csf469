I frequently use git stash and git stash pop to save and restore changes in my working tree. Yesterday I had some changes in my working tree that I had stashed and popped, and then I made more changes to my working tree. I\'d like to go back and review yesterday\'s stashed changes, but git stash pop appears to remove all references to the associated commit.I know that if I use git stash then .git/refs/stash contains the reference of the commit used to create the stash. And .git/logs/refs/stash contains the whole stash. But those references are gone after git stash pop. I know that the commit is still in my repository somewhere, but I don\'t know what it was.Is there an easy way to recover yesterday\'s stash commit reference?Note that this isn\'t critical for me today because I have daily backups and can go back to yesterday\'s working tree to get my changes. I\'m asking because there must be an easier way!If you have only just popped it and the terminal is still open, you will still have the hash value printed by git stash pop on screen (thanks, Dolda).Otherwise, you can find it using this for Linux and Unix:and for Windows:This will show you all the commits at the tips of your commit graph which are no longer referenced from any branch or tag \xe2\x80\x93 every lost commit, including every stash commit you\xe2\x80\x99ve ever created, will be somewhere in that graph.The easiest way to find the stash commit you want is probably to pass that list to gitk:This will launch a repository browser showing you every single commit in the repository ever, regardless of whether it is reachable or not.You can replace gitk there with something like git log --graph --oneline --decorate if you prefer a nice graph on the console over a separate GUI app.To spot stash commits, look for commit messages of this form:        WIP on somebranch: commithash Some old commit messageNote: The commit message will only be in this form (starting with "WIP on") if you did not supply a message when you did git stash.Once you know the hash of the commit you want, you can apply it as a stash:Or you can use the context menu in gitk to create branches for any unreachable commits you are interested in. After that, you can do whatever you want with them with all the normal tools. When you\xe2\x80\x99re done, just blow those branches away again.If you didn\'t close the terminal, just look at the output from git stash pop and you\'ll have the object ID of the dropped stash. It normally looks like this:(Note that git stash drop also produces the same line.)To get that stash back, just run git branch tmp 2cae03e, and you\'ll get it as a branch. To convert this to a stash, run:Having it as a branch also allows you to manipulate it freely; for example, to cherry-pick it or merge it.Just wanted to mention this addition to the accepted solution.  It wasn\'t immediately obvious to me the first time I tried this method (maybe it should have been), but to apply the stash from the hash value, just use "git stash apply ":When I was new to git, this wasn\'t clear to me, and I was trying different combinations of "git show", "git apply", "patch", etc.I just constructed a command that helped me find my lost stash commit:This lists all the objects in the .git/objects tree, locates the ones that are of type commit, then shows a summary of each one. From this point it was just a matter of looking through the commits to find an appropriate "WIP on work: 6a9bb2" ("work" is my branch, 619bb2 is a recent commit).I note that if I use "git stash apply" instead of "git stash pop" I wouldn\'t have this problem, and if I use "git stash save message" then the commit might have been easier to find.Update: With Nathan\'s idea, this becomes shorter:To get the list of stashes that are still in your repository, but not reachable any more:If you gave a title to your stash, replace "WIP" in -grep=WIP at the end of the command with a part of your message, e.g. -grep=Tesselation.The command is grepping for "WIP" because the default commit message for a stash is in the form WIP on mybranch: [previous-commit-hash] Message of the previous commit.git fsck --unreachable | grep commit should show the sha1, although the list it returns might be quite large. git show <sha1> will show if it is the commit you want.git cherry-pick -m 1 <sha1> will merge the commit onto the current branch.If you want to restash a lost stash, you need to find the hash of your lost stash first.As Aristotle Pagaltzis suggested a git fsck should help you.Personally I use my log-all alias which show me every commit (recoverable commits) to have a better view of the situation :You can do an even faster search if you\'re looking only for "WIP on" messages.Once you know your sha1, you simply change your stash reflog to add the old stash :You\'ll probably prefer to have an associated message so a -mAnd you\'ll even want to use this as an alias :I liked Aristotle\'s approach, but didn\'t like using GITK... as I\'m used to using GIT from the command line. Instead, I took the dangling commits and output the code to a DIFF file for review in my code editor.Now you can load up the resulting diff/txt file (its in your home folder) into your txt editor and see the actual code and resulting SHA.Then just use In OSX with git v2.6.4, I just run git stash drop accidentally, then I found it by going trough below stepsIf you know name of the stash then use:  $ git fsck --unreachable | grep commit | cut -c 20- | xargs git show | grep -B 6 -A 2 <name of the stash>otherwise you will find ID from the result by manually with:$ git fsck --unreachable | grep commit | cut -c 20- | xargs git showThen when you find the commit-id just hit the git stash apply {commit-id}Hope this helps someone quicklyWindows PowerShell equivalent using gitk:gitk --all $(git fsck --no-reflog | Select-String "(dangling commit )(.*)" | %{ $_.Line.Split(\' \')[2] })There is probably a more efficient way to do this in one pipe, but this does the job.I want to add to the accepted solution another good way to go through all the changes, when you either don\'t have gitk available or no X for output.Then you get all the diffs for those hashes displayed one after another. Press \'q\' to get to the next diff.Why do people ask this question? Because they don\'t yet know about or understand the reflog.Most answers to this question give long commands with options almost nobody will remember. So people come into this question and copy paste whatever they think they need and forget it almost immediately after.I would advise everyone with this question to just check the reflog (git reflog), not much more than that. Once you see that list of all commits there are a hundred ways to find out what commit you\'re looking for and  to cherry-pick it or create a branch from it. In the process you\'ll have learned about the reflog and useful options to various basic git commands.The accepted answer by Aristotle will show all reachable commits, including non-stash-like commits. To filter out the noise:This will only include commits which have exactly 3 parent commits (which a stash will have), and whose message includes "WIP on".Keep in mind, that if you saved your stash with a message (e.g. git stash save "My newly created stash"), this will override the default "WIP on..." message.You can display more information about each commit, e.g. display the commit message, or pass it to git stash show:I couldn\'t get any of the answers to work on Windows in a simple command window (Windows 7 in my case). awk, grep and Select-string weren\'t recognized as commands. So I tried a different approach:will look something like this:start cmd /k git show 8506d235f935b92df65d58e7d75e9441220537a4\nstart cmd /k git show 44078733e1b36962571019126243782421fcd8ae\nstart cmd /k git show ec09069ec893db4ec1901f94eefc8dc606b1dbf1\nstart cmd /k git show d00aab9198e8b81d052d90720165e48b287c302emay not be the best solution, but worked for meWhat I came here looking for is how to actually get the stash back, regardless of what I have checked out. In particular, I had stashed something, then checked out an older version, then poped it, but the stash was a no-op at that earlier time point, so the stash disappeared; I couldn\'t just do git stash to push it back on the stack. This worked for me:In retrospect, I should have been using git stash apply not git stash pop. I was doing a bisect and had a little patch that I wanted to apply at every bisect step. Now I\'m doing this:Recovered it by using following steps:Identify the deleted stash hash code: gitk --all $( git fsck --no-reflog | awk \'/dangling commit/ {print $3}\' )Cherry Pick the Stash:git cherry-pick -m 1 $stash_hash_codeResolve Conflicts if any using: git mergetoolAdditionally you might be having issues with commit message if you are using gerrit. Please Stash your changes before following next alternatives: