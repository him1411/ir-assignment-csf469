I have a JavaScript widget which provides standard extension points. One of them is the beforecreate function. It should return false to prevent an item from being created. I\'ve added an Ajax call into this function using jQuery:But I want to prevent my widget from creating the item, so I should return false in the mother-function, not in the callback. Is there a way to perform a synchronized Ajax request using jQuery or any other API?From the jQuery documentation: you specify the asynchronous option to be false to get a synchronous Ajax request. Then your callback can set some data before your mother function proceeds.Here\'s what your code would look like if changed as suggested:You can put the jQuery\'s Ajax setup in synchronous mode by callingand then perform your Ajax calls using jQuery.get( ... );then just turning it on again once I guess it works out the same thing as suggested by @Adam, but it might be helpful to someone that does want to reconfigure their jQuery.get() or jQuery.post() to the more elaborate jQuery.ajax() syntax.Excellent solution!  I noticed when I tried to implement it that if I returned a value in the success clause, it came back as undefined.  I had to store it in a variable and return that variable.  This is the method I came up with:All of these answers miss the point that doing an Ajax call with async:false will cause the browser to hang until the Ajax request completes. Using a flow control library will solve this problem without hanging up the browser. Here is an example with Frame.js:Keep in mind that if you\'re doing a cross-domain Ajax call (by using JSONP) - you can\'t do it synchronously, the async flag will be ignored by jQuery.For JSONP-calls you could use:Note: You shouldn\'t use async due to this:Starting with Gecko 30.0 (Firefox 30.0 / Thunderbird 30.0 / SeaMonkey 2.27), synchronous requests on the main thread have been deprecated due to the negative effects to the user experience.Chrome even warns about this in the console:Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user\'s experience. For more help, check https://xhr.spec.whatwg.org/.This could break your page if you are doing something like this since it could stop working any day.If you want to do it a way that still feels like if it\'s synchronous but still don\'t block then you should use async/await and probably also some ajax that are based on promises like the new Fetch apiThis is example:I used the answer given by Carcione and modified it to use JSON.I added the dataType of \'json\' and changed the .responseText to responseJSON.I also retrieved the status using the statusText property of the returned object. Note, that this is the status of the Ajax response, not whether the JSON is valid.The backend has to return the response in correct (well-formed) JSON, otherwise the returned object will be undefined.There are two aspects to consider when answering the original question. One is telling Ajax to perform synchronously (by setting async: false) and the other is returning the response via the calling function\'s return statement, rather than into a callback function. I also tried it with POST and it worked. I changed the GET to POST and added data: postdataNote that the above code only works in the case where async is false. If you were to set async:true the returned object jqxhr would not be valid at the time the ajax call returns, only later when the asynchronous call has finished, but that is much too late to set the response variable.With async: false you get yourself a blocked browser.\nFor a non blocking synchronous solution you can use the following:With ES6 you can use a generator & the co library:With ES7 you can just use asyc await: