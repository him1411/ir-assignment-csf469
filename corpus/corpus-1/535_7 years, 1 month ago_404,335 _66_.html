After reading some tutorials I still don\'t get it.Could someone explain how ?: is used and what it\'s good for?Let me try to explain this with an example.Consider the following text:Now, if I apply the regex below over it...... I would get the following result:But I don\'t care about the protocol -- I just want the host and path of the URL. So, I change the regex to include the non-capturing group (?:).Now, my result looks like this:See? The first group has not been captured. The parser uses it to match the text, but ignores it later, in the final result.As requested, let me try to explain groups too.Well, groups serve many purposes. They can help you to extract exact information from a bigger match (which can also be named), they let you rematch a previous matched group, and can be used for substitutions. Let\'s try some examples, shall we?Ok, imagine you have some kind of XML or HTML (be aware that regex may not be the best tool for the job, but it is nice as an example). You want to parse the tags, so you could do something like this (I have added spaces to make it easier to understand):The first regex has a named group (TAG), while the second one uses a common group. Both regexes do the same thing: they use the value from the first group (the name of the tag) to match the closing tag. The difference is that the first one uses the name to match the value, and the second one uses the group index (which starts at 1).Let\'s try some substitutions now. Consider the following text:Now, let\'s use the this dumb regex over it:This regex matches words with at least 3 characters, and uses groups to separate the first three letters. The result is this:So, if we apply the substitution string...... over it, we are trying to use the first group, add an underscore, use the third group, then the second group, add another underscore, and then the fourth group. The resulting string would be like the one below.You can use named groups for substitutions too, using ${name}.To play around with regexes, I recommend http://regex101.com/, which offers a good amount of details on how the regex works; it also offers a few regex engines to choose from.You can use capturing groups to organize and parse an expression.  A non-capturing group has the first benefit, but doesn\'t have the overhead of the second.  You can still say a non-capturing group is optional, for example.Say you want to match numeric text, but some numbers could be written as 1st, 2nd, 3rd, 4th,...  If you want to capture the numeric part, but not the (optional) suffix you can use a non-capturing group.That will match numbers in the form 1, 2, 3... or in the form 1st, 2nd, 3rd,... but it will only capture the numeric part.?: is used when you want to group an expression, but you do not want to save it as a matched/captured portion of the string.An example would be something to match an IP address:Note that I don\'t care about saving the first 3 octets, but the (?:...) grouping allows me to shorten the regex without incurring the overhead of capturing and storing a match. It makes the group non-capturing, which means that the substring matched by that group will not be included in the list of captures. An example in ruby to illustrate the difference:Groups that capture you can use later on in the regex to match OR you can use them in the replacement part of the regex.  Making a non-capturing group simply exempts that group from being used for either of these reasons.  Non-capturing groups are great if you are trying to capture many different things and there are some groups you don\'t want to capture. Thats pretty much the reason they exist.  While you are learning about groups, learn about Atomic Groups, they do a lot!  There is also lookaround groups but they are a little more complex and not used so much.Example of using later on in the regex (backreference):<([A-Z][A-Z0-9]*)\\b[^>]*>.*?</\\1>  [ Finds an xml tag (without ns support) ]([A-Z][A-Z0-9]*) is a capturing group (in this case it is the tagname)Later on in the regex is \\1 which means it will only match the same text that was in the first group (the ([A-Z][A-Z0-9]*) group) (in this case it is matching the end tag).HISTORICAL MOTIVATION: The existence of non-capturing groups can be explained with the use of parenthesis. Consider the expressions (a|b)c and a|bc, due to priority of concatenation over |, these expressions represent two different languages ({ac, bc} and {a, bc} respectively). However, the parenthesis are also used as a matching group (as explained by the other answers...).When you want to have parenthesis but not capture the subexpression you use NON-CAPTURING GROUPS. In the example, (?:a|b)cLet me try this with an example :-Regex Code :- (?:animal)(?:=)(\\w+)(,)\\1\\2Search String :-Line 1 - animal=cat,dog,cat,tiger,dogLine 2 - animal=cat,cat,dog,dog,tigerLine 3 - animal=dog,dog,cat,cat,tiger(?:animal) --> Non-Captured Group 1(?:=)--> Non-Captured Group 2(\\w+)--> Captured Group 1(,)--> Captured Group 2\\1 --> result of captured group 1 i.e In Line 1 is cat,In Line 2 is cat,In Line 3 is dog.\\2 -->result of captured group 2 i.e comma(,)So in this code by giving \\1 and \\2 we recall or repeat the result of captured group 1 and 2 respectively later in the code.As per the order of code (?:animal) should be group 1 and (?:=) should be group 2 and continues..but by giving the ?: we make the match-group non captured(which do not count off in matched group, so the grouping number starts from the first captured group and not the non captured), so that the repetition of the result of match-group (?:animal) can\'t be called later in code.Hope this explains the use of non capturing group.enter image description hereIn complex regular expressions you may have the situation arise where you wish to use a large number of groups some of which are there for repetition matching and some of which are there to provide back references. By default the text matching each group is loaded into the backreference array. Where we have lots of groups and only need to be able to reference some of them from the backreference array we can override this default behaviour to tell the regular expression that certain groups are there only for repetition handling and do not need to be captured and stored in the backreference array.Well I am a JavaScript developer and will try to explain its significance pertaining to JavaScript.Consider a scenario where you want to match cat is animal\nwhen you would like match cat and animal and both should have a is in between them.I think I would give you the answer,\nDon\'t use capture variables without checking that the match succeeded.The capture variables, $1, etc, are not valid unless the match succeeded, and they\'re not cleared, either.In the above example, To avoid capturing bronto in $1, (?:) is used.\nIf the pattern is matched , then $1 is captured as next grouped pattern.\nSo, the output will be as below:It is Useful if you don\'t want the matches to be saved .One interesting thing that I came across is the fact that you can have a capturing group inside a non-capturing group. Have a look at below regex for matching web urls:Input url string:The first group in my regex (?:([A-Za-z]+):) is a non-capturing group which matches the protocol scheme and colon : character i.e. http: but when I was running below code, I was seeing the 1st index of the returned array was containing the string http when I was thinking that http and colon : both will not get reported as they are inside a non-capturing group.I thought if the first group (?:([A-Za-z]+):) is a non-capturing group then why it is returning http string in the output array.So if you notice that there is a nested group ([A-Za-z]+) inside the non-capturing group. That nested group ([A-Za-z]+) is a capturing group (not having ?: at the beginning) in itself inside a non-capturing group (?:([A-Za-z]+):). That\'s why the text http still gets captured but the colon : character which is inside the non-capturing group but outside the capturing group doesn\'t get reported in the output array.