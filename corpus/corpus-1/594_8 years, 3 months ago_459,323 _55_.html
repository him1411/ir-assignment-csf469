What exactly does putting extern "C" into C++ code do?For example:extern "C" makes a function-name in C++ have \'C\' linkage (compiler does not mangle the name) so that client C code can link to (i.e use) your function using a \'C\' compatible header file that contains just the declaration of your function. Your function definition is contained in a binary format (that was compiled by your C++ compiler) that the client \'C\' linker will then link to using the \'C\' name.Since C++ has overloading of function names and C does not, the C++ compiler cannot just use the function name as a unique id to link to, so it mangles the name by adding information about the arguments.  A C compiler does not need to mangle the name since you can not overload function names in C.  When you state that a function has extern "C" linkage in C++, the C++ compiler does not add argument/parameter type information to the name used for linkage.Just so you know, you can specify "C" linkage to each individual declaration/definition explicitly or use a block to group a sequence of declarations/definitions to have a certain linkage:If you care about the technicalities, they are listed in section 7.5 of the C++03 standard, here is a brief summary (with emphasis on extern "C"):Just wanted to add a bit of info, since I haven\'t seen it posted yet.You\'ll very often see code in C headers like so:What this accomplishes is that it allows you to use that C header file with your C++ code, because the macro "__cplusplus" will be defined. But you can also still use it with your legacy C code, where the macro is NOT defined, so it won\'t see the uniquely C++ construct.Although, I have also seen C++ code such as:which I imagine accomplishes much the same thing.Not sure which way is better, but I have seen both.In every C++ program, all non-static functions are represented in the binary file as symbols. These symbols are special text strings that uniquely identify a function in the program.In C, the symbol name is the same as the function name. This is possible because in C no two non-static functions can have the same name.Because C++ allows overloading and has many features that C does not \xe2\x80\x94 like classes, member functions, exception specifications - it is not possible to simply use the function name as the symbol name. To solve that, C++ uses so-called name mangling, which transforms the function name and all the necessary information (like the number and size of the arguments) into some weird-looking string which only the compiler knows about.So if you specify a function to be extern C, the compiler doesn\'t performs name mangling with it and it can be directly \naccessed using its symbol name.This comes handy while using dlsym() and dlopen() for calling such functions.Let\'s decompile the object file g++ generated to see what goes on inside this implementation.Generate exampleInput:Compile with GCC 4.8 Linux ELF output:Decompile the symbol table:The output contains:InterpretationWe see that:ef and eg were stored in symbols with the same name as in the codethe other symbols were mangled. Let\'s unmangle them:Conclusion: both of the following symbol types were not mangled:So you will need extern "C" both when calling:Things that do not work in extern CIt becomes obvious that any C++ feature that requires name mangling will not wok inside extern C:Not any C-header will compile with extern "C". When identifiers in a C-header conflict with C++ keywords the C++ compiler will complain about this.For example, I have seen the following code fail in a g++ :Kinda makes sense, but is something to keep in mind when porting C-code to C++. It changes the linkage of a function in such a way that the function is callable from C. In practice that means that the function name is not mangled.It informs the C++ compiler to look up the names of those functions in a C-style when linking, because the names of functions compiled in C and C++ are different during the linking stage.extern "C" is meant to be recognized by a C++ compiler and to notify the compiler that the noted function is (or to be) compiled in C style. So that while linking, it link to the correct version of function from C.Most programming languages aren\'t built on-top of existing programming languages. C++ is built on-top of C, and for that reason there are C++ keywords like extern which provide backwards compatibility with C.Let\'s look at the following example:A C compiler will throw an error when running this example, because the same function printMe is defined twice (even though they have different parameters int a vs char a).gcc -o printMe printMe.c && ./printMe;\n  1 error. PrintMe is defined more than once.However, a C++ compiler won\'t throw an error if the function name printMe is defined twice (as long as the parameters are different).g++ -o printMe printMe.c && ./printMe;This is because a C++ compiler implicitly renames (mangles) functions based on their parameters. In C, this feature was not supported. However, when C++ was built over C, the language was designed to be object-oriented, and needed to support the ability to create different classes with methods (functions) of the same name, and to override methods (method overriding) based on different parameters.However, mangling C function names with a C++ compiler can cause errors in the linking phase that follows compilation. The linker is supposed to match function references/calls to function names. But, if the C function references/calls in external files are not mangled as well, then they can\'t be linked to a mangled function name.And therefore, the extern keyword tells the C++ compiler -\n"Let\'s avoid this whole linker mess, C is not C++, so don\'t rename C function names".I used \'extern "C"\' before for dll(dynamic link library) files to make etc. main() function "exportable" so it can be used later in another executable from dll.\nMaybe an example of where I used to use it can be useful.DLLEXEextern "C" is a linkage specification which is used to call C functions in the Cpp source files. We can call C functions, write Variables, & include headers. Function is declared in extern entity & it is defined outside. Syntax isType 1:Type 2:eg:When mixing C and C++ (i.e., a. calling C function from C++; and b. calling C++ function from C), the C++ name mangling causes linking problems. Technically speaking, this issue happens only when the callee functions have been already compiled into binary (most likely, a *.a library file) using the corresponding compiler.So we need to use extern "C" to disable the name mangling in C++.