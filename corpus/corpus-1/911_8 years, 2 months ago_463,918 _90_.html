EntityManager.merge() can insert new objects and update existing ones.Why would one want to use persist() (which can only create new objects)?Either way will add an entity to a PersistenceContext, the difference is in what you do with the entity afterwards. Persist takes an entity instance, adds it to the context and makes that instance managed (ie future updates to the entity will be tracked).Merge creates a new instance of your entity, copies the state from the supplied entity, and makes the new copy managed. The instance you pass in will not be managed (any changes you make will not be part of the transaction - unless you call merge again). Maybe a code example will help. Scenario 1 and 3 are roughly equivalent, but there are some situations where you\'d want to use Scenario 2. Persist and merge are for two different purposes (they aren\'t alternatives at all).(edited to expand differences information)persist: merge: persist() efficiency:persist() semantics:Example:This way only exists 1 attached object for any register in the entity manager.merge() for an entity with an id is something like:Although if connected to MySQL merge() could be as efficient as persist() using a call to INSERT with ON DUPLICATE KEY UPDATE option, JPA is a very high level programming and you can\'t assume this is going to be the case everywhere.If you\'re using the assigned generator, using merge instead of persist can cause a redundant SQL statement, therefore affecting performance.Also, calling merge for managed entities is also a mistake since managed entities are automatically managed by Hibernate and their state is synchronized with the database record by the dirty checking mechanism upon flushing the Persistence Context. To understand how all this works, you should first know that Hibernate shifts the developer mindset from SQL statements to entity state transitions. Once an entity is actively managed by Hibernate, all changes are going to be automatically propagated to the database. Hibernate monitors currently attached entities. But for an entity to become managed, it must be in the right entity state.First, we must define all entity states:New (Transient)A newly created object that hasn\xe2\x80\x99t ever been associated with a Hibernate Session (a.k.a Persistence Context) and is not mapped to any database table row is considered to be in the New (Transient) state. To become persisted we need to either explicitly call the EntityManager#persist method or make use of the transitive persistence mechanism.Persistent (Managed)A persistent entity has been associated with a database table row and it\xe2\x80\x99s being managed by the current running Persistence Context. Any change made to such entity is going to be detected and propagated to the database (during the Session flush-time). \nWith Hibernate, we no longer have to execute INSERT/UPDATE/DELETE statements. Hibernate employs a transactional write-behind working style and changes are synchronized at the very last responsible moment, during the current Session flush-time.DetachedOnce the current running Persistence Context is closed all the previously managed entities become detached. Successive changes will no longer be tracked and no automatic database synchronization is going to happen.To associate a detached entity to an active Hibernate Session, you can choose one of the following options:ReattachingHibernate (but not JPA 2.1) supports reattaching through the Session#update method.\nA Hibernate Session can only associate one Entity object for a given database row. This is because the Persistence Context acts as an in-memory cache (first level cache) and only one value (entity) is associated to a given key (entity type and database identifier).\nAn entity can be reattached only if there is no other JVM object (matching the same database row) already associated to the current Hibernate Session.MergingThe merge is going to copy the detached entity state (source) to a managed entity instance (destination). If the merging entity has no equivalent in the current Session, one will be fetched from the database.\nThe detached object instance will continue to remain detached even after the merge operation.RemovedAlthough JPA demands that managed entities only are allowed to be removed, Hibernate can also delete detached entities (but only through a Session#delete method call).\nA removed entity is only scheduled for deletion and the actual database DELETE statement will be executed during Session flush-time.To understand the JPA state transitions better, you can visualize the following diagram:Or if you use the Hibernate specific API:I noticed that when I used em.merge, I got a SELECT statement for every INSERT, even when there was no field that JPA was generating for me--the primary key field was a UUID that I set myself.  I switched to em.persist(myEntityObject) and got just INSERT statements then.The JPA specification says the following about persist().If X is a detached object, the EntityExistsException may be thrown when the persist\n  operation is invoked, or the EntityExistsException or another PersistenceException may be thrown at flush or commit time.So using persist() would be suitable when the object ought not to be a detached object. You might prefer to have the code throw the PersistenceException so it fails fast.Although the specification is unclear, persist() might set the @GeneratedValue @Id for an object. merge() however must have an object with the @Id already generated.Some more details about merge which will help you to use merge over persist:Returning a managed instance other than the original entity is a critical part of the merge\n  process. If an entity instance with the same identifier already exists in the persistence context, the\n  provider will overwrite its state with the state of the entity that is being merged, but the managed\n  version that existed already must be returned to the client so that it can be used. If the provider did not\n  update the Employee instance in the persistence context, any references to that instance will become\n  inconsistent with the new state being merged in.When merge() is invoked on a new entity, it behaves similarly to the persist() operation. It adds\n  the entity to the persistence context, but instead of adding the original entity instance, it creates a new\n  copy and manages that instance instead. The copy that is created by the merge() operation is persisted\n  as if the persist() method were invoked on it.In the presence of relationships, the merge() operation will attempt to update the managed entity\n  to point to managed versions of the entities referenced by the detached entity. If the entity has a\n  relationship to an object that has no persistent identity, the outcome of the merge operation is\n  undefined. Some providers might allow the managed copy to point to the non-persistent object,\n  whereas others might throw an exception immediately. The merge() operation can be optionally\n  cascaded in these cases to prevent an exception from occurring. We will cover cascading of the merge()\n  operation later in this section. If an entity being merged points to a removed entity, an\n  IllegalArgumentException exception will be thrown.Lazy-loading relationships are a special case in the merge operation. If a lazy-loading\n  relationship was not triggered on an entity before it became detached, that relationship will be\n  ignored when the entity is merged. If the relationship was triggered while managed and then set to null while the entity was detached, the managed version of the entity will likewise have the relationship cleared during the merge."All of the above information was taken from "Pro JPA 2 Mastering the Java\xe2\x84\xa2 Persistence API" by Mike Keith and Merrick Schnicariol. Chapter 6. Section detachment and merging. This book is actually a second book devoted to JPA by authors. This new book has many new information then former one. I really recommed to read this book for ones who will be seriously involved with JPA. I am sorry for anonimously posting my first answer.There are some more differences between merge and persist (I will enumerate again those already posted here):D1. merge does not make the passed entity managed, but rather returns another instance that is managed. persist on the other side will make the passed entity managed:D2. If you remove an entity and then decide to persist the entity back, you may do that only with persist(), because merge will throw an IllegalArgumentException.D3. If you decided to take care manually of your IDs (e.g by using UUIDs), then a merge \noperation will trigger subsequent SELECT queries in order to look for existent entities with that ID, while persist may not need those queries.D4. There are cases when you simply do not trust the code that calls your code, and in order to make sure that no data is updated, but rather is inserted, you must use persist.I was getting lazyLoading exceptions on my entity because I was trying to access a lazy loaded collection that was in session.What I would do was in a separate request, retrieve the entity from session and then try to access a collection in my jsp page which was problematic.To alleviate this, I updated the same entity in my controller and passed it to my jsp, although I imagine when I re-saved in session that it will also be accessible though SessionScope and not throw a LazyLoadingException, a modification of example 2:The following has worked for me:Going through the answers there are some details missing regarding `Cascade\' and id generation. See questionAlso, it is worth mentioning that you can have separate Cascade annotations for merging and persisting: Cascade.MERGE and Cascade.PERSIST which will be treated according to the used method.The spec is your friend ;)I found this explanation from the Hibernate docs enlightening, because they contain a use case:The usage and semantics of merge() seems to be confusing for new users. Firstly, as long as you are not trying to use object state loaded in one entity manager in another new entity manager, you should not need to use merge() at all. Some whole applications will never use this method.Usually merge() is used in the following scenario:Here is the exact semantic of merge():From: http://docs.jboss.org/hibernate/entitymanager/3.6/reference/en/html/objectstate.htmlScenario X:Table:Spitter (One) ,Table: Spittles (Many) (Spittles is Owner of the relationship with a FK:spitter_id)This scenario results in saving : The Spitter and both Spittles  as if owned by Same Spitter.Scenario Y:This will save the Spitter, will save the 2 Spittles But they will not reference the same Spitter!JPA is indisputably a great simplification in the domain of enterprise\n  applications built on the Java platform. As a developer who had to\n  cope up with the intricacies of the old entity beans in J2EE I see the\n  inclusion of JPA among the Java EE specifications as a big leap\n  forward. However, while delving deeper into the JPA details I find\n  things that are not so easy. In this article I deal with comparison of\n  the EntityManager\xe2\x80\x99s merge and persist methods whose overlapping\n  behavior may cause confusion not only to a newbie. Furthermore I\n  propose a generalization that sees both methods as special cases of a\n  more general method combine.Persisting entitiesIn contrast to the merge method the persist method is pretty straightforward and intuitive. The most common scenario of the persist method\'s usage can be summed up as follows:"A newly created instance of the entity class is passed to the persist method. After this method returns, the entity is managed and planned for insertion into the database. It may happen at or before the transaction commits or when the flush method is called. If the entity references another entity through a relationship marked with the PERSIST cascade strategy this procedure is applied to it also."The specification goes more into details, however, remembering them is not crucial as these details cover more or less exotic situations only.Merging entitiesIn comparison to persist, the description of the merge\'s behavior is not so simple. There is no main scenario, as it is in the case of persist, and a programmer must remember all scenarios in order to write a correct code. It seems to me that the JPA designers wanted to have some method whose primary concern would be handling detached entities (as the opposite to the persist method that deals with newly created entities primarily.) The merge method\'s major task is to transfer the state from an unmanaged entity (passed as the argument) to its managed counterpart within the persistence context. This task, however, divides further into several scenarios which worsen the intelligibility of the overall method\'s behavior.Instead of repeating paragraphs from the JPA specification I have prepared a flow diagram that schematically depicts the behaviour of the merge method:So, when should I use persist and when merge?persistmergepersist(entity) should be used with totally new entities, to add them to DB (if entity already exists in DB there will be EntityExistsException throw). merge(entity) should be used, to put entity back to persistence context if the entity was detached and was changed.Probably persist is generating INSERT sql statement and merge UPDATE sql statement (but i\'m not sure).