Is there a catchall function somewhere that works well for sanitizing user input for SQL injection and XSS attacks, while still allowing certain types of html tags?It\'s a common misconception that user input can be filtered. PHP even has a (now deprecated) "feature", called magic-quotes, that builds on this idea. It\'s nonsense. Forget about filtering (Or cleaning, or whatever people call it).What you should do, to avoid problems is quite simple: Whenever you embed a string within foreign code, you must escape it, according to the rules of that language. For example, if you embed a string in some SQL targeting MySql, you must escape the string with MySql\'s function for this purpose (mysqli_real_escape_string).Another example is HTML: If you embed strings within HTML markup, you must escape it with htmlspecialchars. This means that every single echo or print statement should use htmlspecialchars.A third example could be shell commands: If you are going to embed strings (Such as arguments) to external commands, and call them with exec, then you must use escapeshellcmd and escapeshellarg.And so on and so forth ...The only case where you need to actively filter data, is if you\'re accepting preformatted input. Eg. if you let your users post HTML markup, that you plan to display on the site. However, you should be wise to avoid this at all cost, since no matter how well you filter it, it will always be a potential security hole.Do not try to prevent SQL injection by sanitizing input data.Instead, do not allow data to be used in creating your SQL code.  Use Prepared Statements (i.e. using parameters in a template query) that uses bound variables.  It is the only way to be guaranteed against SQL injection.Please see my website http://bobby-tables.com/ for more about preventing SQL injection.No.  You can\'t generically filter data without any context of what it\'s for.  Sometimes you\'d want to take a SQL query as input and sometimes you\'d want to take HTML as input.You need to filter input on a whitelist -- ensure that the data matches some specification of what you expect.  Then you need to escape it before you use it, depending on the context in which you are using it.The process of escaping data for SQL - to prevent SQL injection - is very different from the process of escaping data for (X)HTML, to prevent XSS.PHP has the new nice filter_input functions now, that for instance liberate you from finding \'the ultimate e-mail regex\' now that there is a built-in FILTER_VALIDATE_EMAIL typeMy own filter class (uses javascript to highlight faulty fields) can be initiated by either an ajax request or normal form post. (see the example below)\n    \n\nOf course, keep in mind that you need to do your sql query escaping too depending on what type of db your are using (mysql_real_escape_string() is useless for an sql server for instance). You probably want to handle this automatically at your appropriate application layer like an ORM. Also, as mentioned above: for outputting to html use the other php dedicated functions like htmlspecialchars ;)For really allowing HTML input with like stripped classes and/or tags depend on one of the dedicated xss validation packages. DO NOT WRITE YOUR OWN REGEXES TO PARSE HTML!No, there is not.First of all, SQL injection is an input filtering problem, and XSS is an output escaping one - so you wouldn\'t even execute these two operations at the same time in the code lifecycle.Basic rules of thumbTo address the XSS issue, take a look at HTML Purifier. It is fairly configurable and has a decent track record.As for the SQL injection attacks, make sure you check the user input, and then run it though mysql_real_escape_string(). The function won\'t defeat all injection attacks, though, so it is important that you check the data before dumping it into your query string.A better solution is to use prepared statements. The PDO library and mysqli extension support these.PHP 5.2 introduced the filter_var function.It supports a great deal of SANITIZE, VALIDATE filters.http://php.net/manual/en/function.filter-var.phpOne trick that can help in the specific circumstance where you have a page like /mypage?id=53 and you use the id in a WHERE clause is to ensure that id definitely is an integer, like so:But of course that only cuts out one specific attack, so read all the other answers. (And yes I know that the code above isn\'t great, but it shows the specific defence.)What you are describing here is two separate issues: 1) User input should always be assumed to be bad.Using prepared statements, or/and filtering with mysql_real_escape_string is definitely a must.\nPHP also has filter_input built in which is a good place to start.2) This is a large topic, and it depends on the context of the data being output. For HTML there are solutions such as htmlpurifier out there.\nas a rule of thumb, always escape anything you output.Both issues are far too big to go into in a single post, but there are lots of posts which go into more detail:Methods PHP outputSafer PHP outputIf you\'re using PostgreSQL, the input from PHP can be escaped with pg_escape_string()$username = pg_escape_string($_POST[\'username\']);From the documentation (http://php.net/manual/es/function.pg-escape-string.php):pg_escape_string() escapes a string for querying the database. It returns an escaped string in the PostgreSQL format without quotes.Just wanted to add that on the subject of output escaping, if you use php DOMDocument to make your html output it will automatically escape in the right context. An attribute (value="") and the inner text of a <span> are not equal.\nTo be safe against XSS read this:\nOWASP XSS Prevention Cheat SheetEasiest way to avoid mistakes in sanitizing input and escaping data is using PHP framework like Symphony, Nette etc. or part of that framework (templating engine, database layer, ORM).Templating engine like Twig or Latte has output escaping on by default - you don\'t have to solve manually if you have properly escaped your output depending on context (HTML or Javascript part of web page).Framework is automatically sanitizing input and you should\'t use $_POST, $_GET or $_SESSION variables directly, but through mechanism like routing, session handling etc.And for database (model) layer there are ORM frameworks like Doctrine or wrappers around PDO like Nette Database.You can read more about it here - What is a software framework?There is the filter extension (howto-link, manual), which works pretty well with all GPC variables. It\'s not a magic-do-it-all thing though, you will still have to use it.The best BASIC method for sanitizing user input with PHP: