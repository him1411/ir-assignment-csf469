What is a smart pointer and when should I use one?A smart pointer is a class that wraps a \'raw\' (or \'bare\') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you really do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by boost::scoped_ptr or std::unique_ptr. Note that scoped_ptr instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.Scoped pointers are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last "reference" to the object is destroyed, the object is deleted. This policy is implemented by boost::shared_ptr and std::shared_ptr.Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.There is one drawback to reference counted pointers \xe2\x80\x94 the possibility of creating a dangling reference:Another possibility is creating circular references:To work around this problem, both Boost and C++11 have defined a weak_ptr to define a weak (uncounted) reference to a shared_ptr.This answer is rather old, and so describes what was \'good\' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of std::unique_ptr, std::shared_ptr and std::weak_ptr. There is also std::auto_ptr. It is very much like a scoped pointer, except that it also has the "special" dangerous ability to be copied \xe2\x80\x94 which also unexpectedly transfers ownership! It is deprecated in the newest standards, so you shouldn\'t use it. Use the std::unique_ptr instead.Here\'s a simple answer for these days of modern C++:Smart pointer is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.Small intro is available on page Smart Pointers - What, Why, Which?.One of the simple smart-pointer type is std::auto_ptr (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.Another convenient type is boost::shared_ptr which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement RAII.Subject is covered in depth in book "C++ Templates: The Complete Guide" by David Vandevoorde, Nicolai M. Josuttis, chapter Chapter 20. Smart Pointers.\nSome topics covered:Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:\nA smart pointer is simply a class that overloads the ->  and * operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.\nshared_ptr and auto_ptr are sufficient in most cases, but come along with their own set of small idiosyncrasies.A smart pointer is like a regular (typed) pointer, like "char*", except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using "->", but not if you need an actual pointer to the data. For that, you can use "&*ptr".It is useful for:Objects that must be allocated with new, but that you\'d like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).You may not want to use a smart pointer when:See also:Most kinds of smart pointers handle disposing of the pointer-to object for you. It\'s very handy because you don\'t have to think about disposing of objects manually anymore.The most commonly-used smart pointers are std::tr1::shared_ptr (or boost::shared_ptr), and, less commonly, std::auto_ptr. I recommend regular use of shared_ptr.shared_ptr is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be "passed across DLL boundaries" (the common nightmare case if different libcs are used between your code and the DLLs).A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.One can implement one\'s own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.For example, Boost provides the following smart pointer implementations:These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.Additionally, the C++ standard library provides three smart pointers; std::unique_ptr for unique ownership, std::shared_ptr for shared ownership and std::weak_ptr. std::auto_ptr existed in C++03 but is now deprecated.Here is the Link for similar answers : http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.htmlA smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don\'t respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.Example: This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:Like other overloaded operators, p will behave like a regular pointer,http://en.wikipedia.org/wiki/Smart_pointerIn computer science, a smart pointer\n  is an abstract data type that\n  simulates a pointer while providing\n  additional features, such as automatic\n  garbage collection or bounds checking.\n  These additional features are intended\n  to reduce bugs caused by the misuse of\n  pointers while retaining efficiency.\n  Smart pointers typically keep track of\n  the objects that point to them for the\n  purpose of memory management. The\n  misuse of pointers is a major source\n  of bugs: the constant allocation,\n  deallocation and referencing that must\n  be performed by a program written\n  using pointers makes it very likely\n  that some memory leaks will occur.\n  Smart pointers try to prevent memory\n  leaks by making the resource\n  deallocation automatic: when the\n  pointer to an object (or the last in a\n  series of pointers) is destroyed, for\n  example because it goes out of scope,\n  the pointed object is destroyed too.Let T be a class in this tutorial \nPointers in C++ can be divided into 3 types :1) Raw pointers :They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track. Pointers with const data or address { Read backwards } Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie *ptr1 = 19 ; will not work. But you can move the pointer. ie ptr1++ , ptr1-- ;  etc will work.\nRead backwards : pointer to type T which is const A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie *ptr2 = 19 will work but ptr2++ ; ptr2-- etc will not work. Read backwards : const pointer to a type T A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . ptr3-- ; ptr3++ ; *ptr3 = 19; will not work 3) Smart Pointers : { #include <memory> } Shared Pointer: Implemented using reference counting to keep track of how many " things " point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. \nThis gets rid of the headache of having to delete objects which you have allocated using new. Weak Pointer : \n    Helps deal with cyclic reference which arises when using Shared Pointer\n    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr. See : When is std::weak_ptr useful?Unique Pointer : \n    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.To change the object pointed to by the unique ptr , use move semanticsReferences : \n    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.See : What are the differences between a pointer variable and a reference variable in C++? Reference : \nhttps://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ \nThanks to Andre for pointing out this question.Smart Pointers are those where you don\'t have to worry about Memory De-Allocation, Resource Sharing and Transfer. You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart point\xe2\x80\x99s life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).