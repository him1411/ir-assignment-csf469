I want to create a list of options for testing purposes. At first, I did this:Then I refactored the code as follows:Is there a better way to do this?Actually, probably the "best" way to initialize the ArrayList is the method you wrote, as it does not need to create a new List in any way:The catch is that there is quite a bit of typing required to refer to that list instance.There are alternatives, such as making an anonymous inner class with an instance initializer (also known as an "double brace initialization"):However, I\'m not too fond of that method because what you end up with is a subclass of ArrayList which has an instance initializer, and that class is created just to create one object -- that just seems like a little bit overkill to me.What would have been nice was if the Collection Literals proposal for Project Coin was accepted (it was slated to be introduced in Java 7, but it\'s not likely to be part of Java 8 either.):Unfortunately it won\'t help you here, as it will initialize an immutable List rather than an ArrayList, and furthermore, it\'s not available yet, if it ever will be.It would be simpler if you were to just declare it as a List - does it have to be an ArrayList?Or if you have only one element:This would mean that places is immutable (trying to change it will cause an UnsupportedOperationException exception to be thrown).To make a mutable list that is a concrete ArrayList you can create an ArrayList from the immutable list:In most cases just useThis will give you a List backed by the array, so it cannot change length, which is fine in most cases.You can make it even shorter with a static import:This also requires the static import:Which any modern IDE will suggest and automatically do for you.\nFor example in IntelliJ IDEA you press Alt+Enter and select Static import method....In Java 9 the recommended syntax will beTo quote JEP 269 (emphasis mine):There is a small set of use cases for initializing a mutable collection instance with a predefined set of values. It\'s usually preferable to have those predefined values be in an immutable collection, and then to initialize the mutable collection via a copy constructor.If you must for some reason have an ArrayList, e.g. if you need a List that can change length, useor in Java 9:You said you\'ve declared the list as an ArrayList in your code, but you should not do that unless you\'re using some member of ArrayList that\'s not in List, for example ArrayList.ensureCapacity(). Which is pretty much never.Usually you should just declare variables by the most general interface that you are going to use (e.g. Iterable, Collection, or List), and initialize them with the specific implementation (e.g. ArrayList, LinkedList or Arrays.asList()).Otherwise you\'re limiting your code to that specific type, and it\'ll be harder to change when you want to.For example:Another example would be always declaring variable an InputStream even though it is usually a FileInputStream or a BufferedInputStream, because one day soon you or somebody else will want to use some other kind of InputStream.If you need a simple list of size 1:If you need a list of several objects:With Guava you can write:In Guava there are also other useful static constructors. You can read about them here.Collection literals didn\'t make it into Java 8, but it is possible to use the Stream API to initialize a list in one rather long line:If you need to ensure that your List is an ArrayList:You could create a factory method:But it\'s not much better than your first refactoring.UPDATE: for greater flexibility, it can be generic:With Java 9, as suggested in JDK Enhancement Proposal - 269, this could be achieved using collection literals now as - Also a similar approach would apply to Map as well - which is similar to Collection Literals proposal as stated by @coobird as well. Further clarified in the JEP doc as well - AlternativesLanguage changes have been considered several times, and rejected:Project Coin Proposal, 29 March 2009 Project Coin Proposal, 30 March 2009 JEP 186 discussion on lambda-dev, January-March 2014The language\n  proposals were set aside in preference to a library-based proposal as\n  summarized in this message.Edit - For the reason of What is the point of overloaded Convenience Factory Methods for the same purpose, do take a look at my answer hereAbout the most compact way to do this is:With Eclipse Collections (formerly GS Collections), you can write the following:You can also be more specific about the types and whether they are Mutable or Immutable.You can also do the same with Sets and Bags:Note: I am a committer for Eclipse Collections.You can use the below statements:Simply use as follows.(Should be a comment, but too long, so new reply).  As others have mentioned, the Arrays.asList method is fixed size, but that\'s not the only issue with it.  It also doesn\'t handle inheritance very well.  For instance, suppose you have the following:The above results in a compiler error, because List<B>(which is what is returned by Arrays.asList) is not a subclass of List<A>, even though you can add Objects of type B to a List<A> object.  To get around this, you need to do something like:This is probably the best way to go about doing this, esp. if you need an unbounded list or need to use inheritance.Like Tom said:But since you complained of wanting an ArrayList, you should firstly know that ArrayList is a subclass of List and you could simply add this line:Although, that might make you complain of \'performance\'.In that case it doesn\'t make sense to me, why, since your list is predefined it wasn\'t defined as an array (since the size is known at time of initialisation). And if that\'s an option for you:In case you don\'t care of the minor performance differences then you can also copy an array to an ArrayList very simply:Okay, but in future you need a bit more than just the place name, you need a country code too. Assuming this is still a predefined list which will never change during run-time, then it\'s fitting to use an enum set, which would require re-compilation if the list needed to be changed in the future.would become:Enum\'s have a static values method that returns an array containing all of the values of the enum in the order they are declared, e.g.:In that case I guess you wouldn\'t need your ArrayList.P.S. Randyaa demonstrated another nice way using the static utility method Collections.addAll.Here is another way:Try with this code line:Java 9 has the following method to create an immutable list:which is easily adapted to create a mutable list, if required:Similar methods are available for Set and Map.In Java, you can\'t doAs was pointed out, you\'d need to do a double brace initialization:But this may force you into adding an annotation @SuppressWarnings("serial") or generate a serial UUID which is annoying. Also most code formatters will unwrap that into multiple statements/lines.Alternatively you can dobut then you may want to do a @SuppressWarnings("unchecked").Also according to javadoc you should be able to do this:But I\'m not able to get it to compile with JDK 1.6.Yes with the help of Arrays you can initialize array list in one line,Here is code by AbacusUtilDeclaration\xef\xbc\x9a I\'m the developer of AbacusUtil.You can use StickyList from Cactoos:If you\'d need to have a list of one item!Collections is from java.util package.The best way to do it:Just create a function that can have as many elements as you want and call it to add them in one line.For me Arrays.asList() is the best and convenient one. I always like to initialize that way.\nIf you are a beginner into Java Collections then I would like you to refer ArrayList initializationSometimes I just feel that people should simply use Groovy and let Java rest in peace. The good thing is that it runs on the JVM, so you can copy paste pure Java code anywhere in a Groovy file, and it will just work.About declaring list in one line, this is how it looks in Groovy:That\'s it, maan!!!Here is more on Groovy lists.ExtrasDeclaring a map in Groovy in one line:Here is more on Groovy maps.Reading a JSON file,in one line as follows:orBoth sets value to value1.Imagine doing the same with Jackson API. You have to write corresponding POJOs for map1 and map2. Then compile. Also every time the JSON changes, you have to reflect those changes in POJOs. This fully defeats goal of making functionality JSON configurable. It\'s the deadly configure-code-recompile chain. Not just configure and go.I cry when I was asked to use Java. Why world why???? (or please enlighten me if am wrong...will reduce a lot of my pain in Java World)Actually, it\'s possible to do it in one line:This is the implementation of Arrays.asList, so you could go withIn Apple WebObjects Foundation framework you can do this.The WebObjects Foundation framework was ported from Objective-C to Java more than a decade ago and was updated after Java 5 added support for generics... I wonder why something similar was not implemented in Java Collections classes.