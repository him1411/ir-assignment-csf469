How do I get the path of the directory in which a Bash script is located, inside that script?For instance, let\'s say I want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so: is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:This last one will work with any combination of aliases, source, bash -c, symlinks, etc.Beware: if you cd to a different directory before running this snippet, the result may be incorrect! Also, watch out for $CDPATH gotchas.To understand how it works, try running this more verbose form:And it will print something like:Use dirname:using pwd alone will not work if you are not running the script from the directory it is contained in.The dirname command is the most basic, simply parsing the path up to the filename off of the $0 (script name) variable:But, as matt b pointed out, the path returned is different depending on how the script is called. pwd doesn\'t do the job because that only tells you what the current directory is, not what directory the script resides in. Additionally, if a symbolic link to a script is executed, you\'re going to get a (probably relative) path to where the link resides, not the actual script. Some others have mentioned the readlink command, but at its simplest, you can use:readlink will resolve the script path to an absolute path from the root of the filesystem. So, any paths containing single or double dots, tildes and/or symbolic links will be resolved to a full path.Here\'s a script demonstrating each of these, whatdir.sh:Running this script in my home dir, using a relative path:Again, but using the full path to the script:Now changing directories:And finally using a symbolic link to execute the script:Works for all versions,including                                                                                                              Alternatively, if the bash script itself is a relative symlink you want to follow it and return the full path of the linked-to script:SCRIPT_PATH is given in full path, no matter how it is called.\nJust make sure you locate this at start of the script.This comment and code Copyleft, selectable license under the GPL2.0 or later or CC-SA 3.0  (CreativeCommons Share Alike) or later. (c) 2008. All rights reserved. No warranty of any kind. You have been warned.\nhttp://www.gnu.org/licenses/gpl-2.0.txt\nhttp://creativecommons.org/licenses/by-sa/3.0/\n18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656Short answer:or (preferably):You can use $BASH_SOURCENote that you need to use #!/bin/bash and not #!/bin/sh since its a bash extensionpwd can be used to find the current working directory, and dirname to find the directory of a particular file (command that was run, is $0, so dirname $0 should give you the directory of the current script).However, dirname gives precisely the directory portion of the filename, which more likely than not is going to be relative to the current working directory. If your script needs to change directory for some reason, then the output from dirname becomes meaningless.I suggest the following:This way, you get an absolute, rather then relative directory.Since the script will be run in a separate bash instance, there is no need to restore the working directory afterwards, but if you do want to change back in your script for some reason, you can easily assign the value of pwd to a variable before you change directory, for future use.Although justsolves the specific scenario in the question, I find having the absolute path to more more useful generally.This should do it:Works with symlinks and spaces in path.\nSee man pages for dirname and readlink.Edit: From the comment track it seems not to work with Mac OS.\nI have no idea why that is. Any suggestions?I don\'t think this is as easy as others have made it out to be.  pwd doesn\'t work, as the current dir is not necessarily the directory with the script.  $0 doesn\'t always have the info either.  Consider the following three ways to invoke a script.In the first and third ways $0 doesn\'t have the full path info.  In the second and third, pwd do not work.  The only way to get the dir in the third way would be to run through the path and find the file with the correct match.  Basically the code would have to redo what the OS does.One way to do what you are asking would be to just hardcode the data in the /usr/share dir, and reference it by full path.  Data shoudn\'t be in the /usr/bin dir anyway, so this is probably the thing to do.This gets the current working directory on Mac OS X 10.6.6:This is Linux specific, but you could use:Here is a POSIX compliant one-liner:I tried every one of these and none of them worked. One was very close but had a tiny bug that broke it badly; they forgot to wrap the path in quotation marks.Also a lot of people assume you\'re running the script from a shell so forget when you open a new script it defaults to your home.Try this directory on for size:/var/No one/Thought/About Spaces Being/In a Directory/Name/And Here\'s your file.textThis gets it right regardless how or where you run it.So to make it actually useful here\'s how to change to the directory of the running script:Hope that helpsI would use something like this:A slight revision to the solution e-satis and 3bcdnlklvc04a pointed out in their answerThis should still work in all the cases they listed.EDIT: prevent popd after failed pushd, thanks to konsoleboxHere is the simple, correct way:Explanation:${BASH_SOURCE[0]} - the full path to the script. The value of this will be correct even when the script is being sourced, e.g. source <(echo \'echo $0\') prints bash, while replacing it with ${BASH_SOURCE[0]} will print the full path of the script. (Of course, this assumes you\'re OK taking a dependency on Bash.)readlink -f - Recursively resolves any symlinks in the specified path. This is a GNU extension, and not available on (for example) BSD systems. If you\'re running a Mac, you can use Homebrew to install GNU coreutils and supplant this with greadlink -f.And of course dirname gets the parent directory of the path.$_ is worth mentioning as an alternative to $0.  If you\'re running a script from bash, the accepted answer can be shortened to:Note that this has to be the first statement in your script.Hmm, if in the path basename & dirname are just not going to cut it\nand walking the path is hard (what if parent didn\'t export PATH!).\nHowever, the shell has to have an open handle to its script, and in\nbash the handle is #255.works for me.I\'ve compared many of the answers given, and come up with some more compact solutions. These seem to handle all of the crazy edge cases that arise from your favorite combination of:If you\'re running from Linux, it seems that using the proc handle is the best solution to locate the fully resolved source of the currently running script (in an interactive session, the link points to the respective /dev/pts/X):This has a small bit of ugliness to it, but the fix is compact and easy to understand. We aren\'t using bash primitives only, but I\'m okay with that because readlink simplifies the task considerably. The echo X adds an X to the end of the variable string so that any trailing whitespace in the filename doesn\'t get eaten, and the parameter substitution ${VAR%X} at the end of the line gets rid of the X. Because readlink adds a newline of its own (which would normally be eaten in the command substitution if not for our previous trickery), we have to get rid of that, too. This is most easily accomplished using the $\'\' quoting scheme, which lets us use escape sequences such as \\n to represent newlines (this is also how you can easily make deviously named directories and files).The above should cover your needs for locating the currently running script on Linux, but if you don\'t have the proc filesystem at your disposal, or if you\'re trying to locate the fully resolved path of some other file, then maybe you\'ll find the below code helpful. It\'s only a slight modification from the above one-liner. If you\'re playing around with strange directory/filenames, checking the output with both ls and readlink is informative, as ls will output "simplified" paths, substituting ? for things like newlines.Try using:So... I believe I\'ve got this one. Late to the party, but I think some will appreciate it being here is them come across this thread. The comments should explain.For systems having GNU coreutils readlink (eg. linux):No need to use BASH_SOURCE when $0 contains the script filename.This is the only way I\'ve found to tell reliably:Try the following cross-compatible solution:as realpath or readlink commands are not always available (depending on the operating system) and ${BASH_SOURCE[0]} is available only in bash shell.Alternatively you can try the following function in bash:This function takes 1 argument. If argument has already absolute path, print it as it is, otherwise print $PWD variable + filename argument (without ./ prefix).Related:This works in bash-3.2:Here\'s an example of its usage:Say you have a ~/bin directory, which is in your $PATH. You have script A inside this directory. It sources script ~/bin/lib/B. You know where the included script is relative to the original one (the subdirectory lib), but not where it is relative to the user\'s current directory.This is solved by the following (inside A):It doesn\'t matter where the user is or how he calls the script, this will always work.The best compact solution in my view would be:There is no reliance on anything other than Bash.  The use of dirname, readlink and basename will eventually lead to compatibility issues, so they are best avoided if at all possible. None of these worked for a bash script launched by Finder in OS X - I ended up using:Not pretty, but it gets the job done.