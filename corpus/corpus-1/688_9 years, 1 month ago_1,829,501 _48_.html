I am trying to insert into a table using the input from another table. Although this is entirely feasible for many database engines, I always seem to struggle to remember the correct syntax for the SQL engine of the day (MySQL, Oracle, SQL Server, Informix, and DB2).Is there a silver-bullet syntax coming from an SQL standard (for example, SQL-92) that would allow me to insert the values without worrying about the underlying database?Try:This is standard ANSI SQL and should work on any DBMSIt definitely works for:@Shadow_x99: That should work fine, and you can also have multiple columns and other data as well:Edit: I should mention that I\'ve only used this syntax with Access, SQL 2000/2005/Express, MySQL, and PostgreSQL, so those should be covered. A commenter has pointed out that it\'ll work with SQLite3.To get only one value in a multi value INSERT from another table I did the following in SQLite3:Both the answers I see work fine in Informix specifically, and are basically standard SQL.  That is, the notation:works fine with Informix and, I would expect, all the DBMS.  (Once upon 5 or more years ago, this is the sort of thing that MySQL did not always support; it now has decent support for this sort of standard SQL syntax and, AFAIK, it would work OK on this notation.)  The column list is optional but indicates the target columns in sequence, so the first column of the result of the SELECT will go into the first listed column, etc.  In the absence of the column list, the first column of the result of the SELECT goes into the first column of the target table.What can be different between systems is the notation used to identify tables in different databases - the standard has nothing to say about inter-database (let alone inter-DBMS) operations.  With Informix, you can use the following notation to identify a table:That is, you may specify a database, optionally identifying the server that hosts that database if it is not in the current server, followed by an optional owner, dot, and finally the actual table name.  The SQL standard uses the term schema for what Informix calls the owner.  Thus, in Informix, any of the following notations could identify a table:The owner in general does not need to be quoted; however, if you do use quotes, you need to get the owner name spelled correctly - it becomes case-sensitive.  That is:all identify the same table.  With Informix, there\'s a mild complication with MODE ANSI databases, where owner names are generally converted to upper-case (informix is the exception).  That is, in a MODE ANSI database (not commonly used), you could write:and the owner name in the system catalog would be "SOMEONE", rather than \'someone\'.  If you enclose the owner name in double quotes, it acts like a delimited identifier.  With standard SQL, delimited identifiers can be used many places.  With Informix, you can use them only around owner names -- in other contexts, Informix treats both single-quoted and double-quoted strings as strings, rather than separating single-quoted strings as strings and double-quoted strings as delimited identifiers.  (Of course, just for completeness, there is an environment variable, DELIMIDENT, that can be set - to any value, but Y is safest - to indicate that double quotes always surround delimited identifiers and single quotes always surround strings.)Note that MS SQL Server manages to use [delimited identifiers] enclosed in square brackets.  It looks weird to me, and is certainly not part of the SQL standard.Most of the databases follow the basic syntax,Every database I have used follow this syntax namely, DB2, SQL Server, MY SQL, PostgresQLThis can be done without specifying the columns in the INSERT INTO part if you are supplying values for all columns in the SELECT part.Let\'s say table1 has two columns. This query should work:This WOULD NOT work (value for col2 is not specified):I\'m using MS SQL Server. I don\'t know how other RDMS work.To add something in the first answer, when we want only few records from another table (in this example only one):Simple insertion when table column sequence is known:Simple insertion mentioning column:Bulk insertion when number of selected columns of a table(#table2) are equal to insertion table(Table1)Bulk insertion when you want to insert only into desired column of a table(table1):This is another example using values with select:Here\'s how to insert from multiple tables. This particular example is where you have a mapping table in a many to many scenario:(I realise matching on the student name might return more than one value but you get the idea. Matching on something other than an Id is necessary when the Id is an Identity column and is unknown.)This works on all DBMSYou could try this if you want to insert all column using SELECT * INTO table.For Microsoft SQL Server, I will recommend learning to interpret the SYNTAX provided on MSDN. With Google it\'s easier than ever, to look for syntax.For this particular case, try Google: insert site:microsoft.comThe first result will be http://msdn.microsoft.com/en-us/library/ms174335.aspxscroll down to the example ("Using the SELECT and EXECUTE options to insert data from other tables") if you find it difficult to interpret the syntax given at the top of the page.This should be applicable for any other RDBMS available there. There is no point in remembering all the syntax for all products IMO.Its simple, instead of VALUES part of INSERT query, just use SELECT query as below.I actually prefer the following in SQL Server 2008:It eliminates the step of adding the Insert () set, and you just select which values go in the table.Here is another example where source is taken using more than one table:This worked for me:The sentence is a bit different from Oracle\'s.Looks nice, but works only if tmp doesn\'t exists (creates it and fills). (SQL sever)To insert into existing tmp table: If you go the INSERT VALUES route to insert multiple rows, make sure to delimit the VALUES into sets using parentheses, so:    Otherwise MySQL objects that "Column count doesn\'t match value count at row 1", and you end up writing a trivial post when you finally figure out what to do about it. 