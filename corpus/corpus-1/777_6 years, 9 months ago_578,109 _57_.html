What does enctype=\'multipart/form-data\' mean in an HTML form and when should we use it?When you make a POST request, you have to encode the data that forms the body of the request in some way. HTML forms provide three methods of encoding. Work was being done on adding application/json, but that has been abandoned.The specifics of the formats don\'t matter to most developers. The important points are:When you are writing client-side code, all you need to know is use multipart/form-data when your form includes any <input type="file"> elements.When you are writing server-side code: Use a prewritten form handling library (e.g. Perl\'s CGI->param or the one exposed by PHP\'s $_POST superglobal) and it will take care of the differences for you. Don\'t bother trying to parse the raw input received by the server.Never use text/plain.If you are writing (or debugging) a library for parsing or generating the raw data, then you need to start worrying about the format. You might also want to know about it for interest\'s sake.application/x-www-form-urlencoded is more or less the same as a query string on the end of the URL. multipart/form-data is significantly more complicated but it allows entire files to be included in the data. An example of the result can be found in the HTML 4 specification. text/plain is introduced by HTML 5 and is useful only for debugging \xe2\x80\x94 from the spec: They are not reliably interpretable by computer \xe2\x80\x94 and I\'d argue that the others combined with tools (like the Net tab in the developer tools of most browsers) are better for that).when should we use itQuentin\'s answer is right: use multipart/form-data if the form contains a file upload, and application/x-www-form-urlencoded otherwise, which is the default if you omit enctype.I\'m going to:There are three possibilities for enctype:Once you see an example of each method, it becomes obvious how they work, and when you should use each one.You can produce examples using:Save the form to a minimal .html file:We set the default text value to a&#x03C9;b, which means a\xcf\x89b because \xcf\x89 is U+03C9, which are the bytes 61 CF 89 62 in UTF-8.Create files to upload:Run our little echo server:Open the HTML on your browser, select the files and click on submit and check the terminal. nc prints the request received.Tested on: Ubuntu 14.04.3, nc BSD 1.105, Firefox 40.Firefox sent:For the binary file and text field, the bytes 61 CF 89 62 (a\xcf\x89b in UTF-8) are sent literally. You could verify that with nc -l localhost 8000 | hd, which says that the bytes:were sent (61 == \'a\' and 62 == \'b\').Therefore it is clear that:Content-Type: multipart/form-data; boundary=---------------------------9051914041544843365972754266 sets the content type to multipart/form-data and says that the fields are separated by the given boundary string.every field gets some sub headers before its data: Content-Disposition: form-data;, the field name, the filename, followed by the data.The server reads the data until the next boundary string. The browser must choose a boundary that will not appear in any of the fields, so this is why the boundary may vary between requests.Because we have the unique boundary, no encoding of the data is necessary: binary data is sent as is.TODO: what is the optimal boundary size (log(N) I bet), and name / running time of the algorithm that finds it? Asked at: https://cs.stackexchange.com/questions/39687/find-the-shortest-sequence-that-is-not-a-sub-sequence-of-a-set-of-sequencesContent-Type is automatically determined by the browser.How it is determined exactly was asked at: How is mime type of an uploaded file determined by browser?Now change the enctype to application/x-www-form-urlencoded, reload the browser, and resubmit.Firefox sent:Clearly the file data was not sent, only the basenames. So this cannot be used for files.As for the text field, we see that usual printable characters like a and b were sent in one byte, while non-printable ones like 0xCF and 0x89 took up 3 bytes each: %CF%89!File uploads often contain lots of non-printable characters (e.g. images), while text forms almost never do.From the examples we have seen that:multipart/form-data: adds a few bytes of boundary overhead to the message, and must spend some time calculating it, but sends each byte in one byte.application/x-www-form-urlencoded: has a single byte boundary per field (&), but adds a linear overhead factor of 3x for every non-printable character.Therefore, even if we could send files with application/x-www-form-urlencoded, we wouldn\'t want to, because it is so inefficient.But for printable characters found in text fields, it does not matter and generates less overhead, so we just use it.When submitting a form, you\'re trying to say your browser to send via the HTTP protocol a message on the network properly enveloped in a TCP/IP protocol message structure. When sending data, you can use POST or GET methods to send data using HTTP protocol. POST tells your browser to build an HTTP message and put all content in the body of the message (a very useful way of doing things, more safe and also flexible). GET has some constraints about data representation and length.When sending a file, it is necessary to tell the HTTP protocol that you are sending a file having several characteristics and information inside it. In this way it is possible to consistently send data to receiver and let it open the file with the current format and so on...\nThis is a requirement from the HTTP protocol as shown hereYou cannot send files using default enctype parameters because your receiver might encounter problems reading it (consider that a file is a descriptor for some data for a specific operating system, if you see things this way, maybe you\'ll understand why it is so important to specify a different enctype for files).This way of doing things also ensures that some security algorithms work on your messages. This information is also used by application-level routers in order to act as good firewalls for external data.Well, as you can see, it is not a stupid thing using a specific enctype for files.enctype=\'multipart/form-data is an encoding type that allows files to be sent through a POST. Quite simply, without this encoding the files cannot be sent through POST.If you want to allow a user to upload a file via a form, you must use this enctype.enctype=\'multipart/form-data\' means that no characters will be encoded. that is why this type is used while uploading files to server.\nSo multipart/form-data is used when a form requires binary data, like the contents of a file, to be uploadedSet the method attribute to POST because file content can\'t be put inside a URL       parameter using a form.Set the value of enctype to multipart/form-data because the data will be split into multiple parts, one for each file plus one for the text of the form body that may be sent with them.Usually this is when you have a POST form which needs to take a file upload as data... this will tell the server how it will encode the data transferred, in such case it won\'t get encoded because it will just transfer and upload the files to the server, Like for example when uploading an image or a pdf