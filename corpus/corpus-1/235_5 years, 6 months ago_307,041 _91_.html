How does data binding work in the AngularJS framework?I haven\'t found technical details on their site. It\'s more or less clear how it works when data is propagated from view to model. But how does AngularJS track changes of model properties without setters and getters?I found that there are JavaScript watchers that may do this work. But they are not supported in Internet Explorer 6 and Internet Explorer 7. So how does AngularJS know that I changed for example the following and reflected this change on a view?AngularJS remembers the value and compares it to a previous value. This is basic dirty-checking. If there is a change in value, then it fires the change event.The $apply() method, which is what you call when you are transitioning from a non-AngularJS world into an AngularJS world, calls $digest(). A digest is just plain old dirty-checking. It works on all browsers and is totally predictable.To contrast dirty-checking (AngularJS) vs change listeners (KnockoutJS and Backbone.js): While dirty-checking may seem simple, and even inefficient (I will address that later), it turns out that it is semantically correct all the time, while change listeners have lots of weird corner cases and need things like dependency tracking to make it more semantically correct. KnockoutJS dependency tracking is a clever feature for a problem which AngularJS does not have.So it may seem that we are slow, since dirty-checking is inefficient. This is where we need to look at real numbers rather than just have theoretical arguments, but first let\'s define some constraints.Humans are:Slow \xe2\x80\x94 Anything faster than 50 ms is imperceptible to humans and thus can be considered as "instant".Limited \xe2\x80\x94 You can\'t really show more than about 2000 pieces of information to a human on a single page. Anything more than that is really bad UI, and humans can\'t process this anyway.So the real question is this: How many comparisons can you do on a browser in 50 ms? This is a hard question to answer as many factors come into play, but here is a test case: http://jsperf.com/angularjs-digest/6 which creates 10,000 watchers. On a modern browser this takes just under 6 ms. On Internet Explorer 8 it takes about 40 ms. As you can see, this is not an issue even on slow browsers these days. There is a caveat: The comparisons need to be simple to fit into the time limit... Unfortunately it is way too easy to add a slow comparison into AngularJS, so it is easy to build slow applications when you don\'t know what you are doing. But we hope to have an answer by providing an instrumentation module, which would show you which are the slow comparisons.It turns out that video games and GPUs use the dirty-checking approach, specifically because it is consistent. As long as they get over the monitor refresh rate (typically 50-60 Hz, or every 16.6-20 ms), any performance over that is a waste, so you\'re better off drawing more stuff, than getting FPS higher.Misko already gave an excellent description of how the data bindings work, but I would like to add my view on the performance issue with the data binding.As Misko stated, around 2000 bindings is where you start to see problems, but you shouldn\'t have more than 2000 pieces of information on a page anyway. This may be true, but not every data-binding is visible to the user. Once you start building any sort of widget or data grid with two-way binding you can easily hit 2000 bindings, without having a bad ux.Consider, for example, a combobox where you can type text to filter the available options. This sort of control could have ~150 items and still be highly usable. If it has some extra feature (for example a specific class on the currently selected option) you start to get 3-5 bindings per option. Put three of these widgets on a page (e.g. one to select a country, the other to select a city in said country, and the third to select a hotel) and you are somewhere between 1000 and 2000 bindings already.Or consider a data-grid in a corporate web application. 50 rows per page is not unreasonable, each of which could have 10-20 columns. If you build this with ng-repeats, and/or have information in some cells which uses some bindings, you could be approaching 2000 bindings with this grid alone.I find this to be a huge problem when working with AngularJS, and the only solution I\'ve been able to find so far is to construct widgets without using two-way binding, instead using ngOnce, deregistering watchers and similar tricks, or construct directives which builds the DOM with jQuery and DOM manipulation. I feel this defeats the purpose of using Angular in the first place.I would love to hear suggestions on other ways to handle this, but then maybe I should write my own question. I wanted to put this in a comment, but it turned out to be way too long for that...TL;DR \nThe data binding can cause performance issues on complex pages.Angular maintains a simple array of watchers in the $scope objects. If you inspect any $scope you will find that it contains an array called $$watchers. Each watcher is an object that contains among other thingsThere are many different ways of defining a watcher in AngularJS. You can explicitly $watch an attribute on $scope. You can place a {{}} interpolation in your template (a watcher will be created for you on the current $scope). You can ask a directive such as ng-model to define the watcher for you.When we interact with angular through the normal channels (ng-model, ng-repeat, etc) a digest cycle will be triggered by the directive.A digest cycle is a depth first traversal of $scope and all its children. For each $scope object, we iterate over its $$watchers array and evaluate all the expressions. If the new expression value is different from the last known value, the watcher\'s function is called. This function might recompile part of the DOM, recompute a value on $scope, trigger an AJAX request, anything you need it to do.Every scope is traversed and every watch expression evaluated and checked against the last value.If a watcher is triggered, the app knows something has changed, and the $scope is marked as dirty.Watcher functions can change other attributes on $scope or on a parent $scope. If one $watcher function has been triggered, we can\'t guarantee that our other $scopes are still clean, and so we execute the entire digest cycle again.This is because Angular 1 has two way binding, so data can be passed back up the $scope tree. We may change a value on a higher $scope that has already been digested. Perhaps we change a value on the $rootScope.We continually loop through the $digest cycle until either the digest cycle comes up clean (all $watch expressions have the same value as they had in the previous cycle), or we reach the digest limit. By default, this limit is set at 10.If we reach the digest limit Angular will raise an error in the console:As you can see, every time something changes in an Angular app, Angular will check every single watcher in the $scope hierarchy to see how to respond. For a developer this is a massive productivity boon, as you now need to write almost no wiring code, Angular will just notice if a value has changed, and make the resto of the app consistent with the change.From the perspective of the machine though this is wildly inefficient and will slow our app down if we create too many watchers. Misko has quoted a figure of about 4000 watchers before your app will feel slow on older browsers.This limit is easy to reach if you ng-repeat over a large JSON array for example. You can mitigate against this using features like one-time binding to compile a template without creating watchers.Each time your user interacts with your app, every single watcher in your app will be evaluated at least once. A big part of optimising an Angular app is reducing the number of watchers in your $scope tree. One easy way to do this is with one time binding.If you have data which will rarely change, you can bind it only once using the :: syntax, like so:orThe binding will only be triggered when the containing template is rendered and the data loaded into $scope.This is especially important when you have an ng-repeat with many items.This is my basic understanding. It may well be wrong!In normal development, data-binding syntax in the HTML tells the AngularJS compiler to create the watches for you and controller methods are run inside $apply already. So to the application developer it is all transparent.I wondered this myself for a while. Without setters how does AngularJS notice changes to the $scope object? Does it poll them?What it actually does is this: Any "normal" place you modify the model was already called from the guts of AngularJS, so it automatically calls $apply for you after your code runs. Say your controller has a method that\'s hooked up to ng-click on some element. Because AngularJS wires the calling of that method together for you, it has a chance to do an $apply in the appropriate place. Likewise for expressions that appear right in the views, those are executed by AngularJS so it does the $apply.When the documentation talk about having to call $apply manually for code outside of AngularJS, it\'s talking about code which, when run, doesn\'t stem from AngularJS itself in the call stack.Explaining with Pictures : The reference in the scope is not exactly the reference   in the template. When you data-bind two objects, you need a third one that listen to the first and modify the other.Here, when you modify the <input>, you touch the data-ref3. And the classic data-bind mecanism will change data-ref4. So how the other {{data}} expressions will move ?Angular maintains a oldValue and newValue of every binding. And after every Angular event, the famous $digest() loop will check the WatchList to see if something changed. These Angular events are ng-click, ng-change, $http completed ...  The $digest() will loop as long as any oldValue differs from the newValue.In the previous picture, it will notice that data-ref1 and data-ref2 has changed.It\'s a little like the Egg and Chicken. You never know who starts, but hopefully it works most of the time as expected. The other point is that you can understand easily the impact deep of a simple binding on the memory and the CPU. Hopefully Desktops are fat enough to handle this. Mobile phones are not that strong.Obviously there is no periodic checking of Scope whether there is any change in the Objects attached to it. Not all the objects attached to scope are watched . Scope prototypically maintains a $$watchers . Scope only iterates through this $$watchers when $digest is called . Angular adds a watcher to the $$watchers for each of these $watch function takes in three parameters:First one is a watcher function which just returns the object or we can just add an expression. Second one is a listener function which will be called when there is a change in the object. All the things like DOM changes will be implemented in this function.The third being an optional parameter which takes in a boolean . If its true , angular deep watches the object & if its false Angular just does a reference watching on the object.\n    Rough Implementation of $watch looks like this There is an interesting thing in Angular called Digest Cycle. The $digest cycle starts as a result of a call to $scope.$digest(). Assume that you change a $scope model in a handler function through the ng-click directive. In that case AngularJS automatically triggers a $digest cycle by calling $digest().In addition to ng-click, there are several other built-in directives/services that let you change models (e.g. ng-model, $timeout, etc) and automatically trigger a $digest cycle.  The rough implementation of $digest looks like this.If we use JavaScript\xe2\x80\x99s setTimeout() function to update a scope model, Angular has no way of knowing what you might change. In this case it\xe2\x80\x99s our responsibility to call $apply() manually, which triggers a $digest cycle. Similarly, if you have a directive that sets up a DOM event listener and changes some models inside the handler function, you need to call $apply() to ensure the changes take effect. The big idea of $apply is that we can execute some code that isn\'t aware of Angular, that code may still change things on the scope. If we wrap that code in $apply , it will take care of calling $digest(). Rough implementation of $apply().AngularJS handle data-binding mechanism with the help of three powerful functions: $watch(), $digest()\nand $apply(). Most of the time AngularJS will call the $scope.$watch() and $scope.$digest() functions for you, but\nin some cases you may have to call these functions yourself to update new values.$watch() - This function is used to observe changes in a variable on the $scope. It accepts three\nparameters: expression, listener and equality object, where listener and equality object are optional parameters.$digest() - This function iterates through all the watches in the $scope object, and its child $scope objects (if it has\nany). When $digest() iterates over the watches, it checks if the value of the expression has changed. If the value\nhas changed, AngularJS calls the listener with the new value and the old value.\nThe $digest() function is called whenever AngularJS thinks it is necessary. For example, after a button click, or\nafter an AJAX call. You may have some cases where AngularJS does not call the $digest() function for you. In that\ncase you have to call it yourself.$apply() - Angular do auto-magically updates only those model changes which are inside AngularJS context. When\nyou do change in any model outside of the Angular context (like browser DOM events, setTimeout, XHR or third\nparty libraries), then you need to inform Angular of the changes by calling $apply() manually. When the $apply()\nfunction call finishes AngularJS calls $digest() internally, so all data bindings are updated.It happened that I needed to link a data model of a person with a form, what I did was a direct mapping of the data with the form.For example if the model had something like:The control input of the form:That way if you modify the value of the object controller, this will be reflected automatically in the view.An example where I passed the model is updated from server data is when you ask for a zip code and zip code based on written loads a list of colonies and cities associated with that view, and by default set the first value with the user. And this I worked very well, what does happen, is that angularJS sometimes takes a few seconds to refresh the model, to do this you can put a spinner while displaying the data.Here is an example of data binding with AngularJS, using an input field. I will explain laterHTML CodeAngularJS CodeAs you can see in the example above, AngularJS uses ng-model to listen and watch what happens on HTML elements, especially on input fields. When something happens, do something. In our case, ng-model is bind to our view, using the mustache notation {{}}. Whatever is typed inside the input field is displayed on the screen instantly. And that\'s the beauty of data binding, using AngularJS in its simplest form.Hope this helps.See a working example here on\nCodepenAngularJs supports Two way data-binding.\nMeans you can access data View -> Controller & Controller -> ViewFor Ex.1)O/PYou can bind data in ng-model Like:-\n2)Here in above example whatever input user will give, It will be visible in <div> tag.If want to bind input from html to controller:-\n3)Here if you want to use input name in the controller then,ng-model binds our view and render it in expression {{ }}.\nng-model is the data which is shown to the user in the view and with which the user interacts.\nSo it is easy to bind data in AngularJs.Angular.js creates a watcher for every model we create in view. Whenever a model is changed, an "ng-dirty" class is appeneded to the model, so the watcher will observe all models which have the class "ng-dirty" & update their values in the controller & vice versa.The one-way data binding is an approach where a value is taken from the data model and inserted into an HTML element. There is no way to update model from view. It is used in classical template systems. These systems bind data in only one direction.Data-binding in Angular apps is the automatic synchronisation of data between the model and view components.Data binding lets you treat the model as the single-source-of-truth in your application. The view is a projection of the model at all times. If the model is changed, the view reflects the change and vice versa.