How do you use Auto Layout within UITableViewCells in a table view to let each cell\'s content and subviews determine the row height, while maintaining smooth scrolling performance?TL;DR: Don\'t like reading? Jump straight to the sample projects on GitHub:The first 2 steps below are applicable regardless of which iOS versions you are developing for.In your UITableViewCell subclass, add constraints so that the subviews of the cell have their edges pinned to the edges of the cell\'s contentView (most importantly to the top AND bottom edges). NOTE: don\'t pin subviews to the cell itself; only to the cell\'s contentView! Let the intrinsic content size of these subviews drive the height of the table view cell\'s content view by making sure the content compression resistance and content hugging constraints in the vertical dimension for each subview are not being overridden by higher-priority constraints you have added. (Huh? Click here.)Remember, the idea is to have the cell\'s subviews connected vertically to the cell\'s content view so that they can "exert pressure" and make the content view expand to fit them. Using an example cell with a few subviews, here is a visual illustration of what some (not all!) of your constraints would need to look like:You can imagine that as more text is added to the multi-line body label in the example cell above, it will need to grow vertically to fit the text, which will effectively force the cell to grow in height. (Of course, you need to get the constraints right in order for this to work correctly!)Getting your constraints right is definitely the hardest and most important part of getting dynamic cell heights working with Auto Layout. If you make a mistake here, it could prevent everything else from working -- so take your time! I recommend setting up your constraints in code because you know exactly which constraints are being added where, and it\'s a lot easier to debug when things go wrong. Adding constraints in code is just as easy as and significantly more powerful than Interface Builder when you leverage one of the fantastic open source APIs available -- here is the one I design, maintain, and use exclusively: https://github.com/smileyborg/PureLayoutFor every unique set of constraints in the cell, use a unique cell reuse identifier. In other words, if your cells have more than one unique layout, each unique layout should receive its own reuse identifier. (A good hint that you need to use a new reuse identifier is when your cell variant has a different number of subviews, or the subviews are arranged in a distinct fashion.)For example, if you were displaying an email message in each cell, you might have 4 unique layouts: messages with just a subject, messages with a subject and a body, messages with a subject and a photo attachment, and messages with a subject, body, and photo attachment. Each layout has completely different constraints required to achieve it, so once the cell is initialized and the constraints are added for one of these cell types, the cell should get a unique reuse identifier specific to that cell type. This means when you dequeue a cell for reuse, the constraints have already been added and are ready to go for that cell type.Note that due to differences in intrinsic content size, cells with the same constraints (type) may still have varying heights! Don\'t confuse fundamentally different layouts (different constraints) with different calculated view frames (solved from identical constraints) due to different sizes of content.With iOS 8, Apple has internalized much of the work that previously had to be implemented by you prior to iOS 8. In order to allow the self-sizing cell mechanism to work, you must first set the rowHeight property on the table view to the constant UITableViewAutomaticDimension. Then, you simply need to enable row height estimation by setting the table view\'s estimatedRowHeight property to a nonzero value, for example:What this does is provide the table view with a temporary estimate/placeholder for the row heights of cells that are not yet onscreen. Then, when these cells are about to scroll onscreen, the actual row height will be calculated. To determine the actual height for each row, the table view automatically asks each cell what height its contentView needs to be based on the known fixed width of the content view (which is based on the table view\'s width, minus any additional things like a section index or accessory view) and the auto layout constraints you have added to the cell\'s content view and subviews. Once this actual cell height has been determined, the old estimated height for the row is updated with the new actual height (and any adjustments to the table view\'s contentSize/contentOffset are made as needed for you).Generally speaking, the estimate you provide doesn\'t have to be very accurate -- it is only used to correctly size the scroll indicator in the table view, and the table view does a good job of adjusting the scroll indicator for incorrect estimates as you scroll cells onscreen. You should set the estimatedRowHeight property on the table view (in viewDidLoad or similar) to a constant value that is the "average" row height. Only if your row heights have extreme variability (e.g. differ by an order of magnitude) and you notice the scroll indicator "jumping" as you scroll should you bother implementing tableView:estimatedHeightForRowAtIndexPath: to do the minimal calculation required to return a more accurate estimate for each row.First, instantiate an offscreen instance of a table view cell, one instance for each reuse identifier, that is used strictly for height calculations. (Offscreen meaning the cell reference is stored in a property/ivar on the view controller and never returned from tableView:cellForRowAtIndexPath: for the table view to actually render onscreen.) Next, the cell must be configured with the exact content (e.g. text, images, etc) that it would hold if it were to be displayed in the table view.Then, force the cell to immediately layout its subviews, and then use the systemLayoutSizeFittingSize: method on the UITableViewCell\'s contentView to find out what the required height of the cell is. Use UILayoutFittingCompressedSize to get the smallest size required to fit all the contents of the cell. The height can then be returned from the tableView:heightForRowAtIndexPath: delegate method.If your table view has more than a couple dozen rows in it, you will find that doing the Auto Layout constraint solving can quickly bog down the main thread when first loading the table view, as tableView:heightForRowAtIndexPath: is called on each and every row upon first load (in order to calculate the size of the scroll indicator).As of iOS 7, you can (and absolutely should) use the estimatedRowHeight property on the table view. What this does is provide the table view with a temporary estimate/placeholder for the row heights of cells that are not yet onscreen. Then, when these cells are about to scroll onscreen, the actual row height will be calculated (by calling tableView:heightForRowAtIndexPath:), and the estimated height updated with the actual one.Generally speaking, the estimate you provide doesn\'t have to be very accurate -- it is only used to correctly size the scroll indicator in the table view, and the table view does a good job of adjusting the scroll indicator for incorrect estimates as you scroll cells onscreen. You should set the estimatedRowHeight property on the table view (in viewDidLoad or similar) to a constant value that is the "average" row height. Only if your row heights have extreme variability (e.g. differ by an order of magnitude) and you notice the scroll indicator "jumping" as you scroll should you bother implementing tableView:estimatedHeightForRowAtIndexPath: to do the minimal calculation required to return a more accurate estimate for each row.If you\'ve done all the above and are still finding that performance is unacceptably slow when doing the constraint solving in tableView:heightForRowAtIndexPath:, you\'ll unfortunately need to implement some caching for cell heights. (This is the approach suggested by Apple\'s engineers.) The general idea is to let the Auto Layout engine solve the constraints the first time, then cache the calculated height for that cell and use the cached value for all future requests for that cell\'s height. The trick of course is to make sure you clear the cached height for a cell when anything happens that could cause the cell\'s height to change -- primarily, this would be when that cell\'s content changes or when other important events occur (like the user adjusting the Dynamic Type text size slider).These projects are fully working examples of table views with variable row heights due to table view cells containing dynamic content in UILabels.Feel free to raise any questions or issues you run into (you can open issues on GitHub or post comments here). I\'ll try my best to help!If you\'re using Xamarin, check out this sample project put together by @KentBoogaart.For IOS8 it\'s really simple:OR But for IOS7, the key is calculate the height after autolayout,Important If multiple lines labels, don\'t forget set the numberOfLines to 0.Don\'t forget label.preferredMaxLayoutWidth = CGRectGetWidth(tableView.bounds)The full example code is here.Updated for Swift 3William Hu\'s Swift answer is good, but it helps me to have some simple yet detailed steps when learning to do something for the first time. The example below is my test project while learning to make a UITableView with variable cell heights. I based it on this basic UITableView example for Swift.The finished project should look like this:It can be just a Single View Application.Add a new Swift file to your project. Name it MyCustomCell. This class will hold the outlets for the views that you add to your cell in the storyboard. In this basic example we will only have one label in each cell.We will connect this outlet later.Open ViewController.swift and make sure you have the following content:Important Note:It is the following two lines of code (along with auto layout) that make the variable cell height possible:Add a Table View to your view controller and use auto layout to pin it to the four sides. Then drag a Table View Cell onto the Table View. And onto the Prototype cell, drag a Label. Use auto layout to pin the label to the four edges of the content view of the Table View Cell.Important note:Custom class name and IdentifierSelect the Table View Cell and set the custom class to be MyCustomCell (the name of the class in the Swift file we added). Also set the Identifier to be cell (the same string that we used for the cellReuseIdentifier in the code above.Zero Lines for LabelSet the number of lines to 0 in your Label. This means multi-line and allows the label to resize itself based on its content. Hook Up the OutletsYou should be able to run your project now and get cells with variable heights.If you are not pinning the leading and trailing (left and right) edges, you may also need to set the label\'s preferredMaxLayoutWidth so that it knows when to line wrap. For example, if you had added a Center Horizontally constraint to the label in the project above rather than pin the leading and trailing edges, then you would need to add this line to the tableView:cellForRowAtIndexPath method:I decided to wrap this clever solution by @smileyborg into a UICollectionViewCell+AutoLayoutDynamicHeightCalculation category.The category also rectifies the issues outlined in @wildmonkey\'s answer (loading a cell from a nib and systemLayoutSizeFittingSize: returning CGRectZero)It doesn\'t take into account any caching but suits my needs right now. Feel free to copy, paste and hack at it.Thankfully we won\'t have to do this jazz in iOS8, but there it is for now!Here is my solution. You need to tell the TableView the estimatedHeight before it loads the view. Otherwise it wont be able to behave like expected.The solution proposed by @smileyborg is almost perfect. If you have a custom cell and you want one or more UILabel with dynamic heights then the systemLayoutSizeFittingSize method combined with AutoLayout enabled returns a CGSizeZero unless you move all your cell constraints from the cell to its contentView (as suggested by @TomSwift here How to resize superview to fit all subviews with autolayout?).To do so you need to insert the following code in your custom UITableViewCell implementation (thanks to @Adrian).Mixing @smileyborg answer with this should works.An important enough gotcha I just ran into to post as an answer.@smileyborg\'s answer is mostly correct. However, if you have any code in the layoutSubviews method of your custom cell class, for instance setting the preferredMaxLayoutWidth, then it won\'t be run with this code:It confounded me for awhile. Then I realized it\'s because those are only triggering layoutSubviews on the contentView, not the cell itself.My working code looks like this:Note that if you are creating a new cell, I\'m pretty sure you don\'t need to call setNeedsLayout as it should already be set. In cases where you save a reference to a cell, you should probably call it. Either way it shouldn\'t hurt anything.Another tip if you are using cell subclasses where you are setting things like preferredMaxLayoutWidth. As @smileyborg mentions, "your table view cell hasn\'t yet had its width fixed to the table view\'s width". This is true, and trouble if you are doing your work in your subclass and not in the view controller. However you can simply set the cell frame at this point using the table width:For instance in the calculation for height:(I happen to cache this particular cell for re-use, but that\'s irrelevant).In case people are still having trouble with this.  I wrote a quick blog post about using Autolayout with UITableViews Leveraging Autolayout For Dynamic Cell Heights as well as an open source component to help make this more abstract and easier to implement.\nhttps://github.com/Raizlabs/RZCellSizeManagerAs long as your layout in your cell is good.Update:  You should use dynamic resizing introduced in iOS 8.(for Xcode 8.x / Xcode 9.x read at the bottom)Beware of the following issue in in Xcode 7.x, which might be a source of confusion:Interface Builder does not handle auto-sizing cell set-up properly. Even if your constraints are  absolutely valid, IB will still complain and give you confusing suggestions and errors. The reason is that IB is unwilling to change the row\'s height as your constraints dictate (so that the cell fits around your content). Instead, it keeps the row\'s height fixed and starts suggesting you change your constraints, which you should ignore.For example, imagine you\'ve set up everything fine, no warnings, no errors, all works.Now if you change the font size (in this example I\'m changing the description label font size from 17.0 to 18.0).Because the font size increased, the label now wants to occupy 3 rows (before that it was occupying 2 rows).If Interface Builder worked as expected, it would resize the cell\'s height to accommodate the new label height. However what actually happens is that IB displays the red auto-layout error icon and suggest that you modify hugging/compression priorities.You should ignore these warnings. What you can* do instead is to manually change the row\'s height in (select Cell > Size Inspector > Row Height).I was changing this height one click at a time (using the up/down stepper) until the red arrow errors disappear! (you will actually get yellow warnings, at which point just go ahead and do \'update frames\', it should all work).* Note that you don\'t actually have to resolve these red errors or yellow warnings in Interface Builder - at runtime, everything will work correctly (even if IB shows errors/warnings). Just make sure that at runtime in the console log you\'re not getting any AutoLayout errors. \n\nIn fact trying to always update row height in IB is super annoying and sometimes close to impossible (because of fractional values).\n\nTo prevent the annoying IB warnings/errors, you can select the views involved and in Size Inspector for the property Ambiguity choose Verify Position OnlyXcode 8.x / Xcode 9.x seems to (sometimes) be doing things differently than Xcode 7.x, but still incorrectly. For example even when compression resistance priority / hugging priority are set to required (1000), Interface Builder might stretch or clip a label to fit the cell (instead of resizing cell height to fit around the label). And in such a case it might not even show any AutoLayout warnings or errors. Or sometimes it does exactly what Xcode 7.x did, described above.Like @Bob-Spryn I ran into an important enough gotcha that I\'m posting this as an answer.I struggled with @smileyborg\'s answer for a while. The gotcha that I ran into is if you\'ve defined your prototype cell in IB with additional elements (UILabels, UIButtons, etc.) in IB when you instantiate the cell with [[YourTableViewCellClass alloc] init] it will not instantiate all the other elements within that cell unless you\'ve written code to do that. (I had a similar experience with initWithStyle.)To have the storyboard instantiate all the additional elements obtain your cell with [tableView dequeueReusableCellWithIdentifier:@"DoseNeeded"] (Not [tableView dequeueReusableCellWithIdentifier:forIndexPath:] as this\'ll cause interesting problems.) When you do this all the elements you defined in IB will be instantiated.Dynamic Table View Cell Height and Auto LayoutA good way to solve the problem with storyboard Auto Layout:Another "solution": skip all this frustration and use a UIScrollView instead to get a result that looks and feels identical to UITableView.That was the painful "solution" for me, after having put in literally 20+ very frustrating hours total trying to build something like what smileyborg suggested and failing over many months and three versions of App Store releases.My take is that if you really need iOS 7 support (for us, it\'s essential) then the technology is just too brittle and you\'ll pull your hair out trying. And that UITableView is complete overkill generally unless you\'re using some of the advanced row editing features and/or really need to support 1000+ "rows" (in our app, it\'s realistically never more than 20 rows). The added bonus is that the code gets insanely simple versus all the delegate crap and back and forth that comes with UITableView. It\'s just one single loop of code in viewOnLoad that looks elegant and is easy to manage.Here\'s some tips on how to do it:1) Using either Storyboard or a nib file, create a ViewController and associated root view.2) Drag over a UIScrollView onto your root view.3) Add constraints top, bottom, left and right constraints to the top-level view so the UIScrollView fills the entire root view.4) Add a UIView inside the UIScrollView and call it "container". Add top, bottom, left and right constraints to the UIScrollView (its parent). KEY TRICK: Also add a "Equal widths" constraints to link the UIScrollView and UIView.You will get an error "scroll view has ambiguous scrollable content height" and that your container UIView should have a height of 0 pixels. Neither error seems to matter when the app is running.5) Create nib files and controllers for each of your "cells". Use UIView not UITableViewCell.5) In your root ViewController, you essentially add all the "rows" to the container UIView and programmatically add constraints linking their left and right edges to the container view, their top edges to either the container view top (for the first item) or the previous cell. Then link the final cell to the container bottom.For us, each "row" is in a nib file. So the code looks something like this:And here\'s the code for UITools.addViewToTop:The only "gotcha" I\'ve found with this approach so far is that UITableView has a nice feature of "floating" section headers at the top of the view as you scroll. The above solution won\'t do that unless you add more programming but for our particular case this feature wasn\'t 100% essential and nobody noticed when it went away.If you want dividers between your cells, just add a 1 pixel high UIView at the bottom of your custom "cell" that looks like a divider.Be sure to turn on "bounces" and "bounce vertically" for the refresh control to work and so it seems more like a tableview.TableView shows some empty rows and dividers under your content, if it doesn\'t fill the full screen where as this solution doesn\'t. But personally, I prefer if those empty rows weren\'t there anyway - with variable cell height it always looked "buggy" to me anyway to have the empty rows in there.Here\'s hoping some other programmer reads my post BEFORE wasting 20+ hours trying to figure it out with Table View in their own app. :)Let\'s say you have a cell with a subview, and you want the cell\'s height to be high enough to encompass the subview + padding.1) Set the subview\'s bottom constraint equal to the cell.contentView minus the padding you want. Do not set constraints on the cell or cell.contentView itself.2) Set either the tableView\'s rowHeight property or tableView:heightForRowAtIndexPath: to UITableViewAutomaticDimension.3) Set either the tableView\'s estimatedRowHeight property or tableView:estimatedHeightForRowAtIndexPath: to a best guess of the height.That\'s it.I had to use dynamic views (setup views and constraints by code) and when I wanted to set preferredMaxLayoutWidth label\'s width was 0. So I\'ve got wrong cell height.Then I added before executingAfter that label\'s width was as expected and dynamic height was calculating right.I\'ve also found a YouTube video explaining how to achieve this using the STV framework.If you do you layout programmatically, here is what to consider for iOS 10 using anchors in Swift.There are three rules/ stepsNUMBER 1: set this two properties of tableview on viewDidLoad, the first one is telling to the tableview that should expect dynamic sizes on their cells, the second one is just to let the app calculate the size of the scrollbar indicator, so it helps for performance.NUMBER 2: This is important you need to add the subviews to the contentView of the cell not to the view, and also use its layoutsmarginguide to anchor the subviews to the top and bottom, this is a working example of how to do it.Create a method that will add the subviews and perform the layout, call it in the init method. NUMBER 3: DON\'T CALL THE METHOD:If you do it you will override your implementation.Follow this 3 rules for dynamic cells in tableviews.here is a working implementation \nhttps://github.com/jamesrochabrun/MinimalViewControllerIn my case i have to create a custom cell with a image which is coming from server and can be of any width and height. And two UILabels with dynamic size(both width & height)i have achieved the same here in my answer with autolayout and programmatically:Basically above @smileyBorg answer helped but systemLayoutSizeFittingSize never worked for me, In my approach :1. No use of automatic row height calculation property. 2.No use of estimated height 3.No need of unnecessary updateConstraints. 4.No use of Automatic Preferred Max Layout Width. 5. No use of systemLayoutSizeFittingSize (should have use but not working for me, i dont know what it is doing internally), but instead my method -(float)getViewHeight working and i know what it\'s doing internally.Is it possible to have differing heights in a UITableView Cell when I use several different ways of displaying the cell?In my case, the padding was because of the sectionHeader and sectionFooter heights, where storyboard allowed me to change it to minimum 1. So in viewDidLoad method:yet another iOs7+iOs8 solution in Swift