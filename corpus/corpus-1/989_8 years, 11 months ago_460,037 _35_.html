What is the best way to check whether a given object is of a given type? How about checking whether the object inherits from a given type?Let\'s say I have an object o. How do I check whether it\'s a str?To check if the type of o is exactly str:To check if o is an instance of str or any subclass of str (this would be the "canonical" way):The following also works, and can be useful in some cases:See Built-in Functions in the Python Library Reference for relevant information.One more note: in this case, you may actually want to use:because this will also catch Unicode strings (unicode is not a subclass of str; both str and unicode are subclasses of basestring).Alternatively, isinstance accepts a tuple of classes. This will return True if x is an instance of any subclass of any of (str, unicode):The most Pythonic way to check the type of an object is... not to check it.Since Python encourages Duck Typing, you should just try to use the object\'s methods the way you want to use them.  So if your function is looking for a writable file object, don\'t check that it\'s a subclass of file, just try to use its .write() method!Of course, sometimes these nice abstractions break down and isinstance(obj, cls) is what you need.  But use sparingly.isinstance(o, str) will return true if o is an str or is of a type that inherits from str.type(o) == str will return true if and only if o is a str. It will return false if o is of a type that inherits from str.LinkHere is an example why duck typing is evil without knowing when it is dangerous.\nFor instance: Here is the Python code (possibly omitting proper indenting), note that this \nsituation is avoidable by taking care of isinstance and issubclassof functions to make sure that when you really need a duck, you don\'t get a bomb.Since the question was asked and answered, type annotations have been added to Python. Type annotations in Python do not cause types to be statically enforced but they allow for types to be checked. Example of type annotation syntax:In this case we want an error to be triggered for foo(\'oops\') since the annotated type of the argument is int. The added annotation does not cause an error to occur when the script is run normally but it associates type annotation data with the function that other programs can use to check for type errors.One of these other programs that can be used to find the type error is mypy:(You might need to install mypy from your package manager. I don\'t think it comes with CPython but seems to have some level of "officialness".)Type checking this way is different from type checking in statically typed compiled languages. Because types are dynamic in Python, type checking must be done at runtime, which imposes a cost -- even on correct programs -- if we insist that it happen at every chance. Explicit type checks may also be more restrictive than needed and cause unnecessary errors (e.g. does the argument really need to be of exactly list type or is anything iterable sufficient?).The upside of explicit type checking is that it can catch errors earlier and give clearer error messages than duck typing. The exact requirements of a duck type can only be expressed with external documentation (hopefully it\'s thorough and accurate) and errors from incompatible types can occur far from where they originate.Python\'s type annotations are meant to offer a compromise where types can be specified and checked but there is no additional cost during usual code execution.The typing package offers type variables that can be used in type annotations to express needed behaviors without requiring particular types. For example, it includes variables such as Iterable and Callable for annotations to specify the need for any type with those behaviors.I think the cool thing about using a dynamic language like python is you really shouldn\'t have to check something like that.I would just call the required methods on your object and catch an AttributeError. Later on this will allow you to call your methods with other (seemingly unrelated) objects to accomplish different tasks, such as mocking an object for testing.I\'ve used this alot when getting data off the web with urllib2.urlopen() which returns a file like object. This can in turn can be passed to almost any method that reads from a file, because is implements the same read() method as a real file.But I\'m sure there is a time and place for using isinstance(), otherwise it probably wouldn\'t be there :)To Hugo:You probably mean list rather than array, but that points to the whole problem with type checking - you don\'t want to know if the object in question is a list, you want to know if it\'s some kind of sequence or if it\'s a single object. So try to use it like a sequence.Say you want to add the object to an existing sequence, or if it\'s a sequence of objects, add them allOne trick with this is if you are working with strings and/or sequences of strings - that\'s tricky, as a string is often thought of as a single object, but it\'s also a sequence of characters. Worse than that, as it\'s really a sequence of single-length strings.I usually choose to design my API so that it only accepts either a single value or a sequence - it makes things easier. It\'s not hard to put a [ ] around your single vealue when you pass it in if need be.(though this can cause errors with strings, as they do look like (are) sequences)you can check with the below line to check the given value is which character type