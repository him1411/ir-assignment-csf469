How do I revert from my current state to a snapshot made on a certain commit? If I do git log, I get the following output:How do revert to the commit from November 3, i.e. commit 0d1d7fc?This depends a lot on what you mean by "revert".If you want to temporarily go back to it, fool around, then come back to where you are, all you have to do is check out the desired commit:Or if you want to make commits while you\'re there, go ahead and make a new branch while you\'re at it:To go back to where you were, just check out the branch you were on again. (If you\'ve made changes, as always when switching branches, you\'ll have to deal with them as appropriate. You could reset to throw them away; you could stash, checkout, stash pop to take them with you; you could commit them to a branch there if you want a branch there.)If, on the other hand, you want to really get rid of everything you\'ve done since then, there are two possibilities. One, if you haven\'t published any of these commits, simply reset:If you mess up, you\'ve already thrown away your local changes, but you can at least get back to where you were before by resetting again.On the other hand, if you\'ve published the work, you probably don\'t want to reset the branch, since that\'s effectively rewriting history. In that case, you could indeed revert the commits. With Git, revert has a very specific meaning: create a commit with the reverse patch to cancel it out. This way you don\'t rewrite any history.The git-revert manpage actually covers a lot of this in its description. Another useful link is this git-scm.com blog post discussing git-revert.If you decide you didn\'t want to revert after all, you can revert the revert (as described here) or reset back to before the revert (see the previous section).You may also find this answer helpful in this case:\nHow to move HEAD back to a previous location? (Detached head)To revert to a previous commit, ignoring any changes:where HEAD is the last commit in your current branchTo revert to a commit that\'s older than the most recent commit:Credits go to a similar Stack Overflow question, Revert to a commit by a SHA hash in Git?.Lots of complicated and dangerous answers here, but it\'s actually easy:This will revert everything from the HEAD back to the commit hash, meaning it will recreate that commit state in the working tree as if every commit since had been walked back. You can then commit the current tree, and it will create a brand new commit essentially equivalent to the commit you "reverted" to.  (The --no-commit flag lets git revert all the commits at once- otherwise you\'ll be prompted for a message for each commit in the range, littering your history with unnecessary new commits.)This is a safe and easy way to rollback to a previous state. No history is destroyed, so it can be used for commits that have already been made public.The best option for me and probably others is the Git reset option:This has been the best option for me! It is simple, fast and effective!Note : As mentioned in comments don\'t do this if you\'re sharing your branch with other people who have copies of the old commitsAlso from the comments, if you wanted a less \'ballzy\' method you could use git clean -i I have tried a lot of ways to revert local changes in Git, and it seems that this works the best if you just want to revert to the latest commit state. Short description: I found a much more convenient and simple way to achieve the results above: where HEAD points to the latest commit at you current branch.It is the same code code as boulder_ruby suggested, but I have added git add . before  git reset --hard HEAD to erase all new files created since the last commit since this is what most people expect I believe when reverting to the latest commit.If you want to "uncommit", erase the last commit message, and put the modified files back in staging, you would use the command:This is an extremely useful command in situations where you committed the wrong thing and you want to undo that last commit.Source: http://nakkaya.com/2009/09/24/git-delete-last-commit/You can do this by the following two commands:It will remove your previous Git commit.If you want to keep your changes, you can also use:Then it will save your changes.Before answering lets add some background, explaining what is this HEAD.HEAD is simply a reference to the current commit (latest) on the current branch.\nThere can only be a single HEAD at any given time. (excluding git worktree)The content of HEAD is stored inside .git/HEAD and it contains the 40 bytes SHA-1 of the current commit.If you are not on the latest commit - meaning that HEAD is pointing to a prior commit in history its called detached HEAD.On the command line it will look like this- SHA-1 instead of the branch name since the HEAD is not pointing to the the tip of the current branchThis will checkout new branch pointing to the desired commit.\nThis command will checkout to a given commit.\nAt this point you can create a branch and start to work from this point on.You can always use the reflog as well.\ngit reflog will display any change which updated the HEAD and checking out the desired reflog entry will set the HEAD back to this commit. Every time the HEAD is modified there will be a new entry in the reflogThis will get you back to your desired commit"Move" your head back to the desired commit.This schema illustrate which command does what.\nAs you can see there reset && checkout modify the HEAD.Say you have the following commits in a text file named ~/commits-to-revert.txt (I used git log --pretty=oneline to get them)Create a Bash shell script to revert each of them:This reverts everything back to the previous state, including file and directory creations, and deletions, commit it to your branch and you retain the history, but you have it reverted back to the same file structure. Why Git doesn\'t have a git revert --to <hash> is beyond me.Jefromi\'s solutions are definitely the best ones, and you should definitely use them. However, for the sake of completeness, I also wanted to show these other alternative solutions that can also be used to revert a commit (in the sense that you create a new commit that undoes changes in previous commit, just like what git revert does).To be clear, these alternatives are not the best way to revert commits, Jefromi\'s solutions are, but I just want to point out that you can also use these other methods to achieve the same thing as git revert.This is a very slightly modified version of Charles Bailey\'s solution to Revert to a commit by a SHA hash in Git?:This basically works by using the fact that soft resets will leave the state of the previous commit staged in the index/staging-area, which you can then commit.This solution comes from svick\'s solution to Checkout old commit and make it a new commit:Similarly to alternative #1, this reproduces the state of <commit> in the current working copy. It is necessary to do git rm first because git checkout won\'t remove files that have been added since <commit>.Here is a much simpler way to go back to a previous commit (and have it in an uncommited state, to do with it whatever you like):So, no need for commit ids and so on :)Assuming you\'re talking about master and on that respective branch (that said, this could be any working branch you\'re concerned with):I found the answer from in blog post Delete remote Git repo to specific commit.There is a command (not a part of core Git, but it is in the git-extras package) specifically for reverting and staging old commits:Per the man page, it can also be used as such:After all the changes, when you push all these commands, you might have to use:And not only git push.Select your required commit, and check it bytill you get the required commit. To make the HEAD point to that, door git reset --hard HEAD~2 or whatever.OK, going back to previous commit in git is quite easy...Revert back without keeping the changes:Revert back with keeping the changes:Explain: using git reset, you can reset to a specific state, it\'s common using it with a commit hash as you see above. But as you see the difference is using the two flags --soft and --hard, by default git reset using --soft flag, but it\'s a good practice always using the flag, I explain each flags:The default flag as explained, not need to provide it, does not change the working tree, but add all changes files ready to commit, so you go back to the commit status which changes to files get unstaged. Be careful with this flag, it resets the working tree and all changes to tracked files and all will be gone!I also created the image below that may happens in a real life working with git:To keep the changes from the previous commit to HEAD and move to the previous commit, do:If changes are not required from the previous commit to HEAD and just discard all changes, do:To completely clean a coder\'s directory up from some accidental changes, we used:Just git reset --hard HEAD will get rid of modifications, but it won\'t get rid of "new" files. In their case they\'d accidentally dragged an important folder somewhere random, and all those files were being treated as new by Git, so a reset --hard didn\'t fix it. By running the git add -A . beforehand, it explicitly tracked them all with git, to be wiped out by the reset.I believe some people may come to this question wanting to know how to rollback committed changes they\'ve made in their master - ie throw everything away and go back to origin/master, in which case, do this:https://superuser.com/questions/273172/how-to-reset-master-to-origin-masterIt directly clears all the changes that you have been making since the last commit.PS: It has a little problem; it also deletes all you recently stored stash changes. Which I guess in most cases should not matter.Revert to  Most Recent commit and ignoring all local changesRevert is the command to rollback the commits.Sample:git revert 2h3h23233It is capable of taking range from the HEAD like below. Here 1 says "revert last commit."git revert HEAD~1..HEADand then do git pushIf the situation is an urgent one, and you just want to do what the questioner asked in a quick and dirty way, assuming your project is under directory "my project":Copy the whole directory and call it something else, like "my project - copy"Do:You then have two versions on your system... you can examine or copy or modify files of interest, or whatever, from the previous commit. You can completely discard the files under "my project - copy", if you have decided the new work was going nowhere...The obvious thing if you want to carry on with the state of the project without actually discarding the work since this retrieved commit is to rename your directory again: Delete the project containing the retrieved commit (or give it a temporary name) and rename your "my project - copy" directory back to "my project". Then probably do another commit fairly soon.Git is a brilliant creation but you can\'t just "pick it up on the fly": also people who try to explain it far too often assume prior knowledge of other VCS [Version Control Systems] and delve far too deep far too soon, and commit other crimes, like using interchangeable terms for "checking out" - in ways which sometimes appear almost calculated to confuse a beginner.  To save yourself much stress you have to pretty much have to read a book on Git - I\'d recommend "Version Control with Git". And if you can trust me (or rather my scars) when I say "have to", it follows that you might as well do it NOW. Much of the complexity of Git comes from branching and then remerging. But from your question there\'s no reason why people should be blinding you with science.  Especially if, for example, this is a desperate situation and you\'re a newbie with Git!PS: One other thought: It is (now) actually quite simple to keep the Git repository ("repo") in a directory other than the one with the working files. This would mean you would not have to copy the entire Git repository using the above quick & dirty solution. See the answer by Fryer using --separate-git-dir here. Be warned, though: If you have a "separate-directory" repository which you don\'t copy, and you do a hard reset, all versions subsequent to the reset commit will be lost forever, unless you have, as you absolutely should, regularly backed up your repository, preferably to the cloud (e.g. Google Drive) among other places.If you want to correct some error in the last commit a good alternative would be using git commit --amend command. If the last commit is not pointed by any reference, this will do the trick, as it create a commit with the same parent as the last commit. If there is no reference to the last commit, it will simply be discarded and this commit will be the last commit. This is a good way of correcting commits without reverting commits. However it has its own limitations. Yet another simplest solution; you have to change branch to do this, but afterwards you can just run:You can complete all these initial steps yourself and push back to git repo.Pull the latest version of your repository from Bitbucket using the\ngit pull --all command. Run the git log command with -n 4  from your terminal. The number after the -n determines the number of commits in the log starting from the most recent commit in your local history.$ git log -n 4Reset the head of your repository\'s history using the git reset --hard HEAD~N where N is the number of commits you want to take the head back. In the following example the head would be set back one\ncommit, to the last commit in the repository history:Push the change to git repo using git push --force to force push\nthe change.If you want git repository to a previous commitTry resetting to the desired commit -git reset COMMIT_IDThis will reset all changed files to un-added state.\nNow you can checkout all un-added files by git checkout .Check git log to verify.I couldn\'t revert mine manually for some reason so here is how I ended up doing it.Choose the number of the HEAD(s) of git reflog, where you want revert to and do (for this example I choose the 12):For rollback (or to revert):Try above two steps, and if you find this is what you want then git push.If you find something wrong do: git revert --abort 