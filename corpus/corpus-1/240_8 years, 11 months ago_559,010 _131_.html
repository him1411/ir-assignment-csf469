In PHP 5, what is the difference between using self and $this?When is each appropriate?Use $this to refer to the current\n  object. Use self to refer to the\n  current class. In other words, use\n  $this->member for non-static members,\n  use self::$member for static members.Here is an example of correct usage of $this and self for non-static and static member variables:Here is an example of incorrect usage of $this and self for non-static and static member variables:Here is an example of polymorphism with $this for member functions:Here is an example of suppressing polymorphic behaviour by using self for member functions:The idea is that $this->foo() calls the foo() member function of whatever >is the exact type of the current object. If the object is of type X, it thus >calls X::foo(). If the object is of type Y, it calls Y::foo(). But with >self::foo(), X::foo() is always called.From http://www.phpbuilder.com/board/showthread.php?t=10354489:By http://board.phpbuilder.com/member.php?145249-laserlightThe keyword self does NOT refer merely to the \'current class\', at least not in a way that restricts you to static members.  Within the context of a non-static member, self also provides a way of bypassing the vtable (see wiki on vtable) for the current object.  Just as you can use parent::methodName() to call the parents version of a function, so you can call self::methodName() to call the current classes implementation of a method.This will output:Hello, I\'m Ludwig the geek\n     Goodbye from Ludwig the personsayHello() uses the $this pointer, so the vtable is invoked to call Geek::getTitle().\nsayGoodbye() uses self::getTitle(), so the vtable is not used, and Person::getTitle() is called.  In both cases, we are dealing with the method of an instantiated object, and have access to the $this pointer within the called functions.DO NOT USE self::, use static::There is another aspect of self:: that is worth mentioning. Annoyingly self:: refers to the scope at the point of definition not at the point of execution. Consider this simple class with two methods:If we call Person::status() we will see "Person is alive" . Now consider what happens when we make a class that inherits from this:Calling Deceased::status() we would expect to see "Person is deceased" however what we see is "Person is alive" as the scope contains the original method definition when call to self::getStatus() was defined.PHP 5.3 has a solution. the static:: resolution operator implements "late static binding" which is a fancy way of saying that its bound to the scope of the class called. Change the line in status() to  static::getStatus() and the results are what you would expect. In older versions of PHP you will have to find a kludge to do this.See PHP DocumentationSo to answer the question not as asked ...$this-> refers to the current object (an instance of a class), whereas static:: refers to a classTo really understand what we\'re talking about when we talk about self versus $this, we need to actually dig into what\'s going on at a conceptual and a practical level. I don\'t really feel any of the answers do this appropriately, so here\'s my attempt.Let\'s start off by talking about what a class and an object is.So, what is a class? A lot of people define it as a blueprint or a template for an object. In fact, you can read more About Classes In PHP Here. And to some extent that\'s what it really is. Let\'s look at a class:As you can tell, there is a property on that class called $name and a method (function) called sayHello(). It\'s very important to note that the class is a static structure. Which means that the class Person, once defined, is always the same everywhere you look at it. An object on the other hand is what\'s called an instance of a Class. What that means is that we take the "blueprint" of the class, and use it to make a dynamic copy. This copy is now specifically tied to the variable it\'s stored in. Therefore, any changes to an instance is local to that instance.We create new instances of a class using the new operator.Therefore, we say that a Class is a global structure, and an Object is a local structure. Don\'t worry about that funny -> syntax, we\'re going to go into that in a little bit. One other thing we should talk about, is that we can check if an instance is an instanceof a particular class: $bob instanceof Person which returns a boolean if the $bob instance was made using the Person class, or a child of Person.So let\'s dig a bit into what a class actually contains. There are 5 types of "things" that a class contains:Properties - Think of these as variables that each instance will contain.Static Properties - Think of these as variables that are shared at the class level. Meaning that they are never copied by each instance.Methods - These are functions which each instance will contain (and operate on instances).Static Methods - These are functions which are shared across the entire class. They do not operate on instances, but instead on the static properties only.Constants - Class resolved constants. Not going any deeper here, but adding for completeness:So basically, we\'re storing information on the class and object container using "hints" about static which identify whether the information is shared (and hence static) or not (and hence dynamic).Inside of a method, an object\'s instance is represented by the $this variable. The current state of that object is there, and mutating (changing) any property will result in a change to that instance (but not others).If a method is called statically, the $this variable is not defined. This is because there\'s no instance associated with a static call.The interesting thing here is how static calls are made. So let\'s talk about how we access the state:So now that we have stored that state, we need to access it. This can get a bit tricky (or way more than a bit), so let\'s split this into two viewpoints: from outside of an instance/class (say from a normal function call, or from the global scope), and inside of an instance/class (from within a method on the object).From the outside of an instance/class, our rules are quite simple and predictable. We have two operators, and each tells us immediately if we\'re dealing with an instance or a class static:-> - object-operator - This is always used when we\'re accessing an instance.It\'s important to note that calling Person->foo does not make sense (since Person is a class, not an instance). Therefore, that is a parse error.:: - scope-resolution-operator - This is always used to access a Class static property or method.Additionally, we can call a static method on an object in the same way:It\'s extremely important to note that when we do this from outside, the object\'s instance is hidden from the bar() method. Meaning that it\'s the exact same as running:Therefore, $this is not defined in the static call.Things change a bit here. The same operators are used, but their meaning becomes significantly blurred. The object-operator -> is still used to make calls to the object\'s instance state.Calling the bar() method on $foo (an instance of Foo) using the object-operator: $foo->bar() will result in the instance\'s version of $a.So that\'s how we expect.The meaning of the :: operator though changes. It depends on the context of the call to the current function:Within a static contextWithin a static context, any calls made using :: will also be static. Let\'s look at an example:Calling Foo::bar() will call the baz() method statically, and hence $this will not be populated. It\'s worth noting that in recent versions of PHP (5.3+) this will trigger an E_STRICT error, because we\'re calling non-static methods statically.Within an instance contextWithin an instance context on the other hand, calls made using :: depend on the receiver of the call (the method we\'re calling). If the method is defined as static, then it will use a static call. If it\'s not, it will forward the instance information.So, looking at the above code, calling $foo->bar() will return true, since the "static" call happens inside of an instance context.Make sense? Didn\'t think so. It\'s confusing.Because tying everything together using class names is rather dirty, PHP provides 3 basic "shortcut" keywords to make scope resolving easier.self - This refers to the current class name. So self::baz() is the same as Foo::baz() within the Foo class (any method on it).parent - This refers to the parent of the current class. static - This refers to the called class. Thanks to inheritance, child classes can override methods and static properties. So calling them using static instead of a class name allows us to resolve where the call came from, rather than the current level. The easiest way to understand this is to start looking at some examples. Let\'s pick a class:Now, we\'re also looking at inheritance here. Ignore for a moment that this is a bad object model, but let\'s look at what happens when we play with this:So the ID counter is shared across both instances and the children (because we\'re using self to access it. If we used static, we could override it in a child class).Note that we\'re executing the Person::getName() instance method every time. But we\'re using the parent::getName() to do it in one of the cases (the child case). This is what makes this approach powerful.Note that the calling context is what determines if an instance is used. Therefore:Is not always true.Now it is really weird here. We\'re calling a different class, but the $this that gets passed to the Foo::isFoo() method is the instance of $bar. This can cause all sorts of bugs and conceptual WTF-ery. So I\'d highly suggest avoiding the :: operator from within instance methods on anything except those three virtual "short-cut" keywords (static, self, and parent).Note that static methods and properties are shared by everyone. That makes them basically global variables. With all the same problems that come with globals. So I would be really hesitant to store information in static methods/properties unless you\'re comfortable with it being truly global.In general you\'ll want to use what\'s known as Late-Static-Binding by using static instead of self. But note that they are not the same thing, so saying "always use static instead of self is really short-sighted. Instead, stop and think about the call you want to make and think if you want child classes to be able to override that static resolved call.Too bad, go back and read it. It may be too long, but it\'s that long because this is a complex topicOk, fine. In short, self is used to reference the current class name within a class, where as $this refers to the current object instance. Note that self is a copy/paste short-cut. You can safely replace it with your class name, and it\'ll work fine. But $this is a dynamic variable that can\'t be determined ahead of time (and may not even be your class).If the object-operator is used (->), then you always know you\'re dealing with an instance. If the scope-resolution-operator is used (::), you need more information about the context (are we in an object-context already? Are we outside of an object? etc).self (not $self) refers to the type of class, where as $this refers to the current instance of the class.  self is for use in static member functions to allow you to access static member variables. $this is used in non-static member functions, and is a reference to the instance of the class on which the member function was called.Because this is an object, you use it like: $this->memberBecause self is not an object, it\'s basically a type that automatically refers to the current class, you use it like: self::member$this-> is used to refer to a specific instance of a class\'s variables (member variables) or methods.$derek is now a specific instance of Person.\nEvery Person has a first_name and a last_name, but $derek has a specific first_name and last_name (Derek Martin). Inside the $derek instance, we can refer to those as $this->first_name and $this->last_nameClassName:: is used to refer to that type of class, and its static variables, static methods. If it helps, you can mentally replace the word "static" with "shared".    Because they are shared, they cannot refer to $this, which refers to a specific instance (not shared). Static Variables (i.e. static $db_connection) can be shared among all instances of a type of object. For example, all database objects share a single connection (static $connection).Static Variables Example:\nPretend we have a database class with a single member variable: static $num_connections;\nNow, put this in the constructor:Just as objects have constructors, they also have destructors, which are executed when the object dies or is unset:Every time we create a new instance, it will increase our connection counter by one. Every time we destroy or stop using an instance, it will decrease the connection counter by one.   In this way, we can monitor the number of instances of the database object we have in use with:Because $num_connections is static (shared), it will reflect the total number of active database objects. You may have seen this technique used to share database connections among all instances of a database class. This is done because creating the database connection takes a long time, so it\'s best to create just one, and share it (this is called a Singleton Pattern).Static Methods (i.e. public static View::format_phone_number($digits)) can be used WITHOUT first instantiating one of those objects (i.e. They do not internally refer to $this).Static Method Example:As you can see, public static function prettyName knows nothing about the object. It\'s just working with the parameters you pass in, like a normal function that\'s not part of an object. Why bother, then, if we could just have it not as part of the object?SELF::\nIf you are coding outside the object that has the static method you want to refer to, you must call it using the object\'s name View::format_phone_number($phone_number);\nIf you are coding inside the object that has the static method you want to refer to, you can either use the object\'s name View::format_phone_number($pn), OR you can use the self::format_phone_number($pn)  shortcutThe same goes for static variables:\nExample: View::templates_path versus self::templates_pathInside the DB class, if we were referring to a static method of some other object, we would use the object\'s name:\nExample: Session::getUsersOnline();But if the DB class wanted to refer to its own static variable, it would just say self:\nExample: self::connection;Hope that helps clear things up :)From this blog post:Inside a class definition, $this refers to the current object, while self refers to the current class.It is necessary to refer to a class element using self, and refer to an object element using $this.In PHP, you use the self keyword to access static properties and methods.The problem is that you can replace $this->method() with self::method()anywhere, regardless if method() is declared static or not. So which one should you use?Consider this code:In this example, self::who() will always output \xe2\x80\x98parent\xe2\x80\x99, while $this->who() will depend on what class the object has.Now we can see that self refers to the class in which it is called, while $this refers to the class of the current object.So, you should use self only when $this is not available, or when you don\xe2\x80\x99t want to allow descendant classes to overwrite the current method.Here is an example of correct usage of $this and self for non-static\n  and static member variables:According to http://www.php.net/manual/en/language.oop5.static.php there is no $self. There is only $this, for referring to the current instance of the class (the object), and self, which can be used to refer to static members of a class. The difference between an object instance and a class comes into play here.I believe question was not whether you can call the static member of the class by calling ClassName::staticMember. Question was what\'s the difference between using self::classmember and $this->classmember.For e.g., both of the following examples work without any errors, whether you use self:: or $this->self refers current class(in which it is called),$this refers current object.\nYou can use static instead of self.\nSee the example:        Output:\n      parent\n     childSee the following example which shows overloading.Most of the time you want to refer to the current class which is why you use static or $this. However, there are times when you need self because you want the original class regardless of what extends it. (Very, Very seldom)When self is used with the :: operator it refers to the current class, which can be done both in static and non-static contexts. $this refers to the object itself. In addition, it is perfectly legal to use $this to call static methods (but not to refer to fields).As no one here talked about performances, here is a small benchmark I did (5.6):Those are the results for 2 000 000 runs, and here is the code I used:$this refers to the current class object, self refers to the current class (Not object). The class is the blueprint of the object. So you define a class, but you construct objects.So in other words, use self for static and this for none-static members or methods.also in child/parent scenario self / parent is mostly used to identified child and parent class members and methods.Additionally since $this:: has not been discussed yet.For informational purposes only, as of PHP 5.3 when dealing with instantiated objects to get the current scope value, as opposed to using static::, one can alternatively use $this:: like so.http://ideone.com/7etRHyUsing the code above is not common or recommended practice, but is simply to illustrate its usage, and is to act as more of a "Did you know?" in reference to the original poster\'s question.It also represents the usage of $object::CONSTANT for example echo $foo::NAME; as opposed to $this::NAME;Use \'self\' if you want to call a method of a class without creating an object/instance of that class, thus saving RAM (sometimes use self for that purpose). In other words, it is actually calling a method statically. Use \'this\' for object perspective.Case 1: Use self can be used for class constantsIf you want to call it outside of the class, use classA::POUNDS_TO_KILOGRAMS to access the constantsCase 2: For static properties According to php.net there are three special keywords in this context: self, parent and static. They are used to access properties or methods from inside the class definition.$this, on the other hand, is used to call an instance and methods of any class as long as that class is accessible.