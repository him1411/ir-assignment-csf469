When using lambda expressions or anonymous methods in C#, we have to be wary of the access to modified closure pitfall. For example:Due to the modified closure, the above code will cause all of the Where clauses on the query to be based on the final value of s.As explained here, this happens because the s variable declared in foreach loop above is translated like this in the compiler:instead of like this:As pointed out here, there are no performance advantages to declaring a variable outside the loop, and under normal circumstances the only reason I can think of for doing this is if you plan to use the variable outside the scope of the loop:However variables defined in a foreach loop cannot be used outside the loop:So the compiler declares the variable in a way that makes it highly prone to an error that is often difficult to find and debug, while producing no perceivable benefits.Is there something you can do with foreach loops this way that you couldn\'t if they were compiled with an inner-scoped variable, or is this just an arbitrary choice that was made before anonymous methods and lambda expressions were available or common, and which hasn\'t been revised since then?The compiler declares the variable in a way that makes it highly prone to an error that is often difficult to find and debug, while producing no perceivable benefits.Your criticism is entirely justified.I discuss this problem in detail here:Closing over the loop variable considered harmfulIs there something you can do with foreach loops this way that you couldn\'t if they were compiled with an inner-scoped variable? or is this just an arbitrary choice that was made before anonymous methods and lambda expressions were available or common, and which hasn\'t been revised since then?The latter. The C# 1.0 specification actually did not say whether the loop variable was inside or outside the loop body, as it made no observable difference. When closure semantics were introduced in C# 2.0, the choice was made to put the loop variable outside the loop, consistent with the "for" loop.I think it is fair to say that all regret that decision. This is one of the worst "gotchas" in C#, and we are going to take the breaking change to fix it. In C# 5 the foreach loop variable will be logically inside the body of the loop, and therefore closures will get a fresh copy every time.The for loop will not be changed, and the change will not be "back ported" to previous versions of C#. You should therefore continue to be careful when using this idiom.What you are asking is thoroughly covered by Eric Lippert in his blog post Closing over the loop variable considered harmful and its sequel. For me, the most convincing argument is that having new variable in each iteration would be inconsistent with for(;;) style loop. Would you expect to have a new int i in each iteration of for (int i = 0; i < 10; i++)?The most common problem with this behavior is making a closure over iteration variable and it has an easy workaround:My blog post about this issue: Closure over foreach variable in C#.Having been bitten by this, I have a habit of including locally defined variables in the innermost scope which I use to transfer to any closure. In your example:I do:Once you have that habit, you can avoid it in the very rare case you actually intended to bind to the outer scopes. To be honest, I don\'t think I have ever done so.In C# 5.0, this problem is fixed and you can close over loop variables and get the results you expect.The language specification says:(...)A foreach statement of the formis then expanded to:(...)The placement of v inside the while loop is important for how it is\n  captured by any anonymous function occurring in the\n  embedded-statement. For example:If v was declared outside of the while loop, it would be shared\n  among all iterations, and its value after the for loop would be the\n  final value, 13, which is what the invocation of f would print.\n  Instead, because each iteration has its own variable v, the one\n  captured by f in the first iteration will continue to hold the value\n  7, which is what will be printed. (Note: earlier versions of C#\n  declared v outside of the while loop.)