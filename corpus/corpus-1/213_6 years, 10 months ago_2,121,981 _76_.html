In PHP, strings are concatenated together as follows:Here, $foo becomes "Hello World".How is this accomplished in Bash?In general to concatenate two variables you can just write them one after another:Bash also supports a += operator as shown in the following transcript:As this question stand specifically for Bash, my first part of the answer would present different ways of doing this properly:The syntax += may be used in different ways:(Because I am frugal, I will only use two variables foo and a and then re-use the same in the whole answer. ;-)Using the Stack Overflow question syntax,works fine!variable a is a string, but also an integerOur a is also an array of only one element.Note that between parentheses, there is a space separated array. If you want to store a string containing spaces in your array, you have to enclose them:Hmm.. this is not a bug, but a feature... To prevent bash to try to develop !", you could:The printf builtin command gives a powerful way of drawing string format. As this is a Bash builtin, there is a option for sending formated string to a variable instead of printing on stdout:There are seven strings in this array. So we could build a formated string containing exactly seven positional arguments:Or we could use one argument format string wich will be repeated as many argument submited...Note that our a is still an array! Only first element is changed!Under bash, when you access a variable name without specifying index, you always address first element only!So to retrieve our seven field array, we only need to re-set 1st element:One argument format string with many argument passed to:Nota: The use of double-quotes may be useful for manipulating strings that contain spaces, tabulations and/or newlinesUnder POSIX shell, you could not use bashisms, so there is no builtin printf.But you could simply do:If you want to use more sophisticated constructions you have to use a fork (new child process that make the job and return the result via stdout):Historically, you could use backticks for retrieving result of a fork:But this is not easy for nesting:with backticks, you have to escape inner forks with backslashes:You can do this too:Will outputThis is useful when \n    $blaohai\nleads to a variable not found error.     The way I\'d solve the problem is justFor example,which producesIf you try to concatenate a string with another string, for example,then echo "$c" will producewith an extra space.doesn\'t work, as you may imagine, butproducesYet another approach......and yet yet another one.If you want to append something like an underscore, use escape (\\)This does not work:                      This works fine:                           You can concatenate without the quotes. Here is an example:This last statement would print "OpenSystems" (without quotes).This is an example of a Bash script:Even if the += operator is now permitted, it has been introduced in Bash 3.1 in 2004.Any script using this operator on older Bash versions will fail with a "command not found" error if you are lucky, or a "syntax error near unexpected token".For those who cares about backward compatibility, stick with the older standard Bash concatenation methods, like those mentioned in the chosen answer:I prefer to use curly brackets ${} for expanding variable in string:Curly brackets will fit to Continuous string usage:Otherwise using foo = "$fooWorld" will not work.Safer way:Strings containing spaces can become part of command, use "$XXX" and "${XXX}" to avoid these errors.Plus take a look at other answer about +=There\'s one particular case where you should take care:Will output "daniel"san, and not danielsan, as you might have wanted.\nIn this case you should do instead:If what you are trying to do is to split a string into several lines, you can use a backslash:With one space in between:This one also adds only one space in between:If it is as your example of adding " World" to the original string, then it can be:The output:Simplest way with quotation marks:Note that this won\'t workas it seems to drop $foo and leaves you with: PREFIX_WORLDbut this will work:and leave you with the correct output: PREFIX_HELLO_WORLDI do it this way when convenient: Use an inline command!Here is the one through AWK:I kind of like making a quick function.Yet another way to skin a cat. This time with functions :DYou can try the below way. When substitution takes place, double quotes will keep the spaces.