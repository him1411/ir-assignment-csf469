I had an interesting job interview experience a while back. The question started really easy:Q1: We have a bag containing numbers 1, 2, 3, \xe2\x80\xa6, 100. Each number appears exactly once, so there are 100 numbers. Now one number is randomly picked out of the bag. Find the missing number.I\'ve heard this interview question before, of course, so I very quickly answered along the lines of:A1: Well, the sum of the numbers 1 + 2 + 3 + \xe2\x80\xa6 + N is (N+1)(N/2) (see Wikipedia: sum of arithmetic series). For N = 100, the sum is 5050.Thus, if all numbers are present in the bag, the sum will be exactly 5050. Since one number is missing, the sum will be less than this, and the difference is that number. So we can find that missing number in O(N) time and O(1) space.At this point I thought I had done well, but all of a sudden the question took an unexpected turn:Q2: That is correct, but now how would you do this if TWO numbers are missing?I had never seen/heard/considered this variation before, so I panicked and couldn\'t answer the question. The interviewer insisted on knowing my thought process, so I mentioned that perhaps we can get more information by comparing against the expected product, or perhaps doing a second pass after having gathered some information from the first pass, etc, but I really was just shooting in the dark rather than actually having a clear path to the solution.The interviewer did try to encourage me by saying that having a second equation is indeed one way to solve the problem. At this point I was kind of upset (for not knowing the answer before hand), and asked if this is a general (read: "useful") programming technique, or if it\'s just a trick/gotcha answer.The interviewer\'s answer surprised me: you can generalize the technique to find 3 missing numbers. In fact, you can generalize it to find k missing numbers.Qk: If exactly k numbers are missing from the bag, how would you find it efficiently?This was a few months ago, and I still couldn\'t figure out what this technique is.  Obviously there\'s a \xce\xa9(N) time lower bound since we must scan all the numbers at least once, but the interviewer insisted that the TIME and SPACE complexity of the solving technique (minus the O(N) time input scan) is defined in k not N.So the question here is simple:So again, of course you must scan the input in O(N), but you can only capture small amount of information (defined in terms of k not N), and must then find the k missing numbers somehow.Here\'s a summary of Dimitris Andreou\'s link.Remember sum of i-th powers, where i=1,2,..,k. This reduces the problem to solving the system of equationsa1 + a2 + ... + ak = b1a12 + a22 + ... + ak2 = b2...a1k + a2k + ... + akk = bkUsing Newton\'s identities, knowing bi allows to computec1 = a1 + a2 + ... akc2 = a1a2 + a1a3 + ... + ak-1ak...ck = a1a2 ... akIf you expand the polynomial (x-a1)...(x-ak) the coefficients will be exactly c1, ..., ck - see Vi\xc3\xa8te\'s formulas. Since every polynomial factors uniquely (ring of polynomials is an Euclidean domain), this means ai are uniquely determined, up to permutation.This ends a proof that remembering powers is enough to recover the numbers. For constant k, this is a good approach.However, when k is varying, the direct approach of computing c1,...,ck is prohibitely expensive, since e.g. ck is the product of all missing numbers, magnitude n!/(n-k)!. To overcome this, perform computations in Zq field, where q is a prime such that n <= q < 2n - it exists by Bertrand\'s postulate. The proof doesn\'t need to be changed, since the formulas still hold, and factorization of polynomials is still unique. You also need an algorithm for factorization over finite fields, for example the one by Berlekamp or Cantor-Zassenhaus.High level pseudocode for constant k:For varying k, find a prime n <= q < 2n using e.g. Miller-Rabin, and perform the steps with all numbers reduced modulo q.As Heinrich Apfelmus commented, instead of a prime q you can use q=2\xe2\x8c\x88log n\xe2\x8c\x89 and perform arithmetic in finite field.You will find it by reading the couple of pages of Muthukrishnan - Data Stream Algorithms: Puzzle 1: Finding Missing Numbers. It shows exactly the generalization you are looking for. Probably this is what your interviewer read and why he posed these questions.Now, if only people would start deleting the answers that are subsumed or superseded by Muthukrishnan\'s treatment, and make this text easier to find. :) Also see sdcvvc\'s directly related answer, which also includes pseudocode (hurray! no need to read those tricky math formulations :)) (thanks, great work!). We can solve Q2 by summing both the numbers themselves, and the squares of the numbers.We can then reduce the problem toWhere x and y are how far the sums are below the expected values.Substituting gives us:Which we can then solve to determine our missing numbers.As @j_random_hacker pointed out, this is quite similar to Finding duplicates in O(n) time and O(1) space, and an adaptation of my answer there works here too.Assuming that the "bag" is represented by a 1-based array A[] of size N - k, we can solve Qk in O(N) time and O(k) additional space.First, we extend our array A[] by k elements, so that it is now of size N.  This is the O(k) additional space.  We then run the following pseudo-code algorithm:The first loop initialises the k extra entries to the same as the first entry in the array (this is just a convenient value that we know is already present in the array - after this step, any entries that were missing in the initial array of size N-k are still missing in the extended array).The second loop permutes the extended array so that if element x is present at least once, then one of those entries will be at position A[x].Note that although it has a nested loop, it still runs in O(N) time - a swap only occurs if there is an i such that A[i] != i, and each swap sets at least one element such that A[i] == i, where that wasn\'t true before.  This means that the total number of swaps (and thus the total number of executions of the while loop body) is at most N-1.The third loop prints those indexes of the array i that are not occupied by the value i - this means that i must have been missing.I asked a 4-year-old to solve this problem. He sorted the numbers and then counted along. This has a space requirement of O(kitchen floor), and it works just as easy however many balls are missing.I haven\'t checked the maths, but I suspect that computing \xce\xa3(n^2) in the same pass as we compute \xce\xa3(n) would provide enough info to get two missing numbers, Do \xce\xa3(n^3) as well if there are three, and so on.Not sure, if it\'s the most efficient solution, but I would loop over all entries, and use a bitset to remember, which numbers are set, and then test for 0 bits.I like simple solutions - and I even believe, that it might be faster than calculating the sum, or the sum of squares etc.The problem with solutions based on sums of numbers is they don\'t take into account the cost of storing and working with numbers with large exponents... in practice, for it to work for very large n, a big numbers library would be used. We can analyse the space utilisation for these algorithms.We can analyse the time and space complexity of sdcvvc and Dimitris Andreou\'s algorithms.Storage:So l_j \\in \\Theta(j log n)Total storage used: \\sum_{j=1}^k l_j \\in \\Theta(k^2 log n)Space used: assuming that computing a^j takes ceil(log_2 j) time, total time:Total time used: \\Theta(kn log n)If this time and space is satisfactory, you can use a simple recursive\nalgorithm. Let b!i be the ith entry in the bag, n the number of numbers before\nremovals, and k the number of removals. In Haskell syntax...Storage used: O(k) for list, O(log(n)) for stack: O(k + log(n))\nThis algorithm is more intuitive, has the same time complexity, and uses less space.Wait a minute.  As the question is stated, there are 100 numbers in the bag.  No matter how big k is, the problem can be solved in constant time because you can use a set and remove numbers from the set in at most 100 - k iterations of a loop.  100 is constant.  The set of remaining numbers is your answer.If we generalise the solution to the numbers from 1 to N, nothing changes except N is not a constant, so we are in O(N - k) = O(N) time.  For instance, if we use a bit set, we set the bits to 1 in O(N) time, iterate through the numbers, setting the bits to 0 as we go (O(N-k) = O(N)) and then we have the answer.It seems to me that the interviewer was asking you how to print out the contents of the final set in O(k) time rather than O(N) time.  Clearly, with a bit set, you have to iterate through all N bits to determine whether you should print the number or not.  However, if you change the way the set is implemented you can print out the numbers in k iterations.  This is done by putting the numbers into an object to be stored in both a hash set and a doubly linked list.  When you remove an object from the hash set, you also remove it from the list.  The answers will be left in the list which is now of length k.Here\'s a solution that uses k bits of extra storage, without any clever tricks and just straightforward. Execution time O (n), extra space O (k). Just to prove that this can be solved without reading up on the solution first or being a genius:  Can you check if every number exists? If yes you may try this:S = sum of all numbers in the bag (S < 5050)\n  Z = sum of the missing numbers 5050 - Sif the missing numbers are x and y then:x = Z - y and\n  max(x) = Z - 1So you check the range from 1 to max(x) and find the numberTo solve the 2 (and 3) missing numbers question, you can modify quickselect, which on average runs in O(n) and uses constant memory if partitioning is done in-place.Partition the set with respect to a random pivot p into partitions l, which  contain numbers smaller than the pivot, and r, which contain numbers greater than the pivot.Determine which partitions the 2 missing numbers are in by comparing the pivot value to the size of each partition (p - 1 - count(l) = count of missing numbers in l and \nn - count(r) - p = count of missing numbers in r)a) If each partition is missing one number, then use the difference of sums approach to find each missing number.(1 + 2 + ... + (p-1)) - sum(l) = missing #1 and \n  ((p+1) + (p+2) ... + n) - sum(r) = missing #2b) If one partition is missing both numbers and the partition is empty, then the missing numbers are either (p-1,p-2) or (p+1,p+2)\n  depending on which partition is missing the numbers.If one partition is missing 2 numbers but is not empty, then recurse onto that partiton.With only 2 missing numbers, this algorithm always discards at least one partition, so it retains O(n) average time complexity of quickselect. Similarly, with 3 missing numbers this algorithm also discards at least one partition with each pass (because as with 2 missing numbers, at most only 1 partition will contain multiple missing numbers). However, I\'m not sure how much the performance decreases when more missing numbers are added.Here\'s an implementation that does not use in-place partitioning, so this example does not meet the space requirement but it does illustrate the steps of the algorithm:DemoYou can solve Q2 if you have the sum of both lists and the product of both lists.(l1 is the original, l2 is the modified list)We can optimise this since the sum of an arithmetic series is n times the average of the first and last terms:Now we know that (if a and b are the removed numbers):So we can rearrange to:And multiply out:And rearrange so the right side is zero:Then we can solve with the quadratic formula:Sample Python 3 code:I do not know the complexity of the sqrt, reduce and sum functions so I cannot work out the complexity of this solution (if anyone does know please comment below.)I think this can be done without any complex mathematical equations and theories. Below is a proposal for an in place and O(2n) time complexity solution:Input form assumptions : # of numbers in bag = n# of missing numbers = kThe numbers in the bag are represented by an array of length nLength of input array for the algo = nMissing entries in the array (numbers taken out of the bag) are replaced by the value of the first element in the array.Eg. Initially bag looks like [2,9,3,7,8,6,4,5,1,10].\nIf 4 is taken out, value of 4 will become 2 (the first element of the array). \nTherefore after taking 4 out the bag will look like [2,9,3,7,8,6,2,5,1,10]The key to this solution is to tag the INDEX of a visited number by negating the value at that INDEX as the array is traversed. This might sound stupid, but, in the first problem presented to you, you would have to see all the remaining numbers in the bag to actually add them up to find the missing number using that equation.So, since you get to see all the numbers, just look for the number that\'s missing. The same goes for when two numbers are missing. Pretty simple I think. No point in using an equation when you get to see the numbers remaining in the bag.May be this algorithm can work for question 1:Or even better:This algorithm can in fact be expanded for two missing numbers. The first step remains the same. When we call GetValue with two missing numbers the result will be a a1^a2 are the two missing numbers. Lets sayval = a1^a2Now to sieve out a1 and a2 from val we take any set bit in val. Lets say the ith bit is set in val. That means that a1 and a2 have different parity at ith bit position. \nNow we do another iteration on the original array and keep two xor values. One for the numbers which have the ith bit set and other which doesn\'t have the ith bit set. We now have two buckets of numbers, and its guranteed that a1 and a2 will lie in different buckets. Now repeat the same what we did for finding one missing element on each of the bucket. Very nice problem. I\'d go for using a set difference for Qk. A lot of programming languages even have support for it, like in Ruby:It\'s probably not the most efficient solution but it\'s one I would use in real life if I was faced with such a task in this case (known boundaries, low boundaries). If the set of number would be very large then I would consider a more efficient algorithm, of course, but until then the simple solution would be enough for me.You could try using a Bloom Filter.  Insert each number in the bag into the bloom, then iterate over the complete 1-k set until reporting each one not found.  This may not find the answer in all scenarios, but might be a good enough solution.I\'d take a different approach to that question and probe the interviewer for more details about the larger problem he\'s trying to solve.  Depending on the problem and the requirements surrounding it, the obvious set-based solution might be the right thing and the generate-a-list-and-pick-through-it-afterward approach might not.For example, it might be that the interviewer is going to dispatch n messages and needs to know the k that didn\'t result in a reply and needs to know it in as little wall clock time as possible after the n-kth reply arrives.  Let\'s also say that the message channel\'s nature is such that even running at full bore, there\'s enough time to do some processing between messages without having any impact on how long it takes to produce the end result after the last reply arrives.  That time can be put to use inserting some identifying facet of each sent message into a set and deleting it as each corresponding reply arrives.  Once the last reply has arrived, the only thing to be done is to remove its identifier from the set, which in typical implementations takes O(log k+1).  After that, the set contains the list of k missing elements and there\'s no additional processing to be done.This certainly isn\'t the fastest approach for batch processing pre-generated bags of numbers because the whole thing runs O((log 1 + log 2 + ... + log n) + (log n + log n-1 + ... + log k)).  But it does work for any value of k (even if it\'s not known ahead of time) and in the example above it was applied in a way that minimizes the most critical interval.I don\'t know whether this is efficient or not but I would like to suggest this solution.Now run a loop to get the possible pairs (p,q) both of which lies in [1 , 100] and sum to d.When a pair is obtained check whether (result of 3) XOR  p = q\nand if yes we are done.Please correct me if I am wrong and also comment on time complexity if this is correctA very simple way to do it in roughly O(N) time is to remove each element when seen in both lists. This works for unsorted lists too and can be easily further optimized if the lists are both sorted.There is a general way to generalize streaming algorithms like this.\nThe idea is to use a bit of randomization to hopefully \'spread\' the k elements into independent sub problems, where our original algorithm solves the problem for us. This technique is used in sparse signal reconstruction, among other things.If all of the missing  numbers have been hashed to different buckets, the non-zero elements of the array will now contain the missing numbers.The probability that a particular pair is sent to the same bucket, is less than 1/u by definition of a universal hash function. Since there are about k^2/2 pairs, we have that the error probability is at most k^2/2/u=1/2. That is, we succeed with probability at least 50%, and if we increase u we increase our chances.Notice that this algorithm takes k^2 logn bits of space (We need logn bits per array bucket.) This matches the space bound from @Dimitris Andreou\'s answers, which happens to also be randomized.\nThis algorithm also has constant time per update, rather than time k in the case of power-sums.I\'d be surprised if there is a more efficient algorithm than the above. In theory (the space bound) as well as in practice (the actual running time).For Q2 this is a solution that is a bit more inefficient than the others, but still has O(N) runtime and takes O(k) space.The idea is to run the original algorithm two times. In the first one you get a total number which is missing, which gives you an upper bound of the missing numbers. Let\'s call this number N. You know that the missing two numbers are going to sum up to N, so the first number can only be in the interval [1, floor((N-1)/2)] while the second is going to be in [floor(N/2)+1,N-1].Thus you loop on all numbers once again, discarding all numbers that are not included in the first interval. The ones that are, you keep track of their sum. Finally, you\'ll know one of the missing two numbers, and by extension the second.I have a feeling that this method could be generalized and maybe multiple searches run in "parallel" during a single pass over the input, but I haven\'t yet figured out how.You\'d probably need clarification on what O(k) means.Here\'s a trivial solution for arbitrary k: for each v in your set of numbers, accumulate the sum of 2^v. At the end, loop i from 1 to N. If sum modulo 2^i is zero, then i is missing.Easy, right? O(N) time, O(1) storage, and it supports arbitrary k.Except that you\'re computing enormous numbers that on a real computer would each require O(N) space. In fact, this solution is identical to a bit vector.So you could be clever and compute the sum and the sum of squares and the sum of cubes... up to the sum of v^k, and do the fancy math to extract the result. But those are big numbers too, which begs the question: what abstract model of operation are we talking about? How much fits in O(1) space, and how long does it take to sum up numbers of whatever size you need?I have an idea, but this is assuming that the actual size of the array is 100 and the missing numbers are replaced with something else (like -1).Basically, do a sort that\'s kind of a modified version of a selection sort that swaps the list in-place. I believe this is O(n) time (correct me if I\'m wrong though) because we make use of the fact we already know the numbers that should exist. We swap the value with the "correct" position, until the index we are at has the correct number (or has -1).After we\'re done with that, we just loop the list again and the index will basically be the missing numbersI believe I have a O(k) time and O(log(k)) space algorithm, given that you have the floor(x) and log2(x) functions for arbitrarily big integers available:You have an k-bit long integer (hence the log8(k) space) where you add the x^2, where x is the next number you find in the bag: s=1^2+2^2+... This takes O(N) time (which is not a problem for the interviewer). At the end you get j=floor(log2(s)) which is the biggest number you\'re looking for. Then s=s-j and you do again the above:Now, you usually don\'t have floor and log2 functions for 2756-bit integers but instead for doubles. So? Simply, for each 2 bytes (or 1, or 3, or 4) you can use these functions to get the desired numbers, but this adds an O(N) factor to time complexityTry to find the product of numbers from 1 to 50:Let product, P1 = 1 x 2 x 3 x ............. 50 When you take out numbers one by one, multiply them so that you get the product P2. But two numbers are missing here, hence P2 < P1.The product of the two mising terms, a x b = P1 - P2.You already know the sum, a + b = S1.From the above two equations, solve for a and b through a quadratic equation. a and b are your missing numbers.I think this can be generalized like this:Denote S, M as the initial values for the sum of arithmetic series and multiplication.I should think about a formula to calculate this, but that is not the point. Anyway, if one number is missing, you already provided the solution. However, if two numbers are missing then, let\'s denote the new sum and total multiple by S1 and M1, which will be as follows:Since you know S1, M1, M and S, the above equation is solvable to find a and b, the missing numbers.Now for the three numbers missing:Now your unknown is 3 while you just have two equations you can solve from.The  key is to use indexes to mark if a number is present or not in the range.\nHere we know that  we have 1 to N. \nTime complexity O(n) \nSpace complexity O(1)Followup questions:\nThis may be modified to find if an element is missing from an AP of difference d. Other variation may include find first missing +ve number from any random array containing -ve number as well. Then first partition around 0 quick sort, then do this procedure on right side of partition part of the array, do necessary modification.  After this we need to iterate over array, and check if a[i]!=-1, then i+1 is the missing number. We have to be careful when a[i]>N.You can motivate the solution by thinking about it in terms of symmetries (groups, in math language). No matter the order of the set of numbers, the answer should be the same. If you\'re going to use k functions to help determine the missing elements, you should be thinking about what functions have that property: symmetric. The function s_1(x) = x_1 + x_2 + ... + x_n is an example of a symmetric function, but there are others of higher degree. In particular, consider the elementary symmetric functions. The elementary symmetric function of degree 2 is s_2(x) = x_1 x_2 + x_1 x_3 + ... + x_1 x_n + x_2 x_3 + ... + x_(n-1) x_n, the sum of all products of two elements. Similarly for the elementary symmetric functions of degree 3 and higher. They are obviously symmetric. Furthermore, it turns out they are the building blocks for all symmetric functions.You can build the elementary symmetric functions as you go by noting that s_2(x,x_(n+1)) = s_2(x) + s_1(x)(x_(n+1)). Further thought should convince you that s_3(x,x_(n+1)) = s_3(x) + s_2(x)(x_(n+1)) and so on, so they can be computed in one pass.How do we tell which items were missing from the array? Think about the polynomial (z-x_1)(z-x_2)...(z-x_n). It evaluates to 0 if you put in any of the numbers x_i. Expanding the polynomial, you get z^n-s_1(x)z^(n-1)+ ... + (-1)^n s_n. The elementary symmetric functions appear here too, which is really no surprise, since the polynomial should stay the same if we apply any permutation to the roots.So we can build the polynomial and try to factor it to figure out which numbers are not in the set, as others have mentioned.Finally, if we are concerned about overflowing memory with large numbers (the nth symmetric polynomial will be of the order 100!), we can do these calculations mod p where p is a prime bigger than 100. In that case we evaluate the polynomial mod p and find that it again evaluates to 0 when the input is a number in the set, and it evaluates to a non-zero value when the input is a number not in the set. However, as others have pointed out, to get the values out of the polynomial in time that depends on k, not N, we have to factor the polynomial mod p.