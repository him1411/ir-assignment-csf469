Due to the implementation of Java generics, you can\'t have code like this: How can I implement this while maintaining type safety?I saw a solution on the Java forums that goes like this:But I really don\'t get what\'s going on.I have to ask a question in return: is your GenSet "checked" or "unchecked"?\nWhat does that mean?Checked: strong typing. GenSet knows explicitly what type of objects it contains (i.e. its constructor was explicitly called with a Class<E> argument, and methods will throw an exception when they are passed arguments that are not of type E. See Collections.checkedCollection.-> in that case, you should write:Unchecked: weak typing. No type checking is actually done on any of the objects passed as argument.-> in that case, you should writeNote that the component type of the array should be the erasure of the type parameter:All of this results from a known, and deliberate, weakness of generics in Java: it was implemented using erasure, so "generic" classes don\'t know what type argument they were created with at run time, and therefore can not provide type-safety unless some explicit mechanism (type-checking) is implemented.You can always do this:This is one of the suggested ways of implementing a generic collection in Effective Java; Item 26.  No type errors, no need to cast the array repeatedly.  However this triggers a warning because it is potentially dangerous, and should be used with caution.  As detailed in the comments, this Object[] is now masquerading as our E[] type, and can cause unexpected errors or ClassCastExceptions if used unsafely.As a rule of thumb, this behavior is safe as long as the cast array is used internally (e.g. to back a data structure), and not returned or exposed to client code.  Should you need to return an array of a generic type to other code, the reflection Array class you mention is the right way to go.Worth mentioning that wherever possible, you\'ll have a much happier time working with Lists rather than arrays if you\'re using generics.  Certainly sometimes you don\'t have a choice, but using the collections framework is far more robust.Here\'s how to use generics to get an array of precisely the type you\xe2\x80\x99re looking for while preserving type safety (as opposed to the other answers, which will either give you back an Object array or result in warnings at compile time):That compiles without warnings, and as you can see in main, for whatever type you declare an instance of GenSet as, you can assign a to an array of that type, and you can assign an element from a to a variable of that type, meaning that the array and the values in the array are of the correct type.It works by using class literals as runtime type tokens, as discussed in the Java Tutorials. Class literals are treated by the compiler as instances of java.lang.Class. To use one, simply follow the name of a class with .class. So, String.class acts as a Class object representing the class String. This also works for interfaces, enums, any-dimensional arrays (e.g. String[].class), primitives (e.g. int.class), and the keyword void (i.e. void.class). Class itself is generic (declared as Class<T>, where T stands for the type that the Class object is representing), meaning that the type of String.class is Class<String>.So, whenever you call the constructor for GenSet, you pass in a class literal for the first argument representing an array of the GenSet instance\'s declared type (e.g. String[].class for GenSet<String>). Note that you won\'t be able to get an array of primitives, since primitives can\'t be used for type variables.Inside the constructor, calling the method cast returns the passed Object argument cast to the class represented by the Class object on which the method was called. Calling the static method newInstance in java.lang.reflect.Array returns as an Object an array of the type represented by the Class object passed as the first argument and of the length specified by the int passed as the second argument. Calling the method getComponentType returns a Class object representing the component type of the array represented by the Class object on which the method was called (e.g. String.class for String[].class, null if the Class object doesn\'t represent an array).That last sentence isn\'t entirely accurate. Calling String[].class.getComponentType() returns a Class object representing the class String, but its type is Class<?>, not Class<String>, which is why you can\'t do something like the following.Same goes for every method in Class that returns a Class object.Regarding Joachim Sauer\'s comment on this answer (I don\'t have enough reputation to comment on it myself), the example using the cast to T[] will result in a warning because the compiler can\'t guarantee type safety in that case.Edit regarding Ingo\'s comments:This is the only answer that is type safeTo extend to more dimensions, just add []\'s and dimension parameters to newInstance() (T is a type parameter, cls is a Class<T>, d1 through d5 are integers):See Array.newInstance() for details.This is covered in Chapter 5 (Generics) of Effective Java, 2nd Edition, item 25...Prefer lists to arraysYour code will work, although it will generate an unchecked warning (which you could suppress with the following annotation:However, it would probably be better to use a List instead of an Array.There\'s an interesting discussion of this bug/feature on the OpenJDK project site.Java generics work by checking types at compile time and inserting appropriate casts, but erasing the types in the compiled files. This makes generic libraries usable by code which doesn\'t understand generics (which was a deliberate design decision) but which means you can\'t normally find out what the type is at run time.The public Stack(Class<T> clazz,int capacity) constructor requires you to pass a Class object at run time, which means class information is available at runtime to code that needs it. And the Class<T> form means that the compiler will check that the Class object you pass is precisely the Class object for type T. Not a subclass of T, not a superclass of T, but precisely T.This then means that you can create an array object of the appropriate type in your constructor, which means that the type of the objects you store in your collection will have their types checked at the point they are added to the collection.Hi although the thread is dead, I would like to draw your attention to this:Generics is used for type checking during compile time:Do don\'t worry about typecasting warnings when you are writing generic class. Worry when you are using it.In Java 8, we can do a kind of generic array creation using a lambda or method reference. This is similar to the reflective approach (which passes a Class), but here we aren\'t using reflection.For example, this is used by <A> A[] Stream.toArray(IntFunction<A[]>).This could also be done pre-Java 8 using anonymous classes but it\'s more cumbersome.The example is using Java reflection to create an array. Doing this is generally not recommended, since it isn\'t typesafe. Instead, what you should do is just use an internal List, and avoid the array at all.I made this code snippet to reflectively instantiate a class which is passed for a simple automated test utility.Note this segment:for array initiating where Array.newInstance(class of array, size of array). Class can be both primitive (int.class) and object (Integer.class).BeanUtils is part of Spring.Look also to this code:It converts a list of any kind of object to an array of the same type.What about this solution?It works and looks too simple to be true. Is there any drawback?I have found a quick and easy way that works for me. Note that i have only used this on Java JDK 8. I don\'t know if it will work with previous versions.Although we cannot instantiate a generic array of a specific type parameter, we can pass an already created array to a generic class constructor.Now in main we can create the array like so:For more flexibility with your arrays you can use a linked list eg. the ArrayList and other methods found in the Java.util.ArrayList class.The forced cast suggested by other people did not work for me, throwing an exception of illegal casting.However, this implicit cast worked fine:where Item is a class I defined containing the member:This way you get an array of type K (if the item only has the value) or any generic type you want defined in the class Item.No one else has answered the question of what is going on in the example you posted.As others have said generics are "erased" during compilation. So at runtime an instance of a generic doesn\'t know what its component type is. The reason for this is historical, Sun wanted to add generics without breaking the existing interface (both source and binary).Arrays on the other hand do know their component type at runtime.This example works around the problem by having the code that calls the constructor (which does know the type) pass a parameter telling the class the required type.So the application would construct the class with something likeand the constructor now knows (at runtime) what the component type is and can use that information to construct the array through the reflection API.Finally we have a type cast because the compiler has no way of knowing that the array returned by Array#newInstance() is the correct type (even though we know).This style is a bit ugly but it can sometimes be the least bad solution to creating generic types that do need to know their component type at runtime for whatever reason (creating arrays, or creating instances of their component type, etc.).You do not need to pass the Class argument to the constructor.\nTry this.andresult:You could create an Object array and cast it to E everywhere. Yeah, it\'s not very clean way to do it but it should at least work.try this.An easy, albeit messy workaround to this would be to nest a second "holder" class inside of your main class, and use it to hold your data.Maybe unrelated to this question but while I was getting the "generic array creation" error for using I find out the following works (and worked for me) with  @SuppressWarnings({"unchecked"}):I\'m wondering if this code would create an effective generic array?Edit: Perhaps an alternate way of creating such an array, if the size you required was known and small, would be to simply feed the required number of "null"s into the zeroArray command?Though obviously this isn\'t as versatile as using the createArray code.You could use a cast:Actually an easier way to do so, is to create an array of objects and cast it to your desired type like the following example:where SIZE is a constant and T is a type identifierI found a sort of a work around to this problem. The line below throws generic array creation errorHowever if I encapsulate List<Person> in a separate class, it works.You can expose people in the class PersonList thru a getter. The line below will give you an array, that has a List<Person> in every element. In other words array of List<Person>.I needed something like this in some code I was working on and this is what I did to get it to work. So far no problems.Passing a list of values...I actually found a pretty unique solution to bypass the inability to initiate a generic array. What you have to do is create a class that takes in the generic variable T like so:and then in your array class just have it start like so:starting a new Generic Invoker[] will cause an issue with unchecked but there shouldn\'t actually be any issues.To get from the array you should call the array[i].variable like so:The rest, such as resizing the array can be done with Arrays.copyOf() like so:And the add function can be added like so: