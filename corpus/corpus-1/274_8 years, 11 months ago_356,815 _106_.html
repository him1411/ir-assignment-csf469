It is discouraged to simply catch System.Exception. Instead, only the "known" exceptions should be caught.Now, this sometimes leads to unneccessary repetitive code, for example:I wonder: Is there a way to catch both exceptions and only call the WebId = Guid.Empty call once?The given example is rather simple, as it\'s only a GUID. But imagine code where you modify an object multiple times, and if one of the manipulations fail in an expected way, you want to "reset" the object. However, if there is an unexpected exception, I still want to throw that higher.About the answer: Thanks everyone! For some reason, I had my mind set on a switch-case statement which does not support switching on GetType(). Now, there were two answers, one using "typeof" and one using "is". I first thought typeof() would be my function, because I thought "Hey, I only want to catch FormatException because that\'s the only thing I expect". But that\'s not how catch() works: catch also catches all derived exceptions. After thinking about it, this is really obvious: Otherwise, catch(Exception ex) would not work! So the correct answer is "is". Yay, learned two things with only one question \\o/Catch System.Exception and switch on the typesEDIT: I do concur with others who are saying that, as of C# 6.0, exception filters are now a perfectly fine way to go: catch (Exception ex) when (ex is ... || ex is ... )Except that I still kind of hate the one-long-line layout and would personally lay the code out like the following. I think this is as functional as it is aesthetic, since I believe it improves comprehension. Some may disagree:ORIGINAL:I know I\'m a little late to the party here, but holy smoke...Cutting straight to the chase, this kind of duplicates an earlier answer, but if you really want to perform a common action for several exception types and keep the whole thing neat and tidy within the scope of the one method, why not just use a lambda/closure/inline function to do something like the following?  I mean, chances are pretty good that you\'ll end up realizing that you just want to make that closure a separate method that you can utilize all over the place. But then it will be super easy to do that without actually changing the rest of the code structurally.  Right?I can\'t help but wonder (warning: a little irony/sarcasm ahead) why on earth go to all this effort to basically just replace the following:...with some crazy variation of this next code smell, I mean example, only to pretend that you\'re saving a few keystrokes.Because it certainly isn\'t automatically more readable.Granted, I left the three identical instances of /* write to a log, whatever... */ return; out of the first example.But that\'s sort of my point.  Y\'all have heard of functions/methods, right?  Seriously.  Write a common ErrorHandler function and, like, call it from each catch block.If you ask me, the second example (with the if and is keywords) is both significantly less readable, and simultaneously significantly more error-prone during the maintenance phase of your project.The maintenance phase, for anyone who might be relatively new to programming, is going to comprise 98.7% or more of the overall lifetime of your project, and the poor schmuck doing the maintenance is almost certainly going to be someone other than you. And there is a very good chance they will spend 50% of their time on the job cursing your name.And of course FxCop barks at you and so you have to also add an attribute to your code that has precisely zip to do with the running program, and is only there to tell FxCop to ignore an issue that in 99.9% of cases it is totally correct in flagging. And, sorry, I might be mistaken, but doesn\'t that "ignore" attribute end up actually compiled into your app?Would putting the entire if test on one line make it more readable? I don\'t think so.  I mean, I did have another programmer vehemently argue once long ago that putting more code on one line would make it "run faster."  But of course he was stark raving nuts. Trying to explain to him (with a straight face--which was challenging) how the interpreter or compiler would break that long line apart into discrete one-instruction-per-line statements--essentially identical to the result if he had gone ahead and just made the code readable instead of trying to out-clever the compiler--had no effect on him whatsoever.  But I digress.How much less readable does this get when you add three more exception types, a month or two from now?  (Answer: it gets a lot less readable).One of the major points, really, is that most of the point of formatting the textual source code that we\'re all looking at every day is to make it really, really obvious to other human beings what is actually happening when the code runs.  Because the compiler turns the source code into something totally different and couldn\'t care less about your code formatting style.  So all-on-one-line totally sucks, too.Just saying...Not in C# unfortunately, as you\'d need an exception filter to do it and C# doesn\'t expose that feature of MSIL. VB.NET does have this capability though, e.g.What you could do is use an anonymous function to encapsulate your on-error code, and then call it in those specific catch blocks:As others have pointed out, you can have an if statement inside your catch block to determine what is going on. C#6 supports Exception Filters, so the following will work:The MyFilter method could then look something like this:Alternatively, this can be all done inline (the right hand side of the when statement just has to be a boolean expression).This is different from using an if statement from within the catch block, using exception filters will not unwind the stack.You can download Visual Studio 2015 to check this out.If you want to continue using Visual Studio 2013, you can install the following nuget package:Install-Package Microsoft.Net.CompilersAt time of writing, this will include support for C# 6.Referencing this package will cause the project to be built using the\n  specific version of the C# and Visual Basic compilers contained in the\n  package, as opposed to any system installed version.For the sake of completeness, since .NET 4.0 the code can rewritten as:TryParse never throws exceptions and returns false if format is wrong, setting WebId to Guid.Empty.Since C# 7 you can avoid introducing a variable on a separate line:You can also create methods for parsing returning tuples, which aren\'t available in .NET Framework yet as of version 4.6:And use them like this:Next useless update to this useless answer comes when deconstruction of out-parameters is implemented in C# 12. :)If you can upgrade your application to C# 6 you are lucky. The new C# version has implemented Exception filters. So you can write this:Some people think this code is the same asBut it\xc2\xb4s not. Actually this is the only new feature in C# 6 that is not possible to emulate in prior versions. First, a re-throw means more overhead than skipping the catch. Second, it is not semantically equivalent. The new feature preserves the stack intact when you are debugging your code. Without this feature the crash dump is less useful or even useless.See a discussion about this on CodePlex. And an example showing the difference.If you don\'t want to use an if statement within the catch scopes, in C# 6.0 you can use Exception Filters syntax which was already supported by the CLR in previews versions but existed only in VB.NET/MSIL:This code will catch the Exception only when it\'s a InvalidDataException or ArgumentNullException.Actually, you can put basically any condition inside that when clause:Note that as opposed to an if statement inside the catch\'s scope, Exception Filters cannot throw Exceptions, and when they do, or when the condition is not true, the next catch condition will be evaluated instead:Output: General catch.When there is more then one true Exception Filter - the first one will be accepted:Output: Catch.And as you can see in the MSIL the code is not translated to if statements, but to Filters, and Exceptions cannot be throw from within the areas marked with Filter 1 and Filter 2 but the filter throwing the Exception will fail instead, also the last comparison value pushed to the stack before the endfilter command will determine the success/failure of the filter (Catch 1 XOR Catch 2 will execute accordingly):Also, specifically Guid has the Guid.TryParse method.This is a variant of Matt\'s answer (I feel that this is a bit cleaner)...use a method:Any other exceptions will be thrown and the code WebId = Guid.Empty; won\'t be hit. If you don\'t want other exceptions to crash your program, just add this AFTER the other two catches:The accepted answer seems acceptable, except that CodeAnalysis/FxCop will complain about the fact that it\'s catching a general exception type.Also, it seems the "is" operator might degrade performance slightly.CA1800: Do not cast unnecessarily says to "consider testing the result of the \'as\' operator instead", but if you do that, you\'ll be writing more code than if you catch each exception separately.Anyhow, here\'s what I would do:@MichealSlightly revised version of your code:String comparisons are ugly and slow.in C# 6 the recommended approach is to use Exception Filters, here is an example:Joseph Daigle\'s Answer is a good solution, but I found the following structure to be a bit tidier and less error prone.There are a few advantages of inverting the expression: It can even be compacted to a single line (though not very pretty)Edit: \nThe exception filtering in C# 6.0 will make the syntax a bit cleaner and comes with a number of other benefits over any current solution. (most notably leaving the stack unharmed)Here is how the same problem would look using C# 6.0 syntax:What is in the link doesn\'t answer your question directly, but it\'s trivial to extend it to look like:(Basically provide another empty Catch overload which returns itself)The bigger question to this is why. I do not think the cost outweighs the gain here :)How aboutUpdate 2015-12-15: See https://stackoverflow.com/a/22864936/1718702 for C#6. It\'s a cleaner and now standard in the language.Geared for people that want a more elegant solution to catch once and filter exceptions, I use an extension method as demonstrated below.I already had this extension in my library, originally written for other purposes, but it worked just perfectly for type checking on exceptions.  Plus, imho, it looks cleaner than a bunch of || statements.  Also, unlike the accepted answer, I prefer explicit exception handling so ex is ... had undesireable behaviour as derrived classes are assignable to there parent types).UsageIsAnyOf.cs Extension (See Full Error Handling Example for Dependancies)Full Error Handling Example (Copy-Paste to new Console app)Two Sample NUnit Unit TestsMatching behaviour for Exception types is exact (ie. A child IS NOT a match for any of its parent types).Since I felt like these answers just touched the surface, I attempted to dig a bit deeper.So what we would really want to do is something that doesn\'t compile, say:The reason we want this is because we don\'t want the exception handler to catch things that we need later on in the process. Sure, we can catch an Exception and check with an \'if\' what to do, but let\'s be honest, we don\'t really want that. (FxCop, debugger issues, uglyness)So why won\'t this code compile - and how can we hack it in such a way that it will?If we look at the code, what we really would like to do is forward the call. However, according to the MS Partition II, IL exception handler blocks won\'t work like this, which in this case makes sense because that would imply that the \'exception\' object can have different types. Or to write it in code, we ask the compiler to do something like this (well it\'s not entirely correct, but it\'s the closest possible thing I guess):The reason that this won\'t compile is quite obvious: what type and value would the \'$exception\' object have (which are here stored in the variables \'e\')? The way we want the compiler to handle this is to note that the common base type of both exceptions is \'Exception\', use that for a variable to contain both exceptions, and then handle only the two exceptions that are caught. The way this is implemented in IL is as \'filter\', which is available in VB.Net.To make it work in C#, we need a temporary variable with the correct \'Exception\' base type. To control the flow of the code, we can add some branches. Here goes:The obvious disadvantages for this are that we cannot re-throw properly, and -well let\'s be honest- that it\'s quite the ugly solution. The uglyness can be fixed a bit by performing branch elimination, which makes the solution slightly better:That leaves just the \'re-throw\'. For this to work, we need to be able to perform the handling inside the \'catch\' block - and the only way to make this work is by an catching \'Exception\' object. At this point, we can add a separate function that handles the different types of Exceptions using overload resolution, or to handle the Exception. Both have disadvantages. To start, here\'s the way to do it with a helper function:And the other solution is to catch the Exception object and handle it accordingly. The most literal translation for this, based on the context above is this:So to conclude:So you\xc2\xb4re repeating lots of code within every exception-switch? Sounds like extracting a method would be god idea, doesn\xc2\xb4t it?So your code comes down to this:I wonder why no-one noticed that code-duplication.From C#6 you furthermore have the exception-filters as already mentioned by others. So you can modify the code above to this:Note that I did find one way to do it, but this looks more like material for The Daily WTF:Wanted to added my short answer to this already long thread.  Something that hasn\'t been mentioned is the order of precedence of the catch statements, more specifically you need to be aware of the scope of each type of exception you are trying to catch.For example if you use a "catch-all" exception as Exception it will preceed all other catch statements and you will obviously get compiler errors however if you reverse the order you can chain up your catch statements (bit of an anti-pattern I think) you can put the catch-all Exception type at the bottom and this will be capture any exceptions that didn\'t cater for higher up in your try..catch block:I highly recommend folks review this MSDN document:Exception HierarchyJust call the try and catch twice.It is just that Simple!!In c# 6.0,Exception Filters is improvements for exception handling