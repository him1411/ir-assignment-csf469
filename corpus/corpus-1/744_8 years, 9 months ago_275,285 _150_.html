How do I parameterize a query containing an IN clause with a variable number of arguments, like this one?In this query, the number of arguments could be anywhere from 1 to 5.I would prefer not to use a dedicated stored procedure for this (or XML), but if there is some elegant way specific to SQL Server 2008, I am open to that.Here\'s a quick-and-dirty technique I have used:So here\'s the C# code:Two caveats:There are other ways to accomplish this that some people may consider cleaner, so please keep reading.You can parameterize each value, so something like:Which will give you:No, this is not open to SQL injection. The only injected text into CommandText is not based on user input. It\'s solely based on the hardcoded "@tag" prefix, and the index of an array. The index will always be an integer, is not user generated, and is safe.The user inputted values are still stuffed into parameters, so there is no vulnerability there.Edit:Injection concerns aside, take care to note that constructing the command text to accomodate a variable number of parameters (as above) impede\'s SQL server\'s ability to take advantage of cached queries. The net result is that you almost certainly lose the value of using parameters in the first place (as opposed to merely inserting the predicate strings into the SQL itself).Not that cached query plans aren\'t valuable, but IMO this query isn\'t nearly complicated enough to see much benefit from it. While the compilation costs may approach (or even exceed) the execution costs, you\'re still talking milliseconds. If you have enough RAM, I\'d expect SQL Server would probably cache a plan for the common counts of parameters as well. I suppose you could always add five parameters, and let the unspecified tags be NULL - the query plan should be the same, but it seems pretty ugly to me and I\'m not sure that it\'d worth the micro-optimization (although, on Stack Overflow - it may very well be worth it).Also, SQL Server 7 and later will auto-parameterize queries, so using parameters isn\'t really necessary from a performance standpoint - it is, however, critical from a security standpoint - especially with user inputted data like this.For SQL Server 2008, you can use a table valued parameter. It\'s a bit of work, but it is arguably cleaner than my other method.First, you have to create a typeThen, your ADO.NET code looks like this:The original question was "How do I parameterize a query ..."Let me state right here, that this is not an answer to the original question.  There are already some demonstrations of that in other good answers.With that said, go ahead and flag this answer, downvote it, mark it as not an answer... do whatever you believe is right.See the answer from Mark Brackett for the preferred answer that I (and 231 others) upvoted. The approach given in his answer allows 1) for effective use of bind variables, and 2) for predicates that are sargable.Selected answerWhat I want to address here is the approach given in Joel Spolsky\'s answer, the answer "selected" as the right answer.Joel Spolsky\'s approach is clever.  And it works reasonably, it\'s going to exhibit predictable behavior and predictable performance, given "normal" values, and with the normative edge cases, such as NULL and the empty string.  And it may be sufficient for a particular application.But in terms generalizing this approach, let\'s also consider the more obscure corner cases, like when the Name column contains a wildcard character (as recognized by the LIKE predicate.)  The wildcard character I see most commonly used is % (a percent sign.). So let\'s deal with that here now, and later go on to other cases.Some problems with % characterConsider a Name value of \'pe%ter\'.  (For the examples here, I use a literal string value in place of the column name.)  A row with a Name value of `\'pe%ter\' would be returned by a query of the form:But that same row will not be returned if the order of the search terms is reversed:The behavior we observe is kind of odd.  Changing the order of the search terms in the list changes the result set.It almost goes without saying that we might not want pe%ter to match peanut butter, no matter how much he likes it.Obscure corner case(Yes, I will agree that this is an obscure case.  Probably one that is not likely to be tested.  We wouldn\'t expect a wildcard in a column value.  We may assume that the application prevents such a value from being stored.  But in my experience, I\'ve rarely seen a database constraint that specifically disallowed characters or patterns that would be considered wildcards on the right side of a LIKE comparison operator.Patching a holeOne approach to patching this hole is to escape the % wildcard character.  (For anyone not familiar with the escape clause on the operator, here\'s a link to the SQL Server documentation.Now we can match the literal %.  Of course, when we have a column name, we\'re going to need to dynamically escape the wildcard.  We can use the REPLACE function to find occurrences of the %character and insert a backslash character in front of each one, like this:So that solves the problem with the % wildcard.  Almost.Escape the escapeWe recognize that our solution has introduced another problem.  The escape character.  We see that we\'re also going to need to escape any occurrences of escape character itself.  This time, we use the ! as the escape character:The underscore tooNow that we\'re on a roll, we can add another REPLACE handle the underscore wildcard.   And just for fun, this time, we\'ll use $ as the escape character.I prefer this approach to escaping because it works in Oracle and MySQL as well as SQL Server.  (I usually use the \\ backslash as the escape character, since that\'s the character we use in regular expressions. But why be constrained by convention!Those pesky bracketsSQL Server also allows for wildcard characters to be treated as literals by enclosing them in brackets [].  So we\'re not done fixing yet, at least for SQL Server.  Since pairs of brackets have special meaning, we\'ll need to escape those as well.  If we manage to properly escape the brackets, then at least we won\'t have to bother with the hyphen - and the carat ^ within the brackets.  And we can leave any %and _ characters inside the brackets escaped, since we\'ll have basically disabled the special meaning of the brackets.Finding matching pairs of brackets shouldn\'t be that hard.  It\'s a little more difficult than handling the occurrences of singleton % and _.  (Note that it\'s not sufficient to just escape all occurrences of brackets, because a singleton bracket is considered to be a literal, and doesn\'t need to be escaped. The logic is getting a little fuzzier than I can handle without running more test cases.)Inline expression gets messyThat inline expression in the SQL is getting longer and uglier.  We can probably make it work, but heaven help the poor soul that comes behind and has to decipher it.  As much of a fan I am for inline expressions, I\'m inclined not use one here, mainly because I don\'t want to have to leave a comment explaining the reason for the mess, and apologizing for it.A function where ?Okay, so, if we don\'t handle that as an inline expression in the SQL, the closest alternative we have is a user defined function.  And we know that won\'t speed things up any (unless we can define an index on it, like we could with Oracle.)  If we\'ve got to create a function, we might better do that in the code that calls the SQL statement.And that function may have some differences in behavior, dependent on the DBMS and version.  (A shout out to all you Java developers so keen on being able to use any database engine interchangeably.)Domain knowledgeWe may have specialized knowledge of the domain for the column, (that is, the set of allowable values enforced for the column.  We may know a priori that the values stored in the column will never contain a percent sign, an underscore, or bracket pairs.  In that case, we just include a quick comment that those cases are covered.The values stored in the column may allow for % or _ characters, but a constraint may require those values to be escaped, perhaps using a defined character, such that the values are LIKE comparison "safe".  Again, a quick comment about the allowed set of values, and in particular which character is used as an escape character, and go with Joel Spolsky\'s approach.But, absent the specialized knowledge and a guarantee, it\'s important for us to at least consider handling those obscure corner cases, and consider whether the behavior is reasonable and "per the specification".Other issues recapitulatedI believe others have already sufficiently pointed out some of the other commonly considered areas of concern:SQL injection (taking what would appear to be user supplied information, and including that in the SQL text rather than supplying them through bind variables.  Using bind variables isn\'t required, it\'s just one convenient approach to thwart with SQL injection.  There are other ways to deal with it:optimizer plan using index scan rather than index seeks, possible need for an expression or function for escaping wildcards (possible index on expression or function)using literal values in place of bind variables impacts scalabilityConclusionI like Joel Spolsky\'s approach.  It\'s clever.  And it works.But as soon as I saw it, I immediately saw a potential problem with it, and it\'s not my nature to let it slide.  I don\'t mean to be critical of the efforts of others.  I know many developers take their work very personally, because they invest so much into it and they care so much about it.  So please understand, this is not a personal attack.  What I\'m identifying here is the type of problem that crops up in production rather than testing.Yes, I\'ve gone far afield from the original question.  But where else to leave this note concerning what I consider to be an important issue with the "selected" answer for a question?You can pass the parameter as a stringSo you have the string Then all you have to do is pass the string as 1 parameter.Here is the split function I use.I heard Jeff/Joel talk about this on the podcast today (episode 34, 2008-12-16 (MP3, 31 MB), 1 h 03 min 38 secs - 1 h 06 min 45 secs), and I thought I recalled Stack Overflow was using LINQ to SQL, but maybe it was ditched. Here\'s the same thing in LINQ to SQL.  That\'s it. And, yes, LINQ already looks backwards enough, but the Contains clause seems extra backwards to me. When I had to do a similar query for a project at work, I naturally tried to do this the wrong way by doing a join between the local array and the SQL Server table, figuring the LINQ to SQL translator would be smart enough to handle the translation somehow. It didn\'t, but it did provide an error message that was descriptive and pointed me towards using Contains.  Anyway, if you run this in the highly recommended LINQPad, and run this query, you can view the actual SQL that the SQL LINQ provider generated. It\'ll show you each of the values getting parameterized into an IN clause.If you are calling from .NET, you could use Dapper dot net:Here Dapper does the thinking, so you don\'t have to. Something similar is possible with LINQ to SQL, of course:This is possibly a half nasty way of doing it, I used it once, was rather effective.Depending on your goals it might be of use. This has a bit of added flexibility in what you can do, but it\'s more suited for situations where you have a large table to query, with good indexing, and you want to use the parametrized list more than once. Saves having to execute it twice and have all the sanitation done manually.I never got around to profiling exactly how fast it was, but in my situation it was needed. We have function that creates a table variable that you can join to:So:This is gross, but if you are guaranteed to have at least one, you could do:Having IN( \'tag1\', \'tag2\', \'tag1\', \'tag1\', \'tag1\' ) will be easily optimized away by SQL Server. Plus, you get direct index seeksIn my opinion, the best source to solve this problem, is what has been posted on this site:Syscomments. Dinakar NethiUse:CREDITS FOR: Dinakar NethiI would pass a table type parameter (since it\'s SQL Server 2008), and do a where exists, or inner join. You may also use XML, using sp_xml_preparedocument, and then even index that temporary table.In SQL Server 2016+ you could use SPLIT_STRING function:or:LiveDemoThe accepted answer will of course work and it is one of the way to go, but it is anti-pattern.E. Find rows by list of valuesThis is replacement for common anti-pattern such as creating a dynamic SQL string in application layer or Transact-SQL, or by using LIKE operator:The proper way IMHO is to store the list in a character string (limited in length by what the DBMS support); the only trick is that (in order to simplify processing) I have a separator (a comma in my example) at the beginning and at the end of the string. The idea is to "normalize on the fly", turning the list into a one-column table that contains one row per value. This allows you to turnin (ct1,ct2, ct3 ... ctn)into anin (select ...)or (the solution I\'d probably prefer) a regular join, if you just add a "distinct" to avoid problems with duplicate values in the list.Unfortunately, the techniques to slice a string are fairly product-specific.\nHere is the SQL Server version:The Oracle version:and the MySQL version:(Of course, "pivot" must return as many rows as the maximum number of\nitems we can find in the list)If you\'ve got SQL Server 2008 or later I\'d use a Table Valued Parameter.If you\'re unlucky enough to be stuck on SQL Server 2005 you could add a CLR function like this,Which you could use like this,I think this is a case when a static query is just not the way to go. Dynamically build the list for your in clause, escape your single quotes, and dynamically build SQL. In this case you probably won\'t see much of a difference with any method due to the small list, but the most efficient method really is to send the SQL exactly as it is written in your post. I think it is a good habit to write it the most efficient way, rather than to do what makes the prettiest code, or consider it bad practice to dynamically build SQL.I have seen the split functions take longer to execute than the query themselves in many cases where the parameters get large. A stored procedure with table valued parameters in SQL 2008 is the only other option I would consider, although this will probably be slower in your case. TVP will probably only be faster for large lists if you are searching on the primary key of the TVP, because SQL will build a temporary table for the list anyway (if the list is large). You won\'t know for sure unless you test it.I have also seen stored procedures that had 500 parameters with default values of null, and having WHERE Column1 IN (@Param1, @Param2, @Param3, ..., @Param500). This caused SQL to build a temp table, do a sort/distinct, and then do a table scan instead of an index seek. That is essentially what you would be doing by parameterizing that query, although on a small enough scale that it won\'t make a noticeable difference. I highly recommend against having NULL in your IN lists, as if that gets changed to a NOT IN it will not act as intended. You could dynamically build the parameter list, but the only obvious thing that you would gain is that the objects would escape the single quotes for you. That approach is also slightly slower on the application end since the objects have to parse the query to find the parameters. It may or may not be faster on SQL, as parameterized queries call sp_prepare, sp_execute for as many times you execute the query, followed by sp_unprepare. The reuse of execution plans for stored procedures or parameterized queries may give you a performance gain, but it will lock you in to one execution plan determined by the first query that is executed. That may be less than ideal for subsequent queries in many cases. In your case, reuse of execution plans will probably be a plus, but it might not make any difference at all as the example is a really simple query.Cliffs notes:For your case anything you do, be it parameterization with a fixed number of items in the list (null if not used), dynamically building the query with or without parameters, or using stored procedures with table valued parameters will not make much of a difference. However, my general recommendations are as follows:Your case/simple queries with few parameters:Dynamic SQL, maybe with parameters if testing shows better performance.Queries with reusable execution plans, called multiple times by simply changing the parameters or if the query is complicated:SQL with dynamic parameters.Queries with large lists:Stored procedure with table valued parameters. If the list can vary by a large amount use WITH RECOMPILE on the stored procedure, or simply use dynamic SQL without parameters to generate a new execution plan for each query.May be we can use XML here:Use the following stored procedure. It uses a custom split function, which can be found here.I\'d approach this by default with passing a table valued function (that returns a table from a string) to the IN condition.Here is the code for the UDF (I got it from Stack Overflow somewhere, i can\'t find the source right now)Once you got this your code would be as simple as this:Unless you have a ridiculously long string, this should work well with the table index.If needed you can insert it into a temp table, index it, then run a join...Another possible solution is instead of passing a variable number of arguments to a stored procedure, pass a single string containing the names you\'re after, but make them unique by surrounding them with \'<>\'. Then use PATINDEX to find the names:For a variable number of arguments like this the only way I\'m aware of is to either generate the SQL explicitly or do something that involves populating a temporary table with the items you want and joining against the temp table.In ColdFusion we just do:Here\'s a technique that recreates a local table to be used in a query string. Doing it this way eliminates all parsing problems. The string can be built in any language. In this example I used SQL since that was the original problem I was trying to solve. I needed a clean way to pass in table data on the fly in a string to be executed later.Using a user defined type is optional. Creating the type is only created once and can be done ahead of time. Otherwise just add a full table type to the declaration in the string. The general pattern is easy to extend and can be used for passing more complex tables.I use a more concise version of the top voted answer:It does loop through the tag parameters twice; but that doesn\'t matter most of the time (it won\'t be your bottleneck; if it is, unroll the loop).If you\'re really interested in performance and don\'t want to iterate through the loop twice, here\'s a less beautiful version:In SQL Server 2016+ another possibility is to use the OPENJSON function.This approach is blogged about in OPENJSON - one of best ways to select rows by list of ids.A full worked example belowHere is another alternative. Just pass a comma-delimited list as a string parameter to the stored procedure and:And the function:I have an answer that doesn\'t require a UDF, XML\nBecause IN accepts a select statement\ne.g. SELECT * FROM Test where Data IN (SELECT Value FROM TABLE)You really only need a way to convert the string into a table.This can be done with a recursive CTE, or a query with a number table (or Master..spt_value)Here\'s the CTE version.Here is another answer to this problem. (new version posted on 6/4/13).Cheers.Here\'s a cross-post to a solution to the same problem.  More robust than reserved delimiters - includes escaping and nested arrays, and understands NULLs and empty arrays.C# & T-SQL string[] Pack/Unpack utility functionsYou can then join to the table-valued function.--YOUR QUERY