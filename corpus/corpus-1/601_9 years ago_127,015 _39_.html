I\'m getting a warning from ReSharper about a call to a virtual member from my objects constructor.  Why would this be something not to do?When an object written in C# is constructed, what happens is that the initializers run in order from the most derived class to the base class, and then constructors run in order from the base class to the most derived class (see Eric Lippert\'s blog for details as to why this is).Also in .NET objects do not change type as they are constructed, but start out as the most derived type, with the method table being for the most derived type. This means that virtual method calls always run on the most derived type.When you combine these two facts you are left with the problem that if you make a virtual method call in a constructor, and it is not the most derived type in its inheritance hierarchy, that it will be called on a class whose constructor has not been run, and therefore may not be in a suitable state to have that method called. This problem is, of course, mitigated if you mark your class as sealed to ensure that it is the most derived type in the inheritance hierarchy - in which case it is perfectly safe to call the virtual method.In order to answer your question, consider this question: what will the below code print out when the Child object is instantiated?The answer is that in fact a NullReferenceException will be thrown, because foo is null. An object\'s base constructor is called before its own constructor. By having a virtual call in an object\'s constructor you are introducing the possibility that inheriting objects will execute code before they have been fully initialized.The rules of C# are very different from that of Java and C++.When you are in the constructor for some object in C#, that object exists in a fully initialized (just not "constructed") form, as its fully derived type.This means that if you call a virtual function from the constructor of A, it will resolve to any override in B, if one is provided.Even if you intentionally set up A and B like this, fully understanding the behavior of the system, you could be in for a shock later. Say you called virtual functions in B\'s constructor, "knowing" they would be handled by B or A as appropriate. Then time passes, and someone else decides they need to define C, and override some of the virtual functions there. All of a sudden B\'s constructor ends up calling code in C, which could lead to quite surprising behavior.It is probably a good idea to avoid virtual functions in constructors anyway, since the rules are so different between C#, C++, and Java. Your programmers may not know what to expect!Reasons of the warning are already described, but how would you fix the warning? You have to seal either class or virtual member. You can seal class A:Or you can seal method Foo:In C#, a base class\' constructor runs before the derived class\' constructor, so any instance fields that a derived class might use in the possibly-overridden virtual member are not initialized yet.Do note that this is just a warning to make you pay attention and make sure it\'s all-right.  There are actual use-cases for this scenario, you just have to document the behavior of the virtual member that it can not use any instance fields declared in a derived class below where the constructor calling it is.There are well-written answers above for why you wouldn\'t want to do that.  Here\'s a counter-example where perhaps you would want to do that (translated into C# from Practical Object-Oriented Design in Ruby by Sandi Metz, p. 126). Note that GetDependency() isn\'t touching any instance variables.  It would be static if static methods could be virtual.(To be fair, there are probably smarter ways of doing this via dependency injection containers or object initializers...) Yes, it\'s generally bad to call virtual method in the constructor.At this point, the objet may not be fully constructed yet, and the invariants expected by methods may not hold yet.Your constructor may (later, in an extension of your software) be called from the constructor of a subclass that overrides the virtual method.  Now not the subclass\'s implementation of the function, but the implementation of the base class will be called.  So it doesn\'t really make sense to call a virtual function here.However, if your design satisfies the Liskov Substitution principle, no harm will be done. Probably that\'s why it\'s tolerated - a warning, not an error.One important aspect of this question which other answers have not yet addressed is that it is safe for a base-class to call virtual members from within its constructor if that is what the derived classes are expecting it to do.  In such cases, the designer of the derived class is responsible for ensuring that any methods which are run before construction is complete will behave as sensibly as they can under the circumstances.  For example, in C++/CLI, constructors are wrapped in code which will call Dispose on the partially-constructed object if construction fails.  Calling Dispose in such cases is often necessary to prevent resource leaks, but Dispose methods must be prepared for the possibility that the object upon which they are run may not have been fully constructed.Because until the constructor has completed executing, the object is not fully instantiated. Any members referenced by the virtual function may not be initialised. In C++, when you are in a constructor, this only refers to the static type of the constructor you are in, and not the actual dynamic type of the object that is being created. This means that the virtual function call might not even go where you expect it to.There\'s a difference between C++ and C# in this specific case.\nIn C++ the object is not initialized and therefore it is unsafe to call a virutal function inside a constructor.\nIn C# when a class object is created all its members are zero initialized. It is possible to call a virtual function in the constructor but if you\'ll might access members that are still zero. If you don\'t need to access members it is quite safe to call a virtual function in C#.Just to add my thoughts. If you always initialize the private field when define it, this problem should be avoid. At least below code works like a charm:The warning is a reminder that virtual members are likely to be overridden on derived class. In that case whatever the parent class did to a virtual member will be undone or changed by overriding child class. Look at the small example blow for clarityThe parent class below attempts to set value to a virtual member on its constructor. And this will trigger Re-sharper warning, let see on code:The child class here overrides the parent property. If this property was not marked virtual the compiler would warn that the property hides property on the parent class and suggest that you add \'new\' keyword if it is intentional.Finally the impact on use, the output of the example below abandons the initial value set by parent class constructor.\nAnd this is what Re-sharper attempts to to warn you, values set on the Parent class constructor are open to be overwritten by the child class constructor which is called right after the parent class constructor.Another interesting thing I found is that ReSharper error can be \'satisfied\' by doing something like below which is dumb to me (however, as mentioned by many earlier, it still is not a good idea to call virtual prop/methods in ctor.}One important missing bit is, what is the correct way to resolve this issue?As Greg explained, the root problem here is that a base class constructor would invoke the virtual member before the derived class has been constructed.The following code, taken from MSDN\'s constructor design guidelines, demonstrates this issue. When a new instance of DerivedFromBad is created, the base class constructor calls to DisplayState and shows BadBaseClass because the field has not yet been update by the derived constructor.An improved implementation removes the virtual method from the base class constructor, and uses an Initialize method. Creating a new instance of DerivedFromBetter displays the expected "DerivedFromBetter" 