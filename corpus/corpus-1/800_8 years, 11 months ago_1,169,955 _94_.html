What I would like is a method to convert a double to a string which rounds using the half-up method - i.e. if the decimal to be rounded is 5, it always rounds up to the previous number. This is the standard method of rounding most people expect in most situations.I also would like only significant digits to be displayed - i.e. there should not be any trailing zeroes.I know one method of doing this is to use the String.format method:returns:which is great, however it always displays numbers with 5 decimal places even if they are not significant: returns:Another method is to use the DecimalFormatter:returns:However as you can see this uses half-even rounding. That is it will round down if the previous digit is even. What I\'d like is this:What is the best way to achieve this in Java?Use setRoundingMode, set the RoundingMode explicitly to handle your issue with the half-even round, then use the format pattern for your required output.Example:gives the output:Assuming value is a double, you can do:That\'s for 5 digits precision. The number of zeros indicate the number of decimals.will get you a BigDecimal.  To get the string out of it, just call that BigDecimal\'s toString method, or the toPlainString method for Java 5+ for a plain format string.  Sample program:  You can also use the to make sure you have the trailing 0\'s.As some others have noted, the correct answer is to use either DecimalFormat or BigDecimal. Floating-point doesn\'t have decimal places so you cannot possibly round/truncate to a specific number of them in the first place. You have to work in a decimal radix, and that is what those two classes do.I am posting the following code as a counter-example to all the answers in this thread and indeed all over StackOverflow (and elsewhere) that recommend multiplication followed by truncation followed by division. It is incumbent on advocates of this technique to explain why the following code produces the wrong output in over 92% of cases.Output of this program:EDIT: I note that this post has been here for nearly six months and no explanations have been forthcoming. Draw your own conclusions.Suppose you haveyou can use BigDecimalor without BigDecimal with both solutions d == 9232.13You can use the DecimalFormat class.Real\'s Java How-to posts this solution, which is also compatible for versions before Java 1.6. @Milhous: the decimal format for rounding is excellent:You can also use the to make sure you have the trailing 0\'s.I would add that this method is very good at providing an actual\nnumeric, rounding mechanism - not only visually, but also when processing.Hypothetical: you have to implement a rounding mechanism into a GUI\nprogram. To alter the accuracy / precision of a result output simply \nchange the caret format (i.e. within the brackets).  So that:would return as output: 0.912385would return as output: 0.91239would return as output: 0.9124[EDIT: also if the caret format is like so ("#0.############") and you\nenter a decimal, e.g. 3.1415926, for argument\'s sake, DecimalFormat\ndoes not produce any garbage (e.g. trailing zeroes) and will return:\n3.1415926 .. if you\'re that way inclined. Granted, it\'s a little verbose\nfor the liking of some dev\'s - but hey, it\'s got a low memory footprint\nduring processing and is very easy to implement.]So essentially, the beauty of DecimalFormat is that it simultaneously handles the string \nappearance - as well as the level of rounding precision set. Ergo: you \nget two benefits for the price of one code implementation. ;)You could use the following utility method-Here is a summary of what you can use if you want the result as String:DecimalFormat#setRoundingMode():BigDecimal#setScale()Here is a suggestion of what libraries you can use if you want double as a result. I wouldn\'t recommend it for string conversion, though, as double may not be able to represent what you want exactly (see e.g. here):Precision from Apache Commons Math Functions from ColtUtils from WekaYou can use BigDecimalRefer: http://www.javabeat.net/precise-rounding-of-decimals-using-rounding-mode-enumeration/Try this: org.apache.commons.math3.util.Precision.round(double x, int scale)See: http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/util/Precision.htmlApache Commons Mathematics Library homepage is: http://commons.apache.org/proper/commons-math/index.htmlThe internal implemetation of this method is:Since I found no complete answer on this theme I\'ve put together a class that should handle this properly, with support for:Usage is pretty simple:(For the sake of this example I am using a custom locale)Here is the class:If you really want decimal numbers for calculation (and not only for output), do not use a binary-based floating point format like double. Use BigDecimal or any other decimal-based format. \xe2\x80\x93 Pa\xc5\xadlo Ebermann I do use BigDecimal for calculations, but bear in mind it is dependent on the size of\nnumbers you\'re dealing with.  In most my implementations, i find parsing from double or\ninteger to Long is sufficient enough for very large number calculations.  In fact, i\'ve\nrecently used parsed-to-Long to get accurate representations (as opposed to hex results)\nin a gui for numbers as big as ################################# characters (as an \nexample).If you\'re using DecimalFormat to convert double to String, it\'s very straightforward:There are several RoundingMode enum values to select from, depending upon the behaviour you require.Just in case someone still needs help with this. This solution works perfectly for me.returns a  String  with the desired output.The code snippet below shows how to display n digits.  The trick is to set variable pp to 1 followed by n zeros.  In the example below, variable pp value has 5 zeros, so 5 digits will be displayed.I came here just wanting a simple answer on how to round a number. This is a supplemental answer to provide that.The most common case is to use Math.round().Numbers are rounded to the nearest whole number. A .5 value is rounded up. If you need different rounding behavior than that, you can use one of the other Math functions. See the comparison below.As stated above, this rounds to the nearest whole number. .5 decimals round up.  This method returns an int.Any decimal value is rounded up to the next integer. It goes to the ceiling. This method returns a double.Any decimal value is rounded down to the next integer. This method returns a double.This is similar to round in that decimal values round to the closest integer. However, unlike round, .5 values round to the even integer.  This method returns a double.I agree with the chosen answer to use DecimalFormat --- or alternatively BigDecimal.Please read Update below first!However if you do want to round the double value and get a double value result, you can use org.apache.commons.math3.util.Precision.round(..) as mentioned above. The implementation uses BigDecimal, is slow and creates garbage.A similar but fast and garbage-free method is provided by the DoubleRounder utility in the decimal4j library:Will outputSee\nhttps://github.com/tools4j/decimal4j/wiki/DoubleRounder-UtilityDisclaimer: I am involved in the decimal4j project.Update:\nAs @iaforek pointed out DoubleRounder sometimes returns counterintuitive results. The reason is that it performs mathematically correct rounding. For instance DoubleRounder.round(256.025d, 2) will be rounded down to 256.02 because the double value represented as 256.025d is somewhat smaller than the rational value 256.025 and hence will be rounded down. Notes:For those reasons and everything mentioned above in this post I cannot recommend to use DoubleRounder.Here\'s a basic solution offered by jpdymond:https://stackoverflow.com/a/22186845/212950DecimalFormat is the best ways to output, but I don\'t prefer it. I always do this all the time, because it return the double value. So I can use it  more than just output.ORIf you need large decimal places value, you can use BigDecimal instead. Anyways .0 is important. Without it the rounding of 0.33333d5 return 0.33333 and only 9 digits are allows. The second function without .0 has problems with 0.30000 return 0.30000000000000004.Where dp = decimal place you want,\nand value is a double.Keep in mind that String.format() and DecimalFormat produce string using default Locale. So they may write formatted number with dot or comma as a separator between integer and decimal parts. To make sure that rounded String is in the format you want use java.text.NumberFormat as so:Will print in English locale (no matter what your locale is):\n  0.99\n  123.57\n  123.00The example is taken from Farenda - how to convert double to String correctly.If you Consider 5 or n number of decimal.\nMay be this answer solve your prob.Output will be: 123.01\nthis can be solve with loop and recursive function.Basically, the round() method returns the closest long or int, as indicated by the method\'s return type, to the argument:And this gives the output: