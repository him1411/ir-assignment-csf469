What exactly is RESTful programming?An architectural style called REST (Representational State Transfer) advocates that web applications should use HTTP as it was originally envisioned. Lookups should use GET requests. PUT, POST, and DELETE requests should be used for *mutation, creation, and deletion respectively *.REST proponents tend to favor URLs, such asbut the REST architecture does not require these \xe2\x80\x9cpretty URLs\xe2\x80\x9d. A GET request with a parameteris every bit as RESTful.Keep in mind that GET requests should never be used for updating information. For example, a GET request for adding an item to a cartwould not be appropriate. GET requests should be idempotent. That is, issuing a request twice should be no different from issuing it once. That\xe2\x80\x99s what makes the requests cacheable. An \xe2\x80\x9cadd to cart\xe2\x80\x9d request is not idempotent\xe2\x80\x94issuing it twice adds two copies of the item to the cart. A POST request is clearly appropriate in this context. Thus, even a RESTful web application needs its share of POST requests.This is taken from the excellent book Core JavaServer faces Book by David M. GearyREST is the underlying architectural principle of the web. The amazing thing about the web is the fact that clients (browsers) and servers can interact in complex ways without the client knowing anything beforehand about the server and the resources it hosts. The key constraint is that the server and client must both agree on the media used, which in the case of the web is HTML.An API that adheres to the principles of REST does not require the client to know anything about the structure of the API. Rather, the server needs to provide whatever information the client needs to interact with the service. An HTML form is an example of this: The server specifies the location of the resource, and the required fields. The browser doesn\'t know in advance where to submit the information, and it doesn\'t know in advance what information to submit. Both forms of information are entirely supplied by the server. (This principle is called HATEOAS: Hypermedia As The Engine Of Application State.)So, how does this apply to HTTP, and how can it be implemented in practice? HTTP is oriented around verbs and resources. The two verbs in mainstream usage are GET and POST, which I think everyone will recognize. However, the HTTP standard defines several others such as PUT and DELETE. These verbs are then applied to resources, according to the instructions provided by the server.For example, Let\'s imagine that we have a user database that is managed by a web service. Our service uses a custom hypermedia based on JSON, for which we assign the mimetype application/json+userdb (There might also be an application/xml+userdb and application/whatever+userdb - many media types may be supported). The client and the server has both been programmed to understand this format, but they don\'t know anything about each other. As Roy Fielding points out:A REST API should spend almost all of its descriptive effort in\n  defining the media type(s) used for representing resources and driving\n  application state, or in defining extended relation names and/or\n  hypertext-enabled mark-up for existing standard media types.A request for the base resource / might return something like this:RequestResponseWe know from the description of our media that we can find information about related resources from sections called "links". This is called Hypermedia controls. In this case, we can tell from such a section that we can find a user list by making another request for /user:RequestResponseWe can tell a lot from this response. For instance, we now know we can create a new user by POSTing to /user:RequestResponseWe also know that we can change existing data:RequestResponseNotice that we are using different HTTP verbs (GET, PUT, POST, DELETE etc.) to manipulate these resources, and that the only knowledge we presume on the clients part is our media definition.Further reading:(This answer has been subject of a fair amount of criticism for missing the point. For the most part, that has been a fair critique. What I originally described was more in line with how REST was usually implemented a few years ago when I first wrote this, rather than its true meaning. I\'ve revised the answer to better represent the real meaning.)RESTful programming is about:The last one is probably the most important in terms of consequences and overall effectiveness of REST. Overall, most of the RESTful discussions seem to center on HTTP and its usage from a browser and what not. I understand that R. Fielding coined the term when he described the architecture and decisions that lead to HTTP. His thesis is more about the architecture and cache-ability of resources than it is about HTTP.If you are really interested in what a RESTful architecture is and why it works, read his thesis a few times and read the whole thing not just Chapter 5! Next look into why DNS works. Read about the hierarchical organization of DNS and how referrals work. Then read and consider how DNS caching works. Finally, read the HTTP specifications (RFC2616 and RFC3040 in particular) and consider how and why the caching works the way that it does. Eventually, it will just click. The final revelation for me was when I saw the similarity between DNS and HTTP. After this, understanding why SOA and Message Passing Interfaces are scalable starts to click.I think that the most important trick to understanding the architectural importance and performance implications of a RESTful and Shared Nothing architectures is to avoid getting hung up on the technology and implementation details. Concentrate on who owns resources, who is responsible for creating/maintaining them, etc. Then think about the representations, protocols, and technologies.This is what it might look like.Create a user with three properties:The server responds:In the future, you can then retrieve the user information:The server responds:To modify the record (lname and age will remain unchanged):To update the record (and consequently lname and age will be NULL):A great book on REST is REST in Practice.Must reads are Representational State Transfer (REST) and REST APIs must be hypertext-driven See Martin Fowlers article the Richardson Maturity Model (RMM) for an explanation on what an RESTful service is. To be RESTful a Service needs to fulfill the Hypermedia as the Engine of Application State. (HATEOAS), that is, it needs to reach level 3 in the RMM, read the article for details or the slides from the qcon talk.The HATEOAS constraint is an acronym\n  for Hypermedia as the Engine of\n  Application State. This principle is\n  the key differentiator between a REST\n  and most other forms of client server\n  system....A client of a RESTful application need\n  only know a single fixed URL to access\n  it. All future actions should be\n  discoverable dynamically from\n  hypermedia links included in the\n  representations of the resources that\n  are returned from that URL.\n  Standardized media types are also\n  expected to be understood by any\n  client that might use a RESTful API. \n  (From Wikipedia, the free encyclopedia)REST Litmus Test for Web Frameworks is a similar maturity test for web frameworks.Approaching pure REST: Learning to love HATEOAS is a good collection of links. REST versus SOAP for the Public Cloud discusses the current levels of REST usage. REST and versioning discusses Extensibility, Versioning, Evolvability, etc.\n through ModifiabilityWhat is REST?REST stands for Representational State Transfer. (It is sometimes\n  spelled "ReST".) It relies on a stateless, client-server, cacheable\n  communications protocol -- and in virtually all cases, the HTTP\n  protocol is used.REST is an architecture style for designing networked applications.\n  The idea is that, rather than using complex mechanisms such as CORBA,\n  RPC or SOAP to connect between machines, simple HTTP is used to make\n  calls between machines.In many ways, the World Wide Web itself, based on HTTP, can be viewed\n  as a REST-based architecture. RESTful applications use HTTP requests\n  to post data (create and/or update), read data (e.g., make queries),\n  and delete data. Thus, REST uses HTTP for all four CRUD\n  (Create/Read/Update/Delete) operations.REST is a lightweight alternative to mechanisms like RPC (Remote\n  Procedure Calls) and Web Services (SOAP, WSDL, et al.). Later, we will\n  see how much more simple REST is.Despite being simple, REST is fully-featured; there\'s basically\n  nothing you can do in Web Services that can\'t be done with a RESTful\n  architecture. REST is not a "standard". There will never be a W3C\n  recommendataion for REST, for example. And while there are REST\n  programming frameworks, working with REST is so simple that you can\n  often "roll your own" with standard library features in languages like\n  Perl, Java, or C#.One of the best reference I found when I try to find the simple real meaning of rest.http://rest.elkstein.org/REST is using the various HTTP methods (mainly GET/PUT/DELETE) to manipulate data.Rather than using a specific URL to delete a method (say, /user/123/delete), you would send a DELETE request to the /user/[id] URL, to edit a user, to retrieve info on a user you send a GET request to /user/[id]For example, instead a set of URLs which might look like some of the following..You use the HTTP "verbs" and have..It\'s programming where the architecture of your system fits the REST style laid out by Roy Fielding in his thesis. Since this is the architectural style that describes the web (more or less), lots of people are interested in it.Bonus answer: No. Unless you\'re studying software architecture as an academic or designing web services, there\'s really no reason to have heard the term.I would say RESTful programming would be about creating systems (API) that follow the REST architectural style.I found this fantastic, short, and easy to understand tutorial about REST by Dr. M. Elkstein and quoting the essential part that would answer your question for the most part:Learn REST: A TutorialREST is an architecture style for designing networked applications.\n  The idea is that, rather than using complex mechanisms such as CORBA,\n  RPC or SOAP to connect between machines, simple HTTP is used to make\n  calls between machines.RESTful applications use HTTP requests to post data (create and/or\n  update), read data (e.g., make queries), and delete data. Thus, REST\n  uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.I don\'t think you should feel stupid for not hearing about REST outside Stack Overflow..., I would be in the same situation!; answers to this other SO question on Why is REST getting big now could could ease some feelings.I apologize if I\'m not answering the question directly, but it\'s easier to understand all this with more detailed examples. Fielding is not easy to understand due to all the abstraction and terminology.There\'s a fairly good example here:Explaining REST and Hypertext: Spam-E the Spam Cleaning RobotAnd even better, there\'s a clean explanation with simple examples here (the powerpoint is more comprehensive, but you can get most of it in the html version):http://www.xfront.com/REST.ppt or http://www.xfront.com/REST.htmlAfter reading the examples, I could see why Ken is saying that REST is hypertext-driven. I\'m not actually sure that he\'s right though, because that /user/123 is a URI that points to a resource, and it\'s not clear to me that it\'s unRESTful just because the client knows about it "out-of-band."That xfront document explains the difference between REST and SOAP, and this is really helpful too. When Fielding says, "That is RPC. It screams RPC.", it\'s clear that RPC is not RESTful, so it\'s useful to see the exact reasons for this. (SOAP is a type of RPC.)What is REST?REST in official words, REST is an architectural style built on certain principles using the current \xe2\x80\x9cWeb\xe2\x80\x9d fundamentals.\nThere are 5 basic fundamentals of web which are leveraged to create REST services.I see a bunch of answers that say putting everything about user 123 at resource "/user/123" is RESTful.Roy Fielding, who coined the term, says REST APIs must be hypertext-driven.  In particular, "A REST API must not define fixed resource names or hierarchies".So if your "/user/123" path is hardcoded on the client, it\'s not really RESTful.  A good use of HTTP, maybe, maybe not.  But not RESTful.  It has to come from hypertext.The answer is very simple, there is a dissertation written by Roy Fielding.]1 In that dissertation he defines the REST principles. If an application fulfills all of those principles, then that is a REST application.The term RESTful was created because ppl exhausted the word REST by calling their non-REST application as REST. After that the term RESTful was exhausted as well. Nowadays we are talking about Web APIs and Hypermedia APIs, because the most of the so called REST applications did not fulfill the HATEOAS part of the uniform interface constraint.The REST constraints are the following:client-server architectureSo it does not work with for example PUB/SUB sockets, it is based on REQ/REP.stateless communicationSo the server does not maintain the states of the clients. This means that you cannot use server a side session storage and you have to authenticate every request. Your clients possibly send basic auth headers through an encrypted connection. (By large applications it is hard to maintain many sessions.)usage of cache if you canSo you don\'t have to serve the same requests again and again.uniform interface as common contract between client and serverThe contract between the client and the server is not maintained by the server. In other words the client must be decoupled from the implementation of the service. You can reach this state by using standard solutions, like the IRI (URI) standard to identify resources, the HTTP standard to exchange messages, standard MIME types to describe the body serialization format, metadata (possibly RDF vocabs, microformats, etc.) to describe the semantics of different parts of the message body. To decouple the IRI structure from the client, you have to send hyperlinks to the clients in hypermedia formats like (HTML, JSON-LD, HAL, etc.). So a client can use the metadata (possibly link relations, RDF vocabs) assigned to the hyperlinks to navigate the state machine of the application through the proper state transitions in order to achieve its current goal.For example when a client wants to send an order to a webshop, then it have to check the hyperlinks in the responses sent by the webshop. By checking the links it founds one described with the http://schema.org/OrderAction. The client know the schema.org vocab, so it understands that by activating this hyperlink it will send the order. So it activates the hyperlink and sends a POST https://example.com/api/v1/order message with the proper body. After that the service processes the message and responds with the result having the proper HTTP status header, for example 201 - created by success. To annotate messages with detailed metadata the standard solution to use an RDF format, for example JSON-LD with a REST vocab, for example Hydra and domain specific vocabs like schema.org or any other linked data vocab and maybe a custom application specific vocab if needed. Now this is not easy, that\'s why most ppl use HAL and other simple formats which usually provide only a REST vocab, but no linked data support.build a layered system to increase scalabilityThe REST system is composed of hierarchical layers. Each layer contains components which use the services of components which are in the next layer below. So you can add new layers and components effortless. For example there is a client layer which contains the clients and below that there is a service layer which contains a single service. Now you can add a client side cache between them. After that you can add another service instance and a load balancer, and so on... The client code and the service code won\'t change.code on demand to extend client functionalityThis constraint is optional. For example you can send a parser for a specific media type to the client, and so on... In order to do this you might need a standard plugin loader system in the client, or your client will be coupled to the plugin loader solution.REST constraints result a highly scalable system in where the clients are decoupled from the implementations of the services. So the clients can be reusable, general just like the browsers on the web. The clients and the services share the same standards and vocabs, so they can understand each other despite the fact that the client does not know the implementation details of the service. This makes possible to create automated clients which can find and utilize REST services to achieve their goals. In long term these clients can communicate to each other and trust each other with tasks, just like humans do. If we add learning patterns to such clients, then the result will be one or more AI using the web of machines instead of a single server park. So at the end the dream of Berners Lee: the semantic web and the artificial intelligence will be reality. So in 2030 we end up terminated by the Skynet. Until then ... ;-)RESTful (Representational state transfer) API programming is writing web applications in any programming language by following 5 basic software architectural style principles:In other words you\'re writing simple point-to-point network applications over HTTP which uses verbs such as GET, POST, PUT or DELETE by implementing RESTful architecture which proposes standardization of the interface each \xe2\x80\x9cresource\xe2\x80\x9d exposes. It is nothing that using current features of the web in a simple and effective way (highly successful, proven and distributed architecture). It is an alternative to more complex mechanisms like SOAP, CORBA and RPC. RESTful programming conforms to Web architecture design and, if properly implemented, it allows you to take the full advantage of scalable Web infrastructure.If I had to reduce the original dissertation on REST to just 3 short sentences, I think the following captures its essence:After that, it\'s easy to fall into debates about adaptations, coding conventions, and best practices.Interestingly, there is no mention of HTTP POST, GET, DELETE, or PUT operations in the dissertation. That must be someone\'s later interpretation of a "best practice" for a "uniform interface".When it comes to web services, it seems that we need some way of distinguishing WSDL and SOAP based architectures which add considerable overhead and arguably much unnecessary complexity to the interface. They also require additional frameworks and developer tools in order to implement. I\'m not sure if REST is the best term to distinguish between common-sense interfaces and overly engineered interfaces such as WSDL and SOAP. But we need something.Here is my basic outline of REST. I tried to demonstrate the thinking behind each of the components in a RESTful architecture so that understanding the concept is more intuitive. Hopefully this helps demystify REST for some people!REST (Representational State Transfer) is a design architecture that outlines how networked resources (i.e. nodes that share information) are designed and addressed. In general, a RESTful architecture makes it so that the client (the requesting machine) and the server (the responding machine) can request to read, write, and update data without the client having to know how the server operates and the server can pass it back without needing to know anything about the client. Okay, cool...but how do we do this in practice?The most obvious requirement is that there needs to be a universal language of some sort so that the server can tell the client what it is trying to do with the request and for the server to respond.But to find any given resource and then tell the client where that resource lives, there needs to be a universal way of pointing at resources. This is where Universal Resource Identifiers (URIs) come in; they are basically unique addresses to find the resources.But the REST architecture doesn\xe2\x80\x99t end there! While the above fulfills the basic needs of what we want, we also want to have an architecture that supports high volume traffic since any given server usually handles responses from a number of clients. Thus, we don\xe2\x80\x99t want to overwhelm the server by having it remember information about previous requests. Therefore, we impose the restriction that each request-response pair between the client and the server is independent, meaning that the server doesn\xe2\x80\x99t have to remember anything about previous requests (previous states of the client-server interaction) to respond to a new request. This means that we want our interactions to be stateless.To further ease the strain on our server from redoing computations that have already been recently done for a given client, REST also allows caching. Basically, caching means to take a snapshot of the initial response provided to the client. If the client makes the same request again, the server can provide the client with the snapshot rather than redo all of the computations that were necessary to create the initial response. However, since it is a snapshot, if the snapshot has not expired--the server sets an expiration time in advance--and the response has been updated since the initial cache (i.e. the request would give a different answer than the cached response), the client will not see the updates until the cache expires (or the cache is cleared) and the response is rendered from scratch again.The last thing that you\xe2\x80\x99ll often here about RESTful architectures is that they are layered. We have actually already been implicitly discussing this requirement in our discussion of the interaction between the client and server. Basically, this means that each layer in our system interacts only with adjacent layers. So in our discussion, the client layer interacts with our server layer (and vice versa), but there might be other server layers that help the primary server process a request that the client does not directly communicate with. Rather, the server passes on the request as necessary.Now, if all of this sounds familiar, then great. The Hypertext Transfer Protocol (HTTP), which defines the communication protocol via the World Wide Web is an implementation of the abstract notion of RESTful architecture (or an instance of the REST class if you\'re an OOP fanatic like me). In this implementation of REST, the client and server interact via GET, POST, PUT, DELETE, etc., which are part of the universal language and the resources can be pointed to using URLs.Representational State Transfer (REST) is a software architecture style consisting of guidelines and best practices for creating scalable web services.REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture.REST has gained widespread acceptance across the Web[citation needed] as a simpler alternative to SOAP and WSDL-based Web services. RESTful systems typically, but not always, communicate over the Hypertext Transfer Protocol with the same HTTP verbs (GET, POST, PUT, DELETE, etc.) used by web browsers to retrieve web pages and send data to remote servers.The REST architectural style was developed by W3C Technical Architecture Group (TAG) in parallel with HTTP 1.1, based on the existing design of HTTP 1.0. The World Wide Web represents the largest implementation of a system conforming to the REST architectural style.Architectural constraintsThe architectural properties of REST are realized by applying specific interaction constraints to components, connectors, and data elements. The formal REST constraints are:Client\xe2\x80\x93serverA uniform interface separates clients from servers. This separation of concerns means that, for example, clients are not concerned with data storage, which remains internal to each server, so that the portability of client code is improved. Servers are not concerned with the user interface or user state, so that servers can be simpler and more scalable. Servers and clients may also be replaced and developed independently, as long as the interface between them is not altered.StatelessThe client\xe2\x80\x93server communication is further constrained by no client context being stored on the server between requests. Each request from any client contains all the information necessary to service the request, and session state is held in the client. The session state can be transferred by the server to another service such as a database to maintain a persistent state for a period and allow authentication. The client begins sending requests when it is ready to make the transition to a new state. While one or more requests are outstanding, the client is considered to be in transition. The representation of each application state contains links that may be used the next time the client chooses to initiate a new state-transition.CacheableAs on the World Wide Web, clients can cache responses. Responses must therefore, implicitly or explicitly, define themselves as cacheable, or not, to prevent clients from reusing stale or inappropriate data in response to further requests. Well-managed caching partially or completely eliminates some client\xe2\x80\x93server interactions, further improving scalability and performance.Layered systemA client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way. Intermediary servers may improve system scalability by enabling load balancing and by providing shared caches. They may also enforce security policies.Code on demand (optional)Servers can temporarily extend or customize the functionality of a client by the transfer of executable code. Examples of this may include compiled components such as Java applets and client-side scripts such as JavaScript. "Code on demand" is the only optional constraint of the REST architecture.Uniform interfaceThe uniform interface constraint is fundamental to the design of any REST service.The uniform interface simplifies and decouples the architecture, which enables each part to evolve independently.REST is an architectural pattern and style of writing distributed applications. It is not a programming style in the narrow sense.Saying you use the REST style is similar to saying that you built a house in a particular style: for example Tudor or Victorian.  Both REST as an software style and Tudor or Victorian as a home style can be defined by the qualities and constraints that make them up. For example REST must have Client Server separation where messages are self-describing. Tudor style homes have Overlapping gables and Roofs that are steeply pitched with front facing gables. You can read Roy\'s dissertation to learn more about the constraints and qualities that make up REST.REST unlike home styles has had a tough time being consistently and practically applied. This may have been intentional. Leaving its actual implementation up to the designer. So you are free to do what you want so as long as you meet the constraints set out in the dissertation you are creating REST Systems.Bonus:The entire web is based on REST (or REST was based on the web). Therefore as a web developer you might want aware of that although it\'s not necessary to write good web apps. I think the point of restful is the separation of the statefulness into a higher layer while making use of the internet (protocol) as a stateless transport layer. Most other approaches mix things up. It\'s been the best practical approach to handle the fundamental changes of programming in internet era. Regarding the fundamental changes, Erik Meijer has a discussion on show here: http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197 . He summarizes it as the five effects, and presents a solution by designing the solution into a programming language. The solution, could also be achieved in the platform or system level, regardless of the language. The restful could be seen as one of the solutions that has been very successful in the current practice. With restful style, you get and manipulate the state of the application across an unreliable internet. If it fails the current operation to get the correct and current state, it needs the zero-validation principal to help the application to continue. If it fails to manipulate the state, it usually uses multiple stages of confirmation to keep things correct. In this sense, rest is not itself a whole solution, it needs the functions in other part of the web application stack to support its working. Given this view point, the rest style is not really tied to internet or web application. It\'s a fundamental solution to many of the programming situations. It is not simple either, it just makes the interface really simple, and copes with other technologies amazingly well. Just my 2c. Edit: Two more important aspects: Statelessness is misleading. It is about the restful API, not the application or system. The system needs to be stateful. Restful design is about designing a stateful system based on a stateless API. Some quotes from another QA: Idempotence: An often-overlooked part of REST is the idempotency of most verbs. That leads to robust systems and less interdependency of exact interpretations of the semantics. Quote from another post: "There is not such notion as "RESTful programming" per se. It would be better called RESTful paradigm or even better RESTful architecture. It is not a programming language. It is a paradigm.From Wikipedia:In computing, representational state transfer (REST) is an\n  architectural style used for web development.This is amazingly long "discussion" and yet quite confusing to say the least.IMO:1) There is no such a thing as restful programing, without a big joint and lots of beer :)2) Representational State Transfer (REST) is an architectural style specified in the dissertation of Roy Fielding.\nIt has a number of constraints.  If your Service/Client respect those then it is RESTful. This is it. You can summarize(significantly) the constraints to :There is another very good post which explains things nicely.A lot of answers copy/pasted valid information mixing it and adding some confusion. People talk here about levels, about RESTFul URIs(there is not such a thing!), apply HTTP methods GET,POST,PUT ... REST is not about that or not only about that.For example links - it is nice to have a beautifully looking API but at the end the client/server does not really care of the links you get/send it is the content that matters. In the end any RESTful client should be able to consume to any RESTful service as long as the content format is known.The point of rest is that if we agree to use a common language for basic operations (the http verbs), the infrastructure can be configured to understand them and optimize them properly, for example, by making use of caching headers to implement caching at all levels.With a properly implemented restful GET operation, it shouldn\'t matter if the information comes from your server\'s DB, your server\'s memcache, a CDN, a proxy\'s cache, your browser\'s cache or your browser\'s local storage. The fasted, most readily available up to date source can be used.Saying that Rest is just a syntactic change from using GET requests with an action parameter to using the available http verbs makes it look like it has no benefits and is purely cosmetic. The point is to use a language that can be understood and optimized by every part of the chain. If your GET operation has an action with side effects, you have to skip all HTTP caching or you\'ll end up with inconsistent results.REST stands for Representational state transfer.It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.REST is often used in mobile applications, social networking Web sites, mashup tools and automated business processes. The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique universal resource indicators (URIs). Introduction about RestOld question, newish way of answering.  There\'s a lot of misconception out there about this concept.  I always try to remember:I define restful programming as An application is restful if it provides resources (being the combination of data + state transitions controls) in a media type the client understandsTo be a restful programmer you must be trying to build applications that allow actors to do things.  Not just exposing the database.State transition controls only make sense if the client and server agree upon a media type representation of the resource.  Otherwise there\'s no way to know what\'s a control and what isn\'t and how to execute a control.  IE if browsers didn\'t know  tags in html then there\'d be nothing for you to submit to transition state in your browser.  I\'m not looking to self promote, but i expand on these ideas to great depth in my talk http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html .Talking is more than simply exchanging information. A Protocol is actually designed so that no talking has to occur. Each party knows what their particular job is because it is specified in the protocol. Protocols allow for pure information exchange at the expense of having any changes in the possible actions. Talking, on the other hand, allows for one party to ask what further actions can be taken from the other party. They can even ask the same question twice and get two different answers, since the State of the other party may have changed in the interim. Talking is RESTful architecture. Fielding\'s thesis specifies the architecture that one would have to follow if one wanted to allow machines to talk to one another rather than simply communicate.REST === HTTP analogy is not correct until you do not stress to the fact that it "MUST" be HATEOAS driven. Roy himself cleared it here.A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user\xe2\x80\x99s manipulation of those representations. The transitions may be determined (or limited by) the client\xe2\x80\x99s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]What is API Testing?API testing utilizes programming to send calls to the API and get the yield. It testing regards the segment under test as a black box. The objective of API testing is to confirm right execution and blunder treatment of the part preceding its coordination into an application.REST APIREST: Representational State Transfer.  4 Commonly Used API Methods:- Steps to Test API Manually:-To use API manually, we can use browser based REST API plugins.  Steps to Automate REST API This is very less mentioned everywhere but the Richardson\'s Maturity Model is one of the best methods to actually judge how Restful is one\'s API. More about it here:Richardson\'s Maturity ModelREST is an architectural style which is based on web-standards and the HTTP protocol. This style was initially described by Roy Fielding in 2000. In a REST based architecture everything is a resource. A resource is accessed via a common interface based on the HTTP standard methods. In a REST based architecture you have a REST server which provides access to the resources. A REST client can access and modify the REST resources.Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs).REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).HTTP methods:The PUT, GET, POST and DELETE methods are typical used in REST based architectures. The following table gives an explanation of these operations.REST is a distributed systems (such as WWW) software architecture style, you can imagine that it is a well-designed Web application rules: a group of Internet Web pages (a virtual state machine), in which hyperlink by clicking link (state transition), the result is the next Web page (which means the next state of the application).REST describes the network system consists of three parts:REST strictly meet the following conditions: