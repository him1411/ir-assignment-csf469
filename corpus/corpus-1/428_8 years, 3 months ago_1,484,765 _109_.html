Is there a better way to engineer a sleep in JavaScript than the following pausecomp function (taken from here)?This is not a duplicate of Sleep in Javascript - delay between actions; I want a real sleep in the middle of a function, and not a delay before a piece of code executes.Since 2009 when this question was asked, JavaScript has evolved significantly. All other answers are now obsolete or overly complicated. Here is the current best practice:You can try this code live on Runkit. Note that,Two new JavaScript features helped write this actual "sleep" function:If for some reason you\'re using Node older than 7, or are targeting old browsers, async/await can still be used via Babel (a tool that will transpile JavaScript + new features into plain old JavaScript), with the transform-async-to-generator plugin. RunCreate .babelrc with:Then run your code withBut again, you don\'t need this if you\'re using Node 7 or later, or if you\'re targeting modern browsers.(See the updated answer for 2016)I think it\'s perfectly reasonable to want to perform an action, wait, then perform another action. If you are used to writing in multi-threaded languages, you probably have the idea of yielding execution for a set amount of time until your thread wakes up.The issue here is that JavaScript is a single-thread event-based model. While in a specific case, it might be nice to have the whole engine wait for a few seconds, in general it is bad practice. Suppose I wanted to make use of your functions while writing my own? When I called your method, my methods would all freeze up. If JavaScript could somehow preserve your function\'s execution context, store it somewhere, then bring it back and continue later, then sleep could happen, but that would basically be threading.So you are pretty much stuck with what others have suggested -- you\'ll need to break your code up into multiple functions.Your question is a bit of a false choice, then. There is no way to sleep in the way you want, nor should you pursue the solution you suggest.In JavaScript, I rewrite every function so that it can end as soon as possible. You want the browser back in control so it can make your DOM changes.Every time I\'ve wanted a sleep in the middle of my function, I refactored to use a setTimeout().I am going to edit this answer because i found this as useful:The infamous sleep, or delay, function within any language is much debated.  Some will say that there should always be a signal or callback to fire a given functionality, others will argue that sometimes an arbitrary moment of delay is useful.  I say that to each their own and one rule can never dictate anything in this industry.Writing a sleep function is simple and made even more usable with JavaScript Promises:only for debug/dev , I post this if it\'s useful to someoneInteresting stuff, in Firebug ( & probably other js consoles ), nothing happen after hitting enter, only after the sleep duration specified (...)Example of use:I agree with the other posters, a busy sleep is just a bad idea.However, setTimeout does not hold up execution, it executes the next line of the function immediately after the timeout is SET, not after the timeout expires, so that does not accomplish the same task that a sleep would accomplish.The way to do it is to breakdown your function in to before and after parts. Make sure your function names still accurately describe what each piece is doing (I.E. GatherInputThenWait and CheckInput, rather than funcPart1 and funcPart2)Edit This method achieves the purpose of not executing the lines of code you decide until AFTER your timeout, while still returning control back to the client PC to execute whatever else it has queued up.Further EditAs pointed out in the comments this will absolutely NOT WORK in a loop. You could do some fancy (ugly) hacking to make it work in a loop, but in general that will just make for disastrous spaghetti code.For the love of $DEITY please do not make a busy-wait sleep function.  setTimeout and setInterval do everything you need.I know this is a bit of an old question, but if (like me) you\'re using Javascript with Rhino, you can use...If you\'re using jQuery, someone actually created a "delay" plugin that\'s nothing more than a wrapper for setTimeout:You can then just use it in a row of function calls as expected:I\'ve searched for sleep solution too (not for production code, only for dev/tests) and found this article:http://narayanraman.blogspot.com/2005/12/javascript-sleep-or-wait.html...and here\'s another link with client-side solutions: http://www.devcheater.com/Also, when you are calling alert(), your code will be paused too, while alert is shown -- need to find a way to not display alert but get the same effect. :)Here you go.  As the code says, don\'t be a bad dev and use this on websites.  It\'s a development utility function.Here\'s a simple solution using a synchronous XMLHttpRequest:contents of sleep.php:Now call it with:\nsleep(5);First:Define a function you want to execute like this:Then schedule its execution with the setTimeout method:Note two thingsBetter solution to make things look like what most people want is to use an anonymous function:This is probably the closest you\'ll get to something that simply does what you want.Note, if you need multiple sleeps this can get ugly in a hurry and you might actually need to rethink your design.I have searched/googled quite a few webpages on javascript sleep/wait... and there is NO answer if you want javascript to "RUN, DELAY, RUN"... what most people got was either, "RUN, RUN(useless stuff), RUN" or "RUN, RUN + delayed RUN"....So I ate some burgers and got thinking:::\nhere is a solution that works... but you have to chop up your running codes...:::\nyes, I know, this is just an easier to read refactoring... still...//.........................................\n//example1://....................................\n//example2://.................\nexample3://..............\nexample4:For browsers, I agree that setTimeout and setInterval are the way to go.But for server-side code, it may require a blocking function (for example, so you can effectively have thread synchronization).If you\'re using node.js and meteor, you may have run into the limitations of using setTimeout in a fiber. Here is the code for server-side sleep.See: https://github.com/laverdet/node-fibers#sleepMost of the answers here are misguided or at the very least outdated. There is no reason javascript has to be single threaded, and indeed it isnt\'t. Today all the mainstream browsers support workers, before this was the case other javascript runtimes like Rhino and Node.js supported multithreading.\'Javascript is single threaded\' is not a valid answer. For example running a sleep function within a worker would not block any of the code running in the ui thread.In newer runtimes supporting generators and yield, one could bring similar functionality to the sleep function in a single threaded environment:This imitation of sleep is different from a true sleep function as it does not block the thread. It is simply sugar on top of javascript\'s current setTimeout function. This functionality type has been implemented in Task.js and should work today in Firefox.I would encapsulate setTimeOut in a Promise for code consistency with other asynchronous tasks : Demo in FiddleUsed like that :It is easy to remember syntax if you used to use Promises.I personally like the simple:then:I\'m using it all the time to create fake load time while creating scripts in P5jsI can understand the purpose of a sleep function if you have to deal with synchronous execution. The setInterval and setTimeout functions create a parallel execution thread which returns the execution sequence back to the main program, which is ineffective if you have to wait for a given result. Of course one may use events and handlers, but in some cases is not what is intended.You can\'t do a sleep like that in JavaScript, or, rather, you shouldn\'t. Running a sleep or a while loop will cause the user\'s browser to hang until the loop is done.Use a timer, as specified in the link you referenced. One scenario where you might want a sleep() function rather than using setTimeout() is if you have a function responding to a user click that will ultimately end up opening a new i.e. popup window and you have initiated some processing that requires a short period to complete before the popup is displayed. Moving the open window into a closure means that it typically gets blocked by the browser.It can be done using Java\'s sleep method. I\'ve tested it in FF and IE and it doesn\'t lock the computer, chew up resources, or cause endless server hits. Seems like a clean solution to me.First you have to get Java loaded up on the page and make its methods available. To do that, I did this:Then, all you have to do when you want a painless pause in your JS is:Where xxx is time in milliseconds. In my case (by way of justification), this was part of back-end order fulfillment at a very small company and I needed to print an invoice that had to be loaded from the server. I did it by loading the invoice (as a webpage) into an iFrame and then printing the iFrame. Of course, I had to wait until the page was fully loaded before I could print, so the JS had to pause. I accomplished this by having the invoice page (in the iFrame) change a hidden form field on the parent page with the onLoad event.  And the code on the parent page to print the invoice looked like this (irrelevant parts cut for clarity):So the user pushes the button, the script loads the invoice page, then waits, checking every quarter second to see if the invoice page is finished loading, then pops up the print dialog for the user to send it to the printer.  QED.A lot of the answers don\'t (directly) answer the question, and neither does this one...Here\'s my two cents (or functions):If you want less clunky functions than setTimeout and setInterval, you can wrap them in functions that just reverse the order of the arguments and give them nice names:CoffeeScript versions:You can then use them nicely with anonymous functions:Now it reads easily as "after N milliseconds, ..." (or "every N milliseconds, ...")For the specific case of wanting to space out a set of calls being executed by a loop, you can use something like the code below with prototype. Without prototype, you can substitute the delay function with setTimeout.Adding my two bits. I needed a busy-wait for testing purposes. I didn\'t want to split the code as that would be a lot of work, so a simple for did it for me. I don\'t see any downside in doing this and it did the trick for me.If you\'re on node.js, you can have a look at fibers \xe2\x80\x93 a native C extension to node, a kinda-multi-threading simulation.It allows you to do a real sleep in a way which is blocking execution in a fiber, but it\'s non-blocking in the main thread and other fibers.Here\'s an example fresh from their own readme:\xe2\x80\x93 and the results are:An old question from 2009.  Now in 2015 a new solution is possible with generators defined in ECMAscript 2015 aka ES6.  It was approved in June, but it was implemented in Firefox and Chrome before.  Now a sleep function can be made non-busy, non-blocking and nested inside loops and sub-functions without freezing the browser.  Only pure JavaScript is needed, no libraries or frameworks.The program below shows how sleep() and runSleepyTask() can be made.  The sleep() function is only a yield statement.  It is so simple that it is actually easier to write the yield statement directly in stead of calling sleep(), but then there would be no sleep-word :-)  The yield returns a time value to the next() method inside wakeup() and waits.  The actual "sleeping" is done in wakeup() using the good old setTimeout().  At callback the the next() method triggers the yield statement to continue, and the "magic" of yield is that all the local variables and the whole call-stack around it is still intact.Functions that use sleep() or yield must be defined as generators.  Easy done by adding an asterix to the keyword function*.  To execute a generator is a bit trickier.  When invoked with the keyword new the generator returns an object that has the next() method, but the body of the generator is not executed (the keyword new is optional and makes no difference).  The next() method triggers execution of the generator body until it encounters a yield.  The wrapper function runSleepyTask() starts up the ping-pong: next() waits for a yield, and yield waits a next().Another way to invoke a generator is with keyword yield*, here it works like a simple function call, but it also includes the ability to yield back to next().This is all demonstrated by the example drawTree().  It draws a tree with leaves on a rotating 3D scene.  A tree is drawn as a trunk with 3 parts at the top in different directions.  Each part is then drawn as another but smaller tree by calling drawTree() recursively after a short sleep.  A very small tree is drawn as only a leaf.Each leaf has its own life in a separate task started with runSleepyTask().  It is born, grows, sits, fades, falls and dies in growLeaf().  The speed is controlled with sleep().  This demonstrates how easy multitasking can be done.The 3D stuff is hidden inside setup3D() and is only included to make it less boring than console.log().  Angels are measured in radians by the way.Tested to work in Firefox and Chrome.  Not implemented in Internet Explore and iOS (iPads).  Try to run it yourself.After another pass of the answers I found, that Gabriel Ratener made a similar answer a year ago: https://stackoverflow.com/a/24401317/5032384 First of all - setTimeout and setInterval is what should be used, because of javascript\'s callback-ish nature. If you want to use sleep() it\'s the control flow or the architecture of your code that is incorrect.Having said that I suppose I still can help with two implementation of a sleep.faking synchronous run off the top of my head:[making playback automatic should also be possible]real synchronous runI gave it a lot of thought one day and the only idea I had for a true sleep in javascript is technical.a sleep function would have to be a synchronous AJAX call with a timeout set to the sleep value. That\'s all and an only way to have a real sleep()Code taken from this link will not freeze comp. But it works only on ff.