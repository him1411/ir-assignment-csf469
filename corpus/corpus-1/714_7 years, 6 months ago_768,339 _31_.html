I\'ve been trying to find a way to write to a file when using Node.js, but with no success. How can I do that?There are a lot of details in the filesystem API. The most common way (as far as I know) is:Currently there are three ways to write a file:fs.write(fd, buffer, offset, length, position, callback)You need to wait for the callback to ensure that the buffer is written to disk. It\'s not buffered.fs.writeFile(filename, data, [encoding], callback)All data must be stored at the same time; you cannot perform sequential writes.fs.createWriteStream(path, [options])Creates a WriteStream, which is convenient because you don\'t need to wait for a callback. But again, it\'s not buffered.A WriteStream, as the name says, is a stream. A stream by definition is \xe2\x80\x9ca buffer\xe2\x80\x9d containing data which moves in one direction (source \xe2\x96\xba destination). But a writable stream is not necessarily \xe2\x80\x9cbuffered\xe2\x80\x9d. A stream is \xe2\x80\x9cbuffered\xe2\x80\x9d when you write n times, and at time n+1, the stream sends the buffer to the kernel (because it\'s full and needs to be flushed).In other words: \xe2\x80\x9cA buffer\xe2\x80\x9d is the object. Whether or not it \xe2\x80\x9cis buffered\xe2\x80\x9d is a property of that object.If you look at the code, the WriteStream inherits from a writable Stream object. If you pay attention, you\xe2\x80\x99ll see how they flush the content; they don\'t have any buffering system.If you write a string, it\xe2\x80\x99s converted to a buffer, and then sent to the native layer and written to disk. When writing strings, they\'re not filling up any buffer. So, if you do:You\'re doing:That\xe2\x80\x99s three calls to the I/O layer. Although you\'re using \xe2\x80\x9cbuffers\xe2\x80\x9d, the data is not buffered. A buffered stream would do: fs.write(new Buffer ("abc")), one call to the I/O layer.As of now, in Node.js v0.12 (stable version announced 02/06/2015) now supports two functions:\ncork() and\nuncork(). It seems that these functions will finally allow you to buffer/flush the write calls.For example, in Java there are some classes that provide buffered streams (BufferedOutputStream, BufferedWriter...). If you write three bytes, these bytes will be stored in the buffer (memory) instead of doing an I/O call just for three bytes. When the buffer is full the content is flushed and saved to disk. This improves performance.I\'m not discovering anything, just remembering how a disk access should be done.You can of course make it a little more advanced. Non-blocking, writing bits and pieces, not writing the whole file at once:I liked Index of ./articles/file-system.It worked for me.See also How do I write files in node.js?.Contents of helloworld.txt:Update:\nAs in Linux node write in current directory , it seems in some others don\'t, so I add this comment just in case :\nUsing this ROOT_APP_PATH = fs.realpathSync(\'.\'); console.log(ROOT_APP_PATH); to get where the file is written.For example : read file and write to another file :Here we use w+ for read/write both actions and if the file path is not found the it would be created automatically.Content means what you have to write to the file and its length, \'content.length\'.You can use library easy-file-managerinstall first from npm\nnpm install easy-file-managerSample to upload and remove filesHere is the sample of how to read file csv from local and write csv file to local.