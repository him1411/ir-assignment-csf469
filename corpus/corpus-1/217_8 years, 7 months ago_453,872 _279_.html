I\'m not that into dynamic programming languages, but I\'ve written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works? I remember a lot discussion I had with people a while back (I\'m not exactly sure what I\'m doing) but as I understand it, there\'s no concept of a class. It\'s just an object, and instances of those objects are clones of the original, right?But what is the exact purpose of this .prototype property in JavaScript? How does it relate to instantiating objects?These slides really helped a lot to understand this topic.Every JavaScript object has an internal property called [[Prototype]]. If you look up a property via obj.propName or obj[\'propName\'] and the object does not have such a property - which can be checked via obj.hasOwnProperty(\'propName\') - the runtime looks up the property in the object referenced by [[Prototype]] instead. If the prototype-object also doesn\'t have such a property, its prototype is checked in turn, thus walking the original object\'s prototype-chain until a match is found or its end is reached.Some JavaScript implementations allow direct access to the [[Prototype]] property, eg via a non-standard property named __proto__. In general, it\'s only possible to set an object\'s prototype during object creation: If you create a new object via new Func(), the object\'s [[Prototype]] property will be set to the object referenced by Func.prototype.This allows to simulate classes in JavaScript, although JavaScript\'s inheritance system is - as we have seen - prototypical, and not class-based:Just think of constructor functions as classes and the properties of the prototype (ie of the object referenced by the constructor function\'s prototype property) as shared members, ie members which are the same for each instance. In class-based systems, methods are implemented the same way for each instance, so methods are normally added to the prototype, whereas an object\'s fields are instance-specific and therefore added to the object itself during construction.In a language implementing classical inheritance like Java, C# or C++ you start by creating a class--a blueprint for your objects--and then you can create new objects from that class or you can extend the class, defining a new class that augments the original class.In JavaScript you first create an object (there is no concept of class), then you can augment your own object or create new objects from it. It\'s not difficult, but a little foreign and hard to metabolize for somebody used to the classical way.Example:Until now I\'ve been extending the base object, now I create another object and then inheriting from Person.While as said I can\'t call setAmountDue(), getAmountDue() on a Person.I play a role as a JavaScript teacher and the prototype concept has always been a controversial topic to cover when I teach. It took me a while to come up with a good method to clarify the concept, and now in this text I\'m gonna be trying to explain How does JavaScript .prototype work.This is a very simple prototype based object model that would be considered as a sample during the explanation, with no comment yet:There are some crucial points that we have to consider before going through the prototype concept.To take the first step we have to figure out, how JavaScript functions actually work , as a class like function using this keyword in it or just as a regular function with its arguments, what it does and what it returns.Let\'s say we want to create a Person object model. but in this step I\'m gonna be trying to do the same exact thing without using prototype and new keyword.So in this step functions, objects and this keyword, are all we have.The first question would be how this keyword could be useful without using new keyword.So to answer that let\'s say we have an empty object, and two functions like:and now without using new keyword how we could use these functions. So JavaScript has 3 different ways to do that:in this case, this would be the current context object, which is usually is the global  window object in the browser or GLOBAL in Node.js. It means we would have, window.name in browser or GLOBAL.name in Node.js, with "George" as its value.-The easiest way to do this is modifying the empty person object, like:this way we can call them like:and now the person object is like:-The other way to attach a property to an object is using the prototype of that object that can be find in any JavaScript object with the name of __proto__, and I have tried to explain it a bit on the summary part. So we could get the similar result by doing:But this way what we actually are doing is modifying the Object.prototype, because whenever we create a JavaScript object using literals ({ ... }), it gets created based on Object.prototype, which means it gets attached to the newly created object as an attribute named __proto__ , so if we change it, as we have done on our previous code snippet, all the JavaScript objects would get changed, not a good practice. So what could be the better practice now:and now other objects are in peace, but it still doesn\'t seem to be a good practice. So we have still one more solutions, but to use this solution we should get back to that line of code where person object got created (var person = {};) then change it like:what it does is creating a new JavaScript Object and attach the propertiesObject to the __proto__ attribute. So to make sure you can do:But the tricky point here is you have access to all the properties defined in __proto__ on the first level of the person object(read the summary part for more detail).as you see using any of these two way this would exactly point to the person object.The apply() method calls a function with a given this value and\n  arguments provided as an array (or an array-like object).andThe call() method calls a function with a given this value and\n  arguments provided individually.this way which is my favorite, we can easily call our functions like:orthese 3 methods are the important initial steps to figure out the .prototype functionality.this is the second step to understand the .prototype functionality.this is what I use to simulate the process:in this part I\'m gonna be trying to take all the steps which JavaScript takes, without using the new keyword and prototype, when you use new keyword. so when we do new Person("George"), Person function serves as a constructor, These are what JavaScript does, one by one:we have my_person_prototype here similar to the prototype object.It is not the way that JavaScript actually attaches the properties that are defined in the prototype. The actual way is related to the prototype chain concept.now we can call the getName function in our my_person_prototype:we can do this with our sample like:orthen the constructor can do whatever it wants, because this inside of that constructor is the object that was just created.now the end result before simulating the other steps:\n    Object {name: "George"}Basically, when you use the new keyword on a function, you are calling on that and that function serves as a constructor, so when you say:JavaScript internally makes an object, an empty hash and then it gives that object to the constructor, then the constructor can do whatever it wants, because this inside of that constructor is the object that was just created and then it gives you that object of course if you haven\'t used the return statement in your function or if you\'ve put a return undefined; at the end of your function body.So when JavaScript goes to look up a property on an object, the first thing it does, is it looks it up on that object. And then there is a secret property [[prototype]] which we usually have it like __proto__ and that property is what JavaScript looks at next. And when it looks through the __proto__, as far as it is again another JavaScript object, it has its own __proto__ attribute, it goes up and up until it gets to the point where the next __proto__ is null. The point is the only object in JavaScript that its __proto__ attribute is null is Object.prototype object:and that\'s how inheritance works in JavaScript.In other words, when you have a prototype property on a function and you call a new on that, after JavaScript finishes looking at that newly created object for properties, it will go look at the function\'s .prototype and also it is possible that this object has its own internal prototype. and so on.prototype allows you to make classes. if you do not use prototype then it becomes a static.Here is a short example.In the above case, you have static funcation call test. This function can be accessed only by obj.test where you can imagine obj to be a class.where as in the below codeThe obj has become a class which can now be instantiated. Multiple instances of obj can exist and they all have the test function.The above is my understanding. I am making it a community wiki, so people can correct me if I am wrong.After reading this thread, I feel confused with JavaScript Prototype Chain, then I found these charts http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance\nit\'s a clear chart to show JavaScript Inheritance by Prototype Chainand http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/this one contains a example with code and several nice diagrams.prototype chain ultimately falls back to Object.prototype. prototype chain can be technically extended as long as you want, each time by setting the prototype of the subclass equal to an object of the parent class.Hope it\'s also helpful for you to understand JavaScript Prototype Chain.0) Two different things can be called "prototype":the prototype property, as in obj.prototypethe prototype internal property, denoted as [[Prototype]] in ES5.It can be retrieved via the ES5 Object.getPrototypeOf().Firefox makes it accessible through the __proto__ property as an extension. ES6 now mentions some optional requirements for __proto__.1) Those concepts exist to answer the question:When I do obj.property, where does JS look for .property?Intuitively, classical inheritance should affect property lookup.2)Lookup order is:This is the so-called prototype chain.You can avoid . lookup with obj.hasOwnProperty(\'key\') and Object.getOwnPropertyNames(f)3) There are two main ways to set obj.__proto__:new:then new has set:This is where .prototype gets used.Object.create:sets:4) The code:Corresponds to the following diagram:This diagram shows many language predefined object nodes: null, Object, Object.prototype, Function and Function.prototype. Our 2 lines of code only created f, F and F.prototype.5) .constructor normally comes from F.prototype through the . lookup:When we write f.constructor, JavaScript does the . lookup as:The result f.constructor == F is intuitively correct, since F is used to construct f, e.g. set fields, much like in classic OOP languages. 6) Classical inheritance syntax can be achieved by manipulating prototypes chains.ES6 adds the class and extends keywords, which are simply syntax sugar for previously possible prototype manipulation madness.Simplified diagram without all predefined objects:Every object has an internal property, [[Prototype]], linking it to another object:Some environments expose that property as __proto__:You create the [[Prototype]] link when creating an object:In traditional javascript, the linked object is the prototype property of a function:and you create the [[Prototype]] link with new:So these statements are equivalent:Note that the link target (Object.prototype) appears only in the Object.create call.Remember:Javascript doesn\'t have inheritance in the usual sense, but it has the prototype chain.If a member of an object can\'t be found in the object it looks for it in the prototype chain. The chain consists of other objects. The prototype of a given instance can be accessed with the __proto__ variable. Every object has one, as there is no difference between classes and instances in javascript.The advantage of adding a function / variable to the prototype is that it has to be in the memory only once, not for every instance.It\'s also useful for inheritance, because the prototype chain can consist of many other objects.This article is long. But I am sure it will clear most of your queries \nregarding the "prototypical" nature of JavaScript Inheritance. And even more. Please read the complete article.JavaScript basically has two kinds of data typesNon objectsFollowing are the Non object data typesThese data types return following when you use the typeof operator typeof "string literal" (or a variable containing string literal)  === \'string\'typeof 5 (or any numeric literal or a variable containing numeric literal or NaN or Infynity)  === \'number\'typeof true (or false or a variable containing true or false)  === \'boolean\'typeof undefined (or an undefined variable or a variable containing undefined) === \'undefined\'The string,number and boolean data types can be represented both as Objects and Non objects.When they are represented as objects their typeof is always === \'object\'. We shall come back to this once we understand the object data types.ObjectsThe object datatypes can be further divided into two typesThe Function type objects are the ones that return the string \'function\' with typeof operator. \nAll the user defined functions and all the JavaScript built in objects that can create new objects by using new operator fall into this category. For eg.So,\ntypeof(Object) === typeof(String) === typeof(Number) === typeof(Boolean) === typeof(Array)  === typeof(RegExp) === typeof(Function)  === typeof(UserDefinedFunction) === \'function\'All the Function type objects are actually instances of the built in JavaScript object Function (including the Function object i.e it is recursively defined). It is as if the these objects have been defined in the following wayAs mentioned, the Function type objects can further create new objects using the new operator. For e.g an object of type Object, String, Number, Boolean, Array, RegExp  Or UserDefinedFunction can be created by usingThe objects thus created are all Non Function type objects and return their typeof===\'object\'. In all these cases the object "a" cannot further create \nobjects using operator new. So the following is wrongThe built in object Math is typeof===\'object\'. Hence a new object of type Math cannot be created by new operator.Also notice that Object,Array and RegExp functions can create a new object without even using operator new. However the follwing ones don\'t.The user defined functions are special case. Since the Function type objects can create new objects they are also called Constructors.Every Constructor/Function (whether built in or user defined) when defined automatically has a property called "prototype" whose value by default is set as an object. This object itself has a property called "constructor" which by default references back the Constructor/Function .For example when we define a functionfollowing automatically happensThis "prototype" property is only present in the Function type objects \n(and never in Non Function type objects). This is because when a new object is created (using new operator)it inherits all properties and methods from Constructor function\'s current prototype object i.e. an internal reference is created in the newly created object that references the object referenced by Constructor function\'s current prototype object.This "internal reference" that is created in the object for referencing inherited properties is known as the object\'s prototype (which references the object referenced by Constructor\'s "prototype" property but is different from it). For any object (Function or Non Function) this can be retrieved using Object.getPrototypeOf() method. Using this method one can trace the prototype chain of an object. Also, every object that is created (Function type or Non Function type) has a "constructor" property which is inherited from the object referenced by prototype  property of the Constructor function. By default this "constructor" property references the Constructor function that created it (if the Constructor Function\'s default "prototype" is not changed). For all Function type objects the constructor function is always\nfunction Function(){}For Non Function type objects (e.g Javascript Built in  Math object) the constructor function is the function that created it.\nFor Math object it is function Object(){}. All the concept explained above can be a little daunting to understand without any supporting code. Please go through the following code line by line to understand the concept. Try to execute it to have a better understanding.The prototype chain of every object ultimately traces back to Object.prototype (which itself does not have any prototype object) .\nFollowing code can be used for tracing the prototype chain of an objectThe prototype chain for various objects work out as follows.For creating an object without any prototype use the following:One might think that setting the prototype property of the Constructor to null shall create an object with a null prototype. However in such cases the newly created object\'s prototype is set to Object.prototype and its constructor is set to function Object. This is demonstrated by the following codeFollowing in the summary of this articleOnly Function type objects can create a new object using the operator new. The objects thus created are Non Function type objects. The Non Function type objects cannot further create an object using operator new.All Function type objects by default have a "prototype" property. This "prototype" property references an object that has a "constructor" property that by default references the Function type object itself.  All objects (Function type and Non Function type) have a "constructor" property that by default references the Function type object/Constructor that created it.Every object that gets created internally references the object referenced by\n"prototype" property of the Constructor that created it. This object is known as the created object\'s prototype (which is different from Function type objects "prototype" property which it references) . This way the created object can directly access the methods and properties defined in object referenced by the Constructor\'s "prototype" property (at the time of object creation).An object\'s prototype (and hence its inherited property names) can be retrieved using the Object.getPrototypeOf()   method. In fact this method \ncan be used for navigating the entire prototype chain of the object.The prototype chain of every object ultimately traces back to Object.prototype (Unless the object is created using Object.create(null) in which case the object has no prototype).typeof(new Array())===\'object\' is by design of language and not a mistake as pointed by Douglas Crockford Setting the prototype property of the Constructor to null(or undefined,number,true,false,string) shall not create an object with a null prototype. In such cases the newly created object\'s prototype is set to Object.prototype and its constructor is set to function Object. Hope this helps.The concept of prototypal inheritance is one of the most complicated for many developers. Let\'s try to understand the root of problem to understand prototypal inheritance better. Let\'s start with a plain function. If we use a new operator on the Tree function, we call it as a constructor function. Every JavaScript function has a prototype. When you log the Tree.prototype, you get...If you look at the above console.log() output, you could a see a constructor property on Tree.prototype and a __proto__ property too. The __proto__ represents the prototype that this function is based off, and since this is just a plain JavaScript function with no inheritance set up yet, it refers to the Object prototype which is something just built in to JavaScript...https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototypeThis has things like .toString, .toValue, .hasOwnProperty etc...__proto__ which was brought my mozilla is deprecated and is replaced by Object.getPrototypeOf method to get the object\'s prototype. Let\'s add a method to our Tree prototype. We have modified the Root and added a function branch to it. That means when you create an instance of Tree, you can call it\'s branch method.We can also add primitives or objects to our Prototype. Let\'s add a child-tree to our Tree. Here the Child inherits its prototype from Tree, what we are doing here is using Object.create() method to create a new object based off what you pass, here it is Tree.prototype. In this case what we\'re doing is setting the prototype of Child to a new object that looks identical to the Tree prototype. Next we are setting the Child\'s constructor to Child, if we don\'t it would point to Tree(). Child now has its own prototype, its __proto__ points to Tree and Tree\'s prototype points to base Object. Now you create an instance of Child and call branch which is originally available in Tree. We haven\'t actually defined our branch on the Child prototype. BUT, in the Root prototype which Child inherits from. In JS everything is not an object, everything can act like an object.Javascript has primitives like strings, number, booleans, undefined, null. They are not object(i.e reference types), but certainly can act like an object. Let\'s look at an example here.In the first line of this listing, a primitive string value is assigned to name. The second line treats name like an object and calls charAt(0) using dot notation.This is what happens behind the scenes:\n// what the JavaScript engine doesThe String object exists only for one statement before it\xe2\x80\x99s destroyed (a process called autoboxing). Let\'s again get back to our prototypal inheritance. A prototype in JS is an object which yields you to the parent of another object. [ie.. delegation] Delegation means that if you are unable to do something, you\xe2\x80\x99ll tell someone else to do it for you.https://jsfiddle.net/say0tzpL/1/If you look up the above fiddle, dog has access to toString method, but its not available in it, but available via the prototype chain which delegates to Object.prototypeIf you look at the below one, we are trying to access the call method which is available in every function.https://jsfiddle.net/rknffckc/If you look up the above fiddle, Profile Function has access to call method, but its not available in it, but available via the prototype chain which delegates to Function.prototypeNote: prototype is a property of the function constructor, whereas __proto__ is a property of the objects constructed from the function constructor. Every function comes with a prototype property whose value is an empty object. When we create an instance of the function, we get an internal property [[Prototype]] or __proto__ whose reference is the prototype of the Function constructor.The above diagram looks bit complicated, but brings out the whole picture on how prototype chaining works. Let\'s walk through this slowly:There are two instance b1 and b2, whose constructor is Bar and parent is Foo and has two methods from prototype chain identify and speak via Bar and Foohttps://jsfiddle.net/kbp7jr7n/If you look up the code above, we have Foo constructor who has the method identify() and Bar constructor which has speak method. We create two Bar instance b1 and b2 whose parent type is Foo. Now while calling speak method of Bar, we are able to identify the who is calling the speak via prototype chain. Bar now has all the methods of Foo which are defined in its prototype. Let\'s dig further in understanding the Object.prototype and Function.prototype and how they are related. If you look up the constructor of Foo, Bar and Object are Function constructor.The prototype of Bar is Foo, prototype of Foo is Object and if you look closely the prototype of Foo is related to Object.prototype.Before we close this down, let\'s just wrap with a small piece of code here to summarize everything above. We are using instanceof operator here to check whether an object has in its prototype chain the prototype property of a constructor which below summarizes the entire big diagram. I hope this add\'s some information, I know this kinda could be big to grasp... in simple words its it\'s just objects linked to objects!!!! what is the exact purpose of this ".prototype" property?The interface to standard classes become extensible. For example, you are using the Array class and you also need to add a custom serializer for all your array objects. Would you spend time coding up a subclass, or use composition or ... The prototype property solves this by letting the users control the exact set of members/methods available to a class.Think of prototypes as an extra vtable-pointer. When some members are missing from the original class, the prototype is looked up at runtime.The Definitive Guide to Object-Oriented JavaScript - a very concise and clear ~30min video explanation of the asked question (Prototypal Inheritance topic begins from 5:45, although I\'d rather listen to the whole video). The author of this video also made JavaScript object visualizer website http://www.objectplayground.com/.\nIt may help to categorise prototype chains into two categories.Consider the constructor:The value of Object.getPrototypeOf(Person) is a function. In fact, it is Function.prototype. Since Person was created as a function, it shares the same prototype function object that all functions have. It is the same as Person.__proto__, but that property should not be used. Anyway, with Object.getPrototypeOf(Person) you effectively walk up the ladder of what is called the prototype chain.The chain in upward direction looks like this:    Person \xe2\x86\x92 Function.prototype \xe2\x86\x92 Object.prototype (end point)Important is that this prototype chain has little to do with the objects that Person can construct. Those constructed objects have their own prototype chain, and this chain can potentially have no close ancestor in common with the one mentioned above.Take for example this object:p has no direct prototype-chain relationship with Person. Their relationship is a different one. The object p has its own prototype chain. Using Object.getPrototypeOf, you\'ll find the chain is as follows:    p \xe2\x86\x92 Person.prototype \xe2\x86\x92 Object.prototype (end point)There is no function object in this chain (although that could be).So Person seems related to two kinds of chains, which live their own lives. To "jump" from one chain to the other, you use:.prototype: jump from the constructor\'s chain to the created-object\'s chain. This property is thus only defined for function objects (as new can only be used on functions)..constructor: jump from the created-object\'s chain to the constructor\'s chain.Here is a visual presentation of the two prototype chains involved, represented as columns:To summarise:The prototype property gives no information of the subject\'s prototype chain, but of objects created by the subject. It is no surprise that the name of the property prototype can lead to confusion. It would maybe have been clearer if this property had been named prototypeOfConstructedInstances or something along that line.You can jump back and forth between the two prototype chains:This symmetry can be broken by explicitly assigning a different object to the prototype property (more about that later).Person.prototype is an object that was created at the same time the function Person was created. It has Person as constructor, even though that constructor did not actually execute yet. So two objects are created at the same time:Both are objects, but they have different roles: the function object constructs, while the other object represents the prototype of any object that function will construct. The prototype object will become the parent of the constructed object in its prototype chain.Since a function is also an object, it also has its own parent in its own prototype chain, but recall that these two chains are about different things. Here are some equalities that could help grasp the issue -- all of these print true:Although a prototype object is created when you create a constructor function, you can ignore that object, and assign another object that should be used as prototype for any subsequent instances created by that constructor.For instance:Now the prototype chain of t is one step longer than that of p:    t \xe2\x86\x92 p \xe2\x86\x92 Person.prototype \xe2\x86\x92 Object.prototype (end point)The other prototype chain is not longer: Thief and Person are siblings sharing the same parent in their prototype chain:    Person}\n    Thief  } \xe2\x86\x92 Function.prototype \xe2\x86\x92 Object.prototype (end point)The earlier presented graphic can then be extended to this (the original Thief.prototype is left out):The blue lines represent prototype chains, the other coloured lines represent other relationships:I found it helpful to explain the "prototype chain" as recursive convention when obj_n.prop_X is being referenced:if obj_n.prop_X doesn\'t exist, check obj_n+1.prop_X where obj_n+1 = obj_n.[[prototype]]If the prop_X is finally found in the k-th prototype object thenobj_1.prop_X = obj_1.[[prototype]].[[prototype]]..(k-times)..[[prototype]].prop_XYou can find a graph of the relation of Javascript objects by their properties here:  http://jsobjects.orgWhen a constructor creates an object, that object implicitly references the constructor\xe2\x80\x99s \xe2\x80\x9cprototype\xe2\x80\x9d property for the purpose of resolving property references. The constructor\xe2\x80\x99s \xe2\x80\x9cprototype\xe2\x80\x9d property can be referenced by the program expression constructor.prototype, and properties added to an object\xe2\x80\x99s prototype are shared, through inheritance, by all objects sharing the prototype.Let me tell you my understanding of prototypes. I am not going to compare the inheritance here with other languages. I wish people would stop comparing languages, and just understand the language as itself. Understanding prototypes and prototypal inheritance is so simple, as I will show you below.Prototype is like a model, based on which you create a product. The crucial point to understand is that when you create an object using another object as it\'s prototype, the link between the prototype and the product is ever-lasting. For instance:Every object contains an internal property called the [[prototype]], which can be accessed by the Object.getPrototypeOf() function. Object.create(model) creates a new object and sets it\'s [[prototype]] property to the object model. Hence when you do Object.getPrototypeOf(product), you will get the object model.Properties in the product are handled in the following way:Such a linking of objects using the prototype property is called prototypal inheritance. There, it is so simple, agree?Another attempt to explain JavaScript prototype-based inheritance with better picturesConsider the following keyValueStore object :I can create a new instance of this object by doing this :Each instance of this object would have the following public properties :Now, suppose we create 100 instances of this keyValueStore object. Even though get, set, delete, getLength will do the exact same thing for each of these 100 instances, every instance has its own copy of this function.Now, imagine if you could have just a single get, set, delete and getLength copy, and each instance would reference that same function. This would be better for performance and require less memory.That\'s where prototypes come in. A prototype is a "blueprint" of properties that is inherited but not copied by instances. So this means that it exists only once in memory for all instances of an object and is shared by all of those instances.Now, consider the keyValueStore object again. I could rewrite it like this :This does EXACTLY the same as the previous version of the keyValueStore object, except that all of its methods are now put in a prototype. What this means, is that all of the 100 instances now share these four methods instead of each having their own copy.I always like analogies when it comes to understand this type of stuff. \'Prototypal inheritance\' is pretty confusing in comparison to class bass inheritance in my opinion, even though prototypes are much simpler paradigm. In fact there really is no inheritance, so the name in and of itself misleading, it\'s more like prototypal delegation.Imagine this ....You\'re in high-school, and you\'re in class and have a test that\'s due today, but you don\'t have a pen to complete it. Ohshi-You have a best friend, Finnius Mcdinglebutt who might possibly have a pen? You ask, and he looks on his desk unsuccessfully, but instead of saying "Man, I don\'t have a pen", he\'s a nice friend he checks with his other friend Derp Derpington if he has a pen. Derp does have a pen and passes it back to Finnius, who passes it over to you to complete your test. Derp has entrusted the pen to Finnius, who has delegated the pen to you for use.This, is essentially how prototypes work in a nutshell.:~]