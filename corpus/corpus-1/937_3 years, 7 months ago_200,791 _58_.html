In Dockerfiles there are two commands that look similar to me: CMD and ENTRYPOINT. But I guess that there is a (subtle?) difference between them - otherwise it would not make any sense to have two commands for the very same thing.The documentation states for CMDThe main purpose of a CMD is to provide defaults for an executing container.and for ENTRYPOINT:An ENTRYPOINT helps you to configure a container that you can run as an executable.So, what\'s the difference between those two commands?Docker has a default entrypoint which is /bin/sh -c but does not have a default command.When you run docker like this:\ndocker run -i -t ubuntu bash\nthe entrypoint is the default /bin/sh -c, the image is ubuntu and the command is bash.  The command is run via the entrypoint. i.e., the actual thing that gets executed is /bin/sh -c bash. This allowed docker to implement RUN quickly by relying on the shell\'s parser.\nLater on, people asked to be able to customize this so ENTRYPOINT and -entrypoint has been introduced.Everything after ubuntu in the example above is the command and is passed to the entrypoint. When using the CMD instruction, it is exactly as if you were doing docker run -i -t ubuntu <cmd>. <cmd> will be the parameter of the entrypoint.You will also get the same result if you instead type this command docker run -i -t ubuntu. You will still start a bash shell in the container because of the ubuntu Dockerfile specified a default CMD: CMD ["bash"]As everything is passed to the entrypoint, you can have a very nice behavior from your images. @Jiri example is good, it shows how to use an image as a "binary". When using ["/bin/cat"] as entrypoint and then doing docker run img /etc/passwd, you get it, /etc/passwd is the command and is passed to the entrypoint so the end result execution is simply /bin/cat /etc/passwd.An other example would be to have any cli as entrypoint. For instance, if you have a redis image, instead of running docker run redisimg redis -H something -u toto get key, you can simply have ENTRYPOINT ["redis", "-H", "something", "-u", "toto"] and then run like this for the same result: docker run redisimg get key.The ENTRYPOINT specifies a command that will always be executed when the container starts.The CMD specifies arguments that will be fed to the ENTRYPOINT.If you want to make an image dedicated to a specific command you will use ENTRYPOINT ["/path/dedicated_command"]Otherwise, if you want to make an image for general purpose, you can leave ENTRYPOINT unspecified and use CMD ["/path/dedicated_command"] as you will be able to override the setting by supplying arguments to docker run.For example, if your Dockerfile is:Running the image without any argument will ping the localhost:Now, running the image with an argument will ping the argument:For comparison, if your Dockerfile is:Running the image without any argument will ping the localhost:But running the image with an argument will run the argument:See this article from Brian DeHamer for even more details:\nhttps://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/Yes, that is a good question. I don\'t understand it fully yet, but:I understand that ENTRYPOINT is the binary that is being executed. You can overide entrypoint by --entrypoint="".CMD is the default argument to container. Without entrypoint, default argument is command that is executed. With entrypoint, cmd is passed to entrypoint as argument. You can emulate a command with entrypoint.So, main advantage is that with entrypoint you can pass arguments (cmd) to your container. To accomplish this, you need to use both:andthen you can use:According to docker docs,Both CMD and ENTRYPOINT instructions define what command gets executed\n  when running a container. There are few rules that describe their\n  co-operation.The tables below shows what command is executed for different ENTRYPOINT / CMD combinations:-- No ENTRYPOINT-- ENTRYPOINT exec_entry p1_entry-- ENTRYPOINT [\xe2\x80\x9cexec_entry\xe2\x80\x9d, \xe2\x80\x9cp1_entry\xe2\x80\x9d]In a nutshell:If you need more details or would like to see difference on example, there is a blog post that comprehensively compare CMD and ENTRYPOINT with lots of examples - http://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/ Comments on EntryPoint function in code// ENTRYPOINT /usr/sbin/nginx. // Set the entrypoint (which defaults to sh -c) to /usr/sbin/nginx.// Will accept the CMD as the arguments to /usr/sbin/nginx.Another reference from documentsYou can use the exec form of ENTRYPOINT to set fairly stable default commands and arguments and then use CMD to set additional defaults that are more likely to be changed.Example:Build:  sudo docker build -t ent_cmd . .p.s:\nIn presence of EntryPoint, CMD will hold arguments to fed to EntryPoint.\nIn absense of EntryPoint, CMD will be the command which will be run.Difference between CMD and ENTRYPOINT by example:More on difference between CMD and ENTRYPOINT:Argument to docker run such as /bin/bash overrides any CMD command we wrote in Dockerfile.ENTRYPOINT cannot be overriden at run time with normal commands such as docker run [args].  The args at the end of docker run [args] are provided as arguments to ENTRYPOINT.  In this way we can create a container which is like a normal binary such as ls.So CMD can act as default parameters to ENTRYPOINT and then we can override the CMD args from [args].ENTRYPOINT can be overriden with --entrypoint.The accepted answer is fabulous in explaining the history. I find this table explain it very well from official doc on \'how CMD and ENTRYPOINT interact\':\nCMD:ENTRYPOINT (The following list does not consider the case where CMD and ENTRYPOINT are used together):As creack said, CMD was developed first. Then ENTRYPOINT was developed for more customization. Since they are not designed together, there are some functionality overlaps between CMD and ENTRYPOINT, which often confuse people.