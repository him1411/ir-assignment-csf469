What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:Somehow, I missed os.path.exists (thanks kanja, Blair, and Douglas). This is what I have now:Is there a flag for "open", that makes this happen automatically?I see two answers with good qualities, each with a small flaw, so I will give my take on it:Try os.path.exists, and consider os.makedirs for the creation.As noted in comments and elsewhere, there\'s a race condition - if the directory is created between the os.path.exists and the os.makedirs calls, the os.makedirs will fail with an OSError. Unfortunately, blanket-catching OSError and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.One option would be to trap the OSError and examine the embedded error code (see Is there a cross-platform way of getting information from Python\xe2\x80\x99s OSError):Alternatively, there could be a second os.path.exists, but suppose another created the directory after the first check, then removed it before the second one - we could still be fooled. Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir \'a\' beforehand and remove all permissions from it, you will get an OSError raised with errno.EACCES (Permission denied, error 13).While a naive solution may first use os.path.isdir followed by os.makedirs, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.Note that capturing the exception and using errno is of limited usefulness because OSError: [Errno 17] File exists, i.e. errno.EEXIST, is raised for both files and directories. It is more reliable simply to check if the directory exists.Per an answer by Dennis, the following also works. mkpath creates the nested directory, and does nothing if the directory already exists. This also works in Python 3.Per Bug 10948, a severe limitation of the above technique is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use mkpath again to recreate the same directory, mkpath will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, os.makedirs doesn\'t rely on any such cache. This limitation may be okay for some applications.If using Python 3.2+, an optional exist_ok parameter is available, with a default value of False. It does not exist in Python 2.x up to 2.7. One can therefore simply specify exist_ok=True in Python 3.2+ to avoid raising an exception if the directory already exists. As such, there is, no need for manual exception handling as with Python 2.7.Credit: answer by hiro protagonistThis recursively creates the directory and does not raise an exception if the directory already exists.With regard to the directory\'s mode, please refer to the documentation if you care about it.I would personally recommend that you use os.path.isdir() to test instead of os.path.exists().If you have:And a foolish user input:... You\'re going to end up with a directory named filename.etc when you pass that argument to os.makedirs() if you test with os.path.exists().Check out os.makedirs:  (It makes sure the complete path exists.)  To handle the fact the directory might exist, catch OSError.I have put the following down. It\'s not totally foolproof though.Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:We want to avoid overwriting the builtin function, dir. Also, filepath or perhaps fullfilepath is probably a better semantic name than filename so this would be better written:Your end goal is to open this file, you initially state, for writing, but you\'re essentially approaching this goal (based on your code) like this, which opens the file for reading:Why would you make a directory for a file that you expect to be there and be able to read? Just attempt to open the file.If the directory or file isn\'t there, you\'ll get an IOError with an associated error number: errno.ENOENT will point to the correct error number regardless of your platform. You can catch it if you want, for example:This is probably what you\'re wanting.In this case, we probably aren\'t facing any race conditions. So just do as you were, but note that for writing, you need to open with the w mode (or a to append). It\'s also a Python best practice to use the context manager for opening files.However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it\'s best to wrap the makedirs call in a try-except block.Try the os.path.exists functionIn Python 3.4 you can also use the brand new pathlib module:Check if a directory exists and create it if necessary?The direct answer to this is, assuming a simple situation where you don\'t expect other users or processes to be messing with your directory:or if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via tempfile:Here\'s the essentials from the online doc:There\'s a new Path object (as of 3.4) with lots of methods one would want to use with paths - one of which is mkdir.(For context, I\'m tracking my weekly rep with a script. Here\'s the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)First the relevant imports:We don\'t have to deal with os.path.join now - just join path parts with a /:Then I idempotently ensure the directory exists - the exist_ok argument shows up in Python 3.5:Here\'s the relevant part of the documentation:If exist_ok is true, FileExistsError exceptions will be ignored (same behavior as the POSIX mkdir -p command), but only if the last path component is not an existing non-directory file.Here\'s a little more of the script - in my case, I\'m not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don\'t have anything trying to remove the directory. Path objects have to be coerced to str before other APIs that expect str paths can use them.Perhaps Pandas should be updated to accept instances of the abstract base class, os.PathLike.Starting from Python 3.5, pathlib.Path.mkdir has an exist_ok flag:This recursively creates the directory and does not raise an exception if the directory already exists.The relevant python documentation suggests the use of the EAFP coding style (Easier to Ask for Forgiveness than Permission). This means that the codeis better than the alternativeThe documentation suggests this exactly because of the race condition discussed in this thread. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.You can use mkpathNote that it will create the ancestor directories as well. It works for Python 2 and 3.I saw Heikki Toivonen and A-B-B\'s answers and thought of this variation. What do you think?For a one-liner solution, you can use IPython.utils.path.ensure_dir_exists():From the documentation: Ensure that a directory exists. If it doesn\xe2\x80\x99t exist, try to create it and protect against a race condition if another process is doing the same.In Python3, os.makedirs supports setting exist_ok. The default setting is False, which means an OSError will be raised if the target directory already exists. By setting exist_ok to True, OSError (directory exists) will be ignored and the directory will not be created.In Python2, os.makedirs doesn\'t support setting exist_ok. You can use the approach in heikki-toivonen\'s answer:You can use os.listdir for this:I use os.path.exists(), here is a python3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (If desired).\nIt prompts users for input of the directory, and can be easily modified-p does all the work for you, why go into all this try/catch stuff when both linux and windows powershell have mkdir -p for years. The only reason to do the check separately is if you want to print the info to a log or screen.If you consider the following: means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists.Where your code here is use the (touch) commandThis will check if the file is there if it is not then it will create it.here you can check folder exists or not. Create if not exists.Example: