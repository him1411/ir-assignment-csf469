Suppose, I have a webserver which holds numerous servlets. For information passing among those servlets I am setting session and instance variables.Now, if 2 or more users send request to this server then what happens to the session variables? Will they all be common for all the users or they will be different for each user. If they are different, then how was the server able to differentiate between different users?One more similar question, if there are n users accessing a particular servlet, then this servlet gets instantiated only the first time the first user accessed it or does it get instantiated for all the users separately? In other words, what happens to the instance variables?When the servlet container (like Apache Tomcat) starts up, it will deploy and load all its web applications. When a web application is loaded, the servlet container creates the ServletContext once and keeps it in the server\'s memory. The web app\'s web.xml file is parsed, and each <servlet>, <filter> and <listener> found (or each class annotated with @WebServlet, @WebFilter and @WebListener respectively) is instantiated once and kept in the server\'s memory as well. For each instantiated filter, its init() method is invoked immediately.When the servlet container shuts down, it unloads all web applications, invokes the destroy() method of all its initialized servlets and filters, and all ServletContext, Servlet, Filter and Listener instances are trashed.When a Servlet has a <servlet><load-on-startup> or @WebServlet(loadOnStartup) value greater than 0, its init() method is also immediately invoked during startup. Those servlets are initialized in the same order specified by that value (1 -> 1st, 2 -> 2nd, etc). If the same value is specified for more than one servlet, then each of those servlets is loaded in the order they appear in the web.xml, or @WebServlet classloading. In the event the "load-on-startup" value is absent, the init() method will be invoked whenever the HTTP request hits that servlet for the very first time. The servlet container is attached to a web server that listens for HTTP requests on a certain port number (port 8080 is usually used during development and port 80 in production). When a client (user with a web browser) sends an HTTP request, the servlet container creates new HttpServletRequest and HttpServletResponse objects and passes them through any defined Filter chain and, eventually, the Servlet instance. In the case of filters, the doFilter() method is invoked. When its code calls chain.doFilter(request, response), the request and response continue on to the next filter, or hit the servlet if there are no remaining filters.In the case of servlets, the service() method is invoked. By default, this method determines which one of the doXxx() methods to invoke based off of  request.getMethod(). If the determined method is absent from the servlet, then an HTTP 405 error is returned in the response. The request object provides access to all of the information about the HTTP request, such as its headers and body. The response object provides the ability to control and send the HTTP response the way you want by, for instance, allowing you to set the headers and the body (usually with generated HTML content from a JSP file). When the HTTP response is committed and finished, both the request and response objects are recycled and made for reuse.When a client visits the webapp for the first time and/or the HttpSession is obtained for the first time via request.getSession(), the servlet container creates a new HttpSession object, generates a long and unique ID (which you can get by session.getId()), and store it in the server\'s memory. The servlet container also sets a Cookie in the Set-Cookie header of the HTTP response with JSESSIONID as its name and the unique session ID as its value. As per the HTTP cookie specification (a contract a decent web browser and web server have to adhere to), the client (the web browser) is required to send this cookie back in subsequent requests in the Cookie header for as long as the cookie is valid (i.e. the unique ID must refer to an unexpired session and the domain and path are correct). Using your browser\'s built-in HTTP traffic monitor, you can verify that the cookie is valid (press F12 in Chrome / Firefox 23+ / IE9+, and check the Net/Network tab). The servlet container will check the Cookie header of every incoming HTTP request for the presence of the cookie with the name JSESSIONID and use its value (the session ID) to get the associated HttpSession from server\'s memory.The HttpSession stays alive until it has not been used for more than the timeout value specified in <session-timeout>, a setting in web.xml. The timeout value defaults to 30 minutes. So, when the client doesn\'t visit the web app for longer than the time specified, the servlet container trashes the session. Every subsequent request, even with the cookie specified, will not have access to the same session anymore; the servlet container will create a new session.On the client side, the session cookie stays alive for as long as the browser instance is running. So, if the client closes the browser instance (all tabs/windows), then the session is trashed on the client\'s side. In a new browser instance, the cookie associated with the session wouldn\'t exist, so it would no longer be sent. This causes an entirely new HTTPSession to be created, with an entirely new session cookie begin used.That said, your major concern is possibly thread safety. You should now know that servlets and filters are shared among all requests. That\'s the nice thing of Java, it\'s multithreaded and different threads (read: HTTP requests) can make use of the same instance. It would otherwise be too expensive to recreate, init() and destroy() them for every single request.You should also realize that you should never assign any request or session scoped data as an instance variable of a servlet or filter. It will be shared among all other requests in other sessions. That\'s not thread-safe! The below example illustrates this:\nIn short: the web server issues a unique identifier to each visitor on his first visit. The visitor must bring back that ID for him to be recognised next time around. This identifier also allows the server to properly segregate objects owned by one session against that of another.If load-on-startup is false:\nIf load-on-startup is true:\nOnce he\'s on the service mode and on the groove, the same servlet will work on the requests from all other clients. Why isn\'t it a good idea to have one instance per client? Think about this: Will you hire one pizza guy for every order that came? Do that and you\'d be out of business in no time.It comes with a small risk though. Remember: this single guy holds all the order information in his pocket: so if you\'re not cautious about thread safety on servlets, he may end up giving the wrong order to a certain client.Session in Java servlets is the same as session in other languages such as PHP.  It is unique to the user.  The server can keep track of it in different ways such as cookies, url rewriting etc.  This Java doc article explains it in the context of Java servlets and indicates that exactly how session is maintained is an implementation detail left to the designers of the server.  The specification only stipulates that it must be maintained as unique to a user across multiple connections to the server.  Check out this article from Oracle for more information about both of your questions.Edit There is an excellent tutorial here on how to work with session inside of servlets. And here is a chapter from Sun about Java Servlets, what they are and how to use them.  Between those two articles, you should be able to answer all of your questions.  When the servletcontainer (like Apache Tomcat) starts up, it will read from web.xml file (only one per application) if any thing goes wrong or shows up error at container side console, otherwise it will deploy and load all webapplications by using web.xml (so named it as deployment descriptor).During instantiation phase of servlet, servletInstance is ready but it cannot serve the client request because it is missing with two pieces of information:\n1:context information\n2:initial configuration informationServlet engine creates servletConfig interface object encapsulating the above missing information into it\nservlet engine calls init() of servlet by suplying servletConfig object references as argument. Once init() is completedly executed servlet is ready to server the client request. A)only once (for every client request a new thread is created)\nonly one instance of the servlet serves any number of the client request ie, after serving one client request server does not die. It waits for other client requests \nie what CGI (for every client request a new process is created) limitation is overcome with servlet (internally servlet engine creates thread).A)whenever getSession() is called on HttpServletRequest object Step 1:request object is evalauated for incoming session ID.Step 2:if ID not avaiable a brand new HttpSession object is created and its corresponding session ID is generated (ie of HashTable) session ID is stored into httpservlet response object and the reference of HttpSession object is returned to servlet (doGet/doPost). Step 3:if ID avaiable brand new session object is not created session ID is picked up from the request object search is made in the collection of sessions by using session ID as the key.  Once the search is sucessful session ID is stored into HttpServletResponse and the exsisting session object references is returned to the doGet() or doPost() of UserDefineservlet.1)when control leaves from servlet code to client dont forget that session object is being hold by servletcontainer ie, servletengine2)multithreading is left to servlet devlopers people for implementing ie., handle the multiple request of client nothing to bother about multithread code A servlet is created when the application starts (it is deployed on the servlet container) or when it is first accessed (depending on the load-on-startup setting)\nwhen the servlet is instantiated, the init() method of the servlet is called\nthen the servlet (its one and only instance) handles all requests (its service() method being called by multiple threads). That\'s why it is not advisable to have any synchronization in it, and you should avoid instance variables of the servlet\nwhen the application is undeployed (the servlet container stops), the destroy() method is called.Sessions - what Chris Thompson said.Instantiation - a servlet is instantiated when the container receives the first request mapped to the servlet (unless the servlet is configured to load on startup with the <load-on-startup> element in web.xml). The same instance is used to serve subsequent requests.The Servlet Specification JSR-315 clearly defines the web container behavior in the service (and doGet, doPost, doPut etc.) methods (2.3.3.1 Multithreading Issues, Page 9):A servlet container may send concurrent requests through the service\n  method of the servlet. To handle the requests, the Servlet Developer\n  must make adequate provisions for concurrent processing with multiple\n  threads in the service method.Although it is not recommended, an alternative for the Developer is to\n  implement the SingleThreadModel interface which requires the container\n  to guarantee that there is only one request thread at a time in the\n  service method. A servlet container may satisfy this requirement by\n  serializing requests on a servlet, or by maintaining a pool of servlet\n  instances. If the servlet is part of a Web application that has been\n  marked as distributable, the container may maintain a pool of servlet\n  instances in each JVM that the application is distributed across.For servlets not implementing the SingleThreadModel interface, if the\n  service method (or methods such as doGet or doPost which are\n  dispatched to the service method of the HttpServlet abstract class)\n  has been defined with the synchronized keyword, the servlet container\n  cannot use the instance pool approach, but must serialize requests\n  through it. It is strongly recommended that Developers not synchronize\n  the service method (or methods dispatched to it) in these\n  circumstances because of detrimental effects on performance