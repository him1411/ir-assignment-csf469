The API Reference Scope page says:A scope can inherit from a parent scope.The Developer Guide Scope page says:A scope (prototypically) inherits properties from its parent scope.So, does a child scope always prototypically inherit from its parent scope?  Are there exceptions?  When it does inherit, is it always normal JavaScript prototypal inheritance?Quick answer: \nA child scope normally prototypically inherits from its parent scope, but not always.  One exception to this rule is a directive with scope: { ... } -- this creates an "isolate" scope that does not prototypically inherit.  This construct is often used when creating a "reusable component" directive.As for the nuances, scope inheritance is normally straightfoward... until you need 2-way data binding (i.e., form elements, ng-model) in the child scope.  Ng-repeat, ng-switch, and ng-include can trip you up if you try to bind to a primitive (e.g., number, string, boolean) in the parent scope from inside the child scope.  It doesn\'t work the way most people expect it should work.  The child scope gets its own property that hides/shadows the parent property of the same name.  Your workarounds areNew AngularJS developers often do not realize that ng-repeat, ng-switch, ng-view, ng-include and ng-if all create new child scopes, so the problem often shows up when these directives are involved. (See this example for a quick illustration of the problem.)This issue with primitives can be easily avoided by following the "best practice" of always have a \'.\' in your ng-models \xe2\x80\x93 watch 3 minutes worth. Misko demonstrates the primitive binding issue with ng-switch.Having a \'.\' in your models will ensure that prototypal inheritance is in play. So, useAlso placed on the AngularJS wiki: https://github.com/angular/angular.js/wiki/Understanding-ScopesIt is important to first have a solid understanding of prototypal inheritance, especially if you are coming from a server-side background and you are more familiar with class-ical inheritance.  So let\'s review that first.Suppose parentScope has properties aString, aNumber, anArray, anObject, and aFunction.  If childScope prototypically inherits from parentScope, we have:(Note that to save space, I show the anArray object as a single blue object with its three values, rather than an single blue object with three separate gray literals.)If we try to access a property defined on the parentScope from the child scope, JavaScript will first look in the child scope, not find the property, then look in the inherited scope, and find the property.  (If it didn\'t find the property in the parentScope, it would continue up the prototype chain... all the way up to the root scope). So, these are all true:Suppose we then do this:The prototype chain is not consulted, and a new aString property is added to the childScope.  This new property hides/shadows the parentScope property with the same name.  This will become very important when we discuss ng-repeat and ng-include below.Suppose we then do this:The prototype chain is consulted because the objects (anArray and anObject) are not found in the childScope.  The objects are found in the parentScope, and the property values are updated on the original objects.  No new properties are added to the childScope;  no new objects are created.  (Note that in JavaScript arrays and functions are also objects.)Suppose we then do this:The prototype chain is not consulted, and child scope gets two new object properties that hide/shadow the parentScope object properties with the same names.Takeaways:One last scenario:We deleted the childScope property first, then when we try to access the property again, the prototype chain is consulted.The contenders:Note, by default, directives do not create new scope -- i.e., the default is scope: false.Suppose we have in our controller:And in our HTML:Each ng-include generates a new child scope, which prototypically inherits from the parent scope.Typing (say, "77") into the first input textbox causes the child scope to get a new myPrimitive scope property that hides/shadows the parent scope property of the same name.  This is probably not what you want/expect.Typing (say, "99") into the second input textbox does not result in a new child property.  Because tpl2.html binds the model to an object property, prototypal inheritance kicks in when the ngModel looks for object myObject -- it finds it in the parent scope.We can rewrite the first template to use $parent, if we don\'t want to change our model from a primitive to an object:Typing (say, "22") into this input textbox does not result in a new child property.  The model is now bound to a property of the parent scope (because $parent is a child scope property that references the parent scope).For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via scope properties $parent, $$childHead and $$childTail.  I normally don\'t show these scope properties in the diagrams.For scenarios where form elements are not involved, another solution is to define a function on the parent scope to modify the primitive.  Then ensure the child always calls this function, which will be available to the child scope due to prototypal inheritance. E.g.,Here is a sample fiddle that uses this "parent function" approach.  (The fiddle was written as part of this answer: https://stackoverflow.com/a/14104318/215945.)See also https://stackoverflow.com/a/13782671/215945 and https://github.com/angular/angular.js/issues/1267.ng-switch scope inheritance works just like ng-include.  So if you need 2-way data binding to a primitive in the parent scope, use $parent, or change the model to be an object and then bind to a property of that object.  This will avoid child scope hiding/shadowing of parent scope properties.See also AngularJS, bind scope of a switch-case?Ng-repeat works a little differently.  Suppose we have in our controller:And in our HTML:For each item/iteration, ng-repeat creates a new scope, which prototypically inherits from the parent scope, but it also assigns the item\'s value to a new property on the new child scope.  (The name of the new property is the loop variable\'s name.)  Here\'s what the Angular source code for ng-repeat actually is:If item is a primitive (as in myArrayOfPrimitives), essentially a copy of the value is assigned to the new child scope property.  Changing the child scope property\'s value (i.e., using ng-model, hence child scope num) does not change the array the parent scope references.  So in the first ng-repeat above, each child scope gets a num property that is independent of the myArrayOfPrimitives array:This ng-repeat will not work (like you want/expect it to).  Typing into the textboxes changes the values in the gray boxes, which are only visible in the child scopes.  What we want is for the inputs to affect the myArrayOfPrimitives array, not a child scope primitive property.  To accomplish this, we need to change the model to be an array of objects.So, if item is an object, a reference to the original object (not a copy) is assigned to the new child scope property.  Changing the child scope property\'s value (i.e., using ng-model, hence obj.num) does change the object the parent scope references.  So in the second ng-repeat above, we have:(I colored one line gray just so that it is clear where it is going.)This works as expected.  Typing into the textboxes changes the values in the gray boxes, which are visible to both the child and parent scopes.See also Difficulty with ng-model, ng-repeat, and inputs and \nhttps://stackoverflow.com/a/13782671/215945Nesting controllers using ng-controller results in normal prototypal inheritance, just like ng-include and ng-switch, so the same techniques apply.\nHowever, "it is considered bad form for two controllers to share information via $scope inheritance" -- http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/\nA service should be used to share data between controllers instead.(If you really want to share data via controllers scope inheritance, there is nothing you need to do.  The child scope will have access to all of the parent scope properties.\nSee also Controller load order differs when loading or navigating)This fiddle has a showScope() function that can be used to examine an isolate and transcluded scope.  See the instructions in the comments in the fiddle.There are four types of scopes:For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via properties $parent and $$childHead and $$childTail.Diagrams were generated with graphviz "*.dot" files, which are on github. Tim Caswell\'s "Learning JavaScript with Object Graphs" was the inspiration for using GraphViz for the diagrams. I in no way want to compete with Mark\'s answer, but just wanted to highlight the piece that finally made everything click as someone new to Javascript inheritance and its prototype chain.Only property reads search the prototype chain, not writes. So when you setIt doesn\'t look up the chain, but when you set there\'s a subtle read going on within that write operation that tries to look up myThing before writing to its prop. So that\'s why writing to object.properties from the child gets at the parent\'s objects.I would like to add an example of prototypical inheritance with javascript to @Scott Driscoll answer. We\'ll be using classical inheritance pattern with Object.create() which is a part of  EcmaScript 5 specification.First we create "Parent" object functionThen add a prototype to "Parent" object functionCreate "Child" object functionAssign child prototype (Make child prototype inherit from parent prototype)Assign proper "Child" prototype constructorAdd method "changeProps" to a child prototype, which will rewrite "primitive" property value in Child object and change "object.one" value  both in Child and Parent objectsInitiate Parent (dad) and Child (son) objects.Call Child (son) changeProps methodCheck the results.Parent primitive property did not changeChild primitive property changed (rewritten)Parent and Child object.one properties changedWorking example here http://jsbin.com/xexurukiso/1/edit/More info on Object.create here https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create