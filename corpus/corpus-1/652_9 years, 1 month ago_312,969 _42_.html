From time to time I see an enum like the following:I don\'t understand what exactly the [Flags]-attribute does.Anyone have a good explanation or example they could post?The flags attribute should be used whenever the enumerable represents a collection of flags, rather than a single value. Such collections are usually manipulated using bitwise operators, for example:Note that [Flags] by itself doesn\'t change this at all - all it does is enable a nice representation by the .ToString() method:It is also important to note that [Flags] does not automatically make the enum values powers of two. If you omit the numeric values, the enum will not work as one might expect in bitwise operations, because by default the values start with 0 and increment. Incorrect declaration:The values, if declared this way, will be Yellow = 0, Green = 1, Red = 2, Blue = 3.  This will render it useless for use as flags.Here\'s an example of a correct declaration:To retrieve the distinct values in your property, one can do this:or, in .NET 4 and later:Under the coversThis works because you previously used powers of two in your enumeration. Under the covers, your enumeration values look like this (presented as bytes, which has 8 bits which can be 1\'s or 0\'s)Likewise, after you\'ve set your property AllowedColors to Red, Green and Blue (which values where OR\'ed by the pipe |), AllowedColors looks like thisSo when you retrieve the value you are actually bitwise AND\'ing the valuesThe None = 0 valueAnd regarding use 0 in you enumeration, quoting from msdn:Use None as the name of the flag enumerated constant whose value is zero. You cannot use the None enumerated constant in a bitwise AND operation to test for a flag because the result is always zero. However, you can perform a logical, not a bitwise, comparison between the numeric value and the None enumerated constant to determine whether any bits in the numeric value are set. You can find more info about the flags attribute and its usage at msdn and designing flags at msdnYou can also do thisI find the bit-shifting easier than typing 4,8,16,32 and so on. It has no impact on your code because it\'s all done at compile timeCombining answers https://stackoverflow.com/a/8462/1037948 (declaration via bit-shifting) and https://stackoverflow.com/a/9117/1037948 (using combinations in declaration) you can bit-shift previous values rather than using numbers.  Not necessarily recommending it, but just pointing out you can.Rather than:You can declareConfirming with LinqPad:Results in:Please see the following for an example which shows the declaration and potential usage:I asked recently about something similar.If you use flags you can add an extension method to enums to make checking the contained flags easier (see post for detail)This allows you to do:Then you can do:I find this easier to read than the most ways of checking the included flags.@NidonocuTo add another flag to an existing set of values, use the OR assignment operator.There\'s something overly verbose to me about the if ((x & y) == y)... construct, especially if x AND y are both compound sets of flags and you only want to know if there\'s any overlap.In this case, all you really need to know is if there\'s a non-zero value[1] after you\'ve bitmasked.  [1] See Jaime\'s comment.  If we were authentically bitmasking, we\'d\n  only need to check that the result was positive.  But since enums\n  can be negative, even, strangely, when combined with the [Flags]\n  attribute,\n  it\'s defensive to code for != 0 rather than > 0.Building off of @andnil\'s setup...To add Mode.Write:Flags allow you to use bitmasking inside your enumeration.  This allows you to combine enumeration values, while retaining which ones are specified.In extension to the accepted answer, in C#7 the enum flags can be written using binary literals:I think this representation makes it clear how the flags work under the covers.