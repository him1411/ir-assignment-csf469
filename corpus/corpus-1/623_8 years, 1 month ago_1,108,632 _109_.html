How can I replace a newline (\\n) using the sed command?I unsuccessfully tried:    How do I fix it?Use this solution with GNU sed: This will read the whole file in a loop, then replaces the newline(s) with a space.Explanation:Here is cross-platform compatible syntax which works with BSD sed (as per @Benjie comment):Use tr instead?or remove the newline characters entirely:or if you have the GNU version (with its long options)Fast answer:sed will loop through step 1 to 3 until it reach the last line, getting all lines fit in the pattern space where sed will substitute all \\n charactersAlternatives:All alternatives, unlike sed will not need to reach the last line to begin the processwith bash, slowwith perl, sed-like speedwith tr, faster than sed, can replace by one character onlywith paste, tr-like speed, can replace by one character onlywith awk, tr-like speedOther alternative like "echo $(< file)" is slow, works only on small files and needs to process the whole file to begin the process.Long answer from the sed FAQ 5.10:5.10. Why can\'t I match or delete a newline using the \\n escape\n      sequence? Why can\'t I match 2 or more lines using \\n?                   The \\n will never match the newline at the end-of-line because the\n   newline is always stripped off before the line is placed into the\n   pattern space. To get 2 or more lines into the pattern space, use\n   the \'N\' command or something similar (such as \'H;...;g;\').                 Sed works like this: sed reads one line at a time, chops off the\n   terminating newline, puts what is left into the pattern space where\n   the sed script can address or change it, and when the pattern space\n   is printed, appends a newline to stdout (or to a file). If the\n   pattern space is entirely or partially deleted with \'d\' or \'D\', the\n   newline is not added in such cases. Thus, scripts like                   will NEVER work, because the trailing newline is removed before\n   the line is put into the pattern space. To perform the above tasks,\n   use one of these scripts instead:                                          Since versions of sed other than GNU sed have limits to the size of\n   the pattern buffer, the Unix \'tr\' utility is to be preferred here.\n   If the last line of the file contains a newline, GNU sed will add\n   that newline to the output but delete all others, whereas tr will\n   delete all newlines.                                                       To match a block of two or more lines, there are 3 basic choices:\n   (1) use the \'N\' command to add the Next line to the pattern space;\n   (2) use the \'H\' command at least twice to append the current line\n   to the Hold space, and then retrieve the lines from the hold space\n   with x, g, or G; or (3) use address ranges (see section 3.3, above)\n   to match lines between two specified addresses.                            Choices (1) and (2) will put an \\n into the pattern space, where it\n   can be addressed as desired (\'s/ABC\\nXYZ/alphabet/g\'). One example\n   of using \'N\' to delete a block of lines appears in section 4.13\n   ("How do I delete a block of specific consecutive lines?"). This\n   example can be modified by changing the delete command to something\n   else, like \'p\' (print), \'i\' (insert), \'c\' (change), \'a\' (append),\n   or \'s\' (substitute).                                                       Choice (3) will not put an \\n into the pattern space, but it does\n   match a block of consecutive lines, so it may be that you don\'t\n   even need the \\n to find what you\'re looking for. Since GNU sed\n   version 3.02.80 now supports this syntax:                                  in addition to the traditional \'/from here/,/to there/{...}\' range\n   addresses, it may be possible to avoid the use of \\n entirely.A shorter awk alternative:An awk program is built up of rules which consist of conditional code-blocks, i.e.:If the code-block is omitted, the default is used: { print $0 }. Thus, the 1 is interpreted as a true condition and print $0 is executed for each line.When awk reads the input it splits it into records based on the value of RS (Record Separator), which by default is a newline, thus awk will by default parse the input line-wise. The splitting also involves stripping off RS from the input record.Now, when printing a record, ORS (Output Record Separator) is appended to it (default is again a newline). So by changing ORS to a space all newlines are changed to spaces.The Perl version works the way you expected.As pointed out in the comments, it\'s worth noting that this edits in place. -i.bak will give you a backup of the original file before the replacement in case your regular expression isn\'t as smart as you thought.gnu sed has an option -z for null separated records (lines). If you know your file has no nulls you can just:Who needs sed? Here is the bash way:In order to replace all newlines with spaces using awk, without reading the whole file into memory:If you want a final newline:You can use a character other than space:is the command.Simple and easy to use.Three things.tr (or cat, etc.) is absolutely not needed. (GNU) sed and (GNU) awk, when combined, can do 99.9% of any text processing you need.stream != line based. ed is a line-based editor. sed is not. See sed lecture for more information on the difference. Most people confuse sed to be line-based because it is, by default, not very greedy in its pattern matching for SIMPLE matches - for instance, when doing pattern searching and replacing by one or two characters, it by default only replaces on the first match it finds (unless specified otherwise by the global command). There would not even be a global command if it were line-based rather than STREAM-based, because it would evaluate only lines at a time. Try running ed; you\'ll notice the difference. ed is pretty useful if you want to iterate over specific lines (such as in a for-loop), but most of the times you\'ll just want sed.That being said,works just fine in GNU sed version 4.2.1. The above command will replace all newlines with spaces. It\'s ugly and a bit cumbersome to type in, but it works just fine. The {}\'s can be left out, as they\'re only included for sanity reasons.The answer with the :a label ...How can I replace a newline (\\n) using sed?... does not work in freebsd 7.2 on the command line:But does if you put the sed script in a file or use -e to "build" the sed script...or ...Maybe the sed in OS X is similar.I\'m not an expert, but I guess in sed you\'d first need to append the next line into the pattern space, bij using "N". From the section "Multiline Pattern Space" in "Advanced sed Commands" of the book sed & awk (Dale Dougherty and Arnold Robbins; O\'Reilly 1997; page 107 in the preview):The multiline Next (N) command creates a multiline pattern space by reading a new line of input and appending it to the contents of the pattern space. The original contents of pattern space and the new input line are separated by a newline. The embedded newline character can be matched in patterns by the escape sequence "\\n". In a multiline pattern space, the metacharacter "^" matches the very first character of the pattern space, and not the character(s) following any embedded newline(s). Similarly, "$" matches only the final newline in the pattern space, and not any embedded newline(s). After the Next command is executed, control is then passed to subsequent commands in the script.From man sed:[2addr]NAppend the next line of input to the pattern space, using an embedded newline character to separate the appended material from the original contents.  Note that the current line number changes.I\'ve used this to search (multiple) badly formatted log files, in which the search string may be found on an "orphaned" next line.You can use xargs:orIn response to the "tr" solution above, on Windows (probably using the Gnuwin32 version of tr), the proposed solution:was not working for me, it\'d either error or actually replace the \\n w/ \'\' for some reason.Using another feature of tr, the "delete" option -d did work though:or \'\\r\\n\' instead of \'\\n\'I had this problem. The kicker was that I needed the solution to work on BSD\'s (Mac OS X) and GNU\'s (Linux and Cygwin) sed and tr:Output:(has trailing newline)It works on Linux, OS X, and BSD - even without UTF-8 support or with a crappy terminal.Use tr to swap the newline with another character.NULL (\\000 or \\x00) is nice because it doesn\'t need UTF-8 support and it\'s not likely to be used.Use sed to match the NULLUse tr to swap back extra newlines if you need themI used a hybrid approach to get around the newline thing by using tr to replace newlines with tabs, then replacing tabs with whatever I want. In this case, "  " since I\'m trying to generate HTML breaks.In some situations maybe you can change RS to some other string or character. This way, \\n is available for sub/gsub: The power of shell scripting is that if you do not know how to do it in one way you can do it in another way. And many times you have more things to take into account than make a complex solution on a simple problem. Regarding the thing that gawk is slow... and reads the file into memory, I do not know this, but to me gawk seems to work with one line at the time and is very very fast (not that fast as some of the others, but the time to write and test also counts). I process MB and even GB of data, and the only limit I found is line size.You could use xargs — it will replace \\n with a space by default.However, it would have problems if your input has any case of an unterminated quote, e.g. if the quote signs on a given line don\'t match.POSIX sed\nrequires input according to the\nPOSIX text file\nand\nPOSIX line\ndefinitions, so NULL-bytes and too long lines are not allowed and each line must end with a newline (including the last line). This makes it hard to use sed for processing arbitrary input data.The following solution avoids sed and instead converts the input bytes to octal codes and then to bytes again, but intercepts octal code 012 (newline) and outputs the replacement string in place of it. As far as I can tell the solution is POSIX-compliant, so it should work on a wide variety of platforms.POSIX reference documentation:\nsh,\nshell command language,\nod,\ntr,\ngrep,\nread,\n[,\nprintf.Both read, [, and printf are built-ins in at least bash, but that is probably not guaranteed by POSIX, so on some platforms it could be that each input byte will start one or more new processes, which will slow things down. Even in bash this solution only reaches about 50 kB/s, so it\'s not suited for large files.Tested on Ubuntu (bash, dash, and busybox), FreeBSD, and OpenBSD.On Mac OS X (using FreeBSD sed):Using Awk:A solution I particularly like is to append all the file in the hold space and replace all newlines at the end of file:However, someone said me the hold space can be finite in some sed implementations.The pure tr solutions can only replace with a single character, and the pure sed solutions don\'t replace the last newline of the input. The following solution fixes these problems, and seems to be safe for binary data (even with a UTF-8 locale):Result:It is sed that introduces the new-lines after "normal" substitution. First, it trims the new-line char, then it processes according to your instructions, then it introduces a new-line.Using sed you can replace "the end" of a line (not the new-line char) after being trimmed, with a string of your choice, for each input line; but, sed will output different lines. For example, suppose you wanted to replace the "end of line" with "===" (more general than a replacing with a single space):To replace the new-line char with the string, you can, inefficiently though, use tr , as pointed before, to replace the newline-chars with a "special char" and then use sed to replace that special char with the string you want.For example:@OP, if you want to replace newlines in a file, you can just use dos2unix (or unix2dox)To remove empty lines:You can use this method also ExplanationFlow:\n   When the first line get from the input, exchange is made, so 1 goes to hold space and \\n comes to pattern space, then appending the hold space to pattern space, and then substitution is performed and deleted the pattern space.\n   During the second line exchange is made, 2 goes to hold space and 1 comes to pattern space, then G append the hold space into the pattern space, then h copy the pattern to it and substitution is made and deleted. This operation is continued until eof is reached then print exact result.This does not work for huge files (buffer limit), but it is very efficient if there is enough memory to hold the file.\n(Correction H-> 1h;1!H after the good remark of @hilojack )Another version that change new line while reading (more cpu, less memory)Another sed method, almost the same as Zsolt Botykai\'s answer, but this uses sed\'s less-frequently used y (transliterate) command, which saves one byte of code (the trailing \'g\'):One would hope y would run faster than s, (perhaps at tr speeds, 20x faster), but in GNU sed v4.2.2 y is about 4% slower than s.  You can also use the Standard Text Editor:Note: this saves the result back to file.As with sed, this solution suffers from having to load the whole file into memory first. 