I usually submit a list of commits for review. If I have:I know that I can modify head commit with git commit --amend, but how can I modify Commit1, given that it is not the HEAD commit?You can use git rebase, for example, if you want to modify back to commit bbc643cd, runIn the default editor, modify pick to edit in the line whose commit you want to modify. Make your changes and then commit them with the same message you had before:to modify the commit, and after thatto return back to the previous head commit.WARNING: Note that this will change the SHA-1 of that commit as well as all children -- in other words, this rewrites the history from that point forward. You can break repos doing this if you push using the command git push --forceFind the commit you want, change pick to e (edit), and save and close the file. Git will rewind to that commit, allowing you to either:The latter is useful for doing more complex stuff like splitting into multiple commits.Then, run git rebase --continue, and Git will replay the subsequent changes on top of your modified commit. You may be asked to fix some merge conflicts.Note: @ is shorthand for HEAD, and ~ is the commit before the specified commit.Read more about rewriting history in the Git docs.ProTip\xe2\x84\xa2: \xc2\xa0 Don\'t be afraid to experiment with "dangerous" commands that rewrite history* \xe2\x80\x94 Git doesn\'t delete your commits for 90 days by default; you can find them in the reflog:* Watch out for options like --hard and --force though \xe2\x80\x94 they can discard data.\n*  Also, don\'t rewrite history on any branches you\'re collaborating on.On many systems, git rebase -i will open up Vim by default. Vim doesn\'t work like most modern text editors, so take a look at how to rebase using Vim. If you\'d rather use a different editor, change it with git config --global core.editor your-favorite-text-editor.Interactive rebase with --autosquash is something I frequently use when I need to fixup previous commits deeper in the history. It essentially speeds up the process that ZelluX\'s answer illustrates, and is especially handy when you have more than one commit you need to edit.From the documentation:--autosquashWhen the commit log message begins with "squash! \xe2\x80\xa6\xe2\x80\x8b" (or "fixup! \xe2\x80\xa6\xe2\x80\x8b"), and there is a commit whose title begins with the same \xe2\x80\xa6\xe2\x80\x8b, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modifiedAssume you have a history that looks like this:and you have changes that you want to amend to Commit2 then commit your changes usingalternatively you can use the commit-sha instead of the commit message, so "fixup! e8adec4 or even just a prefix of the commit message.Then initiate an interactive rebase on the commit beforeyour editor will open with the commits already correctly orderedall you need to do is save and exitRun:$ git rebase --interactive commit_hash^each ^ indicates how many commits back you want to edit, if it\'s only one (the commit hash that you specified), then you just add one ^.Using Vim you change the words pick to reword for the commits you want to change, save and quit(:wq). Then git will prompt you with each commit that you marked as reword so you can change the commit message.Each commit message you have to save and quit(:wq) to go to the next commit messageIf you want to exit without applying the changes, press :q!EDIT: to navigate in vim you use j to go up, k to go down, h to go left, and l to go right( all this in NORMAL mode, press ESC to go to NORMAL mode ).\nTo edit a text, press i so that you enter the INSERT mode, where you insert text. \nPress ESC to go back to NORMAL mode :)UPDATE: Here\'s a great link from github listing How to undo (almost) anything with git If for some reason you don\'t like interactive editors, you can use git rebase --onto.Say you want to modify Commit1. First, branch from before Commit1:Second, grab Commit1 with cherry-pick:Now, amend your changes, creating Commit1\':And finally, after having stashed any other changes, transplant the rest of your commits up to master on top of your\nnew commit:Read: "rebase, onto the branch amending, all commits between Commit1 (non-inclusive) and master (inclusive)". That is, Commit2 and Commit3, cutting the old Commit1 out entirely. You could just cherry-pick them, but this way is easier.Remember to clean up your branches!Came to this approach (and it is probably exactly the same as using interactive rebase) but for me it\'s kind of straightforward.Note: I present this approach for the sake of illustration of what you can do rather than an everyday alternative. Since it has many steps (and possibly some caveats.)Say you want to change commit 0 and you are currently on feature-branchCheckout to this commit and create a quick-branch. You can also clone your feature branch as a recovery point (before starting).You will now have something like this:Stage changes, stash everything else.Commit changes and checkout back to feature-branchYou will now have something like this:Rebase feature-branch onto quick-branch (resolve any conflicts along the way). Apply stash and remove quick-branch.And you end up with:Git will not duplicate (although I can\'t really say to what extent) the 0 commit when rebasing.Note: all commit hashes are changed starting from the commit we originally intended to change.