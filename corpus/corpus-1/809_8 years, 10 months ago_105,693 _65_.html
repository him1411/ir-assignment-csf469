\nI\'m setting up a new server, and want to support UTF-8 fully in my web application. I have tried in the past on existing servers and always seem to end up having to fall back to ISO-8859-1.Where exactly do I need to set the encoding/charsets? I\'m aware that I need to configure Apache, MySQL and PHP to do this - is there some standard checklist I can follow, or perhaps troubleshoot where the mismatches occur?This is for a new Linux server, running MySQL 5, PHP 5 and Apache 2.Data Storage:Specify the utf8mb4 character set on all tables and text columns in your database.  This makes MySQL physically store and retrieve values encoded natively in UTF-8.  Note that MySQL will implicitly use utf8mb4 encoding if a utf8mb4_* collation is specified (without any explicit character set).In older versions of MySQL (< 5.5.3), you\'ll unfortunately be forced to use simply utf8, which only supports a subset of Unicode characters.  I wish I were kidding.Data Access:In your application code (e.g. PHP), in whatever DB access method you use, you\'ll need to set the connection charset to utf8mb4.  This way, MySQL does no conversion from its native UTF-8 when it hands data off to your application and vice versa.Some drivers provide their own mechanism for configuring the connection character set, which both updates its own internal state and informs MySQL of the encoding to be used on the connection—this is usually the preferred approach.   In PHP:If you\'re using the PDO abstraction layer with PHP ≥ 5.3.6, you can specify charset in the DSN:If you\'re using mysqli, you can call set_charset():If you\'re stuck with plain mysql but happen to be running PHP ≥ 5.2.3, you can call mysql_set_charset.If the driver does not provide its own mechanism for setting the connection character set, you may have to issue a query to tell MySQL how your application expects data on the connection to be encoded: SET NAMES \'utf8mb4\'.The same consideration regarding utf8mb4/utf8 applies as above.Output:If your application transmits text to other systems, they will also need to be informed of the character encoding.  With web applications, the browser must be informed of the encoding in which data is sent (through HTTP response headers or HTML metadata).In PHP, you can use the default_charset php.ini option, or manually issue the Content-Type MIME header yourself, which is just more work but has the same effect.Input:Unfortunately, you should verify every received string as being valid UTF-8 before you try to store it or use it anywhere.  PHP\'s mb_check_encoding() does the trick, but you have to use it religiously.  There\'s really no way around this, as malicious clients can submit data in whatever encoding they want, and I haven\'t found a trick to get PHP to do this for you reliably.From my reading of the current HTML spec, the following sub-bullets are not necessary or even valid anymore for modern HTML.  My understanding is that browsers will work with and submit data in the character set specified for the document.  However, if you\'re targeting older versions of HTML (XHTML, HTML4, etc.), these points may still be useful:Other Code Considerations:Obviously enough, all files you\'ll be serving (PHP, HTML, JavaScript, etc.) should be encoded in valid UTF-8.You need to make sure that every time you process a UTF-8 string, you do so safely.  This is, unfortunately, the hard part.  You\'ll probably want to make extensive use of PHP\'s mbstring extension.PHP\'s built-in string operations are not by default UTF-8 safe.  There are some things you can safely do with normal PHP string operations (like concatenation), but for most things you should use the equivalent mbstring function.To know what you\'re doing (read: not mess it up), you really need to know UTF-8 and how it works on the lowest possible level.  Check out any of the links from utf8.com for some good resources to learn everything you need to know.I\'d like to add one thing to chazomaticus\' excellent answer:Don\'t forget the META tag either (like this, or the HTML4 or XHTML version of it):That seems trivial, but IE7 has given me problems with that before.I was doing everything right; the database, database connection and Content-Type HTTP header were all set to UTF-8, and it worked fine in all other browsers, but Internet Explorer still insisted on using the "Western European" encoding.It turned out the page was missing the META tag. Adding that solved the problem.Edit:The W3C actually has a rather large section dedicated to I18N. They have a number of articles related to this issue – describing the HTTP, (X)HTML and CSS side of things:They recommend using both the HTTP header and HTML meta tag (or XML declaration in case of XHTML served as XML).In addition to setting default_charset in php.ini, you can send the correct charset using header() from within your code, before any output:Working with Unicode in PHP is easy as long as you realize that most of the string functions don\'t work with Unicode, and some might mangle strings completely. PHP considers "characters" to be 1 byte long. Sometimes this is okay (for example, explode() only looks for a byte sequence and uses it as a separator -- so it doesn\'t matter what actual characters you look for). But other times, when the function is actually designed to work on characters, PHP has no idea that your text has multi-byte characters that are found with Unicode.A good library to check into is phputf8. This rewrites all of the "bad" functions so you can safely work on UTF8 strings. There are extensions like the mbstring extension that try to do this for you, too, but I prefer using the library because it\'s more portable (but I write mass-market products, so that\'s important for me). But phputf8 can use mbstring behind the scenes, anyway, to increase performance.Old topic, I know. Found an issue with someone using PDO and the answer was to use this for the PDO Connection string:The site I took this from is down, was able to get it using google cache luckily. In my case, I was using mb_split, which uses regex.  Therefore I also had to manually make sure the regex encoding was utf-8 by doing mb_regex_encoding(\'UTF-8\');As a side note, I also discovered by running mb_internal_encoding() that the internal encoding wasn\'t utf-8, and I changed that by running mb_internal_encoding("UTF-8");.First of all if you are in < 5.3PHP then no. You\'ve got a ton of problems to tackle. I am surprised that none has mentioned the intl library, the one that has good support for unicode, graphemes, string operations , localisation and many more, see below. I will quote some information about unicode support in PHP by Elizabeth Smith\'s slides at PHPBenelux\'14Good:Bad:I ll update this answer in case things change features added and so on. The only thing I would add to these amazing answers is to emphasize on saving your files in utf8 encoding, i have noticed that browsers accept this property over setting utf8 as your code encoding. Any decent text editor will show you this, for example Notepad++ has a menu option for file enconding, it shows you the current encoding and enables you to change it. For all my php files I use utf8 without BOM. Sometime ago i had someone ask me to add utf8 support for a php/mysql application designed by someone else, i noticed that all files were encoded in ANSI, so I had to use ICONV to convert all files, change the database tables to use the utf8 charset and utf8_general_ci collate, add \'SET NAMES utf8\' to the database abstraction layer after the connection (if using 5.3.6 or earlier otherwise you have to use charset=utf8 in the connection string) and change string functions to use the php multibyte string functions equivalent.I recently discovered that using strtolower() can cause issues where the data is truncated after a special character.The solution was to use mb_ uses MultiByte. It supports more characters but in general is a little slower.In PHP, you\'ll need to either use the multibyte functions, or turn on mbstring.func_overload. That way things like strlen will work if you have characters that take more than one byte.You\'ll also need to identify the character set of your responses. You can either use AddDefaultCharset, as above, or write PHP code that returns the header. (Or you can add a META tag to your HTML documents.)Good goal to have from the start - based on the nature of your site, I\'ve found lots of resources about this by Googling - you\'re not the first to deal with it, of course.The mystical PHP6 is supposed to have all this straightened out, right?You can pretty much set utf-8 as the global default charset for mysql at the server level and it will default properly to the more granular levels.I have just went through the same issue and found a good solution at PHP manuals.I changed all my file encoding to UTF8 then the default encoding on my connection. This solved all the problems.View SourceUnicode support in PHP is still a huge mess. While it\'s capable of converting an ISO8859 string (which it uses internally) to utf8, it lacks the capability to work with unicode strings natively, which means all the string processing functions will mangle and corrupt your strings. So you have to either use a separate library for proper utf8 support, or rewrite all the string handling functions yourself.The easy part is just specifying the charset in HTTP headers and in the database and such, but none of that matters if your PHP code doesn\'t output valid UTF8. That\'s the hard part, and PHP gives you virtually no help there. (I think PHP6 is supposed to fix the worst of this, but that\'s still a while away)If you want MySQL server to decide character set, and not PHP as a client (old behaviour; preferred, in my opinion), try adding skip-character-set-client-handshake to your my.cnf, under [mysqld], and restart mysql.This may cause troubles in case you\'re using anything other than UTF8.The top answer is excellent. Here is what I had to on a regular debian/php/mysql setup:that was all !