What is the difference between __str__ and __repr__ in Python?Alex summarized well but, surprisingly, was too succinct.First, let me reiterate the main points in Alex\xe2\x80\x99s post:Default implementation is uselessThis is mostly a surprise because Python\xe2\x80\x99s defaults tend to be fairly useful. However, in this case, having a default for __repr__ which would act like:would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if __repr__ is defined, and __str__ is not, the object will behave as though __str__=__repr__.This means, in simple terms: almost every object you implement should have a functional __repr__ that\xe2\x80\x99s usable for understanding the object. Implementing __str__ is optional: do that if you need a \xe2\x80\x9cpretty print\xe2\x80\x9d functionality (for example, used by a report generator).The goal of __repr__ is to be unambiguousLet me come right out and say it \xe2\x80\x94 I do not believe in debuggers. I don\xe2\x80\x99t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature \xe2\x80\x94 most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is aBut you have to do the last step \xe2\x80\x94 make sure every object you implement has a useful repr, so code like that can just work. This is why the \xe2\x80\x9ceval\xe2\x80\x9d thing comes up: if you have enough information so eval(repr(c))==c, that means you know everything there is to know about c. If that\xe2\x80\x99s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about c anyway. I usually use an eval-like format: "MyClass(this=%r,that=%r)" % (self.this,self.that). It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \xe2\x80\x94 but it is a useful form to express \xe2\x80\x9cthis is everything you need to know about this instance\xe2\x80\x9d.Note: I used %r above, not %s. You always want to use repr() [or %r formatting character, equivalently] inside __repr__ implementation, or you\xe2\x80\x99re defeating the goal of repr. You want to be able to differentiate MyClass(3) and MyClass("3").The goal of __str__ is to be readableSpecifically, it is not intended to be unambiguous \xe2\x80\x94 notice that str(3)==str("3"). Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be "2010/4/12 15:35:22", etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class \xe2\x80\x94 as long is it supports readability, it is an improvement.Container\xe2\x80\x99s __str__ uses contained objects\xe2\x80\x99 __repr__This seems surprising, doesn\xe2\x80\x99t it? It is a little, but how readable wouldbe? Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you\xe2\x80\x99re printing a list, just(you can probably also figure out what to do about dictionaries.SummaryImplement __repr__ for any class you implement. This should be second nature. Implement __str__ if you think it would be useful to have a string version which errs on the side of more readability in favor of more ambiguity.My rule of thumb:  __repr__ is for developers, __str__ is for customers.Unless you specifically act to ensure otherwise, most classes don\'t have helpful results for either:As you see -- no difference, and no info beyond the class and object\'s id.  If you only override one of the two...:as you see, if you override __repr__, that\'s ALSO used for __str__, but not vice versa.Other crucial tidbits to know: __str__ on a built-on container uses the __repr__, NOT the __str__, for the items it contains. And, despite the words on the subject found in typical docs, hardly anybody bothers making the __repr__ of objects be a string that eval may use to build an equal object (it\'s just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible).So, my advice: focus on making __str__ reasonably human-readable, and __repr__ as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making __repr__\'s returned value acceptable as input to __eval__!__repr__: representation of python object usually eval will convert it back to that object__str__: is whatever you think is that object in text forme.g.In short, the goal of __repr__ is to be unambiguous and __str__ is to be\n  readable.Here is a good example:Read this documentation for repr:repr(object)Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse\n  quotes). It is sometimes useful to be able to access this operation as\n  an ordinary function. For many types, this function makes an attempt\n  to return a string that would yield an object with the same value when\n  passed to eval(), otherwise the representation is a string enclosed in\n  angle brackets that contains the name of the type of the object\n  together with additional information often including the name and\n  address of the object. A class can control what this function returns\n  for its instances by defining a __repr__() method.Here is the documentation for str:str(object=\'\')Return a string containing a nicely printable\n  representation of an object. For strings, this returns the string\n  itself. The difference with repr(object) is that str(object) does not\n  always attempt to return a string that is acceptable to eval(); its\n  goal is to return a printable string. If no argument is given, returns\n  the empty string, \'\'.__str__ (read as "dunder (double-underscore) string") and __repr__ (read as "dunder-repper" (for "representation")) are both special methods that return strings based on the state of the object. __repr__ provides backup behavior if __str__ is missing. So one should first write a __repr__ that allows you to reinstantiate an equivalent object from the string it returns e.g. using eval or by typing it in character-for-character in a Python shell. At any time later, one can write a __str__ for a user-readable string representation of the instance, when one believes it to be necessary.If you print an object, or pass it to format, str.format, or str, then if a __str__ method is defined, that method will be called, otherwise, __repr__ will be used. The __repr__ method is called by the builtin function repr and is what is echoed on your python shell when it evaluates an expression that returns an object. Since it provides a backup for __str__, if you can only write one, start with __repr__Here\'s the builtin help on repr:That is, for most objects, if you type in what is printed by repr, you should be able to create an equivalent object. But this is not the default implementation.The default object __repr__ is (C Python source) something like:That means by default you\'ll print the module the object is from, the class name, and the hexadecimal representation of its location in memory - for example:This information isn\'t very useful, but there\'s no way to derive how one might accurately create a canonical representation of any given instance, and it\'s better than nothing, at least telling us how we might uniquely identify it in memory.Let\'s look at how useful it can be, using the Python shell and datetime objects. First we need to import the datetime module:If we call datetime.now in the shell, we\'ll see everything we need to recreate an equivalent datetime object. This is created by the datetime __repr__:If we print a datetime object, we see a nice human readable (in fact, ISO) format. This is implemented by datetime\'s __str__:It is a simple matter to recreate the object we lost because we didn\'t assign it to a variable by copying and pasting from the __repr__ output, and then printing it, and we get it in the same human readable output as the other object:As you\'re developing, you\'ll want to be able to reproduce objects in the same state, if possible. This, for example, is how the datetime object defines __repr__ (Python source). It is fairly complex, because of all of the attributes needed to reproduce such an object:If you want your object to have a more human readable representation, you can implement __str__ next. Here\'s how the datetime object (Python source) implements __str__, which it easily does because it already has a function to display it in ISO format:This is a critique of another answer here that suggests setting __repr__ = __str__.Setting __repr__ = __str__ is silly - __repr__ is a fallback for __str__ and a __repr__, written for developers usage in debugging, should be written before you write a __str__.You need a __str__ only when you need a textual representation of the object.Define __repr__ for objects you write so you and other developers have a reproducible example when using it as you develop. Define __str__ when you need a human readable string representation of it. In all honesty, eval(repr(obj)) is never used. If you find yourself using it, you should stop, because eval is dangerous, and strings are a very inefficient way to serialize your objects (use pickle instead). Therefore, I would recommend setting __repr__ = __str__. The reason is that str(list) calls repr on the elements (I consider this to be one of the biggest design flaws of Python that was not addressed by Python 3). An actual repr will probably not be very helpful as the output of print [your, objects]. To qualify this, in my experience, the most useful use case of the repr function is to put a string inside another string (using string formatting). This way, you don\'t have to worry about escaping quotes or anything. But note that there is no eval happening here. From http://pyref.infogami.com/str by effbot:__str__ "computes the "informal" string representation of an object. This differs from __repr__ in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead."To put it simply:__str__ is used in to show a string representation of your object to be read easily by others.__repr__ is used to show a string representation of the object.Let\'s say I want to create a Fraction class where the string representation of a fraction is \'(1/2)\' and the object (Fraction class) is to be represented as \'Fraction (1,2)\'So we can create a simple Fraction class:Apart from all the answers given, I would like to add few points :-1) __str__() is invoked when you use object with print statement. In case, if __str__ is missing, then print invokes __repr__() of object.2) __repr__() is invoked when you simply write object\'s name on interactive python console and press enter.3) __str__() of containers, when invoked will execute __repr__() method of its contained elements.str - Creates a new string object from the given object.repr - Returns the canonical string representation of the object.The differences:str():repr():On page 358 of the book Python scripting for computational science by Hans Petter Langtangen, it clearly states that So, I prefer to understand them asfrom the user point of view\nalthough this is a misunderstanding i made when learning python.A small but good example is also given on the same page as follows:When print() is called on the result of decimal.Decimal(23) / deci- mal.Decimal("1.05") the raw number is printed; this output is in string form which can be achieved with __str __(). If we simply enter the expression we get a decimal.Decimal output\xe2\x80\x94this output is in representational form which can be achieved with __repr __(). All Python objects have two output forms. String form is designed to be human-readable. Representational form is designed to produce output that if fed to a Python interpreter would (when possible) re- produce the represented objectOne important thing to keep in mind is that container\'s __str__ uses contained objects\' __repr__.Python favors unambiguity over readability, the __str__ call of a tuple calls the contained objects\' __repr__, the "formal" representation of an object. Although the formal representation is harder to read than an informal one, it is unambiguous and more robust against bugs.Excellent answers are already cover the difference between __str__ and __repr__, which for me boils down to the former being readable even by an end user, and the latter being as useful as possible to developers. Given that, I find that the default implementation of __repr__ often fails to achieve this goal because it omits information useful to developers.For this reason, if I have a simple enough __str__, I generally just try to get the best of both worlds with something like:One aspect that is missing in other answers. It\'s true that in general the pattern is:Unfortunately, this differentiation is flawed, because the Python REPL and also IPython use __repr__ for printing objects in a REPL console (see related questions for Python and IPython). Thus, projects which are targeted for interactive console work (e.g., Numpy or Pandas) have started to ignore above rules and provide a human-readable __repr__ implementation instead.From the book: Fluent Python