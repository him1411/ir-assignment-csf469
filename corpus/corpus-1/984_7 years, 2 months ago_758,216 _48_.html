I have a class called Order which has properties such as OrderId, OrderDate, Quantity, and Total. I have a list of this Order class:Now I want to sort the list based on one property of the Order object, for example I need to sort it by the order date or order id.How can i do this in C#?The easiest way I can think of is to use Linq:If you need to sort the list in-place then you can use the Sort method, passing a Comparison<T> delegate:If you prefer to create a new, sorted sequence rather than sort in-place then you can use LINQ\'s OrderBy method, as mentioned in the other answers.To do this without LINQ on .Net2.0:If you\'re on .Net3.0, then LukeH\'s answer is what you\'re after.To sort on multiple properties, you can still do it within a delegate. For example:This would give you ascending dates with descending orderIds. However, I wouldn\'t recommend sticking delegates as it will mean lots of places without code re-use. You should implement an IComparer and just pass that through to your Sort method. See here.And then to use this IComparer class, just instantiate it and pass it to your Sort method:If you want something like Then try like following.Doing it without Linq as you said:Then just call .sort() on your list of Orders// Totally generic sorting for use with a gridviewA Classical Object Oriented SolutionFirst I must genuflect to the awesomeness of LINQ....  Now that we\'ve got that out of the wayA variation on JimmyHoffa answer. With generics the CompareTo parameter becomes type safe.This default sortability is re-usable of course. That is each client does not have to redundantly re-write the sorting logic. Swapping the "1" and "-1" (or the logic operators, your choice) reverses the sort order.Here is a generic LINQ extension method that does not create an extra copy of the list:To use it:I recently built this additional one which accepts an ICompare<U>, so that you can customize the comparison.  This came in handy when I needed to do a Natural string sort:Using LINQYou can do something more generic about the properties selection yet be specific about the type you\'re selecting from, in your case \'Order\':write your function as a generic one:and then use it like this:You can be even more generic and define an open type for what you want to order:and use it the same way:Which is a stupid unnecessary complex way of doing a LINQ style \'OrderBy\',\nBut it may give you a clue of how it can be implemented in a generic wayPlease let me complete the answer by @LukeH with some sample code, as I have tested it I believe it may be useful for some:An improved of Roger\'s version.The problem with GetDynamicSortProperty is that only get the property names but what happen if in the GridView we use NavigationProperties? it will send an exception, since it finds null.Example:"Employee.Company.Name; " will crash... since allows only "Name" as a parameter to get its value.Here\'s an improved version that allows us to sort by Navigation Properties.None of the above answers were generic enough for me so I made this one:Careful on massive data sets though. It\'s easy code but could get you in trouble if the collection is huge and the object type of the collection has a large number of fields.\nRun time is NxM where:N = # of Elements in collectionM = # of Properties within Object Make use of LiNQ OrderBy From performance point of view the best is to use a sorted list so that data is sorted as it is added to result.\nOther approaches need at least one extra iteration on data and most create a copy of data so not only performance but memory usage will be affected too. Might not be an issue with couple of hundreds of elements but will be with thousands, especially in services where many concurrent requests may do sorting at the same time.\nHave a look at System.Collections.Generic namespace and choose a class with sorting instead of List.And avoid generic implementations using reflection when possible, this can cause performance issues too.Based on GenericTypeTea\'s Comparer :\nwe can obtain more flexibility by adding sorting flags :  In this scenario, you must instantiate it as MyOrderingClass explicitly( rather then IComparer )\nin order to set its sorting properties :   Anybody working with nullable types, Value is required to use CompareTo.objListOrder.Sort((x, y) => x.YourNullableType.Value.CompareTo(y.YourNullableType.Value));