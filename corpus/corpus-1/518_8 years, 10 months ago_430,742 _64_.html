In most of programming languages, dictionaries are preferred over hashtables.\nWhat are the reasons behind that?For what it\'s worth, a Dictionary is a hash table.If you meant "why do we use the Dictionary class instead of the Hashtable class?", then it\'s an easy answer: Dictionary is a generic type, Hashtable is not. That means you get type safety with Dictionary, because you can\'t insert any random object into it, and you don\'t have to cast the values you take out.Dictionary <<<>>> Hashtable differences:Dictionary / Hashtable similarities:Similar .NET collections (candidates to use instead of Dictionary and Hashtable):Because Dictionary is a generic class ( Dictionary<TKey, TValue> ), so that accessing its content is type-safe (i.e. you do not need to cast from Object, as you do with a Hashtable).ComparetoHowever, Dictionary is implemented as Hashtable inside, so technically it works the same way.FYI: In .Net Hashtable is thread safe for use by multiple reader threads and a single writing thread, while in Dictionary public static members are thread safe, but any instance members are not guaranteed to be thread safe.We had to change all our Dictionaries back to Hashtable because of this.In .NET, the difference between Dictionary<,> and HashTable is primarily that the former  is a generic type, so you get all the benefits of generics in terms of static type checking (and reduced boxing, but this isn\'t as big as people tend to think in terms of performance - there is a definite memory cost to boxing, though).People are saying that a Dictionary is the same as a hash table.This is not necessarily true. A hash table is an implementation of a dictionary. A typical one at that, and it may be the default one in .NET, but it\'s not by definition the only one.You could equally well implement a dictionary with a linked list or a search tree, it just wouldn\'t be as efficient (for some metric of efficient).Collections & Generics are useful for handling group of Objects. In .net, all the collections objects comes under the interface IEnumerable, Which in turn has ArrayList(Index-Value)) & HashTable(Key-Value). After .net framework 2.0, ArrayList & HashTable were replaced with List & Dictionary. Now, the Arraylist & HashTable are no more used in now a days projects.Coming to difference between HashTable & Dictionary, Dictionary is generic where as Hastable is not Generic. We can add any type of object to HashTable, but while retrieving we need to Cast it to the required Type. So, it is not type safe. But to dictionary, while declaring itself we can specify the type of Key & Value, so no need to cast while retrieving. Let\'s look at an example:HashTableDictionary,Dictionary:It returns/throws Exception if we try to find a key which does not exist.It is faster than a Hashtable because there is no boxing and unboxing.Only public static members are thread safe.Dictionary is a generic type which means we can use it with any data type (When creating, must specify the data types for both keys and values).Example: Dictionary<string, string> <NameOfDictionaryVar> = \n               new Dictionary<string, string>();Dictionay is a type-safe implementation of Hashtable, Keys and Values are strongly typed.Hashtable:It returns null if we try to find a key which does not exist.It is slower than dictionary because it requires boxing and unboxing.All the members in a Hashtable are thread safe,Hashtable is not a generic type,Hashtable is loosely-typed data structure, we can add keys and values of any type.The Extensive Examination of Data Structures Using C# article on MSDN states that there is also a difference in the  collision resolution strategy:The Hashtable class uses a technique referred to as rehashing. Rehashing works as follows: there is a set of hash different functions,\n  H1 ... Hn, and when inserting or retrieving an item from the hash\n  table, initially the H1 hash function is used. If this leads to a\n  collision, H2 is tried instead, and onwards up to Hn if needed.The Dictionary uses a technique referred to as chaining. With rehashing, in the event of a collision the hash is recomputed, and the new slot corresponding to a hash is tried.  With chaining, however, a secondary data structure is utilized to hold\n  any collisions. Specifically, each slot in the Dictionary has an array\n  of elements that map to that bucket. In the event of a collision, the\n  colliding element is prepended to the bucket\'s list.Since .Net Framework 3.5 there is also a HashSet<T> which provides all the pros of the Dictionary<TKey, TValue> if you need only the keys and no values.So if you use a Dictionary<MyType, object> and always set the value to null to simulate the type safe hash table you should maybe consider switching to the HashSet<T>.The Hashtable is a loosely-typed data structure, so you can add keys and values of any type to the Hashtable. The Dictionary class is a type-safe Hashtable implementation, and the keys and values are strongly typed. When creating a Dictionary instance, you must specify the data types for both the key and value.Notice that MSDN says: "Dictionary<(Of <(TKey, TValue>)>) class is implemented as a hash table" not "Dictionary<(Of <(TKey, TValue>)>) class is implemented as a HashTable"\nDictionary is NOT implemented as a HashTable, but is implemented following the concept of a hash table.  The implementation is unrelated to the HashTable class because of the use of Generics, although internally Microsoft could have used the same code and replaced the symbols of type Object with TKey and TValue.  In .NET 1.0 Generics did not exist; this is where the HashTable and ArrayList originally began.A Hashtable object consists of buckets that contain the elements of the collection. A bucket is a virtual subgroup of elements within the Hashtable, which makes searching and retrieving easier and faster than in most collections.The Dictionary class has the same functionality as the Hashtable class. A Dictionary of a specific type (other than Object) has better performance than a Hashtable for value types because the elements of Hashtable are of type Object and, therefore, boxing and unboxing typically occur if storing or retrieving a value type.For further reading: Hashtable and Dictionary Collection Typesone more difference that i can figure out is we can not use dictionary (generics) with web services the reason is no web service standard supports genrics standard. Dictionary<> is a generic type and so its type safe.You can insert any value type in HashTable and this may sometimes throw an exception.\nBut Dictionary<int> will only accept integer value and similarly Dictionary<string> will only accept strings.So, it is better to use Dictionary<> instead of HashTableAnother important difference is that Hashtable is thread safe. Hashtable has built in multiple reader/single writer (MR/SW) thread safety which means Hashtable allows ONE writer together with multiple readers without locking. In the case of Dictionary there is no thread safety, if you need thread safety you must implement your own synchronization.To elaborate further:Hashtable, provide some thread-safety through the Synchronized property, which returns a thread-safe wrapper around the collection. The wrapper works by locking the entire collection on every add or remove operation. Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock. This is not scalable and can cause significant performance degradation for large collections. Also, the design is not completely protected from race conditions.The .NET Framework 2.0 collection classes like  List<T>, Dictionary<TKey, TValue>, etc do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrentlyIf you need type safety as well thread safety, use concurrent collections classes in the .NET Framework. Further reading here.An additional difference is that when we add the multiple entries in Dictionary, the order in which the entries are added is maintained. When we retrieve the items from Dictionary we will get the records in the same order we have inserted them. Whereas Hashtable doesn\'t preserve the insertion order.HashTable : Key/Value will be converted into object(boxing) type while storing into the heap.Key/Value needs to be converted into desired type while reading from the heap. This operations are very costly. We need to avoid boxing/unboxing as much as possible. Dictionary : Generic variant of HashTable. No boxing/unboxing. No conversions required. According to what I see by using reflector:so we can be sure that DictionaryBase uses a HashTable internally.