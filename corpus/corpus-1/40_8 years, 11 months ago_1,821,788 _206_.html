Is there a good way to explain how to resolve merge conflicts in Git?Try: git mergetoolIt opens a GUI that steps you through each conflict, and you get to choose how to merge.  Sometimes it requires a bit of hand editing afterwards, but usually it\'s enough by itself.  It is much better than doing the whole thing by hand certainly.As per @JoshGlover comment:The command doesn\'t necessarily open a GUI unless you install one. Running git mergetool for me resulted in vimdiff being used. You can install one of the following tools to use it instead: meld, opendiff, kdiff3, tkdiff, xxdiff, tortoisemerge, gvimdiff, diffuse, ecmerge, p4merge, araxis, vimdiff, emerge.Here\'s a probable use-case, from the top:You\'re going to pull some changes, but oops, you\'re not up to date:So you get up-to-date and try again, but have a conflict:So you decide to take a look at the changes:Oh me, oh my, upstream changed some things, but just to use my changes...no...their changes...And then we try a final timeTa-da!I find merge tools rarely help me understand the conflict or the resolution. I\'m usually more successful looking at the conflict markers in a text editor and using git log as a supplement.Here are a few tips:The best thing I have found is to use the "diff3" merge conflict style:git config merge.conflictstyle diff3This produces conflict markers like this:The middle section is what the common ancestor looked like. This is useful because you can compare it to the top and bottom versions to get a better sense of what was changed on each branch, which gives you a better idea for what the purpose of each change was.If the conflict is only a few lines, this generally makes the conflict very obvious. (Knowing how to fix a conflict is very different; you need to be aware of what other people are working on. If you\'re confused, it\'s probably best to just call that person into your room so they can see what you\'re looking at.)If the conflict is longer, then I will cut and paste each of the three sections into three separate files, such as "mine", "common" and "theirs".Then I can run the following commands to see the two diff hunks that caused the conflict:This is not the same as using a merge tool, since a merge tool will include all of the non-conflicting diff hunks too. I find that to be distracting.Somebody already mentioned this, but understanding the intention behind each diff hunk is generally very helpful for understanding where a conflict came from and how to handle it.This shows all of the commits that touched that file in between the common ancestor and the two heads you are merging. (So it doesn\'t include commits that already exist in both branches before merging.) This helps you ignore diff hunks that clearly are not a factor in your current conflict.Verify your changes with automated tools.If you have automated tests, run those. If you have a lint, run that. If it\'s a buildable project, then build it before you commit, etc. In all cases, you need to do a bit of testing to make sure your changes didn\'t break anything. (Heck, even a merge without conflicts can break working code.)Plan ahead; communicate with co-workers.Planning ahead and being aware of what others are working on can help prevent merge conflicts and/or help resolve them earlier -- while the details are still fresh in mind. For example, if you know that you and another person are both working on different refactoring that will both affect the same set of files, you should talk to each other ahead of time and get a better sense for what types of changes each of you is making. You might save considerable time and effort if you conduct your planned changes serially rather than in parallel. For major refactorings that cut across a large swath of code, you should strongly consider working serially: everybody stops working on that area of the code while one person performs the complete refactoring.If you can\'t work serially (due to time pressure, maybe), then communicating about expected merge conflicts at least helps you solve the problems sooner while the details are still fresh in mind. For example, if a co-worker is making a disruptive series of commits over the course of a one-week period, you may choose to merge/rebase on that co-workers branch once or twice each day during that week. That way, if you do find merge/rebase conflicts, you can solve them more quickly than if you wait a few weeks to merge everything together in one big lump.If you\'re unsure of a merge, don\'t force it.Merging can feel overwhelming, especially when there are a lot of conflicting files and the conflict markers cover hundreds of lines. Often times when estimating software projects we don\'t include enough time for overhead items like handling a gnarly merge, so it feels like a real drag to spend several hours dissecting each conflict.In the long run, planning ahead and being aware of what others are working on are the best tools for anticipating merge conflicts and prepare yourself to resolve them correctly in less time.Identify which files are in conflict (Git should tell you this).Open each file and examine the diffs; Git demarcates them.  Hopefully it will be obvious which version of each block to keep.  You may need to discuss it with fellow developers who committed the code.Once you\'ve resolved the conflict in a file git add the_file.Once you\'ve resolved all conflicts, do git rebase --continue or whatever command \nGit said to do when you completed.Check out the answers in Stack Overflow question Aborting a merge in Git, especially Charles Bailey\'s answer which shows how to view the different versions of the file with problems, for example, Merge conflicts happens when changes are made to a file at the same time. Here is how to solve it.Here are simple steps what to do when you get into conflicted state:Solve the conflicts separately for each file by one of the following approaches:Use GUI to solve the conflicts: git mergetool (the easiest way).To accept remote/other version, use: git checkout --theirs path/file. This will reject any local changes you did for that file.To accept local/our version, use: git checkout --ours path/fileHowever you\'ve to be careful, as remote changes that conflicts were done for some reason.Related: What is the precise meaning of "ours" and "theirs" in git?Edit the conflicted files manually and look for the code block between <<<<</>>>>> then choose the version either from above or below =====. See: How conflicts are presented.Path and filename conflicts can be solved by git add/git rm.Finally, review the files ready for commit using: git status.If you still have any files under Unmerged paths, and you did solve the conflict manually, then let Git know that you solved it by: git add path/file.If all conflicts were solved successfully, commit the changes by: git commit -a and push to remote as usual.See also: Resolving a merge conflict from the command line at GitHubI\'ve successfully used DiffMerge which can visually compare and merge files on Windows, macOS and Linux/Unix.It graphically can show the changes between 3 files and it allows automatic merging (when safe to do so) and full control over editing the resulting file.Image source: DiffMerge (Linux screenshot)Simply download it and run in repo as:On macOS you can install via:And probably (if not provided) you need the following extra simple wrapper placed in your PATH (e.g. /usr/bin):Then you can use the following keyboard shortcuts:Alternatively you can use opendiff (part of Xcode Tools) which lets you merge two files or directories together to create a third file or directory.If you\'re making frequent small commits, then start by looking at the commit comments with git log --merge. Then git diff will show you the conflicts.For conflicts that involve more than a few lines, it\'s easier to see what\'s going on in an external GUI tool. I like opendiff -- Git also supports vimdiff, gvimdiff, kdiff3, tkdiff, meld, xxdiff, emerge out of the box and you can install others: git config merge.tool "your.tool" will set your chosen tool and then git mergetool after a failed merge will  show you the diffs in context.Each time you edit a file to resolve a conflict, git add filename will update the index and your diff will no longer show it. When all the conflicts are handled and their files have been git add-ed, git commit will complete your merge.See How Conflicts Are Presented or, in Git, the git merge documentation to understand what merge conflict markers are.Also, the How to Resolve Conflicts section explains how to resolve the conflicts:After seeing a conflict, you can do two things:Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this.Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit to seal the deal.You can work through the conflict with a number of tools:Use a mergetool. git mergetool to launch a graphical mergetool which will work you through the merge.Look at the diffs. git diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions.Look at the diffs from each branch. git log --merge -p <path> will show diffs first for the HEAD version and then the MERGE_HEAD version.Look at the originals. git show :1:filename shows the common ancestor, git show :2:filename shows the HEAD version, and git show :3:filename shows the MERGE_HEAD version.You can also read about merge conflict markers and how to resolve them in the Pro Git book section Basic Merge Conflicts.For Emacs users which want to resolve merge conflicts semi-manually:shows all files which require conflict resolution.Open each of those files one by one, or all at once by:When visiting a buffer requiring edits in Emacs, typeThis will open three buffers (mine, theirs, and the output buffer). Navigate by pressing \'n\' (next region), \'p\' (prevision region). Press \'a\' and \'b\' to copy mine or theirs region to the output buffer, respectively. And/or edit the output buffer directly.When finished: Press \'q\'. Emacs asks you if you want to save this buffer: yes.\nAfter finishing a buffer mark it as resolved by running from the teriminal:When finished with all buffers typeto finish the merge.Please follow the following steps to fix merge conflicts in git:Check the git status:\ngit statusGet the patchset:\ngit fetch (checkout the right patch from your git commit)Checkout a local branch (temp1 in my example here):\ngit checkout -b temp1Pull the recent contents from master:\ngit pull --rebase origin masterStart the mergetool and check the conflicts and fix them...and check the changes in the remote branch with your current branch:\ngit mergetoolCheck the status again:\n git statusDelete the unwanted files locally created by mergetool, usually mergetool creates extra file with *.orig extension. Please delete that file as that is just the duplicate and fix changes locally and add the correct version of your files.\ngit add #your_changed_correct_filescheck the status again:\ngit statusCommit the changes to the same commit id (this avoids a new separate patch set):\ngit commit --amendPush to the master branch:\ngit push (to your git repository) simply, if you know well that changes in one of the repositories is not important, and want to resolve all changes in favor of the other one, so use:to resolve changes in the favor of your repository, orto resolve changes in favor of the other or the main repository.Or else you will have to use a GUI merge tool to step through files one by one, say the merge tool is p4merge, or write any one\'s name you\'ve already installedand after finishing a file, you will have to save and close, so the next one will openYou could fix merge conflicts in a number of ways as other have detailed.I think the real key is knowing how changes flow with local and remote repositories.  The key to this is understanding tracking branches.  I have found that I think of the tracking branch as the \'missing piece in the middle\' between me my local, actual files directory and the remote defined as origin.  I\'ve personally got into the habit of 2 things to help avoid this.Instead of:Which has two drawbacks - a) All new/changed files get added and that might include some unwanted changes.\nb) You don\'t get to review the file list first.So instead I do:This way you are more deliberate about which files get added and you also get to review the list and think a bit more while using the editor for the message.  I find it also improves my commit messages when I use a full screen editor rather than the -m option.[Update - as time has passed I\'ve switched more to:]Also (and more relevant to your situation), I try to avoid:orbecause pull implies a merge and if you have changes locally that you didn\'t want merged you can easily end up with merged code and/or merge conflicts for code that shouldn\'t have been merged.Instead I try to doYou may also find this helpful:git branch, fork, fetch, merge, rebase and clone, what are the differences?In speaking of pull/fetch/merge in the above answers, I would like to share an interesting and productive trick,This above command is the most useful command in my git life which saved a lots of time.Before pushing your newly committed change to remote server, try git pull --rebase rather git pull and manual merge and it will automatically sync latest remote server changes (with a fetch + merge) and will put your local latest commit at the top in git log. No need to worry about manual pull/merge.In case of conflict, just use Find details at: http://gitolite.com/git-pull--rebaseI either want my or their version in full, or want to review individual changes and decide for each of them.Fully accept my or theirs version:Accept my version (local, ours): Accept their version (remote, theirs):If you want to do for all conflict files run:orReview all changes and accept them individuallyDefault mergetool works in command line. How to use a command line mergetool should be a separate question. You can also install visual tool for this, e.g. meld and run It will open local version (ours), "base" or "merged" version (the current result of the merge) and remote version (theirs). Save the merged version when you  are finished, run git mergetool -t meld again until you get "No files need merging", then go to Steps 3. and 4.CoolAJ86\'s answer sums up pretty much everything. In case you have changes in both branches in the same piece of code you will have to do a manual merge. Open the file in conflict in any text editor and you should see following structure.Choose one of the alternatives or a combination of both in a way that you want new code to be, while removing equal signs and angle brackets. Does not seem to always work for me and usually ends up displaying every commit that was different between the two branches, this happens even when using -- to separate the path from the command.What I do to work around this issue is open up two command lines and in one runand in the otherReplacing $MERGED_IN_BRANCH with the branch I merged in and [path] with the file that is conflicting. This command will log all the commits, in patch form, between (..) two commits. If you leave one side empty like in the commands above git will automatically use HEAD (the branch you are merging into in this case).This will allow you to see what commits went into the file in the two branches after they diverged. It usually makes it much easier to solve conflicts.As of December 12th 2016, you can merge branches and resolve conflicts on github.comThus, if you don\'t want to use the command-line or any 3rd party tools that are offered here from older answers, go with GitHub\'s native tool.This blog post explains in detail, but the basics are that upon \'merging\' two branches via the UI, you will now see a \'resolve conflicts\' option that will take you to an editor allowing you to deal with these merge conflicts.I always follow the below steps to avoid conflicts.Now you can do the same and maintain as many local branches you want and work simultaneous my just doing a git checkout to your branch when ever necessary.if you want to merge from branch(test) to master, you can follow these steps:Step1: go to the branchStep2: git pull --rebase origin masterStep3: if there are some conflicts, go to these files to modify it.Step4: add these changesStep5: git rebase --continueStep6: if there is still conflict, go back to Step3 again. If there is no conflict, do following: git push origin +testStep7: and then there is no conflict between test and master. you can use merge directly. Merge conflicts could occur in different situations:You need to install a merge tool which is compatible with Git to resolve the conflicts. I personally use KDiff3 and I\'ve found it nice and handy. You can download its windows version here: https://sourceforge.net/projects/kdiff3/files/BTW if you install Git Extensions there is an option in its setup wizard to install Kdiff3.Then setup git configs to use Kdiff as its mergetool :(Remember to replace the path with the actual path of Kdiff exe file.)Then every time you come across a merge conflict you just need to run this command :Then it opens the Kdiff3, and first tries to resolve the merge conflicts automatically. Most of the conflicts would be resolved spontaneously and you need to fix the rest manually. Here\'s what Kdiff3 looks like:\nThen once you\'re done, save the file and it goes to the next file with conflict and you do the same thing again until all the conflicts are resolved.To check if everything is merged successfully, just run the mergetool command again, you should get this result :I\'m surprised no one else spoke about resolving conflict using patience with the merge recursive strategy. For big merge conflict, using patience provided good results for me. The idea is that it will try to match blocks rather than individual lines.If you change the indentation of your program for instance, the default git merge strategy sometimes matches single braces { which belongs to different functions. This is avoided with patience.From the documentation:If you have a merge conflict and want to see what others had in mind when modifying their branch, it\'s sometimes easier to compare their branch directly with the common ancestor (instead of our branch). For that you can use merge-base:Usually, you only want to see the changes for a particular file:There are 3 steps:Check the files, in which you would find the conflicts marked like<<<<<<<<head\nblablablaChange the way you want it ,then with commandsgit fetch \n  git checkout your branch\n  git rebase masterIn this step you will try to fix the conflict using your prefer IDEYou can follow this link to check ho to fix the conflict in the file\nhttps://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/git add\n  git rebase --continue\n  git commit --amend\n  git push origin HEAD:refs/drafts/master  (push like a drafts)Now every thing is fine and you will find your commit in gerritI hope that this will help every one concerning this issue. A safer way to resolve conflicts is to use git-mediate (the common solutions suggested here are quite error prone imho).See this post for a quick intro on how to use it.This has always been faster and easier for me than using GiT. It is especially beneficial if changes mess up a pull request and your IDE doesn\'t handle GiT merges very well.If you are using intelliJ as IDE\nTry to merge parent to your branch byIt will show all conflicts like thisA_MBPro:test anu$ git merge origin/ Auto-merging\n  src/test/java/com/.../TestClass.java CONFLICT\n  (content): Merge conflict in\n  src/test/java/com/.../TestClass.javaNow note that the file TestClass.java is shown in red in intelliJ\nAlso git status will show Open the file in intelliJ, it will have sections with where HEAD is changes on your local branch and origin/ is changes from the remote branch. Here keep the stuff that you need and remove the stuff you don\'t need.After that the normal steps should do. That isgit checkout branch1git fetch origingit rebase -p origin/mainbranchIf there are merge conflicts, fix them. Then, continue the rebase process by running: git rebase \xe2\x80\x93-continueafter the fixing you can commit and push your local branch to remote branchgit push origin branch1According to github blog post "You can now resolve simple merge conflicts on GitHub right from your pull requests, saving you a trip to the command line and helping your team merge pull requests faster."In simple words, What you do is,  push your changes to your remote repository on GitHub and merge your changes in a pull request.Please use the following official github link which explain the the process in simple steps. If you do not want to use github, then you can always use difftool. My recommended one is meld. Please see the video tutorial here.For those who are using Visual Studio (2015 in my case)Close your project in VS. Especially in big projects VS tends to freak out when merging using the UI.Do the merge in command prompt. git checkout target_branchgit merge source_branchThen open the project in VS and go to Team Explorer -> Branch.  Now there is a message that says Merge is pending and conflicting files are listed right below the message.Click the conflicting file and you will have the option to Merge, Compare, Take Source, Take Target.  The merge tool in VS is very easy to use.if you not use tool to merge, \nfirst copy your code outsiteit resolve conflict and you can copy your code.