What does .PHONY mean in a Makefile? I have gone through this, but it is too complicated.Can somebody explain it to me in simple terms?By default, Makefile targets are "file targets" - they are used to build files from other files. Make assumes its target is a file, and this makes writing Makefiles relatively easy:However, sometimes you want your Makefile to run commands that do not represent physical files in the file system. Good examples for this are the common targets "clean" and "all". Chances are this isn\'t the case, but you may potentially have a file named clean in your main directory. In such a case Make will be confused because by default the clean target would be associated with this file and Make will only run it when the file doesn\'t appear to be up-to-date with regards to its dependencies.These special targets are called phony and you can explicitly tell Make they\'re not associated with files, e.g.:Now make clean will run as expected even if you do have a file named clean.In terms of Make, a phony target is simply a target that is always out-of-date, so whenever you ask make <phony_target>, it will run, independent from the state of the file system. Some common make targets that are often phony are: all, install, clean, distclean, TAGS, info, check.For more information, there\'s a nice tutorial explaining it here.Let\'s assume you have install target, which is a very common in makefiles. If you do not use .PHONY, and a file named install exists in the same directory as the Makefile, then make install will do nothing. This is because Make interprets the rule to mean "execute such-and-such recipe to create the file named install". Since the file is already there, and its dependencies didn\'t change, nothing will be done.However if you make the install target PHONY, it will tell the make tool that the target is fictional, and that make should not expect it to create the actual file. Hence it will not check whether the install file exists, meaning: a) its behavior will not be altered if the file does exist and b) extra stat() will not be called.Generally all targets in your Makefile which do not produce an output file with the same name as the target name should be PHONY. This typically includes all, install, clean, distclean, and so on.NOTE: The make tool reads the makefile and checks the modification time-stamps of the files at both the side of \':\' symbol in a rule.In a directory \'test\' following files are present:In makefile a rule is defined as follows:Now assume that file \'hello\' is a text file containing some data, which was created after \'hello.c\' file. So the modification (or creation) time-stamp of \'hello\' will be newer than that of the \'hello.c\'. So when we will invoke \'make hello\' from command line, it will print as:Now access the \'hello.c\' file and put some white spaces in it, which doesn\'t affect the code syntax or logic and then save and quit. Now the modification time-stamp of hello.c is newer than that of the \'hello\'. Now if you invoke \'make hello\', it will execute the commands as:And the file \'hello\' (text file) will be overwritten with a new binary file \'hello\' (result of above compilation command).If we use .PHONY in makefile as follow:and then invoke \'make hello\', it will ignore if any file present in the pwd named \'hello\' and execute the command every time.Now suppose if no dependencies of target is there in makefile:and \'hello\' file is already present in the pwd \'test\', then \'make hello\' will always show as:It is a build target that is not a filename.The best explanation is the GNU make manual itself: 4.6 Phony Targets section..PHONY is one of make\'s Special Built-in Target Names. There are other targets that you may be interested in, so it\'s worth skimming through these references.When it is time to consider a .PHONY target, make will run its recipe\n  unconditionally, regardless of whether a file with that name exists or\n   what its last-modification time is.You may also be interested in make\'s Standard Targets such as all and clean.There\'s also one important tricky treat of ".PHONY" - when a physical target depends on phony target that depends on another physical target:TARGET1 -> PHONY_FORWARDER1 -> PHONY_FORWARDER2 -> TARGET2You\'d simply expect that if you updated TARGET2, then TARGET1 should be considered stale against TARGET1, so TARGET1 should be rebuild. And it really works this way.The tricky part is when TARGET2 isn\'t stale against TARGET1 - in which case you should expect that TARGET1 shouldn\'t be rebuild.This surprisingly doesn\'t work because: the phony target was run anyway (as phony targets normally do), which means that the phony target was considered updated. And because of that TARGET1 is considered stale against the phony target.Consider:You can play around with this:You can see that fileall depends on file1 indirectly through a phony target - but it always gets rebuilt due to this dependency. If you change the dependency in fileall from filefwd to file, now fileall does not get rebuilt every time, but only when any of dependent targets is stale against it as a file.