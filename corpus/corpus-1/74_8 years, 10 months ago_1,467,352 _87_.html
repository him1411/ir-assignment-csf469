If you have java.io.InputStream object, how should you process that object and produce a String?Suppose I have an InputStream that contains text data, and I want to convert this to a String. For example, so I can write the contents of the stream to a log file.What is the easiest way to take the InputStream and convert it to a String?A nice way to do this is using Apache commons IOUtils to copy the InputStream into a StringWriter... something likeor evenAlternatively, you could use ByteArrayOutputStream if you don\'t want to mix your Streams and WritersHere\'s a way using only standard Java library (note that the stream is not closed, YMMV).I learned this trick from "Stupid Scanner tricks" article. The reason it works is because Scanner iterates over tokens in the stream, and in this case we separate tokens using "beginning of the input boundary" (\\A) thus giving us only one token for the entire contents of the stream.Note, if you need to be specific about the input stream\'s encoding, you can provide the second argument to Scanner constructor that indicates what charset to use (e.g. "UTF-8").Hat tip goes also to Jacob, who once pointed me to the said article.EDITED: Thanks to a suggestion from Patrick, made the function more robust when handling an empty input stream. One more edit: nixed try/catch, Patrick\'s way is more laconic.Summarize other answers I found 11 main ways to do this (see below). And I wrote some performance tests (see results below):Ways to convert an InputStream to a String:Using IOUtils.toString (Apache Utils) Using CharStreams (guava) Using Scanner (JDK) Using Stream Api (Java 8). Warning: This solution convert different line breaks (like \\r\\n) to \\n.Using parallel Stream Api (Java 8). Warning: This solution convert different line breaks (like \\r\\n) to \\n.    Using InputStreamReader and StringBuilder (JDK) Using StringWriter and IOUtils.copy (Apache Commons)Using ByteArrayOutputStream and inputStream.read (JDK)  Using BufferedReader (JDK). Warning: This solution convert different line breaks (like \\n\\r) to line.separator system property (for example, in Windows to "\\r\\n").Using BufferedInputStream and ByteArrayOutputStream (JDK) Using inputStream.read() and StringBuilder  (JDK). Warning: This solution has problem with Unicode, for example with Russian text (work correctly only with non-Unicode text) Warning:Solutions 4, 5 and 9 convert different line breaks to one.Solution 11 can\'t work correctly with Unicode textPerformance testsPerformance tests for small String (length = 175), url in github (mode = Average Time, system = Linux, score 1,343 is the best):Performance tests for big String (length = 50100), url in github (mode = Average Time, system = Linux, score 200,715 is the best):Graphs (performance tests depending on Input Stream length in Windows 7 system)\nPerformance test (Average Time) depending on Input Stream length in Windows 7 system:Apache Commons allows: Of course, you could choose other character encodings besides UTF-8. Also see: (Docs)Taking into account file one should first get a java.io.Reader instance. This can then be read and added to a StringBuilder (we don\'t need StringBuffer if we are not accessing it in multiple threads, and StringBuilder is faster). The trick here is that we work in blocks, and as such don\'t need other buffering streams. The block size is parameterized for run-time performance optimization.How about this?If you are using Google-Collections/Guava you could do the following:Note that the second parameter (i.e. Charsets.UTF_8) for the InputStreamReader isn\'t necessary, but it is generally a good idea to specify the encoding if you know it (which you should!)This is my pure Java & Android solution, works well...Here\'s the most elegant, pure-Java (no library) solution I came up with after some experimentation:How about:For completeness here is Java 9 solution:The readAllBytes is currently in JDK 9 main codebase, so it likely to appear in the release. You can try it right now using the JDK 9 snapshot builds.I\'d use some Java 8 tricks.Essentially the same as some other answers except more succinct.I ran some timing tests because time matters, always.I attempted to get the response into a String 3 different ways. (shown below)\nI left out try/catch blocks for the sake readability.To give context, this is the preceding code for all 3 approaches:1)2)3)So, after running 500 tests on each approach with the same request/response data, here are the numbers. Once again, these are my findings and your findings may not be exactly the same, but I wrote this to give some indication to others of the efficiency differences of these approaches.Ranks:\nApproach #1\nApproach #3 - 2.6% slower than #1\nApproach #2 - 4.3% slower than #1Any of these approaches is an appropriate solution for grabbing a response and creating a String from it.Pure Java solution using Streams, works since Java 8.As mentioned by Christoffer Hammarstr\xc3\xb6m below other answer it is safer to explicitly specify the Charset. I.e. The InputStreamReader constructor can be changes as follows:Here\'s more-or-less sampath\'s answer, cleaned up a bit and represented as a function:If you were feeling adventurous, you could mix Scala and Java and end up with this:Mixing Java and Scala code and libraries has it\'s benefits.See full description here: Idiomatic way to convert an InputStream to a String in ScalaIf you can\'t use Commons IO (FileUtils/IOUtils/CopyUtils) here\'s an example using a BufferedReader to read the file line by line:or if you want raw speed I\'d propose a variation on what Paul de Vrieze suggested (which avoids using a StringWriter (which uses a StringBuffer internally) :This is an answer adapted from org.apache.commons.io.IOUtils source code, for those who want to have the apache implementation but do not want the whole library.Make sure to close the streams at end if you use Stream ReadersEDIT: On JDK 7+, you can use try-with-resources construct.Here is the complete method for converting InputStream into String without using any third party library. Use StringBuilder for single threaded environment otherwise use StringBuffer.  Here\'s how to do it using just the JDK using byte array buffers. This is actually how the commons-io IOUtils.copy() methods all work. You can replace byte[] with char[] if you\'re copying from a Reader instead of an InputStream.Kotlin users simply do:whereas is Kotlin standard library\xe2\x80\x99s built-in extension method.This one is nice because:What the for?The easiest way in JDK is with the following code snipplets. Another one, for all the Spring users:The utility methods in org.springframework.util.StreamUtils are similar to the ones in FileCopyUtils, but they leave the stream open when done.Well you can program it for yourself.. it\'s not complicated..JDK 7/8 answer that closes the stream and still throws an IOException:You can use apache commons.\nIn the IOUtils you can find the toString metod with 3 helpfull implementations.I have written a class that does just that, so I figured I\'d share it with everyone. Sometimes you don\'t want to add Apache Commons just for one thing, and want something dumber than Scanner that doesn\'t examine the content.Usage is as followsHere is the code for ReaderSink:Guava provides much shorter efficient autoclosing solution in case when input stream comes from classpath resource (which seems to be popular task):or There is also general concept of ByteSource and CharSource that gently take care of both opening and closing the stream.So, for example, instead of explicitly opening a small file to read its contents:or just