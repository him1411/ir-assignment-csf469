I have some code and when it executes, it throws a NullReferenceException, saying:Object reference not set to an instance of an object.What does this mean, and what can I do to fix this error?You are trying to use something that is null (or Nothing in VB.NET). This means you either set it to null, or you never set it to anything at all. Like anything else, null gets passed around. If it is null in method "A", it could be that method "B" passed a null to method "A".The rest of this article goes into more detail and shows mistakes that many programmers often make which can lead to a NullReferenceException.The runtime throwing a NullReferenceException always means the same thing: you are trying to use a reference, and the reference is not initialized (or it was once initialized, but is no longer initialized). This means the reference is null, and you cannot access members (such as methods) through a null reference. The simplest case:This will throw a NullReferenceException at the second line because you can\'t call the instance method ToUpper() on a string reference pointing to null.How do you find the source of a NullReferenceException? Apart from looking at the exception itself, which will be thrown exactly at the location where it occurs, the general rules of debugging in Visual Studio apply: place strategic breakpoints and inspect your variables, either by hovering the mouse over their names, opening a (Quick)Watch window or using the various debugging panels like Locals and Autos.If you want to find out where the reference is or isn\'t set, right-click its name and select "Find All References". You can then place a breakpoint at every found location and run your program with the debugger attached. Every time the debugger breaks on such a breakpoint, you need to determine whether you expect the reference to be non-null, inspect the variable and and verify that it points to an instance when you expect it to.By following the program flow this way, you can find the location where the instance should not be null, and why it isn\'t properly set.Some common scenarios where the exception can be thrown:If ref1 or ref2 or ref3 is null, then you\'ll get a NullReferenceException. If you want to solve the problem, then find out which one is null by rewriting the expression to its simpler equivalent:Specifically, in HttpContext.Current.User.Identity.Name, the HttpContext.Current could be null, or the User property could be null, or the Identity property could be null.When creating a variable of a reference (class) type, it is by default set to null.Class type variables must either be initialized or set to an already existing class instance. Initialization is done by using the new keyword.If you want to avoid the child (Person) null reference, you could initialize it in the parent (Book) object\'s constructor.The same applies to nested object initializers:While the new keyword is used, it only creates a new instance of Book, but not a new instance of Person, so the Author the property is still null.If you named fields differently from locals, you might have realized that you never initialized the field. This can be solved by following the convention to prefix fields with an underscore:If the exception occurs when referencing a property of @Model in an ASP.NET MVC view, you need to understand that the Model gets set in your action method, when you return a view. When you return an empty model (or model property) from your controller, the exception occurs when the views access it:WPF controls are created during the call to InitializeComponent in the order they appear in the visual tree.  A NullReferenceException will be raised in the case of early-created controls with event handlers, etc. , that fire during InitializeComponent which reference late-created controls.For example :Here comboBox1 is created before label1. If comboBox1_SelectionChanged attempts to reference `label1, it will not yet have been created.Changing the order of the declarations in the XAML (i.e., listing label1 before comboBox1, ignoring issues of design philosophy, would at least resolve the NullReferenceException here.This doesn\'t throw an InvalidCastException but returns a null when the cast fails (and when someObject is itself null). So be aware of that.The plain versions First() and Single() throw exceptions when there is nothing. The "OrDefault" versions return null in that case. So be aware of that.foreach throws when you try to iterate null collection. Usually caused by unexpected null result from methods that return collections.More realistic example - select nodes from XML document. Will throw if nodes are not found but initial debugging shows that all properties valid:If you expect the reference sometimes to be null, you can check for it being null before accessing instance members:Methods call you expect to return an instance can return null, for example when the object being sought cannot be found. You can choose to return a default value when this is the case:You can also throw a custom exception, only to catch it in the calling code:When you know during development that a method maybe can, but never should return null, you can use Debug.Assert() to break as soon as possible when it does occur:Though this check will not end up in your release build, causing it to throw the NullReferenceException again when book == null at runtime in release mode.The shorthand to providing a default value when a null is encountered:This is also sometimes called the safe navigation or Elvis (after its shape) operator. If the expression on the left side of the operator is null, then the right side will not be evaluated, and null is returned instead. That means cases like this:If the person does not have a title, this will throw an exception because it is trying to call ToUpper on a property with a null value.In C# 5 and below, this can be guarded with:Now the title variable will be null instead of throwing an exception. C# 6 introduces a shorter syntax for this:This will result in the title variable being null, and the call to ToUpper is not made if person.Title is null.Of course, you still have to check title for null or use the null condition operator together with the null coalescing operator (??) to supply a default value:The NullReference Exception for Visual Basic is no different from the one in C#. After all, they are both reporting the same exception defined in the .NET Framework which they both use. Causes unique to Visual Basic are rare (perhaps only one).This answer will use Visual Basic terms, syntax and context. The examples used come from a large number of past Stack Overflow questions. This is to maximize relevance by using the kinds of situations often seen in posts. A bit more explanation is also provided for those who might need it. An example similar to yours is very likely listed here.Note:The message "Object not set to instance of Object" means you are trying to use an object which has not been initialized. This boils down to one of these:Since the problem is an object reference which is Nothing, the answer is to examine them to find out which one. Then determine why it is not initialized. Hold the mouse over the various variables and Visual Studio (VS) will show their values - the culprit will be Nothing.You should also remove any Try/Catch blocks from the relevant code, especially ones where there is nothing in the Catch block. This will cause your code to crash when it tries to use an object which is Nothing. This is what you want, because it will identify the exact location of the problem, and allow you to identify the object causing it.A MsgBox in the Catch which displays Error while... will be of little help. This method also leads to very bad Stack Overflow questions, because the you can\'t describe the actual exception, the object involved or even the line of code where it happens.You can also use the Locals Window (Debug -> Windows -> Locals) to examine your objects.Once you know what and where the problem is, it is usually fairly easy to fix and faster than posting a new question.See also:The problem is that Dim does not create a CashRegister object; it only declares a variable named reg of that Type. Declaring an object variable and creating an instance are two different things.RemedyThe New operator can often be used to create the instance when you declare it:When it is only appropriate to create the instance later:Note: Do not use Dim again in a procedure, including the constructor (Sub New):This will create a local variable, reg, which exists only in that context (sub). The reg variable with module level Scope which you will use everywhere else remains Nothing.Missing the New operator is the #1 cause of NullReference Exceptions seen in the Stack Overflow questions reviewed.Visual Basic tries to make the process clear repeatedly using New: Using the New Operator creates a new object and calls Sub New -- the constructor -- where your object can perform any other initialization.To be clear, Dim (or Private) only declares a variable and its Type.   The Scope of the variable - whether it exists for the entire module/class or is local to a procedure - is determined by where it is declared. Private | Friend | Public defines the access level, not Scope.For more information, see:Arrays must also be instantiated:This array has only been declared, not created. There are several ways to initialize an array:Note: Beginning with VS 2010, when initializing a local array using a literal and Option Infer, the As <Type> and New elements are optional:The data Type and array size are inferred from the data being assigned. Class/Module level declarations still require As <Type> with Option Strict:Example: Array of class objectsThe array has been created, but the Foo objects in it have not.RemedyUsing a List(Of T) will make it quite difficult to have an element without a valid object:For more information, see:.NET collections (of which there are many varieties - Lists, Dictionary, etc.) must also instantiated or created.You get the same exception for the same reason - myList was only declared, but no instance created. The remedy is the same:A common oversight is a class which uses a collection Type:Either procedure will result in a NRE, because barList is only declared, not instantiated. Creating an instance of Foo will not also create an instance of the internal barList. It may have been the intent to do this in the constructor:As before, this is incorrect:For more information, see List(Of T) Class.Working with databases presents many opportunities for a NullReference because there can be many objects (Command, Connection, Transaction, Dataset, DataTable, DataRows....) in use at once.  Note: It does not matter which data provider you are using -- MySQL, SQL Server, OleDB, etc. -- the concepts are the same.Example 1As before, the ds Dataset object was declared, but an instance was never created. The DataAdapter will fill an existing DataSet, not create one. In this case, since ds is a local variable, the IDE warns you that that this might happen:When declared as a module/class level variable, as appears to be the case with con, the compiler can\'t know if the object was created by an upstream procedure. Do not ignore warnings.RemedyExample 2A typo is the problem here: Employees vs Employee. There was no DataTable named "Employee" created, so a NullReferenceException results trying to access it. Another potential problem is assuming there will be Items which may not be so when the SQL includes a WHERE clause.RemedySince this uses one table, using Tables(0) will avoid spelling errors.  Examining Rows.Count can also help:Fill is a function returning the number of Rows affected which can also be tested:Example 3The DataAdapter will provide TableNames as shown in the previous example, but it does not parse names from the SQL or database table. As a result, ds.Tables("TICKET_RESERVATION") references a non-existent table.The Remedy is the same, reference the table by index:See also DataTable Class.The code is only testing Items while both myFoo and Bar may also be Nothing. The remedy is to test the entire chain or path of objects one at a time:AndAlso is important. Subsequent tests will not be performed once the first False condition is encountered. This allows the code to safely \'drill\' into the object(s) one \'level\' at a time, evaluating myFoo.Bar only after (and if) myFoo is determined to be valid. Object chains or paths can get quite long when coding complex objects:It is not possible to reference anything \'downstream\' of a null object.  This also applies to controls:Here, myWebBrowser or Document could be Nothing, or the formfld1 element may not exist.Among other things, this code does not anticipate that the user may not have selected something in one or more UI controls.  ListBox1.SelectedItem may well be Nothing, so ListBox1.SelectedItem.ToString will result in an NRE.RemedyValidate data before using it (also use Option Strict and SQL parameters):Alternatively, you can use (ComboBox5.SelectedItem IsNot Nothing) AndAlso...This is a fairly common way to get an NRE. In C#, depending on how it is coded, the IDE will report that Controls does not exist in the current context, or "cannot reference non static member". So, to some extent this is a VB-only situation. It is also complex, because it can result in failure cascade.The arrays and collections cannot be initialized this way. This initialization code will run before the constructor creates the Form or the Controls. As a result:Referencing array elements later will result in a NRE. If you do this in Form_Load, due to an odd bug, the IDE may not report the exception when it happens. The exception will pop up later when your code tries to use the array. This "silent exception" is detailed in this post. For our purposes, the key is that when something catastrophic happens while creating a form (Sub New or Form Load event), exceptions may go unreported, the code exits the procedure and just displays the form.Since no other code in your Sub New or Form Load event will run after the NRE, a great many other things can be left uninitialized.Note this applies to any and all control and component references making these illegal where they are:Partial RemedyIt is curious that VB does not provide a warning, but the remedy is to declare the containers at the form level, but initialize them in form load event handler when the controls do exist. This can be done in Sub New as long as your code is after the InitializeComponent call:The array code may not be out of the woods yet. Any controls which are in a container control (like a GroupBox or Panel) will not be found in Me.Controls; they will be in the Controls collection of that Panel or GroupBox. Nor will a control be returned when the control name is misspelled ("TeStBox2"). In such cases, Nothing will again be stored in those array elements and a NRE will result when you attempt to reference it.These should be easy to find now that you know what you are looking for:\n"Button2" resides on a PanelRemedyRather than indirect references by name using the form\'s Controls collection, use the control reference:This is a case where the IDE will warn you that \'not all paths return a value and a NullReferenceException may result\'. You can suppress the warning, by replacing Exit Function with Return Nothing, but that does not solve the problem. Anything which tries to use the return when someCondition = False will result in a NRE:RemedyReplace Exit Function in the function with Return bList. Returning an empty List is not the same as returning Nothing. If there is a chance that a returned object can be Nothing, test before using it:A badly implemented Try/Catch can hide where the problem is and result in new ones:This is a case of an object not being created as expected, but also demonstrates the counter usefulness of an empty Catch.There is an extra comma in the SQL (after \'mailaddress\') which results in an exception at .ExecuteReader. After the Catch does nothing, Finally tries to perform clean up, but since you cannot Close a null DataReader object, a brand new NullReferenceException results.An empty Catch block is the devil\'s playground. This OP was baffled why he was getting an NRE in the Finally block. In other situations, an empty Catch may result in something else much further downstream going haywire and cause you to spend time looking at the wrong things in the wrong place for the problem. (The "silent exception" described above provides the same entertainment value.)RemedyDon\'t use empty Try/Catch blocks - let the code crash so you can a) identify the cause b) identify the location and c) apply a proper remedy.  Try/Catch blocks are not intended to hide exceptions from the person uniquely qualified to fix them - the developer.The IsDBNull function is used to test if a value equals System.DBNull:  From MSDN:The System.DBNull value indicates that the Object represents missing or non-existent data. DBNull is not the same as Nothing, which indicates that a variable has not yet been initialized.RemedyAs before, you can test for Nothing, then for a specific value:Example 2FirstOrDefault returns the first item or the default value, which is Nothing for reference types and never DBNull:If a CheckBox with chkName can\'t be found (or exists in a GroupBox), then chk will be Nothing and attempting to reference any property will result in an exception.RemedyThe DGV has a few quirks seen periodically:If dgvBooks has AutoGenerateColumns = True, it will create the columns, but it does not name them, so the above code fails when it references them by name.RemedyName the columns manually, or reference by index:When your DataGridView has AllowUserToAddRows as True (the default), the Cells in the blank/new row at the bottom will all contain Nothing.  Most attempts to use the contents (for example, ToString) will result in an NRE.RemedyUse a For/Each loop and test the IsNewRow property to determine if it is that last row. This works whether AllowUserToAddRows is true or not:If you do use a For n loop, modify the row count or use Exit For when IsNewRow is true.Under certain circumstances, trying to use an item from My.Settings which is a StringCollection can result in a NullReference the first time you use it. The solution is the same, but not as obvious. Consider:Since VB is managing Settings for you, it is reasonable to expect it to initialize the collection. It will, but only if you have previously added an initial entry to the collection (in the Settings editor). Since the collection is (apparently) initialized when an item is added, it remains Nothing when there are no items in the Settings editor to add.RemedyInitialize the settings collection in the form\'s Load event handler, if/when needed:Typically, the Settings collection will only need to be initialized the first time the application runs. An alternate remedy is to add an initial value to your collection in Project -> Settings | FooBars, save the project, then remove the fake value.You probably forgot the New operator.orSomething you assumed would perform flawlessly to return an initialized object to your code, did not.Don\'t ignore compiler warnings (ever) and use Option Strict On (always).MSDN NullReference ExceptionAnother scenario is when you cast a null object into a value type. For example, the code below:It will throw a NullReferenceException on the cast. It seems quite obvious in the above sample, but this can happen in more "late-binding" intricate scenarios where the null object has been returned from some code you don\'t own, and the cast is for example generated by some automatic system.One example of this is this simple ASP.NET binding fragment with the Calendar control:Here, SelectedDate is in fact a property - of DateTime type - of the Calendar Web Control type, and the binding could perfectly return something null. The implicit ASP.NET Generator will create a piece of code that will be equivalent to the cast code above. And this will raise a NullReferenceException that is quite difficult to spot, because it lies in ASP.NET generated code which compiles fine...It means that the variable in question is pointed at nothing. I could generate this like so:That will throw the error because while I\'ve declared the variable "connection", it\'s not pointed to anything. When I try to call the member "Open", there\'s no reference for it to resolve, and it will throw the error.To avoid this error:JetBrains\' Resharper tool will identify every place in your code that has the possibility of a null reference error, allowing you to put in a null check. This error is the number one source of bugs, IMHO.It means your code used an object reference variable that was set to null (i.e. it did not reference an actual object instance).To prevent the error, objects that could be null should be tested for null before being used.Be aware that regardless of the scenario, the cause is always the same in .NET:You are trying to use a reference variable whose value is Nothing/null.  When the value is Nothing/null for the reference variable, that means it is not actually holding a reference to an instance of any object that exists on the heap.  You either never assigned something to the variable, never created an instance of the value assigned to the variable, or you set the variable equal to Nothing/null manually, or you called a function that set the variable to Nothing/null for you.An example of this exception being thrown is: When you are trying to check something, that is null.For example:The .NET runtime will throw a NullReferenceException when you attempt to perform an action on something which hasn\'t been instantiated i.e. the code above.In comparison to an ArgumentNullException which is typically thrown as a defensive measure if a method expects that what is being passed to it is not null.More information is in C# NullReferenceException and Null Parameter. If you have not initialized a reference type, and you want to set or read one of its properties, it will throw a NullReferenceException.Example:You can simply avoid this by checking if the variable is not null:To fully understand why a NullReferenceException is thrown, it is important to know the difference between value types and reference types.So, if you\'re dealing with value types, NullReferenceExceptions can not occur. Though you need to keep alert when dealing with reference types!Only reference types, as the name is suggesting, can hold references or point literally to nothing (or \'null\'). Whereas value types always contain a value.Reference types (these ones must be checked):Value types (you can simply ignore these ones):Another case where NullReferenceExceptions can happen is the (incorrect) use of the as operator:Here, Book and Car are incompatible types; a Car cannot be converted/cast to a Book.  When this cast fails, as returns null.  Using mybook after this causes a NullReferenceException.In general, you should use a cast or as, as follows:If you are expecting the type conversion to always succeed (ie. you know what the object should be ahead of time), then you should use a cast:If you are unsure of the type, but you want to try to use it as a specific type, then use as:You are using the object that contains the null value reference. So it\'s giving a null exception. In the example the string value is null and when checking its length, the exception occurred.Example:The exception error is:Unhandled Exception:System.NullReferenceException: Object reference not set to an instance\n  of an object. at Program.Main()Simon Mourier gave this example:where an unboxing conversion (cast) from object (or from one of the classes System.ValueType or System.Enum, or from an interface type) to a value type (other than Nullable<>) in itself gives the NullReferenceException.In the other direction, a boxing conversion from a Nullable<> which has HasValue equal to false to a reference type, can give a null reference which can then later lead to a NullReferenceException. The classic example is:Sometimes the boxing happens in another way. For example with this non-generic extension method:the following code will be problematic:These cases arise because of the special rules the runtime uses when boxing Nullable<> instances.While what causes a NullReferenceExceptions and approaches to avoid/fix such an exception have been addressed in other answers, what many programmers haven\'t learned yet is how to independently debug such exceptions during development.In Visual Studio this is usually easy thanks to the Visual Studio Debugger.First, make sure that the correct error is going to be caught - see\nHow do I allow breaking on 'System.NullReferenceException' in VS2010? Note1Then either Start with Debugging (F5) or Attach [the VS Debugger] to Running Process. On occasion it may be useful to use Debugger.Break, which will prompt to launch the debugger.Now, when the NullReferenceException is thrown (or unhandled) the debugger will stop (remember the rule set above?) on the line on which the exception occurred. Sometimes the error will be easy to spot.For instance,\nin the following line the only code that can cause the exception is if myString evaluates to null. This can be verified by looking at the Watch Window or running expressions in the Immediate Window.In more advanced cases, such as the following, you\'ll need to use one of the techniques above (Watch or Immediate Windows) to inspect the expressions to determine if str1 was null or if str2 was null.Once where the exception is throw has been located, it\'s usually trivial to reason backwards to find out where the null value was [incorrectly] introduced --Take the time required to understand the cause of the exception. Inspect for null expressions. Inspect the previous expressions which could have resulted in such null expressions. Add breakpoints and step through the program as appropriate. Use the debugger.1  If Break on Throws is too aggressive and the debugger stops on an NPE in the .NET or 3rd-party library, Break on User-Unhandled can be used to limit the exceptions caught. Additionally, VS2012 introduces Just My Code which I recommend enabling as well.If you are debugging with Just My Code enabled, the behavior is slightly different. With Just My Code enabled, the debugger ignores first-chance common language runtime (CLR) exceptions that are thrown outside of My Code and do not pass through My CodeAdding a case when the class name for entity used in entity framework is same as class name for a web form code-behind file.Suppose you have a web form Contact.aspx whose codebehind class is Contact and you have an entity name Contact.Then following code will throw a NullReferenceException when you call context.SaveChanges()For the sake of completeness DataContext classand Contact entity class. Sometimes entity classes are partial classes so that you can extend them in other files too.The error occurs when both the entity and codebehind class are in same namespace.\nTo fix this, rename the entity class or the codebehind class for Contact.aspx.Reason\nI am still not sure about the reason. But whenever any of the entity class will extend System.Web.UI.Page this error occurs.For discussion have a look at NullReferenceException in DbContext.saveChanges()Another general case where one might receive this exception involves mocking classes during unit testing. Regardless of the mocking framework being used, you must ensure that all appropriate levels of the class hierarchy are properly mocked. In particular, all properties of HttpContext which are referenced by the code under test must be mocked.See "NullReferenceException thrown when testing custom AuthorizationAttribute" for a somewhat verbose example.I have a different perspective to answering this. This sort of answers "what else can I do to avoid it?"When working across different layers, for example in an MVC application, a controller needs services to call business operations. In such scenarios Dependency Injection Container can be used to initialize the services to avoid the NullReferenceException. So that means you don\'t need to worry about checking for null and just call the services from the controller as though they will always to available (and initialized) as either a singleton or a prototype.On the matter of "what should I do about it", there can be many answers.A more "formal" way of preventing such error conditions while developing is applying design by contract in your code. This means you need to set class invariants, and/or even function/method preconditions and postconditions on your system, while developing.In short, class invariants ensure that there will be some constraints in your class that will not get violated in normal use (and therefore, the class will not get in an inconsistent state). Preconditions mean that data given as input to a function/method must follow some constraints set and never violate them, and postconditions mean that a function/method output must follow the set constraints again without ever violating them.\nContract conditions should never be violated during execution of a bug-free program, therefore design by contract is checked in practice in debug mode, while being disabled in releases, to maximize the developed system performance.This way, you can avoid NullReferenceException cases that are results of violation of the constraints set. For example, if you use an object property X in a class and later try to invoke one of its methods and X has a null value, then this will lead to NullReferenceException:But if you set "property X must never have a null value" as method precondition, then you can prevent the scenario described before:For this cause, Code Contracts project exists for .NET applications.Alternatively, design by contract can be applied using assertions.UPDATE: It is worth mentioning that the term was coined by Bertrand Meyer in connection with his design of the Eiffel programming language.A NullReferenceException is thrown when we are trying to access Properties of a null object or when a string value becomes empty and we are trying to access string methods.For example: When a string method of an empty string accessed:When a property of a null object accessed:TL;DR: Try using Html.Partial instead of RenderpageI was getting Object reference not set to an instance of an object when I tried to render a View within a View by sending it a Model, like this:Debugging showed the model was Null inside MyOtherView. Until I changed it to:And it worked.Furthermore, the reason I didn\'t have Html.Partial to begin with was because Visual Studio sometimes throws error-looking squiggly lines under Html.Partial if it\'s inside a differently constructed foreach loop, even though it\'s not really an error:But I was able to run the application with no problems with this "error". I was able to get rid of the error by changing the structure of the foreach loop to look like this:Although I have a feeling it was because Visual Studio was misreading the ampersands and brackets.What can you do about it?There is a lot of good answers here explaining what a null reference is and how to debug it. But there is very little on how to prevent the issue or at least make it easier to catch.Check argumentsFor example methods can check the different arguments to see if they are null and throw and ArgumentNullException, an exception obviously created for this exact purpose. The constructor for the ArgumentNullException even takes the name of the parameter and a message as arguments so you can tell the developer exactly what the problem is.Use ToolsThere are also several libraries that can help. "Resharper" for example can provide you with warnings while you are writing code, especially if you use their attribute: NotNullAttributeThere\'s "Microsoft Code Contracts" where you use syntax like Contract.Requires(obj != null) which gives you runtime and compile checking: Introducing Code Contracts.There\'s also "PostSharp" which will allow you to just use attributes like this: By doing that and making PostSharp part of your build process obj will be checked for null at runtime. See: PostSharp null checkPlain Code SolutionOr you can always code your own approach using plain old code. For example here is a struct that you can use to catch null references. It\'s modeled after the same concept as Nullable<T>:You would use very similar to the same way you would use Nullable<T>, except with the goal of accomplishing exactly the opposite - to not allow null. Here are some examples:NotNull<T> is implicitly casted to and from T so you can use it just about anywhere you need it. For example you can pass a Person object to a method that takes a NotNull<Person>:As you can see above as with nullable you would access the underlying value through the Value property. Alternatively, you can use explicit or implicit cast, you can see an example with the return value below:Or you can even use it when the method just returns T (in this case Person) by doing a cast. For example the following code would just just like the code above:Combine with ExtensionCombine NotNull<T> with an extension method and you can cover even more situations. Here is an example of what the extension method can look like:And here is an example of how it could be used:GitHubFor your reference I made the code above available on GitHub, you can find it at:https://github.com/luisperezphd/NotNullRelated Language FeatureC# 6.0 introduced the "null-conditional operator" that helps with this a little. With this feature you can reference nested objects and if any one of them is null the whole expression returns null.This reduces the number of null checks you have to do in some cases. The syntax is to put a question mark before each dot. Take the following code for example:Imagine that country is an object of type Country that has a property called State and so on. If country, State, County, or City is null then address will benull. Therefor you only have to check whetheraddressisnull`.It\'s a great feature, but it gives you less information. It doesn\'t make it obvious which of the 4 is null.Built-in like Nullable?C# has a nice shorthand for Nullable<T>, you can make something nullable by putting a question mark after the type like so int?. It would be nice if C# had something like the NotNull<T> struct above and had a similar shorthand, maybe the exclamation point (!) so that you could write something like: public void WriteName(Person! person).The error line "Object reference not set to an instance of an object.\n" states that you have not assigned instance object to a object reference and still you are accessing properies/methods of that object. for example: let say you have a class called myClass and it contains one property prop1. Now you are accessing this prop1 in some other class just like below:above line throws error because reference of class myClass is declared but not instantiated or an instance of object is not assigned to referecne of that class. To fix this you have to instantiate (assign object to reference of that class).Interestingly, none of the answers on this page mention the two edge cases, hope no one minds if I add them:Generic dictionaries in .NET are not thread-safe and they sometimes might throw a NullReference or even (more frequent) a KeyNotFoundException when you try to access a key from two concurrent threads. The exception is quite misleading in this case.If a NullReferenceException is thrown by unsafe code, you might look at your pointer variables, and check them for IntPtr.Zero or something. Which is the same thing ("null pointer exception"), but in unsafe code, variables are often cast to value-types/arrays, etc., and you bang your head against the wall, wondering how a value-type can throw this exception. (Another reason for non-using unsafe code unless you need it, by the way)NullReferenceException or Object reference not set to an instance of an object occurs when an object of the class you are trying to use is not instantiated.\nFor example:Assume that you have a class named Student.Now, consider another class where you are trying to retrieve the student\'s full name.As seen in the above code, the statement \nStudent s - only declares the variable of type Student, note that the Student class is not instantiated at this point.\nHence, when the statement s.GetFullName() gets executed, it will throw the NullReferenceException.  If we consider common scenarios where this exception can be thrown, accessing properties withing object at the top.Ex: in here , if address is null , then you will get NullReferenceException.So, as a practice we should always use null check, before accessing properties in such objects (specially in generic)Well, in simple terms:You are trying to access an object that isn\'t created or currently not in memory.So how to tackle this:Debug and let the debugger break... It will directly take you to the variable that is broken... Now your task is to simply fix this.. Using the new keyword in the appropriate place.If it is caused on some database commands because the object isn\'t present then all you need to do is do a null check and handle it:The hardest one .. if the GC collected the object already... This generally occurs if you are trying to find an object using strings... That is, finding it by name of the object then it may happen that the GC might already cleaned it up... This is hard to find and will become quite a problem... A better way to tackle this is do null checks wherever necessary during the development process. This will save you a lot of time.By finding by name I mean some framework allow you to FIndObjects using strings and the code might look like this: FindObject("ObjectName");It means you are trying to manipulate something which has reference but not yet initialized \n\nThe first thing to do here is check every instance created.\n\n\nUse breakpoints , watches , inspect your varibale values.\n\nFollow stack trace and search for exact row and column which is creating problemYou are trying to access an object that isn\'t created or currently not in memory.When I get this error, I add the following code to any event handler that triggers the error.The ! means "not", FYI. So if the object in question isn\'t loaded, the program terminates the execution and prevents the crash. This is basically is a Null reference exception. As Microsoft states-A NullReferenceException exception is thrown when you try to access a\n  member on a type whose value is null.That means if any member which doesn\xe2\x80\x99t hold any value and we are making that member to perform certain task then the system will undoubtedly toss a message and say-\xe2\x80\x9cHey wait, that member has no values so it can\xe2\x80\x99t perform the task which you are handing it over.\xe2\x80\x9dThe exception itself says that something is being referred but whose value is not being set. So this denotes that it only occurs while using a reference types as Value types are non-nullable.NullReferenceException wont occur if we are using Value type members.The above code shows simple string which is assigned with a null value.Now, when I try to print the length of the string str, I do get An unhandled exception of type \xe2\x80\x98System.NullReferenceException\xe2\x80\x99 occurred message because member str is pointing to null and there can\xe2\x80\x99t be any length of null.\xe2\x80\x98NullReferenceException\xe2\x80\x99 also occurs when we forget to instantiate a reference type. Suppose I have a class and member method in it. I have not instantiated my class but only named my class. Now if I try to use the method, the compiler will throw an error or issue a warning (depending on the compiler).Compiler for the above code raises an error that variable obj is unassigned which signifies that our variable has null values or nothing. Compiler for the above code raises an error that variable obj is unassigned which signifies that our variable has null values or nothing.NullReferenceException arises due to our fault for not checking the object\xe2\x80\x99s value. We often leave the object values unchecked in the code development.It also arises when we forget to instantiate our objects. Using methods, properties, collections etc. which can return or set null values can also be the cause of this exception.There are various ways and methods to avoid this renowned exception:Explicit Checking: We should adhere to the tradition of checking the objects, properties, methods, arrays and collections whether they are null. This can be simply implemented using conditional statements like if-else if-else etc.Exception handling: One of the important ways of managing this exception. Using simple try-catch-finally blocks we can control this exception and also maintain a log of it. This can be very useful when your application is on production stage.Null operators: Null Coalescing operator and null conditional operators can also be used in handy while setting values to objects, variables, properties and fields.Debugger: For developers, we have big weapon of Debugging with us. If have we face NullReferenceException during the development face we can use the debugger to get to the source of the exception.In-built method: System methods such as GetValueOrDefault(),IsNullOrWhiteSpace() and IsNullorEmpty()  checks for nulls and assign the default value if there is a null value.There are many good answers already here. You can also check more detailed description with examples on my blog.Hope this helps too!You should check if the object you tried to create is not null before you use the object.There is a scenario that can happen that is Class related. The question ended up getting closed prior to my stating the resolution:\nhttps://stackoverflow.com/questions/43348009/unable-to-instantiate-classBeware of classes not instantiating: If any part of your constructor in a class throws a null reference exception the class does not instantiate. In my case it was trying to get a connection string from the web.config that that did not exist. I instantiated a class:Inside the class itself was a call to get a connection string from the web.config. This part of the constructor threw an null value exception so myClass was null.If you ever have a situation where a class in not instantiating, try making sure that no part of the class constructor Is throwing a null value exception. F-11 and step through the class and make sure there are no nulls.