I know that PHP doesn\'t have native Enumerations. But I have become accustomed to them from the Java world. I would love to use enums as a way to give predefined values which IDEs\' auto completion features could understand.Constants do the trick, but there\'s the namespace collision problem and (or actually because) they\'re global. Arrays don\'t have the namespace problem, but they\'re too vague, they can be overwritten at runtime and IDEs rarely (never?) know how to autofill their keys.Are there any solutions/workarounds you commonly use? Does anyone recall whether the PHP guys have had any thoughts or decisions around enums?Depending upon use case, I would normally use something simple like the following:However, other use cases may require more validation of constants and values. Based on the comments below about reflection, and a few other notes, here\'s an expanded example which may better serve a much wider range of cases:By creating a simple enum class that extends BasicEnum, you now have the ability to use methods thusly for simple input validation:As a side note, any time I use reflection at least once on a static/const class where the data won\'t change (such as in an enum), I cache the results of those reflection calls, since using fresh reflection objects each time will eventually have a noticeable performance impact (Stored in an assocciative array for multiple enums).Now that most people have finally upgraded to at least 5.3, and SplEnum is available, that is certainly a viable option as well--as long as you don\'t mind the traditionally unintuitive notion of having actual enum instantiations throughout your codebase. In the above example, BasicEnum and DaysOfWeek cannot be instantiated at all, nor should they be.There is a native extension, too. The SplEnumSplEnum gives the ability to emulate and create enumeration objects\n  natively in PHP.http://www.php.net/manual/en/class.splenum.phpWhat about class constants?The top answer above is fantastic. However, if you extend it in two different ways, then whichever extension is done first results in a call to the functions will create the cache. This cache will then be used by all subsequent calls, no matter whichever extension the calls are initiated by ...To solve this, replace the variable and first function with:I use interface instead of class:I used classes with constants:Well, for a simple java like enum in php, I use:And to call it:But I\'m a PHP beginner, struggling with the syntax so this might not be the best way. I experimented some with Class Constants, using Reflection to get the constant name from it\'s value, might be neater.I\'ve commented on some of the other answers here, so I figured I would weigh in too.\nAt the end of the day, since PHP doesn\'t support typed enumerations, you can go one of two ways: hack out typed enumerations, or live with the fact that they\'re extremely difficult to hack out effectively.I prefer to live with the fact, and instead use the const method that other answers here have used in some way or another:An example enumeration:Using Enum as a base class from which all other enumerations extend allows for helper methods, such as toArray, isValid, and so on. To me, typed enumerations (and managing their instances) just end up too messy.If, there existed a __getStatic magic method (and preferably an __equals magic method too) much of this could be mitigated with a sort of multiton pattern.(The following is hypothetical; it won\'t work, though perhaps one day it will)Four years later I came across this again. My current approach is this as it allows for code completion in the IDE as well as type safety:Base class:Example Enum:Example usage:Note that all instances of the same enum entry are the same:You can also use it inside of a switch statement:You can also create an enum entry by name or value:Or you can just get the name (i.e. the function name) from an existing enum entry:If you need to use enums that are globally unique (i.e. even when comparing elements between different Enums) and are easy to use, feel free to use the following code. I also added some methods that I find useful. You will find examples in the comments at the very top of the code.I like enums from java too and for this reason I write my enums in this way, I think this is the most similiar behawior like in Java enums, of course, if some want to use more methods from java should write it here, or in abstract class but core idea is embedded in code belowHere is a github library for handling type-safe enumerations in php:This library handle classes generation, classes caching and it implements the Type Safe Enumeration design pattern, with several helper methods for dealing with enums, like retrieving an ordinal for enums sorting, or retrieving a binary value, for enums combinations.The generated code use a plain old php template file, which is also configurable, so you can provide your own template.It is full test covered with phpunit.php-enums on github (feel free to fork)I have taken to using the approach below as it gives me the ability to have type safety for function parameters, auto complete in NetBeans and good performance.  The one thing I don\'t like too much is that you have to call [extended class name]::enumerate(); after defining the class.I found this library on github and I think it provides a very decent alternative to the answers here.It might be as simple asin the future.PHP RFC: Enumerated TypesThe most common solution that I have seen to enum\'s in PHP has been to create a generic enum class and then extend it. You might take a look at this.UPDATE: Alternatively, I found this from phpclasses.org.I know this is an old thread, however none of the workarounds I\'ve seen really looked like enums, since almost all workarounds requires you to manually assign values to the enum items, or it requires you to pass an array of enum keys to a function. So I created my own solution for this. To create an enum class using my solution one can simply extend this Enum class below, create a bunch of static variables (no need to initialize them), and make a call to yourEnumClass::init() just below the definition of your enum class. edit: This only works in php >= 5.3, but it can probably be modified to work in older versions as well\n    \n\nThe accepted answer is the way to go and is actually what I am doing for simplicity. Most advantages of enumeration are offered (readable, fast, etc.). One concept is missing, however: type safety. In most languages, enumerations are also used to restrict allowed values. Below is an example of how type safety can also be obtained by using private constructors, static instantiation methods and type checking:We could even go further: using constants in the DaysOfWeek class might lead to misusage: e.g. one might mistakenly use it this way:which is wrong (calls integer constant). We can prevent this using private static variables instead of constants:Of course, it is not possible to access integer constants (this was actually the purpose). The intVal method allows to convert a DaysOfWeek object to its integer representation.Note that we could even go further by implementing a caching mechanism in instantiation methods to save memory in the case enumerations are extensively used...Hope this will helpSome good solutions on here!Here\'s my version.I think the main disadvantage is that enum members do have to be separately declared and instantiated, due to the descriptions and PHP\'s inability to construct objects at static member declaration time.  I guess a way round this might be to use reflection with parsed doc comments instead.The abstract enum looks like this:Here\'s an example concrete enum:Which can be used like this:And produces this output:1 : My first value  array(3) {\n       [1]=>\n       object(EMyEnum)#1 (2) {\n         ["code":"AbstractEnum":private]=>\n         int(1)\n         ["description":"AbstractEnum":private]=>\n         string(14) "My first value"\n       }\n       [2]=>\n       object(EMyEnum)#2 (2) {\n         ["code":"AbstractEnum":private]=>\n         int(2)\n         ["description":"AbstractEnum":private]=>\n         string(15) "My second value"\n       }\n       [3]=>\n       object(EMyEnum)#3 (2) {\n         ["code":"AbstractEnum":private]=>\n         int(3)\n         ["description":"AbstractEnum":private]=>\n         string(14) "My third value"\n       }\n     }My second valueDon\'t use reflection. It makes it extremely difficult to reason about your code and track down where something is being used, and tends to break static analysis tools (eg what\'s built into your IDE).This is my take on "dynamic" enum... so that i can call it with variables, ex. from a form.look at updated verison below this codeblock...UPDATE: Better way of doing it...Call withYesterday I wrote this class on my blog. I think it\'s maybe be easy for use in php scripts:Usage:Pointed out solution works well. Clean and smooth.However, if you want strongly typed enumerations, you can use this:With an Enum class looking like:This way, enum values are strongly typed and TestEnum::$TEST1 === TestEnum::parse(\'TEST1\') // true statementOne of the aspects missing from some of the other answers here is a way to use enums with type hinting.If you define your enum as a set of constants in an abstract class, e.g.then you can\'t type hint it in a function parameter - for one, because it\'s not instantiable, but also because the type of ShirtSize::SMALL is int, not ShirtSize.That\'s why native enums in PHP would be so much better than anything we can come up with. However, we can approximate an enum by keeping a private property which represents the value of the enum, and then restricting the initialization of this property to our predefined constants. To prevent the enum from being instantiated arbitrarily (without the overhead of type-checking a whitelist), we make the constructor private.Then we can use ShirtSize like this:This way, the biggest difference from the user\'s perspective is that you have to tack on a () on the constant\'s name.One downside though is that === (which compares object equality) will return false when == returns true. For that reason, it\'s best to provide an equals method, so that users don\'t have to remember to use == and not === to compare two enum values.EDIT: A couple of the existing answers are very similar, particularly: https://stackoverflow.com/a/25526473/2407870.I realize this is a very-very-very old thread but I had a thought about this and wanted to know what people thought.Notes: I was playing around with this and realized that if I just modified the __call() function that you can get even closer to actual enums.  The __call() function handles all unknown function calls.  So let\'s say you wan to make three enums RED_LIGHT, YELLOW_LIGHT, and GREEN_LIGHT.  You can do so now by just doing the following:Once defined all you have to do is to call them again to get the values:and you should get 0, 1, and 2.  Have fun!  This is also now up on GitHub.Update:  I\'ve made it so both the __get() and __set() functions are now used.  These allow you to not have to call a function unless you want to.  Instead, now you can just say:For both the creation and getting of the values.  Because the variables haven\'t been defined initially, the __get() function is called (because there isn\'t a value specified) which sees that the entry in the array hasn\'t been made.  So it makes the entry, assigns it the last value given plus one(+1), increments the last value variable, and returns TRUE.  If you set the value:Then the __set() function is called and the last value is then set to the new value plus one (+1).  So now we have a fairly good way to do enums and they can be created on the fly.Stepping on the answer of @Brian Cline I thought I might give my 5 centsI made a library based on Brian Cline\'s answer, it is named greg0ire/enum\nEnjoy!My attempt to create an enum with PHP...it\'s extremely limited since it doesn\'t support objects as the enum values but still somewhat useful...