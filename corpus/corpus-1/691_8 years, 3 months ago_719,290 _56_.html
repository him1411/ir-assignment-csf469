There is no built in reverse function in Python\'s str object. What is the best way of implementing this?If supplying a very concise answer, please elaborate on it\'s efficiency. Is the str converted to a different object, etc. How about:This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.@Paolo\'s s[::-1] is fastest; a slower approach (maybe more readable, but that\'s debatable) is \'\'.join(reversed(s)).My own experience with this question is academic. However, if you\'re a pro looking for the quick answer, use a slice that steps by -1:or more readably (but slower due to the method name lookups and the fact that join forms a list when given an iterator), str.join:or for readability and reusability, put the slice in a functionand then:If you\'re interested in the academic exposition, please keep reading.There is no built-in reverse function in Python\'s str object. Here is a couple of things about Python\'s strings you should know:In Python, strings are immutable. Changing a string does not modify the string. It creates a new one.Strings are sliceable. Slicing a string gives you a new string from one point in the string, backwards or forwards, to another point, by given increments. They take slice notation or a slice object in a subscript:The subscript creates a slice by including a colon within the braces:To create a slice outside of the braces, you\'ll need to create a slice object:While \'\'.join(reversed(\'foo\')) is readable, it requires calling a string method, str.join, on another called function, which can be rather slow. Let\'s put this in a function - we\'ll come back to it:Much faster is using a reverse slice:But how can we make this more readable and understandable to someone less familiar with the intent of the original author? Let\'s create a named slice object, and pass it to the subscript notation.To actually implement this as a function, I think it is semantically clear enough to simply use a descriptive name:And usage is simply:If you have an instructor, they probably want you to start with an empty string, and build up a new string from the old one. You can do this with pure syntax and literals using a while loop:This is theoretically bad because, remember, strings are immutable - so every time where it looks like you\'re appending a character onto your new_string, it\'s theoretically creating a new string every time! However, CPython knows how to optimize this in certain cases, of which this trivial case is one.Theoretically better is to collect your substrings in a list, and join them later:However, as we will see in the timings below for CPython, this actually takes longer, because CPython can optimize the string concatenation.Here are the timings:CPython optimizes string concatenation, whereas other implementations may not:... do not rely on CPython\'s efficient implementation of in-place string concatenation for statements in the form  a += b  or  a = a + b  . This optimization is fragile even in CPython (it only works for some types) and isn\'t present at all in implementations that don\'t use refcounting. In performance sensitive parts of the library, the  \'\'.join()   form should be used instead. This will ensure that concatenation occurs in linear time across various implementations. This answer is provided to address the following concern from @odigity:Wow. I was horrified at first by the solution Paolo proposed, but that \n  took a back seat to the horror I felt upon reading the first\n  comment: "That\'s very pythonic. Good job!" I\'m so disturbed that such\n  a bright community thinks using such cryptic methods for something so\n  basic is a good idea. Why isn\'t it just s.reverse()?Python has a special circumstance to be aware of: a string is an iterable type.One rationale for excluding a string.reverse() method is to give python developers incentive to leverage the power of this special circumstance.In simplified terms, this simply means each individual character in a string can be easily operated on as a part of a sequential array of elements, just like arrays in other programming languages.To understand how this works, reviewing example02 can provide a good overview.The cognitive load associated with understanding how slice notation works in python may indeed be too much for some adopters and developers who do not wish to invest much time in learning the language.Nevertheless, once the basic principles are understood, the power of this approach over fixed string manipulation methods can be quite favorable.For those who think otherwise, there are alternate approaches, such as lambda functions, iterators, or simple one-off function declarations.If desired, a developer can implement her own string.reverse() method, however it is good to understand the rationale behind this aspect of python.A lesser perplexing way to look at it would be:\'happy\'\'yppah\'In English [-1::-1] reads as:"Starting at -1,  go all the way,  taking steps of -1"Reverse a string in python without using reversed() or [::-1]Here is a no fancy one:Here is one without [::-1] or reversed (for learning purposes):you can use += to concatenate strings but join() is faster. Another alternative, (not efficient! just to show the diversity of Python with so many possible solutions!): convert the string to a list using the list() function. A list value is a mutable data type. Therefore we can use the method reverse() which reverses the objects of a list in place. And then we convert the list back to a string using the list join method with an empty separator: Here is simply:print "loremipsum"[-1::-1]and some logically:output:muspimerolOUTPUT : Sure, in Python you can do very fancy 1-line stuff. :) \nHere\'s a simple, all rounder solution that could work in any programming language.You can use the reversed function with a list comprehesive. But I don\'t understand why this method was eliminated in python 3, was unnecessarily. 