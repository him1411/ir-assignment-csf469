I am trying to understand threading in Python. I\'ve looked at the documentation and examples, but quite frankly, many examples are overly sophisticated and I\'m having trouble understanding them.How do you clearly show tasks being divided for multi-threading?Since this question was asked in 2010, there has been real simplification in how to do simple multithreading with python with map and pool.The code below comes from an article/blog post that you should definitely check out (no affiliation) - Parallelism in one line:\nA Better Model for Day to Day Threading Tasks.  I\'ll summarize below - it ends up being just a few lines of code:Which is the multithreaded version of:DescriptionMap is a cool little function, and the key to easily injecting parallelism into your Python code. For those unfamiliar, map is something lifted from functional languages like Lisp. It is a function which maps another function over a sequence.Map handles the iteration over the sequence for us, applies the function, and stores all of the results in a handy list at the end.ImplementationParallel versions of the map function are provided by two libraries:multiprocessing, and also its little known, but equally fantastic step child:multiprocessing.dummy.And the timing results:Passing multiple arguments (works like this only in Python 3.3 and later): (source):To pass multiple arrays:or to pass a constant and an array:If you are using an earlier version of Python, you can pass multiple arguments via this workaround.(Thanks to user136036 for the helpful comment)Here\'s a simple example: you need to try a few alternative URLs and return the contents of the first one to respond.This is a case where threading is used as a simple optimization: each subthread is waiting for a URL to resolve and respond, in order to put its contents on the queue; each thread is a daemon (won\'t keep the process up if main thread ends -- that\'s more common than not); the main thread starts all subthreads, does a get on the queue to wait until one of them has done a put, then emits the results and terminates (which takes down any subthreads that might still be running, since they\'re daemon threads).Proper use of threads in Python is invariably connected to I/O operations (since CPython doesn\'t use multiple cores to run CPU-bound tasks anyway, the only reason for threading is not blocking the process while there\'s a wait for some I/O).  Queues are almost invariably the best way to farm out work to threads and/or collect the work\'s results, by the way, and they\'re intrinsically threadsafe so they save you from worrying about locks, conditions, events, semaphores, and other inter-thread coordination/communication concepts.NOTE: For actual parallelization in Python, you should use the multiprocessing module to fork multiple processes that execute in parallel (due to the global interpreter lock, Python threads provide interleaving but are in fact executed serially, not in parallel, and are only useful when interleaving I/O operations).However, if you are merely looking for interleaving (or are doing I/O operations that can be parallelized despite the global interpreter lock), then the threading module is the place to start. As a really simple example, let\'s consider the problem of summing a large range by summing subranges in parallel:Note that the above is a very stupid example, as it does absolutely no I/O and will be executed serially albeit interleaved (with the added overhead of context switching) in CPython due to the global interpreter lock.Just a note, Queue is not required for threading.This is the simplest example I could imagine that shows 10 processes running concurrently.Like others mentioned, CPython can use threads only for I\\O waits due to GIL.\nIf you want to benefit from multiple cores for CPU-bound tasks, use multiprocessing:The answer from Alex Martelli helped me, however here is modified version that I thought was more useful (at least to me).I found this very useful: create as many threads as cores and let them execute a (large) number of tasks (in this case, calling a shell program):For me, the perfect example for Threading is monitoring Asynchronous events.  Look at this code.You can play with this code by opening an IPython session and doing something like:Wait a few minutesAlong with all the great answers and examples here at stack that have helped me personally understand the above mentioned multiprocessing and threading, the following site (here i\'ve provided topic specific links, due to the simple examples contained therein;  as the op requested.), really clicked for me, with its documentation, and my understanding of any questions i\'ve had about python thus far, heres to hopes it can help someone here as much as I.Python Threading Python MultiprocessingWhile i recognize theres a multitude of answers, i find it would be worth the reference if i can help another get a better understanding of something in their interest\n.Using the blazing new concurrent.futures moduleThe executor approach might seem familiar to all those who have gotten their hands dirty with Java before.Also on a side note: To keep the universe sane, don\'t forget to close your pools/executors if you don\'t use with context (which is so awesome that it does it for you)Given a function, f, thread it like this:To pass arguments to fMulti threading with simple example which will be helpful. You can run it and understand easily how is multi thread working in python. I used lock for prevent to access other thread until previous threads finished their work. By the use of tLock = threading.BoundedSemaphore(value=4)this line of code you can allow numbers of process at a time and keep hold to rest of thread which will run later or after finished previous processes.Python 3 has the facility of Launching parallel tasks. This makes our work easier. It has for thread pooling and Process pooling. The following gives an insight:ThreadPoolExecutor ExampleProcessPoolExecutorMost documentations and tutorials use Python\'s Threading and Queue module they could seem overwhelming for beginners.Perhaps consider the concurrent.futures.ThreadPoolExecutor module of python 3.\nCombined with with clause and list comprehension it could be a real charm.Here, args is a tuple of arguments; use an empty tuple to call function without passing any arguments. kwargs is an optional dictionary of keyword arguments.ExampleWhen the above code is executed, it produces the following result \xe2\x88\x92None of the above solutions actually used multiple cores on my GNU/Linux server (where I don\'t have admin rights). They just ran on a single core. I used the lower level os.fork interface to spawn multiple threads. This is the code that worked for me: