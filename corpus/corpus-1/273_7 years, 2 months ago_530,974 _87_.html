For a web page that exists, but for which a user that does not have sufficient privileges, (they are not logged in or do not belong to the proper user group), what is the proper HTTP response to serve? 401? 403? Something else? What I\'ve read on each so far isn\'t very clear on the difference between the two. What use cases are appropriate for each response?A clear explanation from Daniel Irvine:There\'s a problem with 401 Unauthorized, the HTTP status code for authentication errors. And that\xe2\x80\x99s just it: it\xe2\x80\x99s for authentication, not authorization.\n  Receiving a 401 response is the server telling you, \xe2\x80\x9cyou aren\xe2\x80\x99t\n  authenticated\xe2\x80\x93either not authenticated at all or authenticated\n  incorrectly\xe2\x80\x93but please reauthenticate and try again.\xe2\x80\x9d To help you out,\n  it will always include a WWW-Authenticate header that describes how\n  to authenticate.This is a response generally returned by your web server, not your web\n  application.It\xe2\x80\x99s also something very temporary; the server is asking you to try\n  again.So, for authorization I use the 403 Forbidden response. It\xe2\x80\x99s\n  permanent, it\xe2\x80\x99s tied to my application logic, and it\xe2\x80\x99s a more concrete\n  response than a 401.Receiving a 403 response is the server telling you, \xe2\x80\x9cI\xe2\x80\x99m sorry. I know\n  who you are\xe2\x80\x93I believe who you say you are\xe2\x80\x93but you just don\xe2\x80\x99t have\n  permission to access this resource. Maybe if you ask the system\n  administrator nicely, you\xe2\x80\x99ll get permission. But please don\xe2\x80\x99t bother\n  me again until your predicament changes.\xe2\x80\x9dIn summary, a 401 Unauthorized response should be used for missing\n  or bad authentication, and a 403 Forbidden response should be used\n  afterwards, when the user is authenticated but isn\xe2\x80\x99t authorized to\n  perform the requested operation on the given resource.Another nice pictorial format of how http status codes should be used.See RFC2616:401 Unauthorized:If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials.403 Forbidden:The server understood the request, but is refusing to fulfill it.UpdateFrom your use case, it appears that the user is not authenticated. I would return 401.Edit: RFC2616 is obsolete, see RFC7231 and RFC7235.Something the other answers are missing is that it must be understood that Authentication and Authorization in the context of RFC 2616 refers ONLY to the HTTP Authentication protocol of RFC 2617. Authentication by schemes outside of RFC2617 are not supported in HTTP status codes and are not considered when deciding whether to use 401 or 403..Unauthorized indicates that the client is not RFC2617 authenticated and the server is initiating the authentication process. Forbidden indicates either that the client is RFC2617 authenticated and does not have authorization or that the server does not support RFC2617 for the requested resource.Meaning if you have your own roll-your-own login process and never use HTTP Authentication, 403 is always the proper response and 401 should never be used.From RFC261610.4.2 401 UnauthorizedThe request requires user authentication. The response MUST include a WWW-Authenticate header field (section 14.47) containing a challenge applicable to the requested resource. The client MAY repeat the request with a suitable Authorization header field (section 14.8). and 10.4.4 403 Forbidden\n  The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated.The first thing to keep in mind is that "Authentication" and "Authorization" in the context of this document refer specifically to the HTTP Authentication protocols from RFC 2617. They do not refer to any roll-your-own authentication protocols you may have created using login pages, etc. I will use "login" to refer to authentication and authorization by methods other than RFC2617So the real difference is not what the problem is or even if there is a solution. The difference is what the server expects the client to do next.401 indicates that the resource can not be provided, but the server is REQUESTING that the client log in through HTTP Authentication and has sent reply headers to initiate the process. Possibly there are authorizations that will permit access to the resource, possibly there are not, but lets give it a try and see what happens.403 indicates that the resource can not be provided and there is, for the current user, no way to solve this through RFC2617 and no point in trying. This may be because it is known that no level of authentication is sufficient (for instance because of an IP blacklist), but it may be because the user is already authenticated and does not have authority. The RFC2617 model is one-user, one-credentials so the case where the user may have a second set of credentials that could be authorized may be ignored. It neither suggests nor implies that some sort of login page or other non-RFC2617 authentication protocol may or may not help - that is outside the RFC2616 standards and definition.Edit: RFC2616 is obsolete, see RFC7231 and RFC7235.According to RFC 2616 (HTTP/1.1) 403 is sent when:The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated. If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity. If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used insteadIn other words, if the client CAN get access to the resource by authenticating, 401 should be sent.If authenticating as another user would grant access to the requested resource, then 401 Unauthorized should be returned. 403 Forbidden is mostly used when access to the resource is forbidden to everyone or restricted to a given network or allowed only over SSL, whatever as long as it is no related to authentication. From RFC 7235 (Hypertext Transfer Protocol (HTTP/1.1): Authentication):3.1. 401 UnauthorizedThe 401 (Unauthorized) status code indicates that the request has\n  not    been applied because it lacks valid authentication credentials\n  for    the target resource.  The origin server MUST send a\n  WWW-Authenticate    header field (Section 4.4) containing at least one\n  challenge    applicable to the target resource.  If the request\n  included    authentication credentials, then the 401 response\n  indicates that    authorization has been refused for those\n  credentials.  The client MAY    repeat the request with a new or\n  replaced Authorization header field    (Section 4.1).  If the 401\n  response contains the same challenge as    the prior response, and the\n  user agent has already attempted    authentication at least once, then\n  the user agent SHOULD present the    enclosed representation to the\n  user, since it usually contains    relevant diagnostic information.And this is from RFC 2616:10.4.4 403 ForbiddenThe server understood the request, but is refusing to fulfill it.\n  Authorization will not help and the request SHOULD NOT be repeated.\n  If the request method was not HEAD and the server wishes to make\n  public why the request has not been fulfilled, it SHOULD describe the \n  reason for the refusal in the entity.  If the server does not wish to \n  make this information available to the client, the status code 404\n  (Not Found) can be used instead.Edit: RFC 7231 (Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content) changes the meaning of 403:6.5.3. 403 ForbiddenThe 403 (Forbidden) status code indicates that the server\n  understood    the request but refuses to authorize it.  A server that\n  wishes to    make public why the request has been forbidden can\n  describe that    reason in the response payload (if any).If authentication credentials were provided in the request, the\n  server considers them insufficient to grant access.  The client\n  SHOULD NOT automatically repeat the request with the same\n  credentials.  The client MAY repeat the request with new or different \n  credentials.  However, a request might be forbidden for reasons\n  unrelated to the credentials.An origin server that wishes to "hide" the current existence of a\n  forbidden target resource MAY instead respond with a status code of\n  404 (Not Found).Thus, a 403 might now mean about anything. Providing new credentials might help... or it might not.TL;DR versionChecks are usually done in this order:UNAUTHORIZED: Status code (401) indicating that the request requires authentication. User/agent unknown by the server. Can repeat with other credentials. NOTE: This is confusing as this should have been named \'unauthenticated\'.FORBIDDEN: Status code (403) indicating the server understood the request but refused to fulfill it. User/agent known by the server but has insufficient credentials. Repeating request will not work.NOT FOUND: Status code (404) indicating that the requested resource is not available. User/agent known but server will not reveal anything about the resource, does as if it does not exist. Repeating will not work. This is a special use of 404 (github does it for example).This is an older question, but one option that was never really brought up was to return a 404. From a security perspective, the highest voted answer suffers from a potential information leakage vulnerability. Say, for instance, that the secure web page in question is a system admin page, or perhaps more commonly, is a record in a system that the user doesn\'t have access to. Ideally you wouldn\'t want a malicious user to even know that there\'s a page / record there, let alone that they don\'t have access. When I\'m building something like this, I\'ll try to record unauthenticate / unauthorized requests in an internal log, but return a 404.OWASP has some more information about how an attacker could use this type of information as part of an attack. This question was asked some time ago, but people\'s thinking moves on.Section 6.5.3 in this draft (authored by Fielding and Reschke) gives status code 403 a slightly different meaning to the one documented in RFC 2616.It reflects what happens in authentication & authorization schemes employed by a number of popular web-servers and frameworks.I\'ve emphasized the bit I think is most salient.6.5.3.  403 ForbiddenThe 403 (Forbidden) status code indicates that the server understood    the request but refuses to authorize it.  A server that wishes to    make public why the request has been forbidden can describe that    reason in the response payload (if any).If authentication credentials were provided in the request, the server considers them insufficient to grant access.  The client SHOULD NOT repeat the request with the same credentials.  The client MAY repeat the request with new or different credentials.  However, a request might be forbidden for reasons unrelated to the credentials. An origin server that wishes to "hide" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).Whatever convention you use, the important thing is to provide uniformity across your site / API.they are not logged in or do not belong to the proper user groupYou have stated two different cases; each case should have a different response:If apache requires authentication (via .htaccess), and you hit Cancel, it will respond with a 401 Authorization RequiredIf nginx finds a file, but has no access rights (user/group) to read/access it, it will respond with 403 ForbiddenMeaning 1: Need to authenticateThe request requires user authentication. ...Meaning 2: Authentication insufficient... If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials. ...Meaning: Unrelated to authentication... Authorization will not help ...More details:The server understood the request, but is refusing to fulfill it.It SHOULD describe the reason for the refusal in the entityThe status code 404 (Not Found) can be used instead (If the server wants to keep this information from client)This is simpler in my head than anywhere here, so:401: You need HTTP basic auth to see this.403: You can\'t see this, and HTTP basic auth won\'t help.If the user just needs to log in using you site\'s standard HTML login form, 401 would not be appropriate because it is specific to HTTP basic auth.I don\'t recommend using 403 to deny access to things like /includes, because as far as the web is concerned, those resources don\'t exist at all and should therefore 404.This leaves 403 as "you need to be logged in".In the case of 401 vs 403, this has been answered many times. This is essentially a \'HTTP request environment\' debate, not an \'application\' debate.There seems to be a question on the roll-your-own-login issue (application).In this case, simply not being logged in is not sufficient to send a 401 or a 403, unless you use HTTP Auth vs a login page (not tied to setting HTTP Auth). It sounds like you may be looking for a "201 Created", with a roll-your-own-login screen present (instead of the requested resource) for the application-level access to a file. This says: "I heard you, it\'s here, but try this instead (you are not allowed to see it)"