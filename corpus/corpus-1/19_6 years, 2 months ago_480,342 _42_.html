If I run the following program, which parses two date strings referencing times 1 second apart and compares them:The output is:Why is ld4-ld3 not 1 (as I would expect from the one-second difference in the times), but 353?If I change the dates to times 1 second later:Then ld4-ld3 will be 1.Java version:It\'s a time zone change on December 31st in Shanghai.See this page for details of 1927 in Shanghai. Basically at midnight at the end of 1927, the clocks went back 5 minutes and 52 seconds. So "1927-12-31 23:54:08" actually happened twice, and it looks like Java is parsing it as the later possible instant for that local date/time - hence the difference.Just another episode in the often weird and wonderful world of time zones.EDIT: Stop press! History changes...The original question would no longer demonstrate quite the same behaviour, if rebuilt with version 2013a of TZDB. In 2013a, the result would be 358 seconds, with a transition time of 23:54:03 instead of 23:54:08.I only noticed this because I\'m collecting questions like this in Noda Time, in the form of unit tests... The test has now been changed, but it just goes to show - not even historical data is safe.EDIT: History has changed again...In TZDB 2014f, the time of the change has moved to 1900-12-31, and it\'s now a mere 343 second change (so the time between t and t+1 is 344 seconds, if you see what I mean).EDIT: To answer a question around a transition at 1900... it looks like the Java timezone implementation treats all time zones as simply being in their standard time for any instant before the start of 1900 UTC:The code above produces no output on my Windows machine. So any time zone which has any offset other than its standard one at the start of 1900 will count that as a transition. TZDB itself has some data going back earlier than that, and doesn\'t rely on any idea of a "fixed" standard time (which is what getRawOffset assumes to be a valid concept) so other libraries needn\'t introduce this artificial transition.You\'ve encountered a local time discontinuity:When local standard time was about to reach Sunday, 1. January 1928,\n  00:00:00 clocks were turned backward 0:05:52 hours to Saturday, 31.\n  December 1927, 23:54:08 local standard time insteadThis is not particularly strange and has happened pretty much everywhere at one time or another as timezones were switched or changed due to political or administrative actions.The moral of this strangeness is:When incrementing time you should convert back to UTC and then add or subtract. Use the local time only for display.This way you will be able to walk through any periods where hours or minutes happen twice.If you converted to UTC, add each second, and convert to local time for display. You would go through 11:54:08 p.m. LMT - 11:59:59 p.m. LMT and then 11:54:08 p.m. CST - 11:59:59 p.m. CST.Instead of converting each date, you use the following code And see the result is:I\'m sorry to say that, but the time discontinuity has moved a bit inJDK 6 two years ago, and in JDK 7 just recently in update 25.Lesson to learn: avoid non-UTC times at all costs, except, maybe, for display.As explained by others, there\'s a time discontinuity there. There are two possible timezone offsets for 1927-12-31 23:54:08 at Asia/Shanghai, but only one offset for 1927-12-31 23:54:07. So, depending on which offset is used, there\'s either a one second difference or a 5 minutes and 53 seconds difference.This slight shift of offsets, instead of the usual one-hour daylight savings (summer time) we are used to, obscures the problem a bit.Note that the 2013a update of the timezone database moved this discontinuity a few seconds earlier, but the effect would still be observable.The new java.time package on Java 8 let use see this more clearly, and provide tools to handle it. Given:Then durationAtEarlierOffset will be one second, while durationAtLaterOffset will be five minutes and 53 seconds.Also, these two offsets are the same:But these two are different:You can see the same problem comparing 1927-12-31 23:59:59 with 1928-01-01 00:00:00, though, in this case, it is the earlier offset that produce the longer divergence, and it is the earlier date that has two possible offsets.Another way to approach this is to check whether there\'s a transition going on. We can do this like this:You can check whether the transition is an overlap - in which case there\'s more than one valid offset for that date/time - or a gap - in which case that date/time is not valid for that zone id - by using the isOverlap() and isGap() methods on zot4.I hope this helps people handle this sort of issue once Java 8 becomes widely available, or to those using Java 7 who adopt the JSR 310 backport.IMHO the pervasive, implicit localization in Java is its single largest design flaw. It may be intended for user interfaces, but frankly, who really uses Java for user interfaces today except for some IDEs where you can basically ignore localization because programmers aren\'t exactly the target audience for it. You can fix it (especially on linux servers) by:To the Java Community Process members I recommend:I mean, come on, aren\'t global static variables an anti-OO pattern? Nothing else are those pervasive defaults given by some rudimentary environment variables.......