In SQL Server, it\'s possible to insert into a table using a SELECT statement:Is it also possible to update via a SELECT? I have a temporary table containing the values, and would like to update another table using those values. Perhaps something like this:In SQL Server 2008 (or better), use MERGEAlternatively:I\'d modify Robin\'s excellent answer to the following:Without a WHERE clause, you\'ll affect even rows that don\'t need to be affected, which could (possibly) cause index recalculation or fire triggers that really shouldn\'t have been fired.One wayAnother possibility not mentioned yet is to just chuck the SELECT statement itself into a CTE then Update the CTE. This has the benefit that it is easy to run the SELECT statement on its own first to sanity check the results but it does requires you to alias the columns as above if they are named the same in source and target tables.This also has the same limitation as the proprietary UPDATE ... FROM syntax shown in four of the other answers. If the source table is on the many side of a one to many join then it is undeterministic which of the possible matching joined records will be used in the Update (An issue that MERGE avoids by raising an error if there is an attempt to update the same row more than once).For the record (and others searching like I was), you can do it in MySQL like this:Using alias:The simple way to do it is:This may be a niche reason to perform an update (for example, mainly used in a procedure), or may be obvious to others, but it should also be stated that you can perform an update-select statement without using join (in case the tables you\'re updating between have no common field).Here is another useful syntax:It checks if it is null or not by using "WHERE EXIST".I add this only so you can see a quick way to write it so that you can check what will be updated before doing the update.If you use MySQL instead of SQL Server, the syntax is:UPDATE from SELECT with INNER JOIN in SQL DatabaseSince there are too many replies of this post, which are most heavily up-voted, I thought I would provide my suggestion here too. Although the question is very interesting, I have seen in many forum sites and made a solution using INNER JOIN with screenshots.At first, I have created a table named with schoolold and inserted few records with respect to their column names and execute it.Then I executed SELECT command to view inserted records.Then I created a new table named with schoolnew and similarly executed above actions on it.Then, to view inserted records in it, I execute SELECT command.Now, Here I want to make some changes in third and fourth row, to complete this action, I execute UPDATE command with INNER JOIN.To view the changes I execute the SELECT command.You can see how Third and Fourth records of table schoolold easily replaced with table schoolnew by using INNER JOIN with UPDATE statement. The following example uses a derived table, a SELECT statement after the FROM clause, to return the old and new values for further updates:And if you wanted to join the table with itself (which won\'t happen too often):Updating through CTE is more readable than the other answer\'s here:If you are using SQL Server you can update one table from another without specifying a join and simply link the two from the where clause. This makes a much simpler SQL Query:The other way is to use a derived table:Sample dataTo make sure you are updating what you want, select firstEITHER:OR:If the ID column name is the same in both tables then just put the table name before the table to be updated and use an alias for the selected table ie:I finally got this simple solution:There is even a shorter method and might be surprising for many of you:In the accepted answer, after the:I would add:What I usually do is putting everything in a rollbacked transaction and using the "OUTPUT": in this way I see everything that is about to happen. When I am happy with what I see, i change the ROLLBACK into COMMIT.I usually need to document what I did, so I use the "results to Text" option when I run the rollbacked query and I save both the script and the result of the OUTPUT. (Of course this is not practical if I changed too many rows)