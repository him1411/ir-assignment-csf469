I got a list of dictionaries and want that to be sorted by a value of that dictionary.Thissorted by name, should becomeIt may look cleaner using a key instead a cmp:or as J.F.Sebastian and others suggested,For completeness (as pointed out in comments by fitzgeraldsteele), add reverse=True to sort descendingTo sort the list of dictionaries by key=\'name\':To sort the list of dictionaries by key=\'age\':If you want to sort the list by multiple keys you can do the following:It is rather hackish, since it relies on converting the values into a single string representation for comparison, but it works as expected for numbers including negative ones (although you will need to format your string appropriately with zero paddings if you are using numbers)my_list will now be what you want.(3 years later) Edited to add:The new key argument is more efficient and neater.  A better answer now looks like:...the lambda is, IMO, easier to understand than operator.itemgetter, but YMMV.\'key\' is used to sort by an arbitrary value and \'itemgetter\' sets that value to each item\'s \'name\' attribute.I guess you\'ve meant:This would be sorted like this:Using Schwartzian transform from Perl,dogivesMore on Perl Schwartzian transformIn computer science, the Schwartzian transform is a Perl programming\n  idiom used to improve the efficiency of sorting a list of items. This\n  idiom is appropriate for comparison-based sorting when the ordering is\n  actually based on the ordering of a certain property (the key) of the\n  elements, where computing that property is an intensive operation that\n  should be performed a minimal number of times. The Schwartzian\n  Transform is notable in that it does not use named temporary arrays.You have to implement your own comparison function that will compare the dictionaries by values of name keys. See Sorting Mini-HOW TO from PythonInfo WikiYou could use a custom comparison function, or you could pass in a function that calculates a custom sort key. That\'s usually more efficient as the key is only calculated once per item, while the comparison function would be called many more times.You could do it this way:But the standard library contains a generic routine for getting items of arbitrary objects: itemgetter. So try this instead:I tried something like this:It worked for integers as well.Here is the alternative general solution - it sorts elements of dict by keys and values.\nThe advantage of it - no need to specify keys, and it would still work if some keys are missing in some of dictionaries.Lets Say I h\'v a Dictionary D with elements below. To sort just use key argument in sorted to pass custom function as belowhttps://wiki.python.org/moin/HowTo/Sorting/#Key_FunctionsUsing the pandas package is another method, though it\'s runtime at large scale is much slower than the more traditional methods proposed by others:Here are some benchmark values for a tiny list and a large (100k+) list of dicts:Here is my answer to a related question on sorting by multiple columns. It also works for the degenerate case where the number of columns is only one.sometime we need to use lower() for example