Every time a user posts something containing < or > in a page in my web application, I get this exception thrown.I don\'t want to go into the discussion about the smartness of throwing an exception or crashing an entire web application because somebody entered a character in a text box, but I am looking for an elegant way to handle this.Trapping the exception and showingAn error has occurred please go back and re-type your entire form again, but this time please do not use <doesn\'t seem professional enough to me.Disabling post validation (validateRequest="false") will definitely avoid this error, but it will leave the page vulnerable to a number of attacks.Ideally: When a post back occurs containing HTML restricted characters, that posted value in the Form collection will be automatically HTML encoded.\nSo the .Text property of my text-box will be something & lt; html & gt;Is there a way I can do this from a handler?I think you are attacking it from the wrong angle by trying to encode all posted data.Note that a "<" could also come from other outside sources, like a database field, a configuration, a file, a feed and so on. Furthermore, "<" is not inherently dangerous. It\'s only dangerous in a specific context: when writing strings that haven\'t been encoded to HTML output (because of XSS).In other contexts different sub-strings are dangerous, for example, if you write an user-provided URL into a link, the sub-string "javascript:" may be dangerous. The single quote character on the other hand is dangerous when interpolating strings in SQL queries, but perfectly safe if it is a part of a name submitted from a form or read from a database field.The bottom line is: you can\'t filter random input for dangerous characters, because any character may be dangerous under the right circumstances. You should encode at the point where some specific characters may become dangerous because they cross into a different sub-language where they have special meaning. When you write a string to HTML, you should encode characters that have special meaning in HTML, using Server.HtmlEncode. If you pass a string to a dynamic SQL statement, you should encode different characters (or better, let the framework do it for you by using prepared statements or the like)..When you are sure you HTML-encode everywhere you pass strings to HTML, then set validateRequest="false" in the <%@ Page ... %> directive in your .aspx file(s).In .NET 4 you may need to do a little more. Sometimes it\'s necessary to also add <httpRuntime requestValidationMode="2.0" /> to web.config (reference).There\'s a different solution to this error if you\'re using ASP.NET MVC:Visual Basic sample:C# sample:In ASP.NET MVC 3, you can add the AllowHtml attribute to a property on your model.It allows a request to include HTML markup during model binding by skipping request validation for the property.If you are on .NET 4.0 make sure you add this in your web.config file inside the <system.web> tags:In .NET 2.0, request validation only applied to aspx requests. In .NET 4.0 this was expanded to include all requests. You can revert to only performing XSS validation when processing .aspx by specifying:You can disable request validate entirely by specifying:For ASP.NET 4.0, you can allow markup as input for specific pages instead of the whole site by putting it all in a <location> element.  This will make sure all your other pages are safe.  You do NOT need to put ValidateRequest="false" in your .aspx page.It is safer to control this inside your web.config, because you can see at a site level which pages allow markup as input.You still need to programmatically validate input on pages where request validation is disabled.The previous answers are great, but nobody said how to exclude a single field from being validated for HTML/JavaScript injections. I don\'t know about previous versions, but in MVC3 Beta you can do this:This still validates all the fields except for the excluded one. The nice thing about this is that your validation attributes still validate the field, but you just don\'t get the "A potentially dangerous Request.Form value was detected from the client" exceptions.I\'ve used this for validating a regular expression. I\'ve made my own ValidationAttribute to see if the regular expression is valid or not. As regular expressions can contain something that looks like a script I applied the above code - the regular expression is still being checked if it\'s valid or not, but not if it contains scripts or HTML.In ASP.NET MVC you need to set requestValidationMode="2.0" and validateRequest="false" in web.config, and apply a ValidateInput attribute to your controller action:andYou can HTML encode text box content, but unfortunately that won\'t stop the exception from happening. In my experience there is no way around, and you have to disable page validation. By doing that you\'re saying: "I\'ll be careful, I promise."For MVC, ignore input validation by adding  [ValidateInput(false)]above each Action in the Controller.You can catch that error in Global.asax.  I still want to validate, but show an appropriate message.   On the blog listed below, a sample like this was available.  Redirecting to another page also seems like a reasonable response to the exception.http://www.romsteady.net/blog/2007/06/how-to-catch-httprequestvalidationexcep.htmlPlease bear in mind that some .NET controls will automatically HTML encode the output. For instance, setting the .Text property on a TextBox control will automatically encode it. That specifically means converting < into &lt;, > into &gt; and & into &amp;. So be wary of doing this...However, the .Text property for HyperLink, Literal and Label won\'t HTML encode things, so wrapping Server.HtmlEncode(); around anything being set on these properties is a must if you want to prevent <script> window.location = "http://www.google.com"; </script> from being output into your page and subsequently executed.Do a little experimenting to see what gets encoded and what doesn\'t.In the web.config file, within the  tags, insert the httpRuntime element with the attribute requestValidationMode="2.0". Also add the validateRequest="false" attribute in the pages element.Example:The answer to this question is simple:This would disable validation for the particular request.If you don\'t want to disable ValidateRequest you need to implement a JavaScript function in order to avoid the exception. It is not the best option, but it works.Then in code behind, on the PageLoad event, add the attribute to your control with the next code:Another solution is:It seems no one has mentioned the below yet, but it fixes the issue for me.  And before anyone says yeah it\'s Visual Basic... yuck.I don\'t know if there are any downsides, but for me this worked amazing.In ASP.NET, you can catch the exception and do something about it, such as displaying a friendly message or redirect to another page... Also there is a possibility that you can handle the validation by yourself...Display friendly message:I guess you could do it in a module; but that leaves open some questions; what if you want to save the input to a database? Suddenly because you\'re saving encoded data to the database you end up trusting input from it which is probably a bad idea. Ideally you store raw unencoded data in the database and the encode every time.Disabling the protection on a per page level and then encoding each time is a better option.Rather than using Server.HtmlEncode you should look at the newer, more complete Anti-XSS library from the Microsoft ACE team.The other solutions here are nice, however it\'s a bit of a royal pain in the rear to have to apply [AllowHtml] to every single Model property, especially if you have over 100 models on a decent sized site.If like me, you want to turn this (IMHO pretty pointless) feature off site wide you can override the Execute() method in your base controller (if you don\'t already have a base controller I suggest you make one, they can be pretty useful for applying common functionality).Just make sure that you are HTML encoding everything that is pumped out to the views that came from user input (it\'s default behaviour in ASP.NET MVC 3 with Razor anyway, so unless for some bizarre reason you are using Html.Raw() you shouldn\'t require this feature.I was getting this error too.In my case, a user entered an accented character \xc3\xa1 in a Role Name (regarding the ASP.NET membership provider).I pass the role name to a method to grant Users to that role and the $.ajax post request was failing miserably...I did this to solve the problem:Instead ofDo this@Html.Raw did the trick.I was getting the Role name as HTML value roleName="Cadastro b&#225;s". This value with HTML entity &#225; was being blocked by ASP.NET MVC. Now I get the roleName parameter value the way it should be: roleName="Cadastro B\xc3\xa1sico" and ASP.NET MVC engine won\'t block the request anymore.CauseASP.NET by default validates all input controls for potentially unsafe contents that can lead to cross-site scripting (XSS) and SQL injections. Thus it disallows such content by throwing the above exception. By default it is recommended to allow this check to happen on each postback.SolutionOn many occasions you need to submit HTML content to your page through Rich TextBoxes or Rich Text Editors. In that case you can avoid this exception by setting the ValidateRequest tag in the @Page directive to false.This will disable the validation of requests for the page you have set the ValidateRequest flag to false. If you want to disable this, check throughout your web application; you\xe2\x80\x99ll need to set it to false in your web.config <system.web> sectionFor .NET 4.0 or higher frameworks you will need to also add the following line in the <system.web> section to make the above work.That\xe2\x80\x99s it. I hope this helps you in getting rid of the above issue.Reference by: ASP.Net Error: A potentially dangerous Request.Form value was detected from the clientDisable the page validation if you really need the special characters like, >, , <, etc. Then ensure that when the user input is displayed, the data is HTML-encoded. There is a security vulnerability with the page validation, so it can be bypassed. Also the page validation shouldn\'t be solely relied on.See: http://www.procheckup.com/PDFs/bypassing-dot-NET-ValidateRequest.pdfIf you\'re using framework 4.0 then the entry in the web.config (<pages validateRequest="false" />)If you\'re using framework 4.5 then the entry in the web.config (requestValidationMode="2.0")You could also use JavaScript\'s escape(string) function to replace the special characters.  Then server side use Server.URLDecode(string) to switch it back.This way you don\'t have to turn off input validation and it will be more clear to other programmers that the string may have HTML content.I found a solution that uses JavaScript to encode the data, which is decoded in .NET (and doesn\'t require jQuery).Add the following JavaScript function to your header.In your textarea, include an onchange that calls boo():Finally, in .NET, useI am aware that this is one-way - if you need two-way you\'ll have to get creative, but this provides a solution if you cannot edit the web.configHere\'s an example I (MC9000) came up with and use via jQuery:And the markup:This works great. If a hacker tries to post via bypassing JavaScript, they they will just see the error. You can save all this data encoded in a database as well, then unescape it (on the server side), and parse & check for attacks before displaying elsewhere.I ended up using JavaScript before each postback to check for the characters you didn\'t want, such as:Granted my page is mostly data entry, and there are very few elements that do postbacks, but at least their data is retained.If you\'re just looking to tell your users that < and > are not to be used BUT, you don\'t want the entire form processed/posted back (and lose all the input) before-hand could you not simply put in a validator around the field to screen for those (and maybe other potentially dangerous) characters?None of the suggestions worked for me.  I did not want to turn off this feature for the whole website anyhow because 99% time I do not want my users placing HTML on web forms.  I just created my own work around method since I\'m the only one using this particular application.  I convert the input to HTML in the code behind and insert it into my database.You can use something like:Later, nvc["yourKey"] should work.You should use the Server.HtmlEncode method to protect your site from dangerous input.More info here