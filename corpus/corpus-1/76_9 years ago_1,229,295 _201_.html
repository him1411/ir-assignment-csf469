If user input is inserted without modification into an SQL query, then the application becomes vulnerable to SQL injection, like in the following example:That\'s because the user can input something like value\'); DROP TABLE table;--, and the query becomes:What can be done to prevent this from happening?Use prepared statements and parameterized queries. These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.You basically have two options to achieve this:Using PDO (for any supported database driver):Using MySQLi (for MySQL):If you\'re connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (e.g. pg_prepare() and pg_execute() for PostgreSQL). PDO is the universal option.Note that when using PDO to access a MySQL database real prepared statements are not used by default. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using PDO is:In the above example the error mode isn\'t strictly necessary, but it is advised to add it. This way the script will not stop with a Fatal Error when something goes wrong. And it gives the developer the chance to catch any error(s) which are thrown as PDOExceptions.What is mandatory however is the first setAttribute() line, which tells PDO to disable emulated prepared statements and use real prepared statements. This makes sure the statement and the values aren\'t parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).Although you can set the charset in the options of the constructor, it\'s important to note that \'older\' versions of PHP (< 5.3.6) silently ignored the charset parameter in the DSN.What happens is that the SQL statement you pass to prepare is parsed and compiled by the database server. By specifying parameters (either a ? or a named parameter like :name in the example above) you tell the database engine where you want to filter on. Then when you call execute, the prepared statement is combined with the parameter values you specify. The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn\'t intend. Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the $name variable contains \'Sarah\'; DELETE FROM employees the result would simply be a search for the string "\'Sarah\'; DELETE FROM employees", and you will not end up with an empty table.Another benefit with using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.Oh, and since you asked about how to do it for an insert, here\'s an example (using PDO):While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.Warning:\n  The question\'s sample code uses PHP\'s mysql extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.If you\'re using a recent version of PHP, the mysql_real_escape_string option outlined below will no longer be available (though mysqli::escape_string is a modern equivalent). These days the mysql_real_escape_string option would only make sense for legacy code on an old version of PHP.You\'ve got two options - escaping the special characters in your unsafe_variable, or using a parameterized query. Both would protect you from SQL injection. The parameterized query is considered the better practice, but will require changing to a newer mysql extension in PHP before you can use it.We\'ll cover the lower impact string escaping one first.See also, the details of the mysql_real_escape_string function.To use the parameterized query, you need to use MySQLi rather than the MySQL functions. To rewrite your example, we would need something like the following.The key function you\'ll want to read up on there would be mysqli::prepare.Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like PDO.Please note that the case you asked about is a fairly simple one, and that more complex cases may require more complex approaches. In particular:Every answer here covers only part of the problem.\nIn fact, there are four different query parts which we can add to it dynamically:and prepared statements covers only 2 of themBut sometimes we have to make our query even more dynamic, adding operators or identifiers as well.\nSo, we will need different protection techniques.In general, such a protection approach is based on whitelisting.\nIn this case every dynamic parameter should be hardcoded in your script and chosen from that set.\nFor example, to do dynamic ordering:However, there is another way to secure identifiers - escaping. As long as you have an identifier quoted, you can escape backticks inside by doubling them. As a further step we can borrow a truly brilliant idea of using some placeholder (a proxy to represent the actual value in the query) from the prepared statements and invent a placeholder of another type - an identifier placeholder.So, to make long story short: it\'s a placeholder, not prepared statement can be considered as a silver bullet.  So, a general recommendation may be phrased as\nAs long as you are adding dynamic parts to the query using placeholders (and these placeholders properly processed of course), you can be sure that your query is safe.Still there is an issue with SQL syntax keywords (such as AND, DESC and such) but white-listing seems the only approach in this case.Although there is a general agreement on the best practices regarding SQL injection protection, there are still many bad practices as well. And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) more than 80 deleted answers - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of bad answers aren\'t deleted but rather prospering.  For example, there(1) are(2) still(3) many(4) answers(5), including the second most upvoted answer suggesting you manual string escaping - an outdated approach that is proven to be insecure. Or there is a slightly better answer that suggests just another method of string formatting and even boasts it as ultimate panacea. While of course it is not. This method is no better than regular string formatting yet it keeps all its drawbacks: it is applicable to strings only and, as any other manual formatting, it\'s essentially optional, non-obligatory measure, prone to human error of any sort. I think that all this because of one very old superstition, supported by such authorities like OWASP or PHP manual, which proclaims equality between whatever "escaping" and protection from SQL injections. Despite of what PHP manual said for ages, *_escape_string by no means makes data safe, and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong because it is manual as opposite to automated. And OWASP makes it even worse, stressing on escaping user input which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It\'s destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is "safe" or not) he takes his first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.So, unlike whatever "escaping", prepared statements is the measure that indeed protects from SQL injection (when applicable).If you\'re still not convinced, here is a step-by step explanation I wrote, The Hitchhiker\'s Guide to SQL Injection prevention, where I explained all these matters in detail, and even compiled a section entirely dedicated to bad practices and their disclosure.I\'d recommend using PDO (PHP Data Objects) to run parameterized SQL queries. Not only does this protect against SQL injection, it also speeds up queries. And by using PDO rather than mysql_, mysqli_, and pgsql_ functions, you make your app a little more abstracted from the database, in the rare occurrence that you have to switch database providers.Use PDO and prepared queries.($conn is a PDO object)As you can see, people suggest you to use prepared statements at the most. It\'s not wrong, but when your query is executed just once per process, there would be a slightly performance penalty. I was facing this issue, but I think I solved it in very sophisticated way - the way hackers use to avoid using quotes. I used this in conjuction with emulated prepared statements. I use it to prevent all kinds of possible SQL injection attacks.If you expect input to be integer make sure it\'s really integer. In a variable-type language like PHP it is this very important. You can use for example this very simple but powerful solution: sprintf("SELECT 1,2,3 FROM table WHERE 4 = %u", $input); If you expect anything else from integer hex it. If you hex it, you will perfectly escape all input. In C/C++ there\'s a function called mysql_hex_string(), in PHP you can use bin2hex().Don\'t worry about that the escaped string will have 2x size of its original length because even if you use mysql_real_escape_string, PHP has to allocate same capacity ((2*input_length)+1), which is the same.This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with 0x or use the MySQL function UNHEX instead.So for example the query:Will become:orHex is the perfect escape. No way to inject.There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:0x prefix can only be used on data columns such as char, varchar, text, block, binary, etc.\nAlso its use is a little complicated if you are about to insert an empty string. You\'ll have to entirely replace it with \'\', or you\'ll get an error.UNHEX() works on any column; you do not have to worry about the empty string.Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with mysql_real_escape_string. Then you can avoid use of quotes.For example, if you just do something like this:an attack can inject you very easily. Consider the following injected code returned from your script:SELECT ... WHERE id = -1 union all select table_name from information_schema.tablesand now just extract table structure:SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = 0x61727469636c65And then just select whatever data ones want. Cool isn\'t it?But if the coder of injectable site would hex it, no injection would be possible because the query would look like this: SELECT ... WHERE id = UNHEX(\'2d312075...3635\')IMPORTANTThe best way to prevent SQL Injection is to use Prepared Statements instead of escaping, as the accepted answer demonstrates. There are libraries such as Aura.Sql and EasyDB that allow developers to use prepared statements easier. To learn more about why prepared statements are better at stopping SQL injection, refer to this mysql_real_escape_string() bypass and recently fixed Unicode SQL Injection vulnerabilities in WordPress.Injection prevention - mysql_real_escape_string()PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, mysql_real_escape_string.mysql_real_escape_string takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(\') a user might enter with a MySQL-safe substitute, an escaped quote \\\'.NOTE: you must be connected to the database to use this function!// Connect to MySQLYou can find more details in MySQL - SQL Injection Prevention.Security Warning: This answer is not in line with security best practices. Escaping is inadequate to prevent SQL injection, use prepared statements instead. Use the strategy outlined below at your own risk. (Also, mysql_real_escape_string() was removed in PHP 7.)You could do something basic like this:This won\'t solve every problem, but it\'s a very good stepping stone. I left out obvious items such as checking the variable\'s existence, format (numbers, letters, etc.).Whatever you do end up using, make sure that you check your input hasn\'t already been mangled by magic_quotes or some other well-meaning rubbish, and if necessary, run it through stripslashes or whatever to sanitise it.Parameterized query AND input validation is the way to go. There is many scenarios under which SQL injection may occur, even though mysql_real_escape_string() has been used.Those examples are vulnerable to SQL injection:orIn both cases, you can\'t use \' to protect the encapsulation.Source: The Unexpected SQL Injection (When Escaping Is Not Enough)In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application\'s architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it\'s just a matter of time until you forget to correctly format your query at some point in your code.Adopting the MVC pattern and a framework like CakePHP or CodeIgniter is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries. There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course PDO is one of the good solution. But I would like to suggest you some good links prevention from SQL Injection.What is SQL injection and how to preventPHP manual for SQL injectionMicrosoft explanation of SQL injection and prevention in PHPand some other like Preventing SQL injection with MySQL and PHPNow, why you do you need to prevent your query from SQL injection?I would like to let you know: Why do we try for preventing SQL injection with a short example below:Query for login authentication match:Now, if someone (a hacker) putsand password anything....The query will be parsed in the system only upto:The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to login as admin without having his password. Now, he can do anything what admin/email person can do. See, it\'s very dangerous if SQL injection is not prevented.I favor stored procedures (MySQL has had stored procedures support since 5.0) from a security point of view - the advantages are -The disadvantages are -I think if someone wants to use PHP and MySQL or some other dataBase server:Libraries examples:---- PDO----- No placeholders - ripe for SQL injection! It\'s bad----- Unnamed placeholders----- Named placeholders--- MySQLiP.S:PDO wins this battle with ease. With support for twelve\ndifferent database drivers and named parameters, we can ignore the\nsmall performance loss, and get used to its API. From a security\nstandpoint, both of them are safe as long as the developer uses them\nthe way they are supposed to be usedBut while both PDO and MySQLi are quite fast, MySQLi performs\ninsignificantly faster in benchmarks \xe2\x80\x93 ~2.5% for non-prepared\nstatements, and ~6.5% for prepared ones.And please test every query to your database - it\'s a better way to prevent injection.Type cast if possible your parameters. But it\'s only working on simple types like int, bool and float.If you want to take advantage of cache engines, like Redis or Memcached, maybe DALMP could be a choice. It uses pure MySQLi. Check this: DALMP Database Abstraction Layer for MySQL using PHP. Also you can \'prepare\' your arguments before preparing your query so that you can build dynamic queries and at the end have a full prepared statements query. DALMP Database Abstraction Layer for MySQL using PHP. Using this PHP function mysql_escape_string() you can get a good prevention in a fast way.For example: mysql_escape_string \xe2\x80\x94 Escapes a string for use in a mysql_queryFor more prevention you can add at the end ... Finally you get:For those unsure of how to use PDO (coming from the mysql_ functions), I made a very, very simple PDO wrapper that is a single file. It exists to show how easy it is to do all the common things applications need done. Works with PostgreSQL, MySQL, and SQLite.Basically, read it while you read the manual to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format you want.I want a single columnI want an array(key => value) results (i.e. for making a selectbox)I want a single row resultI want an array of resultsA few guidelines for escaping special characters in SQL statements.Don\'t use MySQL, this extension is deprecated, use MySQLi or PDO.MySQLiFor manually escaping special characters in a string you can use the mysqli_real_escape_string function. The function will not work properly unless the correct character set is set with mysqli_set_charset.Example:For automatic escaping of values with prepared statements, use mysqli_prepare, and mysqli_stmt_bind_param where types for the corresponding bind variables must be provided for an appropriate conversion:Example:No matter if you use prepared statements or mysqli_real_escape_string, you always have to know the type of input data you\'re working with.So if you use a prepared statement, you must specify the types of the variables for mysqli_stmt_bind_param function.And use of mysqli_real_escape_string is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. mysqli_real_escape_string is a useful function when used properly, especially when combined with sprintf.Example:I use three different ways to prevent my web application from being vulnerable to SQL injection.I hope this will help you.Consider the following query:$iId = mysql_real_escape_string("1 OR 1=1");\n $sSql = "SELECT * FROM table WHERE id = $iId";mysql_real_escape_string() will not protect here. If you use single quotes (\' \') around your variables inside your query is what protects you against this. Here is an solution below for this:$iId = (int) mysql_real_escape_string("1 OR 1=1");\n $sSql = "SELECT * FROM table WHERE id = $iId";This question has some good answers about this.I suggest, using PDO is the best option.Edit:mysql_real_escape_string() is deprecated as of PHP 5.5.0. Use either mysqli or PDO.An alternative to mysql_real_escape_string() is Example:The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.\nFor example: if you are using mysql database. then enter into the database through terminal or the ui provided and just follow this command:This will restrict the user to only get confined with the specified query\'s only. Remove the delete permission and so the data would never get deleted from the query fired from the php page.\nThe second thing to do is to flush the privileges so that the mysql refreshes the permissions and updates.more information about flush.To see the current privileges for the user fire the following query.Learn more about GRANT.Regarding many useful answers, I hope to add some values to this thread.\nSQL injection is attack that can be done through user inputs (Inputs that filled by user and then used inside queries), The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, we assume that there might be bad person that try to get secret information (bypassing access control) that affect the three principles of security (Confidentiality, Integrity, Availability). Now, our point is to prevent security threats such as SQL injection attacks, the question asking (How to prevent SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? How you secure your application?My approach against SQL injection is: clearing user-input data before sending it to the database (before using it inside any query).Data filtering for (Converting unsafe data to safe data)\nConsider that PDO and MySQLi not available, how can you secure your application? Do you force me to use them? What about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border not just for specific language.see Principle of least privilegeData filtering: before building any query user input should be validated and filtered, for programmers, it\'s important to define some properties for each user-input variables:\ndata type, data pattern, and data length. a field that is a number between (x and y) must be exactly validated using exact rule, for a field that is a string (text): pattern is the case, for example, username must contain only some characters lets say [a-zA-Z0-9_-.] the length vary between (x and n) where x and n (integers, x <=n ).\nRule: creating exact filters and validation rules are best practice for me. Use other tools: Here, I will also agree with you that prepared statement (parametrized query) and Stored procedures, the disadvantages here is these ways requires advanced skills which do not exist for most users, the basic idea here is to distinguish between SQL query and the data that being used inside, both approaches can be used even with unsafe data, because the user-input data here not add anything to the original query such as (any or x=x).\nFor more information, please read OWASP SQL Injection Prevention Cheat Sheet.Now, if you are an advanced user, start using this defense as you like, but, for beginners, if they can\'t quickly implement stored procedure and prepared the statement, it\'s better to filter input data as much they can.Finally, let\'s consider that user sends this text below instead of entering his  username:This input can be checked early without any prepared statement and stored procedures, but to be on safe side, using them starts after user-data filtering and validation.The last point is detecting unexpected behavior which requires more effort and complexity; it\'s not recommended for normal web applications.\nUnexpected behavior in above user input is SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, root once these words detected, you can avoid the input.A user commented that this post is useless, OK! Here is what OWASP.ORG provided:Primary defenses: \n   \n      Option #1: Use of Prepared Statements (Parameterized Queries) \n      Option #2: Use of Stored Procedures \n      Option #3: Escaping all User Supplied Input  \n   \n  Additional defenses: \n   \n      Also Enforce: Least Privilege \n      Also Perform: White List Input Validation As you may know, claiming on any article should be supported by valid argument, at least one reference! Otherwise, it\'s considered as an attack and bad claim!From the PHP manual, PHP: Prepared Statements - Manual:Escaping and SQL injection Bound variables will be escaped automatically by the server. The\n  server inserts their escaped values at the appropriate places into the\n  statement template before execution. A hint must be provided to the\n  server for the type of bound variable, to create an appropriate\n  conversion. See the mysqli_stmt_bind_param() function for more\n  information. The automatic escaping of values within the server is sometimes\n  considered a security feature to prevent SQL injection. The same\n  degree of security can be achieved with non-prepared statements if\n  input values are escaped correctly. I created test cases for knowing how PDO and MySQLi send the query to MySQL server when using prepared statement:PDO:Query Log:MySQLi:Query Log:As also mentioned in above statement The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly, therefore, this proves that data validation such as intval() is a good idea for integer values before sending any query, in addition, preventing malicious user data before sending the query is correct and valid approach.Please see this question for more detail: PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same resultReferences:A simple way would be to use a PHP framework like CodeIgniter or Laravel which have in-built features like filtering and active-record, so that you don\'t have to worry about these nuances.There are so many answers for PHP and MySQL, but here is code for PHP and Oracle for preventing SQL injection as well as regular use of oci8 drivers:Warning : the approach described in this answer only applies for very specific scenarios and isn\'t secure since SQL injection attacks do not only rely on being able to inject X=Y.If the attackers are trying to hack with the form via PHP\'s $_GET variable or with the URL\'s query string, you would be able to catch them if they\'re not secure.Because 1=1, 2=2, 1=2, 2=1, 1+1=2, etc... are the common questions to an SQL database of an attacker. Maybe also it\'s used by many hacking applications.But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect (it depends on you) that hacking-specific dynamic query string into a page that will store the attacker\'s IP address, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.Using PDO and MYSQLi is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to usemysql_real_escape_stringThere are more ability to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also it would be better to use these functions to check input data.is_stringis_numericAnd it is so much better to use those functions to check input data with mysql_real_escape_string.A good idea is to use an \'object-relational mapper\' like Idiorm:It not only saves you from SQL injections, but from syntax errors too! Also Supports collections of models with method chaining to filter or apply actions to multiple results at once and mutliple connection.I\'ve written this little function several years ago:This allows running statements in an one-liner C#-ish String.Format like:It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is invalid syntax.SECURITY UPDATE: The previous str_replace version allowed injections by adding {#} tokens into user data. This preg_replace_callback version doesn\'t cause problems if the replacement contains these tokens.