How do I iterate over a range of numbers in Bash when the range is given by a variable?I know I can do this (called "sequence expression" in the Bash documentation):Which gives:1 \n  2 \n  3 \n  4 \n  5Yet, how can I replace either of the range endpoints with a variable? This doesn\'t work:Which prints:{1..5}edit: I prefer seq over the other methods because I can actually remember it ;)The seq method is the simplest, but Bash has built-in arithmetic evaluation.The for ((expr1;expr2;expr3)); construct works just like for (expr1;expr2;expr3) in C and similar languages, and like other ((expr)) cases, Bash treats them as arithmetic.Using seq is fine, as Jiaaro suggested. Pax Diablo suggested a Bash loop to avoid calling a subprocess, with the additional advantage of being more memory friendly if $END is too large. Zathrus spotted a typical bug in the loop implementation, and also hinted that since i is a text variable, continuous conversions to-and-fro numbers are performed with an associated slow-down.This is an improved version of the Bash loop:If the only thing that we want is the echo, then we could write echo $((i++)).ephemient taught me something: Bash allows for ((expr;expr;expr)) constructs. Since I\'ve never read the whole man page for Bash (like I\'ve done with the Korn shell (ksh) man page, and that was a long time ago), I missed that.So,seems to be the most memory-efficient way (it won\'t be necessary to allocate memory to consume seq\'s output, which could be a problem if END is very large), although probably not the \xe2\x80\x9cfastest\xe2\x80\x9d.eschercycle noted that the {a..b} Bash notation works only with literals; true, accordingly to the Bash manual. One can overcome this obstacle with a single (internal) fork() without an exec() (as is the case with calling seq, which being another image requires a fork+exec):Both eval and echo are Bash builtins, but a fork() is required for the command substitution (the $(\xe2\x80\xa6) construct).Here is why the original expression didn\'t work.From man bash:Brace expansion is performed before\n  any other expansions, and any\n  characters special to  other \n  expansions  are    preserved in the\n  result.  It is strictly textual.  Bash\n  does not apply any syntactic\n  interpretation to the context of\n  the expansion or the text between the\n  braces.So, brace expansion is something done early as a purely textual macro operation, before parameter expansion.Shells are highly optimized hybrids between macro processors and more formal programming languages.  In order to optimize the typical use cases, the language is made rather more complex and some limitations are accepted.RecommendationI would suggest sticking with Posix1 features. This means using for i in <list>; do, if the list is already known, otherwise, use while or seq, as in:The POSIX wayIf you care about portability, use the example from the POSIX standard:Output:Things which are not POSIX:the dollar at i=$i+1 might be required, but I\'m not sure. POSIX 7 2.6.4 Arithmetic Expansion says:If the shell variable x contains a value that forms a valid integer constant, optionally including a leading plus or minus sign, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.but reading it literally that does not imply that $((x+1)) expands since x+1 is not a variable.Another layer of indirection:You can useIf you\'re on BSD / OS X you can use jot instead of seq:This works fine in bash:I know this question is about bash, but - just for the record - ksh93 is smarter and implements it as expected:This is another way:These are all nice but seq is supposedly deprecated and most only work with numeric ranges.If you enclose your for loop in double quotes, the start and end variables will be dereferenced when you echo the string, and you can ship the string right back to BASH for execution. $i needs to be escaped with \\\'s so it is NOT evaluated before being sent to the subshell.This output can also be assigned to a variable:The only "overhead" this should generate should be the second instance of bash so it should be suitable for intensive operations.If you need it prefix than you might like thisthat will yieldReplace {} with (( )):Yields:If you\'re doing shell commands and you (like I) have a fetish for pipelining, this one is good:seq 1 $END | xargs -I {} echo {}If you want to stay as close as possible to the brace-expression syntax, try out the range function from bash-tricks\' range.bash.For example, all of the following will do the exact same thing as echo {1..10}:It tries to support the native bash syntax with as few "gotchas" as possible: not only are variables supported, but the often-undesirable behavior of invalid ranges being supplied as strings (e.g. for i in {1..a}; do echo $i; done) is prevented as well.The other answers will work in most cases, but they all have at least one of the following drawbacks:Disclaimer: I am the author of the linked code.