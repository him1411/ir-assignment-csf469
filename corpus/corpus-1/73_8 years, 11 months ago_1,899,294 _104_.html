What is the most concise and efficient way to find out if a JavaScript array contains an object?This is the only way I know to do it:Is there a better and more concise way to accomplish this?This is very closely related to Stack Overflow question Best way to find an item in a JavaScript Array? which addresses finding objects in an array using indexOf.Modern browsers have Array#indexOf, which can do that. Even newer browsers have Array#includes, which does exactly that, but unfortunately it\'s not widely supported. Older browsers can be supported using this polyfill.jQuery offers $.inArray, which is functionally equivalent to Array#indexOf.underscore.js, a JavaScript utility library, offers _.contains(list, value), alias _.include(list, value), both of which use indexOf internally if passed a JavaScript array.Some other frameworks offer similar methods:Notice that some frameworks implement this as a function, while others add the function to the array prototype.In CoffeeScript, the in operator is the equivalent of contains:Dart:Update: As @orip mentions in comments, the linked benchmark was done in 2008, so results may not be relevant for modern browsers. However, you probably need this to support non-modern browsers anyway and they probably haven\'t been updated since. Always test for yourself.As others have said, the iteration through the array is probably the best way, but it has been proven that a decreasing while loop is the fastest way to iterate in JavaScript. So you may want to rewrite your code as follows:Of course, you may as well extend Array prototype:And now you can simply use the following:indexOf maybe, but it\'s a "JavaScript extension to the ECMA-262 standard; as such it may not be present in other implementations of the standard."Example:AFAICS Microsoft does not offer some kind of alternative to this, but you can add similar functionality to arrays in Internet Explorer (and other browsers that don\'t support indexOf) if you want to, as a quick Google search reveals (for example, this one).ECMAScript 7 introduces Array.prototype.includes.It can be used like this:It also accepts an optional second argument fromIndex:Unlike indexOf, which uses Strict Equality Comparison, includes compares using SameValueZero equality algorithm. That means that you can detect if an array includes a NaN:Also unlike indexOf, includes does not skip missing indices:Currently it\'s still a draft but can be polyfilled to make it work on all browsers.b is the value, and a is the array. It returns true or false:Here\'s a JavaScript 1.6 compatible implementation of Array.indexOf:Use:Extending the JavaScript Array object is a really bad idea because you introduce new properties (your custom methods) into for-in loops which can break existing scripts. A few years ago the authors of the Prototype library had to re-engineer their library implementation to remove just this kind of thing.If you don\'t need to worry about compatibility with other JavaScript running on your page, go for it, otherwise, I\'d recommend the more awkward, but safer free-standing function solution.You can use Array.prototype.some()Upside to this is that the iteration is aborted once the element is found so unnecessary iteration cycles are saved.One thing to note is that some() is not present in all js versions: (from the website)some was added to the ECMA-262 standard in the 5th edition; as such it\n  may not be present in all implementations of the standardYou can add it in case it\'s not there with this polyfill (from the same link)I use the following:Thinking out of the box for a second, if you are in making this call many many times, it is vastly more efficient to use an associative array a Map to do lookups using a hash function.https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/MapOne-liner:Array.prototype.some() was added to the ECMA-262 standard in the 5th editionA hopefully faster bidirectional indexOf / lastIndexOf alternativeWhile the new method includes is very nice, the support is basically zero for now.It\'s long time that I was thinking of way to replace the slow indexOf/lastIndexOf functions.A performant way has already been found, looking at the top answers. From those I chose the contains function posted by @Damir Zekic which should be the fastest one. But it also states that the benchmarks are from 2008 and so are outdated.I also prefer while over for, but for not a specific reason I ended writing the function with a for loop. It could be also done with a while --.I was curious if the iteration was much slower if I check both sides of the array while doing it. Apparently no, and so this function is around two times faster than the top voted ones. Obviously it\'s also faster than the native one. This in a real world environment, where you never know if the value you are searching is at the beginning or at the end of the array.When you know you just pushed an array with a value, using lastIndexOf remains probably the best solution, but if you have to travel through big arrays and the result could be everywhere, this could be a solid solution to make things faster.Bidirectional indexOf/lastIndexOfhttp://jsperf.com/bidirectionalindexofAs test I created an array with 100k entries.Three queries: at the beginning, in the middle & at the end of the array.I hope you also find this interesting and test the performance.Note: As you can see I slightly modified the contains function to reflect the indexOf & lastIndexOf output (so basically true with the index and false with -1). That shouldn\'t harm it.The function can also be easily modified to return true or false or even the object, string or whatever it is.And here is the while variant:I think that the simple calculation to get the reflected index in an array is so simple that it\'s two times faster than doing an actual loop iteration.Here is a complex example doing three checks per iteration, but this is only possible with a longer calculation which causes the slowdown of the code.http://jsperf.com/bidirectionalindexof/2If you are checking repeatedly for existence of an object in an array you should maybe look intoReturns array index if found, or -1 if not foundWhile array.indexOf(x)!=-1 is the most concise way to do this (and has been supported by non-InternetÂ Explorer browsers for over decade...), it is not O(1), but rather O(N), which is terrible. If your array will not be changing, you can convert your array to a hashtable, then do table[x]!==undefined or ===undefined:Demo:(Unfortunately, while you can create an Array.prototype.contains to "freeze" an array and store a hashtable in this._cache in two lines, this would give wrong results if you chose to edit your array later. JavaScript has insufficient hooks to let you keep this state, unlike Python for example.)If you are using JavaScript 1.6 or later (Firefox 1.5 or later) you can use Array.indexOf.  Otherwise, I think you are going to end up with something similar to your original code.We use this snippet (works with objects, arrays, strings):Usage:Use lodash\'s some function.It\'s concise, accurate and has great cross platform support.The accepted answer does not even meet the requirements.Requirements: Recommend most concise and efficient way to find out if a JavaScript array contains an object.Accepted Answer:My recommendation:Notes: $.inArray works fine for determining whether a scalar value exists in an array of scalars...... but the question clearly asks for an efficient way to determine if an object is contained in an array.In order to handle both scalars and objects, you could do this:ECMAScript 6 has an elegant proposal on find.The find method executes the callback function once for each element\n  present in the array until it finds one where callback returns a true\n  value. If such an element is found, find immediately returns the value\n  of that element. Otherwise, find returns undefined. callback is\n  invoked only for indexes of the array which have assigned values; it\n  is not invoked for indexes which have been deleted or which have never\n  been assigned values.Here is the MDN documentation on that.The find functionality works like this.You can use this in ECMAScript 5 and below by defining the function.Solution that works in all modern browsers:Usage:IE6+ solution:Usage:Array.indexOf and Array.includes (as well as most of the answers here) only compare by reference and not by value.Non-optimized ES6 one-liner:Note:\nComparing objects by value will work better if the keys are in the same order, so to be safe you might sort the keys first with a package like this one: https://www.npmjs.com/package/sort-keysUpdated the contains function with a perf optimization. Thanks itinance for pointing it out.Use:DemoTo know exactly what the tilde ~ do at this point, refer to this question What does a tilde do when it precedes an expression?.Use:I know it\'s not the best way to go, but since there is no native IComparable way to interact between objects, I guess this is as close as you can get to compare two entities in an array. Also, extending Array object might not be a wise thing to do, but sometimes it\'s OK (if you are aware of it and the trade-off).One can use Set that has the method "has()":Here\'s how Prototype does it:Also see here for how they hook it up.As others have mentioned you can use Array.indexOf, but it isn\'t available in all browsers. Here\'s the code from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf to make it work the same in older browsers.indexOf is a recent addition to the ECMA-262 standard; as such it may\n  not be present in all browsers. You can work around this by inserting\n  the following code at the beginning of your scripts, allowing use of\n  indexOf in implementations which do not natively support it. This\n  algorithm is exactly the one specified in ECMA-262, 5th edition,\n  assuming Object, TypeError, Number, Math.floor, Math.abs, and Math.max\n  have their original value.By no means the best, but I was just getting creative and adding to the repertoire.You can also use this trick:Similar thing: Finds the first element by a "search lambda":Usage:Same in coffeescript: