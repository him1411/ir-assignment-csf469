I want to get the filename (without extension) and the extension separately.The best solution I found so far is:This is wrong because it doesn\'t work if the file name contains multiple "." characters. If, let\'s say, I have a.b.js it will consider a and b.js, instead of a.b and js.It can be easily done in Python withbut I\'d prefer not to fire a Python interpreter just for this, if possible.Any better ideas?First, get file name without the path:Alternatively, you can focus on the last \'/\' of the path instead of the \'.\' which should work even if you have unpredictable file extensions:For more details, see shell parameter expansion in the Bash manual.Usually you already know the extension, so you might wish to use:for example:and we getYou can use the magic of POSIX variables:There\'s a caveat in that if your filename was of the form ./somefile.tar.gz then echo ${FILENAME%%.*} would greedily remove the longest match to the . and you\'d have the empty string. (You can work around that with a temporary variable:)This site explains more.That doesn\'t seem to work if the file has no extension, or no filename.  Here is what I\'m using; it only uses builtins and handles more (but not all) pathological filenames.And here are some testcases:You can use basename.Example:You do need to provide basename with the extension that shall be removed, however if you are always executing tar with -z then you know the extension will be .tar.gz.This should do what you want:You could use the cut command to remove the last two extensions (the ".tar.gz" part):As noted by Clayton Hughes in a comment, this will not work for the actual example in the question. So as an alternative I propose using sed with extended regular expressions, like this:It works by removing the last two (alpha-numeric) extensions unconditionally.[Updated again after comment from Anders Lindahl]Mellen writes in a comment on a blog post:Using Bash, there\xe2\x80\x99s also ${file%.*} to get the filename without the extension and ${file##*.} to get the extension alone. That is,Outputs:Here are some alternative suggestions (mostly in awk), including some advanced use cases, like extracting version numbers for software packages.  All use cases are using the original full path as input, without depending on intermediate results.works fine, so you can just use:The commands, by the way, work as follows.The command for NAME substitutes a "." character followed by any number of non-"." characters up to the end of the line, with nothing (i.e., it removes everything from the final "." to the end of the line, inclusive). This is basically a non-greedy substitution using regex trickery.The command for EXTENSION substitutes a any number of characters followed by a "." character at the start of the line, with nothing (i.e., it removes everything from the start of the line to the final dot, inclusive). This is a greedy substitution which is the default action.I think that if you just need the name of the file, you can try this:And that is all =D.[Revised from a one-liner to a generic bash function, behavior now consistent with dirname and basename utilities; rationale added.]The accepted answer works well in typical cases, but fails in edge cases, namely:Thus, the complexity of a robust solution that covers all edge cases calls for a function - see its definition below; it can return all components of a path.Example call:Note that the arguments after the input path are freely chosen, positional variable names.\nTo skip variables not of interest that come before those that are, specify _ (to use throw-away variable $_) or \'\'; e.g., to extract filename root and extension only, use splitPath \'/etc/bash.bashrc\' _ _ fnameroot extension.Test code that exercises the function:Expected output - note the edge cases:You can force cut to display all fields and subsequent ones adding - to field number.So if FILE is eth0.pcap.gz, the EXTENSION will be pcap.gzUsing the same logic, you can also fetch the file name using \'-\' with cut as follows :This works even for filenames that do not have any extension.  No need to bother with awk or sed or even perl for this simple task. There is a pure-Bash, os.path.splitext()-compatible solution which only uses parameter expansions.Documentation of os.path.splitext(path):Split the pathname path into a pair (root, ext) such that root + ext == path, and ext is empty or begins with a period and contains at most one period. Leading periods on the basename are ignored; splitext(\'.cshrc\') returns (\'.cshrc\', \'\').Python code:Here are test cases for the Ignoring leading periods implementation, which should match the Python reference implementation on every input.All tests passed.Ok so if I understand correctly, the problem here is how to get the name and the full extension of a file that has multiple extensions, e.g., stuff.tar.gz.This works for me:This will give you stuff as filename and .tar.gz as extension. It works for any number of extensions, including 0. Hope this helps for anyone having the same problem =)In addition to the lot of good answers on this StackÂ Overflow question I would like to add:Under Linux and other unixen, there is a magic command named file, that do filetype detection by analysing some first bytes of file. This is a very old tool, initialy used for print servers (if not created for... I\'m not sure about that).Standards extensions could be found in /etc/mime.types (on my Debian GNU/Linux desktop. See man file and man mime.types. Perhaps you have to install the file utility and mime-support packages):You could create a bash function for determining right extension.\nThere is a little (not perfect) sample:This function could set a Bash variable that can be used later:(This is inspired from @Petesh right answer):I use the following scriptThis caters for multiple dots and spaces in a filename, however if there is no extension it returns the filename itself. Easy to check for though; just test for the filename and extension being the same.Naturally this method doesn\'t work for .tar.gz files. However that could be handled in a two step process. If the extension is gz then check again to see if there is also a tar extension.How to extract the filename and extension in fish:Caveats: Splits on the last dot, which works well for filenames with dots in them, but not well for extensions with dots in them. See example below.Usage:There\'s probably better ways to do this. Feel free to edit my answer to improve it.If there\'s a limited set of extensions you\'ll be dealing with and you know all of them, try this:This does not have the caveat as the first example, but you do have to handle every case so it could be more tedious depending on how many extensions you can expect.Here is code with AWK. It can be done more simply. But I am not good in AWK.Smallest and simplest solution (in single line) is:$ file=/blaabla/bla/blah/foo.txtecho $(basename ${file%.*})fooA simple answer:To expand on the POSIX variables answer, note that you can do more interesting patterns. So for the case detailed here, you could simply do this:That will cut off the last occurrence of .tar.<something>.More generally, if you wanted to remove the last occurrence of .<something>.<something-else> thenshould work fine.The link the above answer appears to be dead. Here\'s a great explanation of a bunch of the string manipulation you can do directly in Bash, from TLDP.Building from Petesh answer, if only the filename is needed,\nboth path and extension can be stripped in a single line,Based largely off of @mklement0\'s excellent, and chock-full of random, useful bashisms - as well as other answers to this / other questions / "that darn internet"... I wrapped it all up in a little, slightly more comprehensible, reusable function for my (or your) .bash_profile that takes care of what (I consider) should be a more robust version of dirname/basename / what have you..Usage examples...From the answers above, the shortest oneliner to mimic Python\'spresuming your file really does have an extension, isIf you also want to allow empty extensions, this is the shortest I could come up with:1st line explained: It matches PATH.EXT or ANYTHING and replaces it with EXT. If ANYTHING was matched, the ext group is not captured.In order to make dir more useful (in the case a local file with no path is specified as input) I did the following:This allows you to do something useful like add a suffix to the input file basename as:You can useto get file name andto get extension.Test case:Here is the algorithm I used for finding the name and extension of a file when I wrote a Bash script to make names unique when names conflicted with respect to casing. The test run.FYI: The complete transliteration program and more test cases can be found here:\nhttps://www.dropbox.com/s/4c6m0f2e28a1vxf/avoid-clashes-code.zip?dl=0Using example file /Users/Jonathan/Scripts/bash/MyScript.sh, this code:will result in ${ME} being MyScript and ${MY_EXT} being .sh:Script:Some tests: