What are "sequence points"?What is the relation between undefined behaviour and sequence points?I often use funny and convoluted expressions like a[++i] = i;, to make myself feel better. Why should I stop using them?If you\'ve read this, be sure to visit the follow-up question Undefined behavior and sequence points reloaded.\n(Note: This is meant to be an entry to Stack Overflow\'s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)\nThis answer is for the older versions of the C++ standard.  The C++11 and C++14 versions of the standard do not formally contain \'sequence points\'; operations are \'sequenced before\' or \'unsequenced\' or \'indeterminately sequenced\' instead.  The net effect is essentially the same, but the terminology is different.Disclaimer : Okay. This answer is a bit long. So have patience while reading it. If you already know these things, reading them again won\'t make you crazy. Pre-requisites : An elementary knowledge of C++ Standard The Standard says At  certain specified points in the execution sequence called sequence points, all side effects of previous evaluations \n  shall be complete and no side effects of subsequent evaluations shall have taken place. (\xc2\xa71.9/7)Evaluation  of  an  expression produces something and if in addition there is a change in the state of the execution environment it is said that the expression (its evaluation) has some side effect(s).For example:In addition to the initialization operation the value of y gets changed due to the side effect of ++ operator. So far so good. Moving on to sequence points. An alternation definition of seq-points given by the comp.lang.c author Steve Summit:Sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.Those are:Example :in the evaluation of each of the following expressions after the evaluation of the first expression(\xc2\xa71.9/18) 2at a function call (whether or not the function is inline), after the evaluation of all function arguments (if any) which \ntakes place before execution of any expressions or statements in the function body (\xc2\xa71.9/17).1 : Note : the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically\npart of the full-expression.  For example, subexpressions involved in evaluating default argument expressions (8.3.6) are considered to be created in the expression that calls the function, not the expression that defines the default argument2 : The operators indicated are the built-in operators, as described in clause 5.  When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation and the operands form an argument list, without an implied sequence point between them.The Standard defines Undefined Behaviour in Section \xc2\xa71.3.12 asbehaviour, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no  requirements 3.Undefined  behaviour  may  also  be  expected  when  this\n  International Standard omits the description of any explicit definition of behavior. 3 : permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or with-\nout the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).In short, undefined behaviour means anything can happen from daemons flying out of your nose to  your girlfriend getting pregnant.Before I get into that you must know the difference(s) between Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour.You must also know that the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.For example:Another example here.Now the Standard in \xc2\xa75/4 saysWhat does it mean?Informally it means that between two sequence points a variable must not be modified more than once.\nIn an expression statement, the next sequence point is usually at the terminating semicolon, and the previous sequence point is at the end of the previous statement. An expression may also contain intermediate sequence points.From the above sentence the following expressions invoke Undefined Behaviour:But the following expressions are fine:What does it mean? It means if an object is written to within a full expression, any and all accesses to it within the same expression must be directly involved in the computation of the value to be written. For example in i = i + 1 all the access of i (in L.H.S and in R.H.S) are directly involved in computation of the value to be written. So it is fine.This rule effectively constrains legal expressions to those in which the accesses demonstrably precede the modification.Example 1:Example 2:is disallowed because one of the accesses of i (the one in a[i]) has nothing to do with the value which ends up being stored in i (which happens over in i++), and so there\'s no good way to define--either for our understanding or the compiler\'s--whether the access should take place before or after the incremented value is stored. So the behaviour is undefined.Example 3 :Follow up answer here. This is a follow up to my previous answer and contains C++11 related material..Pre-requisites : An elementary knowledge of Relations (Mathematics).Yes! This is very true. Sequence Points have been replaced by Sequenced Before and Sequenced After (and Unsequenced and Indeterminately Sequenced) relations in C++11.Sequenced Before(\xc2\xa71.9/13) is a relation which is: between evaluations executed by a single thread and induces a strict partial order1Formally it means given any two evaluations(See below) A and B, if A is sequenced before B, then the execution of A shall precede the execution of B. If A is not sequenced before B and B is not sequenced before A, then A and B are unsequenced 2.Evaluations A and B are indeterminately sequenced when either A is sequenced before B or B is sequenced before A, but it is unspecified which3.[NOTES]\n\n  1 :  A strict partial order is a binary relation "<" over a set P which is asymmetric, and transitive, i.e., for all a, b, and c in P, we have that:  \n  ........(i). if a < b then \xc2\xac (b < a) (asymmetry);\n  ........(ii). if a < b and b < c then a < c (transitivity).\n  2 : The execution of unsequenced evaluations can overlap.\n  3 : Indeterminately sequenced evaluations cannot overlap, but either could be executed first.\nIn C++11, evaluation of an expression (or a sub-expression) in general includes: value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) andinitiation of side effects.Now  (\xc2\xa71.9/14) says:Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.Trivial example: int x;\n x = 10;\n ++x;Value computation and side effect associated with ++x is sequenced after the value computation and side effect of x = 10; Yes! Right.In (\xc2\xa71.9/15) it has been mentioned that Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced4.For example : 4: In an expression that is evaluated more than once during the execution\nof a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations. (\xc2\xa71.9/15)\n  The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator.That means in x + y the value computation of x and y are sequenced before the value computation of (x + y).More importantly(\xc2\xa71.9/15) If a side effect on a scalar object is unsequenced relative to either(a) another side effect on the same scalar object or (b) a value computation using the value of the same scalar object.the behaviour is undefined.Examples:When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [Note: Value computations and side effects associated with different argument expressions are unsequenced.  \xe2\x80\x94 end note]Expressions (5), (7) and (8) do not invoke undefined behaviour. Check out the following answers for a more detailed explanation.Final Note : If you find any flaw in the post please leave a comment. Power-users (With rep >20000) please do not hesitate to edit the post for correcting typos and other mistakes.I am guessing there is a fundamental reason for the change, it isn\'t merely cosmetic to make the old interpretation clearer: that reason is concurrency. Unspecified order of elaboration is merely selection of one of several possible serial orderings, this is quite different to before and after orderings, because if there is no specified ordering, concurrent evaluation is possible: not so with the old rules. For example in:previously either a then b, or, b then a. Now, a and b can be evaluated with instructions interleaved or even on different cores. C++17 (N4659) includes a proposal Refining Expression Evaluation Order for Idiomatic C++\nwhich defines a stricter order of expression evaluation.In particular, the following sentence was added:8.18 Assignment and compound assignment operators:....In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.\n  The right operand is sequenced before the left operand.It makes several cases of previously undefined behavior valid, including the one in question:However several other similar cases still lead to undefined behavior.In N4140:But in N4659Of course, using a C++17 compliant compiler does not necessarily mean that one should start writing such expressions.