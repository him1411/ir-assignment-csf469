How can I add an empty directory (that contains no files) to a Git repository?Another way to make a directory stay empty (in the repository) is to create a .gitignore file inside that directory that contains four lines:Then you don\'t have to get the order right the way that you have to do in m104\'s solution.You can\'t.  See the Git FAQ.Currently the design of the git index\n  (staging area) only permits files to\n  be listed, and nobody competent enough\n  to make the change to allow empty\n  directories has cared enough about\n  this situation to remedy it.Directories are added automatically\n  when adding files inside them. That\n  is, directories never have to be added\n  to the repository, and are not tracked\n  on their own.You can say "git add <dir>" and it\n  will add files in there.If you really need a directory to\n  exist in checkouts you should create a\n  file in it. .gitignore works well for\n  this purpose; you can leave it empty,\n  or fill in the names of files you\n  expect to show up in the directory.Create an empty file called .gitkeep in the directory, and add that.You could always put a README file in the directory with an explanation of why you want this, otherwise empty, directory in the repository.On Linux, this creates an empty file named .keep. This name is preferred over .gitkeep as the former is agnostic to Git, whereas the latter is specific to Git. Secondly, as another user has noted, the .git prefix convention should be reserved for files and directories that Git itself uses.Alternatively, as noted in another answer, the directory can contain a descriptive README or README.md file instead.Of course this requires that the presence of the file won\'t cause your application to break.An empty directory cannot be part of a tree under the Git versioning system.\nBut there are many scenarios in which an empty directory could be useful, for example:Many users suggest:While both solutions surely work, no question on that, I find them unconsistent with a meaningful approach to Git versioning.Use an empty file called .gitkeep in order to force the presence of the folder in the versioning system.Although it may seem not such a big difference:You use a file that has the single purpose of keeping the folder. You don\'t put there any info you don\'t want to put.For instance, you should use READMEs as READMEs, not as an excuse to keep the folder.Separation of concerns is always a good thing, and you can still add a .gitignore to ignore unwanted files.Naming it .gitkeep makes it very clear and straightforward from the filename itself (and also to other developers, which is good for a shared project and one of the core purposes of a Git repository) that this file isI\'ve seen the .gitkeep approach adopted by very important frameworks like Laravel, Angular-CLI.As described in other answers, Git is unable to represent empty directories in its staging area. (See the Git FAQ.) However, if, for your purposes, a directory is empty enough if it contains a .gitignore file only, then you can create .gitignore files in empty directories only via:Andy Lester is right, but if your directory just needs to be empty, and not empty empty, you can put an empty .gitignore file in there as a workaround.As an aside, this is an implementation issue, not a fundamental Git storage design problem. As has been mentioned many times on the Git mailing list, the reason that this has not been implemented is that no one has cared enough to submit a patch for it, not that it couldn\xe2\x80\x99t or shouldn\xe2\x80\x99t be done.The Ruby on Rails way: Now the log directory will be included in the tree. It is super-useful when deploying, so you won\'t have to write a routine to make log directories.The logfiles can be kept out by issuing, but you probably knew that.Git does not track empty directories. See the Git FAQ for more explanation. The suggested workaround is to put a .gitignore file in the empty directory. I do not like that solution, because the .gitignore is "hidden" by Unix convention. Also there is no explanation why the directories are empty.I suggest to put a README file in the empty directory explaining why the directory is empty and why it needs to be tracked in Git. With the README file in place, as far as Git is concerned, the directory is no longer empty.The real question is why do you need the empty directory in git? Do you not have some sort of build script that can create the empty directory before compiling/running? Usually when you really do need the empty directory in git there is a reason for that. So you put that reason in the README file. That way other developers know why the empty directory needs to be there. Future you will also know that you can remove the empty directory when the problem requiring the empty directory has been solved.To list every empty directory use the following command:To create placeholder READMEs in every empty directory:To ignore everything in the directory except the README file put the following lines in your .gitignore:Alternatively, you could just exclude every README file from being ignored:To list every README after they are already created:WARNING: This tweak is not truly working as it turns out. Sorry for the inconvenience.Original post below:I found a solution while playing with Git internals!Create your empty directory:Add it to the index using a plumbing command and the empty tree SHA-1:Type the command and then enter the second line. Press Enter and then Ctrl + D to terminate your input.\nNote: the format is mode [SPACE] type [SPACE] SHA-1hash [TAB] path (the tab is important, the answer formatting does not preserve it).That\'s it! Your empty folder is in your index. All you have to do is commit.This solution is short and apparently works fine (see the EDIT!), but it is not that easy to remember...The empty tree SHA-1 can be found by creating a new empty Git repository, cd into it and issue git write-tree, which outputs the empty tree SHA-1.EDIT:I\'ve been using this solution since I found it. It appears to work exactly the same way as creating a submodule, except that no module is defined anywhere.\nThis leads to errors when issuing git submodule init|update.\nThe problem is that git update-index rewrites the 040000 tree part into 160000 commit.Moreover, any file placed under that path won\'t ever be noticed by Git, as it thinks they belong to some other repository. This is nasty as it can easily be overlooked!However, if you don\'t already (and won\'t) use any Git submodules in your repository, and the "empty" folder will remain empty or if you want Git to know of its existence and ignore its content, you can go with this tweak. Going the usual way with submodules takes more steps that this tweak.Maybe adding an empty directory seems like it would be the path of least resistance because you have scripts that expect that directory to exist (maybe because it is a target for generated binaries).  Another approach would be to modify your scripts to create the directory as needed.In this example, you might check in a (broken) symbolic link to the directory so that you can access it without the ".generated" prefix (but this is optional).When you want to clean up your source tree you can just:If you take the oft-suggested approach of checking in an almost-empty folder, you have the minor complexity of deleting the contents without also deleting the ".gitignore" file.You can ignore all of your generated files by adding the following to your root .gitignore:Let\'s say you need an empty directory named tmp :In other words, you need to add the .gitignore file to the index before you can tell Git to ignore it (and everything else in the empty directory).I\'ve been facing the issue with empty directories, too. The problem with using placeholder files is that you need to create them, and delete them, if they are not necessary anymore (because later on there were added sub-directories or files. With big source trees managing these placeholder files can be cumbersome and error prone.This is why I decided to write an open source tool which can manage the creation/deletion of such placeholder files automatically. It is written for .NET platform and runs under Mono (.NET for Linux) and Windows.Just have a look at: http://code.google.com/p/markemptydirsYou can\'t and unfortunately will never be able to. This is a decision made by Linus Torvald himself. He knows what\'s good for us. There is a rant out there somewhere I read once. I found Re: Empty directories.., but maybe there is another one.You have to live with the workarounds...unfortunately.When you add a .gitignore file, if you are going to put any amount of content in it (that you want Git to ignore) you might want to add a single line with just an asterisk * to make sure you don\'t add the ignored content accidentally. As mentioned it\'s not possible to add empty directories, but here is a one liner that adds empty .gitignore files to all directories. ruby -e \'require "fileutils" ; Dir.glob(["target_directory","target_directory/**"]).each { |f| FileUtils.touch(File.join(f, ".gitignore")) if File.directory?(f) }\'I have stuck this in a Rakefile for easy access.I always build a function to check for my desired folder structure and build it for me within the project. This gets around this problem as the empty folders are held in Git by proxy.This is in PHP, but I am sure most languages support the same functionality, and because the creation of the folders is taken care of by the application, the folders will always be there.There\'s no way to get Git to track directories, so the only solution is to add a placeholder file within the directory that you want Git to track.The file can be named and contain anything you want, but most people use an empty file named .gitkeep (although some people prefer the VCS-agnostic .keep).The prefixed . marks it as a hidden file.Another idea would be to add a README file explaining what the directory will be used for.The solution of Jamie Flournoy works great. Here is a bit enhanced version to keep the .htaccess :With this solution you are able to commit a empty folder, for example /log, /tmp or /cache and the folder will stay empty.I like the answers by @Artur79 and @mjs so I\'ve been using a combination of both and made it a standard for our projects.However, only a handful of our developers work on Mac or Linux. A lot work on Windows and I could not find an equivalent simple one-liner to accomplish the same there. Some were lucky enough to have Cygwin installed for other reasons, but prescribing Cygwin just for this seemed overkill.So, since most of our developers already have Ant installed, I put together a build file to accomplish this independently of the platform.Now I can simply run And this creates a .gitkeep file in any empty subdir. Even on Windows :)\nNote: This build file requires the Ant Contrib jar.I continue to work on this concept here.https://github.com/mig82/gitkeepHere is a hack, but it\'s funny that it works (Git 2.2.1). Similar to what @Teka suggested, but easier to remember:Now, you have a directory that gets created when commit is checked out. An interesting thing though is that if you look at the content of tree object of this file you\'ll get:fatal: Not a valid object name\n  b64338b90b4209263b50244d18278c0999867193I wouldn\'t encourage to use it though since it may stop working in the future versions of Git. Which may leave your repository corrupted.You can\'t. This is an intentional design decision by the Git maintainers. Basically, the purpose of a Source Code Management System like Git is managing source code and empty directories aren\'t source code. Git is also often described as a content tracker, and again, empty directories aren\'t content (quite the opposite, actually), so they are not tracked.You can save this code as create_readme.php and run the PHP code from the root directory of your Git project. It will add README files to all directories that are empty so those directories would be then added to the index.Then doAdding one more option to the fray.Assuming you would like to add a directory to git that, for all purposes related to git, should remain empty and never have it\'s contents tracked, a .gitignore as suggested numerous times here, will do the trick.The format, as mentioned, is:Now, if you want a way to do this at the command line, in one fell swoop, while inside the directory you want to add, you can execute:Myself, I have a shell script that I use to do this.  Name the script whatever you whish, and either add it somewhere in your include path, or reference it directly:With this, you can either execute it from within the directory you wish to add, or reference the directory as it\'s first and only parameter:Another option (in response to a comment by @GreenAsJade), if you want to track an empty folder that MAY contain tracked files in the future, but will be empty for now, you can ommit the * from the .gitignore file, and check that in.  Basically, all the file is saying is "do not ignore me", but otherwise, the directory is empty and tracked.Your .gitignore file would look like:That\'s it, check that in, and you have an empty, yet tracked, directory that you can track files in at some later time.The reason I suggest keeping that one line in the file is that it gives the .gitignore purpose. Otherwise, some one down the line may think to remove it.  It may help if you place a comment above the line.Sometimes you have to deal with bad written libraries or software, which need a "real" empty and existing directory. Putting a simple .gitignore or .keep might break them and cause a bug. The following might help in these cases, but no guarantee...First create the needed directory:Then you add a broken symbolic link to this directory (but on any other case than the described use case above, please use a README with an explanation):To ignore files in this directory, you can add it in your root .gitignore:To add the ignored file, use a parameter to force it:After the commit you have a broken symbolic link in your index and git creates the directory. The broken link has some advantages, since it is no regular file and points to no regular file. So it even fits to the part of the question "(that contains no files)", not by the intention but by the meaning, I guess:This commands shows an empty result, since no files are present in this directory. So most applications, which get all files in a directory usually do not see this link, at least if they do a "file exists" or a "is readable". Even some scripts will not find any files there:But I strongly recommend to use this solution only in special circumstances, a good written README in an empty directory is usually a better solution. (And I do not know if this works with a windows filesystem...)Sometimes I have repositories with folders that will only ever contain files considered to be "content"\xe2\x80\x94that is, they are not files that I care about being versioned, and therefore should never be committed. With Git\'s .gitignore file, you can ignore entire directories. But there are times when having the folder in the repo would be beneficial. Here\'s a excellent solution for accomplishing this need.What I\'ve done in the past is put a .gitignore file at the root of my repo, and then exclude the folder, like so:However, these folders then don\'t become part of the repo. You could add something like a README file in there. But then you have to tell your application not to worry about processing any README files.If your app depends on the folders being there (though empty), you can simply add a .gitignore file to the folder in question, and use it to accomplish two goals:Tell Git there\'s a file in the folder, which makes Git add it to the repo.\nTell Git to ignore the contents of this folder, minus this file itself.\nHere is the .gitignore file to put inside your empty directories:The first line (*) tells Git to ignore everything in this directory. The second line tells Git not to ignore the .gitignore file. You can stuff this file into every empty folder you want added to the repository.If you want to add a folder that will house a lot of transient data in multiple semantic directories, then one approach is to add something like this to your root .gitignore.../app/data/**/*.*\n!/app/data/**/*.mdThen you can commit descriptive README.md files (or blank files, doesn\'t matter, as long as you can target them uniquely like with the *.md in this case) in each directory to ensure that the directories all remain part of the repo but the files (with extensions) are kept ignored. LIMITATION: .\'s are not allowed in the directory names!You can fill up all of these directories with xml/images files or whatever and add more directories under /app/data/ over time as the storage needs for your app develop (with the README.md files serving to burn in a description of what each storage directory is for exactly).There is no need to further alter your .gitignore or decentralise by creating a new .gitignore for each new directory. Probably not the smartest solution but is terse gitignore-wise and always works for me. Nice and simple! ;)