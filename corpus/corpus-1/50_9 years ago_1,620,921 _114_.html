How do I discard changes in my working copy that are not in the index?Another quicker way is:After that, you can drop that stash with a git stash drop command if you like.For a specific file use:For all unstaged files use:Make sure to include the period at the end.It seems like the complete solution is:git clean removes all untracked files (warning: while it won\'t delete ignored files mentioned directly in .gitignore, it may delete ignored files residing in folders) and git checkout clears all unstaged changes.This checks out the current index for the current directory, throwing away all changes in files from the current directory downwards.or this which checks out all files from the index, overwriting working tree files.Cleans the working tree by recursively removing files that are not under version control, starting from the current directory.-d: Remove untracked directories in addition to untracked files-f: Force (might be not necessary depending on  clean.requireForce setting)Run git help clean to see the manualMy favorite isThat lets you selectively revert chunks.See also:I really found this article helpful for explaining when to use what command: http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/There are a couple different cases:If you haven\'t staged the file, then you use git checkout.  Checkout "updates files in the working tree to match the version in the index".  If the files have not been staged (aka added to the index)... this command will essentially revert the files to what your last commit was.  git checkout -- foo.txtIf you have staged the file, then use git reset.  Reset changes the index to match a commit.git reset -- foo.txt I suspect that using git stash is a popular choice since it\'s a little less dangerous.  You can always go back to it if you accidently blow too much away when using git reset.  Reset is recursive by default.Take a look at the article above for further advice.Since no answer suggests the exact option combination that I use, here it is:This is the online help text for the used git clean options:-dRemove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is not removed by default. Use -f option twice if you really want to remove such a directory.-fIf the Git configuration variable clean.requireForce is not set to false, git clean will refuse to delete files or directories unless given -f, -n or -i. Git will refuse to delete directories with .git sub directory or file unless a second -f is given.-xDon\xe2\x80\x99t use the standard ignore rules read from .gitignore (per directory) and $GIT_DIR/info/exclude, but do still use the ignore rules given with -e options. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with git reset) to create a pristine working directory to test a clean build.Also, git checkout . is done in the root of the repo.If you aren\'t interested in keeping the unstaged changes (especially if the staged changes are new files), I found this handy:git checkout -fman git-checkout:-f, --forceWhen switching branches, proceed even if the index or the working tree differs from HEAD. This is used to throw away local changes.When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.You can use git stash - if something goes wrong, you can still revert from the stash.\nSimilar to some other answer here, but this one also removes all unstaged files and also all unstaged deletes:if you check that everything is OK, throw the stash away:The answer from Bilal Maqsood with git clean also worked for me, but with the stash I have more control - if I do sth accidentally, I can still get my changes backUPDATEI think there is 1 more change (don\'t know why this worked for me before):git add . -A instead of git add .without the -A the removed files will not be stagedAs you type git status, \n(use "git checkout -- ..." to discard changes in working directory)\nis shown.e.g. git checkout -- .Instead of discarding changes, I reset my remote to the origin. Note - this method is to completely restore your folder to that of the repo. So I do this to make sure they don\'t sit there when I git reset (later - excludes gitignores on the Origin/branchname)NOTE: If you want to keep files not yet tracked, but not in GITIGNORE you may wish to skip this step, as it will Wipe these untracked files not found on your remote repository (thanks @XtrmJosh).Then I Then I reset to originThat will put it back to square one. Just like RE-Cloning the branch, WHILE keeping all my gitignored files locally and in place.Updated per user comment below:\nVariation to reset the to whatever current branch the user is on. Tried all the solutions above but still couldn\'t get rid of new, unstaged files.Use git clean -f to remove those new files - with caution though! Note the force option.Just use:Done. Easy.If you really care about your stash stack then you can follow with git stash drop. But at that point you\'re better off using (from Mariusz Nowak):Nonetheless, I like git stash -u the best because it "discards" all tracked and untracked changes in just one command. Yet git checkout -- . only discards tracked changes,\nand git clean -df only discards untracked changes... and typing both commands is far too much work :)simply sayIt will remove all your local changes. You also can use later by sayingor \n    git stash popThis works even in directories that are; outside of normal git permissions.Happened to me recentlyThe easiest way to do this is by using this command:Or:Another way to get rid of new files that is more specific than git clean -df (it will allow you to get rid of some files not necessarily all), is to add the new files to the index first, then stash, then drop the stash.This technique is useful when, for some reason, you can\'t easily delete all of the untracked files by some ordinary mechanism (like rm).In my opinion,should do the trick. As per Git documentation on git cleangit-clean - Remove untracked files from the working treeDescription Cleans the working tree by recursively removing files that\n  are not under version control, starting from the current directory.Normally, only files unknown to Git are removed, but if the -x option\n  is specified, ignored files are also removed. This can, for example,\n  be useful to remove all build products.If any optional ... arguments are given, only those paths are\n  affected.Options-d Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is\n  not removed by default. Use -f option twice if you really want to\n  remove such a directory.-f\n  --force If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to run unless given -f, -n or -i.What follows is really only a solution if you are working with a fork of a repository where you regularly synchronize (e.g. pull request) with another repo. Short answer: delete fork and refork, but read the warnings on github.I had a similar problem, perhaps not identical, and I\'m sad to say my solution is not ideal, but it is ultimately effective.I would often have git status messages like this (involving at least 2/4 files):A keen eye will note that these files have dopplegangers that are a single letter in case off. Somehow, and I have no idea what led me down this path to start with (as I was not working with these files myself from the upstream repo), I had switched these files. Try the many solutions listed on this page (and other pages) did not seem to help. I was able to fix the problem by deleting my forked repository and all local repositories, and reforking. This alone was not enough; upstream had to rename the files in question to new filenames. As long as you don\'t have any uncommited work, no wikis, and no issues that diverge from the upstream repository, you should be just fine. Upstream may not be very happy with you, to say the least. As for my problem, it is undoubtedly a user error as I\'m not that proficient with git, but the fact that it is far from easy to fix points to an issue with git as well. When you want to transfer a stash to someone else:[edit] as commented, it \xc3\xads possible to name stashes. Well, use this if you want to share your stash ;)If all the staged files were actually committed, then the branch can simply be reset e.g. from your GUI with about three mouse clicks: Branch, Reset, Yes!So what I often do in practice to revert unwanted local changes is to commit all the good stuff, and then reset the branch.If the good stuff is committed in a single commit, then you can use "amend last commit" to bring it back to being staged or unstaged if you\'d ultimately  like to commit it a little differently.This might not be the technical solution you are looking for to your problem, but I find it a very practical solution. It allows you to discard unstaged changes selectively, resetting the changes you don\'t like and keeping the ones you do.So in summary, I simply do commit, branch reset, and amend last commit.None of the solutions work if you just changed the permissions of a file (this is on DOS/Windoze)The only way to fix this is to manually reset the permissions on the changed files:If you are in case of submodule and no other solutions work try:To check what is the problem (maybe a "dirty" case) use:git diffTo remove stashgit submodule updateI had a weird situation where a file is always unstaged, this helps me to resolve.git rm .gitattributes\n  git add -A\n  git reset --hard You could create your own alias which describes how to do it in a descriptive way.I use the next alias to discard changes.Then you can use it as next to discard all changes:Or just a file:Otherwise, if you want to discard all changes and also the untracked files, I use a mix of checkout and clean:So the use is simple as next:Now is available in the next Github repo which contains a lot of aliases:Just use:This will stash unstaged changes and untracked files (new files) and keep staged files.It\'s better than reset/checkout/clean, because you might want them back later (by git stash pop). Keeping them in the stash is better than discarding them.If it\'s almost impossible to rule out modifications of the files, have you considered ignoring them? If this statement is right and you wouldn\'t touch those files during your development, this command may be useful: git update-index --assume-unchanged file_to_ignore