How can I see the changes un-stashing will make to the current working tree? I would like to know what changes will be made before applying them!See the most recent stash:See an arbitrary stash:From the git stash manpages:By default, the command shows the diffstat, but it will accept any\n  format known to git diff (e.g., git stash show -p stash@{1} to view\n  the second most recent stash in patch form).To see the most recent stash:To see an arbitrary stash:Also, I use git diff to compare the stash with any branch.You can use:To see all changes compared to branch master.\n\nOr You can use:To easy find only changed file names.If the branch that your stashed changes are based on has changed in the meantime, this command may be useful:This compares the stash against the commit it is based on.If your working tree is dirty, you can compare it to a stash by first committing the dirty working tree, and then comparing it to the stash. Afterwards, you may undo the commit with the dirty working tree (since you might not want to have that dirty commit in your commit log).You can also use the following approach to compare two stashes with each other (in which case you just pop one of the stashes at first).Commit your dirty working tree:Diff the stash with that commit:Then, afterwards, you may revert the commit, and put it back in the working dir:Now you\'ve diffed the dirty working tree with your stash, and are back to where you were initially. This works for me on git version 1.8.5.2:If you have tools for diff (like beyond compare)@Magne\'s answer is the only one to (very late) date that answers the most flexible/useful interpretation of the question, but its a fair bit more complicated than necessary.  Rather than committing and resetting, just stash your working copy, compare, then unstash.That show\'s you the differences between the top of the stash stack and your working folder by temporarily making your working folder changes the top of the stash stack (stash@{0}), moving the original top down one (stash@{1}) then comparing using the original top in the \'new set\' position so you see the changes that would result from applying it on top of your current work."But what if I don\'t have any current work?"  Then you are in the normal boring case.  Just use @Amber\'s answeror @czerasz\'s answeror admit that stashing and unstashing is fast and easy anyway, just unstash the changes and inspect them.  If you don\'t want them at the moment throw them (the current index/working folder changes) away.  In full that\'sFWIW\nThis may be a bit redundant to all the other answers and is very similar to the accepted answer which is spot on; but maybe it will help someone out. git stash show --help will give you all you should need; including stash show info.show [<stash>]Show the changes recorded in the stash as a diff between the stashed state and its original parent. When no  is given, shows the latest one. By default, the command shows the diffstat, but it will accept any format known to git diff (e.g., git stash show -p stash@{1} to view the second most recent stash in patch form). You can use stash.showStat and/or stash.showPatch config variables to change the default behavior.Combining what I learned in this thread and in this one, when I want to see "what is inside the stash", I first run:That will show what files were modified. Then, to get a nice visual diff in a difftool, I do:This will display all the differences at once of the given stash against its parent.You can configure the diff tool in ~/.gitconfig, e.g. with Meld: