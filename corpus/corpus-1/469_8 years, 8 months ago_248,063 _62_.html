Ran across this line of code:What do the two question marks mean, is it some kind of ternary operator?\nIt\'s hard to look up in Google.It\'s the null coalescing operator, and quite like the ternary (immediate-if) operator. See also ?? Operator - MSDN.expands to:which further expands to:In English, it means "If whatever is to the left is not null, use that, otherwise use what\'s to the right."Note that you can use any number of these in sequence. The following statement will assign the first non-null Answer# to Answer (if all Answers are null then the Answer is null):Also it\'s worth mentioning while the expansion above is conceptually equivalent, the result of each expression is only evaluated once. This is important if for example an expression is a method call with side effects. (Credit to @Joey for pointing this out.)Just because no-one else has said the magic words yet: it\'s the null coalescing operator. It\'s defined in section 7.12 of the C# 3.0 language specification.It\'s very handy, particularly because of the way it works when it\'s used multiple times in an expression. An expression of the form:will give the result of expression a if it\'s non-null, otherwise try b, otherwise try c, otherwise try d. It short-circuits at every point.Also, if the type of d is non-nullable, the type of the whole expression is non-nullable too.It\'s the null coalescing operator.http://msdn.microsoft.com/en-us/library/ms173224.aspxYes, nearly impossible to search for unless you know what it\'s called! :-)EDIT: And this is a cool feature from another question.  You can chain them.Hidden Features of C#?Thanks everybody, here is the most succinct explanation I found on the MSDN site:?? is there to provide a value for a nullable type when the value is null. So, if formsAuth  is null, it will return new FormsAuthenticationWrapper(). The two question marks (??) indicate that its a Coalescing operator.Coalescing operator returns the first NON-NULL value from a chain. You can see this youtube video which demonstrates the whole thing practically http://www.youtube.com/watch?v=YJGGmTNHPeo.But let me add more to what the video says.If you see the English meaning of coalescing it says \xe2\x80\x9cconsolidate together\xe2\x80\x9d.  For example below is a simple coalescing code which chains four strings.So if \xe2\x80\x9cstr1\xe2\x80\x9d is null it will try \xe2\x80\x9cstr2\xe2\x80\x9d  , if \xe2\x80\x9cstr2\xe2\x80\x9d is null it will try \xe2\x80\x9cstr3\xe2\x80\x9d and so on until it finds a string with a non-null value.In simple words Coalescing operator returns the first NON-NULL value from a chain. It\'s short hand for the ternary operator.  Or for those who don\'t do ternary:If you\'re familiar with Ruby, its ||= seems akin to C#\'s ?? to me.  Here\'s some Ruby:And in C#:For your amusement only (knowing you are all C# guys ;-).I think it originated in Smalltalk, where it has been around for many years. It is defined there as:in Object:in UndefinedObject (aka nil\'s class):There are both evaluating (?) and non-evaluating versions (??) of this. \nIt is often found in getter-methods for lazy-initialized private (instance) variables, which are left nil until really needed.Nothing dangerous about this. In fact, it is beautiful. \nYou can add default value if that is desirable, for example:CODEcoalescing operatorit\'s equivalent toSome of the examples here of getting values using coalescing are inefficient.What you really want is:orThis prevents the object from being recreated every time. Instead of the private variable remaining null and a new object getting created on every request, this ensures the private variable is assigned if the new object is created.As correctly pointed in numerous answers that is the "null coalescing operator" (??), speaking of which you might also want to check out its cousin the "Null-conditional Operator" (?. or ?[) that is an operator that many times it is used in conjunction with ??Null-conditional OperatorUsed to test for null before performing a member access (?.) or index (?[) operation. These operators help you write less code to handle null checks, especially for descending into data structures.For example: the old way without ?. and ?? of doing this iswhich is more verbose and cumbersome.I have read whole this thread and many others but I can\'t find as thorough answer as this is.By which I completely understood the "why to use ?? and when to use ?? and how to use ??."Windows communication foundation unleashed By Craig McMurtry\nISBN 0-672-32948-4There are two common circumstances in which one would like to know whether\na value has been assigned to an instance of a value type. The first is when the instance represents a value in a database. In such a case, one would like to be able to examine the instance to ascertain whether a value is indeed present in the database. The other circumstance, which is more pertinent to the subject matter of this book, is when the instance represents a data item received from some remote source. Again, one would like to determine from the instance whether a value for that data item was received.The .NET Framework 2.0 incorporates a generic type definition that provides for cases like these in which one wants to assign null to an instance of a value type, and test whether the value of the instance is null. That generic type definition is System.Nullable, which constrains the generic type arguments that may be substituted for T to value types.\nInstances of types constructed from System.Nullable can be assigned a value of null; indeed, their values are null by default. Thus, types constructed from\nSystem.Nullable may be referred to as nullable value types.\nSystem.Nullable has a property, Value, by which the value assigned to an instance of\na type constructed from it can be obtained if the value of the instance is not null.\nTherefore, one can write:The C# programming language provides an abbreviated syntax for declaring types\nconstructed from System.Nullable. That syntax allows one to abbreviate:toThe compiler will prevent one from attempting to assign the value of a nullable value type to an ordinary value type in this way:It prevents one from doing so because the nullable value type could have the value null, which it actually would have in this case, and that value cannot be assigned to an ordinary value type. Although the compiler would permit this code,The second statement would cause an exception to be thrown because any attempt to\naccess the System.Nullable.Value property is an invalid operation if the type\nconstructed from System.Nullable has not been assigned a valid value of T, which has not happened in this case.One proper way to assign the value of a nullable value type to an ordinary value type is to use the System.Nullable.HasValue property to ascertain whether a valid value of T has been assigned to the nullable value type:Another option is to use this syntax:By which the ordinary integer myInteger is assigned the value of the nullable integer "myNullableInteger" if the latter has been assigned a valid integer value; otherwise, myInteger is assigned the value of -1.