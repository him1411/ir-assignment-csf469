The command git add [--all|-A] appears to be identical to git add .. Is this correct? If not, how do they differ?Summary:git add -A stages Allgit add . stages new and modified, without deletedgit add -u stages modified and deleted, without newDetail:git add -A is equivalent to  git add .; git add -u.The important point about git add . is that it looks at the working tree and adds all those paths to the staged changes if they are either changed or are new and not ignored, it does not stage any \'rm\' actions.git add -u looks at all the already tracked files and stages the changes to those files if they are different or if they have been removed. It does not add any new files, it only stages changes to already tracked files.git add -A is a handy shortcut for doing both of those.You can test the differences out with something like this (note that for Git version 2.x your output for git add . git status will be different):Here is table for quick understanding:Git Version 1.x:\nGit Version 2.x:\nLong-form flags:Further reading:So from Charles instructions above, after testing my proposed understanding would be as follow:This link might also be helpfull to understand in what situation those commands may be applied: Removing Deleted Files from your Git Working Directory.With Git 2.0, git add -A is default: git add . equals git add -A ..  git add <path> is the same as "git add -A <path>" now, so that\n  "git add dir/" will notice paths you removed from the directory and\n  record the removal.\n  In older versions of Git, "git add <path>" used to ignore removals.  You can say "git add --ignore-removal <path>" to\n  add only added or modified paths in <path>, if you really want to.git add is like git add :/ (add everything from top git repo folder).\nNote that git 2.7 (Nov. 2015) will allow you to add a folder named ":"!\nSee commit 29abb33 (25 Oct 2015) by Junio C Hamano (gitster).  Note that starting git 2.0 (Q1 or Q2 2014), when talking about git add . (current path within the working tree), you must use \'.\' in the other git add commands as well.That means:"git add -A ." is equivalent to "git add .; git add -u ."(Note the extra \'.\' for git add -A and git add -u)Because git add -A or git add -u would operate (starting git 2.0 only) on the entire working tree, and not just on the current path.Those commands will operate on the entire tree in Git 2.0 for consistency with "git commit -a" and other commands.\n  Because there will be no mechanism to make "git add -u" behave as if "git add -u .", it is important for those who are used to "git add -u" (without pathspec) updating the index only for paths in the current subdirectory to start training their fingers to explicitly say "git add -u ." when they mean it before Git 2.0 comes.A warning is issued when these commands are run without a pathspec and when you have local changes outside the current directory, because the behaviour in Git 2.0 will be different\n  from today\'s version in such a situation.Late to the party but this question also deserves a more distilled quick answer. Does both below (same as git add --all)Stages new + modified filesStages modified + deleted filesThings changed with Git 2.0:So for git 2 the answer is:Finally I think I get this, many thanks to you all. I hope this may add some more clarity.Limiters may be -u or -A or nil. Pathspec may be a filepath or dot, \'.\' to indicate the current directory. Important background knowledge about how git \'adds\'.Now, given that knowledge, we can apply the answers above.The limiters are as follows.The pathspec is as follows.git add -A .git add -u .In conclusion, my policy is ; git add . equals git add -A . adds files to index only from current and children folders.git add -A adds files to index from all folders in working tree.P.S.: information relates to Git 2.0.