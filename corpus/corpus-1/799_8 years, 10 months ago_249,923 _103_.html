Given two date ranges, what is the simplest or most efficient way to determine whether the two date ranges overlap?As an example, suppose we have ranges denoted by DateTime variables StartDate1 to EndDate1 and StartDate2 to EndDate2.(StartA <= EndB)  and  (EndA >= StartB)Proof:\nLet ConditionA Mean that DateRange A Completely After DateRange B\n_                        |---- DateRange A ------| \n|---Date Range B -----|                           _\n  (True if StartA > EndB)   Let ConditionB Mean that DateRange A is Completely Before DateRange B\n|---- DateRange A -----|                       _ \n _                          |---Date Range B ----|\n (True if EndA < StartB)  Then Overlap exists if Neither A Nor B is true -\n (If one range is neither completely after the other,\n   nor completely before the other, \n     then they must overlap.)Now one of De Morgan\'s laws says that: Not (A Or B)  <=>  Not A And Not BWhich translates to: (StartA <= EndB)  and  (EndA >= StartB)NOTE: This includes conditions where the edges overlap exactly.  If you wish to exclude that,\nchange the >= operators to >, and <=  to < NOTE2. Thanks to @Baodad, see this blog, the actual overlap is least of:\n  { endA-startA, endA - startB, endB-startA, endB - startB }   (StartA <= EndB)  and  (EndA >= StartB)\n(StartA <= EndB)  and  (StartB <= EndA)NOTE3. Thanks to @tomosius, a shorter version reads:\nDateRangesOverlap = max(start1, start2) < min(end1, end2)\nThis is actually a syntactical shortcut for what is a longer implementation, which includes extra checks to verify that the start dates are on or before the endDates.  Deriving this from above: If start and end dates can be out of order, i.e., if it is possible that startA > endA or startB > endB, then you also have to check that they are in order, so that means you have to add two additional validity rules:\n(StartA <= EndB) and (StartB <= EndA) and (StartA <= EndA) and (StartB <= EndB)\nor:\n(StartA <= EndB) and (StartA <= EndA) and (StartB <= EndA) and (StartB <= EndB)\nor,\n(StartA <= Min(EndA, EndB) and (StartB <= Min(EndA, EndB))\nor:\n(Max(StartA, StartB) <= Min(EndA, EndB) But to implement Min() and Max(), you have to code, (using C ternary for terseness),:\n(StartA > StartB? Start A: StartB) <= (EndA < EndB? EndA: EndB) I believe that it is sufficient to say that the two ranges overlap if:This article Time Period Library for .NET describes the relation of two time periods by the enumeration PeriodRelation:For reasoning about temporal relations (or any other interval relations, come to that), consider Allen\'s Interval Algebra.  It describes the 13 possible relations that two intervals can have with respect to each other.  You can find other references \xe2\x80\x94 "Allen Interval" seems to be an operative search term.  You can also find information about these operations in Snodgrass\'s Developing Time-Oriented Applications in SQL (PDF available online at URL), and in Date, Darwen and Lorentzos Temporal Data and the Relational Model (2002) or  Time and Relational Theory: Temporal Databases in the Relational Model and SQL (2014; effectively the second edition of TD&RM).The short(ish) answer is: given two date intervals A and B with components .start and .end and the constraint .start <= .end, then two intervals overlap if:You can tune the use of >= vs > and <= vs < to meet your requirements for degree of overlap.ErikE comments:You can only get 13 if you count things funny... I can get "15 possible relations that two intervals can have" when I go crazy with it. By sensible counting, I get only six, and if you throw out caring whether A or B comes first, I get only three (no intersect, partially intersect, one wholly within other). 15 goes like this: [before:before, start, within, end, after], [start:start, within, end, after], [within:within, end, after], [end:end, after], [after:after]. I think that you cannot count the two entries \'before:before\' and \'after:after\'.  I could see 7 entries if you equate some relations with their inverses (see the diagram in the referenced Wikipedia URL; it has 7 entries, 6 of which have a different inverse, with equals not having a distinct inverse).  And whether three is sensible depends on your requirements.If the overlap itself should be calculated as well, you can use the following formula:All the solutions that check a multitude of conditions based on where the ranges are in relation to one another can be greatly simplified by just ensuring that a specific range starts earlier! You ensure that the first range starts earlier (or at the same time) by swapping the ranges if necessary up front.Then, you can detect overlap if the other range start is less than or equal to the first range end (if ranges are inclusive, containing both the start and end times) or less than (if ranges are inclusive of start and exclusive of end).Assuming inclusive at both ends, there\'s only four possibilities of which one is a non-overlap:The endpoint of the range 2 doesn\'t enter into it. So, in pseudo-code:This could be simplified even more into:If the ranges are inclusive at the start and exclusive at the end, you just have to replace > with >= in the second if statement (for the first code segment: in the second code segment, you\'d use < rather than <=):You greatly limit the number of checks you have to make because you remove half of the problem space early by ensuring range 1 never starts after range 2.Here is yet another solution using JavaScript. Specialities of my solution:The tests are based on integers but since date objects in JavaScript are comparable you can just throw in two date objects as well. Or you could throw in the millisecond timestamp.Result when run with karma&jasmine&PhantomJS:PhantomJS 1.9.8 (Linux): Executed 20 of 20 SUCCESS (0.003 secs / 0.004 secs)I know this has been tagged as language-agnostic, but for all of you implementing in Java: Don\'t reinvent the wheel and use Joda Time.http://joda-time.sourceforge.net/api-release/org/joda/time/base/AbstractInterval.html#overlaps(org.joda.time.ReadableInterval)I would do Where IsBetween is something like The solution posted here did not work for all overlapping ranges... my working solution was:This was my javascript solution with moment.js:In case you\'re using a date range that has not ended yet (still on going) e.g. not set \nendDate = \'0000-00-00\' you can not use BETWEEN because 0000-00-00 is not a valid date!I used this solution:If startdate2 is higher then enddate there is no overlap!the simplestThe simplest way is to use a well-engineered dedicated library for date-time work.The best in the business is the java.time framework built into Java 8 and later. Add to that the ThreeTen-Extra project that supplements java.time with additional classes, specifically the Interval class we need here.As for the language-agnostic tag on this Question, the source code for both projects is available for use in other languages (mind their licenses). The org.threeten.extra.Interval class is handy, but requires date-time moments (java.time.Instant objects) rather than date-only values. So we proceed by using the first moment of the day in UTC to represent the date.Create an Interval to represent that span of time.We can also define an Interval with a starting moment plus a Duration.Comparing to test for overlaps is easy.You can compare an Interval against another Interval or Instant:All of these use the Half-Open approach to defining a span of time where the beginning is inclusive and the ending is exclusive. Here is a generic method that can be usefull locally.In Microsoft SQL SERVER  - SQL Function   Using Java util.Date, here what I did.The easiest way to do it in my opinion would be to compare if either EndDate1 is before StartDate2 and EndDate2 is before StartDate1.That of course if you are considering intervals where StartDate is always before EndDate.Here\'s my solution in Java, which works on open intervals tooThe mathematical solution given by @Bretana is good but neglects two specific details:About the closed or open state of interval boundaries, the solution of @Bretana valid for closed intervals (StartA <= EndB)  and  (EndA >= StartB)can be rewritten for half-open intervals to:(StartA < EndB) and (EndA > StartB)This correction is necessary because an open interval boundary does not belong to the value range of an interval by definition.And about empty intervals, well, here the relationship shown above does NOT hold. Empty intervals which do not contain any valid value by definition must be handled as special case. I demonstrate it by my Java time library Time4J via this example:The leading square bracket "[" indicates a closed start while the last bracket ")" indicates an open end.As shown above, empty intervals violate the overlap condition above (especially startA < endB), so Time4J (and other libraries, too) has to handle it as special edge case in order to guarantee that the overlap of any arbitrary interval with an empty interval does not exist. Of course, date intervals (which are closed by default in Time4J but can be half-open, too, like empty date intervals) are handled in a similar way.This is an extension to the excellent answer by @charles-bretana.The answer however does not make a distinction among open, closed, and half-open (or half-closed) intervals.Case 1: A, B are closed intervalsOverlap iff: (StartA <= EndB)  and  (EndA >= StartB)Case 2: A, B are open intervalsOverlap iff: (StartA < EndB)  and  (EndA > StartB)Case 3: A, B right open Overlap condition: (StartA < EndB)  and  (EndA > StartB)Case 4: A, B left openOverlap condition: (StartA < EndB)  and  (EndA > StartB)Case 5: A right open, B closedOverlap condition: (StartA <= EndB)  and  (EndA > StartB)etc...Finally, the general condition for two intervals to overlap is (StartA <\xf0\x9f\x9e\x90 EndB)  and  (EndA >\xf0\x9f\x9e\x90 StartB)where \xf0\x9f\x9e\x90 turns a strict inequality into a non-strict one whenever the comparison is made between two included endpoint.Split the problem into cases then handle each case.The situation \'two date ranges intersect\' is covered by two cases - the first date range starts within the second, or the second date range starts within the first.You can try this:This was my solution, it returns true when the values don\'t overlap:X START 1\nY END 1A START 2\nB END 2For ruby I also found this:Found it here with nice explaination ->\nhttp://makandracards.com/makandra/984-test-if-two-date-ranges-overlap-in-ruby-or-railsBelow query gives me the ids  for which the supplied date range (start and end dates overlaps with any of the dates (start and end dates) in my table_nameThe answer is too simple for me so I have created a more generic dynamic SQL statement which checks to see if a person has any overlapping dates.I had a situation where we had dates instead of datetimes, and the dates could overlap only on start/end. Example below:(Green is the current interval, blue blocks are valid intervals, red ones are overlapping intervals).I adapted Ian Nelson\'s answer to the following solution:This matches all overlap cases but ignores the allowed overlap ones.Easy solution: