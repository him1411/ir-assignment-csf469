How can I squash my last X commits together into one commit using Git?Use git rebase -i <after-this-commit> and replace "pick" on the second and subsequent commits with "squash" or "fixup", as described in the manual.In this example, <after-this-commit> is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past the command is git rebase -i HEAD~5. You can do this fairly easily without git rebase or git merge --squash. In this example, we\'ll squash the last 3 commits.If you want to write the new commit message from scratch, this suffices:If you want to start editing the new commit message with a concatenation of the existing commit messages (i.e. similar to what a pick/squash/squash/\xe2\x80\xa6/squash git rebase -i instruction list would start you with), then you need to extract those messages and pass them to git commit:Both of those methods squash the last three commits into a single new commit in the same way. The soft reset just re-points HEAD to the last commit that you do not want to squash. Neither the index nor the working tree are touched by the soft reset, leaving the index in the desired state for your new commit (i.e. it already has all the changes from the commits that you are about to \xe2\x80\x9cthrow away\xe2\x80\x9d).You can use git merge --squash for this, which is slightly more elegant than git rebase -i.  Suppose you\'re on master and you want to squash the last 12 commits into one.  First check that git status is clean (since git reset --hard will throw away staged and unstaged changes) and then:The documentation for git merge describes the --squash option in more detail.Update: the only real advantage of this method over the simpler git reset --soft HEAD~12 && git commit suggested by Chris Johnsen in his answer is that you get the commit message prepopulated with every commit message that you\'re squashing.I recommend avoiding git reset when possible -- especially for Git-novices.  Unless you really need to automate a process based on a number of commits, there is a less exotic way...The commit message will be prepopulated based on the squash.Based on Chris Johnsen\'s answer,Add a global "squash" alias from bash: (or Git Bash on Windows)... or using Windows\' Command Prompt:\nYour ~/.gitconfig should now contain this alias:\nUsage:... Which automatically squashes together the last N commits, inclusive.Note: The resultant commit message is a combination of all the squashed commits, in order. If you are unhappy with that, you can always git commit --amend to modify it manually. (Or, edit the alias to match your tastes.)If you use TortoiseGit, you can the function Combine to one commit:This function automatically executes all necessary single git steps.\nUnfortunatly only available for Windows.Thanks to this handy blog post I found that you can use this command to squash the last 3 commits:This is handy as it works even when you are on a local branch with no tracking information/remote repo.The command will open the interactive rebase editor which then allows you to reorder, squash, reword, etc as per normal.Based on this article I found this method easier for my usecase.My \'dev\' branch was ahead of \'origin/dev\' by 96 commits (so these commits were not pushed to the remote yet).I wanted to squash these commits into one before pushing the change. I prefere to reset the branch to the state of \'origin/dev\' (this will leave all changes from the 96 commits unstaged) and then commit the changes at once:If you are on a remote branch(called feature-branch) cloned from a Golden Repository(golden_repo_name), then here\'s the technique to squash your commits into one:Checkout the golden repoCreate a new branch from it(golden repo) as followsSquash merge with your local branch that you have alreadyCommit your changes (this will be the only commit that goes in dev-branch)Push the branch to your local repositoryTo do this you can use following git command.n(=4 here) is the number of last commit. Then you got following options,Update like bellow,For details click on the LinkGood luck!!This is super-duper kludgy, but in a kind of cool way, so I\'ll just toss it into the ring:Translation: provide a new "editor" for git which, if the filename to be edited is git-rebase-todo (the interactive rebase prompt) changes all but the first "pick" to "squash", and otherwise spawns vim - so that when you\'re prompted to edit the squashed commit message, you get vim. (And obviously I was squashing the last five commits on branch foo, but you could change that however you like.)I\'d probably do what Mark Longair suggested, though.If you want to squish every commit into a single commit (e.g. when releasing a project publicly for the first time), try:I find a more generic solution is not to specify \'N\' commits, but rather the branch/commit-id you want to squash on top of.  This is less error-prone than counting the commits up to a specific commit\xe2\x80\x94just specify the tag directly, or if you really want to count you can specify HEAD~N.In my workflow, I start a branch, and my first commit on that branch summarizes the goal (i.e. it\'s usually what I will push as the \'final\' message for the feature to the public repository.)  So when I\'m done, all I want to do is git squash master back to the first message and then I\'m ready to push.I use the alias:This will dump the history being squashed before it does so\xe2\x80\x94this gives you a chance to recover by grabbing an old commit ID off the console if you want to revert.  (Solaris users note it uses the GNU sed -i option, Mac and Linux users should be fine with this.)Have a look at this gist:Gist - Easy git-squashYou\'ll have to type e.g. git-squash 3 and that\'s it. Last three commits merged into one with their messages concatenated.In question it could be ambiguous what is meant by "last". for example git log --graph outputs the following (simplified):Then last commits by time are H0, merge, B0. To squash them you will have to rebase your merged branch on commit H1.The problem is that H0 contains H1 and H2 (and generally more commits before merge and after branching) while B0 don\'t. So you have to manage changes from H0, merge, H1, H2, B0 at least.It\'s possible to use rebase but in different manner then in others mentioned answers:rebase -i HEAD~2This will show you choice options (as mentioned in other answers):Put squash instead of pick to H0:After save and exit rebase will apply commits in turn after H1. That means that it will ask you to resolve conflicts again (where HEAD will be H1 at first and then accumulating commits as they are applied).After rebase will finish you can choose message for squashed H0 and B0:P.S. If you just do some reset to BO: \n(for example, using reset --mixed that is explained in more detail here https://stackoverflow.com/a/18690845/2405850):then you squash into B0 changes of H0, H1, H2 (losing completely commits for changes after branching and before merge.If you\'re using GitUp, select the commit you want to merge with its parent and press S. You have to do it once for each commit, but it\'s much more straightforward than coming up with the correct command line incantation. Especially if it\'s something you only do once in a while.Just add this bash function to your bash of .zshrc file.Then just runAnd you\'re done.What can be really convenient:\nFind the commit hash you want to squash on top of; say it\'s d43e15\nNow usegit reset d43e15git commit -am \'new commit name\'Switch to the master branch and make sure you are up to date:sh\ngit checkout master && git fetch && git pull\nMerge your feature branch into the master branch locally:sh\ngit merge feature_branch\nReset the local master branch to origin\'s state:sh\ngit reset origin/master\nNow all of your changes are considered as unstaged changed. You can stage and commit them into one or more commits.sh\ngit add . --all\ngit commit\nThis command worked for me-\ngit rebase -i HEAD~<no. of commits you want to squash>also you would like to check a git log before squashing to get the actual no. of commits to be squashed!