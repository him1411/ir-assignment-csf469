I am relatively new to Java, and often find that I need to sort a Map<Key, Value> on the values. Since the values are not unique, I find myself converting the keySet into an array, and sorting that array through array sort with a custom comparator that sorts on the value associated with the key. Is there an easier way?Here\'s a generic-friendly version you\'re free to use:And an associated JUnit4 test so you don\'t have to take my word for it:Java 7 VersionJava 8 Version. This will sort according to the value in ascending order; for descending order, it is just possible to uncomment the call to Collections.reverseOrder().This code can break in multiple ways. If you intend to use the code provided, be sure to read the comments as well to be aware of the implications. For example, values can no longer be retrieved by their key. (get always returns null.)It seems much easier than all of the foregoing. Use a TreeMap as follows:Output:Three 1-line answers...I would use Google Collections Guava to do this - if your values are Comparable then you can useWhich will create a function (object) for the map [that takes any of the keys as input, returning the respective value], and then apply natural (comparable) ordering to them [the values].If they\'re not comparable, then you\'ll need to do something along the lines ofThese may be applied to a TreeMap (as Ordering extends Comparator), or a LinkedHashMap after some sortingNB: If you are going to use a TreeMap, remember that if a comparison == 0, then the item is already in the list (which will happen if you have multiple values that compare the same).  To alleviate this, you could add your key to the comparator like so (presuming that your keys and values are Comparable):= Apply natural ordering to the value mapped by the key, and compound that with the natural ordering of the keyNote that this will still not work if your keys compare to 0, but this should be sufficient for most comparable items (as hashCode, equals and compareTo are often in sync...)See Ordering.onResultOf() and Functions.forMap().So now that we\'ve got a comparator that does what we want, we need to get a result from it. Now this will most likely work work, but:Point 1 is a bit of a deal-breaker for me; google collections is incredibly lazy (which is good: you can do pretty much every operation in an instant; the real work is done when you start using the result), and this requires copying a whole map!Don\'t worry though; if you were obsessed enough with having a "live" map sorted in this manner, you could solve not one but both(!) of the above issues with something crazy like the following:Note: This has changed significantly in June 2012 - the previous code could never work: an internal HashMap is required to lookup the values without creating an infinite loop between the TreeMap.get() -> compare() and compare() -> get()When we put, we ensure that the hash map has the value for the comparator, and then put to the TreeSet for sorting. But before that we check the hash map to see that the key is not actually a duplicate. Also, the comparator that we create will also include the key so that duplicate values don\'t delete the non-duplicate keys (due to == comparison).\nThese 2 items are vital for ensuring the map contract is kept; if you think you don\'t want that, then you\'re almost at the point of reversing the map entirely (to Map<V,K>).The constructor would need to be called as From http://www.programmersheaven.com/download/49349/download.aspxJava 8 offers a new answer: convert the entries into a stream, and use the comparator combinators from Map.Entry:This will let you consume the entries sorted in ascending order of value.  If you want descending value, simply reverse the comparator:If the values are not comparable, you can pass an explicit comparator:You can then proceed to use other stream operations to consume the data. For example, if you want the top 10 in a new map:Or print to System.out:Sorting the keys requires the Comparator to look up each value for each comparison. A more scalable solution would use the entrySet directly, since then the value would be immediately available for each comparison (although I haven\'t backed this up by numbers).Here\'s a generic version of such a thing:There are ways to lessen memory rotation for the above solution. The first ArrayList created could for instance be re-used as a return value; this would require suppression of some generics warnings, but it might be worth it for re-usable library code. Also,  the Comparator does not have to be re-allocated at every invocation.Here\'s a more efficient albeit less appealing version:Finally, if you need to continously access the sorted information (rather than just sorting it once in a while), you can use an additional multi map. Let me know if you need more details...The commons-collections library contains a solution called TreeBidiMap. Or, you could have a look at the Google Collections API. It has TreeMultimap which you could use.And if you don\'t want to use these framework... they come with source code.I\'ve looked at the given answers, but a lot of them are more complicated than needed or remove map elements when several keys have same value.Here is a solution that I think fits better:Note that the map is sorted from the highest value to the lowest.With Java 8, you can use the streams api to do it in a significantly less verbose way:To accomplish this with the new features in Java 8:The entries are ordered by their values using the given comparator. Alternatively, if your values are mutually comparable, no explicit comparator is needed:The returned list is a snapshot of the given map at the time this method is called, so neither will reflect subsequent changes to the other. For a live iterable view of the map:The returned iterable creates a fresh snapshot of the given map each time it\'s iterated, so barring concurrent modification, it will always reflect the current state of the map.Create customized comparator and use it while creating new TreeMap object.Use the below code in your main funcOutput:While I agree that the constant need to sort a map is probably a smell, I think the following code is the easiest way to do it without using a different data structure.}And here is an embarrassingly incomplete unit test:}The result is a sorted list of Map.Entry objects, from which you can obtain the keys and values.Use a generic comparator such as :The answer voted for the most does not work when you have 2 items that equals.\nthe TreeMap leaves equal values out.the exmaple:\nunsorted mapresultsSo leaves out E!!For me it worked fine to adjust the comparator, if it equals do not return 0 but -1.in the example:class ValueComparator implements Comparator {Map base;\n      public ValueComparator(Map base) {\n          this.base = base;\n      }public int compare(Object a, Object b) {}\n    }now it returns:unsorted map:results:as a response to Aliens (2011 nov. 22):\nI Am using this solution for a map of Integer Id\'s and names, but the idea is the same, so might be the code above is not correct (I will write it in a test and give you the correct code), this is the code for a Map sorting, based on the solution above:and this is the test class (I just tested it, and this works for the Integer, String Map:here is the code for the Comparator of a Map:and this is the testcase for this:of cource you can make this a lot more generic, but I just needed it for 1 case (the Map)Instead of using Collections.sort as some do I\'d suggest using Arrays.sort. Actually what Collections.sort does is something like this:It just calls toArray on the list and then uses Arrays.sort. This way all the map entries will be copied three times: once from the map to the temporary list (be it a LinkedList or ArrayList), then to the temporary array and finally to the new map.My solution ommits this one step as it does not create unnecessary LinkedList. Here is the code, generic-friendly and performance-optimal:This is a variation of Anthony\'s answer, which doesn\'t work if there are duplicate values:Note that it\'s rather up in the air how to handle nulls. One important advantage of this approach is that it actually returns a Map, unlike some of the other solutions offered here.Major problem. If you use the first answer (Google takes you here), change the comparator to add an equal clause, otherwise you cannot get values from the sorted_map by keys:There are a lot of answers for this question already, but none provided me what I was looking for, a map implementation that returns keys and entries sorted by the associated value, and maintains this property as keys and values are modified in the map. Two other questions ask for this specifically. I cooked up a generic friendly example that solves this use case. This implementation does not honor all of the contracts of the Map interface, such as reflecting value changes and removals in the sets return from keySet() and entrySet() in the original object. I felt such a solution would be too large to include in a Stack Overflow answer. If I manage to create a more complete implementation, perhaps I will post it to Github and then to it link in an updated version of this answer.This is just too complicated. Maps were not supposed to do such job as sorting them by Value. The easiest way is to create your own Class so it fits your requirement.In example lower you are supposed to add TreeMap a comparator at place where * is. But by java API it gives comparator only keys, not values. All of examples stated here is based on 2 Maps. One Hash and one new Tree. Which is odd.The example:So change the map into a set this way:You will create class Results,and the Comparator class:This way you can easily add more dependencies.And as the last point I\'ll add simple iterator:Based on @devinmoore code, a map sorting methods using generics and supporting both ascending and descending ordering.Here is an OO solution (i.e., doesn\'t use static methods):Hereby donated to the public domain.Afaik the most cleaner way is utilizing collections to sort map on value:Since TreeMap<> does not work for values that can be equal, I used this:You might want to put list in a LinkedHashMap, but if you\'re only going to iterate over it right away, that\'s superfluous...Some simple changes in order to have a sorted map with pairs that have duplicate values. In the compare method (class ValueComparator) when values are equal do not return 0 but return the result of comparing the 2 keys. Keys are distinct in a map so you succeed to keep duplicate values (which are sorted by keys by the way). So the above example could be modified like this:For sure the solution of Stephen is really great, but for those who can\'t use Guava:Here\'s my solution for sorting by value a map.\nThis solution handle the case where there are twice the same value etc...The exec:\nhttp://www.ideone.com/dq3LuThe output:Hope it will help some folksI\'ve merged the solutions of user157196 and Carter Page:If you have duplicate keys and only a small set of data (<1000) and your code is not performance critical you can just do the following:inputUnsortedMap is the input to the code.The variable sortedOutputMap will contain the data in decending order when iterated over. To change order just change > to a < in the if statement.Is not the fastest sort but does the job without any additional dependencies.You can try Guava\'s multimaps:As a result you get a map from original values to collections of keys that correspond to them. This approach can be used even if there are multiple keys for the same value.Best ApproachOutputDepending on the context, using java.util.LinkedHashMap<T> which rememebers the order in which items are placed into the map.  Otherwise, if you need to sort values based on their natural ordering, I would recommend maintaining a separate List which can be sorted via Collections.sort().