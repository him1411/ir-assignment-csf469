When looking beyond the RAD (drag-drop and configure) way of building user interfaces that many tools encourage you are likely to come across three design patterns called Model-View-Controller, Model-View-Presenter and Model-View-ViewModel. My question has three parts to it:In MVP, the Presenter contains the UI business logic for the View. All invocations from the View delegate directly to Presenter. The Presenter is also decoupled directly from the View and talks to it through an interface. This is to allow mocking of the View in a unit test. One common attribute of MVP is that there has to be a lot of two-way dispatching. For example, when someone clicks the "Save" button, the event handler delegates to the Presenter\'s "OnSave" method. Once the save is completed, the Presenter will then call back the View through its interface so that the View can display that the save has completed. MVP tends to be a very natural pattern for achieving separated presentation in Web Forms. The reason is that the View is always created first by the ASP.NET runtime. You can find out more about both variants.Passive View: The View is as dumb as possible and contains almost zero logic. The Presenter is a middle man that talks to the View and the Model. The View and Model are completely shielded from one another. The Model may raise events, but the Presenter subscribes to them for updating the View. In Passive View there is no direct data binding, instead the View exposes setter properties which the Presenter uses to set the data. All state is managed in the Presenter and not the View.Supervising Controller: The Presenter handles user gestures. The View binds to the Model directly through data binding. In this case it\'s the Presenter\'s job to pass off the Model to the View so that it can bind to it. The Presenter will also contain logic for gestures like pressing a button, navigation, etc. In the MVC, the Controller is responsible for determining which View is displayed in response to any action including when the application loads. This differs from MVP where actions route through the View to the Presenter. In MVC, every action in the View correlates with a call to a Controller along with an action. In the web each action involves a call to a URL on the other side of which there is a Controller who responds. Once that Controller has completed its processing, it will return the correct View. The sequence continues in that manner throughout the life of the application:One other big difference about MVC is that the View does not directly bind to the Model. The view simply renders, and is completely stateless. In implementations of MVC the View usually will not have any logic in the code behind. This is contrary to MVP where it is absolutely necessary because, if the View does not delegate to the Presenter, it will never get called.One other pattern to look at is the Presentation Model pattern. In this pattern there is no Presenter. Instead the View binds directly to a Presentation Model. The Presentation Model is a Model crafted specifically for the View. This means this Model can expose properties that one would never put on a domain model as it would be a violation of separation-of-concerns. In this case, the Presentation Model binds to the domain model, and may subscribe to events coming from that Model. The View then subscribes to events coming from the Presentation Model and updates itself accordingly. The Presentation Model can expose commands which the view uses for invoking actions. The advantage of this approach is that you can essentially remove the code-behind altogether as the PM completely encapsulates all of the behaviour for the view. This pattern is a very strong candidate for use in WPF applications and is also called Model-View-ViewModel.There is a MSDN article about the Presentation Model and a section in the Composite Application Guidance for WPF (former Prism) about Separated Presentation PatternsI blogged about this a while back, quoting on Todd Snyder\'s excellent post on the difference between the two:Here are the key differences between\n  the patterns:MVP PatternMVC PatternIt is the best explanation on the web I could find.This is an oversimplification of the many variants of these design patterns, but this is how I like to think about the differences between the two.MVCMVPHere are illustrations which represent communication flow \nMVP is not necessarily a scenario where the View is in charge (see Taligent\'s MVP for example).\nI find it unfortunate that people are still preaching this as a pattern (View in charge) as opposed to an anti-pattern as it contradicts "It\'s just a view" (Pragmatic Programmer). "It\'s just a view" states that the final view shown to the user is a secondary concern of the application. Microsoft\'s MVP pattern renders re-use of Views much more difficult and conveniently excuses Microsoft\'s designer from encouraging bad practice.To be perfectly frank, I think the underlying concerns of MVC hold true for any MVP implementation and the differences are almost entirely semantic. As long as you are following separation of concerns between the view (that displays the data), the controller (that initialises and controls user interaction) and the model (the underlying data and/or services)) then you are acheiving the benefits of MVC. If you are acheiving the benefits then who really cares whether your pattern is MVC, MVP or Supervising Controller? The only real pattern remains as MVC, the rest are just differing flavours of it.Consider this highly exciting article that comprehensively lists a number of these differing implementations. \nYou may note that they\'re all basically doing the same thing but slightly differently.I personally think MVP has only been recently re-introduced as a catchy term to either reduce arguments between semantic bigots who argue whether something is truly MVC or not or to justify Microsofts Rapid Application Development tools. Neither of these reasons in my books justify its existence as a separate design pattern.The view, in most cases, creates its presenter. The presenter will interact with the model and manipulate the view through an interface. The view will sometimes interact with the presenter, usually through some interface.  This comes down to implementation; do you want the view to call methods on the presenter or do you want the view to have events the presenter listens to? It boils down to this: The view knows about the presenter. The view delegates to the presenter.The controller is created or accessed based on some event/request. The controller then creates the appropriate view and interacts with the model to further configure the view. It boils down to: the controller creates and manages the view; the view is slave to the controller. The view does not know about the controller.MVC (Model View Controller)The input is directed at the Controller first, not the view. That input might be coming from a user interacting with a page, but it could also be from simply entering a specific url into a browser. In either case, its a Controller that is interfaced with to kick off some functionality.\nThere is a many-to-one relationship between the Controller and the View. That\xe2\x80\x99s because a single controller may select different views to be rendered based on the operation being executed.\nNote the one way arrow from Controller to View. This is because the View doesn\xe2\x80\x99t have any knowledge of or reference to the controller.\nThe Controller does pass back the Model, so there is knowledge between the View and the expected Model being passed into it, but not the Controller serving it up.MVP (Model View Presenter)The input begins with the View, not the Presenter.\nThere is a one-to-one mapping between the View and the associated Presenter.\nThe View holds a reference to the Presenter. The Presenter is also reacting to events being triggered from the View, so its aware of the View its associated with.\nThe Presenter updates the View based on the requested actions it performs on the Model, but the View is not Model aware.For more ReferenceMVC = Model-View-ControllerAlso worth remembering is that there are different types of MVPs as well. Fowler has broken the pattern into two - Passive View and Supervising Controller.When using Passive View, your View typically implement a fine-grained interface with properties mapping more or less directly to the underlaying UI widget. For instance, you might have a ICustomerView with properties like Name and Address.Your implementation might look something like this:Your Presenter class will talk to the model and "map" it to the view. This approach is called the "Passive View". The benefit is that the view is easy to test, and it is easier to move between UI platforms (Web, Windows/XAML, etc.). The disadvantage is that you can\'t leverage things like databinding (which is really powerful in frameworks like WPF and Silverlight).The second flavor of MVP is the Supervising Controller. In that case your View might have a property called Customer, which then again is databound to the UI widgets. You don\'t have to think about synchronizing and micro-manage the view, and the Supervising Controller can step in and help when needed, for instance with compled interaction logic.The third "flavor" of MVP (or someone would perhaps call it a separate pattern) is the Presentation Model (or sometimes referred to Model-View-ViewModel). Compared to the MVP you "merge" the M and the P into one class. You have your customer object which your UI widgets is data bound to, but you also have additional UI-spesific fields like "IsButtonEnabled", or "IsReadOnly", etc.I think the best resource I\'ve found to UI architecture is the series of blog posts done by Jeremy Miller over at The Build Your Own CAB Series Table of Contents. He covered all the flavors of MVP and showed C# code to implement them.I have also blogged about the Model-View-ViewModel pattern in the context of Silverlight over at YouCard Re-visited: Implementing the ViewModel pattern.I wrote an article a few years ago on the topic of interactive application architecture patterns which includes a detailed discussion of both the MVC pattern and MVP pattern variants.  You can find the article here.Both of these frameworks aim to seperate concerns - for instance, interaction with a data source (model), application logic (or turning this data into useful information) (Controller/Presenter) and display code (View).  In some cases the model can also be used to turn a data source into a higher level abstraction as well.  A good example of this is the MVC Storefront project.There is a discussion here regarding the differences between MVC vs MVP.The distinction made is that in an MVC application traditionally has the view and the controller interact with the model, but not with each other.MVP designs have the Presenter access the model and interact with the view.Having said that, ASP.NET MVC is by these definitions an MVP framework because the Controller accesses the Model to populate the View which is meant to have no logic (just  displays the variables provided by the Controller).To perhaps get an idea of the ASP.NET MVC distinction from MVP, check out this MIX presentation by Scott Hanselman.Both are patterns trying to separate presentation and business logic, decoupling business logic from UI aspectsArchitecturally, MVP is Page Controller based approach where MVC is Front Controller based approach. \nThat means that in MVP standard web form page life cycle is just enhanced by extracting the business logic from code behind. In other words, page is the one servicing http request. In other words, MVP IMHO is web form evolutionary type of enhancement.\nMVC on other hand changes completely the game because the request gets intercepted by controller class before page is loaded, the business logic is executed there and then at the end result of controller processing the data just dumped to the page ("view")\nIn that sense, MVC looks (at least to me) a lot to Supervising Controller flavor of MVP enhanced with routing engine Both of them enable TDD and have downsides and upsides. Decision on how to choose one of them IMHO should be based on how much time one invested in ASP NET web form type of web development. \nIf one would consider himself good in web forms, I would suggest MVP. \nIf one would feel not so comfortable in things such as page life cycle etc MVC could be a way to go here.Here\'s yet another blog post link giving a little bit more details on this topic http://blog.vuscode.com/malovicn/archive/2007/12/18/model-view-presenter-mvp-vs-model-view-controller-mvc.aspxI have used both MVP and MVC and although we as developers tend to focus on the technical differences of both patterns the point for MVP in IMHO is much more related to ease of adoption than anything else. If I\xe2\x80\x99m working in a team that already as a good background on web forms development style it\xe2\x80\x99s far easier to introduce MVP than MVC. I would say that MVP in this scenario is a quick win. My experience tells me that moving  a team from web forms to MVP and then from MVP to MVC is relatively easy; moving from web forms to MVC is more difficult.I leave here a link to a series of articles a friend of mine has published about MVP and MVC.http://www.qsoft.be/post/Building-the-MVP-StoreFront-Gutthrie-style.aspxSomething I don\'t get is why data binding has to reduce testability.  I mean, a view is effectively based off of what could be thought of as one or more database views, right?  There might be connections between rows in different views.  Alternatively, we can talk object-oriented instead of relational, but that actually doesn\'t change anything -- we still have one or more distinct data entities.If we view programming as data structures + algorithms, then wouldn\'t it be best to have the data structures made explicit as possible, and then develop algorithms that each depend on as small a piece of data as possible, with minimal coupling between the algorithms?I sense very Java-esque FactoryFactoryFactory thought patterns here -- we want to have multiple views, multiple models, multiple degrees of freedom all over the place.  It\'s almost like that is the driving force behind MVC and MVP and whatnot.  Now let me ask this: how often is the cost you pay for this (and there most definitely is a cost) worth it?I also see no discussion of how to efficiently manage state between HTTP requests.  Haven\'t we learned from the functional folks (and the voluminous mistakes made by imperative spaghetti) that state is evil and should be minimized (and when used, should be well understood)?I see a lot of usage of the terms MVC and MVP without much evidence that people think critically about them.  Clearly, the problem is "them", me, or both...You may find the answers on this question: "Implementing MVC with Windows Forms" helpful as they talk about the different options when implementing MVC and MVP.In android there is version of mvc which is mvp:\nWhat is MVP?The MVP pattern allows separate the presentation layer from the logic, so that everything about how the interface works is separated from how we represent it on screen. Ideally the MVP pattern would achieve that same logic might have completely different and interchangeable views.First thing to clarify is that MVP is not an architectural pattern, it\xe2\x80\x99s only responsible for the presentation layer . In any case it is always better to use it for your architecture that not using it at all.An example for mvp is https://github.com/antoniolg/androidmvpWhat is MVC?\nMVC architecture is one of the oldest patterns available for achieving the separation of concerns. MVC consists of three layers, viz, Model, View, and Controller.Classic MVC existed at a time when every control/gadget that existed in the screen was considered dumb and each control is paired with its own controller to manage the user interactions happening on them. So if 10 gadgets exist, then 10 controllers have to exist. In this scenario, every gadget is counted as a view. The advent of Windows GUI systems changed this picture. The Control-Controller relationship became obsolete. Controls gained the intelligence to respond to the actions initiated by the user. In the Windows world, view is a surface on which all the controls/gadgets exist, hence there is a need for only one controller. View can receive events and reach for controllers help to do further processing.Sample code for mvc in android  http://androidexample.com/Use_MVC_Pattern_To_Create_Very_Basic_Shopping_Cart__-_Android_Example/index.php?view=article_discription&aid=116&aaid=138Difference between both is available here http://www.codeproject.com/Articles/288928/Differences-between-MVC-and-MVP-for-BeginnersNow From my experience you must use MVP for android based project , because it enhanced version of MVC Model .My humble short view: MVP is for large scales, and MVC for tiny scales. With MVC, I sometime feel the V and the C may be seen a two sides of a single indivisible component rather directly bound to M, and one inevitably falls to this when going down\xe2\x80\x91to shorter scales, like UI controls and base widgets. At this level of granularity, MVP makes little sense. When one on the contrary go to larger scales, proper interface becomes more important, the same with unambiguous assignment of responsibilities, and here comes MVP.On the other hand, this scale rule of a thumb, may weight very little when the platform characteristics favours some kind of relations between the components, like with the web, where it seems to be easier to implement MVC, more than MVP.In MVP the view draws data from the presenter which draws and prepares/normalizes data from the model while in MVC the controller draws data from the model and set, by push in the view.In MVP you can have a single view working with multiple types of presenters and a single presenter working with different multiple views.MVP usually uses some sort of a binding framework, such as Microsoft WPF binding framework or various binding frameworks for HTML5 and Java. In those frameworks, the UI/HTML5/XAML, is aware of what property of the presenter each UI element displays, so when you bind a view to a presenter, the view looks for the properties and knows how to draw data from them and how to set them when a value is changed in the UI by the user.So, if for example, the model is a car, then the presenter is some sort of a car presenter, exposes the car properties (year, maker, seats, etc.) to the view. The view knows that the text field called \'car maker\' needs to display the presenter Maker property. You can then bind to the view many different types of presenter, all must have Maker property - it can be of a plane, train or what ever , the view doesn\'t care. The view draws data from the presenter - no matter which - as long as it implements an agreed interface.This binding framework, if you strip it down, it\'s actually the controller :-) And so, you can look on MVP as an evolution of MVC. MVC is great, but the problem is that usually its controller per view. Controller A knows how to set fields of View A. If now, you want View A to display data of model B, you need Controller A to know model B, or you need Controller A to receive an object with an interface - which is like MVP only without the bindings, or you need to rewrite the UI set code in Controller B.Conclusion - MVP and MVC are both decouple of UI patterns, but MVP usually uses a bindings framework which is MVC underneath. THUS MVP is at a higher architectural level than MVC and a wrapper pattern above of MVC.They each addresses different problems and can even be combined together to have something like belowThere is also a complete comparison of MVC, MVP and MVVM hereMVPMVP stands for Model - View- Presenter. This came to picture in early 2007 where Microsoft introduced Smart Client windows applications. Presenter is acting as a supervisory role in MVP which binding View events and business logics from models.View event binding will be implemented in Presenter from a view interface. View is the initiator for user inputs and then delegates the events to Presenter and presenter handles event bindings and get data from models.Pros:\n    View is having only  UI not any logics\n    High level of testability Cons:\n    Bit complex and more work when implementing event bindingsMVCMVC stands for Model-View-Controller. Controller is responsible for creating models and rendering views with binding models. Controller is the initiator and it decides which view to render. Pros:\n  Emphasis on Single Responsibility Principle\n  High level of testability Cons:\n  Sometimes too much workload for Controllers, if try to render multiple views in same controller. A lot of people does not know exactly what is the difference between the Controller and Presenter in MVC and MVP respectively.its a simple equation where MVC View = View and Presenter of MVPMVP Model = Controller and Model of MVCmore info refer to this http://includeblogh.blogspot.com.eg/2016/07/the-difference-and-relationship-between.htmlAnswers for android architecture may be little confusing without a perfect example. see this know how to write application in different pattern (mvp, mvc and mvmm)\nDefault Pattern MVC on AndroidIf you want a working example of Mvc, mvp,mvvm here is my github repository\nhttps://github.com/saksham24/Android-Firebase-Mvp-Mvc-Mvvm-chatcontaining application with same functionality but written all three android coding formats (Mvc, Mvp, Mvvm). Also the application is written in best coding standard as per oracle and google for java nd xmls.\n Also read this blog  by realm to better understand mvc, mvp and mvvm\nhttps://academy.realm.io/posts/eric-maxwell-mvc-mvp-and-mvvm-on-android/