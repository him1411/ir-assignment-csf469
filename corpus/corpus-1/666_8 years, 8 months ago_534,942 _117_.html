I have a list view with a couple of image buttons on each row. When you click the list row, it launches a new activity. I have had to build my own tabs because of an issue with the camera layout. The activity that gets launched for result is a map. If I click on my button to launch the image preview (load an image off the SD card) the application returns from the activity back to the listview activity to the result handler to relaunch my new activity which is nothing more than an image widget. The image preview on the list view is being done with the cursor and ListAdapter. This makes it pretty simple, but I am not sure how I can put a resized image (I.e. Smaller bit size not pixel as the src for the image button on the fly. So I just resized the image that came off the phone camera.The issue is that I get an out of memory error when it tries to go back and re-launch the 2nd activity.This would be preferable as I also need to make some changes to the properties of the widgets/elements in each row as I am unable to select a row with touch screen because of focus issue. (I can use roller ball.)As soon as I disabled the image on the list view it worked fine again.FYI: This is how I was doing it:Where R.id.imagefilename is a ButtonImage.Here is my LogCat:I also have a new error when displaying an image: The Android Training class, "Displaying Bitmaps Efficiently", offers some great information for understanding and dealing with the exception java.lang.OutOfMemoryError: bitmap size exceeds VM budget when loading Bitmaps.The BitmapFactory class provides several decoding methods (decodeByteArray(), decodeFile(), decodeResource(), etc.) for creating a Bitmap from various sources. Choose the most appropriate decode method based on your image data source. These methods attempt to allocate memory for the constructed bitmap and therefore can easily result in an OutOfMemory exception. Each type of decode method has additional signatures that let you specify decoding options via the BitmapFactory.Options class. Setting the inJustDecodeBounds property to true while decoding avoids memory allocation, returning null for the bitmap object but setting outWidth, outHeight and outMimeType. This technique allows you to read the dimensions and type of the image data prior to construction (and memory allocation) of the bitmap.To avoid java.lang.OutOfMemory exceptions, check the dimensions of a bitmap before decoding it, unless you absolutely trust the source to provide you with predictably sized image data that comfortably fits within the available memory.Now that the image dimensions are known, they can be used to decide if the full image should be loaded into memory or if a subsampled version should be loaded instead. Here are some factors to consider:For example, it\xe2\x80\x99s not worth loading a 1024x768 pixel image into memory if it will eventually be displayed in a 128x96 pixel thumbnail in an ImageView.To tell the decoder to subsample the image, loading a smaller version into memory, set inSampleSize to true in your BitmapFactory.Options object. For example, an image with resolution 2048x1536 that is decoded with an inSampleSize of 4 produces a bitmap of approximately 512x384. Loading this into memory uses 0.75MB rather than 12MB for the full image (assuming a bitmap configuration of ARGB_8888). Here\xe2\x80\x99s a method to calculate a sample size value that is a power of two based on a target width and height:Note: A power of two value is calculated because the decoder uses a\n  final value by rounding down to the nearest power of two, as per the\n  inSampleSize documentation.To use this method, first decode with inJustDecodeBounds set to true, pass the options through and then decode again using the new inSampleSize value and inJustDecodeBounds set to false:This method makes it easy to load a bitmap of arbitrarily large size into an ImageView that displays a 100x100 pixel thumbnail, as shown in the following example code:You can follow a similar process to decode bitmaps from other sources, by substituting the appropriate BitmapFactory.decode* method as needed.To fix the OutOfMemory error, you should do something like this:This inSampleSize option reduces memory consumption.Here\'s a complete method. First it reads image size without decoding the content itself. Then it finds the best inSampleSize value, it should be a power of 2, and finally the image is decoded.I\'ve made a small improvement to Fedor\'s code. It basically does the same, but without the (in my opinion) ugly while loop and it always results in a power of two. Kudos to Fedor for making the original solution, I was stuck until I found his, and then I was able to make this one :)I come from iOS experience and I was frustrated to discover an issue with something so basic as loading and showing an image. After all, everyone that is having this issue is trying to display reasonably sized images. Anyway, here are the two changes that fixed my problem (and made my app very responsive).1) Every time you do BitmapFactory.decodeXYZ(), make sure to pass in a BitmapFactory.Options with inPurgeable set to true (and preferably with inInputShareable also set to true).2) NEVER use Bitmap.createBitmap(width, height, Config.ARGB_8888). I mean NEVER! I\'ve never had that thing not raise memory error after few passes. No amount of recycle(), System.gc(), whatever helped. It always raised exception. The one other way that actually works is to have a dummy image in your drawables (or another Bitmap that you decoded using step 1 above), rescale that to whatever you want, then manipulate the resulting Bitmap (such as passing it on to a Canvas for more fun). So, what you should use instead is: Bitmap.createScaledBitmap(srcBitmap, width, height, false). If for whatever reason you MUST use the brute force create method, then at least pass Config.ARGB_4444. This is almost guaranteed to save you hours if not days. All that talk about scaling the image, etc. does not really work (unless you consider getting wrong size or degraded image a solution). It\'s a known bug, it\'s not because of large files. Since Android Caches the Drawables, it\'s going out of memory after using few images. But I\'ve found an alternate way for it, by skipping the android default cache system.Solution:\nMove the images to "assets" folder and use the following function to get BitmapDrawable:I had this same issue and solved it by avoiding the BitmapFactory.decodeStream or decodeFile functions and instead used BitmapFactory.decodeFileDescriptordecodeFileDescriptor looks like it calls different native methods than the decodeStream/decodeFile.Anyways, what worked was this (note that I added some options as some had above, but that\'s not what made the difference. What is critical is the call to BitmapFactory.decodeFileDescriptor instead of decodeStream or decodeFile):I think there is a problem with the native function used in decodeStream/decodeFile. I have confirmed that a different native method is called when using decodeFileDescriptor.  Also what I\'ve read is "that Images (Bitmaps) are not allocated in a standard Java way but via native calls; the allocations are done outside of the virtual heap, but are\ncounted against it!"I think best way to avoid the OutOfMemoryError is to face it and understand it.I made an app to intentionally cause OutOfMemoryError, and monitor memory usage.After I\'ve done a lot of experiments with this App, I\'ve got the following conclusions:I\'m gonna talk about SDK versions before Honey Comb first.Bitmap is stored in native heap, but it will get garbage collected automatically, calling recycle() is needless.If {VM heap size} + {allocated native heap memory} >= {VM heap size limit for the device}, and you are trying to create bitmap, OOM will be thrown.NOTICE: VM HEAP SIZE is counted rather than VM ALLOCATED MEMORY.VM Heap size will never shrink after grown, even if the allocated VM memory is shrinked. So you have to keep the peak VM memory as low as possible to keep VM Heap Size from growing too big to save available memory for Bitmaps.Manually call System.gc() is meaningless, the system will call it first before trying to grow the heap size.Native Heap Size will never shrink too, but it\'s not counted for OOM, so no need to worry about it.Then, let\'s talk about SDK Starts from Honey Comb.Bitmap is stored in VM heap, Native memory is not counted for OOM.The condition for OOM is much simpler: {VM heap size} >= {VM heap size limit for the device}. So you have more available memory to create bitmap with the same heap size limit,  OOM is less likely to be thrown.Here is some of my observations about Garbage Collection and Memory Leak.You can see it yourself in the App. If an Activity executed an AsyncTask that was still running after the Activity was destroyed, the Activity will not get garbage collected until the AsyncTask finish.This is because AsyncTask is an instance of an anonymous inner class, it holds a reference of the Activity.Calling AsyncTask.cancel(true) will not stop the execution if the task is blocked in an IO operation in background thread.Callbacks are anonymous inner classes too, so if a static instance in your project holds them and do not release them, memory would be leaked.If you scheduled a repeating or delayed task, for example a Timer, and you do not call cancel() and purge() in onPause(), memory would be leaked.I have seen a lot of questions about OOM exceptions and caching lately. The developer guide has a really good article on this, but some tends to fail on implementing it in a suitable way. Because of this I wrote an example application that demonstrates caching in an Android environment. This implementation has not yet gotten an OOM.Look at the end of this answer for a link to the source code.The images that are being downloaded are images (75x75) from Flickr. However, put whatever image urls you want to be processed, and the application will scale it down if it exceeds the maximum. In this application the urls are simply in a String array.The LruCache has a good way to deal with bitmaps. However, in this application I put an instance of an LruCache inside another cache class that I created in order to get the application more feasible.Cache.java\'s critical stuff (the loadBitmap() method is the most important):You shouldn\'t need to edit anything in the Cache.java file unless you want to implement disk caching.MainActivity.java\'s critical stuff:getView() gets called very often. It\'s normally not a good idea to download images there if we haven\'t implemented a check that ensure us that we won\'t start an infinite amount of threads per row. Cache.java checks whether the rowObject.mBitmapUrl already is in a task and if it is, it won\'t start another. Therefore, we are most likely not exceeding the work queue restriction from the AsyncTask pool.You can download the source code from https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip.I have tested this for a few weeks now, I haven\'t gotten a single OOM exception yet. I have tested this on the emulator, on my Nexus One and on my Nexus S. I have tested image urls that contain images that were in HD quality. The only bottleneck is that it takes more time to download.There is only one possible scenario where I can imagine that the OOM will appear, and that is if we download many, really big images, and before they get scaled and put into cache, will simultaneously take up more memory and cause an OOM. But that isn\'t even an ideal situation anyway and it most likely won\'t be possible to solve in a more feasible way.Report errors in the comments! :-)I did the following to take the image and resize it on the fly. Hope this helpsIt seems that this is a very long running problem, with a lot of differing explanations.  I took the advice of the two most common presented answers here, but neither one of these solved my problems of the VM claiming it couldn\'t afford the bytes to perform the decoding part of the process.  After some digging I learned that the real problem here is the decoding process taking away from the NATIVE heap.  See here: BitmapFactory OOM driving me nutsThat lead me to another discussion thread where I found a couple more solutions to this problem.  One is to callSystem.gc(); manually after your image is displayed.  But that actually makes your app use MORE memory, in an effort to reduce the native heap.  The better solution as of the release of 2.0 (Donut) is to use the BitmapFactory option "inPurgeable".  So I simply added o2.inPurgeable=true; just after o2.inSampleSize=scale;.More on that topic here: Is the limit of memory heap only 6M? Now, having said all of this, I am a complete dunce with Java and Android too.  So if you think this is a terrible way to solve this problem, you are probably right.  ;-)  But this has worked wonders for me, and I have found it impossible to run the VM out of heap cache now.  The only drawback I can find is that you are trashing your cached drawn image.  Which means if you go RIGHT back to that image, you are redrawing it each and every time.  In the case of how my application works, that is not really a problem.  Your mileage may vary.unfortunately if None of the Above works, then Add this to your Manifest file. Inside application tagI have a much more effective solution which does not need scaling of any sort. Simply decode your bitmap only once and then cache it in a map against its name. Then simply retrieve the bitmap against the name and set it in the ImageView. There is nothing more that needs to be done.This will work because the actual binary data of the decoded bitmap is not stored within the dalvik VM heap. It is stored externally. So every time you decode a bitmap, it allocates memory outside of VM heap which is never reclaimed by GCTo help you better appreciate this, imagine you have kept ur image in the drawable folder. You just get the image by doing a getResources().getDrwable(R.drawable.). This will NOT decode your image everytime but re-use an already decoded instance everytime you call it. So in essence it is cached.Now since your image is in a file somewhere (or may even be coming from an external server), it is YOUR responsibility to cache the decoded bitmap instance to be reused any where it is needed.Hope this helps.Use this bitmap.recycle(); This helps without any image quality issue.There are two issues here....This worked for me!I have resolved the same issue in the following manner.None of the answers above worked for me, but I did come up with a horribly ugly workaround that solved the problem. I added a very small, 1x1 pixel image to my project as a resource, and loaded it into my ImageView before calling into garbage collection. I think it might be that the ImageView was not releasing the Bitmap, so GC never picked it up. It\'s ugly, but it seems to be working for now.This works for me.and this is on C# monodroid.\nyou can easily change the path of the image. what important here is the options to be set.Great answers here, but I wanted a fully usable class to address this problem.. so I did one.Here is my BitmapHelper class that is OutOfMemoryError proof :-)I just ran into this issue a couple minutes ago. I solved it by doing a better job at managing my listview adapter. I thought it was an issue with the hundreds of 50x50px images I was using, turns out I was trying to inflate my custom view each time the row was being shown. Simply by testing to see if the row had been inflated I eliminated this error, and I am using hundreds of bitmaps. This is actually for a Spinner, but the base adapter works all the same for a ListView. This simple fix also greatly improved the performance of the adapter.  I\'ve spent the entire day testing these solutions and the only thing that worked for me is the above approaches for getting the image and manually calling the GC, which I know is not supposed to be necessary, but it is the only thing that worked when I put my app under heavy load testing switching between activities.  My app has a list of thumbnail images in a listview in (lets say activity A) and when you click on one of those images it takes you to another activity (lets say activity B) that shows a main image for that item.  When I would switch back and forth between the two activities, I would eventually get the OOM error and the app would force close.  When I would get half way down the listview it would crash.Now when I implement the following in activity B, I can go through the entire listview with no issue and keep going and going and going...and its plenty fast.This seems like the appropriate place to share my utility class for loading and processing images with the community, you are welcome to use it and modify it freely.In one of my application i need to take picture either from Camera/Gallery. If user click image from Camera(may be 2MP, 5MP or 8MP), image size varies from kBs to MBs. If image size is less(or up to 1-2MB) above code working fine but if i have image of size above 4MB or 5MB then OOM comes in frame :(then i have worked to solve this issue & finally i\'ve made the below improvement to Fedor\'s(All Credit to Fedor for making such a nice solution) code :)I hope this will help the buddies facing the same problem!for more please refer thisThis issue only happens in Android emulators. I also faced this issue in an emulator but when I checked in a device then it worked fine. So please check in a device. It may be run in device.This code will help to load large bitmap from drawable}My 2 cents: i solved my OOM errors with bitmaps by:a) scaling my images by a factor of 2b) using Picasso library in my custom Adapter for a ListView, with a one-call in getView like this: Picasso.with(context).load(R.id.myImage).into(R.id.myImageView);use these code for every image in select from SdCard or drewable to convert bitmap object.use your image path instend of ImageData_Path.get(img_pos).getPath() .All the solutions here require setting a IMAGE_MAX_SIZE. This limits devices with more powerful hardware and if the image size is too low it looks ugly on the HD screen.I came out with a solution that works with my Samsung Galaxy S3 and several other devices including less powerful ones, with better image quality when a more powerful device is used.The gist of it is to calculate the maximum memory allocated for the app on a particular device, then set the scale to be lowest possible without exceeding this memory. Here\'s the code:I set the maximum memory used by this bitmap to be 25% of maximum allocated memory, you may need to adjust this to your needs and make sure this bitmap is cleaned up and don\'t stay in memory when you\'ve finished using it. Typically I use this code to perform image rotation (source and destination bitmap) so my app needs to load 2 bitmaps in memory at the same time, and 25% gives me a good buffer without running out of memory when performing image rotation.Hope this helps someone out there..Such OutofMemoryException cannot be totally resolved by calling the System.gc() and so on .By referring to the Activity Life CycleThe Activity States are determined by the OS itself subject to the memory usage for each process and the priority of each process.You may consider the size and the resolution for each of the bitmap pictures used. I recommend to reduce the size ,resample to lower resolution , refer to the design of galleries (one small picture PNG , and one original picture.)Generally android device heap size is only 16MB (varies from device/OS see post Heap Sizes), if you are loading the images and it crosses the size of 16MB , it will throw out of memory exception, instead of using the Bitmap for , loading images from SD card or from resources or even from network try to using getImageUri , loading bitmap require more memory , or you can set bitmap to null if your work done with that bitmap.