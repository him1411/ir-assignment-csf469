In a Unix shell, if I want to combine stderr and stdout into the stdout stream for further manipulation, I can append the following on the end of my command:So, if I want to use "head" on the output from g++, I can do something like this:so I can see only the first few errors. I always have trouble remembering this, and I constantly have to go look it up, and it is mainly because I don\'t fully understand the syntax of this particular trick.  Can someone break this up and explain character by character what "2>&1"  means?File descriptor 1 is the standard output (stdout).\nFile descriptor 2 is the standard error (stderr).Here is one way to remember this construct (although it is not entirely accurate): at first, 2>1 may look like a good way to redirect stderr to stdout. However, it will actually be interpreted as "redirect stderr to a file named 1". & indicates that what follows is a file descriptor and not a filename. So the construct becomes: 2>&1...redirects stdout to afile.txt. This is the same as doing..To redirect stderr, you do..>& is the syntax to redirect a stream to another file descriptor - 0 is stdin. 1 is stdout. 2 is stderr.You can redirect stdout to stderr by doing....or vice versa:So, in short.. 2> redirects stderr to an (unspecified) file, appending &1 redirects stderr to stdoutSome syntax particularity about this may have important behaviours. There is some little samples about redirections, STDERR, STDOUT and arguments ordering.Symbole > mean redirection.Any case, the file would be created if they not exist. For testing this, we need a simple command which will send something on both outputs:(Expecting you don\'t have a directory named /tnt, of course ;). Well, we have it!!So lets see:The last command line dump STDERR to the console, it seem not to be the expected behaviour... But...If you want to make some post filtering about one ouput, the other or both:Notice that the last command line in this paragraph is exactly same as in previous paraghaph, where I wrote seem not to be the expected behaviour (so, this could even be an expected behaviour).Well there is a little tricks about redirections, for\ndoing different operation on both ouputs:Nota: &9 descriptor would occur spontaneously because of ) 9>&2.Addendum: nota! With new version of bash (>4.0) there is a new feature and more sexy syntax for doing this kind of things:And finaly for such a cascading output formatting:Addendum: nota! Same new syntax, in both ways:Where STDOUT go through a specific filter, STDERR to another and finally both outputs merged go through a third command filter.That\'s about overwritting:While set -o noclobber instruct bash to not overwrite any existing file, the >| syntax let you pass through this limitation:File is overwritted each time, well now:Pass through with >|:Unsetting this option and/or inquiring if already set.For redirecting both output from a given command, we see that a right syntax could be:for this special case, there is a shortcut syntax: &> ... or >&Nota: if 2>&1 exist, 1>&2 is a correct syntaxe too:you could Read The Fine Manual by hitting:in a bash console ;-)The numbers refer to the file descriptors (fd).  2>&1 redirects fd 2 to 1.  This works for any number of file descriptors if the program uses them.You can look at /usr/include/unistd.h if you forget them:That said I have written C tools that use non-standard file descriptors for custom logging so you don\'t see it unless you redirect it to a file or something.That construct sends the standard error stream (stderr) to the current location of standard output (stdout) - this currency issue appears to have been neglected by the other answers.You can redirect any output handle to another by using this method but it\'s most often used to channel stdout and stderr streams into a single stream for processing.Some examples are:Note that that last one will not direct stderr to outfile2 - it redirects it to what stdout was when the argument was encountered (outfile1) and then redirects stdout to outfile2.This allows some pretty sophisticated trickery.I found this brilliant post on redirection : All about redirectionsRedirect both standard output and standard error to a file$ command &>fileThis one-liner uses the &> operator to redirect both output streams - stdout and stderr - from command to file. This is bash\'s shortcut for quickly redirecting both streams to the same destination.Here is how the file descriptor table looks like after bash has redirected both streams:\nAs you can see both stdout and stderr now point to file. So anything written to stdout and stderr gets written to file.There are several ways to redirect both streams to the same destination. You can redirect each stream one after another:$ command >file 2>&1This is a much more common way to redirect both streams to a file. First stdout is redirected to file, and then stderr is duplicated to be the same as stdout. So both streams end up pointing to file.When bash sees several redirections it processes them from left to right. Let\'s go through the steps and see how that happens. Before running any commands bash\'s file descriptor table looks like this:Now bash processes the first redirection >file. We\'ve seen this before and it makes stdout point to file:Next bash sees the second redirection 2>&1. We haven\'t seen this redirection before. This one duplicates file descriptor 2 to be a copy of file descriptor 1 and we get:Both streams have been redirected to file.However be careful here! Writing:command >file 2>&1Is not the same as writing:$ command 2>&1 >fileThe order of redirects matters in bash! This command redirects only the standard output to the file. The stderr will still print to the terminal. To understand why that happens, let\'s go through the steps again. So before running the command the file descriptor table looks like this:Now bash processes redirections left to right. It first sees 2>&1 so it duplicates stderr to stdout. The file descriptor table becomes:Now bash sees the second redirect >file and it redirects stdout to file:Do you see what happens here? Stdout now points to file but the stderr still points to the terminal! Everything that gets written to stderr still gets printed out to the screen! So be very, very careful with the order of redirects!Also note that in bash, writing this:$ command &>fileIs exactly the same as:$ command >&fileTo answer your question: It takes any error output (normally sent to stderr) and writes it to standard output (stdout). This is helpful with, for example \'more\' when you need paging for all output. Some programs like printing usage information into stderr.To help you remember"2>&1" simply points everything sent to stderr, to stdout instead.I also recommend reading this post on error redirecting where this subject is covered in full detail.2 is the Console standard error.1 is the Console standard output.This is the standard Unix, Windows also follows the POSIX.\nE.g. when you runThe standard error is redirected to standard output, so you can see both outputs together.After execution, you can see all the output, including errors, in the debug.log.Then standard output goes to out.log, and standard error to err.log.I suggest you to try to understand these.From a programmer\'s point of view, it means precisely this:See the man page.Understanding that 2>&1 is a copy also explains why ...... is not the same as ...The first will send both streams to file, whereas the second will send errors to stdout, and ordinary output into file.2>&1 is a POSIX shell construct. Here is a breakdown, token by token:2: "Standard error" output file descriptor.>&: Duplicate an Output File Descriptor operator (a variant of Output Redirection operator >). Given [x]>&[y], the file descriptor denoted by x is made to be a copy of the output file descriptor y.1 "Standard output" output file descriptor.The expression 2>&1 copies file descriptor 1 to location 2, so any output written to 2 ("standard error") in the execution environment goes to the same file originally described by 1 ("standard output").Further explanation:File Descriptor: "A per-process unique, non-negative integer used to identify an open file for the purpose of file access."Standard output/error: Refer to the following note in the Redirection section of the shell documentation:Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening  characters allowed) to designate the file descriptor number.People, always remember paxdiablo\'s hint about the current location of the redirection target... It is important.My personal mnemonic for the 2>&1 operator is this:The same mnemonic works for the other frequently used redirection too, 1>&2:And always remember: you have to read chains of redirections \'from the end\', from right to left (not from left to right).This  is just  like paasing the error to the stdout or terminal .\ni.e . cmd is not a command \n$cmd 2>filename\ncat filename\ncommand not found The error  sent to the file like that \n2>&1\nerror sent to the terminalRedirection of input causes the file whose name\n  results from the expansion of    word to be opened for reading on file\n  descriptor n,  or  the  standard  input    (file descriptor 0) if n is\n  not specified.The general format for redirecting input is:Redirection  of  output causes the file whose\n  name results from the expansion    of word to be opened for writing on\n  file descriptor n, or the standard output    (file  descriptor 1) if n\n  is not specified.  If the file does not exist it is    created; if it\n  does exist it is truncated to zero size.The general format for redirecting output is:Moving File Descriptors    The redirection operatormoves the file descriptor digit to file descriptor n, or the \n  standard  input    (file  descriptor  0)  if  n  is  not specified. \n  digit is closed after being    duplicated to n.Similarly, the redirection operatormoves the file descriptor digit to file descriptor n, or the\n  standard  output    (file descriptor 1) if n is not specified.man bash\ntype /^REDIRECT to locate to the redirection section , learn more..a online version here:\nhttp://www.gnu.org/software/bash/manual/bashref.html#Redirectionslots of time, man was the powerful tool to learn linuxProvided that /foo does not exist on your system and /tmp does\xe2\x80\xa6will print the contents of /tmp and print an error message for /foowill send the contents of /tmp to /dev/null and print an error message for /foowill do exactly the same (note the 1)will print the contents of /tmp and send the error message to /dev/nullwill send both the listing as well as the error message to /dev/nullis shorthand0 for input, 1 for stdout and 2 for stderr.One Tip:\nsomecmd >1.txt 2>&1 is correct, while somecmd 2>&1 >1.txt is totally wrong with no effect!