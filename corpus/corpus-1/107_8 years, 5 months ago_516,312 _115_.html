ECMAScript 6 introduced the let statement. I\'ve heard it described as a "local" variable, but I\'m still not quite sure how it behaves differently than the var keyword.What are the differences? When should let be used over var?The difference is scoping. var is scoped to the nearest function block and let is scoped to the nearest enclosing block, which can be smaller than a function block. Both are global if outside any block.Also, variables declared with let are not accessible before they are declared in their enclosing block. As seen in the demo, this will throw a ReferenceError exception.Demo: They are very similar when used like this outside a function block.However, global variables defined with let will not be added as properties on the global window object like those defined with var.They are identical when used like this in a function block.Here is the difference. let is only visible in the for() loop and var is visible to the whole function.Assuming strict mode, var will let you re-declare the same variable in the same scope. On the other hand, let will not:let can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.DEMOCode above demonstrates a classic JavaScript closure problem. Reference to the i variable is being stored in the click handler closure, rather than the actual value of i.Every single click handler will refer to the same object because there\xe2\x80\x99s only one counter object which holds 6 so you get six on each click.General workaround is to wrap this in an anonymous function and pass i as argument. Such issues can also be avoided now by using let instead var as shown in code below.DEMO (Tested in Chrome and Firefox 50)Here\'s an explanation of the let keyword with some examples.let works very much like var. The main difference is that the scope of a var variable is the entire enclosing functionThis table on Wikipedia shows which browsers support Javascript 1.7.Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don\'t.The accepted answer is missing a point:To understand the difference, consider the following code:Here, we can see that our variable j is only known in the first for loop, but not before and after. Yet, our variable i is known in the entire function from the moment it is defined onward.Some people would argue that in the future we\'ll ONLY use let statements and that var statements will become obsolete. JavaScript guru Kyle Simpson wrote a very elaborate article on why that\'s not the case.Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it\'s safe to use the let statement. The answer to that question depends on your environment:If you\'re writing server-side JavaScript code (Node.js), you can safely use the let statement.If you\'re writing client-side JavaScript code and use a transpiler (like Traceur), you can safely use the let statement, however your code is likely to be anything but optimal with respect to performance.If you\'re writing client-side JavaScript code and don\'t use a transpiler, you need to consider browser support.Today, Feb 23 2016, these are some browsers that either don\'t support let or have only partial support:For an up-to-date overview of which browsers support the let statement at the time of your reading this answer, see this Can I Use page.Here is an example for the difference between the two (support just started for chrome):\nAs you can see the var j variable is still having a value outside of the for loop scope, but the let i variable is undefined outside of the for loop scope.There are some subtle differences -- let scoping behaves more like variable scoping does in more or less any other languages. e.g. It scopes to the enclosing block, They don\'t exist before they\'re declared, etc.However it\'s worth noting that let is only a part of newer Javascript implementations and has varying degrees of browser support.Variables declared using the let keyword are block-scoped, which means that they are available only in the block in which they were declared.At the top level, variables declared using let don\'t create properties on the global object.Inside a funciton (but outside a block), let has the same scope as var.Variables declared using let inside a block can\'t be accessed outside that block.Variables declared with let in loops can be referenced only inside that loop.If you use let instead of var in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.Because of the temporal dead zone, variables declared using let can\'t be accessed before they are declared. Attempting to do so throws an error.You can\'t declare the same variable multiple times using let. You also can\'t declare a variable using let with the same identifier as another variable which was declared using var.const is quite similar to let\xe2\x80\x94it\'s block-scoped and has TDZ. There are, however, two things which are different.Variable declared using const can\'t be re-assigned.Note that it doesn\'t mean that the value is immutable. Its properties still can be changed.If you want to have an immutable object, you should use Object.freeze().You always must specify a value when declaring a variable using const.Variable Not Hoistinglet will not hoist to the entire scope of the block they appear in. By contrast, var could hoist as below.Actually, Per @Bergi, Both var and let are hoisted.Garbage CollectionBlock scope of let is useful relates to closures and garbage collection to reclaim memory. Consider,The click handler callback does not need the hugeData variable at all. Theoretically, after process(..) runs, the huge data structure hugeData could be garbage collected. However, it\'s possible that some JS engine will still have to keep this huge structure, since the click function has a closure over the entire scope.However, the block scope can make this huge data structure to garbage collected.let loopslet in the loop can re-binds it to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,However, replace var with letBecause let create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are here.Here\'s an interesting example to add on to what others have already written. Suppose you want to make an array of functions, adderFunctions, where each function takes a single Number argument and returns the sum of the argument and the function\'s index in the array. Trying to generate adderFunctions with a loop using the var keyword causes problems:The process above doesn\'t generate the desired array of functions because i\'s scope extends beyond the for block. Now, try the same using the Harmony (ECMAScript 6) spec and the let keyword:This time, i\'s scope is limited to the for block and adderFunctions contains the desired function at each index.May the following two functions show the difference:let is interesting, because it allows us to do something like this:Which results in counting [0, 7].WhereasOnly counts [0, 1].The difference is in the scope of the variables declared with each.In practice, there are a number of useful consequences of the difference in scope:The restrictions imposed by let reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their reachability(helping with reclaiming unused memory).Consequently, let variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.var may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of var for exports may be supplanted if export migrates out of transpiler space and into the core language.1. No use outside nearest enclosing block:\nThis block of code will throw a reference error because the second use of x occurs outside of the block where it is declared with let:\nIn contrast, the same example with var works.2. No use before declaration:\nThis block of code will throw a ReferenceError before the code can be run because x is used before it is declared: In contrast, the same example with var parses and runs without throwing any exceptions.3. No redeclaration:\nThe following code demonstrates that a variable declared with let may not be redeclared later: 4. Globals not attached to window:\n5. Easy use with closures:\nVariables declared with var do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable i has at different points in time: Specifically, this outputs:In JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to setTimeout: ... the output remains unchanged as long as we stick with let.  In contrast, if we had used var i instead: ... the loop unexpectedly outputs "i is 5" five times:The main difference is the Scope difference, while let can be only available inside the scope it\'s declared, like in for loop, var can be access outside the loop for example. From the documentation in MDN (examples also from MDN):let allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope.Variables declared by let have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function:At the top level of programs and functions, let, unlike var, does not create a property on the global object. For example:When used inside a block, let limits the variable\'s scope to that block. Note the difference between var whose scope is inside the function where it is declared.Also don\'t forget it\'s ECMA6 feature, so it\'s not fully supported yet, so it\'s better always transpiles it to ECMA6 using Babel etc... for more info about visit babel websiteIt also appears that, at least in Visual Studio 2015, TypeScript 1.5, "var" allows multiple declarations of the same variable name in a block, and "let" doesn\'t.This won\'t generate a compile error:This will:If I read the specs right then let thankfully can also be leveraged to avoid self invoking functions used to simulate private only members - a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone\'s desire for semantics, so stop using it. /rantSee \'Emulating private interfaces\'Some hacks with let:1.2.3.Previously there were only two scopes in JavaScript, i.e. functional and global. With \'let\' keyword JavaScript has now introduced block-level variables.To have a complete understanding of the \'let\' keyword, \nES6: \xe2\x80\x98let\xe2\x80\x99 keyword to declare variable in JavaScript will help.Now I think there is better scoping of variables to a block of statements using let:I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.Hoisting is not supported using let.With this approach errors present in JavaScript are getting removed. Refer to ES6 In Depth: let and const to understand it better.ECMAScript 6 added one more keyword to declare variables other the "const" other than "let".The primary goal of introduction of "let" and "const" over "var" is to have block scoping instead of traditional lexical scoping.\nThis article explains very briefly difference between "var" and "let" and it also covers the discussion on "const".This article clearly defines the difference between var, let and constconst is a signal that the identifier won\xe2\x80\x99t be reassigned.let, is a signal that the variable may be reassigned, such as a\n  counter in a loop, or a value swap in an algorithm. It also signals\n  that the variable will be used only in the block it\xe2\x80\x99s defined in,\n  which is not always the entire containing function.var is now the weakest signal available when you define a variable\n  in JavaScript. The variable may or may not be reassigned, and the\n  variable may or may not be used for an entire function, or just for\n  the purpose of a block or loop.https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75#.esmkpbg9b