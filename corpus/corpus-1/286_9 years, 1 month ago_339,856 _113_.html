In the C and C++ programming languages, what is the difference between using angle brackets and using quotes in an include statement, as follows?The difference is in the location where the preprocessor searches for the included file. For #include "filename" the preprocessor searches in the same directory as the file containing the directive, and then like for #include <filename>. This method is normally used to include programmer-defined header files. For #include <filename> the preprocessor searches in an implementation dependent manner, normally in search directories pre-designated by the compiler/IDE. This method is normally used to include standard library header files.The only way to know is to read your implementation\'s documentation.In the C standard, section 6.10.2, paragraphs 2 to 4 state:A preprocessing directive of the formsearches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the < and > delimiters, and causes the replacement of that directive by the entire contents of the header. How the places are specified or the header identified is implementation-defined.A preprocessing directive of the formcauses the replacement of that directive by the entire contents of the source file identified by the specified sequence between the " delimiters. The named source file is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it readwith the identical contained sequence (including > characters, if any) from the original\n  directive.A preprocessing directive of the form(that does not match one of the two previous forms) is permitted. The preprocessing tokens after include in the directive are processed just as in normal text. (Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.) The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between a < and a > preprocessing token pair or a pair of " characters is combined into a single header name preprocessing token is implementation-defined.h-char: any member of the source character set except the new-line character and >q-char: any member of the source character set except the new-line character and "The sequence of characters between < and > uniquely refer to a header, which isn\'t necessarily a file. Implementations are pretty much free to use the character sequence as they wish. (Mostly, however, just treat it as a file name and do a search in the include path, as the other posts state.)If the #include "file" form is used, the implementation first looks for a file of the given name, if supported. If not (supported), or if the search fails, the implementation behaves as though the other (#include <file>) form was used.Also, a third form exists and is used when the #include directive doesn\'t match either of the forms above. In this form, some basic preprocessing (such as macro expansion) is done on the "operands" of the #include directive, and the result is expected to match one of the two other forms.Some good answers here make references to the C standard but forgot the POSIX standard, especially the specific behavior of the c99 (e.g. C compiler) command.According to The Open Group Base Specifications Issue 7,-I directoryChange the algorithm for searching for headers whose names are not absolute pathnames to look in the directory named by the directory pathname before looking in the usual places. Thus, headers whose names are enclosed in double-quotes ( "" ) shall be searched for first in the directory of the file with the #include line, then in directories named in -I options, and last in the usual places. For headers whose names are enclosed in angle brackets ( "<>" ), the header shall be searched for only in directories named in -I options and then in the usual places. Directories named in -I options shall be searched in the order specified. Implementations shall support at least ten instances of this option in a single c99 command invocation.So, in a POSIX compliant environment, with a POSIX compliant C compiler, #include "file.h" is likely going to search for ./file.h first, where . is the directory where is the file with the #include statement, while #include <file.h>, is likely going to search for /usr/include/file.h first, where /usr/include is your system defined usual places for headers (it\'s seems not defined by POSIX).It does:with . being either the directory of the file where the #include is contained in, and/or the current working directory of the compiler, and/or the default_include_pathsandIf ./ is in <default_include_paths>, then it doesn\'t make a difference.If mypath/myfile is in another include directory, the behavior is undefined.GCC Documentation says the following about the difference between the two :Both user and system header files are included using the preprocessing     directive \xe2\x80\x98#include\xe2\x80\x99. It has two variants:#include <file> This variant is used for system header files. It searches for a file named file in a standard list of system directories. You can prepend directories to this list with the -I option (see Invocation).  #include "file" This variant is used for header files of your own program. It searches for a file named file first in the directory containing the current file, then in the quote directories and then the same directories used for <file>. You can prepend directories to the list of quote directories with the -iquote option.\n    The argument of \xe2\x80\x98#include\xe2\x80\x99, whether delimited with quote marks or angle brackets, behaves like a string constant in that comments are not recognized, and macro names are not expanded. Thus, #include <x/*y> specifies inclusion of a system header file named x/*y.However, if backslashes occur within file, they are considered ordinary text characters, not escape characters. None of the character escape sequences appropriate to string constants in C are processed. Thus,#include "x\\n\\\\y"specifies a filename containing three backslashes. (Some systems interpret \xe2\x80\x98\\\xe2\x80\x99 as a pathname separator. All of these also interpret \xe2\x80\x98/\xe2\x80\x99 the same way. It is most portable to use only \xe2\x80\x98/\xe2\x80\x99.)It is an error if there is anything (other than comments) on the line after the file name.The <file> include tells the preprocessor to search in -I directories and in predefined directories first, then in the .c file\'s directory. The "file" include tells the preprocessor to search the source file\'s directory first, and then revert to -I and predefined. All destinations are searched anyway, only the order of search is different.The 2011 standard mostly discusses the include files in "16.2 Source file inclusion".2 A preprocessing directive of the form# include <h-char-sequence> new-linesearches a sequence of implementation-defined places for a header identified uniquely by the\n  specified sequence between the < and > delimiters, and causes the\n  replacement of that directive by the entire contents of the header.\n  How the places are specified or the header identified is\n  implementation-defined.3 A preprocessing directive of the form# include "q-char-sequence" new-linecauses the replacement of that directive by the entire contents of the source file identified by the\n  specified sequence between the " delimiters. The named source file is\n  searched for in an implementation-defined manner. If this search is\n  not supported, or if the search fails, the directive is reprocessed as\n  if it read# include <h-char-sequence> new-linewith the identical contained sequence (including > characters, if any) from the original directive.Note that "xxx" form degrades to <xxx> form if the file is not found. The rest is implementation-defined.By the standard - yes, they are different:A preprocessing directive of the formsearches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the < and > delimiters, and causes the replacement of that directive by the entire contents of the header. How the places are specified or the header identified is implementation-defined.A preprocessing directive of the formcauses the replacement of that directive by the entire contents of the source file identified by the specified sequence between the " delimiters. The named source file is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it readwith the identical contained sequence (including > characters, if any) from the original\n  directive.A preprocessing directive of the form(that does not match one of the two previous forms) is permitted. The preprocessing tokens after include in the directive are processed just as in normal text. (Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.) The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between a < and a > preprocessing token pair or a pair of " characters is combined into a single header name preprocessing token is implementation-defined.h-char: any member of the source character set except the new-line character and >q-char: any member of the source character set except the new-line character and "Note that the standard does not tell any relation between the implementation-defined manners. The first form searches in one implementation-defined way, and the other in a (possibly other) implementation-defined way. The standard also specifies that certain include files shall be present (for example, <stdio.h>).Formally you\'d have to read the manual for your compiler, however normally (by tradition) the #include "..." form searches the directory of the file in which the #include was found first, and then the directories that the #include <...> form searches (the include path, eg system headers).At least for GCC version <= 3.0, the angle-bracket form does not generate a dependency between the included file and the including one.So if you want to generate dependency rules (using the GCC -M option for exemple), you must use the quoted form for the files that should be included in the dependency tree.(See http://gcc.gnu.org/onlinedocs/cpp/Invocation.html )Thanks for the great answers, esp. Adam Stelmaszczyk and piCookie, and aib.  Like many programmers, I have used the informal convention of using the "myApp.hpp" form for application specific files, and the <libHeader.hpp> form for library and compiler system files, i.e. files specified in /I and the INCLUDE environment variable, for years thinking that was the standard.However, the C standard states that the search order is implementation specific, which can make portability complicated.  To make matters worse, we use jam, which automagically figures out where the include files are.  You can use relative or absolute paths for your include files. i.e.Older versions of MSVS required double backslashes (\\\\), but now that\'s not required. I don\'t know when it changed. Just use forward slashes for compatibility with \'nix (Windows will accept that).If you are really worried about it, use "./myHeader.h" for an include file in the same directory as the source code (my current, very large project has some duplicate include file names scattered about--really a configuration management problem).Here\'s the MSDN explanation copied here for your convenience).Quoted formThe preprocessor searches for include files in this order:Angle-bracket formThe preprocessor searches for include files in this order:For #include "" a compiler normally searches the folder of the file which contains that include and then the other folders. For #include <> the compiler does not search the current file\'s folder.An #include with angle brackets will search an "implementation-dependent list of places" (which is a very complicated way of saying "system headers") for the file to be included.An #include with quotes will just search for a file (and, "in an implementation-dependent manner", bleh). Which means, in normal English, it will try to apply the path/filename that you toss at it and will not prepend a system path or tamper with it otherwise.Also, if #include "" fails, it is re-read as #include <> by the standard.The gcc documentation has a (compiler specific) description which although being specific to gcc and not the standard, is a lot easier to understand than the attorney-style talk of the ISO standards.#include<> is for predefined header filesIf the header file is predefined then you would simply write the header file name in angular brackets, and it would look like this (assuming we have a predefined header file name iostream):#include <iostream>#include " " is for header files the programmer definesIf you (the programmer) wrote your own header file then you would write the header file name in quotes. So, suppose you wrote a header file called myfile.h, then this is an example of how you would use the include directive to include that file:#include "myfile.h"example:\nthe filename here is Seller.hIn the class implementation (ex. Seller.cpp, and in other files that will use the file Seller.h), the header defined by the user should now be included, as follows:Many of the answers here focus on the paths the compiler will search in order to find the file. While this is what most compilers do, a conforming compiler is allowed to be preprogrammed with the effects of the standard headers, and to treat, say, #include <list> as a switch, and it need not exist as a file at all.This is not purely hypothetical. There is at least one compiler that work that way. Using #include <xxx> only with standard headers is recommended.In C++, include a file in two ways:The first one is #include  which tells the preprocessor to look for the file in the predefined default location.\nThis location is often an INCLUDE environment variable that denotes the path to include files.And the second type is #include "filename" which tells the preprocessor to look for the file in the current directory first, then look for it in the predefined locations user have set up.The #include <filename> is used when a system file is being referred to. That is a header file that can be found at system default locations like /usr/include or /usr/local/include. For your own files that needs to be included in another program you have to use the #include "filename" syntax.The simple general rule is to use angled brackets to include header files that come with the compiler. Use double quotes to include any other header files. Most compilers do it this way.1.9 \xe2\x80\x94 Header files explains in more detail about pre-processor directives. If you are a novice programmer, that page should help you understand all that. I learned it from here, and I have been following it at work.is used when you want to use the header file of the C/C++ system or compiler libraries. These libraries can be stdio.h, string.h, math.h, etc.is used when you want to use your own custom header file which is in your project folder or somewhere else.For more information about preprocessors and header. Read C - Preprocessors.is used to include standard library files. So they will check in the locations where standard library headers are residing.will tell the compiler to include user defined header files. So the compiler will check for these header files in the current folder or -I defined folders#include includes source file, identified by filename, into the current source file at the line immediately after the directive.The first version of the directive searches only standard include\n  directories. The standard C++ library, as well as standard C library,\n  is implicitly included in standard include directories. The standard\n  include directories can be controlled by the user through compiler\n  options.The second version first searches the directory where the current file\n  resides and, only if the file is not found, searches the standard\n  include directories.In the case the file is not found, the program is ill-formed.I believe that headers included in double-quotes will be looked for the in same system paths as angle-bracketed includes if they are not found in the current directory.The order of search header files is different. <XXX.h> prefer to search the standard headers first while "XXX.h" searches the workspace\'s header files first.#include <filename>will find the corresponding file from the C++ library.\nit means if you have a file called hello.h in the C++ library folder, #include <hello.h> will load it.But,#include "filename"will find the file in the same directory where your source file is.In addition,#include "path_to_file/filename"will find the file in the directory which you typed in path_to_file.To include a predefined library header file , #include<filename> is used whereas to include user defined header file, #include "filename" is relevant.