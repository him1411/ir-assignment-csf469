A new branch from master is created, we call it test.There are several developers who either commit to master or create other branches and later merge into master.Let\'s say work on test is taking several days and you want to continuously keep test updated with commits inside master.I would do git pull origin master from test. Question 1: Is this the right approach?  Other developers could have easily worked on same files as I have worked btw.My work on test is done and I am ready to merge it back to master. Here are the two ways I can think of:A: B: I am not using --rebase because from my understanding, rebase will get the changes from master and stack mine on top of that hence it could overwrite changes other people made.Question 2: Which one of these two methods is right?  What is the difference there?The goal in all of this is to keep my test branch updated with the things happening in master and later I could merge them back into master hoping to keep the timeline as linear as possible.How I would do thisIf I have a local branch from a remote one, I don\'t feel comfortable with merging other branches than this one with the remote. Also I would not push my changes, until I\'m happy with what I want to push and also I wouldn\'t push things at all, that are only for me and my local repository. In your description it seems, that test is only for you? So no reason to publish it.git always tries to respect yours and others changes, and so will --rebase. I don\'t think I can explain it appropriately, so have a look at the Git book - Rebasing or git-ready: Intro into rebasing for a little description. It\'s a quite cool featureThis is a very practical question, but all the answers above are not practical.LikeThis approach has two issues:It\'s unsafe, because we don\'t know if there are any conflicts between test branch and master branch.It would "squeeze" all test commits into one merge commit on master; that is to say on master branch, we can\'t see the all change logs of test branch.So, when we suspect there would some conflicts, we can have following git operations:Test merge before commit, avoid a fast-forward commit by --no-ff,If conflict is encountered, we can run git status to check details about the conflicts and try to solve Once we solve the conflicts, or if there is no conflict, we commit and push themBut this way will lose the changes history logged in test branch, and it would make master branch to be hard for other developers to understand the history of the project.So the best method is we have to use rebase instead of merge (suppose, when in this time, we have solved the branch conflicts).Following is one simple sample, for advanced operations, please refer to http://git-scm.com/book/en/v2/Git-Branching-RebasingYep, when you have uppers done, all the Test branch\'s commits will be moved onto the head of Master branch. The major benefit of rebasing is that you get a linear and much cleaner project history.The only thing you need to avoid is: never use rebase on public branch, like master branch.like following operation:never do these operations.Details for https://www.atlassian.com/git/tutorials/merging-vs-rebasing/the-golden-rule-of-rebasingappendix:Neither a rebase nor a merge should overwrite anyone\'s changes (unless you choose to do so when resolving a conflict).The usual approach while developing isWhen you\'re ready to merge back into master,If you\'re worried about breaking something on the merge, git merge --abort is there for you.Using push and then pull as a means of merging is silly. I\'m also not sure why you\'re pushing test to origin.Besides KingCrunches answer, I suggest to useYou might have made many commits in the other branch, which should only be one commit in the master branch. To keep the commit history as clean as possible, you might want to squash all your commits from the test branch into one commit in the master branch (see also: Git: To squash or not to squash?). Then you can also rewrite the commit message to something very expressive. Something that is easy to read and understand, without digging into the code.edit: You might be interested inSo on GitHub, I end up doing the following for a feature branch mybranch:Get the latest from originFind the merge base hash:Now make sure only the first is pick, the rest is s:Next choose a very good commit message and push to GitHub. Make the pull request then.After the merge of the pull request, you can delete it locally:and on GitHubThis is the workflow that I use at my job with the team. The scenario is as you described. First, when I\'m done working on test I rebase with master to pull in whatever has been added to master during the time I\'ve been working on the test branch.git pull -r upstream masterThis will pull the changes to master since you forked the test branch and apply them, and then apply the changes you\'ve made to test "on top of" the current state of master. There may be conflicts here, if the other people have made changes to the same files that you\'ve edited in test. If there are, you will have to fix them manually, and commit. Once you\'ve done that, you\'ll be good to switch to the master branch and merge test in with no problems.After merging, if the file is changed, then when you merge it will through error of "Resolve Conflict"So then you need to first resolve all your conflicts then, you have to again commit all your changes and then pushThis is better do who has done changes in test branch, because he knew what changes he has done.That is simple, just follow these steps.Git Push origin masterThat\'s it.