Is it possible to have static methods in Python so I can call them without initializing a class, like:Yep, using the staticmethod decoratorNote that some code might use the old method of defining a static method, using staticmethod as a function rather than a decorator. This should only be used if you have to support ancient versions of Python (2.2 and 2.3)This is entirely identical to the first example (using @staticmethod), just not using the nice decorator syntaxFinally, use staticmethod() sparingly! There are very few situations where static-methods are necessary in Python, and I\'ve seen them used many times where a separate "top-level" function would have been clearer.The following is verbatim from the documentation::A static method does not receive an implicit first argument. To declare a static method, use this idiom:The @staticmethod form is a function decorator \xe2\x80\x93 see the description of function definitions in Function definitions for details.It can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class.Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see classmethod().For more information on static methods, consult the documentation on the standard type hierarchy in The standard type hierarchy.New in version 2.2.Changed in version 2.4: Function decorator syntax added.I think that Steven is actually right. To answer the original question, then, in order to set up a class method, simply assume that the first argument is not going to be a calling instance, and then make sure that you only call the method from the class.(Note that this answer refers to Python 3.x. In Python 2.x you\'ll get a TypeError for calling the method on the class itself.)For example:In this code, the "rollCall" method assumes that the first argument is not an instance (as it would be if it were called by an instance instead of a class). As long as "rollCall" is called from the class rather than an instance, the code will work fine. If we try to call "rollCall" from an instance, e.g.:however, it would cause an exception to be raised because it would send two arguments: itself and -1, and "rollCall" is only defined to accept one argument.Incidentally, rex.rollCall() would send the correct number of arguments, but would also cause an exception to be raised because now n would be representing a Dog instance (i.e., rex) when the function expects n to be numerical.This is where the decoration comes in:\nIf we precede the "rollCall" method withthen, by explicitly stating that the method is static, we can even call it from an instance. Now, would work. The insertion of @staticmethod before a method definition, then, stops an instance from sending itself as an argument.You can verify this by trying the following code with and without the @staticmethod line commented out.Yes, check out the staticmethod decorator:You don\'t really need to use the @staticmethod decorator. Just declaring a method (that doesn\'t expect the self parameter) and call it from the class. The decorator is only there in case you want to be able to call it from an instance as well (which was not what you wanted to do)Mostly, you just use functions though...Static methods in Python?Is it possible to have static methods in Python so I can call them\n  without initializing a class, like:Yes, static methods can be created like this (although it\'s a bit more Pythonic to use underscores instead of CamelCase for methods):The above uses the decorator syntax. This syntax is equivalent to This can be used just as you described:A builtin example of a static method is str.maketrans() in Python 3, which was a function in the string module in Python 2.Another option that can be used as you describe is the classmethod, the difference is that the classmethod gets the class as an implicit first argument, and if subclassed, then it gets the subclass as the implicit first argument.Note that cls is not a required name for the first argument, but most experienced Python coders will consider it badly done if you use anything else.These are typically used as alternative constructors. A builtin example is dict.fromkeys():Aside from the particularities of how static method objects behave, there is a certain kind of beauty you can strike with them when it comes to organizing your module-level code..........It now becomes a bit more intuitive and self-documenting in which context certain components are meant to be used and it pans out ideally for naming distinct test cases as well as having a straightforward approach to how test modules map to actual modules under tests for purists.I frequently find it viable to apply this approach to organizing a project\'s utility code. Quite often, people immediately rush and create a utils package and end up with 9 modules of which one has 120 LOC and the rest are two dozen LOC at best. I prefer to start with this and convert it to a package and create modules only for the beasts that truly deserve them:Perhaps the simplest option is just to put those functions outside of the class:Using this method, functions which modify or use internal object state (have side effects) can be kept in the class, and the reusable utility functions can be moved outside.Let\'s say this file is called dogs.py. To use these, you\'d call dogs.barking_sound() instead of dogs.Dog.barking_sound.If you really need a static method to be part of the class, you can use the staticmethod decorator.