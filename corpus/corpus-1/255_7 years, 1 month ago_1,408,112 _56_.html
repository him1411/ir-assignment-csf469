This question already has an answer here:What is the most appropriate way to test if a variable is undefined in JavaScript? I\'ve seen several possible ways:OrOrIf you are interested in finding out whether a variable has been declared regardless of its value, then using the in operator is the safest way to go. Consider this example.But this may not be the intended result for some cases, since the variable or property was declared but just not initialized. Use the in operator for a more robust check.If you are interested in knowing whether the variable hasn\'t been declared or has the value undefined, then use the typeof operator.The typeof operator is guaranteed to return a string. Direct comparisons against undefined are troublesome as undefined can be overwritten. As @CMS pointed out, this has been patched in ECMAScript 5th ed., and undefined is non-writable.if (window.myVar) will also include these falsy values, so it\'s not very robust:Thanks to @CMS for pointing out that your third case - if (myVariable) can also throw an error in two cases. The first is when the variable hasn\'t been defined which throws a ReferenceError. The other case is when the variable has been defined, but has a getter function which throws an error when invoked. For example,I personally use Warning: Please note that === is used over == and that myVar has been previously declared (not defined).I do not like typeof myVar === "undefined". I think it is long winded and unnecessary. (I can get the same done in less code.)Now some people will keel over in pain when they read this, screaming: "Wait! WAAITTT!!! undefined can be redefined!"Cool. I know this. Then again, most variables in Javascript can be redefined. Should you never use any built-in identifier that can be redefined?If you follow this rule, good for you: you aren\'t a hypocrite.The thing is, in order to do lots of real work in JS, developers need to rely on redefinable identifiers to be what they are. I don\'t hear people telling me that I shouldn\'t use setTimeout because someone canBottom line, the "it can be redefined" argument to not use a raw === undefined is bogus. (If you are still scared of undefined being redefined, why are you blindly integrating untested library code into your code base? Or even simpler: a linting tool.)Also, like the typeof approach, this technique can "detect" undeclared variables: But both these techniques leak in their abstraction. I urge you not to use this or even Consider:To catch whether or not that variable is declared or not, you may need to resort to the in operator. (In many cases, you can simply read the code O_o).But wait! There\'s more! What if some prototype chain magic is happening\xe2\x80\xa6? Now even the superior in operator does not suffice. (Okay, I\'m done here about this part except to say that for 99% of the time, === undefined (and ****cough**** typeof) works just fine. If you really care, you can read about this subject on its own.)Using typeof is my preference. It will work when the variable has never been declared, unlike any comparison with the == or === operators or type coercion using if. (undefined, unlike null, may also be redefined in ECMAScript 3 environments, making it unreliable for comparison, although nearly all common environments now are compliant with ECMAScript 5 or above).You need to use typeof .If it is undefined, it will not be equal to a string that contains the characters "undefined", as the string is not undefined.You can check the type of the variable:Sometimes you don\'t even have to check the type. If the value of the variable can\'t evaluate to false when it\'s set (for example if it\'s a function), then you can just evalue the variable. Example:Note that strict comparison (!==) is not necessary in this case, since typeof will always return a string.Some scenarios illustrating the results of the various answers:\nhttp://jsfiddle.net/drzaus/UVjM4/(Note that the use of var for in tests make a difference when in a scoped wrapper)Code for reference:And results:In this article I read that frameworks like Underscore.js use this function:Personally, I always use the following:The window.undefined property is non-writable in all modern browsers (JavaScript 1.8.5 or later). From Mozilla\'s documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined, I see this: One reason to use typeof() is that it does not throw an error if the variable has not been defined.I prefer to have the approach of usingbecause it fails and blows up in my face rather than silently passing/failing if x has not been declared before. This alerts me that x is not declared. I believe all variables used in JavaScript should be declared.The most reliable way I know of checking for undefined is to use void 0.This is compatible with newer and older browsers, alike, and cannot be overwritten like window.undefined can in some cases.In Google Chrome, the following was ever so slightly faster than a typeof test:The difference was negligible.  However, this code is more concise, and clearer at a glance to someone who knows what void 0 means.  Note, however, that abc must still be declared.Both typeof and void were significantly faster than comparing directly against undefined.  I used the following test format in the Chrome developer console:The results were as follows:Note that the first row is in milliseconds, while the second row is in nanoseconds.  A difference of 3.4 nanoseconds is nothing.  The times were pretty consistent in subsequent tests.Since none of the other answers helped me, I suggest doing this. It worked for me in Internet Explorer 8:On the contrary of @Thomas Eding answer:If I forget to declare myVar in my code, then I\'ll get myVar is not defined.Let\'s take a real example:I\'ve a variable name, but I am not sure if it is declared somewhere or not.Then @Anurag\'s answer will help:I use it as a function parameter and exclude it on function execution that way I get the "real" undefined. Although it does require you to put your code inside a function. I found this while reading the jQuery source.Of course you could just use typeof though. But all my code is usually inside a containing function anyways, so using this method probably saves me a few bytes here and there.