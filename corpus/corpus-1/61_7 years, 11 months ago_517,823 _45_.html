I\'d like to move the last several commits I\'ve committed to master to a new branch and take master back to before those commits were made. Unfortunately, my Git-fu isn\'t strong enough yet, any help?I.e. How can I go from thisto this?Unless there are other circumstances involved, this can be easily done by branching and rolling back.But do make sure how many commits to go back. Alternatively, you can instead of HEAD~3, simply provide the hash of the commit (or the reference like origin/master) you want to "revert back to" on the master (/current) branch, e.g:*1 You will only be "losing" commits from the master branch, but don\'t worry, you\'ll have those commits in newbranch!WARNING: With Git version 2.0 and later, if you later git rebase the new branch upon the original (master) branch, you may need an explicit --no-fork-point option during the rebase to avoid losing the carried-over commits.  Having branch.autosetuprebase always set makes this more likely.  See John Mellor\'s answer for details.WARNING: The method above works because you are creating a new branch with the first command: git branch newbranch. If you want to use an existing branch you need to merge your changes into the existing branch before executing git reset --hard HEAD~3. If you don\'t merge your changes first, they will be lost. So, if you are working with an existing branch it will look like this:For those wondering why it works (as I was at first):You want to go back to C, and move D and E to the new branch.  Here\'s what it looks like at first:After git branch newBranch:After git reset --hard HEAD~2:Since a branch is just a pointer, master pointed to the last commit.  When you made newBranch, you simply made a new pointer to the last commit.  Then using git reset you moved the master pointer back two commits.  But since you didn\'t move newBranch, it still points to the commit it originally did.The method exposed by sykora is the best option in this case. But sometimes is not the easiest and it\'s not a general method. For a general method use git cherry-pick:To achieve what OP wants, its a 2-step process:ExecuteNote the hashes of (say 3) commits you want on newbranch. Here I shall use:\nC commit: 9aa1233\nD commit: 453ac3d\nE commit: 612ecb3 Note: You can use the first seven characters or\n  the whole commit hashgit cherry-pick applies those three commits to newbranch.Yet another way to do this, using just 2 commands. Also keeps your current working tree intact.Being able to push to . is a nice trick to know.Late Edit:\nNow that I know about git branch -f the right way to do it is:Which is the same, but less "magic"Do NOT do this:As the next time you run git rebase (or git pull --rebase) those 3 commits would be silently discarded from newbranch! (see explanation below)Instead do this:Warning: the reflog is enabled by default, but if you\'ve manually disabled it (e.g. by using a "bare" git repository), you won\'t be able to get the 3 commits back after running git reset --keep HEAD~3.An alternative that doesn\'t rely on the reflog is:(if you prefer you can write @{-1} - the previously checked out branch - instead of oldbranch).Why would git rebase discard the 3 commits after the first example? It\'s because git rebase with no arguments enables the --fork-point option by default, which uses the local reflog to try to be robust against the upstream branch being force-pushed.Suppose you branched off origin/master when it contained commits M1, M2, M3, then made three commits yourself:but then someone rewrites history by force-pushing origin/master to remove M2:Using your local reflog, git rebase can see that you forked from an earlier incarnation of the origin/master branch, and hence that the M2 and M3 commits are not really part of your topic branch. Hence it reasonably assumes that since M2 was removed from the upstream branch, you no longer want it in your topic branch either once the topic branch is rebased:This behavior makes sense, and is generally the right thing to do when rebasing.So the reason that the following commands fail:is because they leave the reflog in the wrong state. Git sees newbranch as having forked off the upstream branch at a revision that includes the 3 commits, then the reset --hard rewrites the upstream\'s history to remove the commits, and so next time you run git rebase it discards them like any other commit that has been removed from the upstream.But in this particular case we want those 3 commits to be considered as part of the topic branch. To achieve that, we need to fork off the upstream at the earlier revision that doesn\'t include the 3 commits. That\'s what my suggested solutions do, hence they both leave the reflog in the correct state.For more details, see the definition of --fork-point in the git rebase and git merge-base docs.This doesn\'t "move" them in the technical sense but it has the same effect:To do this without rewriting history (i.e. if you\'ve already pushed the commits):Both branches can then be pushed without force!Had just this situation:I performed:I expected that commit I would be the HEAD, but commit L is it now...To be sure to land on the right spot in the history its easier to work with the hash of the commit