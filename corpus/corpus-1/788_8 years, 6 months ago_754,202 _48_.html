I\'m using this code to get standard output from an external program:The communicate() method returns an array of bytes:However, I\'d like to work with the output as a normal Python string. So that I could print it like this:I thought that\'s what the binascii.b2a_qp() method is for, but when I tried it, I got the same byte array again:Does anybody know how to convert the bytes value back to string? I mean, using the "batteries" instead of doing it manually. And I\'d like it to be ok with Python 3.You need to decode the bytes object to produce a string:I think this way is easy:You need to decode the byte string and turn it in to a character (unicode) string. or If you don\'t know the encoding, then to read binary input into string in Python 3 and Python 2 compatible way, use ancient MS-DOS cp437 encoding:Because encoding is unknown, expect non-English symbols to translate to characters of cp437 (English chars are not translated, because they match in most single byte encodings and UTF-8).Decoding arbitrary binary input to UTF-8 is unsafe, because you may get this:The same applies to latin-1, which was popular (default?) for Python 2. See the missing points in Codepage Layout - it is where Python chokes with infamous ordinal not in range.UPDATE 20150604: There are rumors that Python 3 has surrogateescape error strategy for encoding stuff into binary data without data loss and crashes, but it needs conversion tests [binary] -> [str] -> [binary] to validate both performance and reliability.UPDATE 20170116: Thanks to comment by Nearoo - there is also a possibility to slash escape all unknown bytes with backslashreplace error handler. That works only for Python 3, so even with this workaround you will still get inconsistent output from different Python versions:See https://docs.python.org/3/howto/unicode.html#python-s-unicode-support for details.UPDATE 20170119: I decided to implement slash escaping decode that works for both Python 2 and Python 3. It should be slower that cp437 solution, but it should produce identical results on every Python version.I think what you actually want is this:Aaron\'s answer was correct, except that you need to know WHICH encoding to use. And I believe that Windows uses \'windows-1252\'. It will only matter if you have some unusual (non-ascii) characters in your content, but then it will make a difference.By the way, the fact that it DOES matter is the reason that Python moved to using two different types for binary and text data: it can\'t convert magically between them because it doesn\'t know the encoding unless you tell it! The only way YOU would know is to read the Windows documentation (or read it here).Set universal_newlines to True, i.e.In Python 3 you can use directly:which is equivalent tohere the default encoding is "utf-8", or you can check it by:While @Aaron Maenpaa\'s answer just works, a user recently askedIs there any more simply way? \'fhand.read().decode("ASCII")\' [...] It\'s so long!You can usedecode() has a standard argumentcodecs.decode(obj, encoding=\'utf-8\', errors=\'strict\')To interpret a byte sequence as a text, you have to know the\ncorresponding character encoding:Example:ls command may produce output that can\'t be interpreted as text. File names\non Unix may be any sequence of bytes except slash b\'/\' and zero\nb\'\\0\':Trying to decode such byte soup using utf-8 encoding raises UnicodeDecodeError.It can be worse. The decoding may fail silently and produce mojibake\nif you use a wrong incompatible encoding:The data is corrupted but your program remains unaware that a failure\nhas occurred.In general, what character encoding to use is not embedded in the byte sequence itself. You have to communicate this info out-of-band. Some outcomes are more likely than others and therefore chardet module exists that can guess the character encoding. A single Python script may use multiple character encodings in different places.ls output can be converted to a Python string using os.fsdecode()\nfunction that succeeds even for undecodable\nfilenames (it uses\nsys.getfilesystemencoding() and surrogateescape error handler on\nUnix):To get the original bytes, you could use os.fsencode().If you pass universal_newlines=True parameter then subprocess uses\nlocale.getpreferredencoding(False) to decode bytes e.g., it can be\ncp1252 on Windows.To decode the byte stream on-the-fly,\nio.TextIOWrapper()\ncould be used: example.Different commands may use different character encodings for their\noutput e.g., dir internal command (cmd) may use cp437. To decode its\noutput, you could pass the encoding explicitly (Python 3.6+):The filenames may differ from os.listdir() (which uses Windows\nUnicode API) e.g., \'\\xb6\' can be substituted with \'\\x14\'\xe2\x80\x94Python\'s\ncp437 codec maps b\'\\x14\' to control character U+0014 instead of\nU+00B6 (\xc2\xb6). To support filenames with arbitrary Unicode characters, see  Decode poweshell output possibly containing non-ascii unicode characters into a python stringFor Python 3,this is a much safer and Pythonic approach to convert from byte to string:Output:I made a function to clean a listI made a function to clean a listFrom http://docs.python.org/3/library/sys.html,To write or read binary data from/to the standard streams, use the underlying binary buffer. For example, to write bytes to stdout, use sys.stdout.buffer.write(b\'abc\').