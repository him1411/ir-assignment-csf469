How can I write two functions that would take a string and return if it starts with the specified character/string or ends with it?For example:Use this if you don\'t want to use a regex.It is possible to use strrpos and strpos to check start-with and ends-with respectively.Note that using strrpos to check starts with and strpos to check ends with will return as soon as possible instead of checking the whole string till the end. Also, this solution does not create a temporary string. Consider explaining the reason before downvoting. Just because a f-wit at the DWTF doesn\'t understand how this function works or thinks there is only one solution doesn\'t mean this answer is wrong.Tests and results (compare with this):Note: the strncmp and substr_compare functions will outperform this function.Updated 23-Aug-2016(Sorted fastest to slowest)(Sorted fastest to slowest)startswith_benchmark.phpAll answers so far seem to do loads of unnecessary work, strlen calculations, string allocations (substr), etc. The \'strpos\' and \'stripos\' functions return the index of the first occurrence of $needle in $haystack:Credit To:Check if a string ends with another stringCheck if a string begins with another stringThe regex functions above, but with the other tweaks also suggested above:I realize this has been finished, but you may want to look at strncmp as it allows you to put the length of the string to compare against, so:If speed is important for you, try this.(I believe it is the fastest method)Works only for strings and if $haystack is only 1 character Here are two functions that don\'t introduce a temporary string, which could be useful when needles are substantially big:You can use strpos and strrpos This question already has many answers, but in some cases you can settle for something simpler than all of them.\nIf the string you\'re looking for is known (hardcoded), you can use regular expressions without any quoting etc.Check if a string starts with \'ABC\':ends with \'ABC\':In my simple case, I wanted to check if a string ends with slash:The advantage: since it\'s very short and simple, you don\'t have to define a function (such as endsWith()) as shown above.But again -- this is not a solution for every case, just this very specific one.Short and easy-to-understand one-liners without regular expressions.startsWith() is straight forward.endsWith() uses the slightly fancy and slow strrev():Focusing on startswith, if you are sure strings are not empty, adding a test on the first char, before the comparison, the strlen, etc., speeds things up a bit:It is somehow (20%-30%) faster. Adding another char test, like $haystack{1}===$needle{1} does not seem to speedup things much, may even slow down.=== seems faster than ==\nConditional operator (a)?b:c seems faster than if(a) b; else c;For those asking "why not use strpos?" calling other solutions "unnecessary work"strpos is fast, but it is not the right tool for this job.To understand, here is a little simulation as an example:What the computer does "inside"?Assuming strlen does not iterate the whole string (but even in that case) this is not convenient at all.I hope that the below answer may be efficient and also simple:I usually end up going with a library like underscore-php these days. The library is full of other handy functions.The substr function can return false in many special cases, so here is my version, which deals with these issues:Tests (true means good):Also, the substr_compare function also worth looking.\nhttp://www.php.net/manual/en/function.substr-compare.phpin short:This may workSource: https://stackoverflow.com/a/4419658Why not the following?Output:Found value at the beginning of valuehaystack!Keep in mind, strpos will return false if the needle was not found in the haystack, and will return 0 if, and only if, needle was found at index 0 (AKA the beginning).And here\'s endsWith:In this scenario there is no need for a function startsWith() aswill return true or false accurately.It seems odd it\'s this simple with all the wild functions running rampant here.I would do it like this Based on James Black\'s answer, here is its endsWith version:Note: I have swapped the if-else part for James Black\'s startsWith function, because strncasecmp is actually the case-insensitive version of strncmp.You also can use regular expressions:Many of the previous answers will work just as well. However, this is possibly as short as you can make it and have it do what you desire. You just state that you\'d like it to \'return true\'. So I\'ve included solutions that returns boolean true/false and the textual true/false.Here\xe2\x80\x99s an efficient solution for PHP 4. You could get faster results if on PHP 5 by using substr_compare instead of strcasecmp(substr(...)).Just a recommendation:That extra line, comparing the first character of the strings, can make the\nfalse case return immediately, therefore making many of your comparisons\na lot faster (7x faster when I measured).  In the true case you pay virtually no price in performance for that single line so I think it\'s worth including.  (Also, in practice, when you test many strings for a specific starting chunk, most comparisons will fail since in a typical case you\'re looking for something.)The answer by mpen is incredibly thorough, but, unfortunately, the provided benchmark has a very important and detrimental oversight.Because every byte in needles and haystacks is completely random, the probability that a needle-haystack pair will differ on the very first byte is 99.609375%, which means that, on average, about 99609 of the 100000 pairs will differ on the very first byte. In other words, the benchmark is heavily biased towards startswith implementations which check the first byte explicitly, as strncmp_startswith2 does.If the test-generating loop is instead implemented as follows:the benchmark results tell a slightly different story:Of course, this benchmark may still not be perfectly unbiased, but it tests the efficiency of the algorithms when given partially matching needles as well.Let\'s keep it simpleNot sure why this is so difficult for people. Substr does a great job and is efficient as you don\'t need to search the whole string if it doesn\'t match.Additionally, since I\'m not checking integer values but comparing strings I don\'t have to necessarily have to worry about the strict === case. However, === is a good habit to get into.or even better optimized.