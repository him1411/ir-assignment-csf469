Consider the following scenario:I have developed a small experimental project A in its own Git repo. It has now matured, and I\'d like A to be part of larger project B, which has its own big repository. I\'d now like to add A as a subdirectory of B.How do I merge A into B, without losing history on any side?A single branch of another repository can be easily placed under a subdirectory retaining its history. For example:This will appear as a single commit where all files of Rails master branch are added into "rails" directory.\nHowever the commit\'s title contains a reference to the old history tree.Where <rev> is a SHA-1 commit hash. You can still see the history, blame some changes.Note that you can\'t see the directory prefix from here since this is an actual old branch left intact.\nYou should treat this like a usual file move commit: you will need an extra jump when reaching it.There are more complex solutions like doing this manually or rewriting the history as described in other answers.The git-subtree command is a part of official git-contrib, some packet managers install it by default (OS X Homebrew).\nBut you might have to install it by yourself in addition to git.If you want to merge project-a into project-b:Taken from: git merge different repositories?This method worked pretty well for me, it\'s shorter and in my opinion a lot cleaner.Note: The --allow-unrelated-histories parameter only exists since git >= 2.9.There are two possible solutions:Either copy repository A into separate directory in larger project B, or (perhaps better) clone repository A into subdirectory in project B.  Then use git submodule to make this repository a submodule of a repository B.This is a good solution for loosely-coupled repositories, where development in repository A continues, and major portion of development is separate stand-alone development in A.  See also SubmoduleSupport and GitSubmoduleTutorial pages on Git Wiki.You can merge repository A into a subdirectory of a project B using the subtree merge strategy. This is described in Subtree Merging and You by Markus Prinz.(option --allow-unrelated-histories is needed for git >= 2.9.0)Or you can use git subtree tool (repository on github) by apenwarr (Avery Pennarun), announced for example in his blog post A new alternative to git submodules: git subtree.I think in your case (A is to be part of larger project B) the correct solution would be to use subtree mergeThe submodule approach is good if you want to maintain the project separately. However, if you really want to merge both projects into the same repository, then you have a bit more work to do.The first thing would be to use git filter-branch to rewrite the names of everything in the second repository to be in the subdirectory where you would like them to end up. So instead of foo.c, bar.html, you would have projb/foo.c and projb/bar.html.Then, you should be able to do something like the following:The git pull will do a git fetch followed by a git merge. There should be no conflicts, if the repository you\'re pulling to does not yet have a projb/ directory.Further searching indicates that something similar was done to merge gitk into git. Junio C Hamano writes about it here: http://www.mail-archive.com/git@vger.kernel.org/msg03395.htmlgit-subtree is nice, but it is probably not the one you want.For example, if projectA is the directory created in B, after git subtree,lists only one commit: the merge. The commits from the merged project are for different paths, so they don\'t show up.Greg Hewgill\'s answer comes closest, although it doesn\'t actually say how to rewrite the paths.The solution is surprisingly simple.(1) In A,Note: This rewrites history, so if you intend to continue using this repo A, you may want to clone (copy) a throwaway copy of it first.(2) Then in B, runVoila! You have a projectA directory in B. If you run git log projectA, you will see all commits from A.In my case, I wanted two subdirectories, projectA and projectB. In that case, I did step (1) to B as well.If both repositories have same kind of files (like two Rails repositories for different projects), fetching the repository with git-fetchand then merging it to current repositoryWould let you have conflicts and \xe2\x80\x9cmanually\xe2\x80\x9d solve those for example with git-mergetool. kdiff3 can be used solely with keyboard, so 5 conflict file takes when reading the code just few minutes. Remember to finish the merge with git-commitAt this point, the remote repository has been merged to current repository and conflicts solved like you wanted.I kept losing history when using merge, so I ended up using rebase since in my case the two repositories are different enough not to end up merging at every commit:=> resolve conflicts, then continue, as many times as needed...Doing this leads to one project having all commits from projA followed by commits from projBIn my case, I had a my-plugin repository and a main-project repository, and I wanted to pretend that my-plugin had always been developed in the plugins subdirectory of main-project.Basically, I rewrote the history of the my-plugin repository so that it appeared all development took place in the plugins/my-plugin subdirectory. Then, I added the development history of my-plugin into the main-project history, and merged the two trees together. Since there was no plugins/my-plugin directory already present in the main-project repository, this was a trivial no-conflicts merge. The resulting repository contained all history from both original projects, and had two roots.First, create a copy of the my-plugin repository, because we\'re going to be rewriting the history of this repository.Now, navigate to the root of the my-plugin repository, check out your main branch (probably master), and run the following command. Of course, you should substitute for my-plugin and plugins whatever your actual names are.Now for an explanation. git filter-branch --tree-filter (...) HEAD runs the (...) command on every commit that is reachable from HEAD. Note that this operates directly on the data stored for each commit, so we don\'t have to worry about notions of "working directory", "index", "staging", and so on.If you run a filter-branch command that fails, it will leave behind some files in the .git directory and the next time you try filter-branch it will complain about this, unless you supply the -f option to filter-branch.As for the actual command, I didn\'t have much luck getting bash to do what I wanted, so instead I use zsh -c to make zsh execute a command. First I set the extended_glob option, which is what enables the ^(...) syntax in the mv command, as well as the glob_dots option, which allows me to select dotfiles (such as .gitignore) with a glob (^(...)).Next, I use the mkdir -p command to create both plugins and plugins/my-plugin at the same time.Finally, I use the zsh "negative glob" feature ^(.git|my-plugin) to match all files in the root directory of the repository except for .git and the newly created my-plugin folder. (Excluding .git might not be necessary here, but trying to move a directory into itself is an error.)In my repository, the initial commit did not include any files, so the mv command returned an error on the initial commit (since nothing was available to move). Therefore, I added a || true so that git filter-branch would not abort.The --all option tells filter-branch to rewrite the history for all branches in the repository, and the extra -- is necessary to tell git to interpret it as a part of the option list for branches to rewrite, instead of as an option to filter-branch itself.Now, navigate to your main-project repository and check out whatever branch you want to merge into. Add your local copy of the my-plugin repository (with its history modified) as a remote of main-project with:You will now have two unrelated trees in your commit history, which you can visualize nicely using:To merge them, use:Note that in pre-2.9.0 Git, the --allow-unrelated-histories option does not exist. If you are using one of these versions, just omit the option: the error message that --allow-unrelated-histories prevents was also added in 2.9.0.You should not have any merge conflicts. If you do, it probably means that either the filter-branch command did not work correctly or there was already a plugins/my-plugin directory in main-project.Make sure to enter an explanatory commit message for any future contributors wondering what hackery was going on to make a repository with two roots.You can visualize the new commit graph, which should have two root commits, using the above git log command. Note that only the master branch will be merged. This means that if you have important work on other my-plugin branches that you want to merge into the main-project tree, you should refrain from deleting the my-plugin remote until you have done these merges. If you don\'t, then the commits from those branches will still be in the main-project repository, but some will be unreachable and susceptible to eventual garbage collection. (Also, you will have to refer to them by SHA, because deleting a remote removes its remote-tracking branches.)Optionally, after you have merged everything you want to keep from my-plugin, you can remove the my-plugin remote using:You can now safely delete the copy of the my-plugin repository whose history you changed. In my case, I also added a deprecation notice to the real my-plugin repository after the merge was complete and pushed.Tested on Mac OS X El Capitan with git --version 2.9.0 and zsh --version 5.2. Your mileage may vary.References:I\'ve been trying to do the same thing for days, I am using git 2.7.2. Subtree does not preserve the history. You can use this method if you will not be using the old project again.I would suggest that you branch B first and work in the branch.Here are the steps without branching:If you now log any of the files in subdir A you will get the full historyThis was the post that help me do this:http://saintgimp.org/2013/01/22/merging-two-git-repositories-into-one-repository-without-losing-file-history/I know it\'s long after the fact, but I wasn\'t happy with the other answers I found here, so I wrote this:If you\'re trying to simply glue two repositories together, submodules and subtree merges are the wrong tool to use because they don\'t preserve all of the file history (as people have noted on other answers). See this answer here for the simple and correct way to do this.I had a similar challenge, but in my case, we had developed one version of the codebase in repo A, then cloned that into a new repo, repo B, for the new version of the product. After fixing some bugs in repo A, we needed to FI the changes into repo B. Ended up doing the following:Worked a treat :) I know this is rather late, but for anyone still looking for a way to do this, i have gathered a lot of information here on StackOverFlow etc., and have manage to put a script together which solves the problem for me.The caveat is that it only takes into account the \'develop\' branch of each repository and merges it into a separate directory in a completely new repository.Tags and other branches are ignored - this might not be what you want.The script even handles feature branches and tags - renaming them in the new project so you know where they came from.You can also get it from http://paste.ubuntu.com/11732805First create a file with the URL to each repository, e.g.: Then call the script giving a name of the project and the path to the script:The script itself has a lot of comments which should explain what it does.Similar to @Smar but uses file system paths, set in PRIMARY and SECONDARY:Then you manually merge.(adapted from post by Anar Manafov)When you want to merge three or more projects in a single commit, do the steps as described in the other answers (remote add -f, merge). Then, (soft) reset the index to old head (where no merge happened). Add all files (git add -A) and commit them (message "Merging projects A, B, C, and D into one project). This is now the commit-id of master.Now, create .git/info/grafts with following content:Run git filter-branch -- head^..head head^2..head head^3..head. If you have more than three branches, just add as much head^n..head as you have branches. To update tags, append --tag-name-filter cat. Do not always add that, because this might cause a rewrite of some commits. For details see man page of filter-branch, search for "grafts".Now, your last commit has the right parents associated.To merge a A within B:1) In the project A2) In the project BIn this branch do all operations you need to do and commit them.C) Then back to the master and a classical merge between the two branches:Given command is the best possible solution I suggest.This function will clone remote repo into local repo dir, after merging all commits will be saved, git log will be show the original commits and proper paths:How to use:If make a little changes you can even move files/dirs of merged repo into different paths, for example:Notices\nPaths replaces via sed, so make sure it moved in proper paths after merging.\nThe --allow-unrelated-histories parameter only exists since git >= 2.9.Merging 2 repos