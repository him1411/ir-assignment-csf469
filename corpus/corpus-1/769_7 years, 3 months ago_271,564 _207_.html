I have noticed that there doesn\'t appear to be a clear explanation of what the this keyword is and how it is correctly (and incorrectly) used in JavaScript on the Stack Overflow site.I have witnessed some very strange behaviour with it and have failed to understand why it has occurred.How does this work and when should it be used?I recommend reading Mike West\'s article Scope in JavaScript (mirror) first. It is an excellent, friendly introduction to the concepts of this and scope chains in JavaScript.Once you start getting used to this, the rules are actually pretty simple. The ECMAScript Standard defines this as a keyword that: evaluates to the value of the ThisBinding of the current execution\n  context;(\xc2\xa711.1.1). ThisBinding is something that the JavaScript interpreter maintains as it evaluates JavaScript code, like a special CPU register which holds a reference to an object. The interpreter updates the ThisBinding whenever establishing an execution context in one of only three different cases:Initial global execution contextThis is the case for JavaScript code that is evaluated when a <script> element is encountered:When evaluating code in the initial global execution context, ThisBinding is set to the global object, window (\xc2\xa710.4.1.1).Entering eval code... by a direct call to eval()ThisBinding is left unchanged; it is the same value as the ThisBinding of the calling execution context (\xc2\xa710.4.2(2)(a)).... if not by a direct call to eval()ThisBinding is set to the global object as if executing in the initial global execution context (\xc2\xa710.4.2(1)).\xc2\xa715.1.2.1.1 defines what a direct call to eval() is. Basically, eval(...) is a direct call whereas something like (0, eval)(...) or var indirectEval = eval; indirectEval(...); is an indirect call to eval(). See chuckj\'s answer to (1,eval)(\'this\') vs eval(\'this\') in JavaScript? and this blog post by Dmitry Soshnikov for when you might use an indirect eval() call.Entering function codeThis occurs when calling a function. If a function is called on an object, such as in obj.myMethod() or the equivalent obj["myMethod"](), then ThisBinding is set to the object (obj in the example; \xc2\xa713.2.1). In most other cases, ThisBinding is set to the global object (\xc2\xa710.4.3).The reason for writing "in most other cases" is because there are eight ECMAScript 5 built-in functions that allow ThisBinding to be specified in the arguments list. These special functions take a so-called thisArg which becomes the ThisBinding when calling the function (\xc2\xa710.4.3).These special built-in functions are:In the case of the Function.prototype functions, they are called on a function object, but rather than setting ThisBinding to the function object, ThisBinding is set to the thisArg.In the case of the Array.prototype functions, the given callbackfn is called in an execution context where ThisBinding is set to thisArg if supplied; otherwise, to the global object.Those are the rules for plain JavaScript. When you begin using JavaScript libraries (e.g. jQuery), you may find that certain library functions manipulate the value of this. The developers of those JavaScript libraries do this because it tends to support the most common use cases, and users of the library typically find this behavior to be more convenient. When passing callback functions referencing this to library functions, you should refer to the documentation for any guarantees about what the value of this is when the function is called.If you are wondering how a JavaScript library manipulates the value of this, the library is simply using one of the built-in JavaScript functions accepting a thisArg. You, too, can write your own function taking a callback function and thisArg:EDIT:I forgot a special case. When constructing a new object via the new operator, the JavaScript interpreter creates a new, empty object, sets some internal properties, and then calls the constructor function on the new object. Thus, when a function is called in a constructor context, the value of this is the new object that the interpreter created:QUIZ: Just for fun, test your understanding with the following examples.To reveal the answers, mouse over the light yellow boxes.What is the value of this at line A? Why? window\n\n Line A is evaluated in the initial global execution context.What is the value of this at line B when obj.staticFunction() is executed? Why? obj\n\n When calling a function on an object, ThisBinding is set to the object.What is the value of this at line C? Why? window\n\n In this example, the JavaScript interpreter enters function code, but because myFun/obj.myMethod is not called on an object, ThisBinding is set to window.\n\n This is different from Python, in which accessing a method (obj.myMethod) creates a bound method object.What is the value of this at line D? Why? window\n\n This one was tricky. When evaluating the eval code, this is obj. However, in the eval code, myFun is not called on an object, so ThisBinding is set to window for the call.What is the value of this at line E? obj\n\n The line myFun.call(obj); is invoking the special built-in function Function.prototype.call(), which accepts thisArg as the first argument.The this keyword behaves differently in JavaScript compared to other language. In Object Oriented languages, the this keyword refers to the current instance of the class. In JavaScript the value of this is determined mostly by the invocation context of function (context.function()) and where it is called.1. When used in global contextWhen you use this in global context, it is bound to global object (window in browser)When you use this inside a function defined in the global context, this is still bound to global object since the function is actually made a method of global context.Above f1 is made a method of global object. Thus we can also call it on window object as follows:2. When used inside object methodWhen you use this keyword inside an object method, this is bound to the "immediate" enclosing object.Above I have put the word immediate in double quotes. It is to make the point that if you nest the object inside another object, then this is bound to the immediate parent.Even if you add function explicitly to the object as a method, it still follows above rules, that is this still points to the immediate parent object.3. When invoking context-less functionWhen you use this inside function that is invoked without any context (i.e. not on any object), it is bound to the global object (window in browser)(even if the function is defined inside the object) .Trying it all with functionsWe can try above points with functions too. However there are some differences.Below I tried out all the things that we did with Object and this above, but by first creating function instead of directly writing an object.4. When used inside constructor function.When the function is used as a constructor (that is when it is called with new keyword), this inside function body points to the new object being constructed.5. When used inside function defined on prototype chainIf the method is on an object\'s prototype chain, this inside such method refers to the object the method was called on, as if the method is defined on the object.6. Inside call(), apply() and bind() functions7. this inside event handlersI recommend to better try this in JSFiddle."this" is all about scope. Every function has its own scope, and since everything in JS is an object, even a function can store some values into itself using "this". OOP 101 teaches that "this" is only applicable to instances of an object. Therefore, every-time a function executes, a new "instance" of that function has a new meaning of "this".Most people get confused when they try to use "this" inside of anonymous closure functions like:So here, inside each(), "this" doesn\'t hold the "value" that you expect it to (from Try it out; you\'ll begin to like this pattern of programmingConsider the following function:Note that we are running this in the normal mode, i.e. strict mode is not used.When run in a browser, the value of this would be logged as window. This is because window is the global variable in a web browser\'s scope.If you run this same piece of code in an environment like node.js, this would refer to the global variable in your app.Now if we run this in strict mode by adding the statement "use strict"; to the beginning of the function declaration, this would no longer refer to the global variable in either of the envirnoments. This is done to avoid confusions in the strict mode. this would, in this case just log undefined, because that is what it is, it is not defined.In the following cases, we would see how to manipulate the value of this.There are different ways to do this. If you have called native methods in Javascript like forEach and slice, you should already know that the this variable in that case refers to the Object on which you called that function (Note that in javascript, just about everything is an Object, including Arrays and Functions). Take the following code for example.If an Object contains a property which holds a Function, the property is called a method. This method, when called, will always have it\'s this variable set to the Object it is associated with. This is true for both strict and non-strict modes.Note that if a method is stored (or rather, copied) in another variable, the reference to this is no longer preserved in the new variable. For example:Considering a more commonly practical scenario:Consider a constructor function in Javascript:How does this work? Well, let\'s see what happens when we use the new keyword.Pretty straighforward, eh?Note that the official ECMAScript spec no where states that such types of functions are actual constructor functions. They are just normal functions, and new can be used on any function. It\'s just that we use them as such, and so we call them as such only.So yeah, since functions are also Objects (and in-fact first class variables in Javascript), even functions have methods which are... well, functions themselved.All functions inherit from the global Function, and two of its many methods are call and apply, and both can be used to manipulate the value of this in the function on which they are called.This is a typical example of using call. It basically takes the first parameter and sets this in the function foo as a reference to thisArg.  All other parameters passed to call are passed to the function foo as arguments.\nSo the above code will log {myObj: "is cool"}, [1, 2, 3] in the console. Pretty nice way to change the value of this in any function.apply is almost the same as call accept that it takes only two parameters: thisArg and an array which contains the arguments to be passed to the function. So the above call call can be translated to apply like this:Note that call and apply can override the value of this set by dot method invocation we discussed in the second bullet.\nSimple enough :)bind is a brother of call and apply.  It is also a method inherited by all functions from the global Function constructor in Javascript. The difference between bind and call/apply is that both call and apply will actually invoke the function. bind, on the other hand, returns a new function with the thisArg and arguments pre-set. Let\'s take an example to better understand this:See the difference between the three? It is subtle, but they are used differently. Like call and apply, bind will also over-ride the value of this set by dot-method invocation.Also note that neither of these three functions do any change to the original function. call and apply would return the value from freshly constructed functions while bind will return the freshly constructed function itself, ready to be called.Sometimes, you don\'t like the fact that this changes with scope, specially nested scope. Take a look at the following example.In the above code, we see that the value of this changed with nested scope, but we wanted the value of this from the original scope. So we \'copied\' this to that and used the copy instead of this. Clever, eh?Index:Since this thread has bumped up, I have compiled few points for readers new to this topic. We use this similar to the way we use pronouns in natural languages like English:  \xe2\x80\x9cJohn is running fast because he is trying to catch the train.\xe2\x80\x9d Instead we could have written \xe2\x80\x9c\xe2\x80\xa6 John is trying to catch the train\xe2\x80\x9d.  this is not assigned a value until an object invokes the function where it is defined. In the global scope, all global variables and functions are defined on the window object. Therefore, this in a global function refers to (and has the value of) the global window object. When use strict, this in global and in anonymous functions that are not bound to any object holds a value of undefined.The this keyword is most misunderstood when: 1) we borrow a method that uses this, 2) we assign a method that uses this to a variable, 3) a function that uses this is passed as a callback function, and 4) this is used inside a closure \xe2\x80\x94 an inner function. (2)Defined in ECMA Script 6, arrow-functions adopt the this binding from the\nenclosing (function or global) scope.While arrow-functions provide an alternative to using bind(), it\xe2\x80\x99s important to note that they essentially are disabling the traditional this mechanism in favor of more widely understood lexical scoping. (1)References:this in Javascript always refers to the \'owner\' of the function that is being executed.If no explicit owner is defined, then the top most owner, the window object, is referenced.So if I didelement.onclick = someKindOfFunction;this would refer to the element object. But be careful, a lot of people make this mistake<element onclick="someKindOfFunction()">In the latter case, you merely reference the function, not hand it over to the element. Therefor, this will refer to the window object.Every function execution context in javascript has a scope context this parameter that is set by:Whatever that scope context is, is referenced by "this".You can change that set the value of this scope context using func.call, func.apply or func.bind.By default, and what confuses most beginners, when a callback listener is called after an event is raised on a DOM element, the scope context this value of the function is the DOM element.jQuery makes this trivial to change with jQuery.proxy.Daniel, awesome explanation! A couple of words on this and good list of this execution context pointer in case of event handlers.In two words, this in JavaScript points the object from whom (or from whose execution context) the current function was run and it\'s always read-only, you can\'t set it anyway (such an attempt will end up with \'Invalid left-hand side in assignment\' message.For event handlers: inline event handlers, such as <element onclick="foo">, override any other handlers attached earlier and before, so be careful and it\'s better to stay off of inline event delegation at all.\nAnd thanks to Zara Alaverdyan who inspired me to this list of examples through a dissenting debate :)Here is one good source of this in JavaScript.Here is the summary:global thisIn a browser, at the global scope, this is the windowobjectIn node using the repl, this is the top namespace. You can refer to it as global.In node executing from a script, this at the global scope starts as an empty object. It is not the same as globalfunction thisExcept in the case of DOM event handlers or when a thisArg is provided (see further down), both in node and in a browser using this in a function that is not called with new references the global scope\xe2\x80\xa6If you use use strict;, in which case this will be undefinedIf you call a function with new the this will be a new context, it will not reference the global this.Functions you create become function objects. They automatically get a special prototype property, which is something you can assign values to. When you create an instance by calling your function with new you get access to the values you assigned to the prototype property. You access those values using this.It is usually a mistake to assign arrays or objects on the prototype. If you want instances to each have their own arrays, create them in the function, not the prototype.You can use this in any function on an object to refer to other properties on that object. This is not the same as an instance created with new.In an HTML DOM event handler, this is always a reference to the DOM element the event was attached to Unless you bind the contextInside HTML attributes in which you can put JavaScript, this is a reference to the element. You can use eval to access this.You can use with to add this to the current scope to read and write to values on this without referring to this explicitly.the jQuery will in many places have this refer to a DOM element. It is difficult to get a good grasp of JS, or write more than anything trivial in it, if you don\'t understand it thoroughly. You cannot just afford to take a quick dip :) I think the best way to get started with JS is to first watch these video lectures by Douglas Crockford - http://yuiblog.com/crockford/, which covers this and that, and everything else about JS.This is the best explanation I\'ve seen.  Understand JavaScripts this with ClarityThe this reference ALWAYS refers to (and holds the value of) an\n  object\xe2\x80\x94a singular object\xe2\x80\x94and it is usually used inside a function or a\n  method, although it can be used outside a function in the global\n  scope. Note that when we use strict mode, this holds the value of\n  undefined in global functions and in anonymous functions that are not\n  bound to any object.There are Four Conditions where this can be confusing:He gives code examples, the explanations, and the code fixes which I thought was very helpful.this is one of the misunderstood concept in JavaScript because it behaves little differently from place to place. Simply, this refers to the "owner" of the function we are currently executing. this helps to get the current object (a.k.a. execution context) we work with. If you understand in which object the current function is getting executed, you can understand easily what current this isAbove we create 3 variables with same name \'val\'. One in global context, one inside obj and the other inside innerMethod of obj. JavaScript resolves identifiers within a particular context by going up the scope chain from local go global. Few places where this can be differentiated When line1 is executed, JavaScript establishes an execution context (EC) for the function call, setting this to the object referenced by whatever came before the last ".". so in the last line you can understand that a() was executed in the global context which is the window.this can be used to refer to the object being createdWhen new Person() is executed, a completely new object is created. Person is called and its this is set to reference that new object. If we miss new keyword, whatIsThis referes to the most global context it can find(window)If the event handler is inline, this refers to global objectWhen adding event handler through JavaScript, this refers to DOM element that generated the event.Probably the most detailed and comprehensive article on this is the following: Gentle explanation of \'this\' keyword in JavaScriptThe idea behind this is to understand that the function invocation types have the significant importance on setting this value.  When having troubles identifying this, do not ask yourself:  Where is this taken from?but do ask yourself:How is the function invoked?For an arrow function (special case of context transparency) ask yourself:What value has this where the arrow function is defined?This mindset is correct when dealing with this and will save you from headache.There is a lot of confusion regarding how "this" keyword is interpreted in JavaScript. Hopefully this article will lay all those to rest once and for all. And a lot more. Please read the entire article carefully. Be forewarned that this article is long.Irrespective of the context in which it is used, "this" always references the "current object" in Javascript. However, what the "current object" is  differs according to context. The context may be exactly 1 of the 6 following:The following describes each of this contexts one by one:Global Context (i.e. Outside all functions):Outside all functions (i.e. in global context) the "current\nobject" (and hence the value of "this") is always the\n"window" object for browsers.Inside Direct "Non Bound Function" Call: Inside a Direct  "Non Bound Function" Call, the object that\ninvoked the function call becomes the "current object" (and hence\nthe value of "this"). If a function is called without a explicit current object, the current object is either the "window" object (For Non Strict Mode) or undefined (For Strict Mode)  . Any function (or variable) defined in\nGlobal Context automatically becomes a property of the "window" object.For e.g Suppose function is defined in Global Context as it becomes the property of the window object, as if you have defined\nit asIn "Non Strict Mode", Calling/Invoking this function directly through   "UserDefinedFunction()" will automatically call/invoke\nit as "window.UserDefinedFunction()" making "window" as the\n"current object" (and hence the value of "this") within "UserDefinedFunction".Invoking this function in "Non Strict Mode" will result in the followingIn "Strict Mode", Calling/Invoking the function directly through\n"UserDefinedFunction()" will "NOT" automatically call/invoke it as "window.UserDefinedFunction()".Hence the "current\nobject" (and the value of "this") within\n"UserDefinedFunction" shall be undefined. Invoking this function in "Strict Mode" will result in the followingHowever, invoking it explicitly using window object shall result in\nthe followingLet us look at another example. Please look at the following codeIn the above example we see that when "UserDefinedFunction" was\ninvoked through o1, "this" takes value of o1 and the\nvalue of its properties "a" and "b" get displayed. The value\nof "c" and "d" were shown as undefined as o1 does\nnot define these propertiesSimilarly when "UserDefinedFunction" was invoked through o2,\n"this" takes value of o2 and the value of its properties "c" and "d" get displayed.The value of "a" and "b" were shown as undefined as o2 does not define these properties.Inside Indirect "Non Bound Function" Call through functionName.call and functionName.apply:When a "Non Bound Function" is called through\nfunctionName.call or functionName.apply, the "current object" (and hence the value of "this") is set to the value of\n"this" parameter (first parameter) passed to call/apply. The following code demonstrates the same.The above code clearly shows that the "this" value for any "NON\nBound Function" can be altered through call/apply. Also,if the\n"this" parameter is  not explicitly passed to call/apply, "current object" (and hence the value of "this") is set to "window" in Non strict mode and "undefined" in strict mode.Inside "Bound Function" Call (i.e. a function that has been bound by calling functionName.bind):A bound function is a function whose "this" value has been\nfixed. The following code demonstrated how "this" works in case\nof bound functionAs given in the code above, "this" value for any "Bound Function"\nCANNOT be altered through call/apply. Also, if the "this"\nparameter is  not explicitly passed to bind, "current object"\n(and hence the value of "this" ) is set to "window" in Non\nstrict mode and "undefined" in strict mode.  One more thing.\nBinding an already bound function does not change the value of "this".\nIt remains set as the value set by first bind function.While Object Creation through "new":Inside a constructor function, the "current object" (and hence the value of \n"this") references the object that is currently being created\nthrough "new" irrespective of the bind status of the function. However\nif the constructor is a bound function it shall get called with \npredefined set of arguments as set for the bound function.Inside Inline DOM event handler:Please look at the following HTML SnippetThe "this" in above examples refer to "button" element and the\n"div" element respectively.In the first example, the font color of the button shall be set to\nwhite when it is clicked.In the second example when the "div" element is clicked it shall\ncall the OnDivClick function with its second parameter\nreferencing the clicked div element. However the value of "this"\nwithin OnDivClick SHALL NOT reference the clicked div\nelement. It shall be set as the "window object" or\n"undefined" in Non strict and Strict Modes respectively (if OnDivClick is an unbound function) or set to a predefined\nBound value (if OnDivClick is a bound function)The following summarizes the entire articleIn Global Context "this" always refers to the "window" objectWhenever a function is invoked, it is invoked in context of an\nobject ("current object"). If the current object is not explicitly provided,\nthe current object  is the "window object" in NON Strict\nMode and "undefined" in Strict Mode by default.The value of "this" within a Non Bound function is the reference to object in context of which the function is invoked ("current object")The value of "this" within a Non Bound function can be overriden by\ncall and apply methods of the function.The value of "this" is fixed for a Bound function and cannot be\noverriden by call and apply methods of the function.Binding and already bound function does not change the value of "this". It remains set as the value set by first bind function.The value of "this" within a constructor is the object that is being\ncreated and initializedThe value of "this" within an inline DOM event handler is reference\nto the element for which the event handler is given.Whould this help? (Most confusion of \'this\' in javascript is coming from the fact that it generally is not linked to your object, but to the current executing scope -- that might not be exactly how it works but is always feels like that to me -- see the article for a complete explanation)this use for Scope just like thisvalue of txt1 and txt is same\nin Above example \n$(this)=$(\'#tbleName tbody tr\') is Same"this" is all about scope. Every function has its own scope, and since everything in JS is an object, even a function can store some values into itself using "this".The value of "this" depends on the "context" in which the function is executed. The context can be any object or the global object, i.e., window.So the Semantic of "this" is different from the traditional OOP languages. And it causes problems:\n1. when a function is passed to another variable (most likely, a callback); and 2. when a closure is invoked from a member method of a class.In both cases, this is set to window.In pseudoclassical terms, the way many lectures teach the \'this\' keyword is as an object instantiated by a class or object constructor. Each time a new object is constructed from a class, imagine that under the hood a local instance of a \'this\' object is created and returned. I remember it taught like this: