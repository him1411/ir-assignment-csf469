How can I stash only one of multiple changed files on my branch?WarningAs noted in the comments, this puts everything into the stash, both staged and unstaged. The --keep-index just leaves the index alone after the stash is done. This can cause merge conflicts when you later pop the stash.This will stash everything that you haven\'t previously added. Just git add the things you want to keep, then run it.For example, if you want to split an old commit into more than one changeset, you can use this procedure:You can also use git stash -p. This way you can select which hunks should be added to stash, whole files can be selected as well. You\'ll be prompted with a few actions for each hunk:Since git is fundamentally about managing a all repository content and index (and not one or several files), git stash deals, not surprisingly, with the all working directory.Actually, since Git 2.13 (Q2 2017), you can stash individual files, with:See "Stash changes to specific files" for more.The original answer (below, June 2010) was about manually selecting what you want to stash.  Casebash comments:This (the stash --patch original solution) is nice, but often I\'ve modified a lot of files so using patch is annoyingbukzor\'s answer (upvoted, November 2011) suggests a more practical solution, based on\ngit add + git stash --keep-index.\nGo see and upvote his answer, which should be the official one (instead of mine).About that option, chhh points out an alternative workflow in the comments:you should "git reset --soft" after such a stash to get your clear staging back:\n  In order to get to the original state - which is a clear staging area and with only some select un-staged modifications, one could softly reset the index to get (without committing anything like you - bukzor - did).(Original answer June 2010: manual stash)Yet, git stash save --patch could allows you to achieve the partial stashing you are after:With --patch, you can interactively select hunks from in the diff between HEAD and the working tree to be stashed.\n  The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree.However that will save the full index (which may not be what you want since it might include other files already indexed),  and a partial worktree (which could look like the one you want to stash).might be a better fit.If --patch doesn\'t work, a manual process might:For one or several files, an intermediate solution would be to:At the end of that rather cumbersome process, you will have only one or several files stashed.When git stash -p (or git add -p with stash --keep-index) would be too cumbersome, I found it easier to use diff, checkout and apply:To "stash" a particular file/dir only:Then afterwardsLet\'s say you have 3 files and you want to stash only b.rb and c.rb but not a.rbyou can do something like thisAnd you are done!\nHTH.Another way to do this:I came up with this after I (once again) came to this page and didn\'t like the first two answers (the first answer just doesn\'t answer the question and I didn\'t quite like working with the -p interactive mode).The idea is the same as what @VonC suggested using files outside the repository, you save the changes you want somewhere, remove the changes you don\'t want in your stash, and then re-apply the changes you moved out of the way. However, I used the git stash as the "somewhere" (and as a result, there\'s one extra step at the end: removing the cahnges you put in the stash, because you moved these out of the way as well).Update (2/14/2015) - I\'ve rewritten the script a bit, to better handle the case of conflicts, which should now be presented as unmerged conflicts rather than .rej files.I often find it more intuitive to do the inverse of @bukzor\'s approach. That is, to stage some changes, and then stash only those staged changes. Unfortunately, git doesn\'t offer a git stash --only-index or similar, so I whipped up a script to do this.You can save the above script as git-stash-index somewhere on your path, and can then invoke it as git stash-indexNow the stash contains a new entry that only contains the changes you had staged, and your working tree still contains any unstaged changes.In some cases, the working tree changes may depend on the index changes, so when you stash the index changes, the working tree changes have a conflict. In this case, you\'ll get the usual unmerged conflicts that you can resolve with git merge/git mergetool/etc.Since creating branches in Git is trivial you could just create a temporary branch and check the individual files into it.Save the following code to a file, for example, named stash. Usage is stash <filename_regex>. The argument is the regular expression for the full path of the file. For example, to stash a/b/c.txt, stash a/b/c.txt or stash .*/c.txt, etc.Code to copy into the file:Just in case you actually mean \'discard changes\' whenever you use \'git stash\' (and don\'t really use git stash to stash it temporarily), in that case you can use Note that git stash is just a quicker and simple alternative to branching and doing stuff.The problem with VonC\'s `intermediate\' solution of copying files to outside the Git repo is that you lose path information, which makes copying a bunch of files back later on somewhat of a hassle.A find it easier to use tar (similar tools will probably do) instead of copy:Sometimes I\'ve made an unrelated change on my branch before I\'ve committed it, and I want to move it to another branch and commit it separately (like master). I do this:Note the first stash & stash pop can be eliminated, you can carry all of your changes over to the master branch when you checkout, but only if there are no conflicts. Also if you are creating a new branch for the partial changes you will need the stash.You can simplify it assuming no conflicts and no new branch:Stash not even needed...This can be done easily in 3 steps using SourceTree.This can all be done in a matter of seconds in SourceTree, where you can just click on the files (or even individual lines) you want to add.  Once added, just commit them to a temporary commit.  Next, click the checkbox to add all changes, then click stash to stash everything.  With the stashed changes out of the way, glance over at your commit list and note the hash for the commit before your temporary commit, then run \'git reset hash_b4_temp_commit\', which is basically like "popping" the commit by resetting your branch to the commit right before it.   Now, you\'re left with just the stuff you didn\'t want stashed.Every answer here is so complicated...What about this to "stash":This to pop the file change back:Exact same behavior as stashing one file and popping it back in.Use git stash push, like this:For example:This is available since Git 2.13, released in spring 2017.In this situation I git add -p (interactive), git commit -m blah and then stash what\'s left if necessary.I would use git stash save --patch. I don\'t find the interactivity to be annoying because there are options during it to apply the desired operation to entire files.Similar situation. Did commit and realized it\'s not ok.Based on the answers this helped me.I don\'t know how to do it on command line, only using SourceTree. Lets say you have changed file A, and have two change hunks in file B. If you want to stash only the second hunk in file B and leave everything else untouched, do this:When you try to switch between two branches, this situation occurs.Try to add the files using  "git add filepath".Later execute this line git stash --keep-indexI\'ve reviewed answers and comments for this and a number of similar threads. Be aware that none of the following commands are correct for the purpose of being able to stash any specific tracked/untracked files:Currently, the most reasonable method to be able to stash any specific tracked/untracked files is to:I wrote a simple script for this procedure in an answer to another question, and there are steps for performing the procedure in SourceTree here.One complicated way would be to first commit everything:Reset back to the original commit but checkout the_one_file from the new commit:Now you can stash the_one_file:Cleanup by saving the committed content in your file system while resetting back to the original commit:Yeah, somewhat awkward...I found no answer to be what I needed and that is as easy as:This stashes exactly one file.Local changes:  To create a stash "my_stash" with only the changes on file_C:Done.You can use git status between the step to see what is happened.