What is the difference between a function decorated with @staticmethod and one decorated with @classmethod?Maybe a bit of example code will help: Notice the difference in the call signatures of foo, class_foo and static_foo:Below is the usual way an object instance calls a method. The object instance, a, is implicitly passed as the first argument.With classmethods, the class of the object instance is implicitly passed as the first argument instead of self.You can also call class_foo using the class. In fact, if you define something to be\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. A.foo(1) would have raised a TypeError, but A.class_foo(1) works just fine:One use people have found for class methods is to create inheritable alternative constructors.With staticmethods, neither self (the object instance) nor  cls (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:Staticmethods are used to group functions which have some logical connection with a class to the class.foo is just a function, but when you call a.foo you don\'t just get the function,\nyou get a "partially applied" version of the function with the object instance a bound as the first argument to the function. foo expects 2 arguments, while a.foo only expects 1 argument.a is bound to foo. That is what is meant by the term "bound" below:With a.class_foo, a is not bound to class_foo, rather the class A is bound to class_foo.Here, with a staticmethod, even though it is a method, a.static_foo just returns\na good \'ole function with no arguments bound. static_foo expects 1 argument, and\na.static_foo expects 1 argument too.And of course the same thing happens when you call static_foo with the class A instead.A staticmethod is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument. It is basically useless in Python -- you can just use a module function instead of a staticmethod.A classmethod, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how dict.fromkeys(), a classmethod, returns an instance of the subclass when called on a subclass:Basically @classmethod makes a method whose first argument is the class it\'s called from (rather than the class instance), @staticmethod does not have any implicit arguments.Official python docs:@classmethodA class method receives the class as\n  implicit first argument, just like an\n  instance method receives the instance.\n  To declare a class method, use this\n  idiom:The @classmethod form is a function\n  decorator \xe2\x80\x93 see the description of\n  function definitions in Function\n  definitions for details.It can be called either on the class\n  (such as C.f()) or on an instance\n  (such as C().f()). The instance is\n  ignored except for its class. If a\n  class method is called for a derived\n  class, the derived class object is\n  passed as the implied first argument.Class methods are different than C++\n  or Java static methods. If you want\n  those, see staticmethod() in this\n  section.@staticmethodA static method does not receive an\n  implicit first argument. To declare a\n  static method, use this idiom:The @staticmethod form is a function\n  decorator \xe2\x80\x93 see the description of\n  function definitions in Function\n  definitions for details.It can be called either on the class\n  (such as C.f()) or on an instance\n  (such as C().f()). The instance is\n  ignored except for its class.Static methods in Python are similar\n  to those found in Java or C++. For a\n  more advanced concept, see\n  classmethod() in this section.Here is a short article on this question@staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It\xe2\x80\x99s definition is immutable via inheritance.@classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance. That\xe2\x80\x99s because the first argument for @classmethod function must always be cls (class).You may have seen Python code like this pseudocode, which demonstrates the signatures of the various method types and provides a docstring to explain each:First I\'ll explain a_normal_instance_method. This is precisely called an "instance method". When an instance method is used, it is used as a partial function (as opposed to a total function, defined for all values when viewed in source code) that is, when used, the first of the arguments is predefined as the instance of the object, with all of its given attributes. It has the instance of the object bound to it, and it must be called from an instance of the object. Typically, it will access various attributes of the instance.For example, this is an instance of a string:if we use the instance method, join on this string, to join another iterable,\nit quite obviously is a function of the instance, in addition to being a function of the iterable list, [\'a\', \'b\', \'c\']:Instance methods can be bound via a dotted lookup for use later.For example, this binds the str.join method to the \':\' instance:And later we can use this as a function that already has the first argument bound to it. In this way, it works like a partial function on the instance:The static method does not take the instance as an argument. It is very similar to a module level function. However, a module level function must live in the module and be specially imported to other places where it is used. If it is attached to the object, however, it will follow the object conveniently through importing and inheritance as well.An example of a static method is str.maketrans, moved from the string module in Python 3.  It makes a translation table suitable for consumption by str.translate. It does seem rather silly when used from an instance of a string, as demonstrated below, but importing the function from the string module is rather clumsy, and it\'s nice to be able to call it from the class, as in str.maketransIn python 2, you have to import this function from the increasingly less useful string module:A class method is a similar to an instance method in that it takes an implicit first argument, but instead of taking the instance, it takes the class. Frequently these are used as alternative constructors for better semantic usage and it will support inheritance.The most canonical example of a builtin classmethod is dict.fromkeys. It is used as an alternative constructor of dict, (well suited for when you know what your keys are and want a default value for them.)When we subclass dict, we can use the same constructor, which creates an instance of the subclass.See the pandas source code for other similar examples of alternative constructors, and see also the official Python documentation on classmethod and staticmethod.@decorators were added in python 2.4 If you\'re using python < 2.4 you can use the classmethod() and staticmethod() function.For example, if you want to create a factory method (A function returning an instance of a different implementation of a class depending on what argument it gets) you can do something like:Also observe that this is a good example for using a classmethod and a static method,\nThe static method clearly belongs to the class, since it uses the class Cluster internally.\nThe classmethod only needs information about the class, and no instance of the object.Another benefit of making the _is_cluster_for method a classmethod is so a subclass can decide to change it\'s implementation, maybe because it is pretty generic and can handle more than one type of cluster, so just checking the name of the class would not be enough.To decide whether to use @staticmethod or @classmethod you have to look inside your method. If your method accesses other variables/methods in your class then use @classmethod. On the other hand if your method does not touch any other parts of the class then use @staticmethod.I think a better question is "When would you use @classmethod vs @staticmethod?"@classmethod allows you easy access to private members that are associated to the class definition. this is a great way to do singletons, or factory classes that control the number of instances of the created objects exist.@staticmethod provides marginal performance gains, but I have yet to see a productive use of a static method within a class that couldn\'t be achieved as a standalone function outside the class.@staticmethod just disables the default function as method descriptor.  classmethod wraps your function in a container callable that passes a reference to the owning class as first argument:As a matter of fact, classmethod has a runtime overhead but makes it possible to access the owning class.  Alternatively I recommend using a metaclass and putting the class methods on that metaclass:Static Methods:Benefits of Static Methods:More convenient to import versus module-level functions since each method does not have to be specially importedClass Methods:These are created with classmethod in-built function.@classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.@staticmethod means: when this method is called, we don\'t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can\'t access the instance of that class (this is useful when your method does not use the instance).The definitive guide on how to use static, class or abstract methods in Python is one good link for this topic, and summary it as following.@staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It\xe2\x80\x99s definition is immutable via inheritance.@classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That\xe2\x80\x99s because the first argument for @classmethod function must always be cls (class).Another consideration with respect to staticmethod vs classmethod comes up with inheritance.  Say you have the following class:And you then want to override bar() in a child class:This works, but note that now the bar() implementation in the child class (Foo2) can no longer take advantage of anything specific to that class.  For example, say Foo2 had a method called magic() that you want to use in the Foo2 implementation of bar():The workaround here would be to call Foo2.magic() in bar(), but then you\'re repeating yourself (if the name of Foo2 changes, you\'ll have to remember to update that bar() method).To me, this is a slight violation of the open/closed principle, since a decision made in Foo is impacting your ability to refactor common code in a derived class (ie it\'s less open to extension).  If bar() were a classmethod we\'d be fine:Gives: In Foo2 MAGICIn Python, a classmethod receives a class as the implicit first argument. The class of the object instance is implicitly passed as the first argument. This can be useful\nwhen one wants the method to be a factory of the class as it gets the actual class (which called the method) as the first argument, one can instantiate the right class, even if subclasses are also concerned.A staticmethod is just a function defined inside a class. It does not  know anything about the class or instance it was called on and only gets  the arguments that were passed without any implicit first argument.\nExample:staticmethods are used to group functions which have some logical connection with a class to the class.I will try to explain the basic difference using an example.1 - we can directly call static and classmethods without initializing2- Static method cannot call self method but can call other static and classmethod3- Static method belong to class and will not use object at all.4- Class method are not bound to an object but to a class.@classmethod : can be used to create a shared global access to all the instances created of that class..... like updating a record by multiple users....\nI particulary found it use ful when creating singletons as well..:)@static method:  has nothing to do with the class or instance being associated with ...but for readability can use static methodA quick hack-up ofotherwise identical methods in iPython reveals that @staticmethod yields marginal performance gains (in the nanoseconds), but otherwise it seems to serve no function. Also, any performance gains will probably be wiped out by the additional work of processing the method through staticmethod() during compilation (which happens prior to any code execution when you run a script).For the sake of code readability I\'d avoid @staticmethod unless your method will be used for loads of work, where the nanoseconds count.