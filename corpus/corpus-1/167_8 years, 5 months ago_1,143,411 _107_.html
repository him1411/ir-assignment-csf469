I have an object, x. I\'d like to copy it as object y, such that changes to y do not modify x. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn\'t a problem, since I\'m copying one of my own, literal-constructed objects.How do I correctly clone a JavaScript object?To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object\'s prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a clone method to Object.prototype, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to Object.prototype, or other intermediate prototypes, that you don\'t know about? In that case, you will copy attributes you shouldn\'t, so you need to detect unforeseen, non-local attributes with the hasOwnProperty method.In addition to non-enumerable attributes, you\'ll encounter a tougher problem when you try to copy objects that have hidden properties. For example, prototype is a hidden property of a function. Also, an object\'s prototype is referenced with the attribute __proto__, which is also hidden, and will not be copied by a for/in loop iterating over the source object\'s attributes. I think __proto__ might be specific to Firefox\'s JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don\'t know of any way to discover it automatically.Yet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object\'s prototype is Object, then simply creating a new general object with {} will work, but if the source\'s prototype is some descendant of Object, then you are going to be missing the additional members from that prototype which you skipped using the hasOwnProperty filter, or which were in the prototype, but weren\'t enumerable in the first place. One solution might be to call the source object\'s constructor property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a Date object stores its data as a hidden member:The date string for d1 will be 5 seconds behind that of d2. A way to make one Date the same as another is by calling the setTime method, but that is specific to the Date class. I don\'t think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!When I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain Object, Array, Date, String, Number, or Boolean. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in Object or Array would also be one of the 6 simple types in that list. This can be accomplished with code like the following:The above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn\'t more than one reference to the same data in the object. For example:It will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don\'t assume that it will just work for anything you throw at it.With jQuery, you can shallow copy with extend:subsequent changes to the copiedObject will not affect the originalObject, and vice versa.Or to make a deep copy:If you do not use functions within your object, a very simple one liner can be the following:This works for all kind of objects containing objects, arrays, strings, booleans and numbers.See also this article about the structured clone algorithm of browsers which is used when posting messages to and from a worker. It also contains a function for deep cloning.In ECMAScript 6 there is Object.assign method, which copies values of all enumerable own properties from one object to another. For example:But be aware that nested objects are still copied as reference.There are many answers, but none that mentions Object.create from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.Thus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:Example:Why do I consider this solution to be superior? It\'s native, thus no looping, no recursion. However, older browsers will need a polyfill.An Object.assign method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.Read more...The polyfill to support older browsers:If you\'re okay with a shallow copy, the underscore.js library has a clone method.or you can extend it likePer MDN:And no need for external libaries but you need to check browser compatablity first.There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn\'t be accepted.I want to deep-copy a Javascript Object with all of its children and their children and so on. But since I\'m not kind of a normal developer, my Object has normal properties, circular structures and even nested objects.So let\'s create a circular structure and a nested object first.Let\'s bring everything together in an Object named a.Next we want to copy a into a variable named b and mutate it.You know what happened here, because if not you wouldn\'t even landed on this great question.Now let\'s find a solution.The first attempt I tried was using JSON.Don\'t waste too much time on it, you\'ll get TypeError: Converting circular structure to JSON.Let\'s have a look at the accepted answer.Looks good, heh? It\'s a recursive copy of the object and handles other types as well, like Date, but that wasn\'t a requirement.Recursion and circular structures doesn\'t work well together... RangeError: Maximum call stack size exceededAfter arguing with my co-worker, my boss asked us what happend, and he found a simple solution after some googling. It\'s called Object.create.This solution was added to Javascript some time ago and even handles circular structure.... and you see, it didn\'t work with the nested structure inside.There\'s a polyfill for Object.create in older browser just like the IE 8. It\'s something like recommended by Mozilla, and of course it\'s not perfect and results in the same problem as the native solution.I\'ve put F outside the scope so we can have a look at what instanceof tells us.Same problem as the native solution, but a little bit worse output.When digging around, I found a similiar question (In Javascript, when performing a deep copy, how do I avoid a cycle, due to a property being "this"?) to this one, but with a way better solution.And let\'s have a look at the output...The requirements are matched, but there are still some smaller issues, including changing the instance of nested andcirc to Object.The structure of trees that share a leaf won\'t be copied, they will become two independent leaves:The last solution using recursion and a cache, may not be the best, but it\'s a real deep-copy of the object. It handles simple properties, circular structures and nested object, but it will mess up the instance of them while cloning.http://jsfiddle.net/einfallstoll/N4mr2/One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.Of course, functions do not belong in JSON, so this only works for objects without member methods.This methodology was perfect for my use case, since I\'m storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.orMore in angular.copy documentation...A.Levy\'s answer is almost complete, here is my little contribution: there is a way how to handle recursive references, see this lineif(this[attr]==this) copy[attr] = copy;If the object is XML DOM element, we must use cloneNode insteadif(this.cloneNode) return this.cloneNode(true);Inspired by A.Levy\'s exhaustive study and Calvin\'s prototyping approach, I offer this solution:See also Andy Burke\'s note in the answers.From this article: How to copy arrays and objects in Javascript by Brian Huisman:Here is a function you can use. You can clone an object and remove any reference from the previous one using a single line of code. Simply do:For browsers / engines that do not currently support Object.create you can use this polyfill:You can simply use a spread property to copy an object without references. But be careful (see comments), the \'copy\' is just on the lowest object/array level. Nested properties are still references!Complete clone:Clone with references on second level:JavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:http://ramdajs.com/docs/#cloneIn ES-6 you can simply use Object.assign(...).\nEx:A good reference is here:\nhttps://googlechrome.github.io/samples/object-assign-es6/New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with Spread Syntax, it\'s easy.This provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.JavaScript keeps evolving.OK, imagine you have this object below and you want to clone it:orThe answer is mainly depeneds on which ECMAscript you using, in ES6+, you can simply use Object.assign to do the clone:or using spread operator like this:But if you using ES5, you can use few methods, but the JSON.stringify, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:Using Lodash: Jan Turo\xc5\x88\'s answer above is very close, and may be the best to use in a browser due to compatibility issues, but it will potentially cause some strange enumeration issues.  For instance, executing:Will assign the clone() method to i after iterating through the elements of the array.  Here\'s an adaptation that avoids the enumeration and works with node.js:This avoids making the clone() method enumerable because defineProperty() defaults enumerable to false.This is an adaptation of A. Levy\'s code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)Some quick testsES6 solution if you want to (shallow) clone a class instance and not just a property object.I just wanted to add to all the Object.create solutions in this post, that this does not work in the desired way with nodejs. In Firefox the result ofis {test:"test"}.In nodejs it is One thing is certain... there is no elegant way. My contribution here is this link\nhttp://oranlooney.com/deep-copy-javascript/I think this library is the most comprehensive and elegant solution. It is particularly focused on the prototype chain of the cloned objects. It includes a mechanism to easy describe custom cloning behavior for particular classes. The author explains that most of the time the default cloning mechanism which is provided works fine.It also clones functions and handles cycles or multiple references.I have recently suggested the author a solution to optimize the mechanism which handles cycles, from O(n^2) to O(n).Since mindeavor stated that the object to be cloned is a \'literal-constructed\' object, a solution might be to simply generate the object multiple times rather than cloning an instance of the object:Interested in cloning simple objects :JSON.parse(JSON.stringify(json_original));Source : How to copy JavaScript object to new variable NOT by reference?I\'ve written my own implementation. Not sure if it counts as a better solution:Following is the implementation:Consult http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#safe-passing-of-structured-data for the W3C\'s "Safe passing of structured data" algorithm, intended to be implemented by browsers for passing data to eg web workers. However, it has some limitations, in that it does not handle functions. See https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm for more information, including an alternative algorithm in JS which gets you part of the way there.