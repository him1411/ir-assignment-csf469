I have a value \'Dog\' and an array [\'Cat\', \'Dog\', \'Bird\']. How do I check if it exists in the array without looping through it? Is there a simple way of checking if the value exists, nothing more?You\'re looking for include?:There is an in? method in ActiveSupport (part of Rails) since v3.1, as pointed out by @campaterson. So within Rails, or if you require \'active_support\', you can write:OTOH, there is no in operator or #in? method in Ruby itself, even though it has been proposed before, in particular by Yusuke Endoh a top notch member of ruby-core.As pointed out by others, the reverse method include? exists, for all Enumerables including Array, Hash, Set, Range:Note that if you have many values in your array, they will all be checked one after the other (i.e. O(n)), while that lookup for a hash will be constant time (i.e O(1)). So if you array is constant, for example, it is a good idea to use a Set instead. E.g:A quick test reveals that calling include? on a 10 element Set is about 3.5x faster  than calling it on the equivalent Array (if the element is not found).A final closing note: be wary when using include? on a Range, there are subtleties, so refer to the doc and compare with cover?...TryUse Enumerable#include:Or, if a number of tests are done,1 you can get rid of the loop (that even include? has) and go from O(n) to O(1) with:If you want to check by a block, you could try any? or all?.  Details are here: http://ruby-doc.org/core-1.9.3/Enumerable.html\nMy inspiration come from here: https://stackoverflow.com/a/10342734/576497Several answers suggest Array#include?, but there is one important caveat: Looking at the source, even Array#include? does perform looping:The way to test the word presence without looping is by constructing a trie for your array. There are many trie implementations out there (google "ruby trie"). I will use rambling-trie in this example: And now we are ready to test the presence of various words in your array without looping over it, in O(log n) time, with same syntactic simplicity as Array#include?, using sublinear Trie#include?:This is another way to do this: use the Array#index method.It returns the index of the first occurrence of the element in the array.example:index() can also take a blockfor examplehere, return the index of the first word in the array that containing letter \'o\'.If you don\'t want to loop, there\'s no way to do it with Arrays. You should use a Set instead.Sets work internally like hashes, so Ruby doesn\'t need to loop through the collection to find items, since as the name implies, it generates hashes of the keys and creates a memory map so that each hash point to a certain point in memory. The previous example done with a Hash:The downside is that Sets and hash keys can only include unique items and if you add a lot of items, Ruby will have to rehash the whole thing after certain number of items to build a new map that suits a larger keyspace. For more about this, I recommend you watch MountainWest RubyConf 2014 - Big O in a Homemade Hash by Nathan Long Here\'s a benchmark:And the results:Ruby has 11 methods to find elements in an array.The preferred one is include?Or for repeated access, creating a set and then calling include? or member?Here are all of them,All of them return a trueish value if the element is present. include? is the preferred method. It uses a C-language for loop internally that breaks when an element matches the internal rb_equal_opt/rb_equal functions. It cannot get much more efficient unless you create a set for repeated membership checks.member? is not redefined in Array class and uses an unoptimized implementation from the Enumerable module that literally enumerate through all elements.Translated to Ruby code this does about the followingBoth include? and member? have O(n) time complexity since the both search the array for the first occurrence of the expected value. We can use a set to get O(1) access time at the cost of having to create a hash representation of the array first. If you repeatedly check membership on the same array this initial investment can pay off quickly. Set is not implemented in C but as plain Ruby class, still the O(1) access time of the underlying @hash makes this worthwhile.Here is the implementation of the Set class,As you can see the Set class just creates an internal @hash instance, maps all objects to true and then checks membership using Hash#include? which is implemented with O(1) access time in the Hash class.I won\'t discuss the other 7 methods as they are all less efficient.There are actually even more methods with O(n) complexity beyond the 11 listed above, but I decided to not list them since scan the entire array rather than breaking at the first match. Don\'t use these,There are multiple ways to accomplish this. A few of them are as follows:This will tell you not only that it exists but also how many times it appears:For what it\'s worth, The Ruby docs are an amazing resource for these kinds of questions.I would also take note of the length of the array you\'re searching through. The include? method will run a linear search with O(n) complexity which can get pretty ugly depending on the size of the array. If you\'re working with a large (sorted) array, I would consider writing a binary search algorithm which shouldn\'t be too difficult and has a worst case of O(log n). Or if you\'re using Ruby 2.0, you can take advantage of bsearch.Fun fact, You can use * to check array membership in a case expressions. Notice the little * in the when clause, this checks for membership in the array. All the usual magic behavior of the splat operator applies, so for example if array is not actually an array but a single element it will match that element.If you have on mind more values... you can try:Example: if Cat and Dog exist in the array:Instead of:Note: member? and include? are the same.This can do the work in one line!There\'s the other way around, too!Suppose the array is [ :edit, :update, :create, :show ] - well perhaps the entire seven deadly/restful sins :)And further toy with the idea of pulling a valid action from some string - say my brother would like me to update his profileIf we want to not use include? this also works:How about this way?if you don\'t want to use include? you can first wrap the element in an array and then check whether the wrapped element is equal to the intersection of the array and the wrapped element.  This will return a boolean value based on equality.Here is one more way to do this:Convert arr to hash, now check in O(1) multiples times for any key : hash = arr.map {|x| [x,true]}.to_hPerformance of Hash#has_key? versus Array#include?