I\'ve been told by others on numerous occasions that my teacher\'s advice of  exercising using namespace std in code was wrong. Hence, we should use std::cout and std::cin.Why is using namespace std considered bad practice? Is it really that inefficient or risk declaring ambiguous variables (variables that share the same name as a function in std namespace)? Or, does this impact performance?This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:Everything works fine, you can call Blah() from Foo and Quux() from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called Quux(). Now you\'ve got a conflict: Both Foo 2.0 and Bar import Quux() into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.If you had used foo::Blah() and bar::Quux(), then the introduction of foo::Quux() would have been a non-event.I agree with everything Greg wrote, but I\'d like to add: It can even get worse than Greg said!Library Foo 2.0 could introduce a function, Quux(), that is an unambiguously better match for some of your calls to Quux() than the bar::Quux() your code called for years. Then your code still compiles, but it silently calls the wrong function and does god-knows-what. That\'s about as bad as things can get.Keep in mind that the std namespace has tons of identifiers, many of which are very common ones (think list, sort, string, iterator, etc.) which are very likely to appear in other code, too.If you consider this unlikely: There was a question asked here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted std:: prefix) about half a year after I gave this answer. Here is another, more recent example of such a question.\nSo this is a real problem.Here\'s one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with std::. Then I worked in a project where it was decided at the start that both using directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code more readable. There\'s a reason for that: Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code. Not only the compiler, but you, too, find it easier to see which identifier is referred to.In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope using actually was used in the project. I grep\'d the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don\'t find std:: painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.Bottom line: Explicitly prefixing everything doesn\'t do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers \xe2\x80\x94 and that should probably be the main goal when writing code.I think it\'s bad to put it in the header files of your classes: because then you would be forcing anyone who wants to use your classes (by including your header files) to also be \'using\' (i.e. seeing everything in) those other namespaces.However, you may feel free to put a using statement in your (private) *.cpp files.Beware that some people disagree with my saying "feel free" like this -- because although a using statement in a cpp file is better than in a header (because it doesn\'t affect people who include your header file), they think it\'s still not good (because depending on the code it could make the implementation of the class more difficult to maintain). This FAQ topic says,The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn\xe2\x80\x99t use it on a regular basis, at least not in your new C++ code.It suggests two alternatives:A using declaration:Get over it and just type std::I recently ran into a complaint about Visual Studio 2010. It turned out that pretty much all the source files had these two lines:A lot of Boost features are going into the C++0x standard, and Visual Studio 2010 has a lot of C++0x features, so suddenly these programs were not compiling.Therefore, avoiding using namespace X; is a form of future-proofing, a way of making sure a change to the libraries and/or header files in use is not going to break a program.Short version: don\'t use global using declarations or directives in header files. Feel free to use them in implementation files. Here\'s what Herb Sutter and Andrei Alexandrescu have to say about this issue in C++ Coding Standards (bolding for emphasis is mine):Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.Corollary: In header files, don\xe2\x80\x99t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable.One shouldn\'t use using directive at global scope, especially in headers. However there are situations where it is appropriate even in a header file:This is better than explicit qualification (std::sin, std::cos...)\nbecause it is shorter and has the ability to work with user defined floating point types (via Argument Dependent Lookup).If you import the right header files you suddenly have names like hex, left, plus or count in your global scope. This might be surprising if you are not aware that std:: contains these names. If you also try to use these names locally it can lead to quite some confusion.If all the standard stuff is in its own namespace you don\'t have to worry about name collisions with your code or other libraries.It is considered "bad" only when used globally. Because:Go ahead and use it locally (almost) freely. This, of course, prevents you from repetition of std:: -- and repetition is also bad.In C++03 there was an idiom -- boilerplate code -- for implementing a swap function for your classes. It was suggested that you actually use a local using namespace std -- or at least using std::swap:This does the following magic:With C++11 there is no reason to use this pattern any more. The implementation of std::swap was changed to find a potential overload and choose it.Experienced programmers use whatever solves their problems and avoid whatever creates new problems. Thus they avoid header-file-level using-directives for obvious reason.And they try to avoid full qualification of names inside their source files. A minor point is that it\'s not elegant to write more code when less code suffice without good reason. A major point is turning off ADL.What are these good reasons? Sometimes you explicitly want turning off ADL. Sometimes you want to disambiguate.So the following are OK:I agree that it should not be used globally, but it\'s not so evil to to use locally, like in a namespace. Here\'s an example from "The C++ Programming Language" :In this example, we resolved potential name clashes and ambiguities arising from their composition.Names explicitly declared there (including names declared by using-declarations like His_lib::String) take priority over names made accessible in another scope by a using-directive (using namespace Her_lib). Another reason is surprise.If I see cout << blah, instead of std::cout << blahI think what is this \'cout\'? Is it the normal cout? Is it something special?I also consider it a bad practice. Why? Just one day I thought that function of a namespace is to divide stuff so I shouldn\'t spoil it with throwing everything into one global bag.\nHowever, if I often use \'cout\' and \'cin\', I write: using std::cout; using std::cin; in cpp file (never in header file as it propagates with #include). I think that noone sane will ever name a stream cout or cin. ;)It\'s all about managing complexity. Using the namespace will pull things in that you don\'t want, and thus possibly make it harder to debug (I say possibly). Using std:: all over the place is harder to read (more text and all that).Horses for courses - manage your complexity how you best can and feel able.you need to be able to read code written by people who have different style and best practices opinions than you.If you\'re only using cout, nobody gets confused.  But when you have lots of namespaces flying around and you see this class and you aren\'t exactly sure what it does, having the namespace explicit acts as a comment of sorts.  You can see at first glance, \'oh, this is a filesystem operation\' or \'thats doing network stuff\'.Using many namespaces at the same time is obviously a recipe for disaster, but using JUST namespace std and only namespace std is not that big of a deal in my opinion because redefinition can only occur by your own code... So just consider them functions as reserved names like "int" or "class" and that is it.People should stop being so anal about it. Your teacher was right all along. Just use ONE namespace; that is the whole point of using namespaces the first place. You are not supposed to use more than one at the same time. Unless it is your own. So again, redefinition will not happen.ConsiderNote that this is a simple example, if you have files with 20 includes and other imports you\'ll have a ton of dependencies to go through to figure out the problem.  The worse thing about it is that you can get unrelated errors in other modules depending on the definitions that conflict.It\'s not horrible but you\'ll save yourself headaches by not using it in header files or the global namespace.  It\'s probably alright to do it in very limited scopes but I\'ve never had a problem typing the extra 5 characters to clarify where my functions are coming from.It\'s nice to see code and know what it does. If I see "std::cout" I know: That\'s the cout stream of the std library. If I see "cout" then I don\'t know. It could be the cout stream of the std library. Or there could be an "int cout = 0;" ten lines higher in the same function. Or a static variable named cout in that file. It could be anything. Now take a million line code base, which isn\'t particularly big, and you\'re searching for a bug, which means you know there is one line in this one million lines that doesn\'t do what it is supposed to do. "cout << 1;" could read a static int named cout, shift it to the left by one bit, and throw away the result. Looking for a bug, I\'d have to check that. Can you see how I really really prefer to see "std::cout"? It\'s one of these things that seem a really good idea if you are a teacher and never had to write and maintain any code for a living. I love seeing code where (1) I know what it does and (2) I\'m confident that the person writing it knew what it does. A concrete example to clarify the concern.  Imagine you have a situation where you have 2 libraries, foo and bar, each with their own namespace:Now let\'s say you use foo and bar together in your own program as follows:At this point everything is fine.  When you run your program it \'does something\'.  But later you update bar and let\'s say it has changed to be like:At this point you\'ll get a compiler error:So you\'ll need to do some maintenance to clarify which \'a\' you meant (i.e. foo::a).  That\'s probably undesirable, but fortunately it is pretty easy (just add foo:: in front of all calls to a that the compiler marks as ambiguous).But imagine an alternative scenario where bar changed instead to look like this instead:At this point your call to a(42) suddenly binds to bar::a instead of foo::a and instead of doing \'something\' it does \'something completely different\'.  No compiler warning or anything.  Your program just silently starts doing something complete different than before.When you use a namespace you\'re risking a scenario like this, which is why people are uncomfortable using namespaces.  The more things in a namespace the greater the risk of conflict, so people might be even more uncomfortable using namespace std (due to the number of things in that namespace) than other namespaces.Ultimately this is a trade-off between writability vs reliability/maintainability.  Readability may factor in also, but I could see arguments for that going either way.  Normally I would say reliability and maintainability are more important, but in this case you\'ll constantly pay the writability cost for an fairly rare reliability/maintainability impact.  The \'best\' trade-off will determine on your project and your priorities.A namespace is a named scope. Namespaces are used to group related declarations and to keep separate\nitems separate. For example, two separately developed libraries may use the same name to refer to different\nitems, but a user can still use both:Repeating a namespace name can be a distraction for both readers and writers. Consequently, it is possible\nto state that names from a particular namespace are available without explicit qualification. For example:Namespaces provide a powerful tool for the management of different libraries and of different versions of\n    code. In particular, they offer the programmer alternatives of how explicit to make a reference to a nonlocal\n    name.Source : An Overview of the C++ Programming Language\nby Bjarne StroustrupI agree with the others here, but would like to address the concerns regarding readability - you can avoid all of that by simply using typedefs at the top of your file, function or class declaration. I usually use it in my class declaration as methods in a class tend to deal with similar data types (the members) and a typedef is an opportunity to assign a name that is meaningful in the context of the class. This actually aids readability in the definitions of the class methods.and in the implementation:as opposed to:or:An example where using namespace std throws complilation error because of the ambiguity of count, which is also a function in algorithm library.I do not think it is necessarily bad practice under all conditions, but you need to be careful when you use it.  If you\'re writing a library, you probably should use the scope resolution operators with the namespace to keep your library from butting heads with other libraries.  For application level code, I don\'t see anything wrong with it."Why is \'using namespace std;\' considered a bad practice in C++?"I put it the other way around: Why is typing 5 extra chars is considered cumbersome by some?Consider e.g. writing a piece of numerical software, why would I even consider polluting my global namespace by cutting general "std::vector" down to "vector" when "vector" is one of the problem domain\'s most important concepts?With unqualified imported identifiers you need external search tools like grep to find out where identifiers are declared. This makes reasoning about program correctness harder.To answer your question I look at it this way practically:  a lot of programmers (not all) invoke namespace std.  Therefore one should be in the habit of NOT using things that impinge or use the same names as what is in the namespace std.  That is a great deal granted, but not so much compared to the number of possible coherent words and pseudonyms that can be come up with strictly speaking.I mean really... saying "don\'t rely on this being present" is just setting you up to rely on it NOT being present.  You are constantly going to have issues borrowing code snippets and constantly repairing them.  Just keep your user-defined and borrowed stuff in limited scope as they should be and be VERY sparing with globals (honestly globals should almost always be a last resort for purposes of "compile now, sanity later"). Truly I think it is bad advice from your teacher because using std will work for both "cout" and "std::cout" but NOT using std will only work for "std::cout".  You will not always be fortunate enough to write all your own code.NOTE: Don\'t focus too much on efficiency issues until you actually learn a little about how compilers work.  With a little experience coding you don\'t have to learn that much about them before you realize how much they are able to generalize good code into something something simple.  Every bit as simple as if you wrote the whole thing in C.  Good code is only as complex as it needs to be.I agree with others - it is asking for name clashes, ambiguities and then the fact is it is less explicit. While I can see the use of using ... my personal preference is to limit it. I would also strongly consider what some others pointed out:If you want to find a function name that might be a fairly common name, but you only want to find it in std namespace (or the reverse: you want to change all calls that are NOT in namespace std, namespace X, ...), then how do you propose to do this? You could write a program to do it but wouldn\'t it be better to spend time working on your project itself rather than writing a program to maintain your project?Personally I actually don\'t mind the std:: prefix. I like the look more than not. I don\'t know if that is because it is explicit and says to me "this isn\'t my code... I am using the standard library" or if it is something else, but I think it looks nicer. This might be odd given that I only recently got in to C++ (used and still do C and other languages for much longer and C is my favourite language of all time, right above assembly).There is one other thing although it is somewhat related to the above and what others point out. While this might be bad practise, I sometimes reserve std::name for standard library version and name for program-specific implementation. Yes indeed this could bite you and bite you hard but it all comes down to that I started this project from scratch and I\'m the only programmer for it. Example: I overload std::string and call it string. I have helpful additions. I did it in part because of my C and Unix (+ Linux) tendency towards lower-case names.Besides that, you can have namespace aliases. Here is an example of where it is useful that might not have been referred to (I didn\'t read all the responses and I\'m having to rush off for a while in a moment). I use the C++11 standard and specifically with libstdc++. Well check this. It doesn\'t have complete std::regex support. Sure it compiles but it throws an exception along the lines of it being an error on the programmer\'s end. But it is lack of implementation. So here\'s how I solved it. Install boost\'s regex, link in boost\'s regex. Then, I do the following so that when libstdc++ has it implemented entirely, I need only remove this block and the code remains the same:I won\'t argue on whether that is a bad idea or not. I will however argue that it keeps it clean for MY project and at the same time makes it specific: True I have to use boost BUT I\'m using it like the libstdc++ will eventually have it. Yes, starting your own project and starting with a standard (...) at the very beginning goes a very long way with helping maintenance, development and everything involved with the project!Edit: Now that I have time, just to clarify something. I don\'t actually think it is a good idea to use a name of a class/whatever in the STL deliberately and more specifically in place of. string is the exception (ignore the first, above, or second here, pun if you must) for me as I didn\'t like the idea of \'String\'. As it is, I am still very biased towards C and biased against C++. Sparing details, much of what I work on fits C more (but it was a good exercise and a good way to make myself a. learn another language and b. try not be less biased against object/classes/etc which is maybe better stated as: less closed-minded, less arrogant, more accepting.). But what IS useful is what some already suggested: I do indeed use list (it is fairly generic, is it not ?), sort (same thing) to name two that would cause a name clash if I were to do "using namespace std;" and so to that end I prefer being specific, in control and knowing that if I intend it to be the standard use then I will have to specify it. Put simply: no assuming allowed.And as for making boost\'s regex part of std. I do that for future integration and - again, I admit fully this is bias - I don\'t think it is as ugly as boost::regex:: ... Indeed that is another thing for me. There\'s many things in C++ that I still have yet to come to fully accept in looks and methods (another example: variadic templates versus var args [though I admit variadic templates are very very useful!]). Even those that I do accept it was difficult AND I still have issues with them.It depends on where it is located. If it is a common header, then you are diminishing the value of the namespace by merging it into the global namespace. Keep in mind, this could be a neat way of making module globals.I think using locally or globally should depend on the application.Because, \n    when we use the library locally, sometimes code going to be a real mess. Readability is going to low.so, we should use libraries locally when only there is a possibility for conflicts.I am not more experiences person. So, let me know if I am wrong.Yes, the namespace is important. Once in my project, I needed to import one var declaration into my source code, but when compiling it, it conflicted with another third-party library.At the end, I had to work around around it by some other means and make the code less clear.Here is an example showing how using namespace std; can lead to name clash problems:Unable to define a global variable in c++In the example a very generic algorithm name (std::count) name clashes with a very reasonable variable name (count).