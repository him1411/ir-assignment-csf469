For a few days I\'ve tried to wrap my head around the functional programming paradigm in Haskell. I\'ve done this by reading tutorials and watching screencasts, but nothing really seems to stick.\nNow, in learning various imperative/OO languages (like C, Java, PHP), exercises have been a good way for me to go. But since I don\'t really know what Haskell is capable of and because there are many new concepts to utilize, I haven\'t known where to start.So, how did you learn Haskell? What made you really "break the ice"? Also, any good ideas for beginning exercises?I\'m going to order this guide by the level of skill you have in haskell, going from an absolute beginner right up to an expert. Note that this process will take many months (years?), so it is rather long.Absolute BeginnerFirstly, haskell is capable of anything, with enough skill. It is very fast (behind only c and c++ in my experience), and can be used for anything from simulations to servers, guis and web applications.However there are some problems that are easier to write for a beginner in haskell than others. Mathematical problems and list process programs are good candidates for this, as they only require the most basic of haskell knowledge to be able to write. Firstly, some good guides to learning the very basics of haskell are the happy learn haskell tutorial and the first 6 chapters of learn you a haskell. While reading these, it is a very good idea to also be solving simple problems with what you know.Another very good resource is Haskell Programming from first principles. It comes with exercises for each chapter, so you have small simple problems matching what you learned on the last few pages.A good list of problems to try is the haskell 99 problems page. These start off very basic, and get more difficult as you go on. It is very good practice doing a lot of those, as they let you practice your skills in recursion and higher order functions. I would recommend skipping any problems that require randomness as that is a bit more difficult in haskell. Check this SO question in case you want to test your solutions with QuickCheck (see Intermediate below).Once you have done a few of those, you could move on to doing a few of the Project Euler problems. These are sorted by how many people have completed them, which is a fairly good indication of difficulty. These test your logic and haskell more than the previous problems, but you should still be able to do the first few. A big advantage haskell has with these problems is Integers aren\'t limited in size. To complete some of these problems, it will be useful to have read chapters 7 and 8 of learn you a haskell as well.BeginnerAfter that you should have a fairly good handle on recursion and higher order functions, so it would be a good time to start doing some more real world problems. A very good place to start is Real World Haskell (online book, you can also purchase a hard copy).  I found the first few chapters introduced too much too quickly for someone who has never done functional programming/used recursion before. However with the practice you would have had from doing the previous problems you should find it perfectly understandable. Working through the problems in the book is a great way of learning how to manage abstractions and building reusable components in haskell. This is vital for people used to object-orientated (oo) programming, as the normal oo abstraction methods (oo classes) don\'t appear in haskell (haskell has type classes, but they are very different to oo classes, more like oo interfaces). I don\'t think it is a good idea to skip chapters, as each introduces a lot new ideas that are used in later chapters.After a while you will get to chapter 14, the dreaded monads chapter (dum dum dummmm). Almost everyone who learns haskell has trouble understanding monads, due to how abstract the concept is. I can\'t think of any concept in another language that is as abstract as monads are in functional programming. Monads allows many ideas (such as IO operations, computations that might fail, parsing,...) to be unified under one idea. So don\'t feel discouraged if after reading the monads chapter you don\'t really understand them. I found it useful to read many different explanations of monads; each one gives a new perspective on the problem. Here is a very good list of monad tutorials. I highly recommend the All About Monads, but the others are also good. Also, it takes a while for the concepts to truly sink in. This comes through use, but also through time. I find that sometimes sleeping on a problem helps more than anything else! Eventually, the idea will click, and you will wonder why you struggled to understand a concept that in reality is incredibly simple. It is awesome when this happens, and when it does, you might find haskell to be your favorite imperative programming language :)To make sure that you are understanding Haskell type system perfectly, you should try to solve 20 intermediate haskell exercises. Those exercises using fun names of functions like "furry" and "banana" and helps you to have a good understanding of some basic functional programming concepts if you don\'t have them already. Nice way to spend your evening with list of paper covered with arrows, unicorns, sausages and furry bananas.IntermediateOnce you understand Monads, I think you have made the transition from a beginner haskell programmer to an intermediate haskeller. So where to go from here? The first thing I would recommend (if you haven\'t already learnt them from learning monads) is the various types of monads, such as Reader, Writer and State. Again, Real world haskell and All about monads gives great coverage of this. To complete your monad training learning about monad transformers is a must. These let you combine different types of Monads (such as a Reader and State monad) into one. This may seem useless to begin with, but after using them for a while you will wonder how you lived without them.Now you can finish the real world haskell book if you want. Skipping chapters now though doesn\'t really matter, as long as you have monads down pat. Just choose what you are interested in.With the knowledge you would have now, you should be able to use most of the packages on cabal (well the documented ones at least...), as well as most of the libraries that come with haskell. A list of interesting libraries to try would be:Parsec: for parsing programs and text. Much better than using regexps. Excellent documentation, also has a real world haskell chapter.Quickcheck: A very cool testing program. What you do is write a predicate that should always be true (eg length (reverse lst) == length lst). You then pass the predicate the quickCheck, and it will generate a lot of random values (in this case lists) and test that the predicate is true for all results. See also the online manual.HUnit: Unit testing in haskell.gtk2hs: The most popular gui framework for haskell, lets you write gtk applications in haskell.happstack: A web development framework for haskell. Doesn\'t use databases, instead a data type store. Pretty good docs (another popular framework would be snap and yesod).Also, there are many concepts (like the Monad concept) that you should eventually learn. This will be easier than learning Monads the first time, as your brain will be used to dealing with the level of abstraction involved. A very good overview for learning about these high level concepts and how they fit together is the Typeclassopedia.Applicative: An interface like Monads, but less powerful. Every Monad is Applicative, but not vice versa. This is useful as there are some types that are Applicative but are not Monads. Also, code written using the Applicative functions is often more composable than writing the equivalent code using the Monad functions. See Functors, Applicative Functors and Monoids from the learn you a haskell guide.Foldable,Traversable: Typeclasses that abstract many of the operations of lists, so that the same functions can be applied to other container types. See also the haskell wiki explaination.Monoid: A Monoid is a type that has a zero (or mempty) value, and an operation, notated <> that joins two Monoids together, such that x <> mempty = mempty <> x = x and x <> (y <> z) = (x <> y) <> z. These are called identity and associativity laws. Many types are Monoids, such as numbers, with mempty = 0 and <> = +. This is useful in many situations.Arrows: Arrows are a way of representing computations that take an input and return an output. A function is the most basic type of arrow, but there are many other types. The library also has many very useful functions for manipulating arrows - they are very useful even if only used with plain old haskell functions.Arrays: the various mutable/immutable arrays in haskell.ST Monad: lets you write code with a mutable state that runs very quickly, while still remaining pure outside the monad. See the link for more details.FRP: Functional Reactive Programming, a new, experimental way of writing code that handles events, triggers, inputs and outputs (such as a gui). I don\'t know much about this though. Paul Hudak\'s talk about yampa is a good start.There are a lot of new language features you should have a look at. I\'ll just list them, you can find lots of info about them from google, the haskell wikibook, the haskellwiki.org site and ghc documentation.A lot of haskell is based around category theory, so you may want to look into that. A good starting point is Category Theory for Computer Scientist. If you don\'t want to buy the book, the author\'s related article is also excellent.Finally you will want to learn more about the various haskell tools. These include:While learning all these new libraries and concepts, it is very useful to be writing a moderate-sized project in haskell. It can be anything (eg a small game, data analyser, website, compiler). Working on this will allow you to apply many of the things you are now learning. You stay at this level for ages (this is where I\'m at).ExpertIt will take you years to get to this stage (hello from 2009!), but from here I\'m guessing you start writing phd papers, new ghc extensions, and coming up with new abstractions.Getting HelpFinally, while at any stage of learning, there are multiple places for getting information. These are:ConclusionWell this turned out longer than I expected... Anyway, I think it is a very good idea to become proficient in haskell. It takes a long time, but that is mainly because you are learning a completely new way of thinking by doing so. It is not like learning ruby after learning java, but like learning java after learning c. Also, I am finding that my object-orientated programming skills have improved as a result of learning haskell, as I am seeing many new ways of abstracting ideas.Some colleague of mine had good experience with Learn You a Haskell for Great Good!.Tutorial aimed at people who have\n  experience in imperative programming\n  languages but haven\'t programmed in a\n  functional language before.And check the answers here tooHere\'s a good book that you can read online: Real World HaskellMost of the Haskell programs I\'ve done have been to solve Project Euler problems.Once piece of advice I read not too long ago was that you should have a standard set of simple problems you know how to solve (in theory) and then whenever you try to learn a new language you implement those problems in that language.I enjoyed watching this 13 episode series on Functional Programming using Haskell.C9 Lectures: Dr. Erik Meijer - Functional Programming Fundamentals:\nhttp://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/To add on others\' answers - there is one useful that will help you when coding (for example when solving project Euler problems):\nHoogle.  You can use either the command line interface or the web interface.After you installed the Haskell platform be sure to cabal install hoogleHoogle usage example:You have a function f x = 3 * x + 1 and you want to apply it on (5 :: Int), then apply it on the result and on that result and so on and get an infinite list of those values. You suspect there might already exist a function to assist you (not specifically for your f though).That function would be of type (a -> a) -> a -> [a] if it takes f 5 or a -> (a -> a) -> [a] if it takes 5 f (we assume the function is for general types and not just Ints)yep, the function you need already exists and it\'s called iterate. you use it by iterate func 5!The result for the same example can be found here.Graham Hutton\'s Programming in Haskell is concise, reasonably thorough, and his years of teaching Haskell really show. It\'s almost always what I recommend people start with, regardless of where you go from there.In particular, Chapter 8 ("Functional Parsers") provides the real groundwork you need to start dealing with monads, and I think is by far the best place to start, followed by All About Monads. (With regard to that chapter, though, do note the errata from the web site, however: you can\'t use the do form without some special help. You might want to learn about typeclasses first and solve that problem on your own.)This is rarely emphasized to Haskell beginners, but it\'s worth learning fairly early on not just about using monads, but about constructing your own. It\'s not hard, and customized ones can make a number of tasks rather more simple.Don\'t try to read all the monad tutorials with funny metaphors. They will just get you mixed up even worse. I\'d suggest joining the #haskell irc channel and asking questions there. That\'s how I learned Haskell. If you go through Real World Haskell as suggested above, real time answers to your questions will help greatly. Lots of smart people on #haskell write Haskell for fun and for profit, so you\'ll get lots of good input. Try it!These are my favoriteHaskell: Functional Programming with TypesReal World HaskellI can additionally recommend Yet Another Haskell Tutorial as an introduction.Another good learning resource (probably on the intermediate level), which has helped me a lot and hasn\'t been mentioned in the other answers as far as I can see, is Brent Yorgey\'s Typeclassopedia, which can be found in The Monad Reader (Issue 13) It is written in a very accessible style and contains (among many other things), the following introductory advice:There are two keys to an expert Haskell hacker\xe2\x80\x99s wisdom:Understand the types.Gain a deep intuition for each type class and its relationship to other\n  type classes, backed up by familiarity with many examples.The Monad Reader itself is an absolute treasure trove for functional programmers (not only Haskell programmers).Try writing easy programs in it.You can find sample tasks in various textbooks, probably.I wouldn\'t recommend sticking to Haskell/FP textbooks, just try to do simple things with it: calculations, string manipulations, file access.After I solved a dozen, I\'ve broke the ice :)After that, read a lot on advanced concepts (Monads, Arrows, IO, recursive data structures), because haskell is infinite and there are a lot of them.I do think that realizing Haskell\'s feature by examples is the best way to start above all.http://en.wikipedia.org/wiki/Haskell_98_featuresHere is tricky typeclasses including monads and arrowshttp://www.haskell.org/haskellwiki/Typeclassopediafor real world problems and bigger project, remember these tags: GHC(most used compiler), Hackage(libraryDB), Cabal(building system), darcs(another building system). A integrated system can save your time: http://hackage.haskell.org/platform/the package database for this system: http://hackage.haskell.org/GHC compiler\'s wiki: http://www.haskell.org/haskellwiki/GHCAfter Haskell_98_features and Typeclassopedia, I think you already can find and read the documention about them yourselfBy the way, you may want to test some GHC\'s languages extension which may be a part of haskell standard in the future.this is my best way for learning haskell. i hope it can help you.I suggest that you first start by reading BONUS\' tutorial, And then reading Real World Haskell (online for free). Join the #Haskell IRC channel, on irc.freenode.com, and ask questions. These people are absolutely newbie friendly, and have helped me a lot over time. Also, right here on SO is a great place to get help with things you can\'t grasp! Try not to get discouraged, once it clicks, your mind will be blown.BONUS\' tutorial will prime you up, and get you ready for the thrill ride that Real World Haskell brings. I wish you luck!If you only have experience with imperative/OO languages, I suggest using a more conventional functional language as a stepping stone. Haskell is really different and you have to understand a lot of different concepts to get anywhere. I suggest tackling a ML-style language (like e.g. F#) first. The first answer is a very good one. In order to get to the Expert level, you should do a PhD with some of the Experts themselves.I suggest you to visit the Haskell page: http://haskell.org. There you have a lot of material, and a lot of references to the most up-to-date stuff in Haskell, approved by the Haskell community.