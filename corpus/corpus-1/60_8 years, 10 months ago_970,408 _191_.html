The idiom I use the most when programming in Java is to test if object != null before I use it. This is to avoid a NullPointerException. I find the code very ugly, and it becomes unreadable.Is there a good alternative to this? I want to address the necessity to test every object if you want to access a field or method of this object. For example:In this case I will avoid a NullPointerException, and I don\'t know exactly if the object is null or not. These tests appear throughout my code as a consequence.This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don\'t know or don\'t trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.To put this another way, there are two instances where null checking comes up:Where null is a valid response in terms of the contract; andWhere it isn\'t a valid response.(2) is easy.  Either use assert statements (assertions) or allow failure (for example,  NullPointerException).  Assertions are a highly-underused Java feature that was added in 1.4.  The syntax is:orwhere <condition> is a boolean expression and <object> is an object whose toString() method\'s output will be included in the error.An assert statement throws an Error (AssertionError) if the condition is not true.  By default, Java ignores assertions.  You can enable assertions by passing the option -ea to the JVM.  You can enable and disable assertions for individual classes and packages.  This means that you can validate code with the assertions while developing and testing, and disable them in a production environment, although my testing has shown next to no performance impact from assertions.Not using assertions in this case is OK because the code will just fail, which is what will happen if you use assertions.  The only difference is that with assertions it might happen sooner, in a more-meaningful way and possibly with extra information, which may help you to figure out why it happened if you weren\'t expecting it.(1) is a little harder.  If you have no control over the code you\'re calling then you\'re stuck.  If null is a valid response, you have to check for it.If it\'s code that you do control, however (and this is often the case), then it\'s a different story.  Avoid using nulls as a response.  With methods that return collections, it\'s easy: return empty collections (or arrays) instead of nulls pretty much all the time.With non-collections it might be harder.  Consider this as an example: if you have these interfaces:where Parser takes raw user input and finds something to do, perhaps if you\'re implementing a command line interface for something.  Now you might make the contract that it returns null if there\'s no appropriate action.  That leads the null checking you\'re talking about.An alternative solution is to never return null and instead use the Null Object pattern:Compare:towhich is a much better design because it leads to more concise code.That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.If you use (or planning to use) JetBrains IntelliJ IDEA, a Java IDE, you can use some particular annotations developed by them.Basically, you\'ve got @Nullable and @NotNull.You can use in method and parameters, like this:orThe second example won\'t compile (in IntelliJ IDEA).When you use the first helloWorld() function in another piece of code:Now the IntelliJ IDEA compiler will tell you that the check is useless, since the helloWorld() function won\'t return null, ever.Using parameterif you write something like:This won\'t compile.Last example using @NullableDoing thisAnd you can be sure that this won\'t happen. :)It\'s a nice way to let the compiler check something more than it usually does and to enforce your contracts to be stronger. Unfortunately, it\'s not supported by all the compilers.In IntelliJ IDEA 10.5 and on, they added support for any other @Nullable @NotNull implementations.See blog post More flexible and configurable @Nullable/@NotNull annotations.If your method is called externally, start with something like this:Then, in the rest of that method, you\'ll know that object is not null.If it is an internal method (not part of an API), just document that it cannot be null, and that\'s it.Example:However, if your method just passes the value on, and the next method passes it on etc. it could get problematic. In that case you may want to check the argument as above.This really depends. If find that I often do something like this:So I branch, and do two completely different things. There is no ugly code snippet, because I really need to do two different things depending on the data. For example, should I work on the input, or should I calculate a good default value?It\'s actually rare for me to use the idiom "if (object != null && ...".It may be easier to give you examples, if you show examples of where you typically use the idiom.Wow, I almost hate to add another answer when we have 57 different ways to recommend the NullObject pattern, but I think that some people interested in this question may like to know that there is a proposal on the table for Java 7 to add "null-safe handling"â€”a streamlined syntax for if-not-equal-null logic.The example given by Alex Miller looks like this:The ?. means only de-reference the left identifier if it is not null, otherwise evaluate the remainder of the expression as null. Some people, like Java Posse member Dick Wall and the voters at Devoxx really love this proposal, but there is opposition too, on the grounds that it will actually encourage more use of null as a sentinel value.Update: An official proposal for a null-safe operator in Java 7 has been submitted under Project Coin. The syntax is a little different than the example above, but it\'s the same notion.Update: The null-safe operator proposal didn\'t make it into Project Coin. So, you won\'t be seeing this syntax in Java 7.You might configure your IDE to warn you about potential null dereferencing. E.g. in Eclipse, see Preferences > Java > Compiler > Errors/Warnings/Null analysis.If you want to define a new API where undefined values make sense, use the Option Pattern (may be familiar from functional languages). It has the following advantages:Java 8 has a built-in Optional class (recommended); for earlier versions, there are library alternatives, for example Guava\'s Optional or FunctionalJava\'s Option. But like many functional-style patterns, using Option in Java (even 8) results in quite some boilerplate, which you can reduce using a less verbose JVM language, e.g. Scala or Xtend.If you have to deal with an API which might return nulls, you can\'t do much in Java. Xtend and Groovy have the Elvis operator ?: and the null-safe dereference operator ?., but note that this returns null in case of a null reference, so it just "defers" the proper handling of null.Only for this situation - \nAvoiding checking for null before a string compare:will result in a NullPointerException if foo doesn\'t exist.You can avoid that if you compare your Strings like this:With Java 8 comes the new java.util.Optional class that arguably solves some of the problem. One can at least say that it improves the readability of the code, and in the case of public APIs make the API\'s contract clearer to the client developer.They work like that:An optional object for a given type (Fruit) is created as the return type of a method. It can be empty or contain a Fruit object:Now look at this code where we search a list of Fruit (fruits) for a given Fruit instance:You can use the map() operator to perform a computation on--or extract a value from--an optional object.  orElse() lets you provide a fallback for missing values.Of course, the check for null/empty value is still necessary, but at least the developer is conscious that the value might be empty and the risk of forgetting to check is limited.In an API built from scratch using Optional whenever a return value might be empty, and returning a plain object only when it cannot be null (convention), the client code might abandon null checks on simple object return values...Of course Optional could also be used as a method argument, perhaps a better way to indicate optional arguments than 5 or 10 overloading methods in some cases.Optional offers other convenient methods, such as orElse that allow the use of a default value, and ifPresent that works with lambda expressions.I invite you to read this article (my main source for writing this answer) in which the NullPointerException (and in general null pointer) problematic as well as the (partial) solution brought by Optional are well explained: Java Optional Objects.Depending on what kind of objects you are checking you may be able to use some of the classes in the apache commons such as: apache commons lang and apache commons collectionsExample: or (depending on what you need to check):The StringUtils class is only one of many; there are quite a few good classes in the commons that do null safe manipulation.Here follows an example of how you can use null vallidation in JAVA when you include apache library(commons-lang-2.4.jar)And if you are using Spring, Spring also has the same functionality in its package, see library(spring-2.4.6.jar) Example on how to use this static classf from spring(org.springframework.util.Assert)You have to check for object != null only if you want to handle the case where the object may be null...There is a proposal to add new annotations in Java7 to help with null / notnull params:\nhttp://tech.puredanger.com/java7/#jsr308I\'m a fan of "fail fast" code. Ask yourself - are you doing something useful in the case where the parameter is null? If you don\'t have a clear answer for what your code should do in that case... I.e. it should never be null in the first place, then ignore it and allow a NullPointerException to be thrown. The calling code will make just as much sense of an NPE as it would an IllegalArgumentException, but it\'ll be easier for the developer to debug and understand what went wrong if an NPE is thrown rather than your code attempting to execute some other unexpected contingency logic - which ultimately results in the application failing anyway. The Google collections framework offers a good and elegant way to achieve the null check.There is a method in a library class like this:And the usage is (with import static):Or in your example:Sometimes, you have methods that operate on its parameters that define a symmetric operation:If you know b can never be null, you can just swap it. It is most useful for equals:\nInstead of foo.equals("bar"); better do "bar".equals(foo);.Java 7 has a new java.util.Objects utility class on which there is a requireNonNull() method. All this does is throw a NullPointerException if its argument is null, but it cleans up the code a bit. Example:The method is most useful for checking just before an assignment in a constructor, where each use of it can save three lines of code:becomesRather than Null Object Pattern -- which has its uses -- you might consider situations where the null object is a bug.When the exception is thrown, examine the stack trace and work through the bug.Null is not a \'problem\'. It is an integral part of a complete modeling tool set. Software aims to model the complexity of the world and null bears its burden. Null indicates \'No data\' or \'Unknown\' in Java and the like. So it is appropriate to use nulls for these purposes. I don\'t prefer the \'Null object\' pattern; I think it rise the \'who will guard\nthe guardians\' problem. \nIf you ask me what is the name of my girlfriend I\'ll tell you that I have no girlfriend. In the Java language I\'ll return null. \nAn alternative would be to throw meaningful exception to indicate some problem that can\'t be (or don\'t want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user.  For an \'unknown question\' give \'unknown answer\'. (Be null-safe where this is correct from business point of view) Checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call.Previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library.And it fits with new coming Java API (looking forward)While it is rather \'normal business flow\' not to find photo stored into the DB for some person, I used to use pairs like below for some other casesAnd don\'t loathe to type <alt> + <shift> + <j> (generate javadoc in Eclipse) and write three additional words for you public API. This will be more than enough for all but those who don\'t read documentation.orThis is rather theoretical case and in most cases you should prefer java null safe API, but NullPointerException is subclass of an Exception. Thus it is a form of Throwable that indicates conditions that a reasonable application might want to catch (javadoc)! To use the first most advantage of exceptions and separate error-handling code from \'regular\' code (according to creators of Java) it is appropriate, as for me, to catch NullPointerException.Questions could arise:Q. What if getPhotoDataSource() returns null?\nA. It is up to business logic. If I fail to find a photo album I\'ll show you no photos. What if appContext is not initialized? This method\'s business logic puts up with this. If the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). The new Java Null-safe API fits better here to specify selectively what implies and what does not imply to be initialized to be fail-fast in case of programmer errors.Q. Redundant code could be executed and unnecessary resources could be grabbed.\nA. It could take place if getPhotoByName() would try to open a database connection, create PreparedStatement and use the person name as an SQL parameter at last. The approach for an unknown question gives an unknown answer (case 1) works here. Before grabbing resources the method should check parameters and return \'unknown\' result if needed.Q. This approach has a performance penalty due to the try closure opening.\nA. Software should be easy to understand and modify firstly. Only after this, one could think about performance, and only if needed! and where needed! (source), and many others).PS. This approach will be as reasonable to use as the separate error-handling code from "regular" code principle is reasonable to use in some place. Consider the next example:PPS. For those fast to downvote (and not so fast to read documentation) I would like to say that I\'ve never caught a null-pointer exception (NPE) in my life. But this possibility was intentionally designed by the Java creators because NPE is a subclass of Exception. We have a precedent in Java history when ThreadDeath is an Error not because it is actually an application error, but solely because it was not intended to be caught! How much NPE fits to be an Error than ThreadDeath! But it is not.Check for \'No data\' only if business logic implies it.andIf appContext or dataSource is not initialized unhandled runtime NullPointerException will kill current thread and will be processed by Thread.defaultUncaughtExceptionHandler (for you to define and use your favorite logger or other notification mechanizm). If not set, ThreadGroup#uncaughtException will print stacktrace to system err. One should monitor application error log and open Jira issue for each unhandled exception which in fact is application error. Programmer should fix bug somewhere in initialization stuff.Ultimately, the only way to completely solve this problem is by using a different programming language:Common "problem" in Java indeed.First, my thoughts on this:I consider that it is bad to "eat" something when NULL was passed where NULL isn\'t a valid value. If you\'re not exiting the method with some sort of error then it means nothing went wrong in your method which is not true. Then you probably return null in this case, and in the receiving method you again check for null, and it never ends, and you end up with "if != null", etc..So, IMHO, null must be a critical error which prevents further execution (that is, where null is not a valid value).The way I solve this problem is this:First, I follow this convention:And finally, in the code, the first line of the public method goes like this:Note that addParam() returns self, so that you can add more parameters to check.Method validate() will throw checked ValidationException if any of the parameters is null (checked or unchecked is more a design/taste issue, but my ValidationException is checked).The message will contain the following text if, for example, "plans" is null:"Illegal argument value null is encountered for parameter [plans]"As you can see, the second value in the addParam() method (string) is needed for the user message, because you cannot easily detect passed-in variable name, even with reflection (not subject of this post anyway...).And yes, we know that beyond this line we will no longer encounter a null value so we just safely invoke methods on those objects.This way, the code is clean, easy maintainable and readable.In addition to using assert you can use the following:This is slightly better than:Asking that question points out that you may be interested in error handling strategies.  Your team\'s architect should decide how to work errors.  There are several ways to do this:allow the Exceptions to ripple through - catch them at the \'main loop\' or in some other managing routine.Sure do have a look at Aspect Oriented Programming, too - they have neat ways to insert if( o == null ) handleNull() into your bytecode.Just don\'t ever use null. Don\'t allow it.In my classes, most fields and local variables have non-null default values, and I add contract statements (always-on asserts) everywhere in the code to make sure this is being enforced (since it\'s more succinct, and more expressive than letting it come up as an NPE and then having to resolve the line number, etc.).Once I adopted this practice, I noticed that the problems seemed to fix themselves. You\'d catch things much earlier in the development process just by accident and realize you had a weak spot..  and more importantly.. it helps encapsulate different modules\' concerns, different modules can \'trust\' each other, and no more littering the code with if = null else constructs!This is defensive programming and results in much cleaner code in the long run. Always sanitize the data, e.g. here by enforcing rigid standards, and the problems go away.The contracts are like mini-unit tests which are always running, even in production, and when things fail, you know why, rather than a random NPE you have to somehow figure out.Guava, a very useful core library by Google, has a nice and useful API to avoid nulls. I find UsingAndAvoidingNullExplained very helpful.As explained in the wiki:Optional<T> is a way of replacing a nullable T reference with a\n  non-null value. An Optional may either contain a non-null T reference\n  (in which case we say the reference is "present"), or it may contain\n  nothing (in which case we say the reference is "absent"). It is never\n  said to "contain null."Usage:I like articles from Nat Pryce. Here are the links:In the articles there is also a link to a Git repository for a Java Maybe Type which I find interesting, but I don\'t think it alone could decrease the\nchecking code bloat. After doing some research on the Internet, I think != null code bloat could be decreased mainly by careful design.This is a very common problem for every Java developer. So there is official support in JavaÂ 8 to address these issues without cluttered code.Java 8 has introduced java.util.Optional<T>. It is a container that may or may not hold a non-null value. Java 8 has given a safer way to handle an object whose value may be null in some of the cases. It is inspired from the ideas of Haskell and Scala.In a nutshell, the Optional class includes methods to explicitly deal with the cases where a value is present or absent. However, the advantage compared to null references is that the Optional<T> class forces you to think about the case when the value is not present. As a consequence, you can prevent unintended null pointer exceptions.In above example we have a home service factory that returns a handle to multiple appliances available in the home. But these services may or may not be available/functional; it means it may result in a NullPointerException. Instead of adding a null if condition before using any service, let\'s wrap it in to Optional<Service>.WRAPPING TO OPTION<T>Let\'s consider a method to get a reference of a service from a factory. Instead of returning the service reference, wrap it with Optional. It lets the API user know that the returned service may or may not available/functional, use defensivelyAs you see Optional.ofNullable() provides an easy way to get the reference wrapped. There are another ways to get the reference of Optional, either Optional.empty() & Optional.of(). One for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively.SO HOW EXACTLY IT HELPS TO AVOID A NULL CHECK?Once you have wrapped a reference object, Optional provides many useful methods to invoke methods on a wrapped reference without NPE.Optional.ifPresent invokes the given Consumer with a reference if it is a non-null value. Otherwise, it does nothing.Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.\nIt is so clean and easy to understand. In the above code example, HomeService.switchOn(Service) gets invoked if the Optional holding reference is non-null.We use the ternary operator very often for checking null condition and return an alternative value or default value. Optional provides another way to handle the same condition without checking null. Optional.orElse(defaultObj) returns defaultObj if the Optional has a null value. Let\'s use this in our sample code:Now HomeServices.get() does same thing, but in a better way. It checks whether the service is already initialized of not. If it is then return the same or create a new New service. Optional<T>.orElse(T) helps to return a default value.Finally, here is our NPE as well as null check-free code:The complete post is NPE as well as Null check-free code \xe2\x80\xa6 Really?.I\'ve tried the NullObjectPattern but for me is not always the best way to go. There are sometimes when a "no action" is not appropiate.NullPointerException is a Runtime exception that means it\'s developers fault and with enough experience it tells you exactly where is the error.Now to the answer:Try to make all your attributes and its accessors as private as possible or avoid to  expose them to the clients at all. You can have the argument values in the constructor of course, but by reducing the scope you don\'t let the client class pass an invalid value. If you need to modify the values, you can always create a new object.  You check the values in the constructor only once and in the rest of the methods you can be almost sure that the values are not null.Of course, experience is the better way to understand and apply this suggestion.Byte!May I answer it more generally!We usually face this issue when the methods get the parameters in the way we not expected (bad method call is programmer\'s fault). For example: you expect to get an object, instead you get a null. You expect to get an String with at least one character, instead you get an empty String ...So there is no difference between:}orThey both want to make sure that we received valid parameters, before we do any other functions.As mentioned in some other answers, to avoid above problems you can follow the Design by contract pattern. Please see http://en.wikipedia.org/wiki/Design_by_contract. To implement this pattern in java, you can use core java annotations like javax.annotation.NotNull or use more sophisticated libraries like Hibernate Validator.Just a sample:Now you can safely develop the core function of your method without needing to check input parameters, they guard your methods from unexpected parameters.You can go a step further and make sure that only valid pojos could be created in your application. (sample from hibernate validator site)Doing this in your own code and you can avoid != null checks.Most of the time null checks seem to guard loops over collections or arrays, so just initialise them empty, you won\'t need any null checks.There is a tiny overhead in this, but it\'s worth it for cleaner code and less NullPointerExceptions.I highly disregard answers that suggest using the null objects in every situation. This pattern may break the contract and bury problems deeper and deeper instead of solving them, not mentioning that used inappropriately will create another pile of boilerplate code that will require future maintenance.In reality if something returned from a method can be null and the calling code has to make decision upon that, there should an earlier call that ensures the state. Also keep in mind, that null object pattern will be memory hungry if used without care. For this - the instance of a NullObject should be shared between owners, and not be an unigue instance for each of these.Also I would not recommend using this pattern where the type is meant to be a primitive type representation - like mathematical entities, that are not scalars: vectors, matrices, complex numbers and POD(Plain Old Data) objects, which are meant to hold state in form of Java built-in types. In the latter case you would end up calling getter methods with arbitrary results. For example what should a NullPerson.getName() method return? It\'s worth considering such cases in order to avoid absurd results.This is the most common error occurred for most of the developers.We have number of ways to handle this.Approach 1:notNull(Object object, String message) Approach 2:Approach 3:Approach 4:Probably the best alternative for Java 8 or newer is to use the Optional class. This is especially handy for long chains of possible null values. Example:Example on how to throw exception on null:Java 7 introduced the Objects.requireNonNull method which can be handy when something should be checked for non-nullness. Example: