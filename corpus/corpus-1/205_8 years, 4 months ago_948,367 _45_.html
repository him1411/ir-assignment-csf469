I would like a JavaScript function to have optional arguments which I set a default on, which gets used if the value isn\'t defined.  In Ruby you can do it like this:Does this work in JavaScript?From ES6/ES2015, default parameters is in the language specification.just works.Reference: Default Parameters - MDNDefault function parameters allow formal parameters to be initialized with default values if no value or undefined is passed.You can also simulate default named parameters via destructuring:Pre ES2015,There are a lot of ways, but this is my preferred method - it lets you pass in anything you want, including false or null. (typeof null == "object")This assigns to delete_after the value of delete_after if it is not a falsey value otherwise it assigns the string "my default here". For more detail, check out Doug Crockford\'s survey of the language and check out the section on Operators.This approach does not work if you want to pass in a falsey value i.e. false, null, undefined, 0 or "". If you require falsey values to be passed in you would need to use the method in Tom Ritter\'s answer.When dealing with a number of parameters to a function, it is often useful to allow the consumer to pass the parameter arguments in an object and then merge these values with an object that contains the default values for the functionto useI find something simple like this to be much more concise and readable personally.In ECMAScript 6 you will actually be able to write exactly what you have:This will set delete_after to false if it s not present or undefined. You can use ES6 features like this one today with transpilers such as Babel.See the MDN article for more information. Default Parameter ValuesWith ES6, you can do perhaps one of the most common idioms in JavaScript relates to setting a default  value for a function parameter. The way we\xe2\x80\x99ve done this for years should look quite  familiar:This pattern is most used, but is dangerous when we pass values like Why? Because the 0 is falsy, and so the x || 11 results in 11, not the directly passed  in 0. To fix this gotcha, some people will instead write the check more verbosely like this:we can now examine a nice helpful syntax added as of ES6 to  streamline the assignment of default values to missing arguments:x = 11 in a function declaration is more like x !== undefined ? x : 11 than the  much more common idiom x || 11Default Value ExpressionsFunction default values can be more than just simple values like 31; they can be any  valid expression, even a function call:As you can see, the default value expressions are lazily evaluated, meaning they\xe2\x80\x99re  only run if and when they\xe2\x80\x99re needed \xe2\x80\x94 that is, when a parameter\xe2\x80\x99s argument is omitted or is undefined.A default value expression can  even be an inline function expression call \xe2\x80\x94 commonly referred to as an Immediately  Invoked Function Expression (IIFE):that solution is work for me in js:Just use an explicit comparison with undefined.As an update...with ECMAScript 6 you can FINALLY set default values in function parameter declarations like so:As referenced by - http://es6-features.org/#DefaultParameterValuesbeing a long time C++ developer (Rookie to web development :)), when I first came across this situation, I did the parameter assignment in the function definition, like it is mentioned in the question, as follows. But beware that it doesn\'t work consistently across browsers. For me it worked on chrome on my desktop, but did not work on chrome on android.\nSafer option, as many have mentioned above is -Intention for this answer is not to repeat the same solutions, what others have already mentioned, but to inform that parameter assignment in the function definition may work on some browsers, but don\'t rely on it.To anyone interested in having there code work in Microsoft Edge, do not use defaults in function parameters. In that example Edge will throw an error "Expecting \')\'"    To get around this useAs of Aug 08 2016 this is still an issueFrom a functional perspective default parameters are harmful, because they lead to ambiguous types:fun has two distinct types depending on whether the "default case" is triggered. In a strictly typed language this wouldn\'t compile. In Javascript it works but leads to numerous little problems in daily life. For instance, you cannot compose such functions properly.Usually we use partially applied functions to achieve the same effect without ambiguous types:As you can see I implemented the function just once and then partially applied it as required. In this way I can define several default values for the same default parameter or several default parameters for the same function. Beyond that the different default cases are explicitly encoded in the function names, which makes the underlying mechanism more apparent.Look at currying for more information.Yes, This will work in Javascript. You can also do that: