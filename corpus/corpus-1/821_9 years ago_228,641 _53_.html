I\'m building a function to extend the Enum.Parse concept thatSo I wrote the following:I am getting a Error Constraint cannot be special class \'System.Enum\'.Fair enough, but is there a workaround to allow a Generic Enum, or am I going to have to mimic the Parse function and pass a type as an attribute, which forces the ugly boxing requirement to your code.EDIT All suggestions below have been greatly appreciated, thanks.Have settled on (I\'ve left the loop to maintain case insensitivity - I am usng this when parsing XML)EDIT: (16th Feb 2015) Julien Lebosquain has recently posted a compiler enforced type-safe generic solution in MSIL or F# below, which is well worth a look, and an upvote. I will remove this edit if the solution bubbles further up the page.Since Enum Type implements IConvertible interface, a better implementation should be something like this:This will still permit passing of value types implementing IConvertible. The chances are rare though.I\'m late to the game, but I took it as a challenge to see how it could be done.  It\'s not possible in C# (or VB.NET, but scroll down for F#), but is possible in MSIL.  I wrote this little....thingWhich generates a function that would look like this, if it were valid C#:Then with the following C# code:Unfortunately, this means having this part of your code written in MSIL instead of C#, with the only added benefit being that you\'re able to constrain this method by System.Enum.  It\'s also kind of a bummer, because it gets compiled into a separate assembly.  However, it doesn\'t mean you have to deploy it that way.By removing the line .assembly MyThing{} and invoking ilasm as follows:you get a netmodule instead of an assembly.  Unfortunately, VS2010 (and earlier, obviously) does not support adding netmodule references, which means you\'d have to leave it in 2 separate assemblies when you\'re debugging.  The only way you can add them as part of your assembly would be to run csc.exe yourself using the /addmodule:{files} command line argument.  It wouldn\'t be too painful in an MSBuild script.  Of course, if you\'re brave or stupid, you can run csc yourself manually each time.  And it certainly gets more complicated as multiple assemblies need access to it.So, it CAN be done in .Net.  Is it worth the extra effort?  Um, well, I guess I\'ll let you decide on that one.Extra Credit:  It turns out that a generic restriction on enum is possible in at least one other .NET language besides MSIL: F#.This one is easier to maintain since it\'s a well-known language with full Visual Studio IDE support, but you still need a separate project in your solution for it. However, it naturally produces considerably different IL (the code is very different) and it relies on the FSharp.Core library, which, just like any other external library, needs to become part of your distribution.Here\'s how you can use it (basically the same as the MSIL solution), and to show that it correctly fails on otherwise synonymous structs:You can have a real compiler enforced enum constraint by abusing constraint inheritance. The following code specifies both a class and a struct constraints at the same time:Usage:Note: this is specifically stated in the C# 5.0 language specification:If type parameter S depends on type parameter T then:\n  [...] It is valid for\n  S to have the value type constraint and T to have the reference type\n  constraint. Effectively this limits T to the types System.Object,\n  System.ValueType, System.Enum, and any interface type.EditThe question has now superbly been answered by Julien Lebosquain.\nI would also like to extend his answer with ignoreCase, defaultValue and optional arguments, while adding TryParse and ParseOrDefault.Examples of usage:OldMy old improvements on Vivek\'s answer by using the comments and \'new\' developments:resulting in:You can define a static constructor for the class that will check that the type T is an enum and throw an exception if it is not. This is the method mentioned by Jeffery Richter in his book CLR via C#.Then in the parse method, you can just use Enum.Parse(typeof(T), input, true) to convert from string to the enum. The last true parameter is for ignoring case of the input. I modified the sample by dimarzionist. This version will only work with Enums and not let structs get through. I tried to improve the code a bit:I do have specific requirement where I required to use enum with text associated with enum value. For example when I use enum to specify error type it required to describe error details.Interestingly enough, apparently this is possible in other langauges (Managed C++, IL directly).  To Quote:... Both constraints actually produce valid IL and can also be consumed by C# if written in another language (you can declare those constraints in managed C++ or in IL).Who knows Hope this is helpful:This is my take at it. Combined from the answers and MSDNMSDN SourceI always liked this (you could modify as appropriate):I loved Christopher Currens\'s solution using IL but for those who don\'t want to deal with tricky business of including MSIL into their build process I wrote similar function in C#.Please note though that you can\'t use generic restriction like where T : Enum because Enum is special type. Therefore I have to check if given generic type is really enum.My function is:I\'ve encapsulated Vivek\'s solution into a utility class that you can reuse. Please note that you still should define type constraints "where T : struct, IConvertible" on your type.I created an extension Method to get integer value from enum \ntake look at method implementation this is usage As stated in other answers before; while this cannot be expressed in source-code it can actually be done on IL Level.\n@Christopher Currens answer shows how the IL do to that.With Fodys Add-In ExtraConstraints.Fody there\'s a very simple way, complete with build-tooling, to achieve this. Just add their nuget packages (Fody, ExtraConstraints.Fody) to your project and add the constraints as follows (Excerpt from the Readme of ExtraConstraints):and Fody will add the necessary IL for the constraint to be present.\nAlso note the additional feature of constraining delegates:Regarding Enums, you might also want to take note of the highly interesting Enums.NET.