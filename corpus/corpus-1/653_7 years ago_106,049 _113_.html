In C++03, an expression is either an rvalue or an lvalue.In C++11, an expression can be an:     Two categories have become five categories.I guess this document might serve as a not so short introduction : n3055The whole massacre began with the move semantics. Once we have expressions that can be moved and not copied, suddenly easy to grasp rules demanded distinction between expressions that can be moved, and in which direction.From what I guess based on the draft, the r/l value distinction stays the same, only in the context of moving things get messy. Are they needed? Probably not if we wish to forfeit the new features. But to allow better optimization we should probably embrace them.Quoting n3055:The document in question is a great reference for this question, because it shows the exact changes in the standard that have happened as a result of the introduction of the new nomenclature.What are these new categories of expressions?The FCD (n3092) has an excellent description:\xe2\x80\x94 An lvalue (so called, historically, because lvalues could appear on the\n  left-hand side of an assignment\n  expression) designates a function or\n  an object. [ Example: If E is an\n  expression of pointer type, then\n  *E is an lvalue expression referring to the object or function to which E\n  points. As another example, the result\n  of calling a function whose return\n  type is an lvalue reference is an\n  lvalue. \xe2\x80\x94end example ] \xe2\x80\x94 An xvalue (an\n  \xe2\x80\x9ceXpiring\xe2\x80\x9d value) also refers to an\n  object, usually near the end of its\n  lifetime (so that its resources may be\n  moved, for example). An xvalue is the\n  result of certain kinds of expressions\n  involving rvalue references (8.3.2). [\n  Example: The result of calling a\n  function whose return type is an\n  rvalue reference is an xvalue. \xe2\x80\x94end\n  example ] \xe2\x80\x94 A glvalue (\xe2\x80\x9cgeneralized\xe2\x80\x9d\n  lvalue) is an lvalue or an xvalue.\xe2\x80\x94\n  An rvalue (so called, historically,\n  because rvalues could appear on the\n  right-hand side of an assignment\n  expressions) is an xvalue, a temporary\n  object (12.2) or subobject thereof, or\n  a value that is not associated with an\n  object.\xe2\x80\x94 A prvalue (\xe2\x80\x9cpure\xe2\x80\x9d rvalue) is\n  an rvalue that is not an xvalue. [\n  Example: The result of calling a\n  function whose return type is not a\n  reference is a prvalue. The value of a\n  literal such as 12, 7.3e5, or true is\n  also a prvalue. \xe2\x80\x94end example ]Every\n  expression belongs to exactly one of\n  the fundamental classifications in\n  this taxonomy: lvalue, xvalue, or\n  prvalue. This property of an\n  expression is called its value\n  category. [ Note: The discussion of\n  each built-in operator in Clause 5\n  indicates the category of the value it\n  yields and the value categories of the\n  operands it expects. For example, the\n  built-in assignment operators expect\n  that the left operand is an lvalue and\n  that the right operand is a prvalue\n  and yield an lvalue as the result.\n  User-defined operators are functions,\n  and the categories of values they\n  expect and yield are determined by\n  their parameter and return types. \xe2\x80\x94end\n  noteI suggest you read the entire section 3.10 Lvalues and rvalues though.How do these new categories relate to the existing rvalue and lvalue categories? Again: Are the rvalue and lvalue categories in C++0x the same as they are in C++03?The semantics of rvalues has evolved particularly with the introduction of move semantics.Why are these new categories needed?So that move construction/assignment could be defined and supported.I\'ll start with your last question:Why are these new categories needed? The C++ standard contains many rules that deal with the value category of an expression. Some rules make a distinction between lvalue and rvalue. For example, when it comes to overload resolution. Other rules make a distinction between glvalue and prvalue. For example, you can have a glvalue with an incomplete or abstract type but there is no prvalue with an incomplete or abstract type. Before we had this terminology the rules that actually need to distinguish between glvalue/prvalue referred to lvalue/rvalue and they were either unintentionally wrong or contained lots of explaining and exceptions to the rule a la "...unless the rvalue is due to unnamed rvalue reference...". So, it seems like a good idea to just give the concepts of glvalues and prvalues their own name.What are these new categories of expressions?\n  How do these new categories relate to the existing rvalue and lvalue categories?We still have the terms lvalue and rvalue that are compatible with C++98. We just divided the rvalues into two subgroups, xvalues and prvalues, and we refer to lvalues and xvalues as glvalues. Xvalues are a new kind of value category for unnamed rvalue references. Every expression is one of these three: lvalue, xvalue, prvalue. A Venn diagram would look like this:Examples with functions:But also don\'t forget that named rvalue references are lvalues:Why are these new categories needed? Are the WG21 gods just trying to confuse us mere mortals?I don\'t feel that the other answers (good though many of them are) really capture the answer to this particular question. Yes, these categories and such exist to allow move semantics, but the complexity exists for one reason. This is the one inviolate rule of moving stuff in C++11:Thou shalt move only when it is unquestionably safe to do so.That is why these categories exist: to be able to talk about values where it is safe to move from them, and to talk about values where it is not.In the earliest version of r-value references, movement happened easily. Too easily. Easily enough that there was a lot of potential for implicitly moving things when the user didn\'t really mean to.Here are the circumstances under which it is safe to move something:If you do this:What does this do? In older versions of the spec, before the 5 values came in, this would provoke a move. Of course it does. You passed an rvalue reference to the constructor, and thus it binds to the constructor that takes an rvalue reference. That\'s obvious.There\'s just one problem with this; you didn\'t ask to move it. Oh, you might say that the && should have been a clue, but that doesn\'t change the fact that it broke the rule. val isn\'t a temporary because temporaries don\'t have names. You may have extended the lifetime of the temporary, but that means it isn\'t temporary; it\'s just like any other stack variable.If it\'s not a temporary, and you didn\'t ask to move it, then moving is wrong.The obvious solution is to make val an lvalue. This means that you can\'t move from it. OK, fine; it\'s named, so its an lvalue.Once you do that, you can no longer say that SomeType&& means the same thing everwhere. You\'ve now made a distinction between named rvalue references and unnamed rvalue references. Well, named rvalue references are lvalues; that was our solution above. So what do we call unnamed rvalue references (the return value from Func above)?It\'s not an lvalue, because you can\'t move from an lvalue. And we need to be able to move by returning a &&; how else could you explicitly say to move something? That is what std::move returns, after all. It\'s not an rvalue (old-style), because it can be on the left side of an equation (things are actually a bit more complicated, see this question and the comments below). It is neither an lvalue nor an rvalue; it\'s a new kind of thing.What we have is a value that you can treat as an lvalue, except that it is implicitly moveable from. We call it an xvalue.Note that xvalues are what makes us gain the other two categories of values: A prvalue is really just the new name for the previous type of rvalue, i.e. they\'re the rvalues that aren\'t xvalues. The glvalues is the union of xvalues and lvalues in one group, because they do share a lot of properties in common.So really, it all comes down to xvalues and the need to restrict movement to exactly and only certain places. Those places are defined by the rvalue category; prvalues are the implicit moves, and xvalues are the explicit moves (std::move returns an xvalue).IMHO, the best explanation about its meaning gave us Stroustrup + take into account examples of D\xc3\xa1niel S\xc3\xa1ndor and Mohan:Stroustrup:Now I was seriously worried. Clearly we were headed for an impasse or\n  a mess or both. I spent the lunchtime doing an analysis to see which\n  of the properties (of values) were independent. There were only two\n  independent properties:This led me to the conclusion that there are exactly three kinds of\n  values (using the regex notational trick of using a capital letter to\n  indicate a negative \xe2\x80\x93 I was in a hurry):In addition to these three fundamental classifications of values, we\n  have two obvious generalizations that correspond to the two\n  independent properties:This led me to put this diagram on the board:\n  I observed that we had only limited freedom to name: The two points to\n  the left (labeled iM and i) are what people with more or less\n  formality have called lvalues and the two points on the right\n  (labeled  m and Im) are what people with more or less formality\n  have called rvalues. This must be reflected in our naming. That is,\n  the left "leg" of the W should have names related to lvalue and the\n  right "leg" of the W should have names related to rvalue. I note\n  that this whole discussion/problem arise from the  introduction of\n  rvalue references and move semantics. These notions simply don\xe2\x80\x99t exist\n  in Strachey\xe2\x80\x99s world consisting of just rvalues and lvalues. Someone\n  observed that the ideas thatare deeply embedded in our consciousness, very useful properties, and\n  traces of this dichotomy can be found all over the draft standard. We\n  all agreed that we ought to preserve those properties (and make them\n  precise). This further constrained our naming choices. I observed that\n  the standard library wording uses rvalue to mean m (the\n  generalization), so that to preserve the expectation and text of the\n  standard library the right-hand bottom point of the W should be named\n  rvalue.This led to a focused discussion of naming. First, we needed to decide\n  on lvalue. Should lvalue mean iM or the generalization i? Led\n  by Doug Gregor, we listed the places in the core language wording\n  where the word lvalue was qualified to mean the one or the other. A\n  list was made and in most cases  and in the most tricky/brittle text\n  lvalue currently means iM. This is the classical meaning of lvalue\n  because "in the old days" nothing was moved; move is a novel notion\n  in C++0x. Also, naming the topleft point of the W lvalue gives us\n  the property that every value is an lvalue or an rvalue, but not both.So, the top left point of the W is lvalue and the bottom right point\n  is rvalue. What does that make the bottom left and top right points?\n  The bottom left point is a generalization of the classical lvalue,\n  allowing for move. So it is a generalized lvalue. We named it\n  glvalue. You can quibble about the abbreviation, but (I think) not\n  with the logic. We assumed that in serious use generalized lvalue\n  would somehow be abbreviated anyway, so we had better do it\n  immediately (or risk confusion). The top right point of the W is less\n  general than the bottom right (now, as ever, called rvalue). That\n  point represent the original pure notion of an object you can move\n  from because it cannot be referred to again (except by a destructor).\n  I liked the phrase specialized rvalue in contrast to generalized\n  lvalue but pure rvalue abbreviated to prvalue won out (and\n  probably rightly so). So, the left leg of the W is lvalue and\n  glvalue and the right leg is prvalue and rvalue. Incidentally,\n  every value is either a glvalue or a prvalue, but not both.This leaves the top middle of the W: im; that is, values that have\n  identity and can be moved. We really don\xe2\x80\x99t have anything that guides\n  us to a good name for those esoteric beasts. They are important to\n  people working with the (draft) standard text, but are unlikely to\n  become a household name. We didn\xe2\x80\x99t find any  real constraints on the\n  naming to guide us, so we picked \xe2\x80\x98x\xe2\x80\x99 for the center, the unknown, the\n  strange, the xpert only, or even x-rated.C++03\'s categories are too restricted to capture the introduction of rvalue references correctly into expression attributes. With the introduction of them, it was said that an unnamed rvalue reference evaluates to an rvalue, such that overload resolution would prefer rvalue reference bindings, which would make it select move constructors over copy constructors. But it was found that this causes problems all around, for example with Dynamic Types and with qualifications. To show this, considerOn pre-xvalue drafts, this was allowed, because in C++03, rvalues of non-class types are never cv-qualified. But it is intended that const applies in the rvalue-reference case, because here we do refer to objects (= memory!), and dropping const from non-class rvalues is mainly for the reason that there is no object around. The issue for dynamic types is of similar nature. In C++03, rvalues of class type have a known dynamic type - it\'s the static type of that expression. Because to have it another way, you need references or dereferences, which evaluate to an lvalue. That isn\'t true with unnamed rvalue references, yet they can show polymorphic behavior. So to solve it, unnamed rvalue references become xvalues. They can be qualified and potentially have their dynamic type different. They do, like intended, prefer rvalue references during overloading, and won\'t bind to non-const lvalue references. What previously was an rvalue (literals, objects created by casts to non-reference types) now becomes an prvalue. They have the same preference as xvalues during overloading. What previously was an lvalue stays an lvalue. And two groupings are done to capture those that can be qualified and can have different dynamic types (glvalues) and those where overloading prefers rvalue reference binding (rvalues). ISOC++11 (officially ISO/IEC 14882:2011) is the most recent version of the standard of the C++ programming language. It contains some new features, and concepts, for example:If we would like to understand the concepts of the new expression value categories we have to be aware of that there are rvalue and lvalue references.\nIt is better to know rvalues can be passed to non-const rvalue references.We can gain some intuition of the concepts of value categories if we quote the subsection titled Lvalues and rvalues from the working draft N3337 (the most similar draft to the published ISOC++11 standard).3.10 Lvalues and rvalues [basic.lval]1 Expressions are categorized according to the taxonomy in Figure 1.Every expression belongs to exactly one of the fundamental\n  classifications in this taxonomy: lvalue, xvalue, or prvalue. This\n  property of an expression is called its value category.But I am not quite sure about that this subsection is enough to understand the concepts clearly, because "usually" is not really general, "near the end of its lifetime" is not really concrete, "involving rvalue references" is not really clear, and "Example: The result of calling a function whose return type is an rvalue reference is an xvalue." sounds like a snake is biting its tail.Every expression belongs to exactly one primary value category. These value categories are lvalue, xvalue and prvalue categories.The expression E belongs to the lvalue category if and only if E refers to an entity that ALREADY has had an identity (address, name or alias) that makes it accessible outside of E.The expression E belongs to the xvalue category if and only if it is\xe2\x80\x94 the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to the type of object being returned, or\xe2\x80\x94 a cast to an rvalue reference to object type, or\xe2\x80\x94 a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or\xe2\x80\x94 a pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.Note that the effect of the rules above is that named rvalue references to objects are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not.The expression E belongs to the prvalue category if and only if E belongs neither to the lvalue nor to the xvalue category.There are two further important mixed value categories. These value categories are rvalue and glvalue categories.The expression E belongs to the rvalue category if and only if E belongs to the xvalue category, or to the prvalue category.Note that this definition means that the expression E belongs to the rvalue category if and only if E refers to an entity that has not had any identity that makes it accessible outside of E YET.The expression E belongs to the glvalue category if and only if E belongs to the lvalue category, or to the xvalue category.Scott Meyer has published a very useful rule of thumb to distinguish rvalues from lvalues.How do these new categories relate to the existing rvalue and lvalue categories?A C++03 lvalue is still a C++11 lvalue, whereas a C++03 rvalue is called a prvalue in C++11.I have struggled with this for a long time, until I came across the cppreference.com explanation of the value categories.It is actually rather simple, but I find that it is often explained in a way that\'s hard to memorize. Here it is explained very schematically. I\'ll quote some parts of the page:The primary value categories correspond to two properties of expressions:has identity: it\'s possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly);can be moved from: move constructor, move assignment operator, or another function overload that implements move semantics can bind to the expression.Expressions that:An lvalue ("left value") expression is an expression that has identity and cannot be moved from. A prvalue ("pure rvalue") expression is an expression that does not have identity and can be moved from.An xvalue ("expiring value") expression is an expression that has identity and can be moved from.A glvalue ("generalized lvalue") expression is an expression that is either an lvalue or an xvalue. It has identity. It may or may not be moved from.An rvalue ("right value") expression is an expression that is either a prvalue or an xvalue. It can be moved from. It may or may not have identity.One addendum to the excellent answers above, on a point that confused me even after I had read Stroustrup and thought I understood the rvalue/lvalue distinction. When you see int&& a = 3,it\'s very tempting to read the int&& as a type and conclude that a is an rvalue. It\'s not: a has a name and is ipso facto an lvalue. Don\'t think of the && as part of the type of a; it\'s just something telling you what a is allowed to bind to. This matters particularly for T&& type arguments in constructors. If you write Foo::Foo(T&& _t) : t{_t} {}you will copy _t into t. You need Foo::Foo(T&& _t) : t{std::move(_t)} {} if you want to move. Would that my compiler warned me when I left out the move!