What are the options to clone or copy a list in Python?Using new_list = my_list then modifies new_list every time my_list changes.\nWhy is this?With new_list = my_list, you don\'t actually have two lists. The assignment just copies the reference to the list, not the actual list, so both new_list and my_list refer to the same list after the assignment.To actually copy the list, you have various possibilities:You can slice it: Alex Martelli\'s opinion (at least back in 2007) about this is, that it is a weird syntax and it does not make sense to use it ever. ;) (In his opinion, the next one is more readable).You can use the built in list() function:You can use generic copy.copy():This is a little slower than list() because it has to find out the datatype of old_list first.If the list contains objects and you want to copy them as well, use generic copy.deepcopy():Obviously the slowest and most memory-needing method, but sometimes unavoidable.Example:Result:Felix already provided an excellent answer, but I thought I\'d do a speed comparison of the various methods:So the fastest is list slicing. But be aware that copy.copy(), list[:] and list(list), unlike copy.deepcopy() and the python version don\'t copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.(Here\'s the script if anyone\'s interested or wants to raise any issues:)EDIT: Added new-style, old-style classes and dicts to the benchmarks, and made the python version much faster and added some more methods including list expressions and extend().I\'ve been told that Python 3.3+ adds list.copy() method, which should be as fast as slicing:newlist = old_list.copy()There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing equivalent objects.A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists. There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:You can also accomplish the same thing by passing the list through the list constructor, but using the constructor is less efficient:In Python 3, lists get the list.copy method:In Python 3.5:Using new_list = my_list then modifies new_list every time my_list changes. Why is this?my_list is a pointer to the actual list in memory. When you say new_list = my_list you\'re not making a copy, you\'re just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists. The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.To make a deep copy of a list, in Python 2 or 3, use deepcopy in the copy module:To demonstrate how this allows us to make new sub-lists:And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don\'t. You\'re likely to create bugs you otherwise wouldn\'t have by using the standard library\'s deepcopy function.You may see this used as a way to deepcopy, but don\'t do it:In 64 bit Python 2.7:on 64 bit Python 3.5:This answer is only for Python 2. I haven\'t upgraded to Python 3 yet. There are many answers already that tell you how to make a proper copy, but none of them say why your original \'copy\' failed. Python doesn\'t store values in variables; it binds names to objects. Your original assignment took the object referred to by my_list and bound it to new_list as well. No matter which name you use there is still only one list, so changes made when referring to it as my_list will persist when referring to it as new_list. Each of the other answers to this question give you different ways of creating a new object to bind to new_list. Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list. This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy. See the documentation for more information about corner cases in copying.new_list = list(old_list)Python\'s idiom for doing this is newList = oldList[:]Use thing[:]All of the other contributors gave great answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only copy.deepcopy() works to clone/copy a list and not have it point to the nested list objects when you are working with multidimensional, nested lists (list of lists). While Felix Kling refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to deepcopy.While new_list = old_list[:], copy.copy(old_list)\' and for Py3k old_list.copy() work for single-leveled lists, they revert to pointing at the list objects nested within the old_list and the new_list, and changes to one of the list objects are perpetuated in the other. As was pointed out by both Aaron Hall and PM 2Ring using eval() is not only a bad idea, it is also much slower than copy.deepcopy(). This means that for multidimensional lists, the only option is copy.deepcopy(). With that being said, it really isn\'t an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to timeit using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.As others have stated, there can be are significant performance issues using the copy module and copy.deepcopy for multidimensional lists.  Trying to work out a different way of copying the multidimensional list without using deepcopy, (I was working on a problem for a course that only allows 5 seconds for the entire algorithm to run in order to receive credit), I came up with a way of using built-in functions to make a copy of the nested list without having them point at one another or at the list objects nested within them. I used eval() and repr() in the assignment to make the copy of the old list into the new list without creating a link to the old list. It takes the form of:Basically what this does is make a representation of old_list as a string and then evaluates the string as if it were the object that the string represents. By doing this, no link to the original list object is made. A new list object is created and each variable points to its own independent object. Here is an example using a 2 dimensional nested list.If you then check the contents of each list, for example a 4 by 3 list, Python will return While this probably isn\'t the canonical or syntactically correct way to do it, it seems to work well. I haven\'t tested performance, but I am going to guess that eval() and rep() will have less overhead to run than deepcopy will. Unlike other languages have variable and value, python has name and object.means give the list(object) a name "a", the just gives the same object a new name "b", so whenever you do something with a, the object changes and therefore b changes. The only way to make a really copy of a is to create a new object like other answers have said.You can see more about this hereHere are the timing results using Python 3.6.0. Keep in mind these times are relative to one another, not absolute.I stuck to only doing shallow copies, and also added some new methods that weren\'t possible in Python2, such as list.copy() (the Python3 slice equivalent) and list unpacking (*new_list, = list):We can see the old winner still comes out on top, but not really by a huge amount, considering the increased readability of the Python3 list.copy() approach.Note that these methods do not output equivalent results for any input other than lists. They all work for sliceable objects, a few work for any iterable, but only copy.copy() works for any Python object.Here is the testing code for interested parties (Template from here):new_list = my_list\nTry to understand this. Let\'s say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning new_list = my_list you\'re Letting new_list pointing to the X. This is known as shallow Copy.                                                              Now if you assign new_list = my_list[:] You\'re simply copying each object of my_list to new_list. This is known as Deep copy.The Other way you can do this are :Not sure if this is still actual, but the same behavior holds for dictionaries as well. Look at this example.Another method (that I feel is fairly readable) is to turn it into a string and then switch it back to a list.