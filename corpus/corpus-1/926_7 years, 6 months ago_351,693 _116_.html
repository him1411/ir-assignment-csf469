I\'m learning C++ and I\'m just getting into Virtual Functions.From what I\'ve read (in the book and online), virtual functions are functions in the a base class that you can override in derived classes.But earlier in the book, when learning about basic inheritance, I was able to override base functions in derived classes without using virtual.So what am I missing here? I know there is more to virtual functions and it seems to be important so I want to be clear on what it is exactly. I just can\'t find a straight answer online.I\'m a C++ newbie myself, but here is how I understood not just what virtual functions are, but why they\'re required:Let\'s say you have these two classes:In your main function:So far so good right? Animals eat generic food, cats eat rats, all without virtual.Let\'s change it a little now so that eat() is called via an intermediate function (a trivial function just for this example):Now our main function is:Uh oh... we passed a Cat into func(), but it won\'t eat rats. Should you overload func() so it takes a Cat* ? If you have to derive more animals from Animal they would all need their own func().The solution is to make eat() from Animal class a virtual function:Main:Done.Without "virtual" you get "early binding". Which implementation of the method is used gets decided at compile time based on the type of the pointer that you call through.With "virtual" you get "late binding". Which implementation of the method is used gets decided at run time based on the type of the pointed-to object - what it was originally constructed as. This is not necessarily what you\'d think based on the type of the pointer that points to that object.EDIT - see this question.Also - this tutorial covers early and late binding in C++.You need at least 1 level of inheritance and a downcast to demonstrate it. Here is a very simple  example:If the base class is Base, and a derived class is Der, you can have a Base *p pointer which actually points to an instance of Der.  When you call p->foo();, if foo is not virtual, then Base\'s version of it executes, ignoring the fact that p actually points to a Der.  If foo is virtual, p->foo() executes the "leafmost" override of foo, fully taking into account the actual class of the pointed-to item.  So the difference between virtual and non-virtual is actually pretty crucial: the former allow runtime polymorphism, the core concept of OO programming, while the latter don\'t.You need virtual methods for safe downcasting, simplicity and conciseness.That’s what virtual methods do: they downcast safely, with apparently simple and concise code, avoiding the unsafe manual casts in the more complex and verbose code that you otherwise would have.The following code is intentionally “incorrect”. It doesn’t declare the value method as virtual, and therefore produces an unintended “wrong” result, namely 0:In the line commented as “bad” the Expression::value method is called, because the statically known type (the type known at compile time) is Expression, and the value method is not virtual.Declaring value as virtual in the statically known type Expression ensures that the each call will check what actual type of object this is, and call the relevant implementation of value for that dynamic type:Here the output is 6.86 as it should be, since the virtual method is called virtually. This is also called dynamic binding of the calls. A little check is performed, finding the actual dynamic type of object, and the relevant method implementation for that dynamic type, is called.The relevant implementation is the one in the most specific (most derived) class.Note that method implementations in derived classes here are not marked virtual, but are instead marked override. They could be marked virtual but they’re automatically virtual. The override keyword ensures that if there is not such a virtual method in some base class, then you’ll get an error (which is desirable).Without virtual one would have to implement some Do It Yourself version of the dynamic binding. It’s this that generally involves unsafe manual downcasting, complexity and verbosity.For the case of a single function, as here, it suffices to store a function pointer in the object and call via that function pointer, but even so it involves some unsafe downcasts, complexity and verbosity, to wit:One positive way of looking at this is, if you encounter unsafe downcasting, complexity and verbosity as above, then often a virtual method or methods can really help.Need for Virtual Function explained [Easy to understand]Output will be:But with virtual function:Output will be:Hence with virtual function you can achieve runtime polymorphism. You have to distinguish between overriding and overloading. Without the virtual keyword you only overload a method of a base class. This means nothing but hiding.\nLet\'s say you have a base class Base and a derived class Specialized which both implement void foo(). Now you have a pointer to Base pointing to an instance of Specialized. When you call foo() on it you can observe the difference that virtual makes: If the method is virtual, the implementation of Specialized will be used, if it is missing, the version from Base will be chosen.\nIt is best practice to never overload methods from a base class. Making a method non-virtual is the way of its author to tell you that its extension in subclasses is not intended.When you have a function in the base class, you can Redefine or Override it in the derived class. Redefining a method :\nA new implementation for the method of base class is given in the derived class. Does not facilitate Dynamic binding.Overriding a method:\nRedefining a virtual method of the base class in the derived class. Virtual method facilitates Dynamic Binding.So when you said :But earlier in the book, when learning about basic inheritance,  I was\n  able to override base methods in derived classes without using\n  \'virtual\'.you were not overriding it as the method in the base class was not virtual, rather you were redefining itWhy do we need Virtual Methods in C++?In Bjarne Stroustrup C++ Programming: Principles and Practice, (14.3):The virtual function provides the ability to define a function in a base class and have a function of the same name and type in a derived class called when a user calls the base class function. That is often called run-time polymorphism, dynamic dispatch, or run-time dispatch because the function called is determined at run time based on the type of the object used.To handle a virtual call, one needs one or more pieces of data related to the derived object 3. The way that is usually done is to add the address of table of functions. This table is usually referred to as virtual table or virtual function table and its address is often called the virtual pointer. Each virtual function gets a slot in the virtual table. Depending of the caller\'s object (derived) type, the virtual function, in its turn, invokes the respective override.   1.The use of inheritance, run-time polymorphism, and encapsulation is the most common definition of object-oriented programming.2. You can\'t code functionality to be any faster or to use less memory using other language features to select among alternatives at run time. Bjarne Stroustrup C++ Programming: Principles and Practice.(14.3.1).3. Something to tell which function is really invoked when we call the base class containing the virtual function.It helps if you know the underlying mechanisms. C++ formalizes some coding techniques used by C programmers, "classes" replaced using "overlays" - structs with common header sections would be used to handle objects of different types but with some common data or operations. Normally the base struct of the overlay (the common part) has a pointer to a function table which points to a different set of routines for each object type. C++ does the same thing but hides the mechanisms i.e. the C++ ptr->func(...) where func is virtual as C would be (*ptr->func_table[func_num])(ptr,...), where what changes between derived classes is the func_table contents. [A non-virtual method ptr->func() just translates to mangled_func(ptr,..).]The upshot of that is that you only need to understand the base class in order to call the methods of a derived class, i.e. if a routine understands class A, you can pass it a derived class B pointer then the virtual methods called will be those of B rather than A since you go through the function table B points at.Virtual Functions are used to support Run time Polymorphism.That is, virtual keyword tells the compiler not to make the decision (of function binding) at compile time, rather postpone it for run time".You can make a function virtual by preceding the keyword virtual in it\'s base class declaration. For example,When a Base Class has a virtual member function, any class that inherits from the Base Class can redefine the function with exactly the same prototype i.e. only functionality can be redefined, not the interface of the function. A Base class pointer can be used to point to Base class object as well as Derived class object. The keyword virtual tells the compiler it should not perform early binding. Instead, it should automatically install all the mechanisms necessary to perform late binding.\nTo accomplish this, the typical compiler1 creates a single table (called the VTABLE) for each class that contains virtual functions.The compiler places the addresses of the virtual functions for that particular class in the VTABLE. In each class with virtual functions,it secretly places a pointer, called the vpointer (abbreviated as VPTR), which points to the VTABLE for that object.\nWhen you make a virtual function call through a base-class pointer the compiler quietly inserts code to fetch the VPTR and look up the function address in the VTABLE, thus calling the correct function and causing late binding to take place.More details in this link\nhttp://cplusplusinterviews.blogspot.sg/2015/04/virtual-mechanism.htmlI would like to add another use of Virtual function though it uses the same concept as above stated answers but I guess its worth mentioning.VIRTUAL DESTRUCTORConsider this program below, without declaring Base class destructor as virtual; memory for Cat may not be cleaned up.Output:Deleting an AnimalOutput:Deleting an Animal name CatDeleting an Animal(Sorry, I\'m a beginner, and this answer might have mistakes, but I\'m going to share my research with you) I\'ve written it in a form of conversation to be a better read:............................................................................Why do we need virtual functions?Because of Polymorphism.What is Polymorphism?The fact that a base pointer can also point to derived type objects.How does this definition of Polymorphism lead into the need for virtual functions?Well, through early binding.What is early binding?Early binding(compile-time binding) in C++ means that a function call is fixed before the program is executed.So...?So if you use a base type as the parameter of a function, the compiler will only recognize the base interface, and if you call that function with any arguments from derived classes, it gets sliced off, which is not what you want to happen.If it\'s not what we want to happen, why is this allowed?Because we need Polymorphism!What\'s the benefit of Polymorphism then?You can use a base type pointer as the parameter of a single function, and then in the run-time of your program, you can access each of the derived type interfaces(e.g. their member functions) without any issues, using dereferencing of that single base pointer.I still don\'t know what virtual functions are good for...! And this was my first question!well, this is because you asked your question too soon!Why do we need virtual functions?Assume that you called a function with a base pointer, which had the address of an object from one of its derived classes. As we\'ve talked about it above, in the run-time, this pointer gets dereferenced, so far so good, however, we expect a method(== a member function) "from our derived class" to be executed! However, a same method(one that has a same header) is already defined in the base class, so why should your program bother to choose the other method? In other words I mean, how can you tell this scenario off from what we used to see normally happen before?The brief answer is "a Virtual member function in base", and a little longer answer is that, "at this step, if the program sees a virtual function in the base class, it knows(realizes) that you\'re trying to use polymorphism" and so goes to derived classes(using v-table, a form of late binding) to find that another method with the same header, but with -expectedly- a different implementation.Why a different implementation?You knuckle-head! Go read a good book!OK, wait wait wait, why would one bother to use base pointers, when he/she could simply use derived type pointers? You be the judge, is all this headache worth it? Look at these two snippets://1://2:OK, although I think that 1 is still better than 2, you could write 1 like this either://1:and moreover, you should be aware that this is yet just a contrived use of all the things I\'ve explained to you so far. Instead of this, assume for example a situation in which you had a function in your program that used the methods from each of the derived classes respectively(getMonthBenefit()):Now, try to re-write this, without any headaches!And actually, this might be yet a contrived example either!About efficiency, the virtual functions are slightly less efficient as the early-binding functions. "This virtual call mechanism can be made almost as efficient as the "normal function call" mechanism (within 25%). Its space overhead is one pointer in each object of a class with virtual functions plus one vtbl for each such class" [A tour of C++ by Bjarne Stroustrup]Virtual methods are used in interface design.  For example in Windows there is an interface called IUnknown like below:These methods are left to the interface user to implement.  They are essential for the creation and destruction of certain objects that must inherit IUnknown.  In this case the run-time is aware of the three methods and expects them to be implemented when it calls them.  So in a sense they act as a contract between the object itself and whatever uses that object.  We need virtual methods for supporting "Run time Polymorphism". \nWhen you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class\'s version of the function.The virtual keyword forces the compiler to pick the method implementation defined in the object\'s class rather than in the pointer\'s class.  In the above example, Shape::getName will be called by default, unless the getName() is defined as virtual in the Base class Shape. This forces the compiler to look for the getName() implementation in the Triangle class rather than in the Shape class. The virtual table is the mechanism in which the compiler keeps track of the various virtual-method implementations of the subclasses. This is also called dynamic dispatch, and there is some overhead associated with it. Finally, why is virtual even needed in C++, why not make it the default behavior like in Java? why do we need virtual functions ?\nVirtual functions avoid unnecessary typecasting problem, some of us can debate that why do we need virtual functions when we can use derived class pointer to call the function specific in derived class!the answer is - it nullifies the whole idea of inheritance in large system development, where having single pointer base class object is much desired.Let`s compare below two simple programs to understand the importance of virtual functions:\nProgram without Virtual function:OUTPUT:Program with virtual function:OUTPUT:By closely analyzing both the outputs one can understand the importance of virtual function.