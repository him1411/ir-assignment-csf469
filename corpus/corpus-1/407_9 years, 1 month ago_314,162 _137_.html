Inversion of Control (or IoC) can be quite confusing when it is first encountered.The Inversion of Control (IoC) and Dependency Injection (DI) patterns are all about removing dependencies from your code.For example, say your application has a text editor component and you want to provide spell checking. Your standard code would look something like this:What we\'ve done here creates a dependency between the TextEditor and the SpellChecker.\nIn an IoC scenario we would instead do something like this:In the first code example we are instantiating SpellChecker (this.checker = new SpellChecker();), which means the TextEditor class directly depends on the SpellChecker class.In the second code example we are creating an abstraction by having the SpellChecker dependency class in TextEditor constructor signature (not initializing dependency in class). This allows us to call the dependency then pass it to the TextEditor class like so:Now the client creating the TextEditor class has the control over which SpellChecker implementation to use because we\'re injecting the dependency to the TextEditor signature.This is just a simple example, there\'s a good series of articles by Simone Busoli that explains it in greater detail.Inversion of Control is what you get when your program callbacks, e.g. like a gui program.For example, in an old school menu, you might have:thereby controlling the flow of user interaction.In a GUI program or somesuch, instead we saySo now control is inverted... instead of the computer accepting user input in a fixed order, the user controls the order in which the data is entered, and when the data is saved in the database.Basically, anything with an event loop, callbacks, or execute triggers falls into this category.What is Inversion of Control?If you follow these simple two steps, you have done inversion of control:There are several techniques possible for each of these steps based on the technology/language you are using for your implementation.--The inversion part of the Inversion of Control (IoC) is the confusing thing; because inversion is the relative term. The best way to understand IoC is to forget about that word!--ExamplesBefore using Inversion of Control you should be well aware of the fact that it has its pros and cons and you should know why you use it if you do so.Pros:Cons:Personally I see the strong points of IoC and I really like them but I tend to avoid IoC whenever possible because it turns your software into a collection of classes that no longer constitute a "real" program but just something that needs to be put together by XML configuration or annotation metadata and would fall (and falls) apart without it.Inversion of Control, (or IoC), is about getting freedom (You get married, you lost freedom and you are being controlled. You divorced, you have just implemented Inversion of Control. That\'s what we called, "decoupled". Good computer system discourages some very close relationship.) more flexibility (The kitchen in your office only serves clean tap water, that is your only choice when you want to drink. Your boss implemented Inversion of Control by setting up a new coffee machine. Now you get the flexibility of choosing either tap water or coffee.) and less dependency (Your partner has a job, you don\'t have a job, you financially depend on your partner, so you are controlled. You find a job, you have implemented Inversion of Control. Good computer system encourages in-dependency.)When you use a desktop computer, you have slaved (or say, controlled). You have to sit before a screen and look at it. Using the keyboard to type and using the mouse to navigate. And a badly written software can slave you even more. If you replace your desktop with a laptop, then you somewhat inverted control. You can easily take it and move around. So now you can control where you are with your computer, instead of your computer controlling it.By implementing Inversion of Control, a software/object consumer get more controls/options over the software/objects, instead of being controlled or having fewer options.With the above ideas in mind. We still miss a key part of IoC. In the scenario of IoC, the software/object consumer is a sophisticated framework. That means the code you created is not called by yourself. Now let\'s explain why this way works better for a web application.Suppose your code is a group of workers. They need to build a car. These workers need a place and tools (a software framework) to build the car. A traditional software framework will be like a garage with many tools. So the workers need to make a plan themselves and use the tools to build the car. Building a car is not an easy business, it will be really hard for the workers to plan and cooperate properly. A modern software framework will be like a modern car factory with all the facilities and managers in place. The workers do not have to make any plan, the managers (part of the framework, they are the smartest people and made the most sophisticated plan) will help coordinate so that the workers know when to do their job (framework calls your code). The workers just need to be flexible enough to use any tools the managers give to them (by using Dependency Injection).Although the workers give the control of managing the project on the top level to the managers (the framework). But it is good to have some professionals help out. This is the concept of IoC truly come from.Modern Web applications with an MVC architecture depends on the framework to do URL Routing and put Controllers in place for the framework to call. Dependency Injection and Inversion of Control are related. Dependency Injection is at the micro level and Inversion of Control is at the macro level. You have to eat every bite (implement DI) in order to finish a meal (implement IoC).Inversion of Controls is about separating concerns. Without IoC: You have a laptop computer and you accidentally break the screen. And darn, you find the same model laptop screen is nowhere in the market. So you\'re stuck.With IoC: You have a desktop computer and you accidentally break the screen. You find you can just grab almost any desktop monitor from the market, and it works well with your desktop.Your desktop successfully implements IoC in this case. It accepts a variety type of monitors, while the laptop does not, it needs a specific screen to get fixed.Wikipedia Article. To me, inversion of control is turning your sequentially written code and turning it into an delegation structure. Instead of your program explicitly controlling everything, your program sets up a class or library with certain functions to be called when certain things happen.It solves code duplication. For example, in the old days you would manually write your own event loop, polling the system libraries for new events. Nowadays, most modern APIs you simply tell the system libraries what events you\'re interested in, and it will let you know when they happen.Inversion of control is a practical way to reduce code duplication, and if you find yourself copying an entire method and only changing a small piece of the code, you can consider tackling it with inversion of control. Inversion of control is made easy in many languages through the concept of delegates, interfaces, or even raw function pointers. It is not appropriate to use in all cases, because the flow of a program can be harder to follow when written this way. It\'s a useful way to design methods when writing a library that will be reused, but it should be used sparingly in the core of your own program unless it really solves a code duplication problem.But I think you have to be very careful with it. If you will overuse this pattern, you will make very complicated design and even more complicated code. Like in this example with TextEditor: if you have only one SpellChecker maybe it is not really necessary to use IoC ? Unless you need to write unit tests or something ...Anyway: be reasonable. Design pattern are good practices but not Bible to be preached. Do not stick it everywhere.IoC / DI to me is pushing out dependencies to the calling objects. Super simple.The non-techy answer is being able to swap out an engine in a car right before you turn it on. If everything hooks up right (the interface), you are good.Suppose you are an object. And you go to a restaurant:Without IoC: you ask for "apple", and you are always served apple when you ask more. With IoC: You can ask for "fruit". You can get different fruits each time you get served. for example, apple, orange, or water melon. So, obviously, IoC is preferred when you like the varieties.Inversion of control is a pattern used for decoupling components and layers in the system. The pattern is implemented through injecting dependencies into a component when it is constructed. These dependences are usually provided as interfaces for further decoupling and to support testability. IoC / DI containers such as Castle Windsor, Unity are tools (libraries) which can be used for providing IoC. These tools provide extended features above and beyond simple dependency management, including lifetime, AOP / Interception, policy, etc.a. Alleviates a component from being responsible for managing it\'s dependencies.\nb. Provides the ability to swap dependency implementations in different environments.\nc. Allows a component be tested through mocking of dependencies.\nd. Provides a mechanism for sharing resources throughout an application.a. Critical when doing test-driven development. Without IoC it can be difficult to test, because the components under test are highly coupled to the rest of the system.\nb. Critical when developing modular systems. A modular system is a system whose components can be replaced without requiring recompilation.\nc. Critical if there are many cross-cutting concerns which need to addressed, partilarly in an enterprise application.For example, task#1 is to create object.\nWithout IOC concept, task#1 is supposed to be done by Programmer.But With IOC concept, task#1 would be done by container.In short Control gets inverted from Programmer to container. So, it is called as inversion of control.I found one good example here.It seems that the most confusing thing about "IoC" the acronym and the name for which it stands is that it\'s too glamorous of a name - almost a noise name.Do we really need a name by which to describe the difference between procedural and event driven programming? OK, if we need to, but do we need to pick a brand new "bigger than life" name that confuses more than it solves?I shall write down my simple understanding of this two terms:Dependency Injection(DI):\nDependency injection generally means passing an object on which method depends, as a parameter to a method, rather than having the method create the dependent object. What it means in practice is that the method does not depends directly on a particular implementation; any implementation that meets the requirements can be passed as a parameter.\nWith this objects tell thier dependencies.\nAnd spring makes it available. This leads to loosely coupled application development.Inversion of Control(IoC) Container:\nThis is common characteristic of frameworks,\nIOC manages java objects \xe2\x80\x93 from instantiation to destruction through its BeanFactory. -Java components that are instantiated by the IoC container are called beans, and the IoC container manages a bean\'s scope, lifecycle events, and any AOP features for which it has been configured and coded.QUICK EXAMPLE:Inversion of Control is about getting freedom, more flexibility, and less dependency. When you are using a desktop computer, you are slaved (or say, controlled). You have to sit before a screen and look at it. Using keyboard to type and using mouse to navigate. And a bad written software can slave you even more. If you replaced your desktop with a laptop, then you somewhat inverted control. You can easily take it and move around. So now you can control where you are with your computer, instead of computer controlling it.By implementing Inversion of Control, a software/object consumer get more controls/options over the software/objects, instead of being controlled or having less options.Inversion of control as a design guideline serves the following purposes:There is a decoupling of the execution of a certain task from implementation.\nEvery module can focus on what it is designed for.\nModules make no assumptions about what other systems do but rely on their contracts.\nReplacing modules has no side effect on other modules I will keep things abstract here, You can visit following links for detail understanding of the topic.\nA good read with exampleDetailed explanationI agree with NilObject, but I\'d like to add to this:if you find yourself copying an entire method and only changing a small piece of the code, you can consider tackling it with inversion of controlIf you find yourself copying and pasting code around, you\'re almost always doing something wrong.  Codified as the design principle Once and Only Once.Let to say that we make some meeting in some hotel.Many people, many carafes of water, many plastic cups.When somebody want to drink, she fill cup, drink and throw cup on the floor.After hour or something we have a floor covered of plastic cups and water.Let invert control.The same meeting in the same place, but instead of plastic cups we have a waiter with one glass cup (Singleton)and she all of time offers to guests drinking.When somebody want to drink, she get from waiter glass, drink and return it back to waiter.Leaving aside the question of the hygienic, last form of drinking process control is much more effective and economic.And this is exactly what the Spring (another IoC container, for example: Guice) does. Instead of let to application create what it need using new keyword (taking plastic cup), Spring IoC container all of time offer to application the same instance (singleton) of needed object(glass of water).Think about yourself as organizer of such meeting. You need the way to message to hotel administration thatmeeting members will need glass of water but not piece of cake.Example:-Useful links:-IoC is about inverting the relationship between your code and third-party code (library/framework):DI (Dependency Injection) is about how the control flows in the application. Traditional desktop application had control flow from your application(main() method) to other library method calls, but with DI control flow is inverted that\'s framework takes care of starting your app, initializing it and invoking your methods whenever required.In the end you always win :)A very simple written explanation can be found herehttp://binstock.blogspot.in/2008/01/excellent-explanation-of-dependency.htmlit says"Any nontrivial application is made up of two or more classes that\n  collaborate with each other to perform some business logic.\n  Traditionally, each object is responsible for obtaining its own\n  references to the objects it collaborates with (its dependencies).\n  When applying DI, the objects are given their dependencies at creation\n  time by some external entity that coordinates each object in the\n  system. In other words, dependencies are injected into objects."Programming speaking IoC in easy terms: It\'s the use of Interface as a way of specific something (such a field or a parameter) as a wildcard that can be used by some classes. It allows the re-usability of the code.For example, let\'s say that we have two classes : Dog and Cat.   Both shares the same qualities/states: age, size, weight. So instead of creating a class of service called DogService and CatService, I can create a single one called AnimalService that allows to use Dog and Cat only if they use the interface IAnimal.However, pragmatically speaking, it has some backwards.a) Most of the developers don\'t know how to use it.  For example, I can create a class called Customer and I can create automatically (using the tools of the IDE) an interface called ICustomer. So, it\'s not rare to find a folder filled with classes and interfaces, no matter if the interfaces will be reused or not. It\'s called BLOATED. Some people could argue that "may be in the future we could use it".  :-|b) It has some limitings. For example, let\'s talk about the case of Dog and Cat and I want to add a new service (functionality) only for dogs.  Let\'s say that I want to calculate the number of days that I need to train a dog (trainDays()), for cat it\'s useless, cats can\'t be trained (I\'m joking).b.1) If I add trainDays() to the Service AnimalService then it also works with cats and it\'s not valid at all.b.2) I can add a condition in trainDays() where it evaluates which class is used. But it will break completely the IoC.b.3) I can create a new class of service called DogService just for the new functionality. But, it will increase the maintainability of the code because we will have two classes of service (with similar functionality) for Dog and it\'s bad.Answering only the first part.\nWhat is it?Inversion of Control (IoC) means to create instances of dependencies first and latter instance of a class (optionally injecting them through constructor), instead of creating an instance of the class first and then the class instance creating instances of dependencies.\nThus, inversion of control inverts the flow of control of the program.Inversion of Control is a generic principle, while Dependency Injection realises this principle as a design pattern for object graph construction (i.e. configuration controls how the objects are referencing each other, rather than the object itself controlling how to get the reference to another object).Looking at Inversion of Control as a design pattern, we need to look at what we are inverting.  Dependency Injection inverts control of constructing a graph of objects. If told in layman\'s term, inversion of control implies change in flow of control in the program. Eg. In traditional standalone app, we have main method, from where the control gets passed to other third party libraries(in case, we have used third party library\'s function), but through inversion of control control gets transferred from third party library code to our code, as we are taking the service of third party library.  But there are other aspects that need to be inverted within a program - e.g. invocation of methods and threads to execute the code.For those interested in more depth on Inversion of Control a paper has been published outlining a more complete picture of Inversion of Control as a design pattern (OfficeFloor: using office patterns to improve software design http://doi.acm.org/10.1145/2739011.2739013 with a free copy available to download from http://www.officefloor.net/mission.html)What is identified is the following relationship:Inversion of Control (for methods) = Dependency (state) Injection + Continuation Injection + Thread InjectionSo number 1 above. What is Inversion of Control?Maintenance is the number one thing it solves for me.  It guarantees I am using interfaces so that two classes are not intimate with each other. In using a container like Castle Windsor, it solves maintenance issues even better.  Being able to swap out a component that goes to a database for one that uses file based persistence without changing a line of code is awesome (configuration change, you\'re done).And once you get into generics, it gets even better.  Imagine having a message publisher that receives records and publishes messages.  It doesn\'t care what it publishes, but it needs a mapper to take something from a record to a message.I wrote it once, but now I can inject many types into this set of code if I publish different types of messages.  I can also write mappers that take a record of the same type and map them to different messages. Using DI with Generics has given me the ability to write very little code to accomplish many tasks.Oh yeah, there are testability concerns, but they are secondary to the benefits of IoC/DI. I am definitely loving IoC/DI.3 . It becomes more appropriate the minute you have a medium sized project of somewhat more complexity.  I would say it becomes appropriate the minute you start feeling pain.Creating an object within class is called tight coupling, Spring removes this dependency by following a design pattern(DI/IOC). In which object of class in passed in constructor rather than creating in class. More over we give super class reference variable in constructor to define more general structure.To understanding the concept, Inversion of Control (IoC) or Dependency Inversion Principle (DIP) involves two activities: abstraction, and inversion.\nDependency Injection (DI) is just one of the few of the inversion methods.To read more about this you can read my blog  HereIt is a practice where you let the actual behavior come from outside of the boundary (Class in Object Oriented Programming). The boundary entity only knows the abstraction (e.g interface, abstract class, delegate in Object Oriented Programming) of it. In term of programming, IoC try to solve monolithic code by making it modular, decoupling various parts of it, and make it unit-testable. It is appropriate most of the time, unless you have situation where you just want monolithic code (e.g very simple program)I like this explanation: http://joelabrahamsson.com/inversion-of-control-an-introduction-with-examples-in-net/It start simple and shows code examples as well.The consumer, X, needs the consumed class, Y, to accomplish something. That\xe2\x80\x99s all good and natural, but does X really need to know that it uses Y?Isn\xe2\x80\x99t it enough that X knows that it uses something that has the behavior, the methods, properties etc, of Y without knowing who actually implements the behavior?By extracting an abstract definition of the behavior used by X in Y, illustrated as I below, and letting the consumer X use an instance of that instead of Y it can continue to do what it does without having to know the specifics about Y.In the illustration above Y implements I and X uses an instance of I. While it\xe2\x80\x99s quite possible that X still uses Y what\xe2\x80\x99s interesting is that X doesn\xe2\x80\x99t know that. It just knows that it uses something that implements I.Read article for further info and description of benefits such as:...IoC is also known as dependency injection (DI). It is a process\n  whereby objects define their dependencies, that is, the other objects\n  they work with, only through constructor arguments, arguments to a\n  factory method, or properties that are set on the object instance\n  after it is constructed or returned from a factory method. The\n  container then injects those dependencies when it creates the bean.\n  This process is fundamentally the inverse, hence the name Inversion of\n  Control (IoC), of the bean itself controlling the instantiation or\n  location of its dependencies by using direct construction of classes,\n  or a mechanism such as the Service Locator patternSpring-framework-referance.pfd\npage 34http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/pdf/spring-framework-reference.pdfUsing IoC you are not new\'ing up your objects. Your IoC container will do that and manage the lifetime of them.It solves the problem of having to manually change every instantiation of one type of object to another.It is appropriate when you have functionality that may change in the future or that may be different depending on the environment or configuration used in.The very first version of Java EE (J2EE at the time) introduced the concept of inversion of control (IoC), meaning that\nthe container would take control of your business code and provide technical services (such as transaction or security\nmanagement).