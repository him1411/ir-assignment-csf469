Good OverviewsGenerally speaking you\'re making a decision between fast read times (for example, nested set) or fast write times (adjacency list). Usually you end up with a combination of the options below that best fit your needs. The following provides some in depth reading:OptionsOnes I am aware of and general features:Database Specific NotesMySQLOraclePostgreSQLSQL ServerThis is kind of a question that is still interesting even after all big three vendors implemented a recursive WITH clause. I\'d suggest that different readers would be pleased with different answers.Some articles from my blog on the subject:Adjacency list vs. nested sets: SQL ServerHierarchical queries in MySQL (querying adjacency lists in MySQL)Joe Celko wrote the book on SQL Trees & HiearichiesThis is the first edition.  Look at the second edition in Bob\'s comment.My favorite answer is as what the first sentence in this thread suggested.  Use an Adjacency List to maintain the hierarchy and use Nested Sets to query the hierarchy.The problem up until now has been that the coversion method from an Adjacecy List to Nested Sets has been frightfully slow because most people use the extreme RBAR method known as a "Push Stack" to do the conversion and has been considered to be way to expensive to reach the Nirvana of the simplicity of maintenance by the Adjacency List and the awesome performance of Nested Sets.  As a result, most people end up having to settle for one or the other especially if there are more than, say, a lousy 100,000 nodes or so.  Using the push stack method can take a whole day to do the conversion on what MLM\'ers would consider to be a small million node hierarchy.I thought I\'d give Celko a bit of competition by coming up with a method to convert an Adjacency List to Nested sets at speeds that just seem impossible. Here\'s the performance of the push stack method on my i5 laptop.And here\'s the duration for the new method (with the push stack method in parenthesis).Yes, that\'s correct.  1 million nodes converted in less than a minute and 100,000 nodes in under 4 seconds.You can read about the new method and get a copy of the code at the following URL.\nhttp://www.sqlservercentral.com/articles/Hierarchy/94040/I also developed a "pre-aggregated" hierarchy using similar methods.  MLM\'ers and people making bills of materials will be particularly interested in this article.\nhttp://www.sqlservercentral.com/articles/T-SQL/94570/If you do stop by to take a look at either article, jump into the "Join the discussion" link and let me know what you think.This is a very partial answer to your question, but I hope still useful.Microsoft SQL Server 2008 implements two features that are extremely useful for managing hierarchical data:Have a look at "Model Your Data Hierarchies With SQL Server 2008" by Kent Tegels on MSDN for starts. See also my own question: Recursive same-table query in SQL Server 2008This design was not mentioned yet:Though it has limitations, if you can bear them, it\'s very simple and very efficient. Features:Here follows an example - taxonomic tree of birds so the hierarchy is Class/Order/Family/Genus/Species - species is the lowest level, 1 row = 1 taxon (which corresponds to species in the case of the leaf nodes):and the example of the data:This is great because this way you accomplish all the needed operations in a very easy way, as long as the internal categories don\'t change their level in the tree.If your database supports arrays, you can also implement a lineage column or materialized path as an array of parent ids.Specifically with Postgres you can then use the set operators to query the hierarchy, and get excellent performance with GIN indices.  This makes finding parents, children, and depth pretty trivial in a single query.  Updates are pretty manageable as well.I have a full write up of using arrays for materialized paths if you\'re curious.I went for it because I could insert new items to the tree easily (you just need a branch\'s id to insert a new item to it) and also query it quite fast.I needed to make accessing and querying the tree faster than inserts, that\'s why I chose thisThe only problem is to fix the left and right columns when inserting new items. well I created a stored procedure for it and called it every time I inserted a new item which was rare in my case but it is really fast.\nI got the idea from the Joe Celko\'s book, and the stored procedure and how I came up with it is explained here in DBA SE\nhttps://dba.stackexchange.com/q/89051/41481This is really a square peg, round hole question.If relational databases and SQL are the only hammer you have or are willing to use, then the answers that have been posted thus far are adequate. However, why not use a tool designed to handle hierarchical data? Graph database are ideal for complex hierarchical data.The inefficiencies of the relational model along with the complexities of any code/query solution to map a graph/hierarchical model onto a relational model is just not worth the effort when compared to the ease with which a graph database solution can solve the same problem.Consider a Bill of Materials as a common hierarchical data structure.Shortest path between two sub-assemblies: Simple graph traversal algorithm. Acceptable paths can be qualified based on criteria.Similarity: What is the degree of similarity between two assemblies? Perform a traversal on both sub-trees computing the intersection and union of the two sub-trees. The percent similar is the intersection divided by the union.Transitive Closure: Walk the sub-tree and sum up the field(s) of interest, e.g. "How much aluminum is in a sub-assembly?"Yes, you can solve the problem with SQL and a relational database. However, there are much better approaches if you are willing to use the right tool for the job.For more complex hierarchies, like an LDAP tree, the OpenLDAP-MySQL Cluster architecture was presented at the MySQL User Conference back in 2009.http://en.oreilly.com/mysql2009/public/schedule/detail/6219It\'s quite similar to the "Multiple lineage columns" scheme shown above.I am using PostgreSQL with closure tables for my hierarchies.\nI have one universal stored procedure for the whole database:Then for each table where I have a hierarchy, I create a triggerFor populating a closure table from existing hierarchy I use this stored procedure:Closure tables are defined with 3 columns - ANCESTOR_ID, DESCENDANT_ID, DEPTH. It is possible (and I even advice) to store records with same value for ANCESTOR and DESCENDANT, and a value of zero for DEPTH. This will simplify the queries for retrieval of the hierarchy. And they are very simple indeed:Here\'s a great example of my personal favorite, the Bridge table(or closure table). 