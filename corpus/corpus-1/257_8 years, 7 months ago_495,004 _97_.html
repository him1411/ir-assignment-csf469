I am using a ListView to display some images and captions associated with those images. I am getting the images from the Internet. Is there a way to lazy load the images so while the text displays, the UI is not locked up and images are displayed as they are downloaded? The total number of images is not fixed.Here\'s what I created to hold the images that my app is currently displaying. Please note that the "Log" object in use here is my custom wrapper around the final Log class inside Android.I made a simple demo of a lazy list (located at GitHub) with images. It may be helpful to somebody. It downloads images in the background thread. Images are being cached on an SD card and in memory. The cache implementation is very simple and is just enough for the demo. I decode images with inSampleSize to reduce memory consumption. I also try to handle recycled views correctly.I recommend open source instrument Universal Image Loader. It is originally based on Fedor Vlasov\'s project LazyList and has been vastly improved since then.Multithreading For Performance, a tutorial by Gilles Debunne.This is from the Android Developers Blog. The suggested code uses:Update: Note that this answer is pretty ineffective now. The Garbage Collector acts aggressively on SoftReference and WeakReference, so this code is NOT suitable for new apps.  (Instead, try libraries like Universal Image Loader suggested in other answers.)Thanks to James for the code, and Bao-Long for the suggestion of using SoftReference. I implemented the SoftReference changes on James\' code. Unfortunately SoftReferences caused my images to be garbage collected too quickly. In my case it was fine without the SoftReference stuff, because my list size is limited and my images are small.There\'s a discussion from a year ago regarding the SoftReferences on google groups: link to thread. As a solution to the too-early garbage collection, they suggest the possibility of manually setting the VM heap size using dalvik.system.VMRuntime.setMinimumHeapSize(), which is not very attractive to me.Picasso Use Jake Wharton\'s  Picasso Library. \n(A Perfect ImageLoading Library form the developer of ActionBarSherlock)A powerful image downloading and caching library for Android.Images add much-needed context and visual flair to Android applications. Picasso allows for hassle-free image loading in your application\xe2\x80\x94often in one line of code!Many common pitfalls of image loading on Android are handled automatically by Picasso:Handling ImageView recycling and download cancellation in an adapter.\nComplex image transformations with minimal memory use.\nAutomatic memory and disk caching.Picasso Jake Wharton\'s LibraryGlideGlide is a fast and efficient open source media management framework for Android that wraps media decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes utility libraries plug in to Google\'s Volley project or Square\'s OkHttp library instead.Glide\'s primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image.Glide Image Loading LibraryFresco by Facebook Fresco is a powerful system for displaying images in Android applications.Fresco takes care of image loading and display, so you don\'t have to. It will load images from the network, local storage, or local resources, and display a placeholder until the image has arrived. It has two levels of cache; one in memory and another in internal storage.Fresco GithubIn Android 4.x and lower, Fresco puts images in a special region of Android memory. This lets your application run faster - and suffer the dreaded OutOfMemoryError much less often.Fresco DocumentationHigh performance loader - after examining the methods suggested here,\nI used Ben\'s solution with some changes - I realized that working with drawables is faster that with bitmaps so I uses drawables insteadUsing SoftReference is great, but it makes the cached image to be deleted too often, so I added a Linked list that holds images references, preventing from the image to be deleted, until it reached a predefined sizeTo open the InputStream I used java.net.URLConnection which allows me to use web cache (you need to set a response cache first, but that\'s another story)My code:I have followed this Android Training and I think it does an excellent job at downloading images without blocking the main UI.  It also handles caching and dealing with scrolling through many images: Loading Large Bitmaps EfficientlyI\'ve written a tutorial that explains how to do lazy-loading of images in a listview. I go into some detail about the issues of recycling and concurrency. I also use a fixed thread pool to prevent spawning a lot of threads.Lazy loading of images in Listview Tutorial1. Picasso allows for hassle-free image loading in your application\xe2\x80\x94often in one line of code!Use Gradle:Just one line of code!Many common pitfalls of image loading on Android are handled automatically by Picasso2. Glide An image loading and caching library for Android focused on smooth scrolling Use Gradle:// For a simple view:// For a simple image list:The way I do it is by launching a thread to download the images in the background and hand it a callback for each list item.  When an image is finished downloading it calls the callback which updates the view for the list item.  This method doesn\'t work very well when you\'re recycling views however.I just want to add one more good example, XML Adapters. As it\'s is used by Google and I am also using the same logic to avoid an OutOfMemory error. Basically this ImageDownloader is your answer (as it covers most of your requirements). Some you can also implement in that.I have been using NetworkImageView from the new Android Volley Library com.android.volley.toolbox.NetworkImageView, and it seems to be working pretty well. Apparently, this is the same view that is used in Google Play and other new Google applications. Definitely worth checking out.Google I/O 2013 volley image cache tutorialDevelopers Google eventsThis is a common problem on Android that has been solved in many ways by many people.  In my opinion the best solution I\'ve seen is the relatively new library called Picasso.  Here are the highlights:I think this issue is very popular among Android developers, and there are plenty of such libraries that claims to resolve this issue, but only a few of them seems to be on the mark. AQuery is one such library, but it is better than most of them in all aspects and is worth trying for.Well, image loading time from the Internet has many solutions. You may also use the library Android-Query. It will give you all the required activity. Make sure what you want to do and read the library wiki page. And solve the image loading restriction.This is my code:It should be solve your lazy loading problem.Have a look at Shutterbug, Applidium\'s lightweight SDWebImage (a nice library on iOS) port to Android.\nIt supports asynchronous caching, stores failed URLs, handles concurrency well, and helpful subclasses are included.Pull requests (and bug reports) are welcome, too!Novoda also has a great lazy image loading library and many apps like Songkick, Podio, SecretDJ and ImageSearch use their library.Their library is hosted here on Github and they have a pretty active issues tracker as well. Their project seems to be pretty active too, with over 300+ commits at the time of writing this reply.DroidParts has ImageFetcher that requires zero configuration to get started.Clone DroidPartsGram for an example:You must try this Universal Loader is best.\nI am using this after done many RnD on lazy loading .Universal Image LoaderFeaturesAndroid 2.0+ supportJust a quick tip for someone who is in indecision regarding what library to use for lazy-loading images:There are four basic ways.DIY => Not the best solution but for a few images and if you want to go without the hassle of using others librariesVolley\'s Lazy Loading library => From guys at android. It is nice and everything but is poorly documented and hence is a problem to use.Picasso: A simple solution that just works, you can even specify the exact image size you want to bring in. It is very simple to use but might not be very "performant" for apps that has to deal with humongous amounts of images.UIL: The best way to lazy load images. You can cache images(you need permission of course), initialize the loader once, then have your work done. The most mature asynchronous image loading library I have ever seen so far.Check my fork of LazyList. Basically, I improve the LazyList by delaying the call of the ImageView and create two methods:I also improved the ImageLoader by implementing a singleton in this object.All above code have their own worth but with my personal experience just give a try with Picasso.Picasso  is a library specifically for this purpose, in-fact it will manage cache and all other network operations automatically.You will have to add library in your project and just write a single line of code to load image from remote URL.Please visit here : http://code.tutsplus.com/tutorials/android-sdk-working-with-picasso--cms-22149 I can recommend a different way that works like a charm: Android Query.You can download that JAR file from hereAs an example:It\'s very fast and accurate, and using this you can find many more features like animation when loading, getting a bitmap (if needed), etc.Give Aquery a try. It has amazingly simple methods to load and cache images asynchronously.URLImageViewHelper is an amazing library that helps you to do that. You can try the Aquery Android library for lazy loading image and listview... The below code may help you..... download library from here.I use droidQuery. There are two mechanisms for loading an image from a URL. The first (shorthand) is simply:This can be added into an ArrayAdapter\'s getView(...) method very easily.The longhand method will give a lot more control, and has options not even discussed here (such as cacheing and callbacks), but a basic implementation that specifies the output size as 200px x 200px can be found here:I had this issue and implemented lruCache. I believe you need API 12 and above or use the compatiblity v4 library. lurCache is fast memory, but it also has a budget, so if you\'re worried about that you can use a diskcache... It\'s all described in Caching Bitmaps.I\'ll now provide my implementation which is a singleton I call from anywhere like this:Here\'s the ideal code to cache and then call the above in getView of an adapter when retrieving the web image: