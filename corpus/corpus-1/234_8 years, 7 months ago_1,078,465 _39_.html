This question already has an answer here:I\'m trying to understand super(). From the looks of it, both child classes can be created just fine. I\'m curious as to what difference there actually is between the following child classes:super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven\'t already.Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer.It\'s been noted that in Python 3.0+ you can usesuper().__init__() to make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, you can achieve the same name-insensitive approach by writing self.__class__ instead of the class name, i.e.super(self.__class__, self).__init__()However, this breaks if you use multiple levels of inheritance, where self.__class__ could return a child class --- meaning that neither you nor anyone else can inherit from a class that uses this pattern. For example:Here I have a class Square, which is a sub-class of Rectangle. Say I don\'t want to write a separate constructor for Square because the constructor for Rectangle is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method.When I create a Square using mSquare = Square(\'a\', 10,10), Python calls the constructor for Rectangle because I haven\'t given Square its own constructor. However, in the constructor for Rectangle, the call super(self.__class__,self) is going to return the superclass of mSquare, so it calls the constructor for Rectangle again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run super(...).__init__() I am calling the constructor for Rectangle but since I give it no arguments, I will get an error.The reason we use super is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).The primary difference in this code is that you get a layer of indirection in the __init__ with super, which uses the current class to determine the next class\'s __init__ to look up in the MRO.I illustrate this difference in an answer at the canonical question, How to use \'super\' in Python?, which demonstrates dependency injection and cooperative multiple inheritance.Here\'s code that\'s actually closely equivalent to super (how it\'s implemented in C, minus some checking and fallback behavior, and translated to Python):Written a little more like native Python:If we didn\'t have the super object, we\'d have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order!The current second to top answer on this question suggests calling super like this:This is completely wrong. super lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If you tell super we\'re in the child instance\'s method, it will then lookup the next method in line (probably this one) resulting in recursion, probably causing a logical failure (in the answerer\'s example, it does) or a RuntimeError when the recursion depth is exceeded.I am at a loss as to why an answer that doesn\'t work has been so upvoted.super() lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven\'t already.It\'s rather hand-wavey and doesn\'t tell us much, but the point of super is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance.I\'ll explain here.And let\'s create a dependency that we want to be called after the Child:Now remember, ChildB uses super, ChildA does not:And UserA does not call the UserDependency method:But UserB, because ChildB uses super, does!:Super has no side effectsworks as expectedgets into infinite recursion.Just a heads up... with Python 2.7, and I believe ever since super() was introduced in version 2.2, you can only call super() if one of the parents inherit from a class that eventually inherits object (new-style classes).Personally, as for python 2.7 code, I\'m going to continue using BaseClassName.__init__(self, args) until I actually get the advantage of using super().There isn\'t, really. super() looks at the next class in the MRO (method resolution order, accessed with cls.__mro__) to call the methods. Just calling the base __init__ calls the base __init__. As it happens, the MRO has exactly one item-- the base. So you\'re really doing the exact same thing, but in a nicer way with super() (particularly if you get into multiple inheritance later).The main difference is that ChildA.__init__ will unconditionally call Base.__init__ whereas ChildB.__init__ will call __init__ is whatever class happens to be ChildB ancestor in self\'s line of ancestors\n(which may differ from what you expect). If you add a ClassC that uses multiple inheritance: then Base is no longer the parent of ChildB for ChildC instances. Now super(ChildB, self) will point to Mixin if self is a ChildC instance.You have inserted Mixin in between ChildB and Base. And you can take advantage of it with super()So if you are designed your classes so that they can be used in a Cooperative Multiple Inheritance scenario, you use super because you don\'t really know who is going to be the ancestor at runtime. The super considered super post and pycon 2015 accompanying video explain this pretty well.  