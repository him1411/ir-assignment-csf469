I have seen both angular.factory() and angular.service() used to declare services; however, I cannot find angular.service anywhere in official documentation.What is the difference between the two methods? Which should be used for what (assuming they do different things)?I had trouble wrapping my head around this concept until I put it to myself this way:Service: the function that you write will be new-ed:Factory: the function (constructor) that you write will be invoked:What you do with that is up to you, but there are some useful patterns... You can accomplish the same thing with both. However, in some cases the factory gives you a little bit more flexibility to create an injectable with a simpler syntax. That\'s because while myInjectedService must always be an object, myInjectedFactory can be an object, a function reference, or any value at all. For example, if you wrote a service to create a constructor (as in the last example above), it would have to be instantiated like so: which is arguably less desirable than this:(But you should be wary about using this type of pattern in the first place because new-ing objects in your controllers creates hard-to-track dependencies that are difficult to mock for testing. Better to have a service manage a collection of objects for you than use new() wily-nilly.)Also keep in mind that in both cases, angular is helping you manage a singleton. Regardless of where or how many times you inject your service or function, you will get the same reference to the same object or function. (With the exception of when a factory simply returns a value like a number or string. In that case, you will always get the same value, but not a reference.)Simply put ..Here are the primary differences:Syntax: module.service( \'serviceName\', function );Result: When declaring serviceName as an injectable argument you will be provided with the instance of a function passed to module.service.Usage: Could be useful for sharing utility functions that are useful to invoke by simply appending ( ) to the injected function reference. Could also be run with injectedArg.call( this ) or similar.Syntax: module.factory( \'factoryName\', function );Result: When declaring factoryName as an injectable argument you will be provided with the value that is returned by invoking the function reference passed to module.factory.Usage: Could be useful for returning a \'class\' function that can then be new\'ed to create instances.Here is example using services and factory. Read more about AngularJS Service vs Factory.You can also check the AngularJS documentation and similar question on stackoverflow confused about service vs factory.TL;DR \n1) When you\xe2\x80\x99re using a Factory you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.\n2) When you\xe2\x80\x99re using Service, Angular instantiates it behind the scenes with the \xe2\x80\x98new\xe2\x80\x99 keyword. Because of that, you\xe2\x80\x99ll add properties to \xe2\x80\x98this\xe2\x80\x99 and the service will return \xe2\x80\x98this\xe2\x80\x99. When you pass the service into your controller, those properties on \xe2\x80\x98this\xe2\x80\x99 will now be available on that controller through your service.Non TL;DR1) Factory \nFactories are the most popular way to create and configure a service. There\xe2\x80\x99s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below. Now whatever properties we attach to \xe2\x80\x98service\xe2\x80\x99 will be available to us when we pass \xe2\x80\x98myFactory\xe2\x80\x99 into our controller. Now let\xe2\x80\x99s add some \xe2\x80\x98private\xe2\x80\x99 variables to our callback function. These won\xe2\x80\x99t be directly accessible from the controller, but we will eventually set up some getter/setter methods on \xe2\x80\x98service\xe2\x80\x99 to be able to alter these \xe2\x80\x98private\xe2\x80\x99 variables when needed.Here you\xe2\x80\x99ll notice we\xe2\x80\x99re not attaching those variables/function to \xe2\x80\x98service\xe2\x80\x99. We\xe2\x80\x99re simply creating them in order to either use or modify them later. Now that our helper/private variables and function are in place, let\xe2\x80\x99s add some properties to the \xe2\x80\x98service\xe2\x80\x99 object. Whatever we put on \xe2\x80\x98service\xe2\x80\x99 we\xe2\x80\x99ll be able to directly use in whichever controller we pass \xe2\x80\x98myFactory\xe2\x80\x99 into. We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven\xe2\x80\x99t had much experience using promises in Angular, I highly recommend doing a deep dive on them. Below setArtist accepts an artist and allows you to set the artist. getArtist returns the artist callItunes first calls makeUrl() in order to build the URL we\xe2\x80\x99ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying \xe2\x80\x98There was an error\xe2\x80\x99.Now our factory is complete. We are now able to inject \xe2\x80\x98myFactory\xe2\x80\x99 into any controller and we\xe2\x80\x99ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes). In the controller above we\xe2\x80\x99re injecting in the \xe2\x80\x98myFactory\xe2\x80\x99 service. We then set properties on our $scope object that are coming from data from \xe2\x80\x98myFactory\xe2\x80\x99. The only tricky code above is if you\xe2\x80\x99ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You\xe2\x80\x99ll notice our controller is very \xe2\x80\x98thin\xe2\x80\x99. All of our logic and persistent data is located in our service, not in our controller. \n\n2) Service \nPerhaps the biggest thing to know when dealing with creating a Service is that  that it\xe2\x80\x99s instantiated with the \xe2\x80\x98new\xe2\x80\x99 keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren\xe2\x80\x99t too familiar with what the \xe2\x80\x98new\xe2\x80\x99 keyword actually does, let\xe2\x80\x99s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service. To really see the changes that occur when you invoke a function with the \xe2\x80\x98new\xe2\x80\x99 keyword, let\xe2\x80\x99s create a function and invoke it with the \xe2\x80\x98new\xe2\x80\x99 keyword, then let\xe2\x80\x99s show what the interpreter does when it sees the \xe2\x80\x98new\xe2\x80\x99 keyword. The end results will both be the same.First let\xe2\x80\x99s create our Constructor. This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the \xe2\x80\x98new\xe2\x80\x99 keyword, \xe2\x80\x98this\xe2\x80\x99 will be bound to the newly created object. Now let\xe2\x80\x99s add a method onto our Person\xe2\x80\x99s prototype so it will be available on every instance of our Person \xe2\x80\x98class\xe2\x80\x99. Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance\xe2\x80\x99s name.Now that we have our Person constructor function and our sayName function on its prototype, let\xe2\x80\x99s actually create an instance of Person then call the sayName function. So all together the code for creating a Person constructor, adding a function to it\xe2\x80\x99s prototype, creating a Person instance, and then calling the function on its prototype looks like this.Now let\xe2\x80\x99s look at what actually is happening when you use the \xe2\x80\x98new\xe2\x80\x99 keyword in JavaScript. First thing you should notice is that after using \xe2\x80\x98new\xe2\x80\x99 in our example, we\xe2\x80\x99re able to call a method (sayName) on \xe2\x80\x98tyler\xe2\x80\x99 just as if it were an object - that\xe2\x80\x99s because it is. So first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says \xe2\x80\x9cOK, I\xe2\x80\x99m going to look on the \xe2\x80\x98tyler\xe2\x80\x99 object we just created, locate the sayName function, then call it. Wait a minute, I don\xe2\x80\x99t see it here - all I see is name and age, let me check the prototype. Yup, looks like it\xe2\x80\x99s on the prototype, let me call it.\xe2\x80\x9d. Below is code for how you can think about what the \xe2\x80\x98new\xe2\x80\x99 keyword is actually doing in JavaScript. It\xe2\x80\x99s basically a code example of the above paragraph. I\xe2\x80\x99ve put the \xe2\x80\x98interpreter view\xe2\x80\x99 or the way the interpreter sees the code inside of notes.Now having this knowledge of what the \xe2\x80\x98new\xe2\x80\x99 keyword really does in JavaScript, creating a Service in Angular should be easier to understand. The biggest thing to understand when creating a Service is knowing that Services are instantiated with the \xe2\x80\x98new\xe2\x80\x99 keyword. Combining that knowledge with our examples above, you should now recognize that you\xe2\x80\x99ll be attaching your properties and methods directly to \xe2\x80\x98this\xe2\x80\x99 which will then be returned from the Service itself. Let\xe2\x80\x99s take a look at this in action. Unlike what we originally did with the Factory example, we don\xe2\x80\x99t need to create an object then return that object because, like mentioned many times before, we used the \xe2\x80\x98new\xe2\x80\x99 keyword so the interpreter will create that object, have it delegate to it\xe2\x80\x99s prototype, then return it for us without us having to do the work. First things first, let\xe2\x80\x99s create our \xe2\x80\x98private\xe2\x80\x99 and helper function. This should look very familiar since we did the exact same thing with our factory. I won\xe2\x80\x99t explain what each line does here because I did that in the factory example, if you\xe2\x80\x99re confused, re-read the factory example.Now, we\xe2\x80\x99ll attach all of our methods that will be available in our controller to \xe2\x80\x98this\xe2\x80\x99. Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here\xe2\x80\x99s the myService controller (which is almost exactly the same as our factory controller).Like I mentioned before, once you really understand what \xe2\x80\x98new\xe2\x80\x99 does, Services are almost identical to factories in Angular. Services and factories are similar to one another. Both will yield a singleton object that can be injected into other objects, and so are often used interchangeably.They are intended to be used semantically to implement different design patterns.A service pattern is one in which your application is broken into logically consistent units of functionality. An example might be an API accessor, or a set of business logic.This is especially important in Angular because Angular models are typically just JSON objects pulled from a server, and so we need somewhere to put our business logic.Here is a Github service for example. It knows how to talk to Github. It knows about urls and methods. We can inject it into a controller, and it will generate and return a promise.Factories, on the other hand are intended to implement a factory pattern. A factory pattern in one in which we use a factory function to generate an object. Typically we might use this for building models. Here is a factory which returns an Author constructor:We would make use of this like so:Note that factories also return singletons.Because a factory simply returns an object, it can return any type of object you like, including a constructor function, as we see above.Another technical difference is in the way services and factories are composed. A service function will be newed to generate the object. A factory function will be called and will return the object.This means that in a service, we append to "this" which, in the context of a constructor, will point to the object under construction.To illustrate this, here is the same simple object created using a service and a factory:ConstructionWith factories, Angular will invoke the function to get the result.  It is the result that is cached and injected.With services, Angular will invoke the constructor function by calling new. The constructed function is cached and injected.ImplementationFactories typically return an object literal because the return value is what\'s injected into controllers, run blocks, directives, etcService functions typically do not return anything. Instead, they perform initialization and expose functions.  Functions can also reference \'this\' since it was constructed using \'new\'.ConclusionWhen it comes to using factories or services they are both very similar. They are injected into a controllers, directives, run block, etc, and used in client code in pretty much the same way. They are also both singletons - meaning the same instance is shared between all places where the service/factory is injected.  So which should you prefer?  Either one - they are so similar that the differences are trivial.  If you do choose one over the other, just be aware how they are constructed, so that you can implement them properly.All the answers here seem to be around service and factory, and that\'s valid since that was what was being asked about. But it\'s also important to keep in mind that there are several others including provider(), value(), and constant().The key to remember is that each one is a special case of the other. Each special case down the chain allowing you to do the same thing with less code. Each one also having some additional limitation.To decide when to use which you just see which one allows you to do what you want in less code. Here is an image illustrating just how similar they are:For a complete step by step breakdown and quick reference of when to use each you can visit the blog post where I got this image from: http://www.simplygoodcode.com/2015/11/the-difference-between-service-provider-and-factory-in-angularjs/I have spent some time trying to figure out the difference.And i think the factory function uses the module pattern and service function uses the standard java script constructor pattern. The factory pattern is more flexible as it can return functions and values as well as objects.There isn\'t a lot of point in the service pattern IMHO, as everything it does you can just as easily do with a factory. The exceptions might be:Arguably, the service pattern is a slightly nicer way to create a new object from a syntax point of view, but it\'s also more costly to instantiate. Others have indicated that angular uses "new" to create the service, but this isn\'t quite true - it isn\'t able to do that because every service constructor has a different number of parameters. What angular actually does is use the factory pattern internally to wrap your constructor function. Then it does some clever jiggery pokery to simulate javascript\'s "new" operator, invoking your constructor with a variable number of injectable arguments - but you can leave out this step if you just use the factory pattern directly, thus very slightly increasing the efficiency of your code.