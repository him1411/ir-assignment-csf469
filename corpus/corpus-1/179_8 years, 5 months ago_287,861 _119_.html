I saw some code that seems to use an operator I don\'t recognize, in the form of two exclamation points, like so: !!. Can someone please tell me what this operator does?The context in which I saw this was,Coerces oObject to boolean. If it was falsey (e.g. 0, null, undefined, etc.), it will be false, otherwise, true.So !! is not an operator, it\'s just the ! operator twice.Real World Example "Test IE version":  If you =>but if you =>  It\'s a horribly obscure way to do a type conversion.! is NOT.  So !true is false, and !false is true. !0 is true, and !1 is false.So you\'re converting a value to a boolean, then inverting it, then inverting it again.!!expr returns a Boolean value (true or false) depending on the truthiness of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:Brew some tea:!! is not an operator. It is the double-use of ! -- which is the logical "not" operator. In theory:! determines the "truth" of what a value is not:The truth is that false is not true (that\'s why !false results\nin true)The truth is that true is not false (that\'s why !true results\nin false)!! determines the "truth" of what a value is not not:The truth is that true is not not true (that\'s why !!true results in true)The truth is that false is not not false (that\'s why !!false results in false)What we wish to determine in the comparison is the "truth" about the value of a reference, not the value of the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be false (or falsey), or if we expect the value not to be typeof boolean. In practice:Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of dynamic typing (aka "duck typing"). We want to write a function that returns true if a user\'s browser supports the HTML5 <audio> element, but we don\'t want the function to throw an error if <audio> is undefined; and we don\'t want to use try ... catch to handle any possible errors (because they\'re gross); and also we don\'t want to use a check inside the function that won\'t consistently reveal the truth about the feature (for example, document.createElement(\'audio\') will still create an element called <audio> even if HTML5 <audio> is not supported). Here are the three approaches:Each function accepts an argument for a <tag> and an attribute to look for, but they each return different values based on what the comparisons determine. But wait, there\'s more!Some of you probably noticed that in this specific example, one could simply check for a property using the slightly more performant means of checking if the object in question has a property. There are two ways to do this:We digress...However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting true from a non-boolean, possibly undefined value is indeed by using !!. Hopefully this ridiculously clears it up.!! converts the value to the right of it to its equivalent boolean value. (Think poor man\'s way of "type-casting"). Its intent is usually to convey to the reader that the code does not care what value is in the variable, but what it\'s "truth" value is.!!foo applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus +foo to cast to number and concatenating an empty string \'\'+foo to cast to string.Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (without using new) to explicitly cast values, ieIt\'s just the logical NOT operator, twice - it\'s used to convert something to boolean, e.g.:It converts the suffix to a Boolean value. So many answers doing half the work. Yes, !!X could be read as "the truthiness of X [represented as a boolean]". But !! isn\'t, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. !!myVar === true is the same as just myVar. Comparing !!X to a "real" boolean isn\'t really useful.What you gain with !! is the ability to check the truthiness of multiple variables against each other in a repeatable, standardized (and JSLint friendly) fashion.That is...The above\'s not so useful. if (!0) gives you the same results as if (!!0 === false). I can\'t think of a good case for casting a variable to boolean and then comparing to a "true" boolean.See "== and !=" from JSLint\'s directions (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:The == and != operators do type coercion before comparing. This is bad because it causes \' \\t\\r\\n\' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.If you only care that a value is truthy or falsy, then use the short form. Instead of\n  (foo != 0)just say\n  (foo)and instead of\n  (foo == 0)say\n  (!foo)Note that there are some unintuitive cases where a boolean will be cast to a number (true is cast to 1 and false to 0) when comparing a boolean to a number. In this case, !! might be mentally useful. Though, again, these are cases where you\'re comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake. if (-1) is still the way to go here.And things get even crazier depending on your engine. WScript, for instance, wins the prize.Because of some historical Windows jive, that\'ll output -1 in a message box! Try it in a cmd.exe prompt and see! But WScript.echo(-1 == test()) still gives you 0, or WScript\'s false. Look away. It\'s hideous.But what if I have two values I need to check for equal truthi/falsi-ness?Pretend we have myVar1 = 0; and myVar2 = undefined;.So the only place you\'d really need to use "boolean-cast variables" would be if you had a situation where you\'re checking if both variables have the same truthiness, right? That is, use !! if you need to see if two vars are both truthy or both falsy (or not), that is, of equal (or not) truthiness.I can\'t think of a great, non-contrived use case for that offhand. Maybe you have "linked" fields in a form? So now if you have a truthy for both or a falsy for both spouse name and age, you can continue. Otherwise you\'ve only got one field with a value (or a very early arranged marriage) and need to create an extra error on your errorObjects collection.Or, admittedly, in some cases, you gain increased readability, as in the q lib here:We\'re not interested in e.stack when we deal with hasStacks later. We just want to lossily retain truthiness. That said, operationally, we could have left out the !! and had the same thing happen. One example:It\'s a double not operation.  The first ! converts the value to boolean and inverts its logical value.  The second ! inverts the logical value back.It simulates the behavior of the Boolean() casting function.\nThe first NOT returns a Boolean value no matter what operand it is given. The second NOT negates that Boolean value and so gives the true Boolean value of a variable. The end result is the same as using the Boolean() function on a value.! is "boolean not", which essentially typecasts the value of "enable" to its boolean opposite. The second ! flips this value. So, !!enable means "not not enable," giving you the value of enable as a boolean.It seems that the !! operator results in a double negation.The !! construct is a simple way of turning any JavaScript expression into\nits Boolean equivalent. For example: !!"he shot me down" === true and !!0 === false.I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of && and \nfirst success or last fail in case of || of condition chain.In order to cast the condition to a true boolean literal we can use the double negation:It\'s not a single operator, it\'s two.  It\'s equivalent to the following and is a quick way to cast a value to boolean. Tons of great answers here, but if you\'ve read down this far, this helped me to \'get it\'. Open the console on Chrome (etc), and start typing:Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.The if and while statements and the ? operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and null are both false.The double negation operator !! calculates the truth value of a value. It\'s actually two operators, where !!x means !(!x), and behaves as follows:When used at the top level of a Boolean context (if, while, or ?), the !! operator is behaviorally a no-op. For example, if (x) and if (!!x) mean the same thing.However it has several practical uses.One use is to lossily compress an object to its truth value, so that your code isn\'t holding a reference to a big object and keeping it alive. Assigning !!some_big_object to a variable instead of some_big_object lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as null or the undefined value, such as browser feature detection.Another use, which I mentioned in an answer about C\'s corresponding !! operator, is with "lint" tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn\'t quite as Boolean:The !! operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, a && b performs a logical AND (true if both sides are true), and a & b performs a bitwise AND. a || b performs a logical OR (true if at least one are true), and a | b performs a bitwise OR. There\'s a bitwise XOR (exclusive OR) as a ^ b, but there\'s no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: !!x !== !!y.Double boolean negation. Often used to check if value is not undefined.I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.So to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!.!!x is shorthand for Boolean(x)The first bang forces the js engine to run Boolean(x) but also has the side effect of inverting the value.  So the second bang undoes the side effect.here is a piece of code from angular js their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame it can be achieved by checking in following way in general:the short way could be using !!so if requestAnimationFrame was assigned a function\n then\n!requestAnimationFrame would be false and one more ! of it would be trueif requestAnimationFrame was assinged undefined then\n!requestAnimationFrame would be true and one more ! of it would be falseSome operators in JavaScript perform implicit type conversions, and are sometimes\nused for type conversion.The unary ! operator converts its operand to a boolean and negates it.This fact lead to the following idiom that you can see in your source code:Returns boolean value of a variable.Instead, Boolean class can be used.(please read code descriptions)Namely, Boolean(X) = !!X in use.Please check code snippet out below \xe2\x86\x93For !a, it checks whether a is NOT defined, while !!a checks if the variable is defined.!!a is the same as !(!a). If a is defined, a is true, !a is false, and !!a is true.Use logical not operator two times\nit means !true= false\n and  !!true = true!! is similar to using the Boolean constructor, or arguably more like the Boolean function.Falsey values in javascript coerce to false, and truthy values coerce to true. Falsey and truthy values can also be used in if statements and will essentially "map" to their corresponding boolean value. However, you will probably not find yourself having to use proper boolean values often, as they mostly differ in output (return values). Although this may seem similar to casting, realistically this is likely a mere coincidence and is not \'built\' or purposely made for and like a boolean cast. So let\'s not call it that.To be concise, it looks something like this: ! ( !null ). Whereas, null is falsey, so !null would be true. Then !true would be false and it would essentially invert back to what it was before, \nexcept this time as a proper boolean value (or even vice versa with truthy values  like {} or 1).   Overall, the context that you saw simply adjusts this.vertical depending on whether or not vertical is defined, and if so; it will be set to the resulting boolean value of vertical, otherwise it will not change. In other words, if vertical is defined; this.vertical will be set to the boolean value of it, otherwise, it will stay the same. I guess that in itself is an example of how you would use !!, and what it does.Run this example and fiddle around with the vertical value in the input. See what the result coerces to so that you can fully understand your context\'s code. In the input, enter any valid javascript value.\nRemember to include the quotations if you are testing out a string. Don\'t mind the CSS and HTML code too much, simply run this snippet and play around with it. However, you might want to take a look at the non-DOM-related javascript code though (the use of the Example constructor and the vertical variable).I just wanted to add thatis the same asBut this can be an issue when something is undefined.The trick here is the chain of &&s will return the first falsey value it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the b.foo.bar statement, and we get no error.The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- [] and {} are both truthy.After seeing all these great answers, I would like to add another reason for using  !!. Currenty I\'m working in Angular 2-4 (TypeScript) and I want to return a boolean as false when my user is not authenticated. If he isn\'t authenticated, the token-string would be null or "". I can do this by using the next block of code:!! it\'s using NOT operation twice together, ! convert the value to a boolean and reverse it, here is a the simple example to see how !! works:At first place you have:Then you do !0, it will be converted to boolean and be evaluated to true, because 0 is falsy, so you get the reversed value and converted to boolean, so it gets evaluated to true.but we don\'t want the revered boolean version of the value, so we can reverse it again to get our result! That\'s why we use another !.Basically, !! make us sure, the value we get is boolean, not falsy, truthy or string etc...So  it\'s like using Boolean function in javascript, but easy and shorter way to convert a value to boolean: