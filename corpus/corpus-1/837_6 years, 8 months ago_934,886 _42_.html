I am working on a simple scripting project for work that involves the use of Bash.  I have a pretty simple script that is something like the following:When I run this script from the command line and pass it the arguments, I am not getting any output.  However, when I run the commands contained within the $MOREF variable, I am able to get output.  I would like to know how one can take the results of a command that needs to be run within a script, save it to a variable, and then output that variable on the screen?In addition to the backticks, you can use $(), which I find easier to read, and allows for nesting.Quoting (") does matter to preserve multi-line values.You\'re using the wrong kind of apostrophe. You need `, not \'. This character is called "backticks" (or "grave accent").Like this:As they have already indicated to you, you should use \'backticks\'.The alternative proposed $(command) works as well, and it also easier to read,\nbut note that it is valid only with bash or korn shells (and shells derived from those),\nso if your scripts have to be really portable on various Unix systems, you should prefer the old backticks notation.I know three ways to do:1) Functions are suitable for such tasks:Invoke it by saying func2) Also another suitable solution could be eval:3) The third one is using variables directly:you can get output of third solution in good way:and also in nasty way:Just to be different:As nesting could become heavy, parenthesis was implemented for thisNested sample:If I just want Used value:you could see array variable:Then:But I prefer this:1st read will just skip header line.(Please avoid useless cat! So this is just 1 fork less:All pipes (|) implies forks. Where another process have to be run, accessing disk, libraries calls and so on.So using sed for sample, will limit subprocess to only one fork:But for many actions, mostly on small files, bash could do the job himself:If you want to do it with multiline/multiple command/s then you can do this:Or:Example:Output:Using heredoc you can simplify things pretty easily by breaking down your long single line code into multiline one. Another example:You can use back-ticks(also known as accent graves) or $().\nLike as-Both have the same effect. But OUTPUT=$(x+2) is more readable and the latest one.This is another way, good to use with some text editors that are unable to correctly highlight every intricate code you create.Some may find this useful. \nInteger values in variable substitution, where the trick is using $(()) double brackets:Here are two more ways: \nPlease keep in mind space is very important in bash so if you want your command to run use as is without introducing anymore spaces.following assigns harshil to L and then prints itfollowing assigns output of a command tr to L2. tr is being operated on another variable L1.When setting a variable make sure you have NO Spaces before and/or after the = sign. Literally spent an hour trying to figure this,  trying all kinds of solutions! This is Not cool.Correct:Will Fail with error: (stuff: not found or similar)