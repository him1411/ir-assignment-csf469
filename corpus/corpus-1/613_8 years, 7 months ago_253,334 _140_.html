The primitive types (Number, String, etc.) are passed by value, but Objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).Although it doesn\'t really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?It\'s interesting in Javascript. Consider this example:This produces the output:If it was pure pass by value, then changing obj1.item would have no effect on the obj1 outside of the function.\nIf it was pure pass by reference, then everything would have changed. num would be 100, and obj2.item would read "changed".Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is itself a reference.\nTechnically, this is called call-by-sharing.In practical terms, this means that if you change the parameter itself (as with num and obj2), that won\'t affect the item that was fed into the parameter.\nBut if you change the INTERNALS of the parameter, that will propagate back up (as with obj1).It\'s always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its members, those changes persist outside of the function.  This makes it look like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it\'s really pass by value.Example:Output:The variable doesn\'t "hold" the object, it holds a reference. You can assign that reference to another variable, now both reference the same object. It\'s always pass by value (even when that value is a reference...). There\'s no way to alter the value held by a variable passed as a parameter, which would be possible if JS supported passing by reference. My 2 Cents.... This is the way I understand it. (Feel free to correct me if I\'m wrong)It\'s time to throw out everything you know about pass by value / reference. Because in JavaScript, it doesn\'t matter whether it\'s passed by value or by reference or whatever.\nWhat matters is mutation vs assignment of the parameters passed into a function.OK, let me do my best to explain what I mean. Let\'s say you have a few objects.What we have done is "assignment"... We\'ve assigned 2 separate empty objects to the variables "object1" and "object2".Now, let\'s say that we like object1 better... So, we "assign" a new variable.Next, for whatever reason, we decide that we like object 2 better. So, we simply do a little re-assignment.Nothing happened to object1 or to object2. We haven\'t changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.OK, now let\'s look at primitives like strings for exampleAgain, we pick a favorite.Both our favoriteString and string1 variables are assigned to \'Hello world\'. Now, what if we want to change our favoriteString??? What will happen???Uh oh.... What has happened. We couldn\'t change string1 by changing favoriteString... Why?? because strings are immutable and we didn\'t mutate it. All we did was "RE ASSIGN" favoriteString to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn\'t assign anything. (Well, actually... we did, we assigned the name property to a new string.) Instead, we simply mutated the object which keeps the connections between the 2 variables and the underlying objects.Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is "assignment" to a new variable, and it works exactly the same as if you simply assigned using the equal (=) sign.Take these examples.Now, the same thing, but with a functionOK, now lets give a few examples using objects instead... first, without the function.Now, the same thing, but with a function callOK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in javascript. It doesn\'t matter whether something is passed by reference or by value... What matters is assignment vs mutation. Every time you pass a variable to a function, you are "Assigning" to whatever the name of the parameter variable is, just like if you used the equal (=) sign.Always remember that the equals sign (=) means assignment.\nAlways remember that passing a parameter to a function also means assignment.\nThey are the same and the 2 variables are connected in exactly the same way.The only time that modifying a variable affects a different variable is when the underlying object is mutated.There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn\'t have a function and just used the equal sign to assign to a new variable.The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)Consider the following:So, forget about "pass by reference/value" don\'t get hung up on "pass by reference/value" because:To answer your question: pointers are passed.Some final comments:Object outside a function  is passed into a function by giving a reference to the outside obejct. When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else. Javascript is always pass-by-value, everything is of value type. Objects are values, member functions of objects are values themselves (remember that functions are first-class objects in Javascript). Also, regarding the concept that everything in Javascript is an object, this is wrong. Strings, symbols, numbers, booleans, nulls and undefineds are primitives. On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience, it does not mean that they are objects themselves. Try the following for referenceIn both alerts you will find the value to be undefined.A very detailed explanation about copying, passing and comparing by value and by reference is in this chapter of "JavaScript: The Definitive Guide" book.Before we leave the topic of\n  manipulating objects and arrays by\n  reference, we need to clear up a point\n  of nomenclature. The phrase "pass by\n  reference" can have several meanings.\n  To some readers, the phrase refers to\n  a function invocation technique that\n  allows a function to assign new values\n  to its arguments and to have those\n  modified values visible outside the\n  function. This is not the way the term\n  is used in this book. Here, we mean\n  simply that a reference to an object\n  or array -- not the object itself --\n  is passed to a function. A function\n  can use the reference to modify\n  properties of the object or elements\n  of the array. But if the function\n  overwrites the reference with a\n  reference to a new object or array,\n  that modification is not visible\n  outside of the function. Readers\n  familiar with the other meaning of\n  this term may prefer to say that\n  objects and arrays are passed by\n  value, but the value that is passed is\n  actually a reference rather than the\n  object itself.One thing I still cannot figure out. Check code below. Any thoughts?Think of it like this: Its always pass by value. However, the value of an object is not the object itself, but a reference to that object. Here is an example, passing a number (a primitive type)Repeating this with an object yields different results:One more example:In JavaScript, the type of the value solely controls whether that value will be assigned by value-copy or by reference-copy. Primitive values are always assigned/passed by value-copy: Compound values are always assigned/passed by reference-copyFor exampleIn the above snippet, because 2 is a scalar primitive, a holds one initial copy of that value, and b is assigned another copy of the value. When changing b, you are in no way changing the value in a.But both c and d are separate references to the same shared value [1,2,3], which is a compound value. It\'s important to note that neither c nor d more "owns" the [1,2,3] value -- both are just equal peer references to the value. So, when using either reference to modify (.push(4)) the actual shared array value itself, it\'s affecting just the one shared value, and both references will reference the newly modified value [1,2,3,4].When we make the assignment b = [4,5,6], we are doing absolutely nothing to affect where a is still referencing ([1,2,3]). To do that, b would have to be a pointer to a rather than a reference to the array -- but no such capability exists in JS!When we pass in the argument a, it assigns a copy of the a reference to x. x and a are separate references pointing at the same [1,2,3] value. Now, inside the function, we can use that reference to mutate the value itself (push(4)). But when we make the assignment x = [4,5,6], this is in no way affecting where the initial reference a is pointing -- still points at the (now modified) [1,2,3,4] value.To effectively pass a compound value (like an array) by value-copy, you need to manually make a copy of it, so that the reference passed doesn\'t still point to the original. For example:Compound value (object, array, etc) that can be passed by reference-copyHere, obj acts as a wrapper for the scalar primitive property a. When passed to foo(..), a copy of the obj reference is passed in and set to the wrapperparameter. We now can use the wrapper reference to access the shared object, and update its property. After the function finishes, obj.a will see the updated value 42.SourceThere\'s some discussion about the use of the term "pass by reference" in JS here, but to answer your question:A object is automatically passed by reference, without the need to specifically state it(From the article mentioned above.)The most succinct explanation I found was in the AirBNB style guide:Primitives: When you access a primitive type you work directly on its\nvalueE.g.:Complex: When you access a complex type you work on a reference to its valueE.g.:I.e. effectively primitive types are passed by value, and complex types are passed by reference.Passing arguments to a function in JavaScript is analogous to passing\nparameters by pointer value in C:Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.Variable: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.Symbol:  Text string used to refer to variable (i.e. variable\'s name).Value:  Particular bits stored in memory and referenced using variable\'s symbol.Memory location:  Where a variable\'s value is stored.  (The location itself is represented by a number separate from the value stored at the location.)Function parameter:  Variable declared in a function definition, used for referencing variables passed to the function.Function argument: Variable outside the function which is passed to the function by the caller.Object variable:  Variable whose basic underlying value is not the "object" itself, rather its value is a pointer (memory location value) to another location in memory where the object\'s actual data is stored.  In most higher-generation languages, the "pointer" aspect is effectively hidden by automatic de-referencing in various contexts.Primitive variable: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable\'s value IS the actual value represented by the variable\'s symbol rather than a pointer to another memory location.Function arguments and parameters are not the same thing.  Also, a variable\'s value is not the variable\'s object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.Pass-by-value or Call-by-sharing (for objects):  The function argument\'s value is COPIED to another memory location which is referenced by the function\'s parameter symbol (regardless of whether it\'s on the stack or heap).  In other words, the function parameter received a copy of the passed argument\'s value... AND (critical) the argument\'s value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable\'s value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter\'s value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument\'s value IS NEVER UPDATED, so it will continue to point to the same object throughout and even after the function call (even if its object\'s data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.Call / Pass-by-reference:  The function argument\'s value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective "alias" for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object\'s data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object\'s data via the function parameter is synonymous to "pass-by-value".Object clone/copy: A new object is created and the original object\'s data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.An easy way to determine whether something is "pass by reference" is whether you can write a "swap" function. For example, in C, you can do:If you can\'t do the equivalent of that in Javascript, it is not "pass by reference".My simple way to understand this...When calling a function, you are passing the content (reference or\nvalue) of the argument variables, not the the variables themselves.Inside the function, parameter variables, inVar1 and inVar2, receive the contents being passed.Since inVar2 received the reference of { prop: 2 }, you can change the value of the object\'s property.In a low level language, if you want to pass a variable by reference you have to use a specific syntax in the creation of the function:The &age is a reference to myAge, but if you want the value you have to convert the reference, using *age.Javascript is a high level language that does this conversion for you. \nSo, although objects are passed by reference, the language converts the reference parameter to the value. You don\'t need to use &, on the function definition, to pass it by reference, neither *, on the function body, to convert the reference to the value, JS does it for you.  That\'s why when you try to change an object inside a function, by replacing it\'s value (i.e. age = {value:5}), the change doesn\'t persist, but if you change it\'s properties (i.e. age.value = 5), it does.Learn moreI have found the extend method of the Underscore.js library very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.I\'ve read through these answers multiple times, but didn\'t REALLY get it until I learned about the technical definition of "Call by sharing" as termed by Barbara LiskovThe semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren\'t visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller\'s scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned \xe2\x80\x94 it is shared.That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.For programming language lawyers, I\'ve went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as asking it on the ECMAScript mailing list. TL;DR: Everythings\'re passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard. Section 11.2.4 "Argument Lists" says the following on producing a argument list consisting of only 1 argument: The production ArgumentList : AssignmentExpression is evaluated as follows:The section also enumerate cases where argument list has 0 or >1 arguments. Thus, everything\'s are passed by reference. Section 11.2.1 "Property Accessors" The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:Thus, properties of Objects are always available as reference. It is described in section 8.7 "The Reference Specification Type", that references are not real types in the language - they\'re only used to describe the behavior of the delete, the typeof, and the assignment operators. It is defined in 5.1 edition that "An Object is a collection of properties". Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of effort to understand. Simple values inside functions will not change those values outside of the function (they are passed by value), whereas complex ones will (they are passed by reference).Array and Object is passed as  pass by reference or  pass by value based on these two condition.if you are changing value of that Object or array with new Object or Array then it is pass by Value.object1 = {item: "car"};\n  array1=[1,2,3];here you are assigning new object or array to old one.you are not changing the value of property \nof old object.so it is pass by value.if you are changing a property value of an object or array then it is pass by Reference.object1.key1= "car";\n  array1[0]=9;here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.CodeI would say it is pass-by-copy -Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.sharing what I know of references in javascriptIn Javascript, objects are stored as references:Primitives are passed by value and objects are passed by reference. This is quite different from other languages like C, VB or Delphi. I can\'t say how they handle objects and primitives exactly, but I know of VB and Delphi that it can (and should) be specified.php does something similar since version 5: all objects are passed by reference, but all primitives may be passed by reference, if preceeded by an ampersand (&). Otherwise primitives are passed by value.So in javascript, if I pass an object X into a function via a parameter, it will still be X. If you are changing data inside the function (or any other object, but that\'s not important) that new value is also available outside the function.In some case, this may be helpful to alter anArg:With an object, the variable is essentially a pointer on the stack that points to the memory location on the heap where the object is stored. \nWith a primitive, the variable and the value are stored together on the stack.When you pass an object variable in JavaScript, it is always passed by Reference, meaning that the a copy of the REFERENCE is passed to the callee. If the underlying object is manipulated by the callee, the original object will be modified outside the function as well.When you pass a stack variable in JavaScript, a copy of the actual value is passed to the callee. If the callee modifies the value it receives, the value is not modified outside of the function.