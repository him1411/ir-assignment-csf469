How do I iterate through each line of a text file with Bash?With this scriptI get this output on the screen:(Later I want to do something more complicated with $p than\njust output to the screen.)The environment variable SHELL is (from env):/bin/bash --version output:cat /proc/version output:The file peptides.txt contains:One way to do it is:Exceptionally, if the loop body may read from standard input, you can open the file using a different file descriptor:Here, 10 is just an arbitrary number (different from 0, 1, 2).Option 1a:  While loop:  Single line at a time:  Input redirectionOption 1b:  While loop:  Single line at a time:\nOpen the file, read from a file descriptor (in this case file descriptor #4).  Option 2:  For loop:  Read file into single variable and parse.\nThis syntax will parse "lines" based on any white space between the tokens.  This still works because the given input file lines are single work tokens.  If there were more than one token per line, then this method would not work as well.  Also, reading the full file into a single variable is not a good strategy for large files.  This is no better than other answers, but is one more way to get the job done in a file without spaces (see comments). I find that I often need one-liners to dig through lists in text files without the extra step of using separate script files.This format allows me to put it all in one command-line. Change the "echo $word" portion to whatever you want and you can issue multiple commands separated by semicolons. The following example uses the file\'s contents as arguments into two other scripts you may have written.Or if you intend to use this like a stream editor (learn sed) you can dump the output to another file as follows.I\'ve used these as written above because I have used text files where I\'ve created them with one word per line. (See comments) If you have spaces that you don\'t want splitting your words/lines, it gets a little uglier, but the same command still works as follows:This just tells the shell to split on newlines only, not spaces, then returns the environment back to what it was previously. At this point, you may want to consider putting it all into a shell script rather than squeezing it all into a single line, though.Best of luck!Use a while loop, like this:Notes: If you don\'t set the IFS properly, you will lose indentation.You should almost always use the -r option with read.Don\'t read lines with forA few more things not covered by other answers:orAnd thenMore about the shell builtins read and readarray commandsMore about IFSIf you don\'t want your read to be broken by newline character, use -Then run the script with file name as parameter.Suppose you have this file:There are four elements that will alter the meaning of the file output read by many Bash solutions: If you want the text file line by line including blank lines and terminating lines without CR, you must use a while loop and you must have an alternate test for the final line.  Here are the methods that may change the file (in comparison to what cat returns):1) Lose the last line and leading and trailing spaces:(If you do while IFS= read -r p; do printf "%s\\n" "\'$p\'"; done </tmp/test.txt instead, you preserve the leading and trailing spaces but still lose the last line if it is not terminated with CR)2) Using process substitution with cat will reads the entire file in one gulp and loses the meaning of individual lines:(If you remove the " from $(cat /tmp/test.txt) you read the file word by word rather than one gulp. Also probably not what is intended...)The most robust and simplest way to read a file line-by-line and preserve all spacing is:If you want to strip leading and trading spaces, remove the IFS= part:(A text file without a terminating \\n, while fairly common, is considered broken under POSIX. If you can count on the trailing \\n you do not need || [[ -n $line ]] in the while loop.) More at the BASH FAQHere is my real life example how to loop lines of another program output, check for substrings, drop double quotes from variable, use that variable outside of the loop. I guess quite many is asking these questions sooner or later.Declare variable outside of the loop, set value and use it outside of loop requires done <<< "$(...)" syntax. Application need to be run within a context of current console. Quotes around the command keeps newlines of output stream.Loop match for substrings then reads name=value pair, splits right-side part of last = character, drops first quote, drops last quote, we have a clean value to be used elsewhere.@Peter: This could work out for you-This would return the output-