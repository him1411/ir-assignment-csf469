I committed the wrong files into Git. I haven\'t pushed the commit to the server yet.How can I undo those commits? 1 Note, however, that you don\'t need to reset to an earlier commit if you just made a mistake in your commit message. The easier option is to git reset (to upstage any changes you\'ve made since) and then git commit --amend, which will open your default commit message editor pre-populated with the last commit message. Beware however that if you have added any new changes to the index, using commit --amend will add them to your previous commit.Undoing a commit is a little scary if you don\'t know how it works.  But it\'s actually amazingly easy if you do understand.Say you have this, where C is your HEAD and (F) is the state of your files.You want to nuke commit C and never see it again.  You do this:The result is:Now B is the HEAD.  Because you used --hard, your files are reset to their state at commit B.Ah, but suppose commit C wasn\'t a disaster, but just a bit off.  You want to undo the commit but keep your changes for a bit of editing before you do a better commit.  Starting again from here, with C as your HEAD:You can do this, leaving off the --hard:In this case the result is:In both cases, HEAD is just a pointer to the latest commit.  When you do a git reset HEAD~1, you tell Git to move the HEAD pointer back one commit.  But (unless you use --hard) you leave your files as they were.  So now git status shows the changes you had checked into C.  You haven\'t lost a thing!For the lightest touch, you can even undo your commit but leave your files and your index:This not only leaves your files alone, it even leaves your index alone.  When you do git status, you\'ll see that the same files are in the index as before.  In fact, right after this command, you could do git commit and you\'d be redoing the same commit you just had.One more thing: Suppose you destroy a commit as in the first example, but then discover you needed it after all?  Tough luck, right?Nope, there\'s still a way to get it back.  Type git reflog and you\'ll see a list of (partial) commit shas that you\'ve moved around in.  Find the commit you destroyed, and do this:You\'ve now resurrected that commit.  Commits don\'t actually get destroyed in Git for some 90 days, so you can usually go back and rescue one you didn\'t mean to get rid of.Add/remove files to get things the way you want:Then amend the commit:The previous, erroneous commit will be edited to reflect the new index state - in other words, it\'ll be like you never made the mistake in the first place.Note that you should only do this if you haven\'t pushed yet. If you have pushed, then you\'ll just have to commit a fix normally.This took me a while to figure out, so maybe this will help someone...There are two ways to "undo" your last commit, depending on whether or not you have already made your commit public (pushed to your remote repository):Lets say I committed locally, but now want to remove that commit.To restore everything back to the way it was prior to the last commit, we need to reset to the commit before HEAD:Now git log will show that our last commit has been removed.If you have already made your commits public, you will want to create a new commit which will "revert" the changes you made in your previous commit (current HEAD).Your changes will now be reverted and ready for you to commit:For more info, check out Git Basics - Undoing ThingsorWarning: The above command will permanently remove the modifications to the .java files (and any other files) that you wanted to commit.The hard reset to HEAD-1 will set your working copy to the state of the commit before your wrong commit.Replace the files in the index:Then, if it\'s a private branch, amend the commit:Or, if it\'s a shared branch, make a new commit:\n(to change a previous commit, use the awesome interactive rebase)ProTip\xe2\x84\xa2: \xc2\xa0 Add *.class to a gitignore to stop this happening again.Amending a commit is the ideal solution if you need to change the last commit, but a more general solution is reset.You can reset git to any commit with:Where N is the number of commits before HEAD, and @~ resets to the previous commit.So, instead of amending the commit, you could use:Check out git help reset, specifically the sections on --soft --mixed and --hard, for a better understanding of what this does.If you mess up, you can always use the reflog to find dropped commits:Use git revert commit-idTo get the commit ID, just use git logIf you have Git Extras installed, you can run git undo to undo the latest commit. git undo 3 will undo the last 3 commits.If you are planning undoing a local commit entirely, whatever you changes you did on the commit, and if you don\'t worry anything about that, just do the following command.(This command will ignore your entire commit and your changes will be lost completely from your local working tree). If you want to undo your commit, but you want your changes in the staging area (before commit just like after git add) then do the following command.Now your committed files comes into the staging area. Suppose if you want to unstage the files, because you need to edit some wrong conent, then do the following commandNow committed files come from the staged area into the unstaged area. Now files are ready to edit, so whatever you changes, you want go edit and added it and make a fresh/new commit.MoreI wanted to undo the lastest 5 commits in our shared repository. I looked up the revision id that I wanted to rollback to. Then I typed in the following.I prefer to use git rebase -i for this job, because a nice list pops up where I can choose the commits to get rid of. It might not be as direct as some other answers here, but it just feels right.Choose how many commits you want to list, then invoke like this (to enlist last three)Sample listThen git will remove commits for any line that you remove.Use git-gui (or similar) to perform a git commit --amend. From the GUI you can add or remove individual files from the commit. You can also modify the commit message. Just reset your branch to the previous location (for example, using gitk or git rebase). Then reapply your changes from a saved copy. After garbage collection in your local repository, it will be like the unwanted commit never happened. To do all of that in a single command, use git reset HEAD~1.Word of warning: Careless use of git reset is a good way to get your working copy into a confusing state. I recommend that Git novices avoid this if they can.Perform a reverse cherry pick (git-revert) to undo the changes.If you haven\'t yet pulled other changes onto your branch, you can simply do...Then push your updated branch to the shared repository.If you have committed junk but not pushed,HEAD~1 is a shorthand for the commit before head. Alternatively you can refer to the SHA-1 of the hash if you want to reset to. --soft option will delete the commit but it will leave all your changed files "Changes to be committed", as git status would put it.If you want to get rid of any changes to tracked files in the working tree since the commit before head use "--hard" instead.ORIf you already pushed and someone pulled which is usually my case, you can\'t use git reset. You can however do a git revert,This will create a new commit that reverses everything introduced by the accidental commit.If you want to permanently undo it and you have cloned some repository The commit id can be seen by Then you can do -On SourceTree (GUI for GitHub), you may right-click the commit and do a \'Reverse Commit\'. This should undo your changes.On the terminal:You may alternatively use:Or:A single command:It works great to undo the last local commit!How to undo the last Git commit?To restore everything back to the way it was prior to the last commit, we need to reset to the commit before HEAD.If you don\'t want to keep your changes that you made:If you want to keep your changes:Now check your git log. It will show that our last commit has been removed.Use reflog to find a correct state\nREFLOG BEFORE RESETSelect the correct reflog (f3cb6e2 in my case) and type After that the repo HEAD will be reset to that HEADid\n\nLOG AFTER RESETFinally the reflog looks like the picture below\nREFLOG FINALFirst run: It will show you all the possible actions you have performed on your repository, for example, commit, merge, pull, etc.Then do:"Reset the working tree to the last commit""Clean unknown files from the working tree"see - Git Quick ReferenceNOTE: This command will delete your previous commit, so use with caution! git reset --hard is safer \xe2\x80\x93Another way:Checkout the branch you want to revert, then reset your local working copy back to the commit that you want to be the latest one on the remote server (everything after it will go bye-bye). To do this, in SourceTree I right-clicked on the and selected "Reset BRANCHNAME to this commit".Then navigate to your repository\'s local directory and run this command:This will erase all commits after the current one in your local repository but only for that one branch.Type git log and find the last commit hash code and then enter:In my case I accidentally committed some files I did not want to. So I did the following and it worked:Verify the results with gitk or git log --statJust reset it doing the command below using git:Explain: what git reset does, it\'s basically reset to any commit you\'d like to go back to, then if you combine it with --soft key, it will go back, but keep the  changes in your file(s), so you get back to the stage which the file was just added, HEAD is the head of the branch and if you combine with ~1 (in this case you also use HEAD^), it will go back only one commit which what you want...I create the steps in the image below in more details for you, including all steps that may happens in real situations and committing the code:There are two main scenariosYou haven\'t pushed the commit yetIf the problem was extra files you commited (and you don\'t want those on repository), you can remove them using git rm and then commiting with --amendYou can also remove entire directories with -r, or even combine with other Bash commandsAfter removing the files, you can commit, with --amend optionThis will rewrite your recent local commit removing the extra files, so, these files will never be sent on push and also will be removed from your local .git repository by GC.You already pushed the commitYou can apply the same solution of the other scenario and then doing git push with the -f option, but it is not recommended since it overwrites the remote history with a divergent change (it can mess your repository).Instead, you have to do the commit without --amend (remember this about -amend`: That option rewrites the history on the last commit).git reset --soft HEAD^ or git reset --soft HEAD~This will undo the last commit.Here --soft means reset into staging.HEAD~ or HEAD^ means to move to commit before HEAD.It will replace the last commit with the new commit.Use SourceTree (graphical tool for Git) to see your commits and tree. You can manually reset it directly by right clicking it.Simple, run this in your command line:To reset to the previous revision, permanently deleting all uncommitted changes: This article has an excellent explanation as to how to go about various scenarios (where a commit has been done as well as the push OR just a commit, before the push):http://christoph.ruegg.name/blog/git-howto-revert-a-commit-already-pushed-to-a-remote-reposit.htmlFrom the article, the easiest command I saw to revert a previous commit by its commit id, was: