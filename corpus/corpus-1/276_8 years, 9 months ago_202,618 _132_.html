I have a Git repository which contains a number of subdirectories. Now I have found that one of the subdirectories is unrelated to the other and should be detached to a separate repository.How can I do this while keeping the history of the files within the subdirectory?I guess I could make a clone and remove the unwanted parts of each clone, but I suppose this would give me the complete tree when checking out an older revision etc. This might be acceptable, but I would prefer to be able to pretend that the two repositories doesn\'t have a shared history.Just to make it clear, I have the following structure:But I would like this instead:Update: This process is so common, that the git team made it much simpler with a new tool, git subtree. See here: Detach (move) subdirectory into separate Git repositoryYou want to clone your repository and then use git filter-branch to mark everything but the subdirectory you want in your new repo to be garbage-collected.To clone your local repository:(Note: the repository will be cloned using hard-links, but that is not a problem since the hard-linked files will not be modified in themselves - new ones will be created.)Now, let us preserve the interesting branches which we want to rewrite as well, and then remove the origin to avoid pushing there and to make sure that old commits will not be referenced by the origin:or for all remote branches:Now you might want to also remove tags which have no relation with the subproject; you can also do that later, but you might need to prune your repo again. I did not do so and got a WARNING: Ref \'refs/tags/v0.1\' is unchanged for all tags (since they were all unrelated to the subproject); additionally, after removing such tags more space will be reclaimed. Apparently git filter-branch should be able to rewrite other tags, but I could not verify this. If you want to remove all tags, use git tag -l | xargs git tag -d.Then use filter-branch and reset to exclude the other files, so they can be pruned. Let\'s also add --tag-name-filter cat --prune-empty to remove empty commits and to rewrite tags (note that this will have to strip their signature):or alternatively, to only rewrite the HEAD branch and ignore tags and other branches:Then delete the backup reflogs so the space can be truly reclaimed (although now the operation is destructive)and now you have a local git repository of the ABC sub-directory with all its history preserved. Note: For most uses, git filter-branch should indeed have the added parameter -- --all. Yes that\'s really dash dash space dash dash all.  This needs to be the last parameters for the command. As Matli discovered, this keeps the project branches and tags included in the new repo.Edit: various suggestions from comments below were incorporated to make sure, for instance, that the repository is actually shrunk (which was not always the case before).It turns out that this is such a common and useful practice that the overlords of git made it really easy, but you have to have a newer version of git (>= 1.7.11 May 2012). See the appendix for how to install the latest git. Also, there\'s a real-world example in the walkthrough below.Prepare the old repoNote: <name-of-folder> must NOT contain leading or trailing characters.  For instance, the folder named subproject MUST be passed as subproject, NOT ./subproject/Note for windows users: when your folder depth is > 1, <name-of-folder> must have *nix style folder separator (/). For instance, the folder named path1\\path2\\subproject MUST be passed as path1/path2/subprojectCreate the new repoLink the new repo to Github or whereverCleanup, if desiredNote: This leaves all the historical references in the repository.See the Appendix below if you\'re actually concerned about having committed a password or you need to decreasing the file size of your .git folder....These are the same steps as above, but following my exact steps for my repository instead of using <meta-named-things>.Here\'s a project I have for implementing JavaScript browser modules in node:I want to split out a single folder, btoa, into a separate git repositoryI now have a new branch, btoa-only, that only has commits for btoa and I want to create a new repository.Next I create a new repo on Github or bitbucket, or whatever and add it is the origin (btw, "origin" is just a convention, not part of the command - you could call it "remote-server" or whatever you like)Happy day!Note: If you created a repo with a README.md, .gitignore and LICENSE, you will need to pull first:Lastly, I\'ll want to remove the folder from the bigger repo...To get the latest version of git:To get brew for OS X:http://brew.shIf that doesn\'t work (you have a very old version of ubuntu), tryIf that still doesn\'t work, tryThanks to rui.araujo from the comments.By default removing files from git doesn\'t actually remove them from git, it just commits that they aren\'t there anymore. If you want to actually remove the historical references (i.e. you have a committed a password), you need to do this:After that you can check that your file or folder no longer shows up in the git history at allHowever, you can\'t "push" deletes to github and the like. If you try you\'ll get an error and you\'ll have to git pull before you can git push - and then you\'re back to having everything in your history.So if you want to delete history from the "origin" - meaning to delete it from github, bitbucket, etc - you\'ll need to delete the repo and re-push a pruned copy of the repo. But wait - there\'s more! - If you\'re really concerned about getting rid of a password or something like that you\'ll need to prune the backup (see below).The aforementioned delete history command still leaves behind a bunch of backup files - because git is all too kind in helping you to not ruin your repo by accident. It will eventually deleted orphaned files over the days and months, but it leaves them there for a while in case you realize that you accidentally deleted something you didn\'t want to.So if you really want to empty the trash to reduce the clone size of a repo immediately you have to do all of this really weird stuff:That said, I\'d recommend not performing these steps unless you know that you need to - just in case you did prune the wrong subdirectory, y\'know? The backup files shouldn\'t get cloned when you push the repo, they\'ll just be in your local copy.Paul\'s answer creates a new repository containing /ABC, but does not remove /ABC from within /XYZ.  The following command will remove /ABC from within /XYZ:Of course, test it in a \'clone --no-hardlinks\' repository first, and follow it with the reset, gc and prune commands Paul lists.I\xe2\x80\x99ve found that in order to properly delete the old history from the new repository, you have to do a little more work after the filter-branch step.Do the clone and the filter:Remove every reference to the old history. \xe2\x80\x9corigin\xe2\x80\x9d was keeping track of your clone, and \xe2\x80\x9coriginal\xe2\x80\x9d is where filter-branch saves the old stuff:Even now, your history might be stuck in a packfile that fsck won\xe2\x80\x99t touch. Tear it to shreds, creating a new packfile and deleting the unused objects:There is an explanation of this in the manual for filter-branch.Edit: Bash script added.The answers given here worked just partially for me; Lots of big files remained in the cache. What finally worked (after hours in #git on freenode):With the previous solutions, the repository size was around 100 MB. This one brought it down to 1.7 MB. Maybe it helps somebody :)The following bash script automates the task:This is no longer so complex you can just use the git filter-branch command on a clone of you repo to cull the subdirectories you don\'t want and then push to the new remote.Update: The git-subtree module was so useful that the git team pulled it into core and made it git subtree. See here: Detach (move) subdirectory into separate Git repositorygit-subtree may be useful for thishttp://github.com/apenwarr/git-subtree/blob/master/git-subtree.txt (deprecated)http://psionides.jogger.pl/2010/02/04/sharing-code-between-projects-with-git-subtree/Here is a small modification to CoolAJ86\'s "The Easy Wayâ„¢" answer in order to split multiple sub folders (let\'s say sub1and sub2) into a new git repository.Prepare the old repoNote: <name-of-folder> must NOT contain leading or trailing characters.  For instance, the folder named subproject MUST be passed as subproject, NOT ./subproject/Note for windows users: when your folder depth is > 1, <name-of-folder> must have *nix style folder separator (/). For instance, the folder named path1\\path2\\subproject MUST be passed as path1/path2/subproject. Moreover don\'t use mvcommand but move.Final note: the unique and big difference with the base answer is the second line of the script "git filter-branch..."Create the new repoLink the new repo to Github or whereverCleanup, if desiredNote: This leaves all the historical references in the repository.See the Appendix in the original answer if you\'re actually concerned about having committed a password or you need to decreasing the file size of your .git folder.The original question wants XYZ/ABC/(*files) to become ABC/ABC/(*files). After implementing the accepted answer for my own code, I noticed that it actually changes XYZ/ABC/(*files) into ABC/(*files). The filter-branch man page even says, The result will contain that directory (and only that) as its project root." In other words, it promotes the top-level folder "up" one level. That\'s an important distinction because, for example, in my history I had renamed a top-level folder. By promoting folders "up" one level, git loses continuity at the commit where I did the rename.My answer to the question then is to make 2 copies of the repository and manually delete the folder(s) you want to keep in each. The man page backs me up with this:[...] avoid using [this command]  if a simple single commit would suffice to fix your problemTo add to Paul\'s answer, I found that to ultimately recover space, I have to push HEAD to a clean repository and that trims down the size of the .git/objects/pack directory.i.e.After the gc prune, also do:Then you can doand the size of ABC/.git is reducedActually, some of the time consuming steps (e.g. git gc) aren\'t needed with the push to clean repository, i.e.:Proper way now is the following:git filter-branch --prune-empty --subdirectory-filter FOLDER_NAME [first_branch] [another_branch]GitHub now even have small article about such cases.But be sure to clone your original repo to separate directory first (as it would delete all the files and other directories and you probable need to work with them).So your algorithm should be:For what it\'s worth, here is how using GitHub on a Windows machine. Let\'s say you have a cloned repo in residing in C:\\dir1. The directory structure looks like this: C:\\dir1\\dir2\\dir3. The dir3 directory is the one I want to be a new separate repo.  Github:Bash Prompt:$ git filter-branch --prune-empty --subdirectory-filter dir2/dir3 HEAD\nReturned: Ref \'refs/heads/master\' was rewritten (fyi: dir2/dir3 is case sensitive.)$ git remote add some_name git@github.com:MyTeam/mynewrepo.git\ngit remote add origin etc. did not work, returned "remote origin already exists"$ git push --progress some_name master It appears that most (all?) of the answers here rely on some form of git filter-branch --subdirectory-filter and its ilk.  This may work "most times" however for some cases, for instance the case of when you renamed the folder, ex:If you do a normal git filter to extract "move_me_renamed" you will lose file change history that occurred from back when it was initially move_me (ref).It thus appears that the only way to really keep all change history (if yours is a case like this), is, in essence, to copy the repository (create a new repo, set that to be the origin), then nuke everything else and rename the subdirectory to the parent, ex:(follow steps 6-11 here if you want to push this to a new repo).This will not save you any space in your .git folder, but it will preserve all your change history for those files even across renames.  And this may not be worth it if there isn\'t "a lot" of history lost, etc.As I mentioned above, I had to use the reverse solution (deleting all commits not touching my dir/subdir/targetdir) which seemed to work pretty well removing about 95% of the commits (as desired).  There are, however, two small issues remaining.FIRST, filter-branch did a bang up job of removing commits which introduce or modify code but apparently, merge commits are beneath its station in the Gitiverse.  This is a cosmetic issue which I can probably live with (he says...backing away slowly with eyes averted).SECOND the few commits that remain are pretty much ALL duplicated!  I seem to have acquired a second, redundant timeline that spans just about the entire history of the project.  The interesting thing (which you can see from the picture below), is that my three local branches are not all on the same timeline (which is, certainly why it exists and isn\'t just garbage collected).The only thing I can imagine is that one of the deleted commits was, perhaps, the single merge commit that filter-branch actually did delete, and that created the parallel timeline as each now-unmerged strand took its own copy of the commits. (shrug Where\'s my TARDiS?)  I\'m pretty sure I can fix this issue, though I\'d really love to understand how it happened.In the case of crazy mergefest-O-RAMA, I\'ll likely be leaving that one alone since it has so firmly entrenched itself in my commit history\xe2\x80\x94menacing at me whenever I come near\xe2\x80\x94, it doesn\'t seem to be actually causing any non-cosmetic problems and because it is quite pretty in Tower.app.I had exactly this problem but all the standard solutions based on git filter-branch were extremely slow. If you have a small repository then this may not be a problem, it was for me. I wrote another git filtering program based on libgit2 which as a first step creates branches for each filtering of the primary repository and then pushes these to clean repositories as the next step. On my repository (500Mb 100000 commits) the standard git filter-branch methods took days. My program takes minutes to do the same filtering.It has the fabulous name of git_filter and lives here: https://github.com/slobobaby/git_filter on GitHub.I hope it is useful to someone.Use this filter command to remove a subdirectory, while preserving your tags and branches:You might need something like "git reflog expire --expire=now --all" before the garbage collection to actually clean the files out. git filter-branch just removes references in the history, but doesn\'t remove the reflog entries that hold the data. Of course, test this first.My disk usage dropped dramatically in doing this, though my initial conditions were somewhat different. Perhaps --subdirectory-filter negates this need, but I doubt it.Split the directories into a local branch\n\n   #change into your repo\'s directory\n   cd /path/to/repo\n   #checkout the branch\n   git checkout XYZ\n   #split multiple directories into new branch XYZ\n   git splits -b XYZ XY1 XY2\nCreate an empty repo somewhere. We\'ll assume we\'ve created an empty repo called xyz on GitHub that has path : git@github.com:simpliwp/xyz.gitPush to the new repo.\n\n   #add a new remote origin for the empty repo so we can push to the empty repo on GitHub\n   git remote add origin_xyz git@github.com:simpliwp/xyz.git\n   #push the branch to the empty repo\'s master branch\n   git push origin_xyz XYZ:master\nClone the newly created remote repo into a new local directory\n\n   #change current directory out of the old repo\n   cd /path/to/where/you/want/the/new/local/repo\n   #clone the remote repo you just pushed to \n   git clone  git@github.com:simpliwp/xyz.git\nCheck out git_split project at https://github.com/vangorra/git_splitTurn git directories into their very own repositories in their own location. No subtree funny business. This script will take an existing directory in your git repository and turn that directory into an independent repository of its own. Along the way, it will copy over the entire change history for the directory you provided. Put this into your gitconfig:I\'m sure git subtree is all fine and wonderful, but my subdirectories of git managed code that I wanted to move was all in eclipse.\nSo if you\'re using egit, it\'s painfully easy.\nTake the project you want to move and team->disconnect it, and then team->share it to the new location. It will default to trying to use the old repo location, but you can uncheck the use-existing selection and pick the new place to move it.\nAll hail egit.I recommend GitHub\'s guide to splitting subfolders into a new repository. The steps are similar to Paul\'s answer, but I found their instructions easier to understand.I have modified the instructions so that they apply for a local repository, rather than one hosted on GitHub.Open Git Bash.Change the current working directory to the location where you want to create your new repository.Clone the repository that contains the subfolder.