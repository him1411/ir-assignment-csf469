I have a data table using pandas and column labels that I need to edit to replace the original column labels. I\'d like to change the column names in a data table A where the original column names are:to I have the edited column names stored it in a list, but I don\'t know how to replace the column names.Just assign it to the .columns attribute:Use the rename function and refer the columns to be renamed. Not all the columns have to be renamed:http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.rename.htmlThe rename method can take a function, for example:Since you only want to remove the $ sign in all column names, you could just do:ORAs documented in http://pandas.pydata.org/pandas-docs/stable/text.html:It will replace the existing names with the names you provide, in the order you provide.You can also assign them by index like this:This way you can manually edit the new_names as you wish.\nWorks great when you need to rename only a few columns to correct mispellings, accents, remove special characters etc.I would like to explain a bit what happens behind the scenes.Dataframes are a set of Series.Series in turn are an extension of a numpy.arraynumpy.arrays have a property .nameThis is the name of the series. It is seldom that pandas respects this attribute, but it lingers in places and can be used to hack some pandas behaviors.A lot of answers here talks about the df.columns attribute being a list when in fact it is a Series. This means it has a .name attribute.This is what happens if you decide to fill in the name of the columns Series:Note that the name of the index always comes one column lower.The .name attribute lingers on sometimes. If you set df.columns = [\'one\', \'two\'] then the df.one.name will be \'one\'.If you set df.one.name = \'three\' then df.columns will still give you [\'one\', \'two\'], and df.one.name will give you \'three\'pd.DataFrame(df.one) will returnBecause pandas reuses the .name of the already defined Series.Pandas has ways of doing multi layered column names. There is not so much magic involved but I wanted to cover this in my answer too since I don\'t see anyone picking up on this here.This is easily achievable by setting columns to lists, like this:If you\'ve got the dataframe, df.columns dumps everything into a list you can manipulate and then reassign into your dataframe as the names of columns...Best way? IDK. A way - yes.A better way of evaluating all the main techniques put forward in the answers to the question is below using cProfile to gage memory & execution time. @kadee, @kaitlyn, & @eumiro had the functions with the fastest execution times - though these functions are so fast we\'re comparing the rounding of .000 and .001 seconds for all the answers. Moral: my answer above likely isn\'t the \'Best\' way.I\'ll focus on two things:OP clearly statesI have the edited column names stored it in a list, but I don\'t know how to replace the column names.  I do not want to solve the problem of how to replace \'$\' or strip the first character off of each column header.  OP has already done this step.  Instead I want to focus on replacing the existing columns object with a new one given a list of replacement column names.df.columns = new where new is the list of new columns names is as simple as it gets.  The drawback of this approach is that it requires editing the existing dataframe\'s columns attribute and it isn\'t done inline.  I\'ll show a few ways to perform this via pipelining without editing the existing dataframe.Setup 1\nTo focus on the need to rename of replace column names with a pre-existing list, I\'ll create a new sample dataframe df with initial column names and unrelated new column names.Solution 1\npd.DataFrame.rename It has been said already that if you had a dictionary mapping the old column names to new column names, you could use pd.DataFrame.rename.However, you can easily create that dictionary and include it in the call to rename.  The following takes advantage of the fact that when iterating over df, we iterate over each column name.This works great if your original column names are unique.  But if they are not, then this breaks down.Setup 2\nnon-unique columns  Solution 2\npd.concat using the keys argument  First, notice what happens when we attempt to use solution 1:We didn\'t map the new list as the column names.  We ended up repeating y765.  Instead, we can use the keys argument of the pd.concat function while iterating through the columns of df.Solution 3\nReconstruct.  This should only be used if you have a single dtype for all columns.  Otherwise, you\'ll end up with dtype object for all columns and converting them back requires more dictionary work.Single dtype Mixed dtype Solution 4\nThis is a gimmicky trick with transpose and set_index.  pd.DataFrame.set_index allows us to set an index inline but there is no corresponding set_columns.  So we can transpose, then set_index, and transpose back.  However, the same single dtype versus mixed dtype caveat from solution 3 applies here.Single dtype Mixed dtype Solution 5\nUse a lambda in pd.DataFrame.rename that cycles through each element of new\nIn this solution, we pass a lambda that takes x but then ignores it.  It also takes a y but doesn\'t expect it.  Instead, an iterator is given as a default value and I can then use that to cycle through one at a time without regard to what the value of x is.And as pointed out to me by the folks in sopython chat, if I add a * in between x and y, I can protect my y variable.  Though, in this context I don\'t believe it needs protecting.  It is still worth mentioning.If your new list of columns is in the same order as the existing columns, the assignment is simple:If you had a dictionary keyed on old column names to new column names, you could do the following:If you don\'t have a list or dictionary mapping, you could strip the leading $ symbol via a list comprehension:Another way we could replace the original column labels is by stripping the unwanted characters (here \'$\') from the original column labels.This could have been done by running a for loop over df.columns and appending the stripped columns to df.columns.Instead , we can do this neatly in a single statement by using list comprehension like below:(strip method in Python strips the given character from beginning and end of the string.)Real simple just use and it will assign the column names by the order you put themYou could use str.slice for that:I know this question and answer has been chewed to death. But I referred to it for inspiration for one of the problem I was having . I was able to solve it using bits and pieces from different answers hence providing my response in case anyone needs it.My method is generic wherein you can add additional delimiters by comma separating delimiters= variable and future-proof it.Working Code:Output:Note that these approach do not work for a MultiIndex. For a MultiIndex, you need to do something like the following:If you have to deal with loads of columns named by the providing system out of your control, I came up with the following approach that is a combination of a general approach and specific replacments in one go.I first create a dictionary from the dataframe column names using regex expressions in order to throw away certain appendixes of column names \nand then I add specific replacements to the dictionary to name core columns as expected later in the receiving database.This is then applied to the dataframe in one go.