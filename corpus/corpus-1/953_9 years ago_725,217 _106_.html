I\'m trying to put together a comprehensive regex to validate phone numbers. Ideally it would handle international formats, but it must handle US formats, including the following:I\'ll answer with my current attempt, but I\'m hoping somebody has something better and/or more elegant.Better option... just strip all non-digit characters on input (except \'x\' and leading \'+\' signs), taking care because of the British tendency to write numbers in the non-standard form +44 (0) ... when asked to use the international prefix (in that specific case, you should discard the (0) entirely).Then, you end up with values like:Then when you display, reformat to your hearts content. e.g.It turns out that there\'s something of a spec for this, at least for North America, called the NANP. You need to specify exactly what you want. What are legal delimiters? Spaces, dashes, and periods? No delimiter allowed? Can one mix delimiters (e.g., +0.111-222.3333)? How are extensions (e.g., 111-222-3333 x 44444) going to be handled? What about special numbers, like 911? Is the area code going to be optional or required? Here\'s a regex for a 7 or 10 digit number, with extensions allowed, delimiters are spaces, dashes, or periods:If the user wants to give you his phone number, then trust him to get it right.  If he does not want to give it to you then forcing him to enter a valid number will either send him to a competitor\'s site or make him enter a random string that fits your regex.  I might even be tempted to look up the number of a premium rate sex line and enter that instead.I would also consider any of the following as valid entries on a web site:I would also suggest looking at the "libphonenumber" Google Library. I know it is not regex but it does exactly what you want. For example, it will recognize that:is a possible number but not a valid number. It also supports countries outside the US. Highlights of functionality:The biggest problem with phone number validation is it is very culturally dependant.A regular expression is fine for checking the format of a phone number, but it\'s not really going to be able to check the validity of a phone number.I would suggest skipping a simple regular expression to test your phone number against, and using a library such as Google\'s libphonenumber (link to GitHub project).Using one of your more complex examples, 1-234-567-8901 x1234, you get the following data out of libphonenumber (link to online demo):So not only do you learn if the phone number is valid (which it is), but you also get consistent phone number formatting in your locale.As a bonus, libphonenumber has a number of datasets to check the validity of phone numbers, as well, so checking a number such as +61299999999 (the international version of (02) 9999 9999) returns as a valid number with formatting:libphonenumber also gives you many additional benefits, such as grabbing the location that the phone number is detected as being, and also getting the time zone information from the phone number:But the invalid Australian phone number ((09) 9999 9999) returns that it is not a valid phone number.Google\'s version has code for Java and Javascript, but people have also implemented libraries for other languages that use the Google i18n phone number dataset:Unless you are certain that you are always going to be accepting numbers from one locale, and they are always going to be in one format, I would heavily suggest not writing your own code for this, and using libphonenumber for validating and displaying phone numbers.Although the answer to strip all whitespace is neat, it doesn\'t really solve the problem that\'s posed, which is to find a regex.  Take, for instance, my test script that downloads a web page and extracts all phone numbers using the regex.  Since you\'d need a regex anyway, you might as well have the regex do all the work.  I came up with this:Here\'s a perl script to test it.  When you match, $1 contains the area code, $2 and $3 contain the phone number, and $5 contains the extension.  My test script downloads a file from the internet and prints all the phone numbers in it.Edit:You can change \\W* to \\s*\\W?\\s* in the regex to tighten it up a bit.  I wasn\'t thinking of the regex in terms of, say, validating user input on a form when I wrote it, but this change makes it possible to use the regex for that purpose./^(?:(?:\\(?(?:00|\\+)([1-4]\\d\\d|[1-9]\\d?)\\)?)?[\\-\\.\\ \\\\\\/]?)?((?:\\(?\\d{1,}\\)?[\\-\\.\\ \\\\\\/]?){0,})(?:[\\-\\.\\ \\\\\\/]?(?:#|ext\\.?|extension|x)[\\-\\.\\ \\\\\\/]?(\\d+))?$/iThis matches:On $n, it saves:You can test it on https://www.regexpal.com/?fam=99127I answered this question on another SO question before deciding to also include my answer as an answer on this thread, because no one was addressing how to require/not require items, just handing out regexs:\nRegex working wrong, matching unexpected thingsFrom my post on that site, I\'ve created a quick guide to assist anyone with making their own regex for their own desired phone number format, which I will caveat (like I did on the other site) that if you are too restrictive, you may not get the desired results, and there is no "one size fits all" solution to accepting all possible phone numbers in the world - only what you decide to accept as your format of choice.  Use at your own risk.I wrote simpliest (although i didn\'t need dot in it). As mentioned below, it checks only for characters, not its structure/orderNote that stripping () characters does not work for a style of writing UK numbers that is common: +44 (0) 1234 567890 which means dial either the international number:\n+441234567890\nor in the UK dial 01234567890If you just want to verify you don\'t have random garbage in the field (i.e., from form spammers) this regex should do nicely:Note that it doesn\'t have any special rules for how many digits, or what numbers are valid in those digits, it just verifies that only digits, parenthesis, dashes, plus, space, pound,  asterisk, period, comma, or the letters e, x, t are present.It should be compatible with international numbers and localization formats. Do you foresee any need to allow square, curly, or angled brackets for some regions? (currently they aren\'t included).If you want to maintain per digit rules (such as in US Area Codes and Prefixes (exchange codes) must fall in the range of 200-999) well, good luck to you. Maintaining a complex rule-set which could be outdated at any point in the future by any country in the world does not sound fun.And while stripping all/most non-numeric characters may work well on the server side (especially if you are planning on passing these values to a dialer), you may not want to thrash the user\'s input during validation, particularly if you want them to make corrections in another field.Have you had a look over at RegExLib?Entering US phone number brought back quite a list of possibilities.If you\'re talking about form validation, the regexp to validate correct meaning as well as correct data is going to be extremely complex because of varying country and provider standards. It will also be hard to keep up to date.I interpret the question as looking for a broadly valid pattern, which may not be internally consistent - for example having a valid set of numbers, but not validating that the trunk-line, exchange, etc. to the valid pattern for the country code prefix.North America is straightforward, and for international I prefer to use an \'idiomatic\' pattern which covers the ways in which people specify and remember their numbers:The North American pattern makes sure that if one parenthesis is included both are.  The international accounts for an optional initial \'+\' and country code.  After that, you\'re in the idiom.  Valid matches would be:This may be biased as my experience is limited to North America, Europe and a small bit of Asia.My attempt at an unrestrictive regex:Accepts:Rejects:It is up to you to sanitize it for display. After validating it could be a number though.I found this to work quite well:It works for these number formats:Make sure to use global AND multiline flags to make sure.Link:  http://www.regexr.com/3bp4bYou\'ll have a hard time dealing with international numbers with a single/simple regex, see this post on the difficulties of international (and even north american) phone numbers.You\'ll want to parse the first few digits to determine what the country code is, then act differently based on the country.Beyond that - the list you gave does not include another common US format - leaving off the initial 1.  Most cell phones in the US don\'t require it, and it\'ll start to baffle the younger generation unless they\'ve dialed internationally.You\'ve correctly identified that it\'s a tricky problem...-AdamMy gut feeling is reinforced by the amount of replies to this topic - that there is a virtually infinite number of solutions to this problem, none of which are going to be elegant.Honestly, I would recommend you don\'t try to validate phone numbers. Even if you could write a big, hairy validator that would allow all the different legitimate formats, it would end up allowing pretty much anything even remotely resembling a phone number in the first place.In my opinion, the most elegant solution is to validate a minimum length, nothing more.This is a simple Regular Expression pattern for Philippine Mobile Phone Numbers:orwill match these: The first one will match ANY two digit country code, while the second one will match the Philippine country code exclusively.Test it here: http://refiddle.com/1oxAfter reading through these answers, it looks like there wasn\'t a straightforward regular expression that can parse through a bunch of text and pull out phone numbers in any format (including international with and without the plus sign).Here\'s what I used for a client project recently, where we had to convert all phone numbers in any format to tel: links.So far, it\'s been working with everything they\'ve thrown at it, but if errors come up, I\'ll update this answer.Regex:/(\\+*\\d{1,})*([ |\\(])*(\\d{3})[^\\d]*(\\d{3})[^\\d]*(\\d{4})/PHP function to replace all phone numbers with tel: links (in case anyone is curious):Here\'s a wonderful pattern that most closely matched the validation that I needed to achieve. I\'m not the original author, but I think it\'s well worth sharing as I found this problem to be very complex and without a concise or widely useful answer.The following regex will catch widely used number and character combinations in a variety of global phone number formats:/^\\s*(?:\\+?(\\d{1,3}))?([-. (]*(\\d{3})[-. )]*)?((\\d{3})[-. ]*(\\d{2,4})(?:[-.x ]*(\\d+))?)\\s*$/gmPositive:\n+42 555.123.4567\n+1-(800)-123-4567\n+7 555 1234567\n+7(926)1234567\n(926) 1234567\n+79261234567\n926 1234567\n9261234567\n1234567\n123-4567\n123-89-01\n495 1234567\n469 123 45 67\n89261234567\n8 (926) 1234567\n926.123.4567\n415-555-1234\n650-555-2345\n(416)555-3456\n202 555 4567\n4035555678\n1 416 555 9292Negative:\n926 3 4\n8 800 600-APPLEOriginal source: http://www.regexr.com/38pvbHere\'s my best try so far. It handles the formats above but I\'m sure I\'m missing some other possible formats.I believe the Number::Phone::US and Regexp::Common  (particularly the source of Regexp::Common::URI::RFC2806) Perl modules could help.The question should probably be specified in a bit more detail to explain the purpose of validating the numbers.  For instance, 911 is a valid number in the US, but 911x isn\'t for any value of x.  That\'s so that the phone company can calculate when you are done dialing.  There are several variations on this issue.  But your regex doesn\'t check the area code portion, so that doesn\'t seem to be a concern.Like validating email addresses, even if you have a valid result you can\'t know if it\'s assigned to someone until you try it.If you are trying to validate user input, why not normalize the result and be done with it?  If the user puts in a number you can\'t recognize as a valid number, either save it as inputted or strip out undailable characters.  The Number::Phone::Normalize Perl module could be a source of inspiration.I work for a market research company and we have to filter these types of input alllll the time. You\'re complicating it too much. Just strip the non-alphanumeric chars, and see if there\'s an extension.For further analysis you can subscribe to one of many providers that will give you access to a database of valid numbers as well as tell you if they\'re landlines or mobiles, disconnected, etc. It costs money.Do a replace on formatting characters, then check the remaining for phone validity.  In PHP, Breaking a complex regexp like this can be just as effective, but much more simple.I found this to be something interesting. I have not tested it but it looks as if it would workYou would probably be better off using a Masked Input for this.  That way users can ONLY enter numbers and you can format however you see fit.  I\'m not sure if this is for a web application, but if it is there is a very click jQuery plugin that offers some options for doing this.  http://digitalbush.com/projects/masked-input-plugin/They even go over how to mask phone number inputs in their tutorial.Here\'s one that works well in JavaScript. It\'s in a string because that\'s what the Dojo widget was expecting.It matches a 10 digit North America NANP number with optional extension. Spaces, dashes and periods are accepted delimiters.I was struggling with the same issue, trying to make my application future proof, but these guys got me going in the right direction. I\'m not actually checking the number itself to see if it works or not, I\'m just trying to make sure that a series of numbers was entered that may or may not have an extension.Worst case scenario if the user had to pull an unformatted number from the XML file, they would still just type the numbers into the phone\'s numberpad 012345678x5, no real reason to keep it pretty. That kind of RegEx would come out something like this for me:My inclination is to agree that stripping non-digits and just accepting what\'s there is best. Maybe to ensure at least a couple digits are present, although that does prohibit something like an alphabetic phone number "ASK-JAKE" for example.A couple simple perl expressions might be:Use the first one to keep the digit groups together, which may give formatting clues. Use the second one to trivially toss all non-digits.Is it a worry that there may need to be a pause and then more keys entered? Or something like 555-1212 (wait for the beep) 123?Must end with a digit, can begin with ( or + or a digit, and may contain + - ( or )Working example for Turkey, just change theaccording to your needs and start using it.