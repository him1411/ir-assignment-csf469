Say, I have a script that gets called with this line:or this one:What\'s the accepted way of parsing this such that in each case (or some combination of the two) $v, $f, and  $d will all be set to true and $outFile will be equal to /fizz/someOtherFile ?I originally answered the question as the OP asked. This Q/A is getting a lot of attention, so I should also offer the non-magic way to do this. I\'m going to expand upon guneysus\'s answer to fix the nasty sed and include Tobias Kienzler\'s suggestion.Two of the most common ways to pass key value pair arguments are:Usage      ./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts To better understand ${i#*=} search for "Substring Removal" in this guide. It is functionally equivalent to `sed \'s/[^=]*=//\' <<< "$i"` which calls a needless subprocess or `echo "$i" | sed \'s/[^=]*=//\'` which calls two needless subprocesses. from: http://mywiki.wooledge.org/BashFAQ/035#getoptsNever use getopt(1). getopt cannot handle empty arguments strings, or arguments with embedded whitespace. Please forget that it ever existed.The POSIX shell (and others) offer getopts which is safe to use instead. Here is a simplistic getopts example:The advantages of getopts are:The disadvantage of getopts is that it can only handle short options (-h, not --help) without trickery.There is a getopts tutorial which explains what all of the syntax and variables mean.  In bash, there is also help getopts, which might be informative.No answer mentions enhanced getopt. And the top-voted answer is misleading: It ignores -\xe2\x81\xa0vfd style short options (requested by the OP), options after positional arguments (also requested by the OP) and it ignores parsing-errors. Instead:The following callsall returnwith the following myscript1 enhanced getopt is available on most \xe2\x80\x9cbash-systems\xe2\x80\x9d, including Cygwin; on OS X try brew install gnu-getopt\n2 the POSIX exec() conventions have no reliable way to pass binary NULL in command line arguments; those bytes prematurely end the argument\n3 first version released in 1997 or before (I only tracked it back to 1997)getopt()/getopts() is a good option.  Stolen from here:The simple use of "getopt" is shown in this mini-script:What we have said is that any of -a,\n  -b, -c or -d will be allowed, but that -c is followed by an argument (the "c:" says that).If we call this "g" and try it out:We start with two arguments, and\n  "getopt" breaks apart the options and\n  puts each in its own argument. It also\n  added "--".from : digitalpeer.com with minor modificationsUsage      myscript.sh -p=my_prefix -s=dirname -l=libnameTo better understand ${i#*=} search for "Substring Removal" in this guide. It is functionally equivalent to `sed \'s/[^=]*=//\' <<< "$i"` which calls a needless subprocess or `echo "$i" | sed \'s/[^=]*=//\'` which calls two needless subprocesses.At the risk of adding another example to ignore, here\'s my scheme.Hope it\'s useful to someone.I\'m about 4 years late to this question, but want to give back. I used the earlier answers as a starting point to tidy up my old adhoc param parsing. I then refactored out the following template code. It handles both long and short params, using = or space separated arguments, as well as multiple short params grouped together. Finally it re-inserts any non-param arguments back into the $1,$2.. variables. I hope it\'s useful.My answer is largely based on the answer by Bruno Bronosky, but I sort of mashed his two pure bash implementations into one that I use pretty frequently.This allows you to have both space separated options/values, as well as equal defined values.So you could run your script using:as well as:and both should have the same end result.PROS:Allows for both -arg=value and -arg valueWorks with any arg name that you can use in bashPure bash. No need to learn/use getopt or getoptsCONS:Can\'t combine argsThese are the only pros/cons I can think of off the top of my headI think this one is simple enough to use:Invocation example:Expanding on the excellent answer by @guneysus, here is a tweak that lets user use whichever syntax they prefer, egvsThat is to say the equals can be replaced with whitespace. This "fuzzy interpretation" might not be to your liking, but if you are making scripts that are interchangeable with other utilities (as is the case with mine, which must work with ffmpeg), the flexibility is useful.I have found the matter to write portable parsing in scripts so frustrating that I have written Argbash - a FOSS code generator that can generate the arguments-parsing code for your script plus it has some nice features:https://argbash.ioThis is how I do in a function to avoid breaking getopts run at the same time somewhere higher in stack:getopts works great if #1 you have it installed and #2 you intend to run it on the same platform. OSX and Linux (for example) behave differently in this respect.Here is a (non getopts) solution that supports equals, non-equals, and boolean flags. For example you could run your script in this way:I give you The Function parse_params that will parse params:The script below is a copy-paste working demonstration. See show_use function to understand how to use parse_params.Limitations:  I\'d like to offer my version of option parsing, that allows for the following:Also allows for this (could be unwanted):You have to decide before use if = is to be used on an option or not. This is to keep the code clean(ish).EasyOptions does not require any parsing:Freely mixing flags between positional arguments:can be accomplished with a fairly concise approach:It\'s usualy clearer to not mix --flag=value and --flag value styles.This is a little dicey to read, but is still validSourceNote that getopt(1) was a short living mistake from AT&T.getopt was created in 1984 but already buried in 1986 because it was not really usable.A proof for the  fact that getopt is very outdated is that the getopt(1) man page still mentions "$*" instead of "$@", that was added to the Bourne Shell in 1986 together with the getopts(1) shell builtin in order to deal with arguments with spaces inside.BTW: if you are interested in parsing long options in shell scripts, it may be of interest to know that the getopt(3) implementation from libc (Solaris) and ksh93 both added a uniform long option implementation that supports long options as aliases for short options. This causes ksh93 and the Bourne Shell to implement a uniform interface for long options via getopts.An example for long options taken from the Bourne Shell man page:getopts "f:(file)(input-file)o:(output-file)" OPTX "$@"shows how long option aliases may be used in both Bourne Shell and ksh93.See the man page of a recent Bourne Shell:http://schillix.sourceforge.net/man/man1/bosh.1.htmland the man page for getopt(3) from OpenSolaris:http://schillix.sourceforge.net/man/man3c/getopt.3c.htmland last, the getopt(1) man page to verify the outdated $*:http://schillix.sourceforge.net/man/man1/getopt.1.htmlHere is my improved solution of Bruno Bronosky\'s answer using variable arrays.it lets you mix parameters position and give you a parameter array preserving the order without the optionsWill output for example:Here is my solution. It is VERY flexible and unlike others, shouldn\'t require external packages and handles leftover arguments cleanly.Usage is: ./myscript -flag flagvariable -otherflag flagvar2All you have to do is edit the validflags line. It prepends a hyphen and searches all arguments. It then defines the next argument as the flag name e.g.The main code (short version, verbose with examples further down, also a version with erroring out):The verbose version with built in echo demos:Final one, this one errors out if an invalid -argument is passed through.Pros: What it does, it handles very well. It preserves unused arguments which a lot of the other solutions here don\'t. It also allows for variables to be called without being defined by hand in the script. It also allows prepopulation of variables if no corresponding argument is given. (See verbose example).Cons: Can\'t parse a single complex arg string e.g. -xcvf would process as a single argument. You could somewhat easily write additional code into mine that adds this functionality though. The top answer to this question seemed a bit buggy when I tried it -- here\'s my solution which I\'ve found to be more robust:I have write a bash helper to write a nice bash toolproject home: https://gitlab.mbedsys.org/mbedsys/bashoptsexample:will give help:enjoy :)Here is my approach - using regexp.script:Use module "arguments" from bash-modulesExample:This also might be useful to know, you can set a value and if someone provides input, override the default with that value.. myscript.sh -f ./serverlist.txt  or just ./myscript.sh   (and it takes defaults)Similar to the solution Bruno Bronosky posted this here is one without the usage of getopt(s).Main differentiating feature of my solution is that it allows to have options concatenated together just like tar -xzf foo.tar.gz is equal to tar -x -z -f foo.tar.gz. And just like in tar, ps etc. the leading hyphen is optional for a block of short options (but this can be changed easily). Long options are supported as well (but when a block starts with one then two leading hyphens are required).For the example usage please see the examples further below.For what its worth there the options with arguments don\'t be the last (only long options need to be). So while e.g. in tar (at least in some implementations) the f options needs to be last because the file name follows (tar xzf bar.tar.gz works but tar xfz bar.tar.gz does not) this is not the case here (see the later examples).As another bonus the option parameters are consumed in the order of the options by the parameters with required options. Just look at the output of my script here with the command line abc X Y Z (or -abc X Y Z):Also you can also have long options in option block given that they occur last in the block. So the following command lines are all equivalent (including the order in which the options and its arguments are being processed):All of these lead to:Options with optional arguments should be possible with a bit of work, e.g. by looking forward whether there is a block without a hyphen; the user would then need to put a hyphen in front of every block following a block with a parameter having an optional parameter. Maybe this is too complicated to communicate to the user so better just require a leading hyphen altogether in this case.Things get even more complicated with multiple possible parameters. I would advise against making the options trying to be smart by determining whether the an argument might be for it or not (e.g. with an option just takes a number as an optional argument) because this might break in the future.I personally favor additional options instead of optional arguments.Just like with optional arguments I am not a fan of this (BTW, is there a thread for discussing the pros/cons of different parameter styles?) but if you want this you could probably implement it yourself just like done at http://mywiki.wooledge.org/BashFAQ/035#Manual_loop with a --long-with-arg=?* case statement and then stripping the equal sign (this is BTW the site that says that making parameter concatenation is possible with some effort but "left [it] as an exercise for the reader" which made me take them at their word but I started from scratch).POSIX-compliant, works even on ancient Busybox setups I had to deal with (with e.g. cut, head and getopts missing).This example shows how to use getopt and eval and HEREDOC and shift to handle short and long parameters with and without a required value that follows.  Also the switch/case statement is concise and easy to follow.The most significant lines of the script above are these:Short, to the point, readable, and handles just about everything (IMHO).Hope that helps someone.