I have some HTML menus, which I show completely when a user clicks on the head of these menus. I would like to hide these elements when the user clicks outside the menus\' area.Is something like this possible with jQuery?NOTE: Using stopEventPropagation() is something that should be avoided as it breaks normal event flow in the DOM. See this article for more information. Consider using this method instead.Attach a click event to the document body which closes the window. Attach a separate click event to the window which stops propagation to the document body.You can listen for a click event on document and then make sure #menucontainer is not an ancestor or the target of the clicked element by using  .closest().If it is not, then the clicked element is outside of the #menucontainer and you can safely hide it.You can also clean up after the event listener if you plan to dismiss the menu and want to stop listening for events. This function will clean up only the newly created listener, preserving any other click listeners on document. With ES2015 syntax:How to detect a click outside an element?The reason that this question is so popular and has so many answers is that it is deceptively complex. After almost eight years and dozens of answers, I am genuinely surprised to see how little care has been given to accessibility.I would like to hide these elements when the user clicks outside the menus\' area.This is a noble cause and is the actual issue. The title of the question—which is what most answers appear to attempt to address—contains an unfortunate red herring.Hint: it\'s the word "click"!If you\'re binding click handlers to close the dialog, you\'ve already failed. The reason you\'ve failed is that not everyone triggers click events. Users not using a mouse will be able to escape your dialog (and your pop-up menu is arguably a type of dialog) by pressing Tab, and they then won\'t be able to read the content behind the dialog without subsequently triggering a click event.So let\'s rephrase the question.How does one close a dialog when a user is finished with it?This is the goal. Unfortunately, now we need to bind the userisfinishedwiththedialog event, and that binding isn\'t so straightforward.So how can we detect that a user has finished using a dialog?A good start is to determine if focus has left the dialog.Hint: be careful with the blur event, blur doesn\'t propagate if the event was bound to the bubbling phase!jQuery\'s focusout will do just fine. If you can\'t use jQuery, then you can use blur during the capturing phase:Also, for many dialogs you\'ll need to allow the container to gain focus. Add tabindex="-1" to allow the dialog to receive focus dynamically without otherwise interrupting the tabbing flow.If you play with that demo for more than a minute you should quickly start seeing issues.The first is that the link in the dialog isn\'t clickable. Attempting to click on it or tab to it will lead to the dialog closing before the interaction takes place. This is because focusing the inner element triggers a focusout event before triggering a focusin event again.The fix is to queue the state change on the event loop. This can be done by using setImmediate(...), or setTimeout(..., 0) for browsers that don\'t support setImmediate. Once queued it can be cancelled by a subsequent focusin:The second issue is that the dialog won\'t close when the link is pressed again. This is because the dialog loses focus, triggering the close behavior, after which the link click triggers the dialog to reopen.Similar to the previous issue, the focus state needs to be managed. Given that the state change has already been queued, it\'s just a matter of handling focus events on the dialog triggers:If you thought you were done by handling the focus states, there\'s more you can do to simplify the user experience.This is often a "nice to have" feature, but it\'s common that when you have a modal or popup of any sort that the Esc key will close it out.If you know you have focusable elements within the dialog, you won\'t need to focus the dialog directly. If you\'re building a menu, you could focus the first menu item instead.This answer hopefully covers the basics of accessible keyboard and mouse support for this feature, but as it\'s already quite sizable I\'m going to avoid any discussion of WAI-ARIA roles and attributes, however I highly recommend that implementers refer to the spec for details on what roles they should use and any other appropriate attributes.The other solutions here didn\'t work for me so I had to use:I have an application that works similarly to Eran\'s example, except I attach the click event to the body when I open the menu... Kinda like this:More information on jQuery\'s one() functionWorks for me just fine.Now there is a plugin for that: outside events (blog post)The following happens when a clickoutside handler (WLOG) is bound to an element:So no events are stopped from propagation and additional click handlers may be used "above" the element with the outside-handler.This worked for me perfectly!!I don\'t think what you really need is to close the menu when the user clicks outside; what you need is for the menu to close when the user clicks anywhere at all on the page. If you click on the menu, or off the menu it should close right? Finding no satisfactory answers above prompted me to write this blog post the other day. For the more pedantic, there are a number of gotchas to take note of: Check the window click event target (it should propagate to the window, as long as it\'s not captured anywhere else), and ensure that it\'s not any of the menu elements.  If it\'s not, then you\'re outside your menu.Or check the position of the click, and see if it\'s contained within the menu area.As another poster said there are a lot of gotchas, especially if the element you are displaying (in this case a menu) has interactive elements.\nI\'ve found the following method to be fairly robust:After research I have found three working solutions (I forgot the page links for reference)As a variant:It has no problem with stopping event propagation and better supports multiple menus on the same page where clicking on a second menu while a first is open will leave the first open in the stopPropagation solution.Instead of using event.stopPropagation() which can have some side affects, just define a simple flag variable and add one if condition. I tested this and worked properly without any side affects of stopPropagation:With just a simple if condition:I\'ve had success with something like this:The logic is: when #menuscontainer is shown, bind a click handler to body that hides #menuscontainer only if the target (of the click) isn\'t a child of #menuscontainer.I found this method in some jQuery calendar plugin.A simple solution for the situation is:The above script will hide the div if outside of the div click event is triggered.You can see the following blog for more information : http://www.codecanal.com/detect-click-outside-div-using-javascript/Instead using flow interruption, blur/focus event or any other tricky technics, simply match event flow with element\'s kinship:To remove click outside event listener, simply:Here is the vanilla JavaScript solution for future viewers.Upon clicking any element within the document, if the clicked element\'s id is toggled, or the hidden element is not hidden and the hidden element does not contain the clicked element, toggle the element.If you are going to have multiple toggles on the same page you can use something like this:If you are scripting for IE and FF 3.* and you just want to know if the click occured within a certain box area, you could also use something like:If you click on the document, hide a given element, unless you click on that same element.Hook a click event listener on the document. Inside the event listener, you can look at the event object, in particular, the event.target to see what element was clicked:Upvote for the most popular answer, but add so, a click on a scroll bar does not [hide or whatever] your target element.Use:This is my solution to this problem:I ended up doing something like this:I have a close button within the new container for end users friendly UI purposes. I had to use return false in order to not go through. Of course, having an A HREF on there to take you somewhere would be nice, or you could call some ajax stuff instead. Either way, it works ok for me. Just what I wanted.We implemented a solution, partly based off a comment from a user above, which works perfectly for us. We use it to hide a search box / results when clicking outside those elements, excluding the element that originally.It checks if the search box is already visible first also, and in our case, it\'s also removing an active class on the hide/show search button.Function:Usage:And functions are very simple:I did it like this in YUI 3:I am checking if ancestor is not the widget element container, \nif target is not which open the widget/element, \nif widget/element I want to close is already open (not that important).The event has a property called event.path of the element which is a "static ordered list of all its ancestors in tree order". To check if an event originated from a specific DOM element or one of its children, just check the path for that specific DOM element. It can also be used to check multiple elements by logically ORing the element check in the some function.So for your case It should be 