If \'Test\' is an ordinary class, is there any difference between:andLet\'s get pedantic, because there are differences that can actually affect your code\'s behavior. Much of the following is taken from comments made to an "Old New Thing" article.Sometimes the memory returned by the new operator will be initialized, and sometimes it won\'t depending on whether the type you\'re newing up is a POD (plain old data), or if it\'s a class that contains POD members and is using a compiler-generated default constructor.Assume:In a C++98 compiler, the following should occur:new A() - zero-initializenew B   - default construct (B::m is uninitialized)new B() - default construct (B::m is uninitialized)new C   - default construct (C::m is zero-initialized)In a C++03 conformant compiler, things should work like so:new A()  - value-initialize A, which is zero-initialization since it\'s a POD.new B    - default-initializes (leaves B::m uninitialized)new B()  - value-initializes B which zero-initializes all fields since its default ctor is compiler generated as opposed to user-defined.new C    - default-initializes C, which calls the default ctor.So in all versions of C++ there\'s a difference between "new A" and "new A()" because A is a POD.And there\'s a difference in behavior between C++98 and C++03 for the case "new B()".This is one of the dusty corners of C++ that can drive you crazy. When constructing an object, sometimes you want/need the parens, sometimes you absolutely cannot have them, and sometimes it doesn\'t matter.new Thing(); is explicit that you want a constructor called whereas new Thing; is taken to imply you don\'t mind if the constructor isn\'t called.If used on a struct/class with a user-defined constructor, there is no difference. If called on a trivial struct/class (e.g. struct Thing { int i; };) then new Thing; is like malloc(sizeof(Thing)); whereas new Thing(); is like calloc(sizeof(Thing)); - it gets zero initialized.The gotcha lies in-between:The behavior of new Thingy; vs new Thingy(); in this case changed between C++98 and C++2003. See Michael Burr\'s explanation for how and why.In general we have default-initialization in first case and value-initialization in second case.For example:\nin case with int (POD type):int* test = new int - we have any initialization and value of *test can be any.int* test = new int() - *test will have 0 value.next behaviour depended from your type Test.\nWe have defferent cases: Test have defult constructor, Test have generated default constructor, Test contain POD member, non POD member...No, they are the same. But there is a difference between:andThis is because of the basic C++ (and C) rule: If something can possibly be a declaration, then it is a declaration.Edit: Re the initialisation issues regarding POD and non-POD data, while I agree with everything that has been said, I would just like to point out that these issues only apply if the thing being new\'d or otherwise constructed does not have a user-defined constructor. If there is such a constructor it will be used. For 99.99% of sensibly designed classes there will be such a constructor, and so the issues can be ignored.  Assuming that Test is a class with a defined constructor, there\'s no difference. The latter form makes it a little clearer that Test\'s constructor is running, but that\'s about it.