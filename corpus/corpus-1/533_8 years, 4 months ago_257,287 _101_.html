When is it recommended to use git rebase vs. git merge?Do I still need to merge after a successful rebase?So when do you use either one?To complement my own answer mentioned by TSamper, a rebase is quite often a good idea to do before a merge, because the idea is that you integrate in your branch Y the work of the branch B upon which you will merge.\nBut again, before merging, you resolve any conflict in your branch (i.e.: "rebase", as in "replay my work in my branch starting from a recent point from the branch B)\nIf done correctly, the subsequent merge from your branch to branch B can be fast-forward.a merge impact directly the destination branch B, which means the merges better be trivial, otherwise that branch B can be long to get back to a stable state (time for you solve all the conflicts)the point of merging after a rebase? In the case that I describe, I rebase B onto my branch, just to have the opportunity to replay my work from a more recent point from B, but while staying into my branch.\nIn this case, a merge is still needed to bring my "replayed" work onto B.The other scenario (described in Git Ready for instance), is to bring your work directly in B through a rebase (which does conserve all your nice commits, or even give you the opportunity to re-order them through an interactive rebase).\nIn that case (where you rebase while being in the B branch), you are right: no further merge is needed:A git tree at default when we have not merged nor rebased we get by rebasing:That second scenario is all about: how do I get new-feature back into master.My point, by describing the first rebase scenario, is to remind everyone that a rebase can also be used as a preliminary step to that (that being "get new-feature back into master").\nYou can use rebase to first bring master "in" the new-feature branch: the rebase will replay new-feature commits from the HEAD master, but still in the new-feature branch, effectively moving your branch starting point from an old master commit to HEAD-master.\nThat allows you to resolve any conflicts in your branch (meaning, in isolation, while allowing master to continue to evolve in parallel if your conflict resolution stage takes too long).\nThen you can switch to master and merge new-feature (or rebase new-feature onto master if you want to preserve commits done in your new-feature branch).So: It\'s simple, with rebase you say to use another branch as the new base for your work.If you have for example a branch master and you create a branch to implement a new feature, say you name it cool-feature, of course the master branch is the base for your new feature.Now at a certain point you want to add the new feature you implemented in the master branch. You could just switch to master and merge the cool-feature branch:but this way a new dummy commit is added, if you want to avoid spaghetti-history you can rebase:and then merge it in master:This time, since the topic branch has the same commits of master plus the commits with the new feature, the merge will be just a fast-forward.A lot of answers here say that merging turns all your commits into one, and therefore suggest to use rebase to preserve your commits. This is incorrect. And a bad idea if you have pushed your commits already.Merge does not obliterate your commits. Merge preserves history! (just look at gitk) Rebase rewrites history, which is a Bad Thing after you\'ve pushed it.Use merge -- not rebase whenever you\'ve already pushed.Here is Linus\' (author of git) take on it. It\'s a really good read. Or you can read my own version of the same idea below.Rebasing a branch on master:In contrast, merging a topic branch into master:If you have any doubt, use merge.The only differences between a rebase and a merge are:So the short answer is to pick rebase or merge based on what you want your history to look like.There are a few factors you should consider when choosing which operation to use.If so, don\'t rebase.  Rebase destroys the branch and those developers will have broken/inconsistent repositories unless they use git pull --rebase.  This is a good way to upset other developers quickly.Rebase is a destructive operation.  That means, if you do not apply it correctly, you could lose committed work and/or break the consistency of other developer\'s repositories.I\'ve worked on teams where the developers all came from a time when companies could afford dedicated staff to deal with branching and merging.  Those developers don\'t know much about Git and don\'t want to know much.  In these teams I wouldn\'t risk recommending rebasing for any reason.Some teams use the branch-per-feature model where each branch represents a feature (or bugfix, or sub-feature, etc.)  In this model the branch helps identify sets of related commits.  For example, one can quickly revert a feature by reverting the merge of that branch (to be fair, this is a rare operation).  Or diff a feature by comparing two branches (more common).  Rebase would destroy the branch and this would not be straightforward.I\'ve also worked on teams that used the branch-per-developer model (we\'ve all been there).  In this case the branch itself doesn\'t convey any additional information (the commit already has the author).  There would be no harm in rebasing.Reverting (as in undoing) a rebase is considerably difficult and/or impossible (if the rebase had conflicts) compared to reverting a merge.  If you think there is a chance you will want to revert then use merge.Rebase operations need to be pulled with a corresponding git pull --rebase.  If you are working by yourself you may be able to remember which you should use at the appropriate time.  If you are working on a team this will be very difficult to coordinate.  This is why most rebase workflows recommend using rebase for all merges (and git pull --rebase for all pulls).Assuming you have the following merge:Some people will state that the merge "destroys" the commit history because if you were to look at the log of only the master branch (A -- D) you would miss the important commit messages contained in B and C.If this were true we wouldn\'t have questions like this.  Basically, you will see B and C unless you explicitly ask not to see them (using --first-parent).  This is very easy to try for yourself.The two approaches merge differently, but it is not clear that one is always better than the other and it may depend on the developer workflow.  For example, if a developer tends to commit regularly (e.g. maybe they commit twice a day as they transition from work to home) then there could be a lot of commits for a given branch.  Many of those commits might not look anything like the final product (I tend to refactor my approach once or twice per feature).  If someone else was working on a related area of code and they tried to rebase my changes it could be a fairly tedious operation.If you like to alias rm to rm -rf to "save time" then maybe rebase is for you.I always think that someday I will come across a scenario where git rebase is the awesome tool that solves the problem.  Much like I think I will come across a scenario where git reflog is an awesome tool that solves my problem.  I have worked with git for over five years now.  It hasn\'t happened.Messy histories have never really been a problem for me.  I don\'t ever just read my commit history like an exciting novel.  A majority of the time I need a history I am going to use git blame or git bisect anyways.  In that case having the merge commit is actually useful to me because if the merge introduced the issue that is meaningful information to me.I feel obligated to mention that I have personally softened on using rebase although my general advice still stands.  I have recently been interacting a lot with the Angular 2 Material project.  They have used rebase to keep a very clean commit history.  This has allowed me to very easily see what commit fixed a given defect and whether or not that commit was included in a release.  It serves as a great example of using rebase correctly.Merge means: Create a single new commit that merges my changes into the destination.Rebase means: Create a whole new series of commits, using my current set of commits as hints. In other words, calculate what my changes would have looked like if I had started making them from the point I\'m rebasing on to. After the rebase, therefore, you might need to re-test your changes and during the rebase, you would possibly have a few conflicts. Given this, why would you rebase? Just to keep the development history clear. Let\'s say you\'re working on feature X and when you\'re done, you merge your changes in. The destination will now have a single commit that would say something along the lines of "Added feature X". Now, instead of merging, if you rebased and then merged, the destination development history would contain all the individual commits in a single logical progression. This makes reviewing changes later on much easier. Imagine how hard you\'d find it to review the development history if 50 developers were merging various features all the time.  That said, if you have already pushed the branch you\'re working on upstream, you should not rebase, but merge instead. For branches that have not been pushed upstream, rebase, test and merge. Another time you might want to rebase is when you want to get rid of commits from your branch before pushing upstream. For example: Commits that introduce some debugging code early on and other commits further on that clean that code up. The only way to do this is by performing an interactive rebase: git rebase -i <branch/commit/tag>UPDATE: You also want to use rebase when you\'re using Git to interface to a version control system that doesn\'t support non-linear history (subversion for example). When using the git-svn bridge, it is very important that the changes you merge back into subversion are a sequential list of changes on top of the most recent changes in trunk. There are only two ways to do that: (1) Manually re-create the changes and (2) Using the rebase command, which is a lot faster.UPDATE2 : One additional way to think of a rebase is that it enables a sort of mapping from your development style to the style accepted in the repository you\'re committing to. Let\'s say you like to commit in small, tiny chunks. You have one commit to fix a typo, one commit to get rid of unused code and so on. By the time you\'ve finished what you need to do, you have a long series of commits. Now let\'s say the repository you\'re committing to encourages large commits, so for the work you\'re doing, one would expect one or maybe two commits. How do you take your string of commits and compress them to what is expected? You would use an interactive rebase and squash your tiny commits into fewer larger chunks. The same is true if the reverse was needed - if your style was a few large commits, but the repo demanded long strings of small commits. You would use a rebase to do that as well. If you had merged instead, you have now grafted your commit style onto the main repository. If there are a lot of developers, you can imagine how hard it would be to follow a history with several different commit styles after some time.UPDATE3: Does one still need to merge after a successful rebase? Yes, you do. The reason is that a rebase essentially involves a "shifting" of commits. As I\'ve said above, these commits are calculated, but if you had 14 commits from the point of branching, then assuming nothing goes wrong with your rebase, you will be 14 commits ahead (of the point you\'re rebasing onto) after the rebase is done. You had a branch before a rebase. You will have a branch of the same length after. You still need to merge before you publish your changes. In other words, rebase as many times as you want (again, only if you have not pushed your changes upstream). Merge only after you rebase.before merge/rebase:after git merge master:after git rebase master:(A, B, C, D, E and F are commits)this example and much more well illustrated info about git can be found here: http://excess.org/article/2008/07/ogre-git-tutorial/This sentence gets it:In general the way to get the best of both worlds is to rebase local\n  changes you\xe2\x80\x99ve made but haven\xe2\x80\x99t shared yet before you push them in\n  order to clean up your story, but never rebase anything you\xe2\x80\x99ve pushed\n  somewhere.Source: http://www.git-scm.com/book/en/v2/Git-Branching-Rebasing#Rebase-vs.-MergeThe pro git book as a really good explanation on the rebasing page.Basically a merge will take 2 commits and combine them.A rebase will go to the common ancestor on the 2 and incrementally apply the changes on top of each other. This makes for a \'cleaner\' and more linear history. But when you rebase you abandon previous commits and create new ones. So you should never rebase a repo that is public. The other people working on the repo will hate you.For that reason alone I almost exclusively merge. 99% of the time my branches don\xe2\x80\x99t differ that much, so if there are conflicts it\'s only in one or two places.This answer is widely oriented around Git Flow. The tables have been generated with the nice ASCII Table Generator, and the history trees with this wonderful command (aliased as git lg):Tables are in reverse chronological order to be more consistent with the history trees. See also the difference between git merge and git merge --no-ff first (you usually want to use git merge --no-ff as it makes your history look closer to the reality):Commands:Result:Commands:Result:First point: always merge features into develop, never rebase develop from features. This is a consequence of the Golden Rule of Rebasing:The golden rule of git rebase is to never use it on public branches.In other words:Never rebase anything you\'ve pushed somewhere.I would personally add: unless it\'s a feature branch AND you and your team are aware of the consequences.So the question of git merge vs git rebase applies almost only to the feature branches (in the following examples, --no-ff has always been used when merging). Note that since I\'m not sure there\'s one better solution (a debate exists), I\'ll only provide how both commands behave. In my case, I prefer using git rebase as it produces a nicer history tree :)Commands:Result:Commands:Result:Commands:Result:Commands:Result:When you just need one specific commit, git cherry-pick is a nice solution (the -x option appends a line that says "(cherry picked from commit...)" to the original commit message body, so it\'s usually a good idea to use it - git log <commit_sha1> to see it):Commands:Result:Not sure I can explain it better than Derek Gourlay... Basically, use git pull --rebase instead of git pull :) What\'s missing in the article though, is that you can enable it by default:Again, nicely explained here. But put simple, if you enable it, you won\'t have to resolve the same conflict multiple times anymore.Git rebase is used to make the branching paths in history cleaner and repository structure linear. It is also used to keep the branches created by you private, as after rebasing and pushing the changes to server, if you delete your branch, there will be no evidence of branch you have worked upon. So your branch is now your local concern.After doing rebase we also get rid of an extra commit which we used to see if we do normal merge. And yes one still needs to do merge after a successful rebase as rebase command just puts your work on top of the branch you mentioned during rebase say master and makes the first commit of your branch as a direct descendant of the master branch. This means we can now do a fast forward merge to bring changes from this branch to master branch.Some practical examples, somewhat connected to large scale development where gerrit is used for review and delivery integration.I merge when i uplift my feature branch to a fresh remote master. This gives minimal uplift work and it\'s easy to follow the history of the feature development in for example gitk.I merge when I prepare a delivery commit.I rebase when my delivery commit fails integration for whatever reason and I need to update it towards a fresh remote master.