I want to sort a data.frame by multiple columns. For example, with the data.frame below I would like to sort by column z (descending) then by column b (ascending): You can use the order() function directly without resorting to add-on tools -- see this simpler answer which uses a trick right from the top of the example(order) code:Edit some 2+ years later:  It was just asked how to do this by column index. The answer is to simply pass the desired sorting column(s) to the order() function:rather than using the name of the column (and with() for easier/more direct access).Most of the time you should use the dplyr or data.table solutions, unless having no-dependencies is important, in which case use base::order.I recently added sort.data.frame to a CRAN package, making it class compatible as discussed here:\nBest way to create generic/method consistency for sort.data.frame?Therefore, given the data.frame dd, you can sort as follows:If you are one of the original authors of this function, please contact me.  Discussion as to public domaininess is here: http://chat.stackoverflow.com/transcript/message/1094290#1094290You can also use the arrange() function from plyr as Hadley pointed out in the above thread:Benchmarks: Note that I loaded each package in a new R session since there were a lot of conflicts.  In particular loading the doBy package causes sort to return "The following object(s) are masked from \'x (position 17)\': b, x, y, z", and loading the Deducer package overwrites sort.data.frame from Kevin Wright or the taRifx package.Median times:dd[with(dd, order(-z, b)), ] 778dd[order(-dd$z, dd$b),] 788Median time: 1,567Median time: 862Median time: 1,694Note that doBy takes a good bit of time to load the package.Couldn\'t make Deducer load.  Needs JGR console.Doesn\'t appear to be compatible with microbenchmark due to the attach/detach.(lines extend from lower quartile to upper quartile, dot is the median)Given these results and weighing simplicity vs. speed, I\'d have to give the nod to arrange in the plyr package.  It has a simple syntax and yet is almost as speedy as the base R commands with their convoluted machinations.  Typically brilliant Hadley Wickham work.  My only gripe with it is that it breaks the standard R nomenclature where sorting objects get called by sort(object), but I understand why Hadley did it that way due to issues discussed in the question linked above.Dirk\'s answer is great. It also highlights a key difference in the syntax used for indexing data.frames and data.tables:The difference between the two calls is small, but it can have important consequences. Especially if you write production code and/or are concerned with correctness in your research, it\'s best to avoid unnecessary repetition of variable names. data.table\n helps you do this.Here\'s an example of how repetition of variable names might get you into trouble:Let\'s change the context from Dirk\'s answer, and say this is part of a bigger project where there are a lot of object names and they are long and meaningful; instead of dd it\'s called quarterlyreport. It becomes :Ok, fine. Nothing wrong with that. Next your boss asks you to include last quarter\'s report in the report. You go through your code, adding an object lastquarterlyreport in various places and somehow (how on earth?) you end up with this :That isn\'t what you meant but you didn\'t spot it because you did it fast and it\'s nestled on a page of similar code. The code doesn\'t fall over (no warning and no error) because R thinks it is what you meant. You\'d hope whoever reads your report spots it, but maybe they don\'t. If you work with programming languages a lot then this situation may be all to familiar. It was a "typo" you\'ll say. I\'ll fix the "typo" you\'ll say to your boss.In data.table we\'re concerned about tiny details like this. So we\'ve done something simple to avoid typing variable names twice. Something very simple. i is evaluated within the frame of dd already, automatically. You don\'t need with() at all.Instead ofit\'s justAnd instead ofit\'s justIt\'s a very small difference, but it might just save your neck one day. When weighing up the different answers to this question, consider counting the repetitions of variable names as one of your criteria in deciding.  Some answers have quite a few repeats, others have none.There are a lot of excellent answers here, but dplyr gives the only syntax that I can quickly and easily remember (and so now use very often):For the OP\'s problem:The R package data.table provides both fast and memory efficient ordering of data.tables with a straightforward syntax (a part of which Matt has highlighted quite nicely in his answer). There has been quite a lot of improvements and also a new function setorder() since then. From v1.9.5+, setorder() also works with data.frames.First, we\'ll create a dataset big enough and benchmark the different methods mentioned from other answers and then list the features of data.table.The timings reported are from running system.time(...) on these functions shown below. The timings are tabulated below (in the order of slowest to fastest).data.table\'s DT[order(...)] syntax was ~10x faster than the fastest of other methods (dplyr), while consuming the same amount of memory as dplyr.data.table\'s setorder() was ~14x faster than the fastest of other methods (dplyr), while taking just 0.4GB extra memory. dat is now in the order we require (as it is updated by reference).Speed:data.table\'s ordering is extremely fast because it implements radix ordering. The syntax DT[order(...)] is optimised internally to use data.table\'s fast ordering as well. You can keep using the familiar base R syntax but speed up the process (and use less memory).Memory:Most of the times, we don\'t require the original data.frame or data.table after reordering. That is, we usually assign the result back to the same object, for example:The issue is that this requires at least twice (2x) the memory of the original object. To be memory efficient, data.table therefore also provides a function setorder().setorder() reorders data.tables by reference (in-place), without making any additional copies. It only uses extra memory equal to the size of one column.Other features:It supports integer, logical, numeric, character and even bit64::integer64 types.Note that factor, Date, POSIXct etc.. classes are all integer/numeric types underneath with additional attributes and are therefore supported as well. In base R, we can not use - on a character vector to sort by that column in decreasing order. Instead we have to use -xtfrm(.). However, in data.table, we can just do, for example, dat[order(-x)] or setorder(dat, -x).With this (very helpful) function by Kevin Wright, posted in the tips section of the R wiki, this is easily achieved.or you can use package doBySuppose you have a data.frame A and you want to sort it using column called x descending order. Call the sorted data.frame newdataIf you want ascending order then replace "-" with nothing. You can have something like where x and z are some columns in data.frame A. This means sort data.frame A by x descending, y ascending and z descending.Alternatively, using the package Deducerif SQL comes naturally to you, sqldf handles ORDER BY as Codd intended.I learned about order with the following example which then confused me for a long time:The only reason this example works is because order is sorting by the vector Age, not by the column named Age in the data frame data.To see this create an identical data frame using read.table with slightly different column names and without making use of any of the above vectors:The above line structure for order no longer works because there is no vector named age:The following line works because order sorts on the column age in my.data.I thought this was worth posting given how confused I was by this example for so long.  If this post is not deemed appropriate for the thread I can remove it.EDIT: May 13, 2014Below is a generalized way of sorting a data frame by every column without specifying column names.  The code below shows how to sort from left to right or by right to left.  This works if every column is numeric.  I have not tried with a character column added.  I found the do.call code a month or two ago in an old post on a different site, but only after extensive and difficult searching.  I am not sure I could relocate that post now.  The present thread is the first hit for ordering a data.frame in R.  So, I thought my expanded version of that original do.call code might be useful.Dirk\'s answer is good but if you need the sort to persist you\'ll want to apply the sort back onto the name of that data frame.  Using the example code:In response to a comment added in the OP for how to sort programmatically:Using dplyr and data.tableJust use arrange_, which is the Standard Evaluation version for arrange.more info here: https://cran.r-project.org/web/packages/dplyr/vignettes/nse.htmlIt is better to use formula as it also captures the environment to evaluate an expression inFor the sake of completeness: you can also use the sortByCol() function from the BBmisc package:Performance comparison:Just like the mechanical card sorters of long ago, first sort by the least significant key, then the next most significant, etc.  No library required, works with any number of keys and any combination of ascending and descending keys.Now we\'re ready to do the most significant key.  The sort is stable, and any ties in the most significant key have already been resolved.This may not be the fastest, but it is certainly simple and reliable