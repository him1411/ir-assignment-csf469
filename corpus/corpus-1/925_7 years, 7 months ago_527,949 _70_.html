Is there a way in bash to convert a string into a lower case string?For example, if I have:I want to convert it to:The are various ways:In Bash 4:To lowercaseTo uppercaseToggle (undocumented)Capitalize (undocumented)Title case:To turn off a declare attribute, use +. For example, declare +c string. This affects subsequent assignments and not the current value.Edit:Added "toggle first character by word" (${var~}) as suggested by ghostdog74.I know this is an oldish post but I made this answer for another site so I thought I\'d post it up here:UPPER -> lower:\nuse python:Or Ruby:Or Perl (probably my favorite):Or PHP:Or Awk:Or Sed:Or Bash 4:Or NodeJS if you have it (and are a bit nuts...):You could also use dd (but I wouldn\'t!):lower -> UPPER:use python:Or Ruby:Or Perl (probably my favorite):Or PHP:Or Awk:Or Sed:Or Bash 4:Or NodeJS if you have it (and are a bit nuts...):You could also use dd (but I wouldn\'t!):Also when you say \'shell\' I\'m assuming you mean bash but if you can use zsh it\'s as easy asfor lower case andfor upper case.In zsh:Gotta love zsh!Using GNU sed:Example:For a standard shell (without bashisms) using only builtins:And for upper case:I would like to take credit for the command I wish to share but the truth is I obtained it for my own use from http://commandlinefu.com. It has the advantage that if you cd to any directory within your own home folder that is it will change all files and folders to lower case recursively please use with caution. It is a brilliant command line fix and especially useful for those multitudes of albums you have stored on your drive.You can specify a directory in place of the dot(.) after the find which denotes current directory or full path.I hope this solution proves useful the one thing this command does not do is replace spaces with underscores - oh well another time perhaps.In bash 4 you can use typesetExample:Pre Bash 4.0Bash Lower the Case of a string and assign to variableYou can try thisref : http://wiki.workassis.com/shell-script-convert-text-to-lowercase-and-uppercase/For Bash versions earlier than 4.0, this version should be fastest (as it doesn\'t fork/exec any commands):technosaurus\'s answer had potential too, although it did run properly for mee.If using v4, this is baked-in.  If not, here is a simple, widely applicable solution.  Other answers (and comments) on this thread were quite helpful in creating the code below.Notes:In spite of how old this question is and similar to this answer by technosaurus. I had a hard time finding a solution that was portable across most platforms (That I Use) as well as older versions of bash. I have also been frustrated with arrays, functions and use of prints, echos and temporary files to retrieve trivial variables. This works very well for me so far I thought I would share.\nMy main testing environments are: Simple C-style for loop to iterate through the strings.\nFor the line below if you have not seen anything like this before\nthis is where I learned this. In this case the line checks if the char ${input:$i:1} (lower case) exists in input and if so replaces it with the given char ${ucs:$j:1} (upper case) and stores it back into input.Many answers using external programs, which is not really using Bash.If you know you will have Bash4 available you should really just use the ${VAR,,} notation (it is easy and cool). For Bash before 4 (My Mac still uses Bash 3.2 for example). I used the corrected version of @ghostdog74 \'s answer to create a more portable version.One you can call lowercase \'my STRING\' and get a lowercase version. I read comments about setting the result to a var, but that is not really portable in Bash, since we can\'t return strings. Printing it is the best solution. Easy to capture with something like var="$(lowercase $str)". How this worksThe way this works is by getting the ASCII integer representation of each char with printf and then adding 32 if upper-to->lower, or subtracting 32 if lower-to->upper. Then use printf again to convert the number back to a char. From \'A\' -to-> \'a\' we have a difference of 32 chars.Using printf to explain:97 - 65 = 32And this is the working version with examples.\nPlease note the comments in the code, as they explain a lot of stuff:And the results after running this:This should only work for ASCII characters though. For me it is fine, since I know I will only pass ASCII chars to it.\nI am using this for some case-insensitive CLI options, for example.To store the transformed string into a variable. Following worked for me -\n$SOURCE_NAME to $TARGET_NAME 