Since MySQL doesn\'t seem to have any \'boolean\' data type, which data type do you \'abuse\' for storing true/false information in MySQL?Especially in the context of writing and reading from/to a PHP script.Over time I have used and seen several approaches:None of the above seems optimal. I tend to prefer the tinyint 0/1 variant, since automatic type conversion in PHP gives me boolean values rather simply.So which data type do you use? Is there a type designed for boolean values which I have overlooked? Do you see any advantages/disadvantages by using one type or another?For MySQL 5.0.3 and higher, you can use BIT. The manual says:As of MySQL 5.0.3, the BIT data type is used to store bit-field\n  values. A type of BIT(M) enables storage of M-bit values. M can range\n  from 1 to 64.Otherwise, according to the MySQL manual you can use bool and boolean which are at the moment aliases of tinyint(1):Bool, Boolean: These types are synonyms for TINYINT(1). A value of\n  zero is considered false. Non-zero\n  values are considered true.MySQL also states that: We intend to implement full boolean\n  type handling, in accordance with\n  standard SQL, in a future MySQL\n  release.References: http://dev.mysql.com/doc/refman/5.5/en/numeric-type-overview.htmlBTW: this is just a matter of https://google.com/search?q=mysql+boolean+datatype.Funny isn\'t it, this link, posted a few years back, has become recursive.BOOL and BOOLEAN are synonyms of TINYINT(1). Zero is false, anything else is true. More information here.This is an elegant solution that I quite appreciate because it uses zero data bytes:To set it to true, set some_flag = \'\' and to set it to false, set some_flag = NULL.Then to test for true, check if some_flag IS NOT NULL, and to test for false, check if some_flag IS NULL.(This method is described in "High Performance MySQL: Optimization, Backups, Replication, and More" by Jon Warren Lentz, Baron Schwartz and Arjen Lentz.)This question has been answered but I figured I\'d throw in my $0.02. I often use a CHAR(0), where \'\' == true and NULL == false.From mysql docsCHAR(0) is also quite nice when you need a column that can take only\n  two values: A column that is defined as CHAR(0) NULL occupies only one\n  bit and can take only the values NULL and \'\' (the empty string).If you use the BOOLEAN type, this is aliased to TINYINT(1).  This is best if you want to use standardised SQL and don\'t mind that the field could contain an out of range value (basically anything that isn\'t 0 will be \'true\').ENUM(\'False\', \'True\') will let you use the strings in your SQL, and MySQL will store the field internally as an integer where \'False\'=0 and \'True\'=1 based on the order the Enum is specified.In MySQL 5+ you can use a BIT(1) field to indicate a 1-bit numeric type.  I don\'t believe this actually uses any less space in the storage but again allows you to constrain the possible values to 1 or 0.All of the above will use approximately the same amount of storage, so it\'s best to pick the one you find easiest to work with.I use TINYINT(1) in order to store boolean values in Mysql.I don\'t know if there is any advantage to use this... But if i\'m not wrong, mysql can store boolean (BOOL) and it store it as a tinyint(1)http://dev.mysql.com/doc/refman/5.0/en/other-vendor-data-types.htmlBit is only advantageous over the various byte options (tinyint, enum, char(1)) if you have a lot of boolean fields.  One bit field still takes up a full byte.  Two bit fields fit into that same byte.  Three, four,five, six, seven, eight.  After which they start filling up the next byte.  Ultimately the savings are so small, there are thousands of other optimizations you should focus on.  Unless you\'re dealing with an enormous amount of data, those few bytes aren\'t going to add up to much.  If you\'re using bit with PHP you need to typecast the values going in and out.Until MySQL implements a bit datatype, if you\'re processing is truly pressed for space and/or time, such as with high volume transactions, create a TINYINT field called bit_flags, for all your boolean variables, and mask and shift the boolean bit you desire in your SQL query.For instance, if your left-most bit represents your bool field, and the 7 rightmost bits represent nothing, then your bit_flags field will equal 128 (binary 10000000).  Mask (hide) the seven rightmost bits (using the bitwise operator &), and shift the 8th bit seven spaces to the right, ending up with 00000001.  Now the entire number (which, in this case, is 1) is your value.You can run statements like these as you testetc...Since you have 8 bits, you have potentially 8 boolean variables, from one byte.  Some future programmer will invariably use the next seven bits, so you MUST mask.  Don\'t just shift, or you will create hell for yourself and others in the future.  Make sure you have MySQL do your masking and shifting - will be significantly faster than having the web-scripting language (PHP, ASP, etc...) do it.  Also make sure you place a comment in the MySQL comment field for your bit_flags field.You\'ll find these sites useful when implementing this method.\nhttp://dev.mysql.com/doc/refman/5.0/en/bit-functions.html\nhttp://acc6.its.brooklyn.cuny.edu/~gurwitz/core5/nav2tool.htmlI got fed up with trying to get zeroes, NULLS, and \'\' accurately round a loop of PHP, MySql and POST values, so I just use \'Yes\' and \'No\'.This works flawlessly and needs no special treatment that isn\'t obvious and easy to do.Referring to this link\n    Boolean datatype in Mysql, according to the application usage, if one wants only 0 or 1 to be stored, bit(1) is the better choice.