What are the differences between a HashMap and a Hashtable in Java?Which is more efficient for non-threaded applications?There are several differences between HashMap and Hashtable in Java:Hashtable is synchronized, whereas HashMap is not.  This makes HashMap better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.Hashtable does not allow null keys or values.  HashMap allows one null key and any number of null values.One of HashMap\'s subclasses is LinkedHashMap, so in the event that you\'d want predictable iteration order (which is insertion order by default), you could easily swap out the HashMap for a LinkedHashMap.  This wouldn\'t be as easy if you were using Hashtable.Since synchronization is not an issue for you, I\'d recommend HashMap. If synchronization becomes an issue, you may also look at ConcurrentHashMap.Note, that a lot of the answers state that Hashtable is synchronised.  In practice this buys you very little.  The synchronization is on the accessor / mutator methods will stop two threads adding or removing from the map concurrently, but in the real world you will often need additional synchronisation.A very common idiom is to "check then put" - i.e. look for an entry in the Map, and add it if it does not already exist.  This is not in any way an atomic operation whether you use Hashtable or HashMap.  An equivalently synchronised HashMap can be obtained by:But to correctly implement this logic you need additional synchronisation of the form:Even iterating over a Hashtable\'s entries (or a HashMap obtained by Collections.synchronizedMap) is not thread safe unless you also guard the Map from being modified through additional synchronization.Implementations of the ConcurrentMap interface (for example ConcurrentHashMap) solve some of this by including thread safe check-then-act semantics such as:No one\'s mentioned the fact that Hashtable is not part of the Java Collections Framework - it just provides a similar API. Also, Hashtable is considered legacy code. There\'s nothing about Hashtable that can\'t be done using HashMap or derivations of HashMap, so for new code, I don\'t see any justification for going back to Hashtable.This question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available.Note on Some Important Terms    HashMap can be synchronized byMap m = Collections.synchronizeMap(hashMap);Map provides Collection views instead of direct support for iteration\n via Enumeration objects. Collection views greatly enhance the\n expressiveness of the interface, as discussed later in this section.\n Map allows you to iterate over keys, values, or key-value pairs;\n Hashtable does not provide the third option. Map provides a safe way\n to remove entries in the midst of iteration; Hashtable did not.\n Finally, Map fixes a minor deficiency in the Hashtable interface.\n Hashtable has a method called contains, which returns true if the\n Hashtable contains a given value. Given its name, you\'d expect this\n method to return true if the Hashtable contained a given key, because\n the key is the primary access mechanism for a Hashtable. The Map\n interface eliminates this source of confusion by renaming the method\n containsValue. Also, this improves the interface\'s consistency \xe2\x80\x94\n containsValue parallels containsKey.The Map InterfaceKeep in mind that HashTable was legacy class before Java Collections Framework (JCF) was introduced and was later retrofitted to implement the Map interface. So was Vector and Stack. Therefore, always stay away from them in new code since there always better alternative in the JCF as others had pointed out.Here is the Java collection cheat sheet that you will find useful. Notice the gray block contains the legacy class HashTable,Vector and Stack.HashMap: An implementation of the Map interface that uses hash codes to index an array.\nHashtable: Hi, 1998 called. They want their collections API back.Seriously though, you\'re better off staying away from Hashtable altogether. For single-threaded apps, you don\'t need the extra overhead of syncrhonisation. For highly concurrent apps, the paranoid synchronisation might lead to starvation, deadlocks, or unnecessary garbage collection pauses. Like Tim Howland pointed out, you might use ConcurrentHashMap instead.In addition to what izb said, HashMap allows null values, whereas the Hashtable does not.Also note that Hashtable extends the Dictionary class, which as the Javadocs state, is obsolete and has been replaced by the Map interface.Take a look at this chart. It provides comparisons between different data structures along with HashMap and Hashtable. The comparison is precise, clear and easy to understand.Java Collection MatrixHashtable is similar to the HashMap and has a similar interface. It is recommended that you use HashMap, unless you require support for legacy applications or you need synchronisation, as the Hashtables methods are synchronised. So in your case as you are not multi-threading, HashMaps are your best bet.Another key difference between hashtable and hashmap is that Iterator in the HashMap is  fail-fast  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator\'s own remove()  method. But this is not a guaranteed behavior and will be done by JVM on best effort."My source: http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.htmlBeside all the other important aspects already mentioned here, Collections API (e.g. Map interface) is being modified all the time to conform to the "latest and greatest" additions to Java spec.For example, compare Java 5 Map iterating:versus the old Hashtable approach:In Java 1.8 we are also promised to be able to construct and access HashMaps like in good old scripting languages:Update: No, they won\'t land in 1.8... :(Are Project Coin's collection enhancements going to be in JDK8?HashTable is synchronized, if you are using it in a single thread you can use HashMap, which is an unsynchronized version. Unsynchronized objects are often a little more performant. By the way if multiple threads access a HashMap concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. \nYoun can wrap a unsynchronized map in a synchronized one using :HashTable can only contain non-null object as a key or as a value. HashMap can contain one null key and null values.The iterators returned by Map are fail-fast, if the map is structurally modified at any time after the iterator is created, in any way except through the iterator\'s own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Whereas the Enumerations returned by Hashtable\'s keys and elements methods are not fail-fast. HashTable and HashMap are member of the Java Collections Framework (since Java 2 platform v1.2, HashTable was retrofitted to implement the Map interface).HashTable is considered legacy code, the documentation advise to use ConcurrentHashMap in place of Hashtable if a thread-safe highly-concurrent implementation is desired.HashMap doesn\'t guarantee the order in which elements are returned. For HashTable I guess it\'s the same but I\'m not entirely sure, I don\'t find ressource that clearly state that.HashMap and Hashtable have significant algorithmic differences as well. No one has mentioned this before so that\'s why I am bringing it up. HashMap will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. However, the Hashtable implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than HashMap i.e. less collisions for some cases.Separate from the obvious differences discussed extensively in this question, I see the Hashtable as a "manual drive" car where you have better control over the hashing and the HashMap as the "automatic drive" counterpart that will generally perform well.Hashtable is synchronized, whereas HashMap isn\'t. That makes Hashtable slower than Hashmap.For non-threaded apps, use HashMap since they are otherwise the same in terms of functionality.Differences between HashMap and Hashtable in Java:1) Thread Safe2) Inherited From3) Null Keys And Null Values4) Traversal5) Fail-Fast Vs Fail-Safe6) Performance7) Legacy Class8) Member Of Java Collection FrameworkWhich is more efficient for non-threaded applications?Hashtable is synchronized, whereas HashMap is not.This makes HashMap better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.Based on the info here, I\'d recommend going with HashMap.  I think the biggest advantage is that Java will prevent you from modifying it while you are iterating over it, unless you do it through the iterator.For threaded apps, you can often get away with ConcurrentHashMap- depends on your performance requirements.Difference between HashMap and HashTable / HashMap vs HashTable Synchronization or Thread Safe :  This is the most important difference between two . HashMap is non synchronized and not thread safe.On the other hand, HashTable is thread safe and synchronized.\nWhen to use HashMap ?  answer is if your application do not require any multi-threading task, in other words hashmap is better for non-threading applications. HashTable should be used in multithreading applications.Null keys and null values :  Hashmap allows one null key and any number of null values, while Hashtable do not allow null keys and null values in the HashTable object.Iterating the values:  Hashmap object values are iterated by using iterator .HashTable is the only class other than vector which uses enumerator to iterate the values of HashTable object.Fail-fast iterator  : The iterator in Hashmap is fail-fast iterator while the enumerator for Hashtable is not.\nAccording to Oracle Docs,  if the Hashtable is structurally modified at any time after the iterator is created in any way except the iterator\'s own remove method , then the iterator will throw ConcurrentModification Exception.\nStructural modification means adding or removing elements from the Collection object (here hashmap or hashtable) . Thus the enumerations returned by the Hashtable keys and elements methods are not fail fast.We have already explained the difference between iterator and enumeration.Performance :  Hashmap is much faster and uses less memory than Hashtable as former is unsynchronized . Unsynchronized objects are often much better in performance in compare to synchronized  object like Hashtable in single threaded environment.Superclass and Legacy :  Hashtable is a subclass of Dictionary class which is now obsolete in Jdk 1.7 ,so ,it is not used anymore. It is better off externally synchronizing a HashMap or using a ConcurrentMap implementation (e.g ConcurrentHashMap).HashMap is the subclass of the AbstractMap class. Although Hashtable and HashMap has different superclasses but they both are implementations of the "Map"  abstract data type.Apart from the differences already mentioned, it should be noted that since Java 8, HashMap dynamically replaces the Nodes (linked list) used in each bucket with TreeNodes (red-black tree), so that even if high hash collisions exist, the worst case when searching isO(log(n)) for HashMap Vs O(n) in Hashtable.*The aforementioned improvement has not been applied to Hashtable yet, but only to HashMap, LinkedHashMap, and ConcurrentHashMap.FYI, currently,There are 5 basic differentiations with HashTable and HashMaps. 1.Hashmap and HashTable both store key and value. 2.Hashmap can store one key as null. Hashtable can\'t store null.3.HashMap is not synchronized but Hashtable is synchronized. 4.HashMap can be synchronized with Collection.SyncronizedMap(map)My small contribution :First and most significant different between Hashtable and HashMap is that, HashMap is not thread-safe  while Hashtable is a thread-safe collection.Second important difference between Hashtable and HashMap is performance, since HashMap is not synchronized it perform better than Hashtable.Third difference on Hashtable vs HashMap is that Hashtable is obsolete class and you should be using ConcurrentHashMap in place of Hashtable in Java.There is many good answer already posted. I\'m adding few new points and summarizing it.HashMap and Hashtable both are used to store data in key and value form. Both are using hashing technique to store unique keys.\nBut there are many differences between HashMap and Hashtable classes that are given below.HashMap 1) HashMap is non synchronized. It is not-thread safe and can\'t be shared between many threads without proper synchronization code.\n2) HashMap allows one null key and multiple null values.\n3) HashMap is a new class introduced in JDK 1.2.\n4) HashMap is fast.\n5) We can make the HashMap as synchronized by calling this code\n         Map m = Collections.synchronizedMap(HashMap);\n6) HashMap is traversed by Iterator.\n7) Iterator in HashMap is fail-fast.\n8) HashMap inherits AbstractMap class.    Hashtable1) Hashtable is synchronized. It is thread-safe and can be shared with many threads.\n2) Hashtable doesn\'t allow any null key or value.\n3) Hashtable is a legacy class.\n4) Hashtable is slow.\n5) Hashtable is internally synchronized and can\'t be unsynchronized.\n6) Hashtable is traversed by Enumerator and Iterator.\n7) Enumerator in Hashtable is not fail-fast.\n8) Hashtable inherits Dictionary class.Further reading What is difference between HashMap and Hashtable in Java?HashTable is a legacy class in the jdk that shouldn\'t be used anymore. Replace usages of it with ConcurrentHashMap. If you don\'t require thread safety, use HashMap which isn\'t threadsafe but faster and uses less memory.1)Hashtable is synchronized whereas hashmap is not.\n2)Another difference is that iterator in the HashMap is fail-safe while the enumerator for the Hashtable isn\'t. If you change the map while iterating, you\'ll know.3)HashMap permits null values in it, while Hashtable doesn\'t.HashMap and HashTable 1) Hashtable and Hashmap implement the java.util.Map interface\n2) Both Hashmap and Hashtable is the hash based collection. and working on hashing.\nso these are similarity of HashMap and HashTable.    1) First difference is HashMap is not thread safe While HashTable is ThreadSafe\n2) HashMap is performance wise better because it is not thread safe. while Hashtable performance wise is not better because it is thread safe. so multiple thread can not access Hashtable at the same time.HashMap:- It is a class available inside java.util package and it is used to store the element in key and value format.Hashtable:-It is a legacy class which is being recognized inside collection frameworkHashMaps gives you freedom of synchronization and debugging is lot more easierHashMap is emulated and therefore usable in GWT client code whereas Hashtable is not.HashMap is a class  used to store the element in key and value format.it is not thread safe.\nbecause it is not synchronized .where as Hashtable is synchronized.Hashmap permits null but hastable doesn\'t permit null.