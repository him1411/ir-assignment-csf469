Using jQuery, how can I cancel/abort an Ajax request that I have not yet received the response from?Most of the jQuery Ajax methods return an XMLHttpRequest (or the equivalent) object, so you can just use abort().See the documentation:UPDATE:\nAs of jQuery 1.5 the returned object is a wrapper for the native XMLHttpRequest object called jqXHR. This object appears to expose all of the native properties and methods so the above example still works. See The jqXHR Object (jQuery API documentation).UPDATE 2:\nAs of jQuery 3, the ajax method returns a promise without extra methods (like abort), so this will no longer work. See the 3.0 blog here. One way around this is to control the xhr object through the xhr property. Here is a crude example:You can\'t recall the request but you can set a timeout value after which the response will be ignored.  See this page for jquery AJAX options.  I believe that your error callback will be called if the timeout period is exceeded.  There is already a default timeout on every AJAX request.You can also use the abort() method on the request object but, while it will cause the client to stop listening for the event, it may probably will not stop the server from processing it.It\'s an asynchronous request, meaning once it\'s sent it\'s out there.In case your server is starting a very expensive operation due to the AJAX request, the best you can do is open your server to listen for cancel requests, and send a separate AJAX request notifying the server to stop whatever it\'s doing.Otherwise, simply ignore the AJAX response.Save the calls you make in an array, then call xhr.abort() on each.HUGE CAVEAT: You can abort a request, but that\'s only the client side. The server side could still be processing the request. If you are using something like PHP or ASP with session data, the session data is locked until the ajax has finished. So, to allow the user to continue browsing the website, you have to call session_write_close(). This saves the session and unlocks it so that other pages waiting to continue will proceed. Without this, several pages can be waiting for the lock to be removed.AJAX requests may not complete in the order they were started. Instead of aborting, you can choose to ignore all AJAX responses except for the most recent one:Rough outline of code:Demo on jsFiddleWe just had to work around this problem and tested three different  approaches.In our case we decided to use approach #3 as it produces less load for the server. But I am not 100% sure if jQuery guarantees the call of the .complete()-method, this could produce a deadlock situation. In our tests we could not reproduce such a situation.It is always best practice to do something like this.But it is much better if you check an if statement to check whether the ajax request is null or not.meouw\'s solution is correct, but if you\'re are interested in more control then you could try the Ajax Manager plugin for jQuery.I was doing a live search solution and needed to cancel pending requests that may have taken longer than the latest/most current request. In my case I used something like this:As many people on the thread have noted, just because the request is aborted on the client-side, the server will still process the request. This creates unnecessary load on the server because it\'s doing work that we\'ve quit listening to on the front-end.The problem I was trying to solve (that others may run in to as well) is that when the user entered information in an input field, I wanted to fire off a request for a Google Instant type of feel.To avoid firing unnecessary requests and to maintain the snappiness of the front-end, I did the following:This will essentially send one request every 150ms (a variable that you can customize for your own needs). If you\'re having trouble understanding what exactly is happening here, log xhrCount and xhrQueue to the console just before the if block.Just use ajax.abort() for example you could abort any pending ajax request before sending another one like thisthere is no reliable way to do it, and I would not even try it, once the request is on the go; the only way to react reasonably is to ignore the response.in most cases, it may happen in situations like: a user clicks too often on a button triggering many consecutive XHR, here you have many options, either block the button till XHR is returned, or dont even trigger new XHR while another is running hinting the user to lean back - or discard any pending XHR response but the recent.Just call xhr.abort() whether it\'s jquery ajax object or native XMLHTTPRequest object.example:I had the problem of polling and once the page was closed the poll continued so in my cause  a user would miss an update as a mysql value was being set for the next 50 seconds after page closing, even though I killed the ajax request, I figured away around, using $_SESSION to set a var won\'t update in the poll its self until its ended and a new one has started, so what I did was set a value in my database as 0 = offpage , while I\'m polling I query that row and return false; when it\'s 0 as querying in polling will get you current values obviously...I hope this helped I have shared a demo that demonstrates how to cancel an AJAX request-- if data is not returned from the server within a predefined wait time.HTML :JS CODE:The following snippet shows initiating as well as aborting an Ajax request:If  xhr.abort();  causes page reload,Then you can set onreadystatechange before abort to prevent: