How do you give a C# Auto-Property a default value?  I either use the constructor, or revert to the old syntax.  Using the Constructor:Using normal property syntax  (with a default value)Is there a better way?In C# 5 and earlier, to give auto implemented properties a default value, you have to do it in a constructor.The ability to have auto property initializers is included since C# 6.0. The syntax is:Edit 1/2/15With C# 6 you can initialize auto-properties directly (finally!), there are now other answers in the thread that describe that.For C# 5 and below:Though the intended use of the attribute is not to actually set the values of the properties, you can use reflection to always set them anyway...When you inline an initial value for a variable it will be done implicitly in the constructor anyway.I would argue that this syntax was best practice in C# up to 5:As this gives you clear control of the order values are assigned.As of C#6 there is a new way:DefaultValueAttribute ONLY work in the vs designer. It will not initialize the property to that value. See DefaultValue attribute is not working with my Auto PropertySometimes I use this, if I don\'t want it to be actually set and persisted in my db:Obviously if it\'s not a string then I might make the object nullable ( double?, int? ) and check if it\'s null, return a default, or return the value it\'s set to.Then I can make a check in my repository to see if it\'s my default and not persist, or make a backdoor check in to see the true status of the backing value, before saving.Hope that helps!Starting with C# 6.0, We can assign default value to auto-implemented properties. We can also create read-only auto implemented property like:See: C# 6: First reactions , Initializers for automatically implemented properties - By Jon SkeetMy solution is to use a custom attribute that provides default value property initialization by constant or using property type initializer.To use this attribute it\'s necessary to inherit a class from special base class-initializer or use a static helper method:Usage example:Output:little complete sample:In C# 6 and above you can simply use the syntax:Note that to have a readonly property simply omit the set, as so:You can also assign readonly auto-properties from the constructor.Prior to this I responded as below.I\'d avoid adding a default to the constructor; leave that for dynamic assignments and avoid having two points at which the variable is assigned (i.e. the type default and in the constructor). Typically I\'d simply write a normal property in such cases.One other option is to do what ASP.Net does and define defaults via an attribute:http://msdn.microsoft.com/en-us/library/system.componentmodel.defaultvalueattribute.aspxIn Version of C# (6.0) & greater, you can do : For Readonly propertiesFor both Writable & Readable propertiesIn current Version of C# (7.0), you can do : You can do it in the Class declaration itself, in the property declaration statements.Source: C# 6.0 Features / Auto-property InitializersIn addition to the answer already accepted, for the scenario when you want to define a default property as a function of other properties you can use expression body notation on C#6.0 (and higher) for even more elegant and concise constructs like:You can use the above in the following fashion In order to be able to use the above "=>" notation, the property must be read only, and you do not use the get accessor keyword.Details on MSDNIn the constructor.  The constructor\'s purpose is to initialized it\'s data members.Have you tried using the DefaultValueAttribute or ShouldSerialize and Reset methods in conjunction with the constructor?  I feel like one of these two methods is necessary if you\'re making a class that might show up on the designer surface or in a property grid.Personally, I don\'t see the point of making it a property at all if you\'re not going to do  anything at all beyond the auto-property.  Just leave it as a field.  The encapsulation benefit for these item are just red herrings, because there\'s nothing behind them to encapsulate.  If you ever need to change the underlying implementation you\'re still free to refactor them as properties without breaking any dependent code.Hmm... maybe this will be the subject of it\'s own question laterTo clarify, yes, you need to set default values in the constructor for class derived objects.  You will need to ensure the constructor exists with the proper access modifier for construction where used.  If the object is not instantiated, e.g. it has no constructor (e.g. static methods) then the default value can be set by the field.  The reasoning here is that the object itself will be created only once and you do not instantiate it.  @Darren Kopp - good answer, clean, and correct.  And to reiterate, you CAN write constructors for Abstract methods.  You just need to access them from the base class when writing the constructor:  Constructor at Base Class:Constructor at Derived / Concrete / Sub-Class:The point here is that the instance variable drawn from the base class may bury your base field name.  Setting the current instantiated object value using "this." will allow you to correctly form your object with respect to the current instance and required permission levels (access modifiers) where you are instantiating it.Use the constructor because "When the constructor is finished, Construction should be finished". properties are like states your classes hold, if you had to initialize a default state, you would do that in your constructor.Type Prop and Press button "TAB" and Visual Studio Suggest you Following Code,after you can change modifier,data type,name and easily assign set and get values.if you need use some variable in another class you can used as follwing,in code you can assign variablein another class you can use this ,I think this would do it for ya givng SomeFlag a default of false.initialize in line, using constructors to initialize is bad practice and will lead to more breaking changes later.