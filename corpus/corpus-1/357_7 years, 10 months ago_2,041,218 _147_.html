I need to match all of these opening tags:But not these:I came up with this and wanted to make sure I\'ve got it right. I am only capturing the a-z.I believe it says:Do I have that right? And more importantly, what do you think?You can\'t parse [X]HTML with regex. Because HTML can\'t be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The <center> cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n\xe2\x80\x8berves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege\xcc\xbf\xcc\x94\xcc\x89x-based HTML parsers are the cancer that is killing StackOverflow it is too late it is too late we cannot be saved the trangession of a chi\xcd\xa1ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied) dear lord help us how can anyone survive this scourge using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes using regex as a tool to process HTML establishes a breach between this world and the dread realm of c\xcd\x92\xcd\xaao\xcd\x9b\xcd\xabrrupt entities (like SGML entities, but more corrupt) a mere glimpse of the world of reg\xe2\x80\x8bex parsers for HTML will ins\xe2\x80\x8btantly transport a programmer\'s consciousness into a world of ceaseless screaming, he comes, the pestilent slithy regex-infection wil\xe2\x80\x8bl devour your HT\xe2\x80\x8bML parser, application and existence for all time like Visual Basic only worse he comes he comes do not fi\xe2\x80\x8bght he com\xcc\xa1e\xcc\xb6s, \xcc\x95h\xcc\xb5i\xe2\x80\x8bs un\xcc\xa8ho\xcd\x9ely radian\xcd\x81ce\xcd\x81 destro\xd2\x89ying all enli\xcc\x8d\xcd\x84\xcc\x82\xcd\x84ghtenment, HTML tags lea\xcd\xa0ki\xcc\xa7n\xcd\x98g fr\xcc\xb6o\xcc\xa8m \xcc\xa1yo\xe2\x80\x8b\xcd\x9fur eye\xcd\xa2s\xcc\xb8 \xcc\x9bl\xcc\x95ik\xcd\x8fe liq\xe2\x80\x8buid pain, the song of re\xcc\xb8gular exp\xe2\x80\x8bression parsing will exti\xe2\x80\x8bnguish the voices of mor\xe2\x80\x8btal man from the sp\xe2\x80\x8bhere I can see it can you see \xcc\xb2\xcd\x9a\xcc\x96\xcd\x94\xcc\x99i\xcc\x82\xcd\x81\xcc\xa9t\xcc\x81\xcc\x8b\xcd\x80\xcc\xb2\xcd\x8e\xcc\xa9\xcc\xb1\xcd\x94 it is beautiful t\xe2\x80\x8bhe final snuffing of the lie\xe2\x80\x8bs of Man ALL IS LOS\xcc\x81\xcc\x8f\xcd\x84\xcd\x96\xcc\xa9\xcd\x87\xcc\x97\xcc\xaaT ALL I\xe2\x80\x8bS LOST the pon\xcc\xb7y he comes he c\xcc\xb6\xcc\xaeomes he comes the ich\xe2\x80\x8bor permeates all MY FACE MY FACE \xe1\xb5\x92h god no NO NOO\xcc\xbcO\xe2\x80\x8bO N\xce\x98 stop the an\xe2\x80\x8b*\xcd\x91\xcc\xbe\xcc\xbe\xcc\xb6\xe2\x80\x8b\xcc\x85\xcd\xab\xcd\x8f\xcc\x99\xcc\xa4g\xcd\x9b\xcd\x86\xcc\xbe\xcd\xab\xcc\x91\xcd\x86\xcd\x87\xcc\xabl\xcc\x8d\xcd\xab\xcd\xa5\xcd\xa8\xcd\x96\xcd\x89\xcc\x97\xcc\xa9\xcc\xb3\xcc\x9fe\xcc\x85\xcc\xa0s \xcd\x8ea\xcc\xa7\xcd\x88\xcd\x96r\xcc\xbd\xcc\xbe\xcd\x84\xcd\x92\xcd\x91e n\xe2\x80\x8bot re\xcc\x80\xcc\x91\xcd\xa7\xcc\x8ca\xcd\xa8l\xcc\x83\xcd\xa4\xcd\x82\xcc\xbe\xcc\x86\xcc\x98\xcc\x9d\xcc\x99 ZA\xcd\xa0\xcc\xa1\xcd\x8a\xcd\x9dLG\xce\x8c IS\xcd\xae\xcc\x82\xd2\x89\xcc\xaf\xcd\x88\xcd\x95\xcc\xb9\xcc\x98\xcc\xb1 TO\xcd\x85\xcd\x87\xcc\xb9\xcc\xba\xc6\x9d\xcc\xb4\xc8\xb3\xcc\xb3 TH\xcc\x98E\xcd\x84\xcc\x89\xcd\x96 \xcd\xa0P\xcc\xaf\xcd\x8d\xcc\xadO\xcc\x9a\xe2\x80\x8bN\xcc\x90Y\xcc\xa1 H\xcd\xa8\xcd\x8a\xcc\xbd\xcc\x85\xcc\xbe\xcc\x8e\xcc\xa1\xcc\xb8\xcc\xaa\xcc\xafE\xcc\xbe\xcd\x9b\xcd\xaa\xcd\x84\xcc\x80\xcc\x81\xcc\xa7\xcd\x98\xcc\xac\xcc\xa9 \xcd\xa7\xcc\xbe\xcd\xac\xcc\xa7\xcc\xb6\xcc\xa8\xcc\xb1\xcc\xb9\xcc\xad\xcc\xafC\xcd\xad\xcc\x8f\xcd\xa5\xcd\xae\xcd\x9f\xcc\xb7\xcc\x99\xcc\xb2\xcc\x9d\xcd\x96O\xcd\xae\xcd\x8f\xcc\xae\xcc\xaa\xcc\x9d\xcd\x8dM\xcd\x8a\xcc\x92\xcc\x9a\xcd\xaa\xcd\xa9\xcd\xac\xcc\x9a\xcd\x9c\xcc\xb2\xcc\x96E\xcc\x91\xcd\xa9\xcd\x8c\xcd\x9d\xcc\xb4\xcc\x9f\xcc\x9f\xcd\x99\xcc\x9eS\xcd\xaf\xcc\xbf\xcc\x94\xcc\xa8\xcd\x80\xcc\xa5\xcd\x85\xcc\xab\xcd\x8e\xcc\xadHave you tried using an XML parser instead?Moderator\'s NoteThis post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.While it is true that asking regexes to parse arbitrary HTML is like asking a beginner to write an operating system, it\'s sometimes appropriate to parse a limited, known set of HTML.  If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament\'s web site.  This was a limited, one-time job.  Regexes worked just fine for me, and were very fast to set up.I think the flaw here is that HTML is a Chomsky Type 2 grammar (context free grammar) and RegEx is a Chomsky Type 3 grammar (regular grammar). Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the Chomsky hierarchy), you can\'t possibly  make this work. But many will try, some will claim success and others will find the fault and totally mess you up.Don\'t listen to these guys. You actually can parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order: I haven\'t figured out the last part yet, but I know I\'m getting close. My code keeps throwing CthulhuRlyehWgahnaglFhtagnExceptions lately, so I\'m going to port it to VB 6 and use On Error Resume Next. I\'ll update with the code once I investigate this strange door that just opened in the wall. Hmm.P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn\'t big enough for the code.Disclaimer: use a parser if you have the option. That said...This is the regex I use (!) to match HTML tags:It may not be perfect, but I ran this code through a lot of HTML. Note that it even catches strange things like <a name="badgenerator"">, which show up on the web.I guess to make it not match self contained tags, you\'d either want to use Kobi\'s negative look-behind:or just combine if and if not.To downvoters: This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML. Caveat: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...  There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid, if they want to use strange words). They are lying. There are people that will tell you that Regular Expressions shouldn\'t be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.You can live in their reality or take the red pill.Like the Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the Underverse Stack Based Regex-Verse and returned with powers knowledge you can\'t imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn\'t difficult.I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this: The options to set is RegexOptions.ExplicitCapture. The capture group you are looking for is ELEMENTNAME. If the capture group ERROR is not empty then there was a parsing error and the Regex stopped.If you have problems reconverting it to a human readable regex, this should help:If you are unsure, no, I\'m NOT kidding (but perhaps I\'m lying). It WILL work. I\'ve built tons of unit tests to test it, and I have even used (part of) the conformance tests. It\'s a tokenizer, not a full blown parser, so it will only split the XML in its component tokens. It won\'t parse/integrate DTDs.Oh... if you want the source code of the regex, with some auxiliary methods:regex to tokenize an xml or the full plain regex In shell, you can parse HTML using:sed though:hxselect from html-xml-utils packagevim/ex (which can easily jump between html tags), for example:removing style tag with inner code:grep, for example:extracting outer html of H1:extracting the body:html2text to plain text parsing:like parsing tables:using xpath (XML::XPath perl module), see example hereperl or Python (see @Gilles example)for parsing multiple files at once, see: How to parse hundred html source code files in shell?Related (why you shouldn\'t use regex match):I suggest using QueryPath for parsing XML and HTML in PHP.  It\'s basically much the same syntax as jQuery, only it\'s on the server side.I agree that the right tool to parse XML and especially HTML is a parser and not a regular expression engine.  However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.Microsoft actually has a section of Best Practices for Regular Expressions in the .NET Framework and specifically talks about Consider[ing] the Input Source.Regular Expressions do have limitations, but have you considered the following?The .NET framework is unique when it comes to regular expressions in that it supports Balancing Group Definitions.For this reason, I believe you CAN parse XML using regular expressions.  Note however, that it must be valid XML (browsers are very forgiving of HTML and allow bad XML syntax inside HTML).  This is possible since the "Balancing Group Definition" will allow the regular expression engine to act as a PDA.Quote from article 1 cited above:.NET Regular Expression EngineAs described above properly balanced constructs cannot be described by\n  a regular expression. However, the .NET regular expression engine\n  provides a few constructs that allow balanced constructs to be\n  recognized. These constructs allow for a .NET regular expression to emulate a\n  restricted PDA by essentially allowing simple versions of the stack\n  operations: push, pop and empty. The simple operations are pretty much\n  equivalent to increment, decrement and compare to zero respectively.\n  This allows for the .NET regular expression engine to recognize a\n  subset of the context-free languages, in particular the ones that only\n  require a simple counter. This in turn allows for the non-traditional\n  .NET regular expressions to recognize individual properly balanced\n  constructs.Consider the following regular expression:Use the flags:You can try this at A Better .NET Regular Expression Tester.I used the sample source of:This found the match:although it actually came out like this:Lastly, I really enjoyed Jeff Atwood\'s article:  Parsing Html The Cthulhu Way.  Funny enough, it cites the answer to this question that currently has over 4k votes.While the answers that you can\'t parse HTML with regexes are correct, they don\'t apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.The suggested regex is wrong, though:If you add something to the regex, by backtracking it can be forced to match silly things like <a >>, [^/] is too permissive. Also note that <space>*[^/]* is redundant, because the [^/]* can also match spaces.My suggestion would beWhere (?<! ... ) is (in Perl regexes) the negative look-behind. It reads "a <, then a word, then anything that\'s not a >, the last of which may not be a /, followed by >".Note that this allows things like <a/ > (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.Try:It is similar to yours, but the last > must not be after a slash, and also accepts h1.Output:Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren\'t self closing and operate on them.I\'m sure you already know by now that you shouldn\'t use regex for this purpose.Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.\n  If you only know yourself, but not your opponent, you may win or may lose.\n  If you know neither yourself nor your enemy, you will always endanger yourself.In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.I have composed a haiku describing the nature of HTML.I have also composed a haiku describing the nature of regex in Perl.I don\'t know your exact need for this, but if you are also using .NET, couldn\'t you use Html Agility Pack?Excerpt:It is a .NET code library that allows\n  you to parse "out of the web" HTML\n  files. The parser is very tolerant\n  with "real world" malformed HTML.You want the first > not preceded by a /.  Look here for details on how to do that.  It\'s referred to as negative lookbehind.However, a na\xc3\xafve implementation of that will end up matching <bar/></foo> in this example documentCan you provide a little more information on the problem you\'re trying to solve?  Are you iterating through tags programatically?The W3C explains parsing in a pseudo regexp form:\nW3C Link Follow the var links for QName, S, and Attribute to get a clearer picture.\nBased on that you can create a pretty good regexp to handle things like stripping tags.If you need this for PHP:The PHP DOM functions won\'t work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.simplehtmldom is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]I have never used querypath, so can\'t comment on its usefulness. Another one to try is my DOMParser which is very light on resources and I\'ve been using happily for a while. Simple to learn & powerful.For Python and Java, similar links were posted.For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.I used a open source tool called HTMLParser before. It\'s designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.\nIn your case, something like this: I like to parse HTML with regular expressions. I don\'t attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):It\'s called htmlsplit, splits the HTML into lines, with one tag or chunk of text on each line.  The lines can then be processed further with other text tools and scripts, such as grep, sed, Perl, etc. I\'m not even joking :) Enjoy.It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it\'s not really necessary.I bet I will get downvoted for this.HTML SplitAgainst my expectation this got some upvotes, so I\'ll suggest some better regular expressions:They are good for XML / XHTML.With minor variations, it can cope with messy HTML... or convert the HTML -> XHTML first.The best way to write regular expressions is in the Lex / Yacc style, not as opaque one-liners or commented multi-line monstrosities. I didn\'t do that here, yet; these ones barely need it.Here is a PHP based parser that parses HTML using  some ungodly regex. As the author of this project, I can tell you it is possible to parse HTML with regex, but not efficient. If you need a server-side solution (as I did for my wp-Typography WordPress plugin), this works.Here\'s the solution:To test it deeply, I entered in the string auto-closing tags like:I also entered tags with:Should you find something which does not work in the proof of concept above, I am available in analysing the code to improve my skills.<EDIT>\nI forgot that the question from the user was to avoid the parsing of self-closing tags.\nIn this case the pattern is simpler, turning into this:The user @ridgerunner noticed that the pattern does not allow unquoted attributes or attributes with no value. In this case a fine tuning brings us the following pattern:</EDIT>If someone is interested in learning more about the pattern, I provide some line:Small tip: to better analyse this code it is necessary looking at the source code generated, since I did not provide any HTML special characters escaping.There are some nice regexes for replacing HTML with BBCode here. For all you nay-sayers, note that he\'s not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple "parser" can\'t understand.For example:About the question of the RegExp methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since NOBODY here spoke about recursion.A RegExp-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.After reading some posts, the first thing I did was looking for the "?R" string in this thread. The second was to search about "recursion".\nNo, holy cow, no match found.\nSince nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.If an (x)HTML parser needs recursion, a RegExp parser without recursion is not enough for the purpose. It\'s a simple construct.The black art of RegExp is hard to master, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)Here\'s the magic pattern:Just try it.\nIt\'s written as a PHP string, so the "s" modifier makes classes include newlines.\nHere\'s a sample note on the PHP manual I wrote on January: Reference(Take care, in that note I wrongly used the "m" modifier; it should be erased, notwithstanding it is discarded by the RegExp engine, since no ^ or $ anchorage was used).Now, we could speak about the limits of this method from a more informed point of view:Anyhow it is only a RegExp pattern, but it discloses the possibility to develop of a lot of powerful implementations.\nI wrote this pattern to power the recursive descent parser of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the jtidy library to turn the HTML into XML and then Jaxen to xpath into the result.The parts explained:<: starting character\\s*: it may have whitespaces before tag name (ugly but possible).(\\w+): tags can contain letters and numbers (h1). Well, \\w also matches \'_\', but it does not hurt I guess. If curious use ([a-zA-Z0-9]+) instead.[^/>]*: anything except > and / until closing >>: closing >And to fellows who underestimate regular expressions saying they are only as powerful as regular languages:anbanban which is not regular and not even context free, can be matched with ^(a+)b\\1b\\1$Backreferencing FTW!I recently wrote an HTML sanitizer in Java. It is based on a mixed approach of regular expressions and Java code. Personally I hate regular expressions and its folly (readability, maintainability, etc.), but if you reduce the scope of its applications it may fit your needs. Anyway, my sanitizer uses a white list for HTML tags and a black list for some style attributes.For your convenience I have set up a playground so you can test if the code matches your requirements: playground and Java code. Your feedback will be appreciated.There is a small article describing this work on my blog: http://roberto.open-lab.comIt seems to me you\'re trying to match tags without a "/" at the end. Try this:Although it\'s not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it\'s not that horrbile to use regular expressions for trivial works. There is a definitive blog post about matching innermost HTML elements written by Steven Levithan.If you\'re simply trying to find those tags (without ambitions of parsing) try this regular expression:I wrote it in 30 seconds, and tested here:\nhttp://gskinner.com/RegExr/It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.