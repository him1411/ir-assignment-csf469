Over the years I have slowly developed a regular expression that validates MOST email addresses correctly, assuming they don\'t use an IP address as the server part.I use it in several PHP programs, and it works most of the time.  However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn\'t allowing 4-character TLDs).What is the best regular expression you have or have seen for validating emails?I\'ve seen several solutions that use functions that use several shorter expressions, but I\'d rather have one long complex expression in a simple function instead of several short expression in a more complex function.The fully RFC 822 compliant regex is inefficient and obscure because of its length.  Fortunately, RFC 822 was superseded twice and the current specification for email addresses is RFC 5322.  RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.One RFC 5322 compliant regex can be found at the top of the page at http://emailregex.com/ but uses the IP address pattern that is floating around the internet with a bug that allows 00 for any of the unsigned byte decimal values in a dot-delimited address, which is illegal.  The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using grep -Po, including cases domain names, IP addresses, bad ones, and account names with and without quotes.Correcting the 00 bug in the IP pattern, we obtain a working and fairly fast regex.  (Scrape the rendered version, not the markdown, for actual code.)(?:[a-z0-9!#$%&\'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&\'*+/=?^_`{|}~-]+)*|"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])Here is diagram of finite state machine for above regexp which is more clear than regexp itself\nThe more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can correctly parse RFC 5322 without a hitch. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it\xe2\x80\x99s best to use a real parser.It\'s also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address. Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down president@whitehouse.gov, and that will even parse as legal, but it isn\'t likely to be the person at the other end.For PHP, you should not use the pattern given in Validate an E-Mail Address with PHP, the Right Way from which I quote:There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.That is no better than all the other non-RFC patterns. It isn\xe2\x80\x99t even smart enough to handle even RFC 822, let alone RFC 5322. This one, however, is.If you want to get fancy and pedantic, implement a complete state engine. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can\'t handle it is just rude and impolite from the user\'s perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, likeThe specified e-mail address \'myemail@address,com\' is invalid. Did you mean \'myemail@address.com\'?See also Validating Email Addresses, including the comments. Or Comparing E-mail Address Validating Regular Expressions.Debuggex DemoYou should not use regular expressions to validate email addresses.Instead, use the MailAddress class, like this:The MailAddress class uses a BNF parser to validate the address in full accordance with RFC822.If you really want to use a regex, here it is:        This question is asked a lot, but I think you should step back and ask yourself why you want to validate email adresses syntactically? What is the benefit really?If you want to validate that an email is correct, you have no choice than to send an confirmation email and have the user reply to that. In many cases you will have to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).It depends on what you mean by best:\nIf you\'re talking about catching every valid email address use the following:(http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html)\nIf you\'re looking for something simpler but that will catch most valid email addresses try something like: EDIT:\nFrom the link:This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).It all depends on how accurate you want to be.  For my purposes, where I\'m just trying to keep out things like bob @ aol.com (spaces in emails) or steve (no domain at all) or mary@aolcom (no period before .com), I useSure, it will match things that aren\'t valid email addresses, but it\'s a matter of playing the 90/10 rule.      [UPDATED] I\'ve collated everything I know about email address validation here: http://isemail.info, which now not only validates but also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay at http://isemail.info/about.is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I\'ve upload a new version at http://isemail.info/I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 and RFC 3696. 275 test addresses in all. I ran all these tests against all the free validators I could find.I\'ll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and co-operation in compiling these tests and constructive criticism of my own validator.People should be aware of the errata against RFC 3696 in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, not 320.Per the W3C HTML5 spec:Context:A valid e-mail address is a string that matches the ABNF production [\xe2\x80\xa6].Note: This requirement is a willful violation of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the \xe2\x80\x9c@\xe2\x80\x9d character), too vague (after the \xe2\x80\x9c@\xe2\x80\x9d character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.It\xe2\x80\x99s easy in Perl 5.10 or newer:Don\'t know about best, but this one is at least correct, as long as the addresses have their comments stripped and replaced with whitespace.Seriously. You should use an already written library for validating emails. The best way is probably to just send a verification e-mail to that address.I useWhich is the one used in ASP.NET by the RegularExpressionValidator.The email addresses I want to validate are going to be used by an ASP.NET web application using the System.Net.Mail namespace to send emails to a list of people. So, rather than using some very complex regular expression, I just try to create a MailAddress instance from the address. The MailAddress construtor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation but at a minimum you need that anyway.Use the following regex for input validation:([-!#-\'*+/-9=?A-Z^-~]+(\\.[-!#-\'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \\t]|(\\\\[\\t -~]))+")@[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)+Addresses matched by this regex:The second constraint is a restriction on RFC 5321/5322.Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there\'s no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that ""@[] is a grammatically correct email address that certainly doesn\'t refer to an existing mailbox.The syntax of email addresses has been defined in various RFCs, most notably RFC 822 and RFC 5322. RFC 822 should be seen as the "original" standard and RFC 5322 as the latest standard. The syntax defined in RFC 822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.In this answer I\xe2\x80\x99ll take \xe2\x80\x9cemail address\xe2\x80\x9d to mean addr-spec as defined in the RFCs (i.e. jdoe@example.org, but not "John Doe"<jdoe@example.org>, nor some-group:jdoe@example.org,mrx@exampel.org;).There\'s one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can\'t be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I\'ll disregard comments and only consider proper regular expressions.The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent canonical representation. Thus, the canonical representation of first. last (comment) @   [3.5.7.9] is first.last@[3.5.7.9].Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC 822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC 5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.I use POSIX "extended" regular expressions in this answer, assuming an ASCII compatible character set.I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I\'ll try to fix the expression as soon as possible.([^][()<>@,;:\\\\". \\x00-\\x1F\\x7F]+|"(\\n|(\\\\\\r)*([^"\\\\\\r\\n]|\\\\[^\\r]))*(\\\\\\r)*")(\\.([^][()<>@,;:\\\\". \\x00-\\x1F\\x7F]+|"(\\n|(\\\\\\r)*([^"\\\\\\r\\n]|\\\\[^\\r]))*(\\\\\\r)*"))*@([^][()<>@,;:\\\\". \\x00-\\x1F\\x7F]+|\\[(\\n|(\\\\\\r)*([^][\\\\\\r\\n]|\\\\[^\\r]))*(\\\\\\r)*])(\\.([^][()<>@,;:\\\\". \\x00-\\x1F\\x7F]+|\\[(\\n|(\\\\\\r)*([^][\\\\\\r\\n]|\\\\[^\\r]))*(\\\\\\r)*]))*I believe it\'s fully complient with RFC 822 including the errata. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked "erratum") and use the updated version as a subexpression in subsequent regular expressions.As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I\'ve expanded the expressions to accommodate this rule and marked the result with "opt-lwsp".I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I\'ll try to fix the expression as soon as possible.([-!#-\'*+/-9=?A-Z^-~]+(\\.[-!#-\'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \\t]|(\\\\[\\t -~]))+")@([-!#-\'*+/-9=?A-Z^-~]+(\\.[-!#-\'*+/-9=?A-Z^-~]+)*|\\[[\\t -Z^-~]*])I believe it\'s fully complient with RFC 5322 including the errata. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked "(normalized)" that doesn\'t accept this whitespace.I ignored all the "obs-" rules from the RFC. This means that the regexes only match email addresses that are strictly RFC 5322 compliant. If you have to match "old" addresses (as the looser grammar including the "obs-" rules does), you can use one of the RFC 822 regexes from the previous paragraph.Note that some sources (notably w3c) claim that RFC 5322 is too strict on the local part (i.e. the part before the @-sign). This is because "..", "a..b" and "a." are not valid dot-atoms, while they may be used as mailbox names. The RFC, however, does allow for local parts like these, except that they have to be quoted. So instead of a..b@example.net you should write "a..b"@example.net, which is semantically equivalent.SMTP (as defined in RFC 5321) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.RFC 5321 basically leaves alone the "local" part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of "correcting" the rules in question, using this draft and RFC 1034 as guidelines. Here\'s the resulting regex.([-!#-\'*+/-9=?A-Z^-~]+(\\.[-!#-\'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \\t]|(\\\\[\\t -~]))+")@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)*|\\[((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|IPv6:((((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+)])Note that depending on the use case you may not want to allow for a "General-address-literal" in your regex. Also note that I used a negative lookahead (?!IPv6:) in the final regex to prevent the "General-address-literal" part to match malformed IPv6 addresses. Some regex processors don\'t support negative lookahead. Remove the substring |(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+ from the regex if you want to take the whole "General-address-literal" part out.Here\'s the derivation:A common use case is user input validation, for example on an html form. In that case it\'s usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC 5321 regex from the previous section as a basis, the resulting expression would be:([-!#-\'*+/-9=?A-Z^-~]+(\\.[-!#-\'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \\t]|(\\\\[\\t -~]))+")@[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)+I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don\'t know what kind of mailbox names some hosts allow (like "a..b"@example.net or even "a b"@example.net).I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how ".museum" invalidated [a-z]{2,4}), but if you must:([-!#-\'*+/-9=?A-Z^-~]+(\\.[-!#-\'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \\t]|(\\\\[\\t -~]))+")@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\\.)*(net|org|com|info|etc...)Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don\'t enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it\'s not feasible to make a regex that incorporates this rule.Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple "syntactically incorrect address". With "vanilla" regexes this is not possible.These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.There are plenty examples of this out on the net (and I think even one that fully validates the RFC - but it\'s tens/hundreds of lines long if memory serves). People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one . and meets some simple minimum length. It\'s trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.While deciding which characters are allowed, please remember your apostrophed and hyphenated friends. I have no control over the fact that my company generates my email address using my name from the HR system. That includes the apostrophe in my last name. I can\'t tell you how many times I have been blocked from interacting with a website by the fact that my email address is "invalid". This regex is from Perl\'s Email::Valid library. I believe it to be the most accurate, it matches all 822. And, it is based on the regular expression in the O\'Reilly book:Regular expression built using Jeffrey Friedl\'s example in\n  Mastering Regular Expressions (http://www.ora.com/catalog/regexp/).As you\'re writing in PHP I\'d advice you to use the PHP build-in validation for emails.If you\'re running a php-version lower than 5.3.6 please be aware of this issue: https://bugs.php.net/bug.php?id=53091If you want more information how this buid-in validation works, see here: Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?Cal Henderson (Flickr) wrote an article called Parsing Email Adresses in PHP and shows how to do proper RFC (2)822-compliant Email Address parsing.  You can also get the source code in php, python and ruby which is cc licensed.I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version.  I always use regexlib to find one to my liking.There is not one which is really usable.\nI discuss some issues in my answer to Is there a php library for email address validation?, it is discussed also in Regexp recognition of email address hard?In short, don\'t expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (jhohn@example.com is correct but it will probably bounce...).One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won\'t reject anything, but after reviewing the spec I can\'t find any email that would be valid and rejected.email =~ /.+@[^@]+\\.[^@]{2,}$/You could use the one employed by the jQuery Validation plugin:For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; "Comparing E-mail Address Validating Regular Expressions"Here is the current top expression for reference purposes:Not to mention that non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names are to be allowed in the near future. Everyone has to change the email regex used, because those characters are surely not to be covered by [a-z]/i nor \\w. They will all fail.After all, the best way to validate the email address is still to actually send an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn\'t look like in the right format, best is still to check if it matches basically the following regex:Simple as that. Why on earth would you care about the characters used in the name and domain? It\'s the client\'s responsibility to enter a valid email address, not the server\'s. Even when the client enters a syntactically valid email address like aa@bb.cc, this does not guarantee that it\'s a legit email address. No one regex can cover that.For a vivid demonstration, the following monster is pretty good but still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of "Hey, y\'all, watch ee-us!"Here\'s the PHP I use. I\'ve choosen this solution in the spirit of "false positives are better than false negatives" as declared by another commenter here AND with regards to keeping your response time up and server load down ... there\'s really no need to waste server resources with a regular expression when this will weed out most simple user error. You can always follow this up by sending a test email if you want.According to official standard RFC 2822 valid email regex is if you want to use it in Java its really very easyRFC 5322 standard:Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.RFC 5321 standard:Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.Basic:Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).The HTML5 spec suggests a simple regex for validating email addresses:This intentionally doesn\'t comply with RFC 5322.Note: This requirement is a willful violation of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the @ character), too vague (after the @ character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.Strange that you "cannot" allow 4 characters TLDs.  You are banning people from .info and .name, and the length limitation stop .travel and .museum, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.You should allow uppercase alphabets too.  Email systems will normalize the local part and domain part.For your regex of domain part, domain name cannot starts with \'-\' and cannot ends with \'-\'. Dash can only stays in between.If you used the PEAR library, check out their mail function (forgot the exact name/library).  You can validate email address by calling one function, and it validates the email address according to definition in RFC822.