I was always under the impression that you could give a stash a name by doing git stash save stashname, which you could later on apply by doing git stash apply stashname. But it seems that in this case all that happens is that stashname will be used as the stash description.Is there no way to actually name a stash? If not, what would you recommend to achieve equivalent functionality? Essentially I have a small stash which I would periodically like to apply, but don\'t want to always have to hunt in git stash list what its actual stash number is.You can actually find the stash by name using git\'s regular expression syntax for addressing objects:For example, when saving your stash with a save name:... you can use a regular expression to address that stash:This will apply the youngest stash that matches the regular expression guacamo. That way, you don\'t have to know what number the stash is at in the stack, you just have to know its name. There is no terser syntax for this, but you can create an alias in your .gitconfig file:You can then use git sapply <regex> to apply that stash (without dropping). You can then use git sshow <regex> to show: files changed, insertions, and deletionsEDIT: Props to this StackOverflow answer on how to use bash arguments in git aliases.EDIT 2: This answer used to contain drop and list aliases, but I\'ve since removed them, since drop requires the stash@{n} syntax while list didn\'t filter the stashes at all. If anyone knows how to resolve a stash SHA-1 hash to a stash ref, then I could implement the other commands as well.EDIT 3: Per isyi\'s suggestion I\'ve added a patch flag to show what the contents of the stash are when showing one.This is how you do it:where "my_stash" is the stash name...Some more useful things to know: All the stashes are stored in a stack.\nType in :This will list down all your stashes.To apply a stash and remove it from the stash stack, You can give,To apply a stash and keep it in the stash stack, type:Where n in the index of the stashed change.You can turn a stash into a branch if you feel it\'s important enough:from the man page:This creates and checks out a new branch named <branchname> starting from the commit at which the <stash> was originally created, applies the changes recorded in <stash> to the new working tree and index, then drops the <stash> if that completes successfully. When no <stash> is given, applies the latest one.This is useful if the branch on which you ran git stash save has changed enough that git stash apply fails due to conflicts. Since the stash is applied on top of the commit that was HEAD at the time git stash was run, it restores the originally stashed state with no conflicts.You can later rebase this new branch to some other place that\'s a descendent of where you were when you stashed.Stashes are not meant to be permanent things like you want. You\'d probably be better served using tags on commits. Construct the thing you want to stash. Make a commit out of it. Create a tag for that commit. Then roll back your branch to HEAD^. Now when you want to reapply that stash you can use git cherry-pick -n tagname (-n is --no-commit).sapply = "!f() { git stash apply \\"$(git stash list | awk -F: --posix -vpat=\\"$*\\" \\"$ 0 ~ pat {print $ 1; exit}\\")\\"; }; f"git sapply "<regex>"Edit: I sticked to my original solution, but I see why majority would prefer Etan Reisner\'s version (above). So just for the record:Alias\nThis might be a more direct syntax for Unix-like systems without needing to encapsulate in a function.\nAdd the following to ~/.gitconfig under [alias]Usage:\n    sapply regexExample:\n    git sshow MySecretStashThe hyphen at the end says take input from standard input.Use git stash save NAME to save.Then... you can use this script to choose which to apply (or pop):I like being able to see the names of the stashes and choose. Also I use Zshell and frankly didn\'t know how to use some of the Bash aliases above ;)Note: As Kevin says, you should use tags and cherry-picks instead.For everything besides the stash creation, I\'d propose another solution by introducing fzf as a dependency. Recommend taking 5 minutes of your time and get introduced to it, as it is over-all great productivity booster.Anyway, a related excerpt from their examples page offering stash searching. It\'s very easy to change the sciptlet to add additional functionality (like stash application or dropping):This is one way to accomplish this using PowerShell:More details here