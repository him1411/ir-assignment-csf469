I\'m trying to create globally-unique identifiers in JavaScript.  I\'m not sure what routines are available on all browsers, how "random" and seeded the built-in random number generator is, etc..The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.There have been a couple attempts at this. The question is: do you want actual GUIDs, or just random numbers that look like GUIDs? It\'s easy enough to generate random numbers.However, note that such values are not genuine GUIDs.\nThere\'s no way to generate real GUIDs in Javascript, because they depend on properties of the local computer that browsers do not expose. You\'ll need to use OS-specific services like ActiveX: http://p2p.wrox.com/topicindex/20339.htm\nEdit: not correct - RFC4122 allows random ("version 4") GUIDs.  See other answers for specifics.Note: the provided code snippet does not follow RFC4122 which requires that the version (4) has to be integrated into the generated output string. Do not use this answer if you need compliant GUIDs.Use:For an RFC4122 version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with.:Update, 2015-06-02:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses Math.random() for brevity, however Math.random() is not guaranteed to be a high-quality RNG.  See Adam Hyland\'s excellent writeup on Math.random() for details.  For a more robust solution, consider something like the uuid module[Disclaimer: I\'m the author], which uses higher quality RNG APIs where available.Update, 2015-08-26: As a side-note, this gist describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x1015 version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.Update, 2017-06-28: A good article from Chrome developers discussing the state of Math.random PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it\'s "pretty good", but not cryptographic quality.  To address that issue, here\'s an updated version of the above solution that uses ES6, the crypto API, and a bit of JS wizardy I can\'t take credit for:I really like how clean Broofa\'s answer is, but it\'s unfortunate that poor implementations of Math.random leave the chance for collision.  Here\'s a similar RFC4122 version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp.  That way, even if Math.random is on the same seed, both clients would have to generate the UUID at the exact same millisecond (or 10,000+ years later) to get the same UUID:   \nHere\'s a fiddle to test.broofa\'s answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!But if you\'re looking at that regular expression, those many replace() callbacks, toString()\'s and Math.random() function calls (where he\'s only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out rfc for generic GUID speed with generateQuickGUID.But, can we get speed and rfc compliance?  I say, YES!  Can we maintain readability?  Well...  Not really, but it\'s easy if you follow along.But first, my results, compared to broofa, guid (the accepted answer), and the non-rfc-compliant generateQuickGuid:So by my 6th iteration of optimizations, I beat the most popular answer by over 12X, the accepted answer by over 9X, and the fast-non-compliant answer by 2-3X.  And I\'m still rfc4122 compliant.Interested in how?  I\'ve put the full source on http://jsfiddle.net/jcward/7hyaC/3/ and on http://jsperf.com/uuid-generator-opt/4For an explanation, let\'s start with broofa\'s code:So it replaces x with any random hex digit, y with random data (except forcing the top 2 bits to 10 per the rfc spec), and the regex doesn\'t match the - or 4 characters, so he doesn\'t have to deal with them.  Very, very slick.The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, but it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).The first step toward performance is to eliminate the RegEx and its callback functions, and use a simple loop instead.  This means we have to deal with the - and 4 characters whereas broofa did not.  Also note that we can use String Array indexing to keep his slick String template architecture:Basically the same inner logic, except we check for - or 4, and the loop structure (instead of replace callbacks) gets us an almost 3X improvement!The next step is a small one on desktop, but makes a decent difference on mobile.  Lets make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let\'s also move that template definition out of the loop, just in case it helps:This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:The next optimization is another classic.  Since we\'re only handling 4-bits of output in each loop iteration, let\'s cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the rfc compliant bit positions, but it\'s not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.The final optimization technique to apply - unroll the loop.  Since we\'re looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper rfc bits, this version smokes them all:Modualized:  http://jcward.com/UUID.js - UUID.generate()The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it\'s most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.I hope my logic is correct -- it\'s very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!Be advised: my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.Here\'s some code based on RFC 4122, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).Fastest GUID like string generator method in the format XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX. This does not generated standard-compliant GUID.Ten million executions of this implementation takes just 32.5 seconds, which is the fastest i\'ve ever seen in a browser (the only solution without loops/iterations).The function is as simple as:To test the performance, you can run this code:I\'m sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:The algorithm:The assembly:Link to this post on my blogEnjoy! :-)Here is a combination of the top voted answer, with a workaround for Chrome\'s collisions:On jsbin if you want to test it.Here\'s a solution dated Oct. 9, 2011 from a comment by user jed at https://gist.github.com/982883:This accomplishes the same goal as the current highest-rated answer, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here\'s the annotated form of an older version of the function:Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.Here are usage examples and timings for this function and several of this question\'s other answers. The timing was performed under Chrome m25, 10 million iterations each.Here is the timing code.A web service would be useful.  Quick Google found: http://www.hoskinson.net/GuidGenerator/Can\'t vouch for this implementation, but SOMEONE must publish a bonafide GUID generator.With such a web service, you could develop a REST web interface that consumes the GUID web service, and serves it through AJAX to javascript in a browser.EDIT:Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.A version based on Briguy37\'s answer and some bitwise operators to extract nibble sized windows from the buffer.Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java\'s UUID.From sagi shkedy\'s technical blog:There are other methods that involve using an ActiveX control, but stay away from these!EDIT:  I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the wikipedia article).  There is always a chance of collisions.  A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.Simple JavaScript module as a combination of best answers in this thread.Usage: Guid.newGuid()"c6c2d12f-d76b-5739-e551-07e6de5b0807"Guid.empty"00000000-0000-0000-0000-000000000000"Well, this has a bunch of answers already, but unfortunately there\'s not a "true" random in the bunch. The version below is an adaptation of broofa\'s answer, but updated to include a "true" random function that uses crypto libraries where available, and the Alea() function as a fallback.From good ol\' wikipedia there\'s a link to a javascript implementation of UUID.It looks fairly elegant, and could perhaps be improved by salting with a hash of the client\'s IP address. This hash could perhaps be inserted into the html document server-side for use by the client-side javascript.UPDATE : The original site has had a shuffle, here is the updated versionJavaScript project on GitHub - https://github.com/LiosK/UUID.jsUUID.js The RFC-compliant UUID generator for JavaScript.See RFC 4122 http://www.ietf.org/rfc/rfc4122.txt.Features Generates RFC 4122 compliant UUIDs.Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs\n  (time-based UUIDs) are available.UUID object allows a variety of access to the UUID including access to\n  the UUID fields.Low timestamp resolution of JavaScript is compensated by random\n  numbers.If ID\'s are generated more than 1 milliseconds apart, they are 100% unique.If two ID\'s are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID\'s that are 99.99999999999999% likely to be globally unique.You can increase this number by adding more digits, but to generate 100% unique ID\'s you will need to use a global counter.This create version 4 UUID (created from pseudo random numbers) :Here is a sample of the UUIDs generated :You can use node-uuid (https://github.com/kelektiv/node-uuid)Simple, fast generation of RFC4122 UUIDS.Features:Install Using NPM:Or Using uuid via browser:Download Raw File (uuid v1): https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js\nDownload Raw File (uuid v4): https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.jsWant even smaller? Check this out: https://gist.github.com/jed/982883Usage:Adjusted my own UUID/GUID generator with some extras here.I\'m using the following Kybos random number generator to be a bit more cryptographically sound.Below is my script with the Mash and Kybos methods from baagoe.com excluded.The better way:Minimized:For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):The above function should have a decent balance between speed and randomness.I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called SP.Guid.newGuid (msdn link) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:It\'s just a simple AJAX call...If anyone is still interested, here\'s my solution.On the server side:On the client side:There is a jQuery plugin that handles Guid\'s nicely @ http://plugins.jquery.com/project/GUID_HelperReturns value of internal Guid. If no guid has been specified, returns a new one (value is then stored internally).Returns a new Guid and sets it\'s value internally.Returns an empty Guid 00000000-0000-0000-0000-000000000000.Returns boolean. True if empty/undefined/blank/null.Returns boolean. True valid guid, false if not.Retrns Guid. Sets Guid to user specified Guid, if invalid, returns an empty guid.This one is based on date, and add a random suffix to "ensure" uniqueness.\nWorks well for css identifiers.\nIt always returns something like and is easy to hack:uid-139410573297741I wanted to understand broofa\'s answer, so I expanded it and added comments:It is important that to use well tested code that is maintained by more than 1 contributors instead of whipping your own stuff for this. This is one of the places where you probably want to prefer most stable code than shortest possible clever version that works in X browser but doesn\'t take in to account idiosyncrasies of Y which would often lead to very hard to investigate bugs than manifests only randomly for some users. Personally I use uuid-js at https://github.com/aurigadl/uuid-js which bower enabled so I can take updates easily.Weird that no one has mentioned this yet but for completeness, there\'s a plethora of guid generators on npm I\'m willing to bet most of them work in browser too.