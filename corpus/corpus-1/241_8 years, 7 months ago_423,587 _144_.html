What do atomic and nonatomic mean in property declarations?What is the operational difference between these three?The last two are identical; "atomic" is the default behavior (note that it is not actually a keyword; it is specified only by the absence of nonatomic -- atomic was added as a keyword in recent versions of llvm/clang).Assuming that you are @synthesizing the method implementations, atomic vs. non-atomic changes the generated code.  If you are writing your own setter/getters, atomic/nonatomic/retain/assign/copy are merely advisory.  (Note:  @synthesize is now the default behavior in recent versions of LLVM.  There is also no need to declare instance variables;  they will be synthesized automatically, too, and will have an _ prepended to their name to prevent accidental direct access).With "atomic", the synthesized setter/getter will ensure that a whole value is always returned from the getter or set by the setter, regardless of setter activity on any other thread.   That is, if thread A is in the middle of the getter while thread B calls the setter, an actual viable value -- an autoreleased object, most likely -- will be returned to the caller in A.In nonatomic, no such guarantees are made.   Thus, nonatomic is considerably faster than "atomic".What "atomic" does not do is make any guarantees about thread safety.  If thread A is calling the getter simultaneously with thread B and C calling the setter with different values, thread A may get any one of the three values returned -- the one prior to any setters being called or either of the values passed into the setters in B and C.  Likewise, the object may end up with the value from B or C, no way to tell.Ensuring data integrity -- one of the primary challenges of multi-threaded programming -- is achieved by other means.Adding to this:atomicity of a single property also cannot guarantee thread safety when multiple dependent properties are in play.Consider:In this case, thread A could be renaming the object by calling setFirstName: and then calling setLastName:.   In the meantime, thread B may call fullName in between thread A\'s two calls and will receive the new first name coupled with the old last name.To address this, you need a transactional model.   I.e. some other kind of synchronization and/or exclusion that allows one to exclude access to fullName while the dependent properties are being updated.This is explained in Apple\'s documentation, but below are some examples of what is actually happening. Note that there is no "atomic" keyword, if you do not specify "nonatomic" then the property is atomic, but specifying "atomic" explicitly will result in an error.Now, the atomic variant is a bit more complicated:Basically, the atomic version has to take a lock in order to guarantee thread safety, and also is bumping the ref count on the object (and the autorelease count to balance it) so that the object is guaranteed to exist for the caller, otherwise there is a potential race condition if another thread is setting the value, causing the ref count to drop to 0.There are actually a large number of different variants of how these things work depending on whether the properties are scalar values or objects, and how retain, copy, readonly, nonatomic, etc interact. In general the property synthesizers just know how to do the "right thing" for all combinations.The best way to understand the difference is using the following example. Suppose there is an atomic string property called "name", and if you call [self setName:@"A"] from thread A, call [self setName:@"B"] from thread B, and call [self name] from thread C, then all operations on different threads will be performed serially which means if one thread is executing a setter or getter, then other threads will wait.This makes property "name" read/write safe, but if another thread, D, calls [name release] simultaneously then this operation might produce a crash because there is no setter/getter call involved here. Which means an object is read/write safe (ATOMIC), but not thread-safe as another threads can simultaneously send any type of messages to the object. The developer should ensure thread-safety for such objects.If the property "name" was nonatomic, then all threads in above example - A,B, C and D will execute simultaneously producing any unpredictable result. In case of atomic, either one of A, B or C will execute first, but D can still execute in parallel.The syntax and semantics are already well-defined by other excellent answers to this question. Because execution and performance are not detailed well, I will add my answer.What is the functional difference between these 3?I\'d always considered atomic as a default quite curious. At the abstraction level we work at, using atomic properties for a class as a vehicle to achieve 100% thread-safety is a corner case. For truly correct multithreaded programs, intervention by the programmer is almost certainly a requirement. Meanwhile, performance characteristics and execution have not\xc2\xa0yet been detailed in depth. Having written some heavily multithreaded programs over the years, I had been declaring my properties as nonatomic the entire time because atomic was not sensible for any purpose. During discussion of the details of atomic and nonatomic properties this question, I did some profiling encountered some curious results.ExecutionOk. The first thing I would like to clear up is that the locking implementation is implementation-defined and abstracted. Louis uses @synchronized(self) in his example -- I have seen this as a common source of confusion. The implementation does not actually use @synchronized(self); it uses object level spin locks. Louis\'s illustration is good for a high-level illustration using constructs we are all familiar with, but it\'s important to know it does not use @synchronized(self).Another difference is that atomic properties will retain/release cycle your objects within the getter.PerformanceHere\'s the interesting part: Performance using atomic property accesses in uncontested (e.g. single-threaded) cases can be really very fast in some cases. In less than ideal cases, use of atomic accesses can cost more than 20 times the overhead of nonatomic. While the Contested case using 7 threads was 44 times slower for the three-byte struct (2.2 GHz Core i7 Quad Core, x86_64). The three-byte struct is an example of a very slow property.Interesting side note: User-defined accessors of the three-byte struct were 52 times faster than the synthesized atomic accessors; or 84% the speed of synthesized nonatomic accessors.Objects in contested cases can also exceed 50 times.Due to the number of optimizations and variations in implementations, it\'s quite difficult to measure real-world impacts in these contexts. You might often hear something like "Trust it, unless you profile and find it is a problem". Due to the abstraction level, it\'s actually quite difficult to measure actual impact. Gleaning actual costs from profiles can be very time consuming, and due to abstractions, quite inaccurate. As well, ARC vs MRC can make a big difference.So let\'s step back, not focussing on the implementation of property accesses, we\'ll include the usual suspects like objc_msgSend, and examine some real-world high-level results for many calls to a NSString getter in uncontested cases (values in seconds):As you have probably guessed, reference count activity/cycling is a significant contributor with atomics and under ARC. You would also see greater differences in contested cases.Although I pay close attention to performance, I still say Semantics First!. Meanwhile, performance is a low priority for many projects. However, knowing execution details and costs of technologies you use certainly doesn\'t hurt. You should use the right technology for your needs, purposes, and abilities. Hopefully this will save you a few hours of comparisons, and help you make a better informed decision when designing your programs.Atomic     = thread safetyNon-atomic = No thread safetyInstance variables are thread-safe if they behave correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.If a thread changes the value of the instance the changed value is available to all the threads, and only one thread can change the value at a time.if the instance variable is gonna be accessed in a multithreaded environment.Not as fast as nonatomic because nonatomic doesn\'t require any watchdog work on that from runtime .If the instance variable is not gonna be changed by multiple threads you can use it. It improves the performance.I found a pretty well put explanation of atomic and non-atomic properties here. Here\'s some relevant text from the same:\'atomic\' means it cannot be broken down. \n  In OS/programming terms an atomic function call is one that cannot be interrupted - the entire function must be executed, and not swapped out of the CPU by the OS\'s usual context switching until it\'s complete. Just in case you didn\'t know: since the CPU can only do one thing at a time, the OS rotates access to the CPU to all running processes in little time-slices, to give the illusion of multitasking. The CPU scheduler can (and does) interrupt a process at any point in its execution - even in mid function call. So for actions like updating shared counter variables where two processes could try to update the variable at the same time, they must be executed \'atomically\', i.e., each update action has to finish in its entirety before any other process can be swapped onto the CPU.So I\'d be guessing that atomic in this case means the attribute reader methods cannot be interrupted - in effect meaning that the variable(s) being read by the method cannot change their value half way through because some other thread/call/function gets swapped onto the CPU.Because the atomic variables can not be interrupted, the value contained by them at any point is (thread-lock) guaranteed to be uncorrupted, although, ensuring this thread lock makes access to them slower. non-atomic variables, on the other hand, make no such guarantee but do offer the luxury of quicker access. To sum it up, go with non-atomic when you know your variables won\'t be accessed by multiple threads simultaneously and speed things up.After reading so many articles, Stack Overflow posts and making demo applications to check variable property attributes, I decided to put all the attributes information together:In the article Variable property attributes or modifiers in iOS you can find all the above-mentioned attributes, and that will definitely help you.atomicExample:nonatomicExample:Easiest answer first: There\'s no difference between your second two examples. By default, property accessors are atomic.Atomic accessors in a non garbage collected environment (i.e. when using retain/release/autorelease) will use a lock to ensure that another thread doesn\'t interfere with the correct setting/getting of the value.See the "Performance and Threading" section of Apple\'s Objective-C 2.0 documentation for some more information and for other considerations when creating multi-threaded apps.Atomic guarantees that access to the property will be performed in an atomic manner. E.g. it always return a fully initialised objects, any get/set of a property on one thread must complete before another can access it.If you imagine the following function occurring on two threads at once you can see why the results would not be pretty.Pros :\nReturn of fully initialised objects each time makes it best choice in case of multi-threading.Cons :\nPerformance hit, makes execution a little slowerUnlike Atomic, it doesn\'t ensure fully initialised object return each time.Pros :\nExtremely fast execution.Cons :\nChances of garbage value in case of multi-threading.Atomic means only one thread accesses the variable (static type). Atomic is thread-safe, but it is slow.Nonatomic means multiple threads access the variable (dynamic type). Nonatomic is thread-unsafe, but it is fast.There is no such keyword "atomic"We can use the above likeSee Stack Overflow question I am getting issues if I use @property(atomic,retain)NSString *myString.Atomic is thread safe, it is slow and it well-assures (not guaranteed) that only the locked value is provided no matter how many threads are attempting access over the same zone. When using atomic, a piece of code written inside this function becomes the part of the critical section, to which only one thread can execute at a time.It only assures the thread safety; it does not guarantee that. What I mean is you hire an expert driver for you car, still it doesn\'t guarantees car won\'t meet an accident. However, probability remains the slightest.Atomic - it can\'t be broken down, so the result is expected. With nonatomic - when another thread access the memory zone it can modify it, so the result is unexpected.Code Talk : Atomic make getter and setter of the property thread safe. for example if u have written : is thread safe. is NOT thread safe. The default is atomic, this means it does cost you performance whenever you use the property, but it is thread safe. What Objective-C does, is set a lock, so only the actual thread may access the variable, as long as the setter/getter is executed. Example with MRC of a property with an ivar _internal:So these last two are the same:On the other hand does nonatomic add nothing to your code. So it is only thread safe if you code security mechanism yourself.The keywords doesn\'t have to be written as first property attribute at all.Don\'t forget, this doesn\'t mean that the property as a whole is thread-safe. Only the method call of the setter/getter is. But if you use a setter and after that a getter at the same time with 2 different threads, it could be broken too!If you are using your property in multi-threaded code then you would be able to see the difference between nonatomic and atomic attributes. Nonatomic is faster than atomic and atomic is thread-safe, not nonatomic.Vijayendra Tripathi has already given an example for a multi-threaded environment.atomic (default)Atomic is the default: if you don\xe2\x80\x99t type anything, your property is\n  atomic. An atomic property is guaranteed that if you try to read from\n  it, you will get back a valid value. It does not make any guarantees\n  about what that value might be, but you will get back good data, not\n  just junk memory. What this allows you to do is if you have multiple\n  threads or multiple processes pointing at a single variable, one\n  thread can read and another thread can write. If they hit at the same\n  time, the reader thread is guaranteed to get one of the two values:\n  either before the change or after the change. What atomic does not\n  give you is any sort of guarantee about which of those values you\n  might get. Atomic is really commonly confused with being thread-safe,\n  and that is not correct. You need to guarantee your thread safety\n  other ways. However, atomic will guarantee that if you try to read,\n  you get back some kind of value.nonatomicOn the flip side, non-atomic, as you can probably guess, just means,\n  \xe2\x80\x9cdon\xe2\x80\x99t do that atomic stuff.\xe2\x80\x9d What you lose is that guarantee that you\n  always get back something. If you try to read in the middle of a\n  write, you could get back garbage data. But, on the other hand, you go\n  a little bit faster. Because atomic properties have to do some magic\n  to guarantee that you will get back a value, they are a bit slower. If\n  it is a property that you are accessing a lot, you may want to drop\n  down to nonatomic to make sure that you are not incurring that speed\n  penalty.See more here: https://realm.io/news/tmi-objective-c-property-attributes/Before discussing about the attributes of @property, you should know what is the use of @property.\n@property offers a way to define the information that a class is intended to encapsulate. If you declare an object/variable using @property, then that object/variable will be accessible to other classes importing its class.\nIf you declare an object using @property in the header file, then you have to synthesize it using @synthesize in the implementation file.Example:.h class.m classNow the compiler will synthesize accessor methods for name.List of attributes of @property :\natomic.\nnonatomic.\nretain.\ncopy.\nreadonly.\nreadwrite.\nassign.\nstrong.atomic : It is the default behaviour. If an object is declared as atomic then it becomes thread-safe. Thread-safe means, at a time only one thread of a particular instance of that class can have the control over that object.Example : nonatomic: It is not thread-safe. You can use the nonatomic property attribute to specify that synthesized accessors simply set or return a value directly, with no guarantees about what happens if that same value is accessed simultaneously from different threads. For this reason, it\xe2\x80\x99s faster to access a nonatomic property than an atomic one.\n@property (nonatomic)NSString *name;retain: is required when the attribute is a pointer to an object.The setter method will increase retain count of the object, so that it will occupy memory in autorelease pool.\n@property (retain)NSString *name;copy: If you use copy, you can\'t use retain. Using copy instance of the class will contain its own copy.\nEven if a mutable string is set and subsequently changed, the instance captures whatever value it has at the time it is set. No setter and getter methods will be synthesized.readonly: If you don\'t want to allow the property to be changed via setter method, you can declare the property readonly.\n@property (readonly) NSString *name;readwrite: is the default behaviour. You don\'t need to specify readwrite attribute explicitly.@property (readwrite) NSString *name;assign: will generate a setter which assigns the value to the instance variable directly, rather than copying or retaining it. This is best for primitive types like NSInteger and CGFloat, or objects you don\'t directly own, such as delegates.@property (assign) NSInteger year;strong: is a replacement for retain.\n@property (nonatomic, strong) AVPlayer *player;unsafe_unretained: There are a few classes in Cocoa and Cocoa Touch that don\xe2\x80\x99t yet support weak references, which means you can\xe2\x80\x99t declare a weak property or weak local variable to keep track of them. These classes include NSTextView, NSFont and NSColorSpace,etc. If you need to use a weak reference to one of these classes, you must use an unsafe reference.\nAn unsafe reference is similar to a weak reference in that it doesn\xe2\x80\x99t keep its related object alive, but it won\xe2\x80\x99t be set to nil if the destination object is deallocated.@property (unsafe_unretained) NSObject *unsafeProperty;How to declare:As atomic is default so,AND in implementation fileSuppose a task related to three properties areAll properties work parallelly (like asynchronously). If you call "name" from thread A, And At the same time if you call from thread B, Now If *name property is nonatomic then  Thats why non atomic is called thread unsafe But but it is fast in performance because of parallel execution Now If *name property is atomicThat\'s why nonatomic is called thread Safe and \nThat\'s why it is called read-write safeSuch situation operation will perform serially.\n And Slow in performance-  Nonatomic means multiple thread access the variable(dynamic type).- Nonatomic is thread unsafe.- but it is fast in performance-Nonatomic is NOT default behavior, we need to add nonatomic keyword    in property attribute.Fro more info please visit the website \nhttp://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.htmlThe atomic property ensures to retain a fully initialised value irrespective of how many threads are doing getter & setter on it. The nonatomic property specifies that synthesized accessors simply set or return a value directly, with no guarantees about what happens if that same value is accessed simultaneously from different threads.Before you begin: You must know that every object in memory needs to be deallocated from memory for a new write to happen. You can\'t just simply write on top of something as you do on paper. You must first erase (dealloc) it and then you can write onto it. If at the moment that the erase is done (or half done) and nothing has yet been wrote (or half wrote) and you try to read it could be very problematic! Atomic and nonatomic help you treat this problem in different ways.First read this question and then read Bbum\'s answer. In addition then read my summary.  atomic will ALWAYS guaranteeRetain counts are the way in which memory is managed in Objective-C.\n  When you create an object, it has a retain count of 1. When you send\n  an object a retain message, its retain count is incremented by 1. When\n  you send an object a release message, its retain count is decremented\n  by 1. When you send an object a autorelease message, its retain count\n  is decremented by 1 at some stage in the future. If an object\xca\xbcs retain\n  count is reduced to 0, it is deallocated.Wait what?! Are multithreading and thread safety different?Yes. Multithreading means: multiple threads can read a shared piece of data at the same time and we will not crash, yet it doesn\'t guarantee that you aren\'t reading from a non-autoreleased value. With thread safety, it\'s guaranteed that what you read is not auto-released. \nThe reason that we don\'t make everything atomic by default is, because there is a performance cost and it\'s most things don\'t really need thread safety. A few parts of our code need it and for those few parts we need to write our code in a thread safe way. To achieve either you must use locks, mutex or synchronization.nonatomicOverall they are different in 2 aspects:  Crashing or not because of having or not having autorelease pool.  Allowing to be read right in the middle of a \'not yet finished write or empty value\' or not allowing and only allowing to read when the value is fully written.Atomic means only one thread can access the variable at a time (static type). Atomic is thread-safe, but it is slow.Nonatomic means multiple threads can access the variable at same time (dynamic type). Nonatomic is thread-unsafe, but it is fast.If you are using atomic, it means the thread will be safe and read-only. If you are using nonatomic, it means the multiple threads access the variable and is thread unsafe, but it is executed fast, done a read and write operations; this is a dynamic type.Atomic: Ensure thread-safety by locking the thread using NSLOCK.Non atomic: Doesn\'t ensure thread-safety as there is no thread-locking mechanism.To simplify the entire confusion let us understand mutex lock.Mutex lock as per the name locks the mutability of the object.So if the object is accessed by a class no other class can access the same object.In iOS @sychronise also provide the mutex lock.Now it serve in FIFO mode and ensures the flow is not affected by two classes sharing the same instance.However if the task is on main thread avoid accessing object using atomic properties as it may hold your UI and degrade the performance The truth is that they use spin lock to implement atomic property. The code as below: