I was writing a simple script in the school computer, and committing the changes to Git (in a repo that was in my pendrive, cloned from my computer at home). After several commits I realized I was committing stuff as the root user.Is there any way to change the author of these commits to my name?Changing the author (or committer) would require re-writing all of the history.  If you\'re okay with that and think it\'s worth it then you should check out git filter-branch.  The main page includes several examples to get you started.  Also note that you can use environment variables to change the name of the author, committer, dates, etc. -- see the "Environment Variables" section of the git man page.Specifically, you can fix all the wrong author names and emails for all branches and tags with this command (source: GitHub help):You could doThen mark all of your bad commits as "edit" in the rebase file. If you also want to change your first commit, you have to manually add it as first line in the rebase file (follow the format of the other lines). Then, when git asks you to amend each commit, do edit or just close the editor that opens, and then doto continue the rebase.You could skip opening the editor altogether here by appending --no-edit\nso that the command will be:As some of the commenters have noted, if you just want to change the most recent commit, the rebase command is not necessary. Just do This will change the author to the name specified, but the committer will be set to your configured user in git config user.name and git config user.email. If you want to set the committer to something you specify, this will set both the author and the committer:There was a slight flaw in my original response. If there are any merge commits between the current HEAD and your <some HEAD before all your bad commits>, then git rebase will flatten them (and by the way, if you use GitHub pull requests, there are going to be a ton of merge commits in your history). This can very often lead to very different history (as duplicate changes may be "rebased out"), and in the worst case, it can lead to git rebase asking you to resolve difficult merge conflicts (which were likely already resolved in the merge commits). The solution is to use the -p flag to git rebase, which will preserve the merge structure of your history. The manpage for git rebase warns that using -p and -i can lead to issues, but in the BUGS section it says "Editing commits and rewording their commit messages should work fine."I\'ve added -p to the above command. For the case where you\'re just changing the most recent commit, this is not an issue.You can also do:Note, if you are using this command in the Windows command prompt, then you need to use " instead of \':One liner, but be careful if you have a multi-user repository - this will change all commits to have the same (new) author and committer.With linebreaks in the string (which is possible in bash):It happens when you do not have a $HOME/.gitconfig initialized. You may fix this as:tested with git version 1.7.5.4For a single commit:(extracted from asmeurer\'s answer)In the case where just the top few commits have bad authors, you can do this all inside git rebase -i using the exec command and the --amend commit, as follows:which presents you with the editable list of commits:Then add exec ... --author="..." lines after all lines with bad authors:save and exit editor (to run).This solution may be longer to type than some others, but it\'s highly controllable - I know exactly what commits it hits.Thanks to @asmeurer for the inspiration.Github has a nice solution, which is the following shell script:As docgnome mentioned, rewriting history is dangerous and will break other people\'s repositories.But if you really want to do that and you are in a bash environment (no problem in Linux, on Windows, you can use git bash, that is provided with the installation of git), use git filter-branch:To speed things up, you can specify a range of revisions you want to rewrite:When taking over an unmerged commit from another author, there is an easy way to handle this.git commit --amend --reset-authorThis is a more elaborated version of @Brian\'s version:To change the author and committer, you can do this (with linebreaks in the string which is possible in bash):You might get one of these errors:If you want to force the run in spite of these errors, add the --force flag:A little explanation of the -- --all option might be needed: It makes the filter-branch work on all revisions on all refs (which includes all branches). This means, for example, that tags are also rewritten and is visible on the rewritten branches.A common "mistake" is to use HEAD instead, which means filtering all revisions on just the current branch. And then no tags (or other refs) would exist in the rewritten branch.You can use this alias so you can do:or for the last 10 commits:Alias:Source: https://github.com/brauliobo/gitconfig/blob/master/configs/.gitconfigHope it is useful.loop the following two commands until you have processed all the commits:git commit --amend --reuse-message=HEAD --author="New Author <new@author.email>"\n;\ngit rebase --continueThis will keep all the other commit information (including the dates).\nThe --reuse-message=HEAD option prevents the message editor from launching.I adapted this solution which works by ingesting a simple author-conv-file (format is the same as one for git-cvsimport). It works by changing all users as defined in the author-conv-file across all branches. We used this in conjunction with cvs2git to migrate our repository from cvs to git.i.e. Sample author-conv-fileThe script:I use the following to rewrite the author for an entire repository, including tags and all branches:Then, as described in the MAN page of filter-branch, remove all original refs backed up by filter-branch (this is destructive, backup first):I found the presented versions way to aggressive, especially if you commit patches from other developers, this will essentially steal their code.The version below does work on all branches and changes the author and comitter separately to prevent that.Kudos to leif81 for the all option.I should point out that if the only problem is that the author/email is different from your usual, this is not a problem.  The correct fix is to create a file called .mailmap at the base of the directory with lines likeAnd from then on, commands like git shortlog will consider those two names to be the same (unless you specifically tell them not to).  See http://schacon.github.com/git/git-shortlog.html for more information.This has the advantage of all the other solutions here in that you don\'t have to rewrite history, which can cause problems if you have an upstream, and is always a good way to accidentally lose data.Of course, if you committed something as yourself and it should really be someone else, and you don\'t mind rewriting history at this point, changing the commit author is probably a good idea for attribution purposes (in which case I direct you to my other answer here).Change commit author name & email by Amend, then replacing old-commit with new-one: Another way Rebasing:If you are the only user of this repository, you can rewrite history using either git filter-branch (as svick wrote), or git fast-export/git fast-import plus filter script (as described in article referenced in docgnome answer), or interactive rebase.  But either of those would change revisions from first changed commit onwards; this means trouble for anybody that based his/her changes on your branch pre-rewrite.RECOVERY If other developers didn\'t based their work on pre-rewrite version, simplest solution would be to re-clone (clone again).  Alternatively they can try git rebase --pull, which would fast-forward if there weren\'t any changes in their repository, or rebase their branch on top of re-written commits (we want to avoid merge, as it would keep pre-rewrite comits forever).  All of this assuming that they do not have not comitted work; use git stash to stash away changes otherwise.If other developers use feature branches, and/or git pull --rebase doesn\'t work e.g. because upstream is not set up, they have to rebase their work on top of post-rewrite commits.  For example just after fetching new changes (git fetch), for a master branch based on / forked from origin/master, one needs to runHere origin/master@{1} is pre-rewrite state (before fetch), see gitrevisions.Alternate solution would be to use refs/replace/ mechanism, available in Git since version 1.6.5.  In this solution you provide replacements for commits that have wrong email; then anybody who fetches \'replace\' refs (something like fetch = +refs/replace/*:refs/replace/* refspec in appropriate place in their .git/config) would get replacements transparently, and those who do not fetch those refs would see old commits.The procedure goes something like this:Find all commits with wrong email, for example usingFor each wrong commit, create a replacement commit, and add it to object databaseNow that you have corrected commit in object database, you have to tell git to automatically and transparently replace wrong commit by corrected one using git replace command:Finally, list all replacement to check if this procedure succededand check if replacements take placeYou can of course automate this procedure... well, all except using git replace which doesn\'t have (yet) batch mode, so you would have to use shell loop for that, or replace "by hand".NOT TESTED! YMMV.Note that you might encounter some rough corners when using refs/replace/ mechanism: it is new, and not yet very well tested.If the commits you want to fix are the latest ones, and just a couple of them, you can use a combination of git reset and git stash to go back an commit them again after configuring the right name and email.The sequence will be something like this (for 2 wrong commits, no pending changes):If you are using Eclipse with EGit, then there is a quite easy solution.\nAssumption: you have commits in a local branch \'local_master_user_x\' which cannot be pushed to a remote branch \'master\' because of the invalid user.Using interactive rebase, you can place an amend command after each commit you want to alter. For instance:Note that git stores two different e-mail addresses, one for the committer (the person who committed the change) and another one for the author (the person who wrote the change).The committer information isn\'t displayed in most places, but you can see it with git log -1 --format=%cn,%ce (or use show instead of log to specify a particular commit).While changing the author of your last commit is as simple as git commit --amend --author "Author Name <email@example.com>", there is no one-liner or argument to do the same to the committer information.The solution is to (temporarily, or not) change your user information, then amend the commit, which will update the committer to your current information:We have experienced an issue today where a UTF8 character in an author name was causing trouble on the build server, so we had to rewrite the history to correct this. The steps taken were:Step 1: Change your username in git for all future commits, as per instructions here:\nhttps://help.github.com/articles/setting-your-username-in-git/Step 2: Run the following bash script:Quick overview: Checkout your repository to a temp file, checkout all the remote branches, run the script which will rewrite the history, do a force push of the new state, and tell all your colleagues to do a rebase pull to get the changes.We had trouble with running this on OS X because it somehow messed up line endings in commit messages, so we had to re-run it on a Linux machine afterwards.Your problem is really common. See "Using Mailmap to Fix Authors List in Git"For the sake of simplicity, I have created a script to ease the process: git-changemailAfter putting that script on your path, you can issue commands like:Change author matchings on current branchChange author and committer matchings on <branch> and <branch2>. Pass -f to filter-branch to allow rewriting backupsShow existing users on repoBy the way, after making your changes, clean the backup from the filter-branch with: git-backup-cleanIf you are the only user of this repo or you don\'t care about possibly breaking the repo for other users, then yes. If you\'ve pushed these commits and they exist where somewhere else can access them, then no, unless you don\'t care about breaking other people\'s repos. The problem is by changing these commits you will be generating new SHAs which will cause them to be treated as different commits. When someone else tries to pull in these changed commits, the history is different and kaboom.This page http://inputvalidation.blogspot.com/2008/08/how-to-change-git-commit-author.html describes how to do it. (I haven\'t tried this so YMMV)Press ^C # after the rebase is done (the loop will keep updating last commit)This isn\'t an answer to your question, but rather a script you can use to avoid this in the future.  It utilizes global hooks available since Git version 2.9 to check your email configuration based on the directory your in:It checks your current working directory, then verifies your git is configured to the correct email.  If not, it changes it automatically.  See the full details here.