Every now and then I hear the advice "Use bcrypt for storing passwords in PHP, bcrypt rules".But what is bcrypt? PHP doesn\'t offer any such functions, Wikipedia babbles about a file-encryption utility and Web searches just reveal a few implementations of Blowfish in different languages. Now Blowfish is also available in PHP via mcrypt, but how does that help with storing passwords? Blowfish is a general purpose cipher, it works two ways. If it could be encrypted, it can be decrypted. Passwords need a one-way hashing function.What is the explanation?bcrypt is a hashing algorithm which is scalable with hardware (via a configurable number of rounds). Its slowness and multiple rounds ensures that an attacker must deploy massive funds and hardware to be able to crack your passwords. Add to that per-password salts (bcrypt REQUIRES salts) and you can be sure that an attack is virtually unfeasible without either ludicrous amount of funds or hardware.bcrypt uses the Eksblowfish algorithm to hash passwords. While the encryption phase of Eksblowfish and Blowfish are exactly the same, the key schedule phase of Eksblowfish ensures that any subsequent state depends on both salt and key (user password), and no state can be precomputed without the knowledge of both. Because of this key difference, bcrypt is a one-way hashing algorithm. You cannot retrieve the plain text password without already knowing the salt, rounds and key (password). [Source]Password hashing functions have now been built directly into PHP >= 5.5. You may now use password_hash() to create a bcrypt hash of any password:To verify a user provided password against an existing hash, you may use the password_verify() as such:There is a compatibility library on GitHub created based on the source code of the above functions originally written in C, which  provides the same functionality. Once the compatibility library is installed, usage is the same as above (minus the shorthand array notation if you are still on the 5.3.x branch).You can use crypt() function to generate bcrypt hashes of input strings. This class can automatically generate salts and verify existing hashes against an input. If you are using a version of PHP higher or equal to 5.3.7, it is highly recommended you use the built-in function or the compat library. This alternative is provided only for historical purposes.You can use this code like this:Alternatively, you may also use the Portable PHP Hashing Framework.So, you want to use bcrypt? Awesome! However, like other areas of cryptography, you shouldn\'t be doing it yourself. If you need to worry about anything like managing keys, or storing salts or generating random numbers, you\'re doing it wrong.The reason is simple: it\'s so trivially easy to screw up bcrypt. In fact, if you look at almost every piece of code on this page, you\'ll notice that it\'s violating at least one of these common problems.Leave it for the experts. Leave it for people who\'s job it is to maintain these libraries. If you need to make a decision, you\'re doing it wrong.Instead, just use a library. Several exist depending on your requirements.Here is a breakdown of some of the more common APIs.Starting in PHP 5.5, a new API for hashing passwords is being introduced. There is also a shim compatibility library maintained (by me) for 5.3.7+. This has the benefit of being a peer-reviewed and simple to use implementation.Really, it\'s aimed to be extremely simple.Resources:This is another API that\'s similar to the PHP 5.5 one, and does a similar purpose. Resources:This is a slightly different approach to password hashing. Rather than simply supporting bcrypt, PasswordLib supports a large number of hashing algorithms. It\'s mainly useful in contexts where you need to support compatibility with legacy and disparate systems that may be outside of your control. It supports a large number of hashing algorithms. And is supported 5.3.2+References:This is a layer that does support bcrypt, but also supports a fairly strong algorithm that\'s useful if you do not have access to PHP >= 5.3.2... It actually supports PHP 3.0+ (although not with bcrypt).ResourcesNote: Don\'t use the PHPASS alternatives that are not hosted on openwall, they are different projects!!!If you notice, every one of these libraries returns a single string. That\'s because of how BCrypt works internally. And there are a TON of answers about that. Here are a selection that I\'ve written, that I won\'t copy/paste here, but link to:There are many different choices. Which you choose is up to you. However, I would HIGHLY recommend that you use one of the above libraries for handling this for you. Again, if you\'re using crypt() directly, you\'re probably doing something wrong. If your code is using hash() (or md5() or sha1()) directly, you\'re almost definitely doing something wrong.Just use a library...You\'ll get a lot of information in Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes or Portable PHP password hashing framework.The goal is to hash the password with something slow, so someone getting your password database will die trying to brute force it (a 10Â ms delay to check a password is nothing for you, a lot for someone trying to brute force it). Bcrypt is slow and can be used with a parameter to choose how slow it is.You can create a one-way hash with bcrypt using PHP\'s crypt() function and passing in an appropriate Blowfish salt. The most important of the whole equation is that A) the algorithm hasn\'t been compromised and B) you properly salt each password. Don\'t use an application-wide salt; that opens up your entire application to attack from a single set of Rainbow tables. PHP - Crypt FunctionEdit: 2013.01.15 - If your server will support it, use martinstoeckli\'s solution instead.Everyone wants to make this more complicated than it is. The crypt() function does most of the work.Example:I know it should be obvious, but please don\'t use \'password\' as your password.Version 5.5 of PHP will have built-in support for BCrypt, the functions password_hash() and password_verify(). Actually these are just wrappers around the function crypt(), and shall make it easier to use it correctly. It takes care of the generation of a safe random salt, and provides good default values.The easiest way to use this functions will be:This code will hash the password with BCrypt (algorithm 2y), generates a random salt from the OS random source, and uses the default cost parameter (at the moment this is 10). The second line checks, if the user entered password matches an already stored hash-value.Should you want to change the cost parameter, you can do it like this, increasing the cost parameter by 1, doubles the needed time to calculate the hash value:In contrast to the "cost" parameter, it is best to omit the "salt" parameter, because the function already does its best to create a cryptographically safe salt.For PHP version 5.3.7 and later, there exists a compatibility pack, from the same author that made the password_hash() function. For PHP versions before 5.3.7 there is no support for crypt() with 2y, the unicode safe BCrypt algorithm. One could replace it instead with 2a, which is the best alternative for earlier PHP versions.An alternative is to use scrypt, specifically designed to be superior to bcrypt by Colin Percival in his paper. There is an scrypt PHP extension in PECL. Ideally this algorithm would be rolled into PHP so that it could be specified for the password_* functions (ideally as "PASSWORD_SCRYPT"), but that\'s not there yet.Current thinking: hashes should be the slowest available, not the fastest possible. This suppresses rainbow table attacks.Also related, but precautionary: An attacker should never have unlimited access to your login screen. To prevent that: Set up an IP address tracking table that records every hit along with the URI. If more than 5 attempts to login come from the same IP address in any five minute period, block with explanation. A secondary approach is to have a two-tiered password scheme, like banks do. Putting a lock-out for failures on the second pass boosts security.Summary: slow down the attacker by using time-consuming hash functions. Also, block on too many accesses to your login, and add a second password tier.For OAuth 2 passwords: