I was looking for the fastest way to popcount large arrays of data. I encountered a very weird effect: Changing the loop variable from unsigned to uint64_t made the performance drop by 50% on my PC.As you see, we create a buffer of random data, with the size being x megabytes where x is read from the command line. Afterwards, we iterate over the buffer and use an unrolled version of the x86 popcount intrinsic to perform the popcount. To get a more precise result, we do the popcount 10,000 times. We measure the times for the popcount. In the upper case, the inner loop variable is unsigned, in the lower case, the inner loop variable is uint64_t. I thought that this should make no difference, but the opposite is the case.I compile it like this (g++ version: Ubuntu 4.8.2-19ubuntu1):Here are the results on my Haswell Core i7-4770K CPU @ 3.50 GHz, running test 1 (so 1 MB random data):As you see, the throughput of the uint64_t version is only half the one of the unsigned version! The problem seems to be that different assembly gets generated, but why? First, I thought of a compiler bug, so I tried clang++ (Ubuntu Clang version 3.4-1ubuntu3):Result: test 1So, it is almost the same result and is still strange. But now it gets super strange. I replace the buffer size that was read from input with a constant 1, so I change:toThus, the compiler now knows the buffer size at compile time. Maybe it can add some optimizations! Here are the numbers for g++:Now, both versions are equally fast. However, the unsigned got even slower! It dropped from 26 to 20 GB/s, thus replacing a non-constant by a constant value lead to a deoptimization. Seriously, I have no clue what is going on here! But now to clang++ with the new version:Wait, what? Now, both versions dropped to the slow number of 15 GB/s. Thus, replacing a non-constant by a constant value even lead to slow code in both cases for Clang!I asked a colleague with an Ivy Bridge CPU to compile my benchmark. He got similar results, so it does not seem to be Haswell. Because two compilers produce strange results here, it also does not seem to be a compiler bug. We do not have an AMD CPU here, so we could only test with Intel.Take the first example (the one with atol(argv[1])) and put a static before the variable, i.e.:Here are my results in g++:Yay, yet another alternative. We still have the fast 26 GB/s with u32, but we managed to get u64 at least from the 13 GB/s to the 20 GB/s version! On my collegue\'s PC, the u64 version became even faster than the u32 version, yielding the fastest result of all. Sadly, this only works for g++, clang++ does not seem to care about static.Can you explain these results? Especially:I know that optimization is a tricky territory, however, I never thought that such small changes can lead to a 100% difference in execution time and that small factors like a constant buffer size can again mix results totally. Of course, I always want to have the version that is able to popcount 26 GB/s. The only reliable way I can think of is copy paste the assembly for this case and use inline assembly. This is the only way I can get rid of compilers that seem to go mad on small changes. What do you think? Is there another way to reliably get the code with most performance?Here is the disassembly for the various results:26 GB/s version from g++ / u32 / non-const bufsize:13 GB/s version from g++ / u64 / non-const bufsize:15 GB/s version from clang++ / u64 / non-const bufsize:20 GB/s version from g++ / u32&u64 / const bufsize:15 GB/s version from clang++ / u32&u64 / const bufsize:Interestingly, the fastest (26 GB/s) version is also the longest! It seems to be the only solution that uses lea. Some versions use jb to jump, others use jne. But apart from that, all versions seem to be comparable. I don\'t see where a 100% performance gap could originate from, but I am not too adept at deciphering assembly. The slowest (13 GB/s) version looks even very short and good. Can anyone explain this?No matter what the answer to this question will be; I have learned that in really hot loops every detail can matter, even details that do not seem to have any association to the hot code. I have never thought about what type to use for a loop variable, but as you see such a minor change can make a 100% difference! Even the storage type of a buffer can make a huge difference, as we saw with the insertion of the static keyword in front of the size variable! In the future, I will always test various alternatives on various compilers when writing really tight and hot loops that are crucial for system performance.The interesting thing is also that the performance difference is still so high although I have already unrolled the loop four times. So even if you unroll, you can still get hit by major performance deviations. Quite interesting.Culprit: False Data Dependency (and the compiler isn\'t even aware of it)On Sandy/Ivy Bridge and Haswell processors, the instruction:appears to have a false dependency on the destination register dest. Even though the instruction only writes to it, the instruction will wait until dest is ready before executing.This dependency doesn\'t just hold up the 4 popcnts from a single loop iteration. It can carry across loop iterations making it impossible for the processor to parallelize different loop iterations.The unsigned vs. uint64_t and other tweaks don\'t directly affect the problem. But they influence the register allocator which assigns the registers to the variables.In your case, the speeds are a direct result of what is stuck to the (false) dependency chain depending on what the register allocator decided to do.The difference between 20 GB/s and 26 GB/s seems to be a minor artifact of the indirect addressing. Either way, the processor starts to hit other bottlenecks once you reach this speed.To test this, I used inline assembly to bypass the compiler and get exactly the assembly I want. I also split up the count variable to break all other dependencies that might mess with the benchmarks.Here are the results:Sandy Bridge Xeon @ 3.5 GHz: (full test code can be found at the bottom)Different Registers: 18.6195 GB/sSame Register: 8.49272 GB/sSame Register with broken chain: 17.8869 GB/sSo what went wrong with the compiler?It seems that neither GCC nor Visual Studio are aware that popcnt has such a false dependency. Nevertheless, these false dependencies aren\'t uncommon. It\'s just a matter of whether the compiler is aware of it.popcnt isn\'t exactly the most used instruction. So it\'s not really a surprise that a major compiler could miss something like this. There also appears to be no documentation anywhere that mentions this problem. If Intel doesn\'t disclose it, then nobody outside will know until someone runs into it by chance.(Update: As of version 4.9.2, GCC is aware of this false-dependency and generates code to compensate it when optimizations are enabled. Major compilers from other vendors, including Clang, MSVC, and even Intel\'s own ICC are not yet aware of this microarchitectural erratum and will not emit code that compensates for it.)Why does the CPU have such a false dependency?We can only speculate, but it\'s likely that Intel has the same handling for a lot of two-operand instructions. Common instructions like add, sub take two operands both of which are inputs. So Intel probably shoved popcnt into the same category to keep the processor design simple.AMD processors do not appear to have this false dependency.The full test code is below for reference:An equally interesting benchmark can be found here: http://pastebin.com/kbzgL8si\n\nThis benchmark varies the number of popcnts that are in the (false) dependency chain.I coded up an equivalent C program to experiment, and I can confirm this strange behaviour. What\'s more, gcc believes the 64-bit integer (which should probably be a size_t anyway...) to be better, as using uint_fast32_t causes gcc to use a 64-bit uint.\nI did a bit of mucking around with the assembly:\nSimply take the 32-bit version, replace all 32-bit instructions/registers with the 64-bit version in the inner popcount-loop of the program. Observation: the code is just as fast as the 32-bit version!\nThis is obviously a hack, as the size of the variable isn\'t really 64 bit, as other parts of the program still use the 32-bit version, but as long as the inner popcount-loop dominates performance, this is a good start.\nI then copied the inner loop code from the 32-bit version of the program, hacked it up to be 64 bit, fiddled with the registers to make it a replacement for the inner loop of the 64-bit version. This code also runs as fast as the 32-bit version.\nMy conclusion is that this is bad instruction scheduling by the compiler, not actual speed/latency advantage of 32-bit instructions. (Caveat: I hacked up assembly, could have broken something without noticing. I don\'t think so.)This is not an answer, but it\'s hard to read if I put results in comment.I get these results with a Mac Pro (Westmere 6-Cores Xeon 3.33 GHz). I compiled it with clang -O3 -msse4 -lstdc++ a.cpp -o a (-O2 get same result).I also tried to:Here is my wild guess:The speed factor comes in three parts:code cache: uint64_t version has larger code size, but this does not have an effect on my Xeon CPU. This makes the 64-bit version slower.Instructions used. Note not only the loop count, but the buffer is accessed with a 32-bit and 64-bit index on the two versions. Accessing a pointer with a 64-bit offset requests a dedicated 64-bit register and addressing, while you can use immediate for a 32-bit offset. This may make the 32-bit version faster.Instructions are only emitted on the 64-bit compile (that is, prefetch). This makes 64-bit faster.The three factors together match with the observed seemingly conflicting results.I can\'t give an authoritative answer, but provide an overview of a likely cause. This reference shows pretty clearly that for the instructions in the body of your loop there is a 3:1 ratio between latency and throughput. It also shows the effects of multiple dispatch. Since there are (give-or-take) three integer units in modern x86 processors, it\'s generally possible to dispatch three instructions per cycle.  So between peak pipeline and multiple dispatch performance and failure of these mechanisms, we have a factor of six in performance. It\'s pretty well known that the complexity of the x86 instruction set makes it quite easy for quirky breakage to occur. The document above has a great example:The Pentium 4 performance for 64-bit right shifts is really poor. 64-bit left shift as well as all 32-bit shifts have acceptable performance. It appears that the data path from the upper 32 bits to the lower 32 bit of the ALU is not well designed.I personally ran into a strange case where a hot loop ran considerably slower on a specific core of a four-core chip (AMD if I recall). We actually got better performance on a map-reduce calculation by turning that core off.Here my guess is contention for integer units: that the popcnt, loop counter, and address calculations can all just barely run at full speed with the 32-bit wide counter, but the 64-bit counter causes contention and pipeline stalls. Since there are only about 12 cycles total, potentially 4 cycles with multiple dispatch, per loop body execution, a single stall could reasonably affect run time by a factor of 2. The change induced by using a static variable, which I\'m guessing just causes a minor reordering of instructions, is another clue that the 32-bit code is at some tipping point for contention.I know this is not a rigorous analysis, but it is a plausible explanation.Have you tried passing -funroll-loops -fprefetch-loop-arrays to GCC?I get the following results with these additional optimizations:I tried this with Visual Studio 2013 Express, using a pointer instead of an index, which sped up the process a bit. I suspect this is because the addressing is offset + register, instead of offset + register + (register<<3). C++ code.assembly code: r10 = bfrptr, r15 = bfrend, rsi = count, rdi = buffer, r13 = k :Have you tried moving the reduction step outside the loop?  Right now you have a data dependency that really isn\'t needed.Try:You also have some weird aliasing going on, that I\'m not sure is conformant to the strict aliasing rules.TL;DR: Use __builtin intrinsics instead.I was able to make gcc 4.8.4 (and even 4.7.3 on gcc.godbolt.org) generate optimal code for this by using __builtin_popcountll which uses the same assembly instruction, but doesn\'t have that false dependency bug.I am not 100% sure of my benchmarking code, but objdump output seems to share my views. I use some other tricks (++i vs i++) to make the compiler unroll loop for me without any movl instruction (strange behaviour, I must say).Results:Benchmarking code:Compile options:GCC version:Linux kernel version:CPU information: