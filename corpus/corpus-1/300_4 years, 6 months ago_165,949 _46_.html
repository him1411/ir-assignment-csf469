The following print statement would print "hello world".\nCould anyone explain this?And randomString() looks like this:When an instance of java.util.Random is constructed with a specific seed parameter (in this case -229985452 or -147909649), it follows the random number generation algorithm beginning with that seed value.Every Random constructed with the same seed will generate the same pattern of numbers every time.The other answers explain why, but here is how.Given an instance of Random:The first 6 numbers that r.nextInt(27) generates are:and the first 6 numbers that r.nextInt(27) generates given Random r = new Random(-147909649) are:Then just add those numbers to the integer representation of the character ` (which is 96):I\'ll just leave it here. Whoever has a lot of (CPU) time to spare, feel free to experiment :) Also, if you have mastered some fork-join-fu to make this thing burn all CPU cores (just threads are boring, right?), please share your code. I would greatly appreciate it.Output:Everyone here did a great job of explaining how the code works and showing how you can construct your own examples, but here\'s an information theoretical answer showing why we can reasonably expect a solution to exist that the brute force search will eventually find.The 26 different lower-case letters form our alphabet \xce\xa3. To allow generating words of different lengths, we further add a terminator symbol \xe2\x8a\xa5 to yield an extended alphabet \xce\xa3\' := \xce\xa3 \xe2\x88\xaa {\xe2\x8a\xa5}.Let \xce\xb1 be a symbol and X a uniformly distributed random variable over \xce\xa3\'. The probability of obtaining that symbol, P(X = \xce\xb1), and its information content, I(\xce\xb1), are given by:P(X = \xce\xb1) = 1/|\xce\xa3\'| = 1/27I(\xce\xb1) = -log\xe2\x82\x82[P(X = \xce\xb1)] = -log\xe2\x82\x82(1/27) = log\xe2\x82\x82(27)For a word \xcf\x89 \xe2\x88\x88 \xce\xa3* and its \xe2\x8a\xa5-terminated counterpart \xcf\x89\' := \xcf\x89 \xc2\xb7 \xe2\x8a\xa5 \xe2\x88\x88 (\xce\xa3\')*, we haveI(\xcf\x89) := I(\xcf\x89\') = |\xcf\x89\'| * log\xe2\x82\x82(27) = (|\xcf\x89| + 1) * log\xe2\x82\x82(27)Since the Pseudorandom Number Generator (PRNG) is initialized with a 32-bit seed, we can expect most words of length up to\xce\xbb = floor[32/log\xe2\x82\x82(27)] - 1 = 5to be generated by at least one seed. Even if we were to search for a 6-character word, we would still be successful about 41.06% of the time. Not too shabby.For 7 letters we\'re looking at closer to 1.52%, but I hadn\'t realized that before giving it a try:See the output: http://ideone.com/JRGb3lI wrote a quick program to find these seeds:I have it running in the background now, but it\'s already found enough words for a classic pangram:(Demo on ideone.)Ps. -727295876, -128911, -1611659, -235516779.I was intrigued by this, I ran this random  word generator on a dictionary word list.\nRange: Integer.MIN_VALUE to Integer.MAX_VALUEI got 15131 hits.PrintsMost random number generators are, in fact, "pseudo random." They are Linear Congruential Generators, or LCGs (http://en.wikipedia.org/wiki/Linear_congruential_generator)LCGs are quite predictable given a fixed seed. Basically, use a seed that gives you your first letter, then write an app that continues to generate the next int (char) until you hit the next letter in your target string and write down how many times you had to invoke the LCG. Continue until you\'ve generated each and every letter.Random always return the same sequence. It\'s used for shuffling arrays and other operations as permutations.To get different sequences, it\'s necessary initialize the sequence in some position, called "seed".The randomSting get the random number in the i position (seed = -229985452) of the "random" sequence. Then uses the ASCII code for the next 27 character in the sequence after the seed position until this value are equal to 0. This return the "hello". The same operation is done for "world". I think that the code did not work for any other words. The guy that programmed that knows the random sequence very well.It\'s very great geek code!As multi-threading is very easy with Java, here is a variant that searches for a seed using all cores available: http://ideone.com/ROhmTADerived from Denis Tulskiy\'s answer, this method generates the seed.The principal is the Random Class constructed with the same seed will generate the same pattern of numbers every time.From the Java docs, this is an intentional feature when specifying a seed value for the Random class.If two instances of Random are created with the same seed, and the\n  same sequence of method calls is made for each, they will generate and\n  return identical sequences of numbers. In order to guarantee this\n  property, particular algorithms are specified for the class Random.\n  Java implementations must use all the algorithms shown here for the\n  class Random, for the sake of absolute portability of Java code.http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Random.htmlOdd though, you would think there are implicit security issues in having predictable \'random\' numbers.It is about "seed". Same seeds give the same result.Here is a minor improvement for Denis Tulskiy answer. It cuts the time by half