What\'s the most elegant way to split a string? The string can be assumed to be composed of words separated by whitespace.(Note that I\'m not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.)The best solution I have right now is:For what it\'s worth, here\'s another way to extract tokens from an input string, relying only on standard library facilities. It\'s an example of the power and elegance behind the design of the STL.Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic copy algorithm.... or create the vector directly:I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.Edit : Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:A possible solution using Boost might be:This approach might be even faster than the stringstream approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.See the documentation for details.For those with whom it does not sit well to sacrifice all efficiency for code size and see "efficient" as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):I usually choose to use std::vector<std::string> types as my second parameter (ContainerT)... but list<> is way faster than vector<> for when direct access is not needed, and you can even create your own string class and use something like std::list<subString> where subString does not do any copies for incredible speed increases.It\'s more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.All it needs is std::string... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.Here\'s another solution. It\'s compact and reasonably efficient:It can easily be templatised to handle string separators, wide strings, etc.Note that splitting "" results in a single empty string and splitting "," (ie. sep) results in two empty strings.It can also be easily expanded to skip empty tokens:If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:This is my favourite way to iterate through a string. You can do what you want per word. This is similar to StackÂ Overflow question How do I tokenize a string in C++?.I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn\'t look as good then.Of course, Boost has a split() that works partially like that. And, if by \'white-space\', you really do mean any type of white-space, using Boost\'s split with is_any_of() works great.The STL does not have such a method available already.However, you can either use C\'s strtok function by using the string.c_str() member, or you can write your own. Here is a code sample I found after a quick google search ("STL string split"):Taken from: http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.htmlIf you have questions about the code sample, leave a comment and I will explain.And just because it does not implement a typedef called iterator or overload the << operator does not mean it is bad code. I use the C functions quite frequently. For example, printf and scanf both are faster then cin and cout (significantly), the fopen syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.Don\'t get sold on this "Elegance over performance" deal.Here is a split function that:ignores empty tokens (can easily be changed)Example usage:I have a 2 lines solution to this problem:Then instead of printing you can put it in a vector.Yet another flexible and fast wayTo use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :That\'s it! And that\'s just one way to use the tokenizer, like how to just \ncount words:Limited by imagination ;)If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the boost_split_iterator.Example code including convenient template:Here\'s a simple solution that uses only the standard regex libraryThe regex argument allows checking for multiple arguments (spaces, commas, etc.)I usually only check to split on spaces and commas, so I also have this default function:The "[\\\\s,]+" checks for spaces (\\\\s) and commas (,).Note, if you want to split wstring instead of string,Note, you might also want to take the string argument by reference, depending on your compiler.Using stringstream as you have works perfectly fine, and do exactly what you wanted. If you\'re just looking for different way of doing things though, you can use find/find_first_of and substring.There is a function named strtok.Heres a regex solution that only uses the standard regex library.  (I\'m a little rusty, so there may be a few syntax errors, but this is at least the general idea)So far I used the one in Boost, but I needed something that doesn\'t depends on it, so I came to this:A good point is that in separators you can pass more than one character.I\'ve rolled my own using strtok and used boost to split a string.  The best method I have found is the C++ String Toolkit Library.  It is incredibly flexible and fast.The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.The stringstream can be convenient if you need to parse the string by non-space symbols:Short and elegantcan use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)using:output:I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn\'t rely on tokens and you can use fields as delimiters, which is another key I needed.I\'m sure there\'s improvements that can be made to even further improve its elegance and please do by all meansStringSplitter.hpp:StringSplitter.cpp:Examples:Will output:This\nis\nan\nexample\ncstringTo keep empty entries (by default empties will be excluded):The goal was to make it similar to C#\'s Split() method where splitting a string is as easy as:I hope someone else can find this as useful as I do.What about this:Here\'s another way of doing it..I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters. For example, this splits "AQueryTrades" into "A", "Query" and "Trades".  The function works with narrow and wide strings. Because it respects the current locale it splits "Raumfahrt\xc3\x9cberwachungsVerordnung" into "Raumfahrt", "\xc3\x9cberwachungs" and "Verordnung".Note std::upper should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like ",", ";" or " " too.The code below uses strtok() to split a  string into tokens and stores the tokens in a vector.I use this simpleton because we got our String class "special" (i.e. not standard):