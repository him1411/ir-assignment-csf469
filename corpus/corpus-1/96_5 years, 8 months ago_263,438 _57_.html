In Swing, the password field has a getPassword() (returns char[]) method instead of the usual getText() (returns String) method. Similarly, I have come across a suggestion not to use String to handle passwords.Why does String pose a threat to security when it comes to passwords?\nIt feels inconvenient to use char[].Strings are immutable. That means once you\'ve created the String, if another process can dump memory, there\'s no way (aside from reflection) you can get rid of the data before garbage collection kicks in.With an array, you can explicitly wipe the data after you\'re done with it. You can overwrite the array with anything you like, and the password won\'t be present anywhere in the system, even before garbage collection.So yes, this is a security concern - but even using char[] only reduces the window of opportunity for an attacker, and it\'s only for this specific type of attack.As noted in comments, it\'s possible that arrays being moved by the garbage collector will leave stray copies of the data in memory. I believe this is implementation-specific - the garbage collector may clear all memory as it goes, to avoid this sort of thing. Even if it does, there\'s still the time during which the char[] contains the actual characters as an attack window.While other suggestions here seem valid, there is one other good reason. With plain String you have much higher chances of accidentally printing the password to logs, monitors or some other insecure place. char[] is less vulnerable.Consider this:Prints:To quote an official document, the Java Cryptography Architecture guide says this about char[] vs. String passwords (about password-based encryption, but this is more generally about passwords of course):It would seem logical to collect and store the password in an object\n  of type java.lang.String. However, here\'s the caveat: Objects of\n  type String are immutable, i.e., there are no methods defined that\n  allow you to change (overwrite) or zero out the contents of a String\n  after usage. This feature makes String objects unsuitable for\n  storing security sensitive information such as user passwords. You\n  should always collect and store security sensitive information in a\n  char array instead.Guideline 2-2 of the Secure Coding Guidelines for the Java Programming Language, Version 4.0 also says something similar (although it is originally in the context of logging):Guideline 2-2: Do not log highly sensitive informationSome information, such as Social Security numbers (SSNs) and\n  passwords, is highly sensitive. This information should not be kept\n  for longer than necessary nor where it may be seen, even by\n  administrators. For instance, it should not be sent to log files and\n  its presence should not be detectable through searches. Some transient\n  data may be kept in mutable data structures, such as char arrays, and\n  cleared immediately after use. Clearing data structures has reduced\n  effectiveness on typical Java runtime systems as objects are moved in\n  memory transparently to the programmer.This guideline also has implications for implementation and use of\n  lower-level libraries that do not have semantic knowledge of the data\n  they are dealing with. As an example, a low-level string parsing\n  library may log the text it works on. An application may parse an SSN\n  with the library. This creates a situation where the SSNs are\n  available to administrators with access to the log files.Character arrays (char[]) can be cleared after use by setting each character to zero and Strings not. If someone can somehow see the memory image, they can see a password in plain text if Strings are used, but if char[] is used, after purging data with 0\'s, the password is secure.Some people believe that you have to overwrite the memory used to store the password once you no longer need it. This reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the JVM memory to do this. An attacker with that much access can catch your key events making this completely useless (AFAIK, so please correct me if I am wrong).UpdateThanks to the comments I have to update my answer. Apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. Still I think it\'s overkill for most use cases.If possible, disabling core dumps and the swap file would take care of both problems. However, they would require administrator rights and may reduce functionality (less memory to use) and pulling RAM from a running system would still be a valid concern.toString() there is always a risk of printing plain text in log file or console but if use Array you won\'t print contents of the array instead its memory location get printed. String password: passwdCharacter password: [C@110b2345Final thoughts: Though using char[] is not just enough you need to erase content to be more secure. I also suggest working with hashed or encrypted password instead of plain text and clearing it from memory as soon as authentication is completed.I don\'t think this is a valid suggestion, but, I can at least guess at the reason.I think the motivation is wanting to make sure that you can erase all trace of the password in memory promptly and with certainty after it is used. With a char[] you could overwrite each element of the array with a blank or something for sure. You can\'t edit the internal value of a String that way.But that alone isn\'t a good answer; why not just make sure a reference to the char[] or String doesn\'t escape? Then there\'s no security issue. But the thing is that String objects can be intern()ed in theory and kept alive inside the constant pool. I suppose using char[] forbids this possibility.The answer has already been given, but I\'d like to share an issue that I discovered lately with Java standard libraries. While they take great care now of replacing password strings with char[] everywhere (which of course is a good thing), other security-critical data seems to be overlooked when it comes to clearing it from memory.I\'m thinking of e.g. the PrivateKey class. Consider a scenario where you would load a private RSA key from a PKCS#12 file, using it to perform some operation. Now in this case, sniffing the password alone wouldn\'t help you much as long as physical access to the key file is properly restricted. As an attacker, you would be much better off if you obtained the key directly instead of the password. The desired information can be leaked manifold, core dumps, a debugger session or swap files are just some examples.And as it turns out, there is nothing that lets you clear the private information of a PrivateKey from memory, because there\'s no API that lets you wipe the bytes that form the corresponding information.This is a bad situation, as this paper describes how this circumstance could be potentially exploited.The OpenSSL library for example overwrites critical memory sections before private keys are freed. Since Java is garbage-collected, we would need explicit methods to wipe and invalidate private information for Java keys, which are to be applied immediately after using the key. As Jon Skeet states, there is no way except by using reflection. However, if reflection is an option for you, you can do this.when runNote: if the String\'s char[] has been copied as a part of a GC cycle, there is a chance the previous copy is somewhere in memory.  This old copy wouldn\'t appear in a heap dump, but if you have direct access to the raw memory of the process you could see it.  In general you should avoid anyone having such access.These are all the reasons, one should choose char[] array instead of String for password.1.  Since Strings are immutable in Java if you store password as plain text it will be available in memory until Garbage collector clears it and since String are used in String pool for reusability there is pretty high chance that it will be remain in memory for long duration, which pose a security threat. Since any one who has access to memory dump can find the password in clear text and that\'s another reason you should always used an encrypted password than plain text. Since Strings are immutable there is no way contents of Strings can be changed because any change will produce new String, while if you char[] you can still set all his element as blank or zero. So Storing password in character array clearly mitigates security risk of stealing password.2.  Java itself recommends using getPassword() method of JPasswordField which returns a char[] and deprecated getText() method which returns password in clear text stating security reason. Its good to follow advice from Java team and adhering to standard rather than going against it.3.  With String there is always a risk of printing plain text in log file or console but if use Array you won\'t print contents of array instead its memory location get printed. though not a real reason but still make sense.Reference from:  http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html\nHope this helps.Edit: Coming back to this answer after a year of security research, I realize it makes the rather unfortunate implication that you would ever actually compare plaintext passwords. Please don\'t. Use a secure one-way hash with a salt and a reasonable number of iterations. Consider using a library: this stuff is hard to get right!Original answer: What about the fact that String.equals() uses short-circuit evaluation, and is therefore vulnerable to a timing attack? It may be unlikely, but you could theoretically time the password comparison in order to determine the correct sequence of characters.Some more resources on timing attacks:There is nothing that char array gives you vs String unless you clean it up manually after use, and I haven\'t seen anyone actually doing that. So to me the preference of char[] vs String is a little exaggerated.Take a look at the widely used Spring Security library here and ask yourself - are Spring Security guys incompetent or char[] passwords just don\'t make much sense. When some nasty hacker grabs memory dumps of your RAM be sure she\'ll get all the passwords even if you use sophisticated ways to hide them.However, Java changes all the time, and some scary features like String Deduplication feature of Java 8 might intern String objects without your knowledge. But that\'s different conversation.Strings are immutable and cannot be altered once they have been created. Creating a password as a string will leave stray references to the password on the heap or on the String pool. Now if someone takes a heap dump of the Java process and carefully scans through he might be able to guess the passwords. Of course these non used strings will be garbage collected but that depends on when the GC kicks in.On the other side char[] are mutable as soon as the authentication is done you can overwrite them with any character like all M\'s or backslashes. Now even if someone takes a heap dump he might not be able to get the passwords which are not currently in use. This gives you more control in the sense like clearing the Object content yourself vs waiting for the GC to do it.Simple and short answer would be because char[] are mutable while String objects are not.Strings in Java are immutable objects. That is why they can\'t be modified once created, and therefore the only way for their contents to be removed from memory is to have them garbage collected. It will be only then, when the memory freed by the object can be overwritten and the data will be gone.Now garbage collection in Java doesn\'t happen at any kind of guaranteed interval. The String can thus persist in memory for a long time, and if a process crashes during this time, the contents of the string may end up in a memory dump or some log. With a character array, you can read the password, finish working with it as soon as you can, and then immediately change the contents.String in java is immutable. So whenever a string is created, it will remain in the memory until it is garbage collected. So anyone who has access to the memory can read the value of the string. \nIf the value of the string is modified then it will end up creating a new string. So both the original value and the modified value stay in the memory until it is garbage collected.  \nWith the character array, the contents of the array can be modified or erased once the purpose of the password is served. The original contents of the array will not be found in memory after it is modified and even before the garbage collection kicks in.\nBecause of the security concern it is better to store password as a character array.1) Since Strings are immutable in Java if you store password as plain text it will be available in memory until Garbage collector clears it and since String are used in String pool for reusability there is pretty high chance that it will be remain in memory for long duration, which pose a security threat. Since any one who has access to memory dump can find the password in clear text and that\'s another reason you should always used an encrypted password than plain text. Since Strings are immutable there is no way contents of Strings can be changed because any change will produce new String, while if you char[] you can still set all his element as blank or zero. So Storing password in character array clearly mitigates security risk of stealing password.2) Java itself recommends using getPassword() method of JPasswordField which returns a char[] and deprecated getText() method which returns password in clear text stating security reason. Its good to follow advice from Java team and adhering to standard rather than going against it.