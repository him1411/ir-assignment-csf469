I\'m using git on a new project that has two parallel -- but currently experimental -- development branches:exp1 and exp2 represent two very different architectural approaches.  Until I get further along I have no way of knowing which one (if either) will work.  As I make progress in one branch I sometimes have edits that would be useful in the other branch and would like to merge just those.What is the best way to merge selective files from one development branch to another while leaving behind everything else?Approaches I\'ve considered:git merge --no-commit followed by manual unstaging of a large number of edits that I don\'t want to make common between the branches.Manual copying of common files into a temp directory followed by git checkout to move to the other branch and then more manual copying out of the temp directory into the working tree.A variation on the above.  Abandon the exp branches for now and use two additional local repositories for experimentation.  This makes the manual copying of files much more straightforward.All three of these approaches seem tedious and error-prone.  I\'m hoping there is a better approach; something akin to a filter path parameter that would make git-merge more selective.You use the cherry-pick command to get individual commits from one branch.If the change(s) you want are not in individual commits, then use the method shown here to split the commit into individual commits. Roughly speaking, you use git rebase -i to get the original commit to edit, then git reset HEAD^ to selectively revert changes, then git commit to commit that bit as a new commit in the history.There is another nice method here in Red Hat Magazine, where they use git add --patch or possibly git add --interactive which allows you to add just parts of a hunk, if you want to split different changes to an individual file (search in that page for "split").Having split the changes, you can now cherry-pick just the ones you want.I had the exact same problem as mentioned by you above.  But I found this clearer in explaining the answer.Summary:Checkout the path(s) from the branch you want to merge,$ git checkout source_branch -- <paths>...or to selectively merge hunks$ git checkout -p source_branch -- <paths>...Alternatively, use reset and then add with the option -p,$ git reset <paths>...\n$ git add -p <paths>...Finally commit$ git commit -m "\'Merge\' these changes"To selectively merge files from one branch into another branch, runwhere branchX is the branch you want to merge from into the current branch.The --no-commit option will stage the files that have been merged by Git without actually committing them. This will give you the opportunity to modify the merged files however you want to and then commit them yourself. Depending on how you want to merge files, there are four cases:In this case, you accept the merged files the way Git merged them automatically and then commit them.For example, you want to retain the version in the current branch and ignore the version in the branch you are merging from.To select the version in the current branch, run:This will retrieve the version of file1 in the current branch and overwrite the file1 automerged by Git. Run:This will retrieve the version of file1 in branchX and overwrite file1 auto-merged by Git.In this case, you can edit the modified file1 directly, update it to whatever you\'d want the version of file1 to become, and then commit.If Git cannot merge a file automatically, it will report the file as "unmerged"  and produce a copy where you will need to resolve the conflicts manually.To explain further with an example, let\'s say you want to merge branchX into the current branch:You then run the git status command to view the status of modified files.For example:Where file1, file2, and file3 are the files git have successfully auto-merged. What this means is that changes in the master and branchX for all those three files have been combined together without any conflicts.You can inspect how the merge was done by running the git diff --cached;RunRunGit has already merged it at this point.file4 above is a failed merge by Git. This means there are changes in both branches that occur on the same line. This is where you will need to resolve the conflicts manually. You can discard the merged done by editing the file directly or running the checkout command for the version in the branch you want file4 to become.Finally, don\'t forget to git commit.I don\'t like the above approaches.  Using cherry-pick is great for picking a single change, but it is a pain if you want to bring in all the changes except for some bad ones.  Here is my approach.There is no --interactive argument you can pass to git merge.Here is the alternative:You have some changes in branch \'feature\' and you want to bring some but not all of them over to \'master\' in a not sloppy way (i.e. you don\'t want to cherry pick and commit each one)So just wrap that in a shell script, change master into $to and change feature into $from and you are good to go:There is another way do go:It is a mix between git checkout and git add -p and might quite be exactly what you are looking for:While some of these answers are pretty good, I feel like none actually answered OP\'s original constraint: selecting particular files from particular branches.  This solution does that, but may be tedious if there are many files.Lets say you have the master, exp1, and exp2 branches.  You want to merge one file from each of the experimental branches into master.  I would do something like this:This will give you in-file diffs for each of the files you want.  Nothing more.  Nothing less.  It\'s useful you have radically different file changes between versions--in my case, changing an app from Rails 2 to Rails 3.EDIT: this will merge files, but does a smart merge.  I wasn\'t able to figure out how to use this method to get in-file diff information (maybe it still will for extreme differences.  Annoying small things like whitespace get merged back in unless you use the -s recursive -X ignore-all-space option)1800 INFORMATION\'s answer is completely correct.  As a git noob, though, "use git cherry-pick" wasn\'t enough for me to figure this out without a bit more digging on the internet so I thought I\'d post a more detailed guide in case anyone else is in a similar boat.  My use case was wanting to selectively pull changes from someone else\'s github branch into my own.  If you already have a local branch with the changes you only need to do steps 2 and 5-7.Create (if not created) a local branch with the changes you want to bring in.$ git branch mybranch <base branch>Switch into it.$ git checkout mybranchPull down the changes you want from the other person\'s account.  If you haven\'t already you\'ll want to add them as a remote.$ git remote add repos-w-changes <git url>Pull down everything from their branch.$ git pull repos-w-changes branch-i-wantView the commit logs to see which changes you want:$ git log Switch back to the branch you want to pull the changes into.$ git checkout originalbranchCherry pick your commits, one by one, with the hashes.$ git cherry-pick -x hash-of-commitHat tip: http://www.sourcemage.org/Git_GuideHere is how you can replace Myclass.java file in master branch with Myclass.java in feature1 branch. It will work even if Myclass.java doesn\'t exist on master.Note this will overwrite - not merge - and ignore local changes in the master branch rather.The simple way, to actually merge specific files from two branches, not just replace specific files with ones from another branch.git diff branch_b > my_patch_file.patchCreates a patch file of the difference between the current branch and branch_bgit apply -p1 --include=pattern/matching/the/path/to/file/or/folder my_patch_file.patchYou can use * as a wildcard in the include pattern. Slashes don\'t need to be escaped.Also, you could use --exclude instead and apply it to everything except the files matching the pattern, or reverse the patch with -R The -p1 option is a holdover from the *unix patch command and the fact that the patch file\'s contents prepend each file name with a/ or b/ ( or more depending on how the patch file was generated) which you need to strip so that it can figure out the real file to the path to the file the patch needs to be applied to.Check out the man page for git-apply for more options. Obviously you\'d want to commit your changes, but who\'s to say you don\'t have some other related tweaks you want to do before making your commit. Here\'s how you can get history to follow just a couple files from another branch with a minimum of fuss, even if a more "simple" merge would have brought over a lot more changes that you don\'t want.First, you\'ll take the unusual step of declaring in advance that what you\'re about to commit is a merge, without git doing anything at all to the files in your working directory:. . . where "branchname" is whatever you claim to be merging from. If you were to commit right away, it would make no changes but it would still show ancestry from the other branch. You can add more branches/tags/etc. to the command line if you need to, as well. At this point though, there are no changes to commit, so get the files from the other revisions, next.If you were merging from more than one other branch, repeat as needed.Now the files from the other branch are in the index, ready to be committed, with history.and you\'ll have a lot of explaining to do in that commit message.Please note though, in case it wasn\'t clear, that this is messed up thing to do. It is not in the spirit of what a "branch" is for, and cherry-pick is a more honest way to do what you\'d be doing, here. If you wanted to do another "merge" for other files on the same branch that you didn\'t bring over last time, it will stop you with an "already up to date" message. It\'s a symptom of not branching when we should have, in the "from" branch should be more than one different branch.I know I am a little late but this is my workflow for merging selective files.I found this post to contain the simplest answer. Merely do:Example:See the post for more info.Easiest way is to set your repo to the branch you want to merge with then run,If you run you will see the file already staged...Then run Simple. It\'s strange that git still does not have such a convenient tool "out of the box". I use it heavily when update some old version branch (which still has a lot of software users) by just some bugfixes from the current version branch. In this case it is often needed to quickly get just some lines of code from the file in trunk, ignoring a lot of other changes (that are not supposed to go into the old version)... And of course interactive three-way merge is needed in this case, git checkout --patch <branch> <file path> is not usable for this selective merge purpose.  You can do it easily: Just add this line to [alias] section in your global .gitconfig or local .git/config file:  It implies you use Beyond Compare. Just change to software of your choice if needed. Or you can change it to three-way auto-merge if you don\'t need the interactive selective merging:  Then use like this:  This will give you the true selective tree-way merge opportunity of just any file in other branch.I would do agit diff commit1..commit2 filepattern | git-apply --index && git commitThis way you can limit the range of commits for a filepattern from a branch.Stolen from: http://www.gelato.unsw.edu.au/archives/git/0701/37964.htmlI like the \'git-interactive-merge\' answer, above, but there\'s one easier.  Let git do this for you using a rebase combination of interactive and onto:So the case is you want C1 and C2 from \'feature\' branch (branch point \'A\'), but none of the rest for now.Which, as above, drops you in to the interactive editor where you select the \'pick\' lines for C1 and C2 (as above).  Save and quit, and then it will proceed with the rebase and give you branch \'temp\' and also HEAD at master + C1 + C2:Then you can just update master to HEAD and delete the temp branch and you\'re good to go:I know this question is old and there are many other answers, but I wrote my own script called \'pmerge\' to partially merge directories. It\'s a work in progress and I\'m still learning both git and bash scripting.This command uses git merge --no-commit and then unapplies changes that don\'t match the path provided.Usage: git pmerge branch path\nExample: git merge develop src/I haven\'t tested it extensively. The working directory should be free of any uncommitted changes and untracked files.I had the exact same problem as mentioned by you above.  But I found this git blog clearer in explaining the answer.Command from the above link:It is not exactly what you were looking for, but it was useful to me:It is a mix of some answers.You can use read-tree to read or merge given remote tree into the current index, for example:To perform merge, use -m instead.See also: How do I merge a sub directory in git?