I\'ve seen many people use the following code:But I know you could also do this:Or this:Personally, I feel the last one is the cleanest, but is there something I\'m missing? Which one is the best to use, or is it personal preference?All are different.What about typeof(T)? Is it also resolved at compile time?Yes. T is always what the type of the expression is. Remember, a generic method is basically a whole bunch of methods with the appropriate type. Example:Use typeof when you want to get the type at compilation time.  Use GetType when you want to get the type at execution time.  There are rarely any cases to use is as it does a cast and, in most cases, you end up casting the variable anyway.There is a fourth option that you haven\'t considered (especially if you are going to cast an object to the type you find as well); that is to use as.This only uses one cast whereas this approach:requires two.1.This is illegal, because typeof only works on types, not on variables. I assume obj1 is a variable. So, in this way typeof is static, and does its work at compile time instead of runtime.2.This is true if obj1 is exactly of type int. If obj1 derives from int, the if condition will be false.3.This is true if obj1 is an int, or if it derives from a class called int, or if it implements an interface called int.This is an error.  The typeof operator in C# can only take type names, not objects.This will work, but maybe not as you would expect.  For value types, as you\'ve shown here, it\'s acceptable, but for reference types, it would only return true if the type was the exact same type, not something else in the inheritance hierarchy.  For instance:This would print "o is something else", because the type of o is Dog, not Animal.  You can make this work, however, if you use the IsAssignableFrom method of the Type class.This technique still leaves a major problem, though.  If your variable is null, the call to GetType() will throw a NullReferenceException.  So to make it work correctly, you\'d do:With this, you have equivalent behavior of the is keyword.  Hence, if this is the behavior you want, you should use the is keyword, which is more readable and more efficient.In most cases, though, the is keyword still isn\'t what you really want, because it\'s usually not enough just to know that an object is of a certain type.  Usually, you want to actually use that object as an instance of that type, which requires casting it too.  And so you may find yourself writing code like this:But that makes the CLR check the object\'s type up to two times.  It will check it once to satisfy the is operator, and if o is indeed an Animal, we make it check again to validate the cast.It\'s more efficient to do this instead:The as operator is a cast that won\'t throw an exception if it fails, instead returning null.  This way, the CLR checks the object\'s type just once, and after that, we just need to do a null check, which is more efficient.But beware: many people fall into a trap with as.  Because it doesn\'t throw exceptions, some people think of it as a "safe" cast, and they use it exclusively, shunning regular casts.  This leads to errors like this:In this case, the developer is clearly assuming that o will always be an Animal, and as long as their assumption is correct, everything works fine.  But if they\'re wrong, then what they end up with here is a NullReferenceException.  With a regular cast, they would have gotten an InvalidCastException instead, which would have more correctly identified the problem.Sometimes, this bug can be hard to find:This is another case where the developer is clearly expecting o to be an Animal every time, but this isn\'t obvious in the constructor, where the as cast is used.  It\'s not obvious until you get to the Interact method, where the animal field is expected to be positively assigned.  In this case, not only do you end up with a misleading exception, but it isn\'t thrown until potentially much later than when the actual error occurred.In summary:If you only need to know whether or not an object is of some type, use is.If you need to treat an object as an instance of a certain type, but you don\'t know for sure that the object will be of that type, use as and check for null.If you need to treat an object as an instance of a certain type, and the object is supposed to be of that type, use a regular cast.I had a Type-property to compare to and could not use is (like my_type is _BaseTypetoLookFor), but I could use these:Notice that IsInstanceOfType and IsAssignableFrom return true when comparing the same types, where IsSubClassOf will return false.  And IsSubclassOf does not work on interfaces, where the other two do.  (See also this question and answer.)I prefer isThat said, if you\'re using is, you\'re likely not using inheritance properly.Assume that Person : Entity, and that Animal : Entity.  Feed is a virtual method in Entity (to make Neil happy)RatherI believe the last one also looks at inheritance (e.g. Dog is Animal == true), which is better in most cases.It depends on what I\'m doing.  If I need a bool value (say, to determine if I\'ll cast to an int), I\'ll use is.  If I actually need the type for some reason (say, to pass to some other method) I\'ll use GetType().The last one is cleaner, more obvious, and also checks for subtypes. The others do not check for polymorphism.You can use "typeof()" operator in C# but you need to call the namespace using System.IO; You must use "is" keyword if you wish to check for a type.Performance test typeof() vs GetType():Results in debug mode:Results in release mode: