What is the difference between old style and new style classes in Python?  Is there ever a reason to use old-style classes these days?From http://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes :Up to Python 2.1, old-style classes were the only flavour available to the user. The concept of (old-style) class is unrelated to the concept of type: if x is an instance of an old-style class, then x.__class__ designates the class of x, but type(x) is always <type \'instance\'>. This reflects the fact that all old-style instances, independently of their class, are implemented with a single built-in type, called instance. New-style classes were introduced in Python 2.2 to unify the concepts of class and type. A new-style class is simply a user-defined type, no more, no less. If x is an instance of a new-style class, then type(x) is typically the same as x.__class__ (although this is not guaranteed \xe2\x80\x93 a new-style class instance is permitted to override the value returned for x.__class__).The major motivation for introducing new-style classes is to provide a unified object model with a full meta-model. It also has a number of immediate benefits, like the ability to subclass most built-in types, or the introduction of "descriptors", which enable computed properties. For compatibility reasons, classes are still old-style by default. New-style classes are created by specifying another new-style class (i.e. a type) as a parent class, or the "top-level type" object if no other parent is needed. The behaviour of new-style classes differs from that of old-style classes in a number of important details in addition to what type returns. Some of these changes are fundamental to the new object model, like the way special methods are invoked. Others are "fixes" that could not be implemented before for compatibility concerns, like the method resolution order in case of multiple inheritance. Python 3 only has new-style classes. No matter if you subclass from object or not, classes are new-style in Python 3.Declaration-wise:New-style classes inherit from object, or from another new-style class.Old-style classes don\'t.Important behavior changes between old and new style classesIt was mentioned in other answers, but here goes a concrete example of the difference between classic MRO and C3 MRO (used in new style classes).The question is the order in which attributes (which include methods and member variables) are searched for in multiple inheritance.Classic classes do a depth first search from left to right. Stop on first match. They do not have the __mro__ attribute.New-style classes MRO is more complicated to synthesize in a single English sentence. It is explained in detail here. One of its properties is that a Base class is only searched for once all its Derived classes have been. They have the __mro__ attribute which shows the search order. Around Python 2.5 many classes could be raised, around Python 2.6 this was removed. On Python 2.7.3:Old style classes are still marginally faster for attribute lookup. This is not usually important, but may be useful in performance-sensitive Python 2.x code:Guido has written The Inside Story on New-Style Classes, a really great article about new-style and old-style class in Python.Python 3 has only new-style class, even if you write an \'old-style class\', it is implicitly derived from object.New-style classes have some advanced features lacking in old-style classes, such as super and the new C3 mro, some magical methods, etc.Here\'s a very practical, True/False difference. The only difference between the two versions of the following code is that in the second version Person inherits from object. Other than that the two versions are identical, but with different results :1) old-style classes2) new-style classes New-style classes inherit from object and must be written as such in Python 2.2 onwards (i.e. class Classname(object): instead of class Classname:). The core change is to unify types and classes, and the nice side-effect of this is that it allows you to inherit from built-in types.Read descrintro for more details.New style classes may use super(Foo, self) where Foo is a class and self is the instance.super(type[, object-or-type])Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by getattr() except that the type itself is skipped.And in Python 3.x you can simply use super() inside a class with no parameters.Or rather, you should always use new-style classes, unless you have code that needs to work with versions of Python older than 2.2.