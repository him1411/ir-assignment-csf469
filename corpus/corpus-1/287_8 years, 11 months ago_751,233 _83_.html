I need to be able to merge two (very simple) JavaScript objects at runtime.  For example I\'d like to:Does anyone have a script for this or know of a built in way to do this?  I do not need recursion, and I do not need to merge functions, just methods on flat objects.ECMAScript 2015 (ES6) Standard Method(see MDN JavaScript Reference)Method for ES5 and EarlierNote that this will simply add all attributes of obj2 to obj1 which might not be what you want if you still want to use the unmodified obj1.If you\'re using a framework that craps all over your prototypes then you have to get fancier with checks like hasOwnProperty, but that code will work for 99% of cases.Example function:jQuery also has a utility for this: http://api.jquery.com/jQuery.extend/.Taken from the jQuery documentation:The above code will mutate the object named settings.If you want to create a new object without modifying either argument, use this:The Harmony ECMAScript 2015 (ES6) specifies Object.assign which will do this.Current browser support is getting better, but if you\'re developing for browsers that don\'t have support, you can use a polyfill.I googled for code to merge object properties and ended up here. However since there wasn\'t any code for recursive merge I wrote it myself. (Maybe jQuery extend is recursive BTW?) Anyhow, hopefully someone else will find it useful as well.(Now the code does not use Object.prototype :)Produces object o3 likeNote that underscore.js\'s extend-method does this in a one-liner:Similar to jQuery extend(), you have the same function in AngularJS:I need to merge objects today, and this question (and answers) helped me a lot. I tried some of the answers, but none of them fit my needs, so I combined some of the answers, added something myself and came up with a new merge function. Here it is:Some example usages:The given solutions should be modified to check source.hasOwnProperty(property) in the for..in loops before assigning - otherwise, you end up copying the properties of the whole prototype chain, which is rarely desired...An Object.assign method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need. (IE not supported)The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.Read more...The polyfill to support older browsers:The following two are probably a good starting point. lodash also has a customizer function for those special needs!_.extend (http://underscorejs.org/#extend) \n_.merge (https://lodash.com/docs#merge)You can use object spread properties\xe2\x80\x94currently a stage 3 ECMAScript proposal.Just by the way, what you\'re all doing is overwriting properties, not merging...This is how JavaScript objects area really merged: Only keys in the to object which are not objects themselves will be overwritten by from. Everything else will be really merged. Of course you can change this behaviour to not overwrite anything which exists like only if to[n] is undefined, etc...:Usage:Object.assign()ECMAScript 2015 (ES6)This is a new technology, part of the ECMAScript 2015 (ES6) standard.\nThis technology\'s specification has been finalized, but check the compatibility table for usage and implementation status in various browsers.The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.Here\'s my stab whichIs short :)Example:The best way for you to do this is to add a proper property that is non-enumerable using Object.defineProperty. This way you will still be able to iterate over your objects properties without having the newly created "extend" that you would get if you were to create the property with Object.prototype.extend.Hopefully this helps:Once you have that working, you can do:I just wrote a blog post about it here: http://onemoredigit.com/post/1527191998/extending-objects-in-node-jsYou can simply use jQuery extendNow obj1 contains all the values of obj1 and obj2For not-too-complicated objects you could use JSON:Mind you that in this example "}{" must not occur within a string!Just if anyone is using Google Closure Library:Similar helper function exists for array:There\'s a library called deepmerge on GitHub: That seems to be getting some traction. It\'s a standalone, available through both the npm and bower package managers.I would be inclined to use or improve on this instead of copy-pasting code from answers.Prototype has this:obj1.extend(obj2) will do what you want.In MooTools, there\'s Object.merge():I extended David Coallier\'s method:If override is false, no property gets overridden but new properties will be added.Usage:\nobj.merge(merges... [, override]);Here is my code:Examples and TestCases:My equals method can be found here: Object comparison in JavaScriptIn Ext JS 4 it can be done as follows:See merge( object ) : Object.With Underscore.js, to merge an array of objects do:It results in:You should use lodash\'s defaultsDeepIt\'s worth mentioning that the version from the 140byt.es collection is solving the task within minimum space and is worth a try for this purpose:Code:Usage for your purpose:Here\'s the original Gist.Based on Markus\' and vsync\' answer, this is an expanded version. The function takes any number of arguments. It can be used to set properties on DOM nodes and makes deep copies of values. However, the first argument is given by reference.To detect a DOM node, the isDOMNode() function is used (see Stack Overflow question JavaScript isDOM \xe2\x80\x94 How do you check if a JavaScript Object is a DOM Object?)It was tested in Opera 11, Firefox 6, Internet Explorer 8 and Google Chrome 16.Set innerHTML and style of a HTML ElementMerge arrays and objects. Note that undefined can be used to preserv values in the lefthand array/object.Any argument not beeing a JavaScript object (including null) will be ignored. Except for the first argument, also DOM nodes are discarded. Beware that i.e. strings, created like new String() are in fact objects.If you want to merge two objects into a new (without affecting any of the two) supply {} as first argumentI use the following which is in pure JavaScript. It starts from the right-most argument and combines them all the way up to the first argument. There is no return value, only the first argument is modified and the left-most parameter (except the first one) has the highest weight on properties.My way::)You can merge objects through following my method