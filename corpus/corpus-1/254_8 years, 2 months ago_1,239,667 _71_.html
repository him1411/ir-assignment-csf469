I have a String[] with values like so:Given String s, is there a good way of testing whether VALUES contains s?Warning: this doesn\'t work for arrays of primitives (see the comments).You can now use a Stream to check whether an array of int, double or long contains a value (by respectively using a IntStream, DoubleStream or LongStream)Just to clear the code up to start with. We have (corrected):This is a mutable static which FindBugs will tell you is very naughty. It should be private:(Note, you can actually drop the new String[]; bit.)So, reference arrays are bad, and in particular here we want a set:(Paranoid people, such as myself, may feel more at ease if this was wrapped in Collections.unmodifiableSet - it could even be made public.)"Given String s, is there a good way of testing whether VALUES contains s?"O(1).You can use ArrayUtils.contains from Apache Commons Langpublic static boolean contains(Object[] array, Object objectToFind)Note that this method returns false if the passed array is null.There are also methods available for primitive arrays of all kinds.I\'m surprised no one suggested to just simply implement it by hand:Improvement:The v != null condition is constant inside the method, it always evaluates to the same boolean value during the method call. So if the input array is big, it is more efficient to evaluate this condition only once and we can use a simplified/faster condition inside the for loop based on the result. The improved contains() method:If the array is not sorted, you will have to iterate over everything and make a call to equals on each.If the array is sorted, you can do a binary search, there\'s one in the Arrays class.Generally speaking, if you are going to do a lot of membership checks, you may want to store everything in a Set, not in an array. For what its worth I ran a test comparing the 3 suggestions for speed. I generated random integers, converted them to a String and added them to an array. I then searched for the highest possible number/string, which would be a worst case scenario for the asList().contains().When using a 10K array size the results where:When using a 100K array the results where:So if the array is created in sorted order the binary search is the fastest, otherwise the asList().contains would be the way to go. If you have many searches, then it may be worthwhile to sort the array so you can use the binary search. It all depends on your application.  I would think those are the results most people would expect. Here is the test code:Four Different Ways to Check If an Array Contains a Value1) Using List:2) Using Set:3) Using a simple loop:4) Using Arrays.binarySearch():The code below is wrong, it is listed here for completeness. binarySearch() can ONLY be used on sorted arrays. You will find the result is weird below. This is the best option when array is sorted.Instead of using the quick array initialsation syntax to you could just initialise it as a List straight away in a similar manner using the Arrays.asList method e.g.:Then you can do (like above): STRINGS.contains("the string you want to find");With Java 8 you can create a stream and check if any entries in the stream matches "s":Or as a generic method:You can use the Arrays class to perform a binary search for the value. If your array is not sorted, you will have to use the sort functions in the same class to sort the array, then search through it.ObStupidAnswer (but I think there\'s a lesson in here somewhere):Actually , if you use HashSet as Tom Hawtin proposed you don`t need to worry about sorting and your speed is the same as with Binary Search on a presorted array, probably even faster.It all depends on how your code is set up, obviously, but from where I stand, the order would be:On an UNsorted array:On a sorted array:So either way, HashSet ftwIf you have the google collections library, Tom\'s answer can be simplified a lot by using ImmutableSet (http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/collect/ImmutableSet.html)This really removes a lot of clutter from the initialization proposedIn Java 8 use Streams.Using a simple loop is the most efficient way of doing this. Courtesy to ProgramcreekFor arrays of limited length use the following (as given by camickr).  This is slow for repeated checks, especially for longer arrays (linear search).  For fast performance if you repeatedly check against a larger set of elementsAn array is the wrong structure.  Use a TreeSet and add each element to it.  It sorts elements and has a fast exist() method (binary search).If the elements implement Comparable & you want the TreeSet sorted accordingly:ElementClass.compareTo() method must be compatable with ElementClass.equals(): see Triads not showing up to fight? (Java Set missing an item) Otherwise, use your own Comparator:The payoff: check existence of some element:Developers often do:The above code works, but there is no need to convert a list to set first. Converting a list to a set requires extra time. It can as simple as:orThe first one is more readable than the second one.Arrays.asList => then applying the contains() method will always work, but a search algorithm is much better, since first you have to convert the Array to a list, then calling the contains method, double the steps, see what I mean?Use Array.BinarySearch(array,obj) for finding the given object in array or not.\nEx:if (Array.BinarySearch(str, i) > -1) -->true --existsfalse --not existsTry This:I am very late to join this discussion, but since my approach in solving this problem, when I faced it a few years ago, was a bit different than the other answers already posted here, I am posting that solution I used at that time, over here, in case anyone finds it usefull: (The contains() method is ArrayUtils.in() in this code.)ObjectUtils.javaArrayUtils.javaAs you can see in the code above, that there are other utility methods ObjectUtils.equals() and ArrayUtils.indexOf(), that were used at other places as well.One possible solution would be:check thisThank You