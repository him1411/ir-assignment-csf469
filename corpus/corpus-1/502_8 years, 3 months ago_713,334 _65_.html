I came across some Java code that had the following structure:I know that in C++ I can assign a parameter a default value.  For example:Does Java support this kind of syntax?  Are there any reasons why this two step syntax is preferable?No, the structure you found is how Java handles it (that is, with overloading instead of default parameters).For constructors, See Effective Java: Programming Language Guide\'s Item 1 tip (Consider static factory methods instead of constructors) if the overloading is getting complicated. For other methods, renaming some cases or using a parameter object can help. This is when you have enough complexity that differentiating is difficult. A definite case is where you have to differentiate using the order of parameters, not just number and type.No, but you can use the Builder Pattern, as described in this Stack Overflow answer.As described in the linked answer, the Builder Pattern lets you write code likein which some fields can have default values or otherwise be optional.There are several ways to simulate default parameters in Java:Method overloading.One of the limitations of this approach is that it doesn\'t work if you have two optional parameters of the same type and any of them can be omitted.Varargs.a) All optional parameters are of the same type:b) Types of optional parameters may be different:The main drawback of this approach is that if optional parameters are of different types you lose static type checking. Furthermore, if each parameter has different meaning you need some way to distinguish them.Nulls. To address the limitations of the previous approaches you can allow null values and then analyse each parameter in a method body:Now all arguments values must be provided, but the default ones may be null.Optional class. This approach is similar to nulls, but uses Java 8 Optional class for parameters that have a default value:Optional makes a method contract explicit for a caller, however, one may find such signature too verbose.Builder pattern. The builder pattern is used for constructors and is implemented by introducing a separate Builder class:Maps. When the number of parameters is too large and for most of them default values are usually used, you can pass method arguments as a map of their names/values:Please note that you can combine any of these approaches to achieve a desirable result.Sadly, no.Unfortunately, yes.could be written in Java 1.5 as:But whether or not you should depend on how you feel about the compiler generating afor each call.For multiple defaultable parameters:could be written in Java 1.5 as:This matches C++ syntax, which only allows defaulted parameters at the end of the parameter list.  Beyond syntax, there is a difference where this has run time type checking for passed defaultable parameters and C++ type checks them during compile.No, but you can very simply emulate them. What in C++ was:In Java, it will be an overloaded function:Earlier was mentioned, that default parameters caused ambiguous cases in function overloading. That is simply not true, we can see in the case of the C++: yes, maybe it can create ambiguous cases, but these problem can be easily handled. It simply wasn\'t developed in Java, probably because the creators wanted a much simpler language as C++ was - if they had right, is another question. But most of us don\'t think he uses Java because of its simplicity.You can do this is in Scala, which runs on the JVM and is compatible with Java programs.\nhttp://www.scala-lang.org/i.e.I might be stating the obvious here but why not simply implement the "default" parameter yourself?for the default you would ether usefunc("my string");and if you wouldn\'t like to use the default, you would usefunc("my string", false);No. In general Java doesn\'t have much (any) syntactic sugar, since they tried to make a simple language.It is not supported but there are several options like using parameter object pattern with some syntax sugar:In this sample we construct ParameterObject with default values and override them in class instance initialization section { param1 = 10; param2 = "bar";}No. You can achieve the same behavior by passing an Object which has smart defaults. But again it depends what your case is at hand.Try this solution:There are half a dozen or better issues such as this, eventually you arrive at the static factory pattern ... see the crypto api for that. Sort difficult to explain, but think of it this way: If you have a constructor, default or otherwise, the only way to propagate state beyond the curly braces is either to have a Boolean isValid; ( along with the null as default value v failed constructor ) or throw an exception which is never informative when getting it back from field users.Code Correct be damned, I write thousand line constructors and do what I need. I find using isValid at object construction - in other words, two line constructors - but for some reason I am migrating to the static factory pattern. I just seems you can do a lot if you in a method call, there are still sync() issues but defaults can be \'substituted\' better ( safer )I think what we need to do here is address the issue of null as default value vis-a-vis something String one=new String(""); as a member variable, then doing a check for null before assigning string passed to the constructor. Very remarkable the amount of raw, stratospheric computer science done in Java.C++ and so on has vendor libs, yes. Java can outrun them on large scale servers due to it\'s massive toolbox. Study static initializer blocks, stay with us.A similar approach to https://stackoverflow.com/a/13864910/2323964 that works in Java 8 is to use an interface with default getters. This will be more whitespace verbose, but is mockable, and it\'s great for when you have a bunch of instances where you actually want to draw attention to the parameters.This is how I did it ... it\'s not as convenient perhaps as having an \'optional argument\' against your defined parameter, but it gets the job done:Notice I can invoke the same method name with either just a string or I can invoke it with a string and a boolean value. In this case, setting wipeClean to true will replace all of the text in my TextArea with the provided string. Setting wipeClean to false or leaving it out all together simply appends the provided text to the TextArea.Also notice I am not repeating code in the two methods, I am merely adding the functionality of being able to reset the TextArea by creating a new method with the same name only with the added boolean.I actually think this is a little cleaner than if Java provided an \'optional argument\' for our parameters since we would need to then code for default values etc. In this example, I don\'t need to worry about any of that. Yes, I have added yet another method to my class, but it\'s easier to read in the long run in my humble opinion.You may use Java Method Invocation Builder to automatically generate the builder with default values.Just add @GenerateMethodInvocationBuilder to the class, or interface, and the @Default to parameters in methods where you want default values. A builder will be generated at compile time, using the default values that you specified with your annotations.And then you can invoke the methods.Or set any of the default values to something else.NO, But we have alternative in the form of function overloading.called when no parameter passedcalled when "a" parameter was passedcalled when parameter b passed