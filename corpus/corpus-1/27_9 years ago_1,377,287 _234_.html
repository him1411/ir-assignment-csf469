I always thought Java was pass-by-reference; however I\'ve seen a couple of blog posts (For example, this blog) that claim it\'s not. I don\'t think I understand the distinction they\'re making. What is the explanation?Java is always pass-by-value. Unfortunately, they decided to call the location of an object a "reference".  When we pass the value of an object, we are passing the reference to it.  This is confusing to beginners.It goes like this:In this example aDog.getName() will still return "Max". The value aDog within main is not changed in the function foo with the Dog "Fifi" as the object reference is passed by value. If it were passed by reference, then the aDog.getName() in main would return "Fifi" after the call to foo.Likewise:In the above example, FiFi is the dog\'s name after call to foo(aDog) because the object\'s name was set inside of foo(...). Any operations that foo performs on d are such that, for all practical purposes, they are performed on aDog itself (except when d is changed to point to a different Dog instance like d = new Dog("Boxer")).I just noticed you referenced my article.The Java Spec says that everything in Java is pass-by-value. There is no such thing as "pass-by-reference" in Java.The key to understanding this is that something likeis not a Dog; it\'s actually a pointer to a Dog.What that means, is when you haveyou\'re essentially passing the address of the created Dog object to the foo method.(I say essentially because Java pointers aren\'t direct addresses, but it\'s easiest to think of them that way)Suppose the Dog object resides at memory address 42. This means we pass 42 to the method.if the Method were defined aslet\'s look at what\'s happening.Now let\'s think about what happens outside the method:Did myDog change?There\'s the key.Keeping in mind that myDog is a pointer, and not an actual Dog, the answer is NO. myDog still has the value 42; it\'s still pointing to the original Dog (but note that because of line "AAA", its name is now "Max" - still the same Dog; myDog\'s value has not changed.)It\'s perfectly valid to follow an address and change what\'s at the end of it; that does not change the variable, however.Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.If Java had pass-by-reference semantics, the foo method we defined above would have changed where myDog was pointing when it assigned someDog on line BBB.Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.Java always passes arguments by value NOT by reference.Let me explain this through an example:\nI will explain this in steps:Declaring a reference named f of type Foo and assign it to a new object of type Foo with an attribute "f".From the method side, a reference of type Foo with a name a is declared and it\'s initially assigned to null.As you call the method changeReference, the reference a will be assigned to the object which is passed as an argument.Declaring a reference named b of type Foo and assign it to a new object of type Foo with an attribute "b".a = b is re-assigning the reference a NOT f to the object whose its attribute is "b".As you call modifyReference(Foo c) method, a reference c is created and assigned to the object with attribute "f".c.setAttribute("c"); will change the attribute of the object that reference c points to it, and it\'s same object that reference f points to it.I hope you understand now how passing objects as arguments works in Java :)This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you\'ll just smile :-)Step one please erase from your mind that word that starts with \'p\' "_ _ _ _ _ _ _", especially if you come from other programming languages. Java and \'p\' cannot be written in the same book, forum, or even txt.Step two remember that when you pass an Object into a method you\'re passing the Object reference and not the Object itself.Now think of what an Object\'s reference/variable does/is:In the following (please don\'t try to compile/execute this...):What happens?A picture is worth a thousand words:Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!If you didn\'t get it then just trust me and remember that it\'s better to say that Java is pass by value. Well, pass by reference value. Oh well, even better is pass-by-copy-of-the-variable-value! ;)Now feel free to hate me but note that given this there is no difference between passing primitive data types and Objects when talking about method arguments.You always pass a copy of the bits of the value of the reference!Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you\'ll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.Of course you can cut it short and just say that  Java is pass-by-value!Java is always pass by value, with no exceptions, ever.So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java never provides direct access to the values of objects themselves, in any circumstances. The only access to objects is through a reference to that object. Because Java objects are always accessed through a reference, rather than directly, it is common to talk about fields and variables and method arguments as being objects, when pedantically they are only references to objects. The confusion stems from this (strictly speaking, incorrect) change in nomenclature.So, when calling a methodSo if you have doSomething(foo) and public void doSomething(Foo foo) { .. } the two Foos have copied references that point to the same objects.Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.Java passes references by value.So you can\'t change the reference that gets passed in.Just to show the contrast, compare the following C++ and Java snippets:In C++: Note: Bad code - memory leaks!  But it demonstrates the point.In Java, Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.I feel like arguing about "pass-by-reference vs pass-by-value" is not super-helpful.If you say, "Java is pass by whatever (reference/value)", but in either case you\'re not provide a complete answer. Here\'s some additional information that will hopefully aid in understanding what\'s happening in memory.Crash course on stack/heap before we get to the Java implementation:\nValues go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.\nMemory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.Okay. First off, local primitives go on the stack. So this code:results in this:When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are racist against the word "pointer". Whatever. Just know that the address of the object goes in the stack.Like so:An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.So, what gets passed in when you call a method? If you pass in an object, what you\'re actually passing in is the address of the object. Some might say the "value" of the address, and some say it\'s just a reference to the object. This is the genesis of the holy war between "reference" and "value" proponents. What you call it isn\'t as important as that you understand that what\'s getting passed in is the address to the object.One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier hisName, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call shout(): a new stack frame is created and a new identifier, name is created and assigned the address of the already-existing String.So, value, reference? You say "potato".Java passes references to objects by value.I can\'t believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term call by sharing (also known as call by object-sharing and call by object) for this specific case of "call by value where the value is a reference".Basically, reassigning Object parameters doesn\'t affect the argument, e.g.,will print out "Hah!" instead of NULL. The reason this works is because bar is a copy of the value of baz, which is just a reference to "Hah!". If it were the actual reference itself, then foo would have redefined baz to null.In java everything is reference, so when you have something like:\n    Point pnt1 = new Point(0,0); Java does following:Java doesn\'t pass method arguments by reference; it passes them by value. I will use example from this site: Flow of the program:Creating two different Point object with two different reference associated.\nAs expected output will be:On this line \'pass-by-value\' goes into the play... References pnt1 and pnt2 are passed by value to the tricky method, which means that now yours references pnt1 and pnt2 have their copies named arg1 and arg2.So pnt1 and arg1 points to the same object. (Same for the pnt2 and arg2)\nIn the tricky method:Next in the tricky methodHere, you first create new temp Point reference which will point on same place like arg1 reference. Then you move reference arg1 to point to the same place like arg2 reference.\nFinally arg2 will point to the same place like temp.From here scope of tricky method is gone and you don\'t have access any more to the references: arg1, arg2, temp. But important note is that everything you do with these references when they are \'in life\' will permanently affect object on which they are point to. So after executing method tricky, when you return to main, you have this situation:\nSo now, completely execution of program will be:The crux of the matter is that the word reference in the expression "pass by reference" means something completely different from the usual mening of the word reference in Java. Usually in Java reference means a a reference to an object. But the technical terms pass by reference/value from programming language theory is talking about a reference to the memory cell holding the variable, which is someting completely different.Getting an outside of the box view, let\'s look at Assembly or some low level memory management. At the CPU level a reference to anything immediately becomes a value if it gets written to memory or to one of the CPU registers. (That is why pointer is a good definition. It is a value, which has a purpose at the same time).Data in memory has a Location and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a Name to certain Location (aka variable), but when compiling the code, the assembler simply replaces Name with the designated location just like your browser replaces domain names with IP addresses.Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).Lets say we have a variable Foo, its Location is at the 47th byte in memory and its Value is 5. We have another variable Ref2Foo which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two Values.\nIf you use them as references then to reach to 5 we have to travel:This is how jump-tables work. If we want to call a method/function/procedure with Foo\'s value, there are a few possible way to pass the variable to the method, depending on the language and its several method invocation modes:In every cases above a value - a copy of an existing value - has been created, it is now upto the receiving method to handle it. When you write "Foo" inside the method, it is either read out from EAX, or automatically  dereferenced, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a reference is a value when represented, because a reference is a value that has to be processed (at language level).Now we have passed Foo to the method:Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only pass-by-reference.Strict pass-by-value is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller\'s view) and a few languages allows to modify the Value of the reference itself.So in short and in Java\'s own terminology, Java is pass-by-value where value can be: either a real value or a value that is a representation of a reference. No, it\'s not pass by reference.Java is pass by value according to the Java Language Specification:When the method or constructor is invoked (\xc2\xa715.12), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the formal parameter. As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:However you could make a wrapper for String like this which would make it able to use it with Strings:edit: i believe this is also the reason to use StringBuffer when it comes to "adding" two Strings because you can modifie the original object which u can\'t with immutable objects like String is.Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference/**Pass By ValueIn Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.*/Example 1:ResultExample 2:/**\n * \n * Pass By Value\n *\n */ResultExample 3:/**\n  This \'Pass By Value has a feeling of \'Pass By Reference\'Some people say primitive types and \'String\' are \'pass by value\'\n  and objects are \'pass by reference\'.But from this example, we can understand that it is infact pass by value only,\n  keeping in mind that here we are passing the reference as the value.\n  ie: reference is passed by value.\n  That\'s why are able to change and still it holds true after the local scope.\n  But we cannot change the actual reference outside the original scope.\n  what that means is demonstrated by next example of PassByValueObjectCase2.*/ResultExample 4:/**In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope."Note: I am not pasting the code for private class Student. The class definition for Student is same as Example3.*/ResultYou can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:Sometimes you want to use the same pattern in Java, but you can\'t; at least not directly. Instead you could do something like this:As was explained in previous answers, in Java you\'re passing a pointer to the array as a value into getValues. That is enough, because the method then modifies the array element, and by convention you\'re expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn\'t necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.I thought I\'d contribute this answer to add more details from the Specifications.First, What's the difference between passing by reference vs. passing by value?Passing by reference means the called functions\' parameter will be the\n  same as the callers\' passed argument (not the value, but the identity\n  - the variable itself). Pass by value means the called functions\' parameter will be a copy of\n  the callers\' passed argument.Or from wikipedia, on the subject of pass-by-referenceIn call-by-reference evaluation (also referred to as\n  pass-by-reference), a function receives an implicit reference to a\n  variable used as argument, rather than a copy of its value. This\n  typically means that the function can modify (i.e. assign to) the\n  variable used as argument\xe2\x80\x94something that will be seen by its caller.And on the subject of pass-by-valueIn call-by-value, the argument expression is evaluated, and the\n  resulting value is bound to the corresponding variable in the function [...]. \n  If the function or procedure is able to assign values to its\n  parameters, only its local copy is assigned [...].Second, we need to know what Java uses in its method invocations. The Java Language Specification statesWhen the method or constructor is invoked (\xc2\xa715.12), the values of the\n  actual argument expressions initialize newly created parameter\n  variables, each of the declared type, before execution of the body of\n  the method or constructor.So it assigns (or binds) the value of the argument to the corresponding parameter variable. What is the value of the argument?Let\'s consider reference types, the Java Virtual Machine Specification statesThere are three kinds of reference types: class types, array types,\n  and interface types. Their values are references to dynamically\n  created class instances, arrays, or class instances or arrays that\n  implement interfaces, respectively.The Java Language Specification also statesThe reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (new ...) all resolve to a reference type value.Soall bind the value of a reference to a String instance to the method\'s newly created parameter, param. This is exactly what the definition of pass-by-value describes. As such, Java is pass-by-value.The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation. The definition of pass-by-reference wasThis typically means that the function can modify (i.e. assign to) the\n  variable used as argument\xe2\x80\x94something that will be seen by its caller.In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. Modifying the object referenced by the variable is a different concept entirely. Primitive values are also defined in the Java Virtual Machine Specification, here. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.Java is always pass by values NOT pass by reference first of we understand what is pass by value and pass by referencepass by value means you are making a copy in memory of the actual parameter\'s value that is passed in, a copy of the contents of the actual parameterpass by reference (also called pass by address), a copy of the address of the actual parameter is storedSome time it gives illusion pass by reference.lets see how it works by exampleOutput of this program is changevaluelets understand step by steptest t=new test();as we all know it will create object in heap and return return reference value back to t. suppose for example value of t is 0x100234(its JVM internal value as we don\'t about it i have just consider it for example) new Passbyvalue().changeValue(t);when passing reference t to function it will not directly pass actual reference value of object test but it will create copy of t and then it pass to function ( as it pass by value it passes copy of variable not actual reference of it) . As we consider value of t will be0x100234 . so in this way both t and f will have same value and hence they will point to same objectso if you change any thing in function using reference f it will modify existing contain of object that why we were getting output "changevalue" which is updated in functionto understand this more clearly consider following examplewill it give null pointer no because it passes only copy of reference .In case of by reference it could have given nullpointer exception Hopefully this will help As many people mentioned it before, Java is always pass-by-valueHere is another example that will help you understand the difference (the classic swap example):Prints:  Before: a = 2, b = 3\n  After: a = 2, b = 3This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.I always think of it as "pass by copy". It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.output of java PassByCopy:name= Maxx\n  name= FidoPrimitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.Java is a call by value .How it works  .You always pass a copy of the bits of the value of the reference!If it\'s a primitive data type these bits contain the value of the primitive data type itself , That\'s why if we change the value of header inside the method then it\'s not reflect the changes outside.If it\'s a object data type like Foo foo=new Foo() then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file abc.txt at C:\\desktop and suppose we make shortcut of same file and put this inside C:\\desktop\\abc-shortcut so when you access the file from C:\\desktop\\abc.txt and write \'Stack Overflow\' and close the file and again you open the file from shortcut then you write \' is the largest online community for programmers to learn\' then total file change will be \'Stack Overflow is the largest online community for programmers to learn\' which means it does\'t matters from where you open the file , each time we were accessing the same file , here we can assume Foo as a file and suppose foo stored at 123hd7h(original address like C:\\desktop\\abc.txt ) address and 234jdid(copied address like C:\\desktop\\abc-shortcut which actually contains the original address of the file inside) ..\nSo for better understanding make shortcut file and feel.To get more info look at this :-\nhttp://easybook4u.com/index.php/2017/06/18/is-java-pass-by-reference-or-pass-by-valueI have created a thread devoted to these kind of questions for any programming languages here.Java is also mentioned. Here is the short summary:To make a long story short, Java objects have some very peculiar properties.In general, Java has primitive types (int, bool, char, double, etc) that are passed directly by value. Then Java has objects (everything that derives from java.lang.Object). Objects are actually always handled through a reference (a reference being a pointer that you can\'t touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.Does this sound strange and confusing? Let\'s consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. void foo(int x) passes an int by value. void foo(int *x) is a function that does not want an int a, but a pointer to an int: foo(&a). One would use this with the & operator to pass a variable address.Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: void foo(int &x) is called by foo(a), where the compiler itself knows that it is a reference and the address of the non-reference a should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.A few corrections to some posts.C does NOT support pass by reference. It is ALWAYS pass by value. C++ does support pass by reference, but is not the default and is quite dangerous.It doesn\'t matter what the value is in Java: primitive or address(roughly) of object, it is ALWAYS passed by value.If a Java object "behaves" like it is being passed by reference, that is a property of mutability and has absolutely nothing to do with passing mechanisms.I am not sure why this is so confusing, perhaps because so many Java "programmers" are not formally trained, and thus do not understand what is really going on in memory?In Java only references are passed and are passed by value:Java arguments are all passed by value (the variable is copied when used by the method) :In the case of primitive types, Java behaviour is simple: \nThe value is copied in another instance of the primitive type.In case of Objects, this is the same: \nObject variables are pointers (buckets) holding only Object\xe2\x80\x99s address that was created using the "new" keyword, and are copied like primitive types.The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object)\nObject\'s content/members might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference. "String" Objects appear to be a perfect counter-example to the urban legend saying that "Objects are passed by reference":In effect, within a method you will never be able, to update the value of a String passed as argument:A String Object, holds characters by an array declared final that can\'t be modified.\nOnly the address of the Object might be replaced by another using "new". \nUsing "new" to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.It\'s really quite, quite simple:For a variable of primitive type (eg. int, boolean, char, etc...), when you use its name for a method argument, you are passing the value contained in it (5, true, or \'c\'). This value gets "copied", and the variable retains its value even after the method invocation.For a variable of reference type (eg. String, Object, etc...), when you use its name for a method argument, you are passing the value contained in it (the reference value that "points" to the object). This reference value gets "copied", and the variable retains its value even after the method invocation. The reference variable keeps "pointing" to the same object.Either way, you\'re always passing stuff by value.Compare this to say C++ where you can have a method to take an int&, or in C# where you could have take a ref int (although, in this case, you also have to use the ref modifier when passing the variable\'s name to the method.)Java is pass by constant reference where a copy of the reference is passed which means that it is basically a pass by value. You might change the contents of the reference if the class is mutable but you cannot change the reference itself. In other words the address can not be changed since it is passed by value but the content that is pointed by the address can be changed. In case of immutable classes, the content of the reference cannot be changed either.