In the following method definitions, what does the * and ** do for param2?The *args and **kwargs is a common idiom to allow arbitrary number of arguments to functions as described in the section more on defining functions in the Python documentation.The *args will give you all function parameters as a tuple:The **kwargs will give you all \nkeyword arguments except for those corresponding to a formal parameter as a dictionary.Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:Another usage of the *l idiom is to unpack argument lists when calling a function.In Python 3 it is possible to use *l on the left side of an assignment (Extended Iterable Unpacking), though it gives a list instead of a tuple in this context:Also Python 3 adds new semantic (refer PEP 3102):Such function accepts only 3 positional arguments, and everything after * can only be passed as keyword arguments.It\'s also worth noting that you can use * and ** when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:You can do things like:Note: The keys in mydict have to be named exactly like the parameters of function foo. Otherwise it will throw a TypeError.The single * means that there can be any number of extra positional arguments. foo() can be invoked like foo(1,2,3,4,5). In the body of foo() param2 is a sequence containing 2-5.The double ** means there can be any number of extra named parameters. bar() can be invoked like bar(1, a=2, b=3). In the body of bar() param2 is a dictionary containing {\'a\':2, \'b\':3 }With the following code:the output isThey allow for functions to be defined to accept and for users to pass any number of arguments, positional (*) and keyword (**).*args allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named args. **kwargs allows for any number of optional keyword arguments (parameters), which will be in a dict named kwargs.You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, args and kwargs are standard names.You can also use *args and **kwargs to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively.The function recieving the parameters does not have to know that they are being expanded. For example, Python 2\'s xrange does not explicitly expect *args, but since it takes 3 integers as arguments:As another example, we can use dict expansion in str.format:You can have keyword only arguments after the *args - for example, here, kwarg2 must be given as a keyword argument - not positionally:Usage:Also, * can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments.Here, kwarg2 again must be an explicitly named, keyword argument:And we can no longer accept unlimited positional arguments because we don\'t have *args*:Again, more simply, here we require kwarg to be given by name, not positionally:In this example, we see that if we try to pass kwarg positionally, we get an error:We must explicitly pass the kwarg parameter as a keyword argument.*args (typically said "star-args") and **kwargs (stars can be implied by saying "kwargs", but be explicit with "double-star kwargs") are common idioms of Python for using the * and ** notation. These specific variable names aren\'t required (e.g. you could use *foos and **bars), but a departure from convention is likely to enrage your fellow Python coders. We typically use these when we don\'t know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit).Example 1The following function describes how they can be used, and demonstrates behavior. Note the named b argument will be consumed by the second positional argument before :We can check the online help for the function\'s signature, with help(foo), which tells us Let\'s call this function with foo(1, 2, 3, 4, e=5, f=6, g=7) which prints:Example 2We can also call it using another function, into which we just provide a:bar(100) prints:Example 3: practical usage in decoratorsOK, so maybe we\'re not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes.We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how *args and **kwargs can be very useful:And now every wrapped function can be written much more succinctly, as we\'ve factored out the redundancy:And by factoring out our code, which *args and **kwargs allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change.Let us first understand what are positional arguments and keyword arguments.\nBelow is an example of function definition with Positional arguments.So this is a function definition with positional arguments.\nYou can call it with keyword/named arguments as well:Now let us study an example of function definition with keyword arguments:You can call this function with positional arguments as well:So we now know function definitions with positional as well as keyword arguments.Now let us study the \'*\' operator and \'**\' operator.Please note these operators can be used in 2 areas:a) function callb) function definitionThe use of \'*\' operator and \'**\' operator in function call. Let us get straight to an example and then discuss it.So remember when the \'*\' or \'**\' operator is used in a function call -\'*\' operator unpacks data structure such as a list or tuple  into arguments needed by function definition.\'**\' operator unpacks a dictionary into arguments needed by function definition.Now let us study the \'*\' operator use in function definition.\nExample:In function definition the \'*\' operator packs the received arguments into a tuple.Now let us see an example of \'**\' used in function definition:In function definition The \'**\' operator packs the received arguments into a dictionary.So remember:In a function call the \'*\' unpacks data structure of tuple or list into positional or keyword arguments to be received by function definition.In a function call the \'**\' unpacks data structure of dictionary into positional or keyword arguments to be received by function definition.In a function definition the \'*\' packs positional arguments into a tuple.In a function definition the \'**\' packs keyword arguments into a dictionary.* and ** have special usage in the function argument list. *\nimplies that the argument is a list and ** implies that the argument\nis a dictionary. This allows functions to take arbitrary number of\nargumentsFrom the Python documentation:If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax "*identifier" is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments). If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax "**identifier" is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. In Python 3.5, you can also use this syntax in list, dict, tuple, and set displays (also sometimes called literals). See PEP 488: Additional Unpacking Generalizations.It also allows multiple iterables to be unpacked in a single function call.(Thanks to mgilson for the PEP link.)In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write init method in Python. Similar usage is seen in frameworks like Django code.For example,A subclass can then beThe subclass then be called as Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class init to offload the attributes setting.\nThis is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example,which can be instatiated asThe complete code is hereI want to give an example which others haven\'t  mentioned* can also unpack a generatorAn example from Python3 Documentunzip_x will be [1, 2, 3], unzip_y will be [4, 5, 6]The zip() receives multiple iretable args, and return a generator. A good example of using both in a function is:This example would help you remember *args, **kwargs and even super and inheritance in Python at once.