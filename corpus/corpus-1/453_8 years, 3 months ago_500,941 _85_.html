I\'m developing a new RESTful webservice for our application.When doing a GET on certain entities, clients can request the contents of the entity.\nIf they want to add some parameters (for example sorting a list) they can add these parameters in the query string.Alternatively I want people to be able to specify these parameters in the request body. \nHTTP/1.1 does not seem to explicitly forbid this. This will allow them to specify more information, might make it easier to specify complex xml requests.My questions:http://tools.ietf.org/html/rfc2616Roy Fielding\'s comment about including a body with a GET request.  Yes. In other words, any HTTP request message is allowed to contain\n  a message body, and thus must parse messages with that in mind.\n  Server semantics for GET, however, are restricted such that a body,\n  if any, has no semantic meaning to the request. The requirements\n  on parsing are separate from the requirements on method semantics.So, yes, you can send a body with GET, and no, it is never useful\n  to do so.This is part of the layered design of HTTP/1.1 that will become\n  clear again once the spec is partitioned (work in progress).....RoyYes, you can send a request body with GET but it should not have any meaning. If you give it meaning by parsing it on the server and changing your response based on its contents, then you are ignoring this recommendation in the HTTP/1.1 spec, section 4.3:[...] if the request method\n     does not include defined semantics for an entity-body, then the\n     message-body SHOULD be ignored when handling the request.And the description of the GET method in the HTTP/1.1 spec, section 9.3:The GET method means retrieve whatever information ([...]) is identified by the Request-URI.which states that the request-body is not part of the identification of the resource in a GET request, only the request URI.While you can do that, insofar as it isn\'t explicitly precluded by the HTTP specification, I would suggest avoiding it simply because people don\'t expect things to work that way.  There are many phases in an HTTP request chain and while they "mostly" conform to the HTTP spec, the only thing you\'re assured is that they will behave as traditionally used by web browsers.  (I\'m thinking of things like transparent proxies, accelerators, A/V toolkits, etc.)This is the spirit behind the Robustness Principle roughly "be liberal in what you accept, and conservative in what you send", you don\'t want to push the boundaries of a specification without good reason.  However, if you have a good reason, go for it.You will likely encounter problems if you ever try to take advantage of caching.  Proxies are not going to look in the GET body to see if the parameters have an impact on the response.  Neither restclient nor REST console support this but curl does.The HTTP specification says in section 4.3A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.Section 5.1.1 redirects us to section 9.x for the various methods. None of them explicitly prohibit the inclusion of a message body. However...Section 5.2 says The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.and Section 9.3 saysThe GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.Which together suggest that when processing a GET request, a server is not required to examine anything other that the Request-URI and Host header field.In summary, the HTTP spec doesn\'t prevent you from sending a message-body with GET but there is sufficient ambiguity that it wouldn\'t surprise me if it was not supported by all servers. Elasticsearch accepts GET requests with a body. It even seems that this is the preferred way : http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/common-options.html#_request_body_in_query_stringSome client libraries (like the Ruby driver) can log the cry command to stdout in development mode and it is using this syntax extensively.Which server will ignore it? \xe2\x80\x93 fijiaaron Aug 30 \'12 at 21:27Google for instance is doing worse than ignoring it, it will consider it an error!Try it yourself with a simple netcat:(the 1234 content is followed by CR-LF, so that is a total of 6 bytes)and you will get:You do also get 400 Bad Request from Bing, Apple, etc... which are served by AkamaiGhost.So I wouldn\'t advise using GET requests with a body entity.You can either send a GET with a body or send a POST and give up RESTish religiosity (it\'s not so bad, 5 years ago there was only one member of that faith -- his comments linked above).Neither are great decisions, but sending a GET body may prevent problems for some clients -- and some servers.  Doing a POST might have obstacles with some RESTish frameworks. Julian Reschke suggested above using a non-standard HTTP header like "SEARCH" which could be an elegant solution, except that it\'s even less likely to be supported.It might be most productive to list clients that can and cannot do each of the above.Clients that cannot send a GET with body (that I know of):Clients that can send a GET with body:Servers & libraries that can retrieve a body from GET:Servers (and proxies) that strip a body from GET:What you\'re trying to achieve has been done for a long time with a much more common method, and one that doesn\'t rely on using a payload with GET.You can simply build your specific search mediatype, or if you want to be more RESTful, use something like OpenSearch, and POST the request to the URI the server instructed, say /search. The server can then generate the search result or build the final URI and redirect using a 303.This has the advantage of following the traditional PRG method, helps cache intermediaries cache the results, etc.That said, URIs are encoded anyway for anything that is not ASCII, and so are application/x-www-form-urlencoded and multipart/form-data. I\'d recommend using this rather than creating yet another custom json format if your intention is to support ReSTful scenarios.From RFC 2616, section 4.3, "Message Body":A server SHOULD read and forward a message-body on any request; if the\n  request method does not include defined semantics for an entity-body,\n  then the message-body SHOULD be ignored when handling the request.That is, servers should always read any provided request body from the network (check Content-Length or read a chunked body, etc). Also, proxies should forward any such request body they receive. Then, if the RFC defines semantics for the body for the given method, the server can actually use the request body in generating a response. However, if the RFC does not define semantics for the body, then the server should ignore it.This is in line with the quote from Fielding above.Section 9.3, "GET", describes the semantics of the GET method, and doesn\'t mention request bodies. Therefore, a server should ignore any request body it receives on a GET request.I put this question to the IETF HTTP WG.  The comment from Roy Fielding (author of http/1.1 document in 1998) was that"... an implementation would be broken to do anything other than to parse and discard that body if received"RFC 7213 (HTTPbis) states "A payload within a GET request message has no defined semantics;"It seems clear now that the intention was that semantic meaning on GET request bodies is prohibited, which means that the request body can\'t be used to affect the result.There are proxies out there that will definitely break your request in various ways if you include a body on GET.So in summary, don\'t do it.If you really want to send cachable JSON/XML body to web application the only reasonable place to put your data is query string encoded with RFC4648: Base 64 Encoding with URL and Filename Safe Alphabet. Of course you could just urlencode JSON and put is in URL param\'s value, but Base64 gives smaller result. Keep in mind that there are URL size restrictions, see What is the maximum length of a URL in different browsers? .You may think that Base64\'s padding = character may be bad for URL\'s param value, however it seems not - see this discussion: http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html . However you shouldn\'t put encoded data without param name because encoded string with padding will be interpreted as param key with empty value.\nI would use something like ?_b64=<encodeddata>.I wouldn\'t advise this, it goes against standard practices, and doesn\'t offer that much in return. You want to keep the body for content, not options.I\'m upset that REST as protocol doesn\'t support OOP and Get method is proof. As a solution, you can serialize your a DTO to JSON and then create a query string. On server side you\'ll able to deserialize the query string to the DTO.Take a look on:Message based approach can help you to solve Get method restriction. You\'ll able to send any DTO as with request bodyNelibur web service framework provides functionality which you can useIMHO you could just send the JSON encoded (ie. encodeURIComponent) in the URL, this way you do not violate the HTTP specs and get your JSON to the server.For example, it works with Curl, Apache and PHP.PHP file:Console command:Output:What about nonconforming base64 encoded headers? "SOMETHINGAPP-PARAMS:sdfSD45fdg45/aS"Length restrictions hm. Can\'t you make your POST handling distinguish between the meanings? If you want simple parameters like sorting, I don\'t see why this would be a problem. I guess it\'s certainty you\'re worried about.According to XMLHttpRequest, it\'s not valid. From the standard:Initiates the request. The optional argument provides the request\n    body. The argument is ignored if request method is GET or HEAD.Throws an InvalidStateError exception if either state is not\n    opened or the send() flag is set.The send(body) method must run these steps:Although, I don\'t think it should because GET request might need big body content.So, if you rely on XMLHttpRequest of a browser, it\'s likely it won\'t work.Google, IBM, Microsoft and apigee seem to use header to designate truly expected method, something like X-HTTP-Method-Override: GET.\nAccording to the blog above, originally, this is introduced for POST as PUT in form.\nI think this solution can be used in this problem.In other words, I think POST with X-HTTP-Method-Override: GET header is better solution.