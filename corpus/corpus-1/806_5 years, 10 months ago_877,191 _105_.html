When running my script, I am getting several errors like this:Warning: Cannot modify header information - headers already sent by (output started at /some/file.php:12) in /some/file.php on line 23The lines mentioned in the error messages contain header() and setcookie() calls.What could be the reason for this? And how to fix it?Functions that send/modify HTTP headers must be invoked before any output is made.\nsummary \xe2\x87\x8a\nOtherwise the call fails:Warning: Cannot modify header information - headers already sent (output started at script:line)Some functions modifying the HTTP header are:Output can be:Unintentional:Intentional:To understand why headers must be sent before output it\'s necessary\nto look at a typical HTTP\nresponse. PHP scripts mainly generate HTML content, but also pass a\nset of HTTP/CGI headers to the webserver:The page/output always follows the headers. PHP has to pass the\nheaders to the webserver first. It can only do that once.\nAfter the double linebreak it can nevermore amend them.When PHP receives the first output (print, echo, <html>) it will\nflush all collected headers. Afterwards it can send all the output\nit wants. But sending further HTTP headers is impossible then.The header() warning contains all relevant information to\nlocate the problem cause:Warning: Cannot modify header information - headers already sent by\n  (output started at /www/usr2345/htdocs/auth.php:52) in\n  /www/usr2345/htdocs/index.php on line 100Here "line 100" refers to the script where the header() invocation failed.The "output started at" note within the parenthesis is more significant.\nIt denominates the source of previous output. In this example it\'s auth.php\nand line 52. That\'s where you had to look for premature output.Typical causes:Intentional output from print and echo statements will terminate\nthe opportunity to send HTTP headers. The application flow must\nbe restructured to avoid that. Use functions\nand templating schemes. Ensure header() calls occur before messages\nare written out.Functions that produce output include among others and user-defined functions.Unparsed HTML sections in a .php file are direct output as well.\nScript conditions that will trigger a header() call must be noted\nbefore any raw <html> blocks.Use a templating scheme to separate processing from output logic.If the warning refers to output in line 1, then it\'s mostly\nleading whitespace, text or HTML before the opening <?php token.Similarly it can occur for appended scripts or script sections:PHP actually eats up a single linebreak after close tags. But it won\'t\ncompensate multiple newlines or tabs or spaces shifted into such gaps.Linebreaks and spaces alone can be a problem. But there are also "invisible"\ncharacter sequences which can cause this. Most famously the\nUTF-8 BOM (Byte-Order-Mark)\nwhich isn\'t displayed by most text editors. It\'s the byte sequence EF BB BF, which\nis optional and redundant for UTF-8 encoded documents. PHP however has to treat\nit as raw output. It may show up as the characters \xc3\xaf\xc2\xbb\xc2\xbf in the output (if the client\ninterprets the document as Latin-1) or similar "garbage".In particular graphical editors and Java based IDEs are oblivious to its\npresence. They don\'t visualize it (obliged by the Unicode standard).\nMost programmer and console editors however do:There it\'s easy to recognize the problem early on. Other editors may identify\nits presence in a file/settings menu (Notepad++ on Windows can identify and\nremedy the problem),\nAnother option to inspect the BOMs presence is resorting to an hexeditor.\nOn *nix systems hexdump is usually available,\nif not a graphical variant which simplifies auditing these and other issues:An easy fix is to set the text editor to save files as "UTF-8 (no BOM)"\nor similar such nomenclature. Often newcomers otherwise resort to creating new\nfiles and just copy&pasting the previous code back in.There are also automated tools to examine and rewrite text files\n(sed/awk or recode).\nFor PHP specifically there\'s the phptags tag tidier.\nIt rewrites close and open tags into long and short forms, but also easily\nfixes leading and trailing whitespace, Unicode and UTF-x BOM issues:It\'s sane to use on a whole include or project directory.If the error source is mentioned as behind the\nclosing ?>\nthen this is where some whitespace or raw text got written out.\nThe PHP end marker does not terminate script executation at this\npoint. Any text/space characters after it will be written out as page content\nstill.It\'s commonly advised, in particular to newcomers, that trailing ?> PHP\nclose tags should be omitted. This eschews a small portion of these cases.\n(Quite commonly include()d scripts are the culprit.)It\'s typically a PHP extension or php.ini setting if no error source\nis concretized.If another PHP statement or expression causes a warning message or\nnotice being printeded out, that also counts as premature output.In this case you need to eschew the error,\ndelay the statement execution, or suppress the message with e.g.\nisset() or @() -\nwhen either doesn\'t obstruct debugging later on.If you have error_reporting or display_errors disabled per php.ini,\nthen no warning will show up. But ignoring errors won\'t make the problem go\naway. Headers still can\'t be sent after premature output.So when header("Location: ...") redirects silently fail it\'s very\nadvisable to probe for warnings. Reenable them with two simple commands\natop the invocation script:Or set_error_handler("var_dump"); if all else fails.Speaking of redirect headers, you should often use an idiom like\nthis for final code paths:Preferrably even a utility function, which prints a user message\nin case of header() failures.PHPs output buffering\nis a workaround to alleviate this issue. It often works reliably, but shouldn\'t\nsubstitute for proper application structuring and separating output from control\nlogic. Its actual purpose is minimizing chunked transfers to the webserver.The output_buffering=\nsetting nevertheless can help.\nConfigure it in the php.ini\nor via .htaccess\nor even .user.ini on\nmodern FPM/FastCGI setups.\nEnabling it will allow PHP to buffer output instead of passing it to the webserver\ninstantly. PHP thus can aggregate HTTP headers.It can likewise be engaged with a call to ob_start();\natop the invocation script. Which however is less reliable for multiple reasons:Even if <?php ob_start(); ?> starts the first script, whitespace or a\nBOM might get shuffled before, rendering it ineffective.It can conceal whitespace for HTML output. But as soon as the application\nlogic attempts to send binary content (a generated image for example),\nthe buffered extraneous output becomes a problem. (Necessitating ob_clean()\nas furher workaround.)The buffer is limited in size, and can easily overrun when left to defaults.\nAnd that\'s not a rare occurence either, difficult to track down\nwhen it happens.Both approaches therefore may become unreliable - in particular when switching between\ndevelopment setups and/or production servers. Which is why output buffering is\nwidely considered just a crutch / strictly a workaround.See also the basic usage example\nin the manual, and for more pros and cons:If you didn\'t get the headers warning before, then the output buffering\n php.ini setting\n has changed. It\'s likely unconfigured on the current/new server.You can always use headers_sent() to probe if\nit\'s still possible to... send headers. Which is useful to conditionally print\nan info or apply other fallback logic.Useful fallback workarounds are:If your application is structurally hard to fix, then an easy (but\nsomewhat unprofessional) way to allow redirects is injecting a HTML\n<meta> tag. A redirect can be achieved with:Or with a short delay:This leads to non-valid HTML when utilized past the <head> section.\nMost browsers still accept it.As alternative a JavaScript redirect\ncan be used for page redirects:While this is often more HTML compliant than the <meta> workaround,\nit incurs a reliance on JavaScript-capable clients.Both approaches however make acceptable fallbacks when genuine HTTP header()\ncalls fail. Ideally you\'d always combine this with a user-friendly message and\nclickable link as last resort. (Which for instance is what the http_redirect()\nPECL extension does.)Both setcookie() and session_start() need to send a Set-Cookie: HTTP header.\nThe same conditions therefore apply, and similar error messages will be generated\nfor premature output situations.(Of course they\'re furthermore affected by disabled cookies in the browser,\nor even proxy issues. The session functionality obviously also depends on free\ndisk space and other php.ini settings, etc.)This error message gets triggered when anything is sent before you send HTTP headers (with setcookie or header). Common reasons for outputting something before the HTTP headers are:Accidental whitespace, often at the beginning or end of files, like this:       To avoid this, simply leave out the closing ?> - it\'s not required anyways.Turning on output buffering should make the problem go away; all output after the call to ob_start is buffered in memory until you release the buffer, e.g. with ob_end_flush.However, while output buffering avoids the issues, you should really determine why your application outputs an HTTP body before the HTTP header. That\'d be like taking a phone call and discussing your day and the weather before telling the caller that he\'s got the wrong number.I got this error many times before.and I am sure all PHP programmer at-least once got this error.\nTo solve this error you can solve use solution as per your problem level:Possible Solution 1:You may have left blank spaces before or after (at the end of file after ?> ) i.e.Most of the time this should solve your problem.Do check all files associated with file you require.Note: Sometimes EDITOR(IDE) like gedit(a default linux editor) add one blank line on save save file.This should not happen. If you are using linux. you can use VI editor to remove space/lines after ?> at the end of the page.If this is not your case then,then you can use ob_start for output buffering like below: Possible Solution 2:Instead of the below linewrite orIt\'ll definitely solve your problem.\nI faced the same problem but I solved through writing header location in the above way.You do before setting the cookies, which isn\'t allowed. You can\'t send any output before the headers, not even a blank line.It is because of this line:You should not print/echo anything before sending the headers.A simple tip: A simple space (or invisible special char) in your script, right before the very first <?php tag, can cause this !\nEspecially when you are working in a team and somebody is using a "weak" IDE or has messed around in the files with strange text editors.I have seen these things ;)Another bad practice can invoke this problem which is not stated yet.See this code snippet:Things are okay,right?What if "a_important_file.php" is this:This will not work? Why?Because already a new line is generated.Now,though this is not a common scenario what if you are using a MVC framework which loads a lots of file before handover things to your controller? This is not an uncommon scenario. Be prepare for this.From PSR-2 2.2 :Believe me , following thse standards can save you a hell lot of hours from your life :)Sometimes when the dev process has both WIN work stations and LINUX systems (hosting) and in the code you do not see any output before the related line, it could be the formatting of the file and the lack of Unix LF (linefeed) \n line ending. What we usually do in order to quickly fix this, is rename the file and on the LINUX system create a new file instead of the renamed one, and then copy the content into that. Many times this solve the issue as some of the files that were created in WIN once moved to the hosting cause this issue.This fix is an easy fix for sites we manage by FTP and sometimes can save our new team members some time.use ob_start();at the very top of your script, and ob_end_flush();at the bottom of your script.\nThis wil turn output buffering on and your headers will be created after the page is bufferd.Generally this error arise when we send header after echoing or printing. If this error arise on a specific page then make sure that page is not echoing anything before calling to start_session().Example of Unpredictable Error:One more example:Conclusion: Do not output any character before calling session_start() or header() functions not even a white-space or new-line