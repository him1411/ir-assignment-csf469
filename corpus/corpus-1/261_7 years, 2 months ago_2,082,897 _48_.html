I am a bit puzzled by the following code:What I don\'t understand is the key portion. How does Python recognize that it needs only to read the key from the dictionary? Is key a special word in Python? Or is it simply a variable?key is just a variable name.  will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:For Python 2.x:For Python 3.x:To test for yourself, change the word key to poop.For Python 3.x, iteritems() has been replaced with simply items(), which returns a set-like view backed by the dict, like iteritems() but even better. \nThis is also available in 2.7 as viewitems(). The operation items() will work for both 2 and 3, but in 2 it will return a list of the dictionary\'s (key, value) pairs, which will not reflect changes to the dict that happen after the items() call. If you want the 2.x behavior in 3.x, you can call list(d.items()).It\'s not that key is a special word, but that dictionaries implement the iterator protocol.  You could do this in your class, e.g. see this question for how to build class iterators.In the case of dictionaries, it\'s implemented at the C level.  The details are available in PEP 234.  In particular, the section titled "Dictionary Iterators":Dictionaries implement a tp_iter slot that returns an efficient\n  iterator that iterates over the keys of the dictionary. [...] This \n  means that we can writewhich is equivalent to, but much faster thanas long as the restriction on modifications to the dictionary\n  (either by the loop or by another thread) are not violated.Add methods to dictionaries that return different kinds of\n  iterators explicitly:This means that for x in dict is shorthand for for x in\n   dict.iterkeys().Iterating over a dict iterates through its keys in no particular order, as you can see here: Edit: (This is no longer the case in Python3.6, but note that it\'s not guaranteed behaviour yet)For your example, it is a better idea to use dict.items():This gives you a list of tuples. When you loop over them like this, each tuple is unpacked into k and v automatically:Using k and v as variable names when looping over a dict is quite common if the body of the loop is only a few lines. For more complicated loops it may be a  good idea to use more descriptive names:It\'s a good idea to get into the habit of using format strings:When you iterate through dictionaries using the for .. in ..-syntax, it always iterates over the keys (the values are accessible using dictionary[key]).To iterate over key-value pairs, use for k,v in s.iteritems(). key is simply a variable.You can do this:... or better,This is a very common looping idiom. in is an operator. For when to use for key in dict and when it must be for key in dict.keys() see David Goodger\'s Idiomatic Python article.You can use this:I have a use case where I have to iterate through the dict to get the key, value pair, also the index indicating where I am. This is how I do it:Note that the parentheses around the key, value is important, without the parentheses, you get an ValueError "not enough values to unpack".How does Python recognize that it needs only to read the key from the\n  dictionary? Is key a special word in Python? Or is it simply a\n  variable?It\'s not just for loops. The important word here is "iterating".A dictionary is a mapping of keys to values:Any time we iterate over it, we iterate over the keys. The variable name key is only intended to be descriptive - and it is quite apt for the purpose.This happens in a list comprehension:It happens when we pass the dictionary to list (or any other collection type object):The way Python iterates is, in a context where it needs to, it calls the __iter__ method of the object (in this case the dictionary) which returns an iterator (in this case, a keyiterator object):We shouldn\'t use these special methods ourselves, instead, use the respective builtin function to call it, iter:Iterators have a __next__ method - but we call it with the builtin function, next:When an iterator is exhausted, it raises StopIteration. This is how Python knows to exit a for loop, or a list comprehension, or a generator expression, or any other iterative context. Once an iterator raises StopIteration it will always raise it - if you want to iterate again, you need a new one.We\'ve seen dicts iterating in many contexts. What we\'ve seen is that any time we iterate over a dict, we get the keys. Back to the original example:If we change the variable name, we still get the keys. Let\'s try it:If we want to iterate over the values, we need to use the .values method of dicts, or for both together, .items:In the example given, it would be more efficient to iterate over the items like this:But for academic purposes, the question\'s example is just fine.To iterate over keys, it is slower but better to use my_dict.keys(). If you tried to do something like this:it would create a runtime error because you are changing the keys while the program is running. If you are absolutely set on reducing time, use the for key in my_dict way, but you have been warned ;). 