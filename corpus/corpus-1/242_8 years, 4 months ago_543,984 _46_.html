I want to merge two branches that have been separated for a while and wanted to know which files have been modified.Came across this link: http://linux.yyz.us/git-howto.html which was quite useful.The tools to compare branches I\'ve come across are:Was wondering if there\'s something like "git status master..branch" to only see those files that are different between the two branches.Without creating a new tool, I think this is the closest you can get to do that now (which of course will show repeats if a file was modified more than once):Was wondering if there\'s something I missed...TryThat should do what you need, if I understand you correctly.TryThis will give you more info about each change, while still using the same number of lines.You can also flip the branches to get an even clearer picture of the difference if you were to merge the other way: Also keep in mind that git has cheap and easy branching. If I think a merge could be problematic I create a branch for the merge. So if master has the changes I want to merge in and ba is my branch that needs the code from master I might do the following:End result is that I got to try out the merge on a throw-away branch before screwing with my branch. If I get my self tangled up I can just delete the ba-merge branch and start over.If anyone is trying to generate a diff file from two branches : Note that git makes it easy to just try out the merge and back away from any problems if you don\'t like the result. It might be easier than looking for potential problems in advance.There is also a GUI based method.You can use gitk. Run:Right click on a commit of a branch and select Mark this commit in the pop-up menu. Then there will be a changed files list in the right bottom panel and diff details in the left bottom panel.One more option, using meld in this case:This allows not only to see the differences between files, but also provides a easy way to point and click into a specific file.When working collaboratively, or on multiple features at once, it\'s common that the upstream or even your master contains work that is not included in your branch, and will incorrectly appear in basic diffs.If your Upstream may have moved, you should do this:Just using git diff master can include, or fail to include, relevant changes.If you are using IntelliJ IDEA, you can also compare any branch with your current working branch. See http://www.jetbrains.com/idea/webhelp/merging-deleting-and-comparing-branches.html#d288093e3827 for more info. This is available in the free edition as well.And if you are looking for changes only among certain file(s), then:branch1 is optional and your current branch (the branch you are on) will be considered by default if branch1 is not provided.\ne.g:Just additional info to JasonSmith\'s answer:I checked out my branch with this command:$ git clone -b branchName http://repository_urlHowever, suggested git diff command was failing:I investigated branches following this thread:I didn\'t have branch master locally, so I performed the comparison against remotes/origin/master instead:More info on remotes/origin/master in this thread.There are two branches lets sayBeing in branch A you can typethen this will give you a output of The important point about this is Text in green is inside present in Branch AText in red is present in Branch BThere are plenty of answers here, but I wanted to add something that I commonly use. IF you are in one of the branches that you would like to compare I typically do one of the following. For the sake of this answer we will say that we are in our secondary branch. Depending on what view you need at the time will depend on which you choose, but most of the time I\'m using the second option of the two. The first option may be handy if you are trying to revert back to an original copy -- either way, both get the job done!This will compare master to the branch that we are in (which is secondary) and the original code will be the added lines and the new code will be considered the removed linesORThis will also compare master to the branch that we are in (which is secondary) and the original code will be the old lines and the new code will be the new lines