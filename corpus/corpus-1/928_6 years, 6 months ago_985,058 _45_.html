This question already has an answer here:I\'m working in the android environment and have tried the following code, but it doesn\'t seem to be working.If I define as follows:it works. Is there something that I\'m missing?Use like this.Try thisWhat is happening is that stock_list.toArray() is creating an Object[] rather than a String[] and hence the typecast is failing1.The correct code would be:or evenFor more details, refer to the javadocs for the two overloads of List.toArray.(From a technical perspective, the reason for this API behaviour / design is that an implementation of the List<T>.toArray() method has no information of what the <T> is at runtime.  All it knows is that the raw element type is Object.  By contrast, in the other case, the array parameter gives the base type of the array.  (If the supplied array is big enough, it is used.  Otherwise a new array of the same type and a larger size will be allocated and returned as the result.)1 - In Java, an Object[] is not assignment compatible with a String[].  If it was, then you could do this:This is clearly nonsense, and that is why array types are not generally assignment compatible.An alternative in Java 8:I can see many answers showing how to solve problem, but only Stephen\'s answer is trying to explain why problem occurs so I will try to add something more on this subject. It is a story about possible reasons why Object[] toArray wasn\'t changed to T[] toArray where generics ware introduced to Java.In Java, generic type exists at compile-time only. At runtime information about generic type (like in your case <String>) is removed and replaced with Object type (take a look at type erasure). That is why at runtime toArray() have no idea about what precise type to use to create new array, so it uses Object as safest type, because each class extends Object so it can safely store instance of any class. Why? Take a look at this example (lets assume that class B extends A): Although such code will compile, at runtime we will see thrown ClassCastException because instance held by reference a is not actually of type B (or its subtypes). Why is this problem (why this exception needs to be cast)? One of the reasons is that B could have new methods/fields which A doesn\'t, so it is possible that someone will try to use these new members via b reference even if held instance doesn\'t have (doesn\'t support) them. In other words we could end up trying to use data which doesn\'t exist, which could lead to many problems. So to prevent such situation JVM throws exception, and stop further potentially dangerous code.You could ask now "So why aren\'t we stopped even earlier? Why code involving such casting is even compilable? Shouldn\'t compiler stop it?". Answer is: no because compiler can\'t know for sure what is the actual type of instance held by a reference, and there is a chance that it will hold instance of class B which will support interface of b reference. Take a look at this example:Now lets go back to your arrays. As you see in question, we can\'t cast instance of Object[] array to more precise type String[] likeHere problem is a little different. Now we are sure that String[] array will not have additional fields or methods because every array support only:So it is not arrays interface which is making it impossible. Problem is that Object[] array beside Strings can store any objects (for instance Integers) so it is possible that one beautiful day we will end up with trying to invoke method like strArray[i].substring(1,3) on instance of Integer which doesn\'t have such method. So to make sure that this situation will never happen, in Java array references can hold onlybut can\'t hold In other words something like this is OKYou could say that one way to resolve this problem is to find at runtime most common type between all list elements and create array of that type, but this wont work in situations where all elements of list will be of one type derived from generic one. Take a looknow most common type is B, not A so toArray() would return array of B class new B[]. Problem with this array is that while compiler would allow you to edit its content by adding new A() element to it, you would get ArrayStoreException because B[] array can hold only elements of class B or its subclass, to make sure that all elements will support interface of B, but instance of A may not have all methods/fields of B. So this solution is not perfect.Best solution to this problem is explicitly tell what type of array toArray() should be returned by passing this type as method argument like or The correct way to do this is:  I\'d like to add to the other great answers here and explain how you could have used the Javadocs to answer your question.The Javadoc for toArray() (no arguments) is here. As you can see, this method returns an Object[] and not String[] which is an array of the runtime type of your list:public Object[] toArray() Returns an array containing all of the\n  elements in this collection. If the collection makes any guarantees as\n  to what order its elements are returned by its iterator, this method\n  must return the elements in the same order. The returned array will be\n  "safe" in that no references to it are maintained by the collection.\n  (In other words, this method must allocate a new array even if the\n  collection is backed by an Array). The caller is thus free to modify\n  the returned array.Right below that method, though, is the Javadoc for toArray(T[] a). As you can see, this method returns a T[] where T is the type of the array you pass in. At first this seems like what you\'re looking for, but it\'s unclear exactly why you\'re passing in an array (are you adding to it, using it for just the type, etc). The documentation makes it clear that the purpose of the passed array is essentially to define the type of array to return (which is exactly your use case):  public <T> T[] toArray(T[] a)Returns an array containing all of the\n  elements in this collection; the runtime type of the returned array is\n  that of the specified array. If the collection fits in the specified\n  array, it is returned therein. Otherwise, a new array is allocated\n  with the runtime type of the specified array and the size of this\n  collection. If the collection fits in the specified array with room to\n  spare (i.e., the array has more elements than the collection), the\n  element in the array immediately following the end of the collection\n  is set to null. This is useful in determining the length of the\n  collection only if the caller knows that the collection does not\n  contain any null elements.)If this collection makes any guarantees as to what order its elements\n  are returned by its iterator, this method must return the elements in\n  the same order.This implementation checks if the array is large enough to contain the\n  collection; if not, it allocates a new array of the correct size and\n  type (using reflection). Then, it iterates over the collection,\n  storing each object reference in the next consecutive element of the\n  array, starting with element 0. If the array is larger than the\n  collection, a null is stored in the first location after the end of\n  the collection.Of course, an understanding of generics (as described in the other answers) is required to really understand the difference between these two methods. Nevertheless, if you first go to the Javadocs, you will usually find your answer and then see for yourself what else you need to learn (if you really do).  Also note that reading the Javadocs here helps you to understand what the structure of the array you pass in should be. Though it may not really practically matter, you should not pass in an empty array like this:  Because, from the doc, this implementation checks if the array is large enough to contain the collection; if not, it allocates a new array of the correct size and type (using reflection). There\'s no need for the extra overhead in creating a new array when you could easily pass in the size.  As is usually the case, the Javadocs provide you with a wealth of information and direction.  Hey wait a minute, what\'s reflection?