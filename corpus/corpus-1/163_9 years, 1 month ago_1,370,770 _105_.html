What\'s the cleanest, most effective way to validate decimal numbers in JavaScript?Bonus points for:Test cases:@Joel\'s answer is pretty close, but it will fail in the following cases:Some time ago I had to implement an IsNumeric function, to find out if a variable contained a numeric value, regardless of its type, it could be a String containing a numeric value (I had to consider also exponential notation, etc.), a Number object, virtually anything could be passed to that function, I couldn\'t make any type assumptions,  taking care of type coercion (eg. +true == 1; but true shouldn\'t be considered as "numeric").I think is worth sharing this set of +30 unit tests (old link) made to numerous function implementations, and also share the one that passes all my tests:P.S. isNaN & isFinite have a confusing behavior due to forced conversion to number. In ES6, Number.isNaN & Number.isFinite would fix these issues. Keep that in mind when using them. Update : \nHere\'s how jQuery does it now (2.2-stable) : Update :\nAngular 4.3 :Arrrgh!  Don\'t listen to the regular expression answers.  RegEx is icky for this, and I\'m not talking just performance.  It\'s so easy to make subtle, impossible to spot mistakes with your regular expression.  If you can\'t use isNaN(), this should work much better:Here\'s how it works:The (input - 0) expression forces JavaScript to do type coercion on your input value; it must first be interpreted as a number for the subtraction operation.  If that conversion to a number fails, the expression will result in NaN.  This numeric result is then compared to the original value you passed in.  Since the left hand side is now numeric, type coercion is again used.  Now that the input from both sides was coerced to the same type from the same original value, you would think they should always be the same (always true). However, there\'s a special rule that says NaN is never equal to NaN, and so a value that can\'t be converted to a number (and only values that cannot be converted to numbers) will result in false. The check on the length is for a special case involving empty strings. Also note that it falls down on your 0x89f test, but that\'s because in many environments that\'s an okay way to define a number literal.  If you want to catch that specific scenario you could add an additional check.  Even better, if that\'s your reason for not using isNaN() then just wrap your own function around isNaN() that can also do the additional check.In summary, if you want to know if a value can be converted to a number, actually try to convert it to a number.I went back and did some research for why a whitespace string did not have the expected output, and I think I get it now: an empty string is coerced to 0 rather than NaN. Simply trimming the string before the length check will handle this case.Running the unit tests against the new code and it only fails on the infinity and boolean literals, and the only time that should be a problem is if you\'re generating code (really, who would type in a literal and check if it\'s numeric? You should know), and that would be some strange code to generate.But, again, the only reason ever to use this is if for some reason you have to avoid isNaN().This way seems to work well:And to test it:I borrowed that regex from http://www.codetoad.com/javascript/isnumeric.asp. Explanation:This works for 0x23 type numbers as well.Yahoo! UI uses this:The accepted answer failed your test #7 and I guess it\'s because you changed your mind. So this is a response to the accepted answer, with which I had issues.During some projects I have needed to validate some data and be as certain as possible that it is a javascript numerical value that can be used in mathematical operations.jQuery, and some other javascript libraries already include such a function, usually called isNumeric. There is also a post on stackoverflow that has been widely accepted as the answer, the same general routine that the afore mentioned libraries are using.First, the code above would return true if the argument was an array of length 1, and that single element was of a type deemed as numeric by the above logic. In my opinion, if it\'s an array then its not numeric.To alleviate this problem, I added a check to discount arrays from the logicOf course, you could also use Array.isArray, jquery $.isArray or prototype Object.isArray instead of Object.prototype.toString.call(n) !== \'[object Array]\'My second issue was that Negative Hexadecimal integer literal strings ("-0xA" -> -10) were not being counted as numeric. However, Positive Hexadecimal integer literal strings ("0xA" -> 10) were treated as numeric.\nI needed both to be valid numeric.I then modified the logic to take this into account.If you are worried about the creation of the regex each time the function is called then you could rewrite it within a closure, something like thisI then took CMSs +30 test cases and cloned the testing on jsfiddle added my extra test cases and my above described solution.It may not replace the widely accepted/used answer but if this is more of what you are expecting as results from your isNumeric function then hopefully this will be of some help.EDIT: As pointed out by Bergi, there are other possible objects that could be considered numeric and it would be better to whitelist than blacklist. With this in mind I would add to the criteria.I want my isNumeric function to consider only Numbers or StringsWith this in mind, it would be better to useTest the solutionsYeah, the built-in isNaN(object) will be much faster than any regex parsing, because it\'s built-in and compiled, instead of interpreted on the fly.Although the results are somewhat different to what you\'re looking for (try it):Use the function isNaN. I believe if you test for !isNaN(yourstringhere) it works fine for any of these situations.Since jQuery 1.7, you can use jQuery.isNumeric():Just note that unlike what you said, 0x89f is a valid number (hexa)It can be done without RegExp as To me, this is the best way:didn\'t work for me. When I put in an alert and tested, input.length was \'undefined\'. I think there is no property to check integer length. So what I did wasIt worked fine.If I\'m not mistaken, this should match any valid JavaScript number value, excluding constants (Infinity, NaN) and the sign operators +/- (because they are not actually part of the number as far as I concerned, they are separate operators):I needed this for a tokenizer, where sending the number to JavaScript for evaluation wasn\'t an option... It\'s definitely not the shortest possible regular expression, but I believe it catches all the finer subtleties of JavaScript\'s number syntax.Valid numbers would include:Invalid numbers would beAn integer value can be verified by:This way is easier and faster! All tests are checked!Here\'s a lil bit improved version (probably the fastest way out there) that I use instead of exact jQuery\'s variant, I really don\'t know why don\'t they use this one:The downside of jQuery\'s version is that if you pass a string with leading numerics and trailing letters like "123abc" the parseFloat | parseInt will extract the numeric fraction out and return 123, BUT, the second guard isFinite will fail it anyway.\nWith the unary + operator it will die on the very first guard since + throws NaN for such hybrids :)\nA little performance yet I think a solid semantic gain.Only problem I had with @CMS\'s answer is the exclusion of NaN and Infinity, which are useful numbers for many situations. One way to check for NaN\'s is to check for numeric values that don\'t equal themselves, NaN != NaN!  So there are really 3 tests you\'d like to deal with ...My isComparableNumber is pretty close to another elegant answer, but handles hex and other string representations of numbers.I realize the original question did not mention jQuery, but if you do use jQuery, you can do:Simple.https://api.jquery.com/jQuery.isNumeric/ (as of jQuery 1.7)My solution,It appears to work in every situation, but I might be wrong.This should work. Some of the functions provided here are flawed, also should be faster than any other function here.Explained:Create a copy of itself, then converts the number into float, then compares itself with the original number, if it is still a number, (whether integer or float) , and matches the original number, that means, it is indeed a number.It works with numeric strings as well as plain numbers. Does not work with hexadecimal numbers. Warning: use at your own risk, no guarantees.I\'d like to add the following:\nPositive hex numbers start with 0x and negative hex numbers start with -0x.\nPositive oct numbers start with 0 and negative oct numbers start with -0.\nThis one takes most of what has already been mentioned into consideration, but includes hex and octal numbers, negative scientific, Infinity and has removed decimal scientific (4e3.2 is not valid).A couple of tests to add:I came up with this:The solution covers:I\'m using simpler solution:None of the answers return false for empty strings, a fix for that...@CMS\' answer: Your snippet failed on whitespace cases on my machine using nodejs. So I combined it with \n@joel\'s answer to the following:I unittested it with those cases that are floats:and those cases that are no floats (including empty whitespaces and objects / arrays):Everything works as expected here. Maybe this helps.Full source code for this can be found here.The following seems to works fine for many cases:This is built on top of this answer (which is for this answer too):\nhttps://stackoverflow.com/a/1561597/1985601I realize this has been answered many times, but the following is a decent candidate which can be useful in some scenarios.it should be noted that it assumes that \'.42\' is NOT a number, and \'4.\' is NOT a number, so this should be taken into account.The isDecimal passes the following test:The idea here is that every number or integer has one "canonical" string representation, and every non-canonical representation should be rejected. So we cast to a number and back, and see if the result is the original string.Whether these functions are useful for you depends on the use case. One feature is that distinct strings represent distinct numbers (if both pass the isNumber() test).This is relevant e.g. for numbers as object property names.knockoutJs Inbuild library validation functions By extending it the field get validated1) numberself.number = ko.observable(numberValue).extend({ number: true});TestCase2) digitself.number = ko.observable(numberValue).extend({ digit: true});TestCase3) min and maxself.number = ko.observable(numberValue).extend({ min: 5}).extend({ max: 10});This field accept value between 5 and 10 onlyTestCaseTo check if a variable contains a valid number and not\njust a String which looks like a number,\nNumber.isFinite(value) can be used.This is part of the language since\nES2015Examples:I think parseFloat function can do all the work here. The function below passes all the tests on this page including isNumeric(Infinity) == true:If n is numeric Number(n) will return the numeric value and +\'\' will turn it back to a string. But if n isn\'t numeric Number(n) will return NaN so it won\'t match the original n