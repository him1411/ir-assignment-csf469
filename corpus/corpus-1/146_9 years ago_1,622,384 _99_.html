If I have an object implementing the Map interface in Java and I wish to iterate over every pair contained within it, what is the most efficient way of going through the map?  Will the ordering of elements depend on the specific map implementation that I have for the interface?Summarize other answers and what I known, I found 10 main ways to do this (see below). And I wrote some performance tests (see results below), for example, if we want to find sum of all keys and values of map, we can write :Using iterator and Map.EntryUsing foreach and Map.EntryUsing forEach from Java 8Using keySet and foreachUsing keySet and iteratorUsing for and Map.EntryUsing Java 8 Stream ApiUsing Java 8 Stream Api parallelUsing IterableMap of Apache CollectionsUsing MutableMap of Eclipse (CS) collectionsPerfomance tests (mode = AverageTime, system = Win 8.1 64-bit, Intel i7-4790 3.60GHz 3.60GHz, 16 GB)1) For small map (100 elements),  score 0.308 is the best2) For map with 10000 elements,  score 37.606 is the best3) For map with 100000 elements,  score 1184.767 is the bestGraphs (perfomance tests depending on map size)Table (perfomance tests depending on map size)All test in githubIn Java 8 you can do it clean and fast using the new lambdas features:The type of k and v will be inferred by the compiler and there is no need to use Map.Entry anymore.Easy-peasy!Yes, the order depends on the specific Map implementation.  @ScArcher2 has the more elegant Java 1.5 syntax.  In 1.4, I would do something like this:Typical code for iterating over a map is:HashMap is the canonical map implementation and doesn\'t make guarantees (or though it should not change order if no mutating operation are performed on it). SortedMap will return entries based on the natural ordering of the keys, or a Comparator, if provided. LinkedHashMap will either return entries in insertion-order or access-order depending upon how it has been constructed. EnumMap returns entries in natural order of keys.Note, IdentityHashMap entrySet iterator currently has a peculiar implementation which returns the same Map.Entry instance for every item in the entrySet! However, every time a new the iterator advances the Map.Entry is updated.Example of using iterator and generics:This is a two part question:How to iterate over the entries of a Map - @ScArcher2 has answered that perfectly.What is the order of iteration - if you are just using Map, then strictly speaking, there are no ordering guarantees.  So you shouldn\'t really rely on the ordering given by any implementation.  However, the SortedMap interface extends Map and provides exactly what you are looking for - implementations will aways give a consistent sort order.NavigableMap is another useful extension - this is a SortedMap with additional methods for finding entries by their ordered position in the key set.  So potentially this can remove the need for iterating in the first place - you might be able to find the specific entry you are after using the higherEntry, lowerEntry, ceilingEntry, or floorEntry methods.  The descendingMap method even gives you an explicit method of reversing the traversal order.There are several ways to iterate over map.Here is comparison of their performances for a common data set stored in map by storing a million key value pairs in map and will iterate over map.1) Using entrySet() in for each loop50 milliseconds2) Using keySet() in for each loop76 milliseconds3) Using entrySet() and iterator50 milliseconds4) Using keySet() and iterator75 millisecondsI have referred this link.FYI, you can also use map.keySet() and map.values() if you\'re only interested in keys/values of the map and not the other.The correct way to do this is to use the accepted answer as it is the most efficient. I find the following code looks a bit cleaner.With Eclipse Collections (formerly GS Collections), you would use the forEachKeyValue method on the MapIterable interface, which is inherited by the MutableMap and ImmutableMap interfaces and their implementations.With Java 8 lambda syntax, you can write the code as follows:Note: I am a committer for Eclipse Collections.Try this with Java 1.4:In Map one can Iteration over keys and/or values and/or both (e.g., entrySet)  depends on one\'s interested in_ Like:1.) Iterate through the keys -> keySet() of the map:2.) Iterate through the values -> values() of the map:3.) Iterate through the both -> entrySet() of the map:Moreover, there are 3 difference ways to Iterate Through a HashMap. They are as below_JAVA 8\nYou can use Lambda Expressions.For more information follow this.ORLambda Expression Java 8In Java 1.8 (Java 8) this has become lot easier by using forEach method from Aggregate operations(Stream operations) that looks similar to iterators from Iterable Interface. Just copy paste below statement to your code and rename the HashMap variable from hm to your HashMap variable to print out key-value pair.Below is the sample code that i tried using Lambda Expression. This stuff is so cool. Must try.Also one can use Spliterator for the same.UPDATEIncluding documentation links to Oracle Docs.\nFor more on Lambda go to this link and must read Aggregate Operations and for Spliterator go to this link.In theory, the most efficient way will depend on which implementation of Map. The official way to do this is to call map.entrySet(), which returns a set of Map.Entry, each of which contains a key and a value (entry.getKey() and entry.getValue()).In an idiosyncratic implementation, it might make some difference whether you use map.keySet(), map.entrySet() or something else. But I can\'t think of a reason why anyone would write it like that. Most likely it makes no difference to performance what you do.And yes, the order will depend on the implementation - as well as (possibly) the order of insertion and other hard-to-control factors.[edit] I wrote valueSet() originally but of course entrySet() is actually the answer.If you have a generic untyped Map you can use:You can do it using generics:Yes, as many people agreed this is the best way to iterate over MAP.But there are chances to throw nullpointerexception if map is null.Don\'t forget to put null .checkThe best way is entrySet() though.In Java 8 we have got forEach method that accepts a lambda expression. We have also got stream APIs. Consider a map:Iterate over keys:Iterate over values:Iterate over entries (Using forEach and Streams):The advantage with streams is they can be parallelized easily in case we want to. We simply need to use parallelStream() in place of stream() above.It doesn\'t quite answer the OP\'s question, but might be useful to others who find this page:If you only need the values and not the keys, you can do this:Ktype, Vtype are pseudocode.If your reason for iterating trough the Map, is to do an operation on the value and write to a resulting Map. I recommend using the transform-methods in the Google Guava Maps class.After you have added the Maps to your imports, you can use Maps.transformValues and Maps.transformEntries on your maps, like this:The ordering will always depend on the specific map implementation.\nUsing Java8 you can use either of these:Or:The result will be the same (same order). The entrySet backed by the map so you are getting the same order. The second one is handy as it allows you to use lambdas, e.g. if you want only to print only Integer objects that are greater than 5:The code below shows iteration through LInkedHashMap and normal HashMap (example). You will see difference in the order:LinkedHashMap (1): 10 (#=10):10, 9 (#=9):9, 8 (#=8):8, 7 (#=7):7, 6 (#=6):6, 5 (#=5):5, 4 (#=4):4, 3 (#=3):3, 2 (#=2):2, 1 (#=1):1, 0 (#=0):0, LinkedHashMap (2): 10 : 10, 9 : 9, 8 : 8, 7 : 7, 6 : 6, 5 : 5, 4 : 4, 3 : 3, 2 : 2, 1 : 1, 0 : 0, HashMap (1): 0 (#:0):0, 1 (#:1):1, 2 (#:2):2, 3 (#:3):3, 4 (#:4):4, 5 (#:5):5, 6 (#:6):6, 7 (#:7):7, 8 (#:8):8, 9 (#:9):9, 10 (#:10):10, HashMap (2): 0 : 0, 1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10 : 10, There are the several way to iterate a map please refer the following code \nWhen you iterate a map using iterator Interface you must to go with Entry or entrySet()\nlook like this I copied the data of a map to another with this code: