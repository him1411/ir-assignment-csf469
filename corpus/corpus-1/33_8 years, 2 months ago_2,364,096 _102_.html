How do I force an overwrite of local files on a git pull?The scenario is following:The errors I\'m getting are:error: Untracked working tree file \'public/images/icon.gif\' would be overwritten by merge.How do I force Git to overwrite them? The person is a designer - usually I resolve all the conflicts by hand, so the server has the most recent version that they just needs to update on their computer.If you have any files that are not tracked by Git (e.g. uploaded user content), these files will not be affected.I think this is the right way:Then, you have two options:OR If you are on some other branch:git fetch downloads the latest from remote without trying to merge or rebase anything.Then the git reset resets the master branch to what you just fetched. The --hard option changes all the files in your working tree to match the files in origin/master[*]: It\'s worth noting that it is possible to maintain current local commits by creating a branch from master before resetting:After this, all of the old commits will be kept in new-branch-to-save-current-commits. Uncommitted changes however (even staged), will be lost. Make sure to stash and commit anything you need.Try this:It should do what you want.WARNING: git clean deletes all your untracked files/directories and can\'t be undone.Sometimes just clean -f does not help. In case you have untracked DIRECTORIES, -d option also needed:WARNING: git clean deletes all your untracked files/directories and can\'t be undone.Like Hedgehog I think the answers are terrible. But though Hedgehog\'s answer might be better, I don\'t think it is as elegant as it could be.  The way I found to do this is by using "fetch" and "merge" with a defined strategy. Which should make it so that your local changes are preserved as long as they are not one of the files that you are trying to force an overwrite with. "-X" is an option name, and "theirs" is the value for that option. You\'re choosing to use "their" changes, instead of "your" changes if there is a conflict.Instead of doing:I\'d advise doing the following:No need to fetch all remotes and branches if you\'re going to reset to the origin/master branch right?It looks like the best way is to first do:To delete all untracked files and then continue with the usual git pull...Warning, doing this will permanently delete your files if you have any directory/* entries in your gitignore file.These seem to be terrible answers, terrible in the sense of what happened to @Lauri by following David Avsajanishvili suggestion.Rather (git > v1.7.6):Later you can clean the stash history.Manually, one-by-one:Brutally, all-at-once:Of course if you want to go back to what you stashed:You might find this command helpful to throw away local changes:And then do a cleanup (removes untracked files from the working tree):If you want to remove untracked directories in addition to untracked files:Instead of merging using git pull, try git fetch --all followed by git reset --hard origin/master.The problem with all these solutions is that they are all either too complex, or, an even bigger problem, is that they remove all untracked files from the web server, which we don\'t want since there are always needed configuration files which are on the server and not in the Git repository.Here is the cleanest solution which we are using:The first command fetches newest data.The second command checks if there are any files which are being added to the repository and deletes those untracked files from the local repository which would cause conflicts.The third command checks-out all the files which were locally modified.Finally we do a pull to update to the newest version, but this time without any conflicts, since untracked files which are in the repo don\'t exist anymore and all the locally modified files are already the same as in the repository.The only thing that worked for me was:This will take you back five commits and then withI found that by looking up how to undo a Git merge.I had the same problem. No one gave me this solution, but it worked for me.I solved it by:Now it works.First of all, try the standard way:If above won\'t help and you don\'t care about your untracked files/directories (make the backup first just in case), try the following simple steps:This will REMOVE all git files (excempt .git/ dir, where you have all commits) and pull it again.Why git reset HEAD --hard could fail in some cases?Custom rules in .gitattributes fileHaving eol=lf rule in .gitattributes could cause git to modify some file changes by converting CRLF line-endings into LF in some text files.If that\'s the case, you\'ve to commit these CRLF/LF changes (by reviewing them in git status), or try: git config core.autcrlf false to temporary ignore them.File system incompabilityWhen you\'re using file-system which doesn\'t support permission attributes.\nIn example you have two repositories, one on Linux/Mac (ext3/hfs+) and another one on FAT32/NTFS based file-system.As you notice, there are two different kind of file systems, so the one which doesn\'t support Unix permissions basically can\'t reset file permissions on system which doesn\'t support that kind of permissions, so no matter how --hard you try, git always detect some "changes".I had a similar problem.  I had to do this:Based on my own similar experiences, the solution offered by Strahinja Kustudic above is by far the best.  As others have pointed out, simply doing hard reset will remove all the untracked files which could include lots of things that you don\'t want removed, such as config files.  What is safer, is to remove only the files that are about to be added, and for that matter, you\'d likely also want to checkout any locally-modified files that are about to be updated.That in mind, I updated Kustudic\'s script to do just that.  I also fixed a typo (a missing \' in the original).I summarized other answers. You can execute git pull without errors:Warning: This script is very powerful, so you could lose your changes.I believe there are two possible causes of conflict, which must be solved separately, and as far as I can tell none of the above answers deals with both:Local files that are untracked need to be deleted, either manually (safer) or as suggested in other answers, by git clean -f -dLocal commits that are not on the remote branch need to be deleted as well. IMO the easiest way to achieve this is with: git reset --hard origin/master (replace \'master\' by whatever branch you are working on, and run a git fetch origin first)An easier way would be to:This will override your local file with the file on gitI had the same problem and for some reason, even a git clean -f -d would not do it. Here is why: For some reason, if your file is ignored by Git (via a .gitignore entry, I assume), it still bothers about overwriting this with a later pull, but a clean will not remove it, unless you add -x.It seems like most answers here are focused on the master branch; however, there are times when I\'m working on the same feature branch in two different places and I want a rebase in one to be reflected in the other without a lot of jumping through hoops.Based on a combination of RNA\'s answer and torek\'s answer to a similar question, I\'ve come up with this which works splendidly:Run this from a branch and it\'ll only reset your local branch to the upstream version.This can be nicely put into a git alias (git forcepull) as well:git config alias.forcepull "!git fetch ; git reset --hard @{u}"Or, in your .gitconfig file:Enjoy!In speaking of pull/fetch/merge in the above answers, I would like to share an interesting and productive trick,This above command is the most useful command in my git life which saved a lots of time.Before pushing your newly commit to server, try this command and it will automatically sync latest server changes (with a fetch + merge) and will place your commit at the top in git log. No need to worry about manual pull/merge.Find details at: http://gitolite.com/git-pull--rebaseI just solved this myself by:where the last command gives a list of what your local changes were. Keep modifying the "tmp" branch until it is acceptable and then merge back onto master with: For next time, you can probably handle this in a cleaner way by looking up "git stash branch" though stash is likely to cause you trouble on the first few tries, so do first experiment on a non-critical project...Reset the index and the head to origin/master, but do not reset the working tree:These four commands work for me.To check/pull after executing these commandsI tried a lot but finally got success with these commands.Despite the original question, the top answers can cause problems for people who have a similar problem, but don\'t want to lose their local files. For example, see Al-Punk and crizCraig\'s comments. The following version commits your local changes to a temporary branch (tmp), checks out the original branch (which I\'m assuming is master) and merges the updates. You could do this with stash, but I\'ve found it\'s usually easier to simply use the branch / merge approach.where we assume the other repository is origin master.I have a strange situation that either git clean or git reset works. I have to remove the conflicting file from git index by Then I can pull just fine.Just doSo you avoid all unwanted side effects, like deleting files or directories you wanted to keep, etc.Requirements:Solution:Fetch with a clean of files and directories ignoring .gitignore and hard reset to origin.I know a much more easier and less painful method:That\'s it!I read through all the answers but I was looking for a single command to do this. Here is what I did. Added a git alias to .gitconfigRun your command as equivalent to