Whenever I want to do something "map"py in R, I usually try to use a function in the apply family. However, I\'ve never quite understood the differences between them -- how {sapply, lapply, etc.} apply the function to the input/grouped input, what the output will look like, or even what the input can be -- so I often just go through them all until I get what I want.Can someone explain how to use which one when?My current (probably incorrect/incomplete) understanding is...sapply(vec, f): input is a vector. output is a vector/matrix, where element i is f(vec[i]), giving you a matrix if f has a multi-element outputlapply(vec, f): same as sapply, but output is a list?Side question: I still haven\'t learned plyr or reshape -- would plyr or reshape replace all of these entirely?R has many *apply functions which are ably described in the help files (e.g. ?apply). There are enough of them, though, that beginning useRs may have difficulty deciding which one is appropriate for their situation or even remembering them all. They may have a general sense that "I should be using an *apply function here", but it can be tough to keep them all straight at first.Despite the fact (noted in other answers) that much of the functionality of the *apply family is covered by the extremely popular plyr package, the base functions remain useful and worth knowing.This answer is intended to act as a sort of signpost for new useRs to help direct them to the correct *apply function for their particular problem. Note, this is not intended to simply regurgitate or replace the R documentation! The hope is that this answer helps you to decide which *apply function suits your situation and then it is up to you to research it further. With one exception, performance differences will not be addressed.apply - When you want to apply a function to the rows or columns\nof a matrix (and higher-dimensional analogues); not generally advisable for data frames as it will coerce to a matrix first.If you want row/column means or sums for a 2D matrix, be sure to\ninvestigate the highly optimized, lightning-quick colMeans,\nrowMeans, colSums, rowSums.lapply - When you want to apply a function to each element of a\nlist in turn and get a list back.This is the workhorse of many of the other *apply functions. Peel\nback their code and you will often find lapply underneath.sapply - When you want to apply a function to each element of a\nlist in turn, but you want a vector back, rather than a list.If you find yourself typing unlist(lapply(...)), stop and consider\nsapply.In more advanced uses of sapply it will attempt to coerce the\nresult to a multi-dimensional array, if appropriate. For example, if our function returns vectors of the same length, sapply will use them as columns of a matrix:If our function returns a 2 dimensional matrix, sapply will do essentially the same thing, treating each returned matrix as a single long vector:Unless we specify simplify = "array", in which case it will use the individual matrices to build a multi-dimensional array:Each of these behaviors is of course contingent on our function returning vectors or matrices of the same length or dimension.vapply - When you want to use sapply but perhaps need to\nsqueeze some more speed out of your code.For vapply, you basically give R an example of what sort of thing\nyour function will return, which can save some time coercing returned\nvalues to fit in a single atomic vector.mapply - For when you have several data structures (e.g.\nvectors, lists) and you want to apply a function to the 1st elements\nof each, and then the 2nd elements of each, etc., coercing the result\nto a vector/array as in sapply.This is multivariate in the sense that your function must accept\nmultiple arguments.Map - A wrapper to mapply with SIMPLIFY = FALSE, so it is guaranteed to return a list.rapply - For when you want to apply a function to each element of a nested list structure, recursively.To give you some idea of how uncommon rapply is, I forgot about it when first posting this answer! Obviously, I\'m sure many people use it, but YMMV. rapply is best illustrated with a user-defined function to apply:tapply - For when you want to apply a function to subsets of a\nvector and the subsets are defined by some other vector, usually a\nfactor.The black sheep of the *apply family, of sorts. The help file\'s use of\nthe phrase "ragged array" can be a bit confusing, but it is actually\nquite simple.A vector:A factor (of the same length!) defining groups:Add up the values in x within each subgroup defined by y:More complex examples can be handled where the subgroups are defined\nby the unique combinations of a list of several factors. tapply is\nsimilar in spirit to the split-apply-combine functions that are\ncommon in R (aggregate, by, ave, ddply, etc.) Hence its\nblack sheep status.On the side note, here is how the various plyr functions correspond to the base *apply functions (from the intro to plyr document from the plyr webpage http://had.co.nz/plyr/)One of the goals of plyr is to provide consistent naming conventions for each of the functions, encoding the input and output data types in the function name. It also provides consistency in output, in that output from dlply() is easily passable to ldply() to produce useful output, etc.Conceptually, learning plyr is no more difficult than understanding the base *apply functions.plyr and reshape functions have replaced almost all of these functions in my every day use. But, also from the Intro to Plyr document:Related functions tapply and sweep have no corresponding function in plyr, and remain useful. merge is useful for combining summaries with the original data.From slide 21 of http://www.slideshare.net/hadley/plyr-one-data-analytic-strategy:(Hopefully it\'s clear that apply corresponds to @Hadley\'s aaply and aggregate corresponds to @Hadley\'s ddply etc. Slide 20 of the same slideshare will clarify if you don\'t get it from this image.)(on the left is input, on the top is output)First start with Joran\'s excellent answer -- doubtful anything can better that.Then the following mnemonics may help to remember the distinctions between each.  Whilst some are obvious, others may be less so --- for these you\'ll find justification in Joran\'s discussions.MnemonicsBuilding the Right BackgroundIf using the apply family still feels a bit alien to you, then it might be that you\'re missing a key point of view.These two articles can help.  They provide the necessary background to motivate the functional programming techniques that are being provided by the apply family of functions.  Users of Lisp will recognise the paradigm immediately.  If you\'re not familiar with Lisp, once you get your head around FP, you\'ll have gained a powerful point of view for use in R -- and apply will make a lot more sense.Since I realized that (the very excellent) answers of this post lack of by and aggregate explanations. Here is my contribution.The by function, as stated in the documentation can be though, as a "wrapper" for tapply. The power of by arises when we want to compute a task that tapply can\'t handle. One example is this code:If we print these two objects, ct and cb, we "essentially" have the same results and the only differences are in how they are shown and the different class attributes, respectively by for cb and array for ct.As I\'ve said, the power of by arises when we can\'t use tapply; the following code is one example:R says that arguments must have the same lengths, say "we want to calculate the summary of all variable in iris along the factor Species": but R just can\'t do that because it does not know how to handle.With the by function R dispatch a specific method for data frame class and then let the summary function works even if the length of the first argument (and the type too) are different.it works indeed and the result is very surprising. It is an object of class by that along Species (say, for each of them) computes the summary of each variable.Note that if the first argument is a data frame, the dispatched function must have a method for that class of objects. For example is we use this code with the mean function we will have this code that has no sense at all:aggregate can be seen as another a different way of use tapply if we use it in such a way.The two immediate differences are that the second argument of aggregate must be a list while tapply can (not mandatory) be a list and that the output of aggregate is a data frame while the one of tapply is an array.The power of aggregate is that it can handle easily subsets of the data with subset argument and that it has methods for ts objects and formula as well.These elements make aggregate easier to work with that tapply in some situations.\nHere are some examples (available in documentation):We can achieve the same with tapply but the syntax is slightly harder and the output (in some circumstances) less readable:There are other times when we can\'t use by or tapply and we have to use aggregate.We cannot obtain the previous result with tapply in one call but we have to calculate the mean along Month for each elements and then combine them (also note that we have to call the na.rm = TRUE, because the formula methods of the aggregate function has by default the na.action = na.omit):while with by we just can\'t achieve that in fact the following function call returns an error (but most likely it is related to the supplied function, mean):Other times the results are the same and the differences are just in the class (and then how it is shown/printed and not only  -- example, how to subset it) object:The previous code achieve the same goal and results, at some points what tool to use is just a matter of personal tastes and needs; the previous two objects have very different needs in terms of subsetting.There are lots of great answers which discuss differences in the use cases for each function. None of the answer discuss the differences in performance. That is reasonable cause various functions expects various input and produces various output, yet most of them have a general common objective to evaluate by series/groups. My answer is going to focus on performance. Due to above the input creation from the vectors is included in the timing, also the apply function is not measured.  I have tested two different functions sum and length at once. Volume tested is 50M on input and 50K on output. I have also included two currently popular packages which were not widely used at the time when question was asked, data.table and dplyr. Both are definitely worth to look if you are aiming for good performance.    It is maybe worth mentioning ave. ave is tapply\'s friendly cousin. It returns results in a form that you can plug straight back into your data frame.There is nothing in the base package that works like ave for whole data frames (as by is like tapply for data frames). But you can fudge it:Despite all the great answers here, there are 2 more base functions that deserve to be mentioned, the useful outer function and the obscure eapply functionouterouter is a very useful function hidden as a more mundane one. If you read the help for outer its description says:which makes it seem like this is only useful for linear algebra type things.  However, it can be used much like mapply to apply a function to two vectors of inputs. The difference is that mapply will apply the function to the first two elements and then the second two etc, whereas outer will apply the function to every combination of one element from the first vector and one from the second. For example:I have personally used this when I have a vector of values and a vector of conditions and wish to see which values meet which conditions.eapplyeapply is like lapply except that rather than applying a function to every element in a list, it applies a function to every element in an environment. For example if you want to find a list of user defined functions in the global environment:Frankly I don\'t use this very much but if you are building a lot of packages or create a lot of environments it may come in handy. I recently discovered the rather useful sweep function and add it here for the sake of completeness:sweepThe basic idea is to sweep through an array row- or column-wise and return a modified array. An example will make this clear (source: datacamp):Let\'s say you have a matrix and want to standardize it column-wise:NB: for this simple example the same result can of course be achieved more easily by apply(dataPoints, 2, scale)