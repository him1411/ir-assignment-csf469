How can I use JUnit4 idiomatically to test that some code throws an exception?While I can certainly do something like this:I recall that there is an annotation or an Assert.xyz or something that is far less kludgy and far more in-the-spirit of JUnit for these sorts of situations.JUnit 4 has support for this:If you can use JUnit 4.7, you can use the ExpectedException RuleThis is much better than @Test(expected=IndexOutOfBoundsException.class) because the test will fail if IndexOutOfBoundsException is thrown before foo.doStuff()See this article for detailsEdit: If you are using Java 8, look at the answer from Rafal. Be careful using expected exception, because it only asserts that the method threw that exception, not a particular line of code in the test.I tend to use this for testing parameter validation, because such methods are usually very simple, but more complex tests might better be served with:Apply judgement.As answered before, there are many ways of dealing with exceptions in JUnit. But with Java 8 there is another one: using Lambda Expressions. With Lambda Expressions we can achieve a syntax like this:assertThrown accepts a functional interface, whose instances can be created with lambda expressions, method references, or constructor references. assertThrown accepting that interface will expect and be ready to handle an exception.This is relatively simple yet powerful technique.Have a look at this blog post describing this technique: http://blog.codeleak.pl/2014/07/junit-testing-exception-with-java-8-and-lambda-expressions.htmlThe source code can be found here: https://github.com/kolorobot/unit-testing-demo/tree/master/src/test/java/com/github/kolorobot/exceptions/java8Disclosure: I am the author of the blog and the project.in junit, there are three ways to test exception. use the optional \'expected\' attribute of Test annonationuse the ExpectedException rulefinally, you also can use the classic try/catch way widely used under junit 3 frameworksofor more info, you can read this document for details.tl;drpre-JDK8 : I will recommend the old good try-catch block. post-JDK8 : Use AssertJ or custom lambdas to assert exceptional behaviour.the long storyIt is possible to write yourself a do it yourself try-catch block or use the JUnit tools (@Test(expected = ...) or the @Rule ExpectedException JUnit rule feature).But these way are not so elegant and don\'t mix well readability wise with other tools.The try-catch block you have to write the block around the tested behavior, and write the assertion in the catch block, that may be fine but many find taht this style interrupts the reading flow of a test. Also you need to write an Assert.fail at the end of the try block otherwise the test may miss one side of the assertions ; PMD, findbugs or Sonar will spot such issues.The @Test(expected = ...) feature is interesting as you can write less code and then writing this test is supposedly less prone to coding errors. But ths approach is lacking a some areas.Also as the expectation is placed around in the method, depending on how the tested code is written then the wrong part of the test code can throw the exception, leading to false positive test and I m not sure that PMD, findbugs or Sonar will give hints on such code.The ExpectedException rule is also an attempt to fix the previous caveats, but it feels a bit awkward to use as it uses an expectation style, EasyMock users knows very well this style. It might be convenient for some, but if you follow Behaviour Driven Development (BDD) or Arrange Act Assert (AAA) principles the ExpectedException rule won\'t fit in those writing style. Aside of that it may suffer from the same issue as the as the @Test way, depending where you place the expectation.Even the expected exception is placed before the test statement, it breaks your reading flow if the tests follow BDD or AAA.Also see this comment issue on JUnit of the author of ExpectedException.So these above options have all their load of caveats, and clearly not immune to coder errors.There\'s a project I became aware after creating this answer that looks promising, it\'s catch-exception.As the description of the project says, it let a coder write in a fluent line of code catching the exception and offer this exception for later assertion. And you can use any assertion library like Hamcrest or AssertJ.A rapid example taken from the home page : As you can see the code is really straightforward, you catch the exception on a specific line, the then API is an alias that will use AssertJ APIs (similar to using assertThat(ex).hasNoCause()...). At some point the project relied on FEST-Assert the ancestor of AssertJ. EDIT: It seems the project is brewing a Java 8 Lambdas support.Currently this library has two shortcomings : At the time of this writing it is noteworthy to say this library is based on Mockito 1.x as it creates a mock of the tested object behind the scene. As Mockito is still not updated this library cannot work with final classes or final methods. And even if it was based on mockito 2 in the current version, this would require to declare a global mock maker (inline-mock-maker), something that may not what you want, as this mockmaker has different drawbacks that the regular mockmaker.It requires yet another test dependency.These issues won\'t apply once the library will support lambdas, however the functionality will be duplicated by AssertJ toolset.Taking all into account if you don\'t want to use the catch-exception tool, I will recommend the old good way of the try-catch block, at least up to the JDK7. And for JDK 8 users you might prefer to use AssertJ as it offers may more than just asserting exceptions.With the JDK8, lambdas enter the test scene, and they have proved to be an interesting way to assert exceptional behaviour. AssertJ has been updated to provide a nice fluent API to assert exceptional behaviour.And a sample test with AssertJ :With a near complete rewrite of JUnit 5, assertions have been improved a bit, they may prove interesting as an out of the box way to assert properly exception. But really the assertion API is still a bit poor, there\'s nothing outside assertThrows. As you noticed assertEquals is still returning void, and as such doesn\'t allow chaining assertions like AssertJ.Also if you remember name clash with Matcher or Assert, be prepared to meet the same clash with Assertions.I\'d like to conclude that today (2017-03-03) AssertJ\'s ease of use, discoverable API, rapid pace of development and as a de facto test dependency is the best solution with JDK8 regardless of the test framework (JUnit or not), prior JDKs should instead rely on try-catch blocks even if they feel clunky.This answer has been copied from another question that don\'t have the same visibility, I am the same author.To solve the same problem I did set up a small project: \nhttp://code.google.com/p/catch-exception/Using this little helper you would writeThis is less verbose than the ExpectedException rule of JUnit 4.7.\nIn comparison to the solution provided by skaffman, you can specify in which line of code you expect the exception. I hope this helps.How about this:  Catch a very general exception, make sure it makes it out of the catch block, then assert that the class of the exception is what you expect it to be.  This assert will fail if a) the exception is of the wrong type (eg. if you got a Null Pointer instead) and b) the exception wasn\'t ever thrown.Using an AssertJ assertion, which can be used alongside JUnit:It\'s better than @Test(expected=IndexOutOfBoundsException.class) because it guarantees the expected line in the test threw the exception and lets you check more details about the exception, such as message, easier:Maven/Gradle instructions here.You can also do this:Update: JUnit5 has an improvement for exceptions testing: assertThrows.following example is from: Junit 5 User GuideOriginal asnwer using JUnit 4.There are several ways to test that an exception is thrown. I have also discussed the below options in my post How to write great unit tests with JUnitSet the expected parameter @Test(expected = FileNotFoundException.class).Using try catchTesting with ExpectedException Rule.You could read more about exceptions testing in JUnit4 wiki for Exception testing and bad.robot - Expecting Exceptions JUnit Rule.IMHO, the best way to check for exceptions in JUnit is the try/catch/fail/assert pattern:The assertTrue might be a bit strong for some people, so assertThat(e.getMessage(), containsString("the message"); might be preferable.More Infos about JUnit 5 on http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertionsI tried many of the methods here, but they were either complicated or didn\'t quite meet my requirements.  In fact, one can write a helper method quite simply:Use it like this:Zero dependencies: no need for mockito, no need powermock; and works just fine with final classes.JUnit has built-in support for this, with an "expected" attributeIn my case I always get RuntimeException from db, but messages differ. And exception need to be handled respectively. Here is how I tested it:We can use an assertion fail after the method that must return an exception:If you would like a solution which:Here is a utility function that I wrote:(taken from my blog)Use it as follows:Just make a Matcher that can be turned off and on, like this:To use it:add public ExpectedException exception = ExpectedException.none();,\nthen:In JUnit 4 or later you can test the exceptions as follows this provides a lot of features which can be used to improve our JUnit tests.  If you see the below example I am testing 3 things on the exception.Additionally to what NamShubWriter has said, make sure that: Do not do this:    Finally, this blog post clearly illustrates how to assert that a certain exception is thrown.Take for example, you want to write Junit for below mentioned code fragmentThe above code is to test for some unknown exception that may occur and the below one is to assert some exception with custom message.I wanted to comment with my solution to this problem, which avoided needing any of the exception related JUnit code.I used assertTrue(boolean) combined with try/catch to look for my expected exception to be thrown. Here\'s an example: