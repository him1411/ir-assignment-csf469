What is the purpose of the self word in Python? I understand it refers to the specific object created from that class, but I can\'t see why it explicitly needs to be added to every function as a parameter. To illustrate, in Ruby I can do this:Which I understand, quite easily. However in Python I need to include self:Can anyone talk me through this? It is not something I\'ve come across in my (admittedly limited) experience.The reason you need to use self. is because Python does not use the @ syntax to refer to instance attributes. Python decided to do methods in a way that makes the instance to which the method belongs be passed automatically, but not received automatically: the first parameter of methods is the instance the method is called on. That makes methods entirely the same as functions, and leaves the actual name to use up to you (although self is the convention, and people will generally frown at you when you use something else.) self is not special to the code, it\'s just another object.Python could have done something else to distinguish normal names from attributes -- special syntax like Ruby has, or requiring declarations like C++ and Java do, or perhaps something  yet more different -- but it didn\'t. Python\'s all for making things explicit, making it obvious what\'s what, and although it doesn\'t do it entirely everywhere, it does do it for instance attributes. That\'s why assigning to an instance attribute needs to know what instance to assign to, and that\'s why it needs self..Let\xe2\x80\x99s take a simple vector class:We want to have a method which calculates the length. What would it look like if we wanted to define it inside the class?What should it look like when we were to define it as a global method/function?So the whole structure stays the same. How can me make use of this? If we assume for a moment that we hadn\xe2\x80\x99t written a length method for our Vector class, we could do this:This works because the first parameter of length_global, can be re-used as the self parameter in length_new. This would not be possible without an explicit self.Another way of understanding the need for the explicit self is to see where Python adds some syntactical sugar. When you keep in mind, that basically, a call likeis internally transformed toit is easy to see where the self fits in. You don\'t actually write instance methods in Python; what you write is class methods which must take an instance as a first parameter. And therefore, you\xe2\x80\x99ll have to place the instance parameter somewhere explicitly.Let\'s say you have a class ClassA which contains a method methodA defined as:and ObjectA is an instance of this class.Now when ObjectA.methodA(arg1, arg2) is called, python internally converts it for you as:The self variable refers to the object itself.When objects are instantiated, the object itself is passed into the self parameter. Because of this, the object\xe2\x80\x99s data is bound to the object. Below is an example of how you might like to visualize what each object\xe2\x80\x99s data might look. Notice how \xe2\x80\x98self\xe2\x80\x99 is replaced with the objects name. I\'m not saying this example diagram below is wholly accurate but it hopefully with serve a purpose in visualizing the use of self. The Object is passed into the self parameter so that the object can keep hold of its own data.Although this may not be wholly accurate, think of the process of instantiating an object like this: When an object is made it uses the class as a template for its own data and methods. Without passing it\'s own name into the self parameter, the attributes and methods in the class would remain as a general template and would not be referenced to (belong to) the object. So by passing the object\'s name into the self parameter it means that if 100 objects are instantiated from the one class, they can all keep track of their own data and methods.See the illustration below:I like this example:I will demonstrate with code that does not use classes:Classes are just a way to avoid passing in this "state" thing all the time (and other nice things like initializing, class composition, the rarely-needed metaclasses, and supporting custom methods to override operators).Now let\'s demonstrate the above code using the built-in python class machinery, to show how it\'s basically the same thing.[migrated my answer from duplicate closed question]As well as all the other reasons already stated, it allows for easier access to overridden methods; you can call Class.some_method(inst).An example of where it\xe2\x80\x99s useful:The following excerpts are from the Python documentation about self:As in Modula-3, there are no shorthands [in Python] for referencing the object\xe2\x80\x99s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call.Often, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention.For more information, see the Python documentation tutorial on classes.Its use is similar to the use of this keyword in Java, i.e. to give a reference to the current object.It\xe2\x80\x99s there to follow the Python zen \xe2\x80\x9cexplicit is better than implicit\xe2\x80\x9d. It\xe2\x80\x99s indeed a reference to your class object. In Java and PHP, for example, it\'s called this.If user_type_name is a field on your model you access it by self.user_type_name.self is an object reference to the object itself, therefore, they are same.\nPython methods are not called in the context of the object itself.\nself in Python may be used to deal with custom object models or something.Python is not a language built for Object Oriented Programming unlike Java or C++. When calling a static method in Python, one simply writes a method with regular arguments inside it. However, an object method, which requires you to make a variable, which is an Animal, in this case, needs the self argumentThe self method is also used to refer to a variable field within the class. In this case, self is referring to the animalName variable of the entire class. REMEMBER: If you have a variable within a method, self will not work. That variable is simply existent only while that method is running. For defining fields (the variables of the entire class), you have to define them OUTSIDE the class methods. If you don\'t understand a single word of what I am saying, then Google "Object Oriented Programming." Once you understand this, you won\'t even need to ask that question :).I\'m surprised nobody has brought up Lua. Lua also uses the \'self\' variable however it can be omitted but still used. C++ does the same with \'this\'. I don\'t see any reason to have to declare \'self\' in each function but you should still be able to use it just like you can with lua and C++. For a language that prides itself on being brief it\'s odd that it requires you to declare the self variable.Take a look at the following example, which clearly explains the purpose of selfself is used/needed to distinguish between instances.Is because by the way python is designed the alternatives would hardly work. Python is designed to allow methods or functions to be defined in a context where both implicit this (a-la Java/C++) or explicit @ (a-la ruby) wouldn\'t work. Let\'s have an example with the explicit approach with python conventions:Now the fubar function wouldn\'t work since it would assume that self is a global variable (and in frob as well). The alternative would be to execute method\'s with a replaced global scope (where self is the object).The implicit approach would beThis would mean that myX would be interpreted as a local variable in fubar (and in frob as well). The alternative here would be to execute methods with a replaced local scope which is retained between calls, but that would remove the posibility of method local variables.However the current situation works out well:here when called as a method frob will receive the object on which it\'s called via the self parameter, and fubar can still be called with an object as parameter and work the same (it is the same as C.frob I think).In the __init__ method, self refers to the newly created object; in other class methods, it refers to the instance whose method was called.self, as a name, is just a convention, call it as you want ! but when using it, for example to delete the object, you have to use the same name: __del__(var), where var was used in the __init__(var,[...])You should take a look at cls too, to have the bigger picture. This post could be helpful.it\'s an explicit reference to the class instance object. 