After I upgraded to latest stable node and npm, I tried npm install moment --save. It saves the entry in the package.json with the caret(^) prefix. Previously, it was a tilde(~) prefix. In the simplest terms, the tilde matches the most recent minor version\n  (the middle number). ~1.2.3 will match all 1.2.x versions but will\n  miss 1.3.0.The caret, on the other hand, is more relaxed. It will update you to\n  the most recent major version (the first number). ^1.2.3 will match\n  any 1.x.x release including 1.3.0, but will hold off on 2.0.0.http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/I would like to add the official npmjs documentation as well which describes all methods for version specificity including the ones referred to in the question - https://www.npmjs.org/doc/files/package.json.htmlhttps://docs.npmjs.com/misc/semver#x-ranges-12x-1x-12-The above list is not exhaustive. Other version specifiers include GitHub urls and GitHub user repo\'s, local paths and packages with specific npm tagsNpm allows installing newer version of a package than the one specified. Using tilde (~) gives you bug fix releases and caret (^) gives you backwards compatible new functionality as well. The problem is old versions usually don\'t receive bug fixes that much, so npm uses caret (^) as the default for --save.According to: "Semver explained - why there\'s a caret (^) in my package.json?".Note that the rules apply to versions above 1.0.0 and not every project follows semantic versioning.Here\'s a visual explanation of the concepts:Source: "Semantic Versioning Cheatsheet".~ fixes major and minor numbers. It is used when you\'re ready to accept bug-fixes in your dependency, but don\'t want any potentially incompatible changes.^ fixes the major number only. It is used when you\'re closely watching your dependencies and are ready to quickly change your code if minor release will be incompatible.In addition to that, ^ is not supported by old npm versions, and should be used with caution.So, ^ is a good default, but it\'s not perfect. I suggest to carefully pick and configure the semver operator that is most useful to you.You can pin version like 1.2.3 or allow updates at the:Set starting major-level and allow updates upwardFreeze major-levelFreeze minor-levelFreeze patch-levelDisallow updatesNotice: Missing major, minor, patch or specifying beta without number, is the same as any for the missing level.Notice: When you install pakckage wich has 0 as major level, update will only install new beta/pr level version! That\'s because npm sets ^ as default in package.json and when installed version is like 0.1.3, it freezes all major/minor/patch levels.~ : Reasonably close to^: Compatible with^ is 1.[any].[any] (latest minor version)\n~ is 1.2.[any] (latest patch)A great read is this blog post on how semver applies to npm\nand what they\'re doing to make it match the semver standard\nhttp://blog.npmjs.org/post/98131109725/npm-2-0-0Hat matching may be considered "broken" because it wont update ^0.1.2 to 0.2.0. When the software is emerging use 0.x.y versions and hat matching will only match the last varying digit (y). This is done on purpose. The reason is that while the software is evolving the API changes rapidly: one day you have these methods and the other day you have those methods and the old ones are gone. If you don\'t want to break the code for people who already are using your library you go and increment the major version: e.g. 1.0.0 -> 2.0.0 -> 3.0.0. So, by the time your software is finally 100% done and full-featured it will be like version 11.0.0 and that doesn\'t look very meaningful, and actually looks confusing. If you were, on the other hand, using 0.1.x -> 0.2.x -> 0.3.x versions then by the time the software is finally 100% done and full-featured it is released as version 1.0.0 and it means "This release is a long-term service one, you can proceed and use this version of the library in your production code, and the author won\'t change everything tomorrow, or next month, and he won\'t abandon the package".The rule is: use 0.x.y versioning when your software hasn\'t yet matured and release it with incrementing the middle digit when your public API changes (therefore people having ^0.1.0 won\'t get 0.2.0 update and it won\'t break their code). Then, when the software matures, release it under 1.0.0 and increment the leftmost digit each time your public API changes (therefore people having ^1.0.0 won\'t get 2.0.0 update and it won\'t break their code).One liner explanationThe standard versioning system is major.minor.build (e.g. 2.4.1)npm checks and fixes the version of a particular package based on these characters~ : major version is fixed, minor version is fixed, matches any build numbere.g. : ~2.4.1 means it will check for 2.4.x where x is anything^ : major version is fixed, matches any minor version, matches any build numbere.g. : ^2.4.1 means it will check for 2.x.x where x is anything~ Tilde:^ Caret:^ : Accept version changes less than Left Most Non-Zero Version (1st no-zero version digit from left side).~ : Accept version changes less than 2nd Left Most Non-Zero Version (2nd no-zero version digit from left side).\n      OR If there is no 2nd Left most Non-Zero version then Accept version changes less than Left most version.