I read about sorting ArrayLists using a Comparator but in all of the examples people used compareTo which according to some research is a method for Strings.I wanted to sort an ArrayList of custom objects by one of their properties: a Date object\n(getStartDay()). Normally I compare them by item1.getStartDate().before(item2.getStartDate()) so I was wondering whether I could write something like:Since Date implements Comparable, it has a compareTo method just like String does.So your custom Comparator could look like this:The compare() method must return an int, so you couldn\'t directly return a boolean like you were planning to anyway.Your sorting code would be just about like you wrote:A slightly shorter way to write all this, if you don\'t need to reuse your comparator, is to write it as an inline anonymous class:You can now write the last example in a shorter form by using a lambda expression for the Comparator:And List has a sort(Comparator) method, so you can shorten this even further:This is such a common idiom that there\'s a built-in method to generate a Comparator for a class with a Comparable key:All of these are equivalent forms.Classes that has a natural sort order (a class Number, as an example) should implement the Comparable interface, whilst classes that has no natural sort order (a class Chair, as an example) should be provided with a Comparator (or an anonymous Comparator class).Two examples:Usage:For sorting an ArrayList you could use the following code snippet:Yes, you can.  There are two options with comparing items, the Comparable interface, and the Comparator interface.Both of these interfaces allow for different behavior.  Comparable allows you to make the object act like you just described Strings (in fact, String implements Comparable).  The second, Comparator, allows you to do what you are asking to do.  You would do it like this:That will cause the Collections.sort method to use your comparator for it\'s sorting mechanism.  If the objects in the ArrayList implement comparable, you can instead do something like this:The Collections class contains a number of these useful, common tools.With Java 8 you can use a method reference for your comparator:Since technologies appear everyday, the answer will change in the time. I took a look at LambdaJ and seems very interesting.You can try solving these tasks with LambdaJ. You can find it here: http://code.google.com/p/lambdaj/Here you have an example:Sort IterativeSort with lambdaOf course, having this kind of beauty impacts in the performance (an average of 2 times), but can you find a more readable code?You can use the Bean Comparator to sort on any property in your custom class.From Java 8 and onward we don\'t have to use Collections.sort() directly. List interface has a default sort() method:See http://visvv.blogspot.in/2016/01/sorting-objects-in-java-8.html.Best easy way with JAVA 8 is for English Alphabetic sortClass ImplementationSortIf you want to sort for alphabet that contains non English characters you can use Locale... Below code use Turkish character sort...Class ImplementationSortYou can try Guava Ordering:Yes, that\'s possible for instance  in this answer I sort by the property v of the class IndexValue If you notice here I\'m creating a anonymous inner class ( which is the Java for closures ) and passing it directly to the sort method of the class Arrays Your object may also implement Comparable ( that\'s what String and most of the core libraries in Java does ) but that would define the "natural sort order" of the class it self, and doesn\'t let you plug new ones.This code snippets might be useful. If you want to sort an Object\nin my case I want to sort by VolumeName:This works. I use it in my jsp.I found most if not all of these answers rely on the underlying class (Object) to implement comparable or to have a helper comparable interface.Not with my solution! The following code lets you compare object\'s field by knowing their string name. You could easily modify it not to use the name, but then you need to expose it or construct one of the Objects you want to compare against.With this library here you can sort the list of custom objects on multiple columns. The library uses version 8.0 features. Sample is also available there. Here is a sample to doJava 8 Lambda shortens the sort.You can Sort using  java 8You can have a look into this presentation hold at the Java Forum in Stuttgart Germany in 2016.Only a few slides use German language, 99% of the content is "English based" Java source code; likewhere OurCustomComparator is using default methods (and other interesting ideas). As shown, leading to very concise code to pick some getter method for sorting; and super simple chaining (or reversing) of sort criteria. If you are into java8, you find a lot of material there to get you started.your customComparator class must implement java.util.Comparator in order to be used.\nit must also overide compare() AND equals()compare() must answer the question:  Is object 1 less than, equal to or greater than object 2?full docs: http://java.sun.com/j2se/1.5.0/docs/api/java/util/Comparator.htmlI prefer this process:If you list of objects has a property called startDate, you call use this over and over.  You can even chain them startDate.time.This requires your object to be Comparable which means you need a compareTo, equals, and hashCode implementation.Yes, it could be faster... But now you don\'t have to make a new Comparator for each type of sort.  If you can save on dev time and give up on runtime, you might go with this one.For Java 8:orIt seems to work with String date type also like "2015-12-14T21:55:51Z"Another way isNew since 1.8 is a List.sort() method instead of using the Collection.sort()\nso you directly call  mylistcontainer.sort()Here is a code snippet which demonstrates the List.sort() feature:The Fruit class is:} // end of Fruit class   