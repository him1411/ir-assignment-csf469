What is the preferred syntax for defining enums in JavaScript? Something like:Or is there a more preferable idiom?This isn\'t much of an answer, but I\'d say that works just fine, personallyHaving said that, since it doesn\'t matter what the values are (you\'ve used 0, 1, 2), I\'d use a meaningful string in case you ever wanted to output the current value.UPDATE: Thanks for all the upvotes everyone, but I don\'t think my answer below is the best way to write enums in Javascript anymore. See my blog post for more details: Enums in Javascript.Alerting the name is already possible:Alternatively, you could make the values objects, so you can have the cake and eat it too:In Javascript, as it is a dynamic language, it is even possible to add enum values to the set later:Remember, the fields of the enum (value, name and code in this example) are not needed for the identity check and are only there for convenience. Also the name of the size property itself does not need to be hardcoded, but can also be set dynamically. So supposing you only know the name for your new enum value, you can still add it without problems:Of course this means that some assumptions can no longer be made (that value represents the correct order for the size for example). Remember, in Javascript an object is just like a map or hashtable. A set of name-value pairs. You can loop through them or otherwise manipulate them without knowing much about them in advance.E.G:And btw, if you are interested in namespaces, you may want to have a look at my solution for simple but powerful namespace and dependency management for javascript: Packages JSI can\'t post comment to THE answer, so I guess I\'d bump the thread since it shows up high in Google.Since 1.8.5 it\'s possible to seal and freeze the object, so define the above as:orand voila! JS enums ;)source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/freezeIMHO quotes aren\'t needed but I kept them for consistency.Bottom line: You can\'t. You can fake it, but you won\'t get type safety. Typically this is done by creating a simple dictionary of string values mapped to integer values. For example:The problem with this approach? You can accidentally redefine your enumerant, or accidentally have duplicate enumerant values. For example:Edit What about Artur Czajka\'s Object.freeze? Wouldn\'t that work to prevent you from setting monday to thursday? \xe2\x80\x93 Fry Quad Absolutely, Object.freeze would totally fix the problem I complained about. I would like to remind everyone that when I wrote the above, Object.freeze didn\'t really exist. Now.... now it opens up some very interesting possibilities. Edit 2\nHere\'s a very good library for creating enums. http://www.2ality.com/2011/10/enums.htmlWhile it probably doesn\'t fit every valid use of enums, it goes a very long way. Here\'s what we all want:Now you can create your enums:By doing this, constants can be acessed in the usual way (YesNo.YES, Color.GREEN) and they get a sequential int value (NO = 0, YES = 1; RED = 0, GREEN = 1, BLUE = 2).You can also add methods, by using Enum.prototype:\nEdit - small improvement - now with varargs: (unfortunately it doesn\'t work properly on IE :S... should stick with previous version then)I\'ve been playing around with this, as I love my enums. =)Using Object.defineProperty I think I came up with a somewhat viable solution.Here\'s a jsfiddle: http://jsfiddle.net/ZV4A6/Using this method.. you should (in theory) be able to call and define enum values for any object, without affecting other attributes of that object.Because of the attribute writable:false this should make it type safe.So you should be able to create a custom object, then call Enum() on it. The values assigned start at 0 and increment per item.In most modern browsers, there is a symbol primitive data type which can be used to create an enumeration. It will ensure type safety of the enum as each symbol value is guaranteed by JavaScript to be unique, i.e. Symbol() != Symbol(). For example:To simplify debugging, you can add a description to enum values:Plunker demoOn GitHub you can find a wrapper that simplifies the code required to initialize the enum:This is the solution that I use.And you define your enums like this:And this is how you access your enums:I usually use the last 2 methods for mapping enums from message objects.Some advantages to this approach:Some disadvantages:This is an old one I know, but the way it has since been implemented via the TypeScript interface is:This enables you to look up on both MyEnum.Bar which returns 1, and MyEnum[1] which returns "Bar" regardless of the order of declaration.If you\'re using Backbone, you can get full-blown enum functionality (find by id, name, custom members) for free using Backbone.Collection.Create an object literal:I\'ve modified the solution of Andre \'Fi\':Test:your answers are far too complicatedIn ES7 , you can do an elegant ENUM relying on static attributes: then The advantage ( of using class instead of literal object) is to have a parent class Enum then all your Enums will extends that class.  IE8 does Not support freeze() method.\nSource: http://kangax.github.io/compat-table/es5/, Click on "Show obsolete browsers?" on top, and check IE8 & freeze row col intersection.In my current game project, I have used below, since few customers still use IE8:We could also do:  or even this:  The last one, seems most efficient for string, it reduces your total bandwidth if you have server & client exchanging this data.\nOf course, now it\'s your duty to make sure there are no conflicts in the data (RE, EX, etc. must be unique, also 1, 2, etc. should be unique). Note that you need to maintain these forever for backward compatibility.  Assignment:Comparision:I\'ve made an Enum class that can fetch values AND names at O(1). It can also generate an Object Array containing all Names and Values.You can init\'d it like this:To fetch a value (like Enums in C#):To fetch a name for a value (can be ambiguous when putting the same value for different names):To get an array with each name & value in an object:Will generate:You can also get the html select options readily:Which holds:A quick and simple way would be :I came up with this approach which is modeled after enums in Java. These are type-safe, and so you can perform instanceof checks as well.You can define enums like this:Days now refers to the Days enum:The implementation:Even though only static methods (and not static properties) are supported in ES2015 (see here as well, ยง15.2.2.2), curiously you can use the below with Babel with the es2015 preset:I found this to be working as expected even across modules (e.g. importing the CellState enum from another module) and also when I import a module using Webpack.The advantage this method has over most other answers is that you can use it alongside a static type checker (e.g. Flow) and you can assert, at development time using static type checking, that your variables, parameters, etc. are of the specific CellState "enum" rather than some other enum (which would be impossible to distinguish if you used generic objects or symbols).The above code has a deficiency in that it allows one to create additional objects of type CellState (even though one can\'t assign them to the static fields of CellState since it\'s frozen). Still, the below more refined code offers the following advantages:the values function that returns all instances of the enum does not have to create the return value in the above, manual (and error-prone) way.As of writing, October 2014 - so here is a contemporary solution. Am writing the solution as a Node Module, and have included a test using Mocha and Chai, as well as underscoreJS. You can easily ignore these, and just take the Enum code if preferred.Seen a lot of posts with overly convoluted libraries etc. The solution to getting enum support in Javascript is so simple it really isn\'t needed. Here is the code:File: enums.jsAnd a test to illustrate what it gives you:file: enumsSpec.jsAs you can see, you get an Enum factory, you can get all the keys simply by calling enum.keys, and you can match the keys themselves to integer constants. And you can reuse the factory with different values, and export those generated Enums using Node\'s modular approach. Once again, if you are just a casual user, or in the browser etc, just take the factory part of the code, potentially removing underscore library too if you don\'t wish to use it in your code.Here\'s a couple different ways to implement TypeScript enums.The easiest way is to just iterate over an object, adding inverted key-value pairs to the object. The only drawback is that you must manually set the value for each member.\nAnd here\'s a lodash mixin to create an enum using a string. While this version is a little bit more involved, it does the numbering automatically for you. All the lodash methods used in this example have a regular JavaScript equivalent, so you can easily switch them out if you want.I\'ve just published an NPM package gen_enum allows you to create Enum data structure in Javascript quickly:One nice thing about this little tool is in modern environment (including nodejs and IE 9+ browsers) the returned Enum object is immutable.For more information please checkout https://github.com/greenlaw110/enumjsUpdatesI obsolete gen_enum package and merge the function into constjs package, which provides more features including immutable objects, JSON string deserialization, string constants and bitmap generation etc. Checkout https://www.npmjs.com/package/constjs for more information To upgrade from gen_enum to constjs just change the statementtoYou can do something like thisAs defined in this library.\nhttps://github.com/webmodule/foo/blob/master/foo.js#L217I had done it a while ago using a mixture of __defineGetter__ and __defineSetter__ or defineProperty depending on the JS version.Here\'s the enum generating function I made: https://gist.github.com/gfarrell/6716853You\'d use it like this:And it would create an immutable string:int dictionary (an enum).You don\'t need to make sure you don\'t assign duplicate numbers to different enum values this way. A new object gets instantiated and assigned to all enum values.It\'s easy to use, I think. https://stackoverflow.com/a/32245370/4365315UPDATE:There is my helper codes(TypeHelper).I wrote enumerationjs a very tiny library to address the issue which ensures type safety, allow enum constants to inherit from a prototype, guaranties enum constants and enum types to be immutable + many little features. It allows to refactor a lot of code and move some logic inside the enum definition. Here is an example : Enumeration is basically a factory. Fully documented guide available here. Hope this helps. Simplest solution:Really like what @Duncan did above, but I don\'t like mucking up global Object function space with Enum, so I wrote the following:@Stijin also has a neat solution (referring to his blog) which includes properties on these objects. I wrote some code for that, too, which I\'m including next.This version produces an additional property list allowing friendly name conversion and short codes.  I like this version because one need not duplicate data entry in properties as the code does it for you.These two can be combined into a single processing unit, mkenum, (consume enums, assign values, create and add property list).  However, as I\'ve spent far too much time on this today already, I will leave the combination as an exercise for the dear reader.What is an enum in my opinion: It\'s an immutable object that is always accessible and you can compare items with eachother, but the items have common properties/methods, but the objects themselves or the values cannot be changed and they are instantiated only once.Enums are imho used for comparing datatypes, settings, actions to take/reply things like that. So for this you need objects with the same instance so you can check if it is a enum type if(something instanceof enum)\nAlso if you get an enum object you want to be able to do stuff with it, regardless of the enum type, it should always respond in the same way.In my case its comparing values of datatypes, but it could be anything, from modifying blocks in facing direction in a 3d game to passing values on to a specific object type registry.Keeping in mind it is javascript and doesn\'t provide fixed enum type, you end up always making your own implementation and as this thread shows there are legions of implementations without one being the absoulte correct.This is what I use for Enums. Since enums are immutable(or should be at least heh) I freeze the objects so they can\'t be manipulated easely.The enums can be used by EnumField.STRING and they have their own methods that will work with their types.\nTo test if something passed to an object you can use if(somevar instanceof EnumFieldSegment)It may not be the most elegant solution and i\'m open for improvements, but this type of immutable enum(unless you unfreeze it) is exactly the usecase I needed.I also realise I could have overridden the prototype with a {} but my mind works better with this format ;-) shoot me.