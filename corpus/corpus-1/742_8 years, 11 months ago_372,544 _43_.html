We all know you can\'t do this:ConcurrentModificationException etc... this apparently works sometimes, but not always. Here\'s some specific code:This, of course, results in:... even though multiple threads aren\'t doing it... Anyway.What\'s the best solution to this problem? How can I remove an item from the collection in a loop without throwing this exception?I\'m also using an arbitrary Collection here, not necessarily an ArrayList, so you can\'t rely on get.Iterator.remove() is safe, you can use it like this:Note that Iterator.remove is the only safe way to modify a collection during iteration; the behavior is unspecified if the underlying collection is modified in any other way while the iteration is in progress.Source:http://docs.oracle.com/javase/tutorial/collections/interfaces/collection.htmlAnd similarly, if you have a ListIterator and want to add items, you can use ListIterator#add, for the same reason you can use Iterator#remove — it\'s designed to allow it.Silly me:I assumed that since a foreach loop is syntactic sugar for iterating, using an iterator wouldn\'t help... but it gives you this .remove() functionality.With Java 8 you can use the new removeIf method. Applied to your example:Since the question has been already answered i.e. the best way is to use the remove method of the iterator object, I would go into the specifics of the place where the error "java.util.ConcurrentModificationException" is thrown.Every collection class has a private class which implements the Iterator interface and provides methods like next(), remove() and hasNext().The code for next looks something like this...Here the method checkForComodification is implemented as So, as you can see, if you explicitly try to remove an element from the collection. It results in modCount getting different from expectedModCount, resulting in the exception ConcurrentModificationException.You can either use the iterator directly like you mentioned, or else keep a second collection and add each item you want to remove to the new collection, then removeAll at the end. This allows you to keep using the type-safety of the for-each loop at the cost of increased memory use and cpu time (shouldn\'t be a huge problem unless you have really, really big lists or a really old computer)In such cases a common trick is (was?) to go backwards:That said, I\'m more than happy that you have better ways in Java 8, e.g. removeIf or filter on streams.Same answer as Claudius with a for loop:With Eclipse Collections (formerly GS Collections), the method removeIf defined on MutableCollection will work:With Java 8 Lambda syntax this can be written as follows:The call to Predicates.cast() is necessary here because a default removeIf method was added on the java.util.Collection interface in Java 8. Note: I am a committer for Eclipse Collections.Make a copy of existing list and iterate over new copy.With a traditional for loopI have a suggestion for the problem above. No need of secondary list or any extra time. Please find an example which would do the same stuff but in a different way.\nThis would avoid the Concurrency Exception.In case ArrayList:remove(int index)- if(index is last element\'s position) it avoids without System.arraycopy() and takes not time for this.arraycopy time increases if(index decreases), by the way elements of list also decreases!the best effective remove way is- removing its elements in descending order:\nwhile(list.size()>0)list.remove(list.size()-1);//takes O(1)\nwhile(list.size()>0)list.remove(0);//takes O(factorial(n))ConcurrentHashMap or ConcurrentLinkedQueue or ConcurrentSkipListMap may be another option, because they will never throw any ConcurrentModificationException, even if you remove or add item.The catch is the after removing the element from the list if you skip the internal iterator.next() call. it still works! Though I dont propose to write code like this it helps to understand the concept behind it :-)Cheers!In addition to @assylias answer you can also use the new Stream api if you use Java 8:If you invert the condition, the solution is even more concise since you do not need to negate() the predicate, thus allowing you to use just the method reference:One of the beauties of this is that the stream is lazily evaluated, i.e. filter() operation is not actually evaluated until it is used by a terminal operation such as forEach(). More on this can be found in Oracle\'s Tutorial.this might not be the best way, but for most of the small cases this should acceptable:"create a second empty-array and add only the ones you want to keep"I don\'t remeber where I read this from... for justiness I will make this wiki in hope someone finds it or just to don\'t earn rep I don\'t deserve.