As a C# developer I\'m used to run through constructors:Is there a way to do this in C++?I tried calling the Class name and using the \'this\' keyword, but both fails.C++11: Yes!C++11 and onwards has this same feature (called delegating constructors). The syntax is slightly different from C#:C++03: NoUnfortunately there\'s no way to do this in C++03, but there are two ways of simulating this:You can combine two (or more) constructors via default parameters:Use an init method to share common code:See the C++FAQ entry for reference.No, you can\'t call one constructor from another in C++03 (called a delegating constructor).This changed in C++11 (aka C++0x), which added support for the following syntax:\n(example taken from Wikipedia)I believe you can call a constructor from a constructor. It will compile and run. I recently saw someone do this and it ran on both Windows and Linux.It just doesn\'t do what you want. The inner constructor will construct a temporary local object which gets deleted once the outer constructor returns. They would have to be different constructors as well or you would create a recursive call.Ref: https://isocpp.org/wiki/faq/ctors#init-methodsIt is worth pointing out that you can call the constructor of a parent class in your constructor, e.g.:But, no, you can\'t call another constructor of the same class.In C++11, a constructor can call another constructor overload:Additionally, members can be initialized like this as well.This should eliminate the need to create the initialization helper method. And it is still recommended not calling any virtual functions in the constructors or destructors to avoid using any members that might not be initialized.If you want to be evil, you can use the in-place "new" operator:Seems to work for me.editAs @ElvedinHamzagic points out, if Foo contained an object which allocated memory, that object might not be freed.  This complicates things further.A more general example:Looks a bit less elegant, for sure. @JohnIdol\'s solution is much better.No, in C++ you cannot call a constructor from a constructor. What you can do, as warren pointed out, is:Note that in the first case, you cannot reduce code duplication by calling one constructor from another. You can of course have a separate, private/protected, method that does all the initialization, and let the constructor mainly deal with argument handling.In Visual C++ you can also use this notation inside constructor: this->Classname::Classname(parameters of another constructor). See an example below:I don\'t know whether it works somewhere else, I only tested it in Visual C++ 2003 and 2008. You may also call several constructors this way, I suppose, just like in Java and C#.P.S.: Frankly, I was surprised that this was not mentioned earlier.If I understand your question correctly, you\'re asking if you can call multiple constructors in C++?If that\'s what you\'re looking for, then no - that is not possible.You certainly can have multiple constructors, each with unique argument signatures, and then call the one you want when you instantiate a new object.You can even have one constructor with defaulted arguments on the end.But you may not have multiple constructors, and then call each of them separately.Another option that has not been shown yet is to split your class into two, wrapping a lightweight interface class around your original class in order to achieve the effect you are looking for:This could get messy if you have many constructors that must call their "next level up" counterpart, but for a handful of constructors, it should be workable.I would propose the use of a private friend method which implements the application logic of the constructor and is the called by the various constructors. Here is an example:Assume we have a class called StreamArrayReader with some private fields:And we want to define the two constructors:Where the second one simply makes use of the first one (and of course we don\'t want to duplicate the implementation of the former). Ideally, one would like to do something like:However, this is not allowed in C++. For that reason, we may define a private friend method as follows which implements what the first constructor is supposed to do:Now this method (because it\'s a friend) has access to the private fields of o. Then, the first constructor becomes:Note that this does not create multiple copies for the newly created copies. The second one becomes:That is, instead of having one constructor calling another, both call a private friend!When calling a constructor it actually allocates memory, either from the stack or from the heap. So calling a constructor in another constructor creates a local copy. So we are modifying another object, not the one we are focusing on.This approach may work for some kinds of classes (when the assignment operator behaves \'well\'):Would be more easy to test, than decide :)\nTry this:and compile it with 98 std:\n    g++ main.cpp -std=c++98  -o test_1 you will see:so :)