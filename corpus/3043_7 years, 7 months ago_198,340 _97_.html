Why is it not possible to override static methods?If possible, please use an example.Overriding depends on having an instance of a class. The point of polymorphism is that you can subclass a class and the objects implementing those subclasses will have different behaviors for the same methods defined in the superclass (and overridden in the subclasses). A static method is not associated with any instance of a class so the concept is not applicable.There were two considerations driving Java\'s design that impacted this. One was a concern with performance: there had been a lot of criticism of Smalltalk about it being too slow (garbage collection and polymorphic calls being part of that) and Java\'s creators were determined to avoid that. Another was the decision that the target audience for Java was C++ developers. Making static methods work the way they do had the benefit of familiarity for C++ programmers and was also very fast, because there\'s no need to wait until runtime to figure out which method to call.Personally I think this is a flaw in the design of Java. Yes, yes, I understand that non-static methods are attached to an instance while static methods are attached to a class, etc etc. Still, consider the following code:This code will not work as you might expect. Namely, SpecialEmployee\'s get a 2% bonus just like regular employees. But if you remove the "static"s, then SpecialEmployee\'s get a 3% bonus.(Admittedly, this example is poor coding style in that in real life you would likely want the bonus multiplier to be in a database somewhere rather than hard-coded. But that\'s just because I didn\'t want to bog down the example with a lot of code irrelevant to the point.)It seems quite plausible to me that you might want to make getBonusMultiplier static. Perhaps you want to be able to display the bonus multiplier for all the categories of employees, without needing to have an instance of an employee in each category. What would be the point of searching for such example instances? What if we are creating a new category of employee and don\'t have any employees assigned to it yet? This is quite logically a static function.But it doesn\'t work.And yes, yes, I can think of any number of ways to rewrite the above code to make it work. My point is not that it creates an unsolvable problem, but that it creates a trap for the unwary programmer, because the language does not behave as I think a reasonable person would expect.Perhaps if I tried to write a compiler for an OOP language, I would quickly see why implementing it so that static functions can be overriden would be difficult or impossible. Or perhaps there is some good reason why Java behaves this way. Can anyone point out an advantage to this behavior, some category of problem that is made easier by this? I mean, don\'t just point me to the Java language spec and say "see, this is documented how it behaves". I know that. But is there a good reason why it SHOULD behave this way? (Besides the obvious "making it work right was too hard"...)Update@VicKirk: If you mean that this is "bad design" because it doesn\'t fit how Java handles statics, my reply is, "Well, duh, of course." As I said in my original post, it doesn\'t work. But if you mean that it is bad design in the sense that there would be something fundamentally wrong with a language where this worked, i.e. where statics could be overridden just like virtual functions, that this would somehow introduce an ambiguity or it would be impossible to implement efficiently or some such, I reply, "Why? What\'s wrong with the concept?"I think the example I give is a very natural thing to want to do. I have a class that has a function that does not depend on any instance data, and which I might very reasonably want to call independent of an instance, as well as wanting to call from within an instance method. Why should this not work? I\'ve run into this situation a fair number of times over the years. In practice I get around it by making the function virtual, and then creating a static method whose only purpose in life is to be a static method that passes the call on to the virtual method with a dummy instance. That seems like a very roundabout way to get there.The short answer is: it is entirely possible, but Java doesn\'t do it.Here is some code which illustrates the current state of affairs in Java:File Base.java:File Child.java:If you run this (I did it on a Mac, from Eclipse, using Java 1.6) you get:Here, the only cases which might be a surprise (and which the question is about) appear to be the first case:"The run-time type is not used to determine which static methods are called, even when called with an object instance (obj.staticMethod())."and the last case:"When calling a static method from within an object method of a class, the static method chosen is the one accessible from the class itself and not from the class defining the run-time type of the object."The static call is resolved at compile-time, whereas a non-static method call is resolved at run-time.  Notice that although static methods are inherited (from parent) they are not overridden (by child).  This could be a surprise if you expected otherwise.Object method calls are resolved using the run-time type, but static (class) method calls are resolved using the compile-time (declared) type.To change these rules, so that the last call in the example called Child.printValue(), static calls would have to be provided with a type at run-time, rather than the compiler resolving the call at compile-time with the declared class of the object (or context). Static calls could then use the (dynamic) type hierarchy to resolve the call, just as object method calls do today.This would easily be doable (if we changed Java :-O), and is not at all unreasonable, however, it has some interesting considerations.The main consideration is that we need to decide which static method calls should do this.At the moment, Java has this "quirk" in the language whereby obj.staticMethod() calls are replaced by ObjectClass.staticMethod() calls (normally with a warning). [Note: ObjectClass is the compile-time type of obj.] These would be good candidates for overriding in this way, taking the run-time type of obj.If we did it would make method bodies harder to read: static calls in a parent class could potentially be dynamically "re-routed".  To avoid this we would have to call the static method with a class name -- and this makes the calls more obviously resolved with the compile-time type hierarchy (as now).The other ways of invoking a static method are more tricky: this.staticMethod() should mean the same as obj.staticMethod(), taking the run-time type of this.  However, this might cause some headaches with existing programs, which call (apparently local) static methods without decoration (which is arguably equivalent to this.method()).So what about unadorned calls staticMethod()?  I suggest they do the same as today, and use the local class context to decide what to do.  Otherwise great confusion would ensue.  Of course it means that method() would mean this.method() if method was a non-static method, and ThisClass.method() if method were a static method.  This is another source of confusion.If we changed this behaviour (and made static calls potentially dynamically non-local), we would probably want to revisit the meaning of final, private and protected as qualifiers on static methods of a class.  We would then all have to get used to the fact that private static and public final methods are not overridden, and can therefore be safely resolved at compile-time, and are "safe" to read as local references.Actually we were wrong.\nDespite Java doesn\'t allow you to override static methods by default, if you look thoroughly through documentation of Class and Method classes in Java, you can still find a way to emulate static methods overriding by following workaround:Resulting output:what we were trying to achieve :)Even if we declare third variable Carl as RegularEmployee and assign to it instance of SpecialEmployee, we will still have call of RegularEmployee method in first case and call of SpecialEmployee method in second casejust look at output console:;)Static methods are treated as global by the JVM, there are not bound to an object instance at all.It could conceptually be possible if you could call static methods from class objects (like in languages like Smalltalk) but it\'s not the case in Java. EDITYou can overload static method, that\'s ok. But you can not override a static method, because class are no first-class object. You can use reflection to get the class of an object at run-time, but the object that you get does not parallel the class hierarchy. You can reflect over the classes, but it stops there. You don\'t invoke a static method by using clazz1.staticMethod(), but using MyClass.staticMethod(). A static method is not bound to an object and there is hence no notion of this nor super in a static method. A static method is a global function; as a consequence there is also no notion of polymorphism and, therefore, method overriding makes no sense. But this could be possible if MyClass was an object at run-time on which you invoke a method, as in Smalltalk (or maybe JRuby as one comment suggest, but I know nothing of JRuby).Oh yeah... one more thing. You can invoke a static method through an object obj1.staticMethod() but that really syntactic sugar for MyClass.staticMethod() and should be avoided. It usually raises a warning in modern IDE. I don\'t know why they ever allowed this shortcut.Method overriding is made possible by dynamic dispatching, meaning that the declared type of an object doesn\'t determine its behavior, but rather its runtime type:Even though both lassie and kermit are declared as objects of type Animal, their behavior (method .speak()) varies because dynamic dispatching will only bind the method call .speak() to an implementation at run time - not at compile time.Now, here\'s where the static keyword starts to make sense: the word "static" is an antonym for "dynamic". So the reason why you can\'t override static methods is because there is no dynamic dispatching on static members - because static literally means "not dynamic". If they dispatched dynamically (and thus could be overriden) the static keyword just wouldn\'t make sense anymore.In Java (and many OOP languages, but I cannot speak for all; and some do not have static at all) all methods have a fixed signature - the parameters and types. In a virtual method, the first parameter is implied: a reference to the object itself and when called from within the object, the compiler automatically adds this.There is no difference for static methods - they still have a fixed signature. However, by declaring the method static you have explicitly stated that the compiler must not include the implied object parameter at the beginning of that signature. Therefore, any other code that calls this must must not attempt to put a reference to an object on the stack. If it did do that, then the method execution would not work since the parameters would be in the wrong place - shifted by one - on the stack.Because of this difference between the two; virtual methods always have a reference to the context object (i.e. this) so then it is possible to reference anything within the heap that belong to that instance of the object. But with static methods, since there is no reference passed, that method cannot access any object variables and methods since the context is not known.If you wish that Java would change the definition so that a object context is passed in for every method, static or virtual, then you would in essence have only virtual methods. As someone asked in a comment to the op - what is your reason and purpose for wanting this feature?I do not know Ruby much, as this was mentioned by the OP, I did some research. I see that in Ruby classes are really a special kind of object and one can create (even dynamically) new methods. Classes are full class objects in Ruby, they are not in Java. This is just something you will have to accept when working with Java (or C#). These are not dynamic languages, though C# is adding some forms of dynamic. In reality, Ruby does not have "static" methods as far as I could find - in that case these are methods on the singleton class object. You can then override this singleton with a new class and the methods in the previous class object will call those defined in the new class (correct?). So if you called a method in the context of the original class it still would only execute the original statics, but calling a method in the derived class, would call methods either from the parent or sub-class. Interesting and I can see some value in that. It takes a different thought pattern.Since you are working in Java, you will need to adjust to that way of doing things. Why they did this? Well, probably to improve performance at the time based on the technology and understanding that was available. Computer languages are constantly evolving. Go back far enough and there is no such thing as OOP. In the future, there will be other new ideas.EDIT: One other comment. Now that I see the differences and as I Java/C# developer myself, I can understand why the answers you get from Java developers may be confusing if you are coming from a language like Ruby. Java static methods are not the same as Ruby class methods. Java developers will have a hard time understanding this, as will conversely those who work mostly with a language like Ruby/Smalltalk. I can see how this would also be greatly confusing by the fact that Java also uses "class method" as another way to talk about static methods but this same term is used differently by Ruby. Java does not have Ruby style class methods (sorry); Ruby does not have Java style static methods which are really just old procedural style functions, as found in C.By the way - thanks for the question! I learned something new for me today about class methods (Ruby style).In general it doesn\'t make sense to allow \'overriding\' of static methods as there would be no good way to determine which one to call at runtime. Taking the Employee example, if we call RegularEmployee.getBonusMultiplier() - which method is supposed to be executed?In the case of Java, one could imagine a language definition where it is possible to \'override\' static methods as long as they are called through an object instance. However, all this would do is to re-implement regular class methods, adding redundancy to the language without really adding any benefit.overriding is reserved for instance members to support polymorphic behaviour. static class members do not belong to a particular instance. instead, static members belong to the class and as a result overriding is not supported because subclasses only inherit protected and public instance members and not static members. You may want to define an inerface and research factory and/or strategy design patterns to evaluate an alternate approach.Well... the answer is NO if you think from the perspective of how an overriden method should behave in Java. But, you don\'t get any compiler error if you try to override a static method. That means, if you try to override, Java doesn\'t stop you doing that; but you certainly don\'t get the same effect as you get for non-static methods. Overriding in Java simply means that the particular method would be called based on the run time type of the object and not on the compile time type of it (which is the case with overriden static methods). Okay... any guesses for the reason why do they behave strangely? Because they are class methods and hence access to them is always resolved during compile time only using the compile time type information. Accessing them using object references is just an extra liberty given by the designers of Java and we should certainly not think of stopping that practice only when they restrict it :-)Example: let\'s try to see what happens if we try overriding a static method:-Output:-\nSuperClass: inside staticMethod \nSuperClass: inside staticMethod \nSubClass: inside staticMethodNotice the second line of the output. Had the staticMethod been overriden this line should have been identical to the third line as we\'re invoking the \'staticMethod()\' on an object of Runtime Type as \'SubClass\' and not as \'SuperClass\'. This confirms that the static methods are always resolved using their compile time type information only.I like and double Jay\'s comment (https://stackoverflow.com/a/2223803/1517187).\nI agree that this is bad design of Java.\nMany other languages support overriding static methods, as we see in previous comments.\nI feel Jay has also come to Java from Delphi like me.\nDelphi (Object Pascal) was the first language implementing OOP.\nIt is obvious that many people had experience with that language, since it was in the past the only language to write commercial GUI products. And - yes, we could in Delphi override static methods. Actually, static methods in Delphi are called "class methods", while Delphi had different concept of "Delphi static methods" which were methods with early binding. To override methods you had to use late binding, declare "virtual" directive. So it was very convenient and intuitive and I would expect this in Java.By overriding we can create a polymorphic nature depending on the object type. Static method has no relation with object. So java can not support static method overriding.Overriding in Java simply means that the particular method would be called based on the run time type \nof the object and not on the compile time type of it (which is the case with overriden static methods). As static methods are class methods they are notinstance methods so they have nothing to do with the fact which reference is pointing to which Object or instance.as per the nature of static method it belongs to specific class, but you can redeclare it in to the subclass but that subclass doesn\'t know anything about the parent class\' static methods because as I said it is specific  to only that class in which it has been declared .Accessing them using object references is just an extra liberty given by the designers of Java and we should certainly not think of stopping that practice only when they restrict it\nmore details and example\nhttp://faisalbhagat.blogspot.com/2014/09/method-overriding-and-method-hiding.htmlAnswer of this question is simple, the method or variable marked as static belongs to the class only, So that static method cannot be inherited in the sub class because they belong to the super class only.What good will it do to override static methods. You cannot call static methods through an instance.EDIT : It appears that through an unfortunate oversight in language design, you can call static methods through an instance. Generally nobody does that. My bad.By overriding, you achieve dynamic polymorhpism.\nWhen you say overridng static methods, the words you are trying to use are contradictory.Static says - compile time, overriding is used for dynamic polymorphism.\nBoth are opposite in nature, and hence can\'t be used together.Dynamic polymorhpic behavior comes when programmer uses an object and accessing an instance method. JRE will map different instance methods of different classes based on what kind of object you are using.When you say overriding static methods, static methods we will access by using class name, which will be linked at compile time, so there is no concept of linking methods at run time with static methods. So the term "overriding" static methods itself doesn\'t make any meaning.Note: even if you access a class method with an object, still java compiler is intelligent enough to find it out, and will do static linking.Easy solution: Use singleton instance. It will allow overrides and inheritance. In my system, I have SingletonsRegistry class, which returns instance for passed Class. If instance is not found, it is created.Haxe language class:Here is a simple explanation.A static method is associated with a class while an instance method is associated with a particular object.Overrides allow to call different implementation of the overridden methods associated with the particular object. So it is counter-intuitive to override static method which is not even associated with objects but class itself in the first place.So static methods cannot be overridden based on what object is calling it, it will always be associated with the class where it was created.A Static method, variable, block or nested class belongs to the entire class rather than an object.A Method in Java is used to expose the behaviour of an Object / Class. Here, as the method is static (i.e, static method is used to represent the behaviour of a class only.) changing/ overriding the behaviour of entire class will violate the phenomenon of one of the fundamental pillar of Object oriented programming i.e, high cohesion. (remember a constructor is a special kind of method in Java.)High Cohesion - One class should have only one role. For example: A car class should produce only car objects and not bike, trucks, planes etc. But the Car class may have some features(behaviour) that belongs to itself only.Therefore, while designing the java programming language. The language designers thought to allow developers to keep some behaviours of a class to itself only by making a method static in nature. The below piece code tries to override the static method, but will not encounter any compilation error.This is because, here we are not overriding a method but we are just re-declaring it. Java allows re-declaration of a method (static/non-static).Removing the static keyword from getVehileNumber() method of Car class will result into compilation error, Since, we are trying to change the functionality of static method which belongs to Vehicle class only.Also, If the getVehileNumber() is declared as final then the code will not compile, Since the final keyword restricts the programmer from re-declaring the method.Overall, this is upto software designers for where to use the static methods.\nI personally prefer to use static methods to perform some actions without creating any instance of a class. Secondly, to hide the behaviour of a class from outside world.Now seeing above answers everyone knows that we can\'t override static methods, but one should not misunderstood about the concept of accessing static methods from subclass.We can access static methods of super class with subclass reference if this static method has not been hidden by new static method defined in sub class.For Example, see below code:-Output:-See  Java oracle docs  and search for What You Can Do in a Subclass for details about hiding of static methods in sub class.ThanksThe following code shows that it is possible:  