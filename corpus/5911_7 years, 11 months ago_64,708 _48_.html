I know there are a plethora of $_SERVER variables headers available for IP address retrieval. I was wondering if there is a general consensus as to how to most accurately retrieve a user\'s real IP address (well knowing no method is perfect) using said variables?I spent some time trying to find an in depth solution and came up with the following code based on a number of sources. I would love it if somebody could please poke holes in the answer or shed some light on something perhaps more accurate.edit includes optimizations from @AlixREMOTE_ADDR still represents the most reliable source of an IP address. The other $_SERVER variables mentioned here can be spoofed by a remote client very easily. The purpose of this solution is to attempt to determine the IP address of a client sitting behind a proxy. For your general purposes, you might consider using this in combination with the IP address returned directly from $_SERVER[\'REMOTE_ADDR\'] and storing both.For 99.9% of users this solution will suit your needs perfectly. It will not protect you from the 0.1% of malicious users looking to abuse your system by injecting their own request headers. If relying on IP addresses for something mission critical, resort to REMOTE_ADDR and don\'t bother catering to those behind a proxy.Here is a shorter, cleaner way to get the IP address:I hope it helps!Your code seems to be pretty complete already, I cannot see any possible bugs in it (aside from the usual IP caveats), I would change the validate_ip() function to rely on the filter extension though:Also your HTTP_X_FORWARDED_FOR snippet can be simplified from this:To this:You may also want to validate IPv6 addresses.Even then however, getting a user\'s real IP address is going to be unreliable. All they need to do is use an anonymous proxy server (one that doesn\'t honor the headers for http_x_forwarded_for, http_forwarded, etc) and all you get is their proxy server\'s IP address.You can then see if there is a list of proxy server IP addresses that are anonymous, but there is no way to be sure that is 100% accurate as well and the most it\'d do is let you know it is a proxy server. And if someone is being clever, they can spoof headers for HTTP forwards.Let\'s say I don\'t like the local college. I figure out what IP addresses they registered, and get their IP address banned on your site by doing bad things, because I figure out you honor the HTTP forwards. The list is endless.Then there is, as you guessed, internal IP addresses such as the college network I metioned before. A lot use a 10.x.x.x format. So all you would know is that it was forwarded for a shared network.Then I won\'t start much into it, but dynamic IP addresses are the way of broadband anymore. So. Even if you get a user IP address, expect it to change in 2 - 3 months, at the longest.We use:The explode on HTTP_X_FORWARDED_FOR is because of weird issues we had detecting IP addresses when Squid was used.The biggest question is for what purpose?Your code is nearly as comprehensive as it could be - but I see that if you spot what looks like a proxy added header, you use that INSTEAD of the CLIENT_IP, however if you want this information for audit purposes then be warned - its very easy to fake.Certainly you should never use IP addresses for any sort of authentication - even these can be spoofed.You could get a better measurement of the client ip address by pushing out a flash or java applet which connects back to the server via a non-http port (which would therefore reveal transparent proxies or cases where the proxy-injected headers are false - but bear in mind that, where the client can ONLY connect via a web proxy or the outgoing port is blocked, there will be no connection from the applet.C.Just a VB.NET version of the answer:i realize there are much better and more concise answers above, and this isnt a function nor the most graceful script around. In our case we needed to output both the spoofable x_forwarded_for and the more reliable remote_addr in a simplistic switch per-say. It needed to allow blanks for injecting into other functions if-none or if-singular (rather than just returning the preformatted function). It needed an "on or off" var with a per-switch customized label(s) for platform settings. It also needed a way for $ip to be dynamic depending on request so that it would take form of forwarded_for.Also i didnt see anyone address isset() vs !empty() -- its possible to enter nothing for x_forwarded_for yet still trigger isset() truth resulting in blank var, a way to get around is to use && and combine both as conditions. Keep in mind you can spoof words like "PWNED" as x_forwarded_for so make sure you sterilize to a real ip syntax if your outputting somewhere protected or into DB.Also also, you can test using google translate if you need a multi-proxy to see the array in x_forwarder_for. If you wanna spoof headers to test, check this out Chrome Client Header Spoof extension. This will default to just standard remote_addr while behind anon proxy.I dunno any case where remote_addr could be empty, but its there as fallback just in case.To make these dynamic for use in function(s) or query/echo/views below, say for log gen or error reporting, use globals or just echo em in wherever you desire without making a ton of other conditions or static-schema-output functions.Thank you for all your great thoughts. Please let me know if this could be better, still kinda new to these headers :)I came up with this function that does not simply return the IP address but an array with IP information.Here\'s the function:I do wonder if perhaps you should iterate over the exploded HTTP_X_FORWARDED_FOR in reverse order, since my experience has been that the user\'s IP address ends up at the end of the comma-separated list, so starting at the start of the header, you\'re more likely to get the ip address of one of the proxies returned, which could potentially still allow session hijacking as many users may come through that proxy.Thanks for this, very useful.It would help though if the code were syntactically correct. As it is there\'s a { too many around line 20. Which I\'m afraid means nobody actually tried this out.I may be crazy, but after trying it on a few valid and invalid addresses, the only version of validate_ip() that worked was this:Here\'s a modified version if you use CloudFlare caching layer ServicesJust another clean way:From Symfony\'s Request class\nhttps://github.com/symfony/symfony/blob/1bd125ec4a01220878b3dbc3ec3156b073996af9/src/Symfony/Component/HttpFoundation/Request.phpAs someone said previously, the key here is for what reason you want to store user\'s ips.I\'ll give an example from a registration system I work on and of course the solution just to contribute sth in this old discussion that comes frequently in my searches.Many php registration libraries use ip to throttle/lock out failed attempts based on user\'s ip.\nConsider this table:Then, when a user tries to do a login or anything related with servicing like a password reset, a function is called at the start:Say, for example, $this->token->get(\'attempts_before_ban\') === 10 and 2 users come for the same ips as is the case in the previous codes where headers can be spoofed, then after 5 attempts each both are banned!\nEven worst, if all come from the same proxy then only the first 10 users will be logged and all the rest will be banned!The critical here is that we need a unique index on table attempts and we can get it from a combination like:where jwt_load comes from a http cookie that follows the json web token technology where we store only the encrypted payload that should contain an arbitrary/unique value for every user.\nOf course the request should be modified to: "SELECT count(*) FROM {$this->token->get(\'table_attempts\')} WHERE ip = ? AND jwt_load = ?" and the class should also initiate a private $jwt.You pretty much answered your own question! :)Source