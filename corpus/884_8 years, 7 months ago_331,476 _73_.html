There are some data structures around that are really useful but are unknown to most programmers. Which ones are they?Everybody knows about linked lists, binary trees, and hashes, but what about Skip lists and Bloom filters for example. I would like to know more data structures that are not so common, but are worth knowing because they rely on great ideas and enrich a programmer\'s tool box.PS: I am also interested in techniques like Dancing links which make clever use of properties of a common data structure. EDIT:\nPlease try to include links to pages describing the data structures in more detail. Also, try to add a couple of words on why a data structure is cool (as Jonas K\xc3\xb6lker already pointed out).  Also, try to provide one data-structure per answer. This will allow the better data structures to float to the top based on their votes alone.Tries, also known as prefix-trees or crit-bit trees, have existed for over 40 years but are still relatively unknown.  A very cool use of tries is described in "TRASH - A dynamic LC-trie and hash data structure", which combines a trie with a hash function.Bloom filter: Bit array of m bits, initially all set to 0. To add an item you run it through k hash functions that will give you k indices in the array which you then set to 1. To check if an item is in the set, compute the k indices and check if they are all set to 1. Of course, this gives some probability of false-positives (according to wikipedia it\'s about 0.61^(m/n) where n is the number of inserted items). False-negatives are not possible.Removing an item is impossible, but you can implement counting bloom filter, represented by array of ints and increment/decrement.Rope: It\'s a string that allows for cheap prepends, substrings, middle insertions and appends. I\'ve really only had use for it once, but no other structure would have sufficed. Regular strings and arrays prepends were just far too expensive for what we needed to do, and reversing everthing was out of the question.Skip lists are pretty neat.  Wikipedia\n  A skip list is a probabilistic data structure, based on multiple parallel, sorted linked lists, with efficiency comparable to a binary search tree (order log n average time for most operations).They can be used as an alternative to balanced trees (using probalistic balancing rather than strict enforcement of balancing).  They are easy to implement and faster than say, a red-black tree. I think they should be in every good programmers toolchest.If you want to get an in-depth introduction to skip-lists here is a link to a video of MIT\'s Introduction to Algorithms lecture on them.Also, here is a Java applet demonstrating Skip Lists visually.Spatial Indices, in particular R-trees and KD-trees, store spatial data efficiently. They are good for geographical map coordinate data and VLSI place and route algorithms, and sometimes for nearest-neighbor search.Bit Arrays store individual bits compactly and allow fast bit operations.Zippers - derivatives of data structures that modify the structure to have a natural notion of \'cursor\' -- current location. These are really useful as they guarantee indicies cannot be out of bound -- used, e.g. in the xmonad window manager to track which window has focused. Amazingly, you can derive them by applying techniques from calculus to the type of the original data structure!Here are a few:Suffix tries.  Useful for almost all kinds of string searching (http://en.wikipedia.org/wiki/Suffix_trie#Functionality).  See also suffix arrays; they\'re not quite as fast as suffix trees, but a whole lot smaller.Splay trees (as mentioned above).  The reason they are cool is threefold:Heap-ordered search trees: you store a bunch of (key, prio) pairs in a tree, such that it\'s a search tree with respect to the keys, and heap-ordered with respect to the priorities.  One can show that such a tree has a unique shape (and it\'s not always fully packed up-and-to-the-left).  With random priorities, it gives you expected O(log n) search time, IIRC.A niche one is adjacency lists for undirected planar graphs with O(1) neighbour queries.  This is not so much a data structure as a particular way to organize an existing data structure.  Here\'s how you do it: every planar graph has a node with degree at most 6.  Pick such a node, put its neighbors in its neighbor list, remove it from the graph, and recurse until the graph is empty.  When given a pair (u, v), look for u in v\'s neighbor list and for v in u\'s neighbor list.  Both have size at most 6, so this is O(1).By the above algorithm, if u and v are neighbors, you won\'t have both u in v\'s list and v in u\'s list.  If you need this, just add each node\'s missing neighbors to that node\'s neighbor list, but store how much of the neighbor list you need to look through for fast lookup.I think lock-free alternatives to standard data structures i.e lock-free queue, stack and list are much overlooked.\nThey are increasingly relevant as concurrency becomes a higher priority and are much more admirable goal than using Mutexes or locks to handle concurrent read/writes. Here\'s some links\nhttp://www.cl.cam.ac.uk/research/srg/netos/lock-free/\nhttp://www.research.ibm.com/people/m/michael/podc-1996.pdf [Links to PDF]\nhttp://www.boyet.com/Articles/LockfreeStack.html Mike Acton\'s (often provocative) blog has some excellent articles on lock-free design and approachesI think Disjoint Set is pretty nifty for cases when you need to divide a bunch of items into distinct sets and query membership.  Good implementation of the Union and Find operations result in amortized costs that are effectively constant (inverse of Ackermnan\'s Function, if I recall my data structures class correctly).Fibonacci heapsThey\'re used in some of the fastest known algorithms (asymptotically) for a lot of graph-related problems, such as the Shortest Path problem.  Dijkstra\'s algorithm runs in O(E log V) time with standard binary heaps; using Fibonacci heaps improves that to O(E + V log V), which is a huge speedup for dense graphs.  Unfortunately, though, they have a high constant factor, often making them impractical in practice.Anyone with experience in 3D rendering should be familiar with BSP trees.  Generally, it\'s the method by structuring a 3D scene to be manageable for rendering knowing the camera coordinates and bearing.Binary space partitioning (BSP) is a\n  method for recursively subdividing a\n  space into convex sets by hyperplanes.\n  This subdivision gives rise to a\n  representation of the scene by means\n  of a tree data structure known as a\n  BSP tree.In other words, it is a method of\n  breaking up intricately shaped\n  polygons into convex sets, or smaller\n  polygons consisting entirely of\n  non-reflex angles (angles smaller than\n  180\xc2\xb0). For a more general description\n  of space partitioning, see space\n  partitioning.Originally, this approach was proposed\n  in 3D computer graphics to increase\n  the rendering efficiency. Some other\n  applications include performing\n  geometrical operations with shapes\n  (constructive solid geometry) in CAD,\n  collision detection in robotics and 3D\n  computer games, and other computer\n  applications that involve handling of\n  complex spatial scenes.Huffman trees - used for compression.Have a look at Finger Trees, especially if you\'re a fan of the previously mentioned purely functional data structures. They\'re a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece. As per the original article:Our functional 2-3 finger trees are an instance of a general design technique in- troduced by Okasaki (1998), called implicit recursive slowdown. We have already noted that these trees are an extension of his implicit deque structure, replacing pairs with 2-3 nodes to provide the flexibility required for efficient concatenation and splitting.A Finger Tree can be parameterized with a monoid, and using different monoids will result in different behaviors for the tree. This lets Finger Trees simulate other data structures.Circular or ring buffer - used for streaming, among other things.I\'m surprised no one has mentioned Merkle trees (ie. Hash Trees).Used in many cases (P2P programs, digital signatures) where you want to verify the hash of a whole file when you only have part of the file available to you.<zvrba> Van Emde-Boas treesI think it\'d be useful to know why they\'re cool.  In general, the question "why" is the most important to ask ;)My answer is that they give you O(log log n) dictionaries with {1..n} keys, independent of how many of the keys are in use.  Just like repeated halving gives you O(log n), repeated sqrting gives you O(log log n), which is what happens in the vEB tree.How about splay trees?Also, Chris Okasaki\'s purely functional data structures come to mind.An interesting variant of the hash table is called Cuckoo Hashing. It uses multiple hash functions instead of just 1 in order to deal with hash collisions. Collisions are resolved by removing the old object from the location specified by the primary hash, and moving it to a location specified by an alternate hash function. Cuckoo Hashing allows for more efficient use of memory space because you can increase your load factor up to 91% with only 3 hash functions and still have good access time.A min-max heap is a variation of a heap that implements a double-ended priority queue. It achieves this by by a simple change to the heap property: A tree is said to be min-max ordered if every element on even (odd) levels are less (greater) than all childrens and grand children. The levels are numbered starting from 1.http://internet512.chonbuk.ac.kr/datastructure/heap/img/heap8.jpgI like Cache Oblivious datastructures.  The basic idea is to lay out a tree in recursively smaller blocks so that caches of many different sizes will take advantage of blocks that convenient fit in them.  This leads to efficient use of caching at everything from L1 cache in RAM to big chunks of data read off of the disk without needing to know the specifics of the sizes of any of those caching layers.Left Leaning Red-Black Trees. A significantly simplified implementation of red-black trees by Robert Sedgewick published in 2008 (~half the lines of code to implement).  If you\'ve ever had trouble wrapping your head around the implementation of a Red-Black tree, read about this variant.Very similar (if not identical) to Andersson Trees.Work Stealing QueueLock-free data structure for dividing the work equaly among multiple threads\nImplementation of a work stealing queue in C/C++?Bootstrapped skew-binomial heaps by Gerth St\xc3\xb8lting Brodal and Chris Okasaki:Despite their long name, they provide asymptotically optimal heap operations, even in a function setting. Note that union takes O(1) rather than O(log n) time unlike the more well-known heaps that are commonly covered in data structure textbooks, such as leftist heaps. And unlike Fibonacci heaps, those asymptotics are worst-case, rather than amortized, even if used persistently!There are multiple implementations in Haskell. They were jointly derived by Brodal and Okasaki, after Brodal came up with an imperative heap with the same asymptotics.Most, if not all, of these are documented on the NIST Dictionary of Algorithms and Data StructuresBall Trees.  Just because they make people giggle.A ball tree is a data structure that indexes points in a metric space.  Here\'s an article on building them.   They are often used for finding nearest neighbors to a point or accelerating k-means. Not really a data structure; more of a way to optimize dynamically allocated arrays, but the gap buffers used in Emacs are kind of cool.Fenwick Tree. It\'s a data structure to keep count of the sum of all elements in a vector, between two given subindexes i and j. The trivial solution, precalculating the sum since the begining doesn\'t allow to update a item (you have to do O(n) work to keep up).Fenwick Trees allow you to update and query in O(log n), and how it works is really cool and simple. It\'s really well explained in Fenwick\'s original paper, freely available here:http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol24/issue3/spe884.pdfIts father, the RQM tree is also very cool: It allows you to keep info about the minimum element between two indexes of the vector, and it also works in O(log n) update and query. I like to teach first the RQM and then the Fenwick Tree.Van Emde-Boas trees.  I have even a C++ implementation of it, for up to 2^20 integers.Nested sets are nice for representing trees in the relational databases and running queries on them. For instance, ActiveRecord (Ruby on Rails\' default ORM) comes with a very simple nested set plugin, which makes working with trees trivial.It\'s pretty domain-specific, but half-edge data structure is pretty neat. It provides a way to iterate over polygon meshes (faces and edges) which is very useful in computer graphics and computational geometry.