I want to check if the iOS version of the device is greater than 3.1.3\nI tried things like:but it does not work, I just want a:How can I achieve this?\nAs of Swift 2.0, you can use #available in an if or guard to protect code that should only be run on certain systems.if #available(iOS 9, *) {}\n\n\n\nIn Objective-C, you need to check the system version and perform a comparison.[[NSProcessInfo processInfo] operatingSystemVersion] in iOS 8 and above.As of Xcode 9:if (@available(iOS 9, *)) {}In Objective-C, and Swift in rare cases, it\'s better to avoid relying on the operating system version as an indication of device or OS capabilities.  There is usually a more reliable method of checking whether a particular feature or class is available.Checking for the presence of APIs:For example, you can check if UIPopoverController is available on the current device using NSClassFromString:For weakly linked classes, it is safe to message the class, directly. Notably, this works for frameworks that aren\'t explicitly linked as "Required". For missing classes, the expression evaluates to nil, failing the condition:Some classes, like CLLocationManager and UIDevice, provide methods to check device capabilities:Checking for the presence of symbols:Very occasionally, you must check for the presence of a constant. This came up in iOS 8 with the introduction of UIApplicationOpenSettingsURLString, used to load Settings app via -openURL:. The value didn\'t exist prior to iOS 8. Passing nil to this API will crash, so you must take care to verify the existence of the constant first:Comparing against the operating system version:Let\'s assume you\'re faced with the relatively rare need to check the operating system version. For projects targeting iOS 8 and above, NSProcessInfo includes a method for performing version comparisons with less chance of error:Projects targeting older systems can use systemVersion on UIDevice. Apple uses it in their GLSprite sample code.If for whatever reason you decide that systemVersion is what you want, make sure to treat it as an string or you risk truncating the patch revision number (eg. 3.1.2 -> 3.1).As suggested by the official Apple docs: you can use the NSFoundationVersionNumber, from the NSObjCRuntime.h header file.Try:In Swift 2.0 Apple added availability checking using a far more convenient syntax (Read more here). Now you can check the OS version with a cleaner syntax:This is the preferred over checking respondsToSelector etc (What\'s New In Swift). Now the compiler will always warn you if you aren\'t guarding your code properly.New in iOS 8 is NSProcessInfo allowing for better semantic versioning checks.For minimum deployment targets of iOS 8.0 or above, use NSProcessInfo\n  operatingSystemVersion or isOperatingSystemAtLeastVersion. This would yield the following:For minimum deployment targets of iOS 7.1 or below, use compare with\n  NSStringCompareOptions.NumericSearch on UIDevice systemVersion.This would yield:More reading at NSHipster.This is used to check for compatible SDK version in Xcode, this is if you have a large team with different versions of Xcode or multiple projects supporting different SDKs that share the same code:What you really want is to check the iOS version on the device. You can do that with this:Swift version:I recommend: credit: How to target a specific iPhone version?Starting Xcode 9, in Objective-C:  Starting Xcode 7, in Swift:  For the version, you can specify the MAJOR, the MINOR or the PATCH (see http://semver.org/ for definitions). Examples:You can input values for any of those systems:Real case example taken from one of my pods:documentationI always keep those in my Constants.h file:With Version class that is contained in nv-ios-version project (Apache License, Version 2.0), it is easy to get and compare iOS version. An example code below dumps the iOS version and checks whether the version is greater than or equal to 6.0.Project Page: nv-ios-version\nTakahikoKawasaki/nv-ios-versionBlog: Get and compare iOS version at runtime with Version class\nGet and compare iOS version at runtime with Version classNew way to check the system version using the swift Forget [[UIDevice currentDevice] systemVersion] and NSFoundationVersionNumber.We can use NSProcessInfo -isOperatingSystemAtLeastVersionUIDevice+IOSVersion.hUIDevice+IOSVersion.mIn general it\'s better to ask if an object can perform a given selector, rather than checking  a version number to decide if it must be present.When this is not an option, you do need to be a bit careful here because [@"5.0" compare:@"5" options:NSNumericSearch] returns NSOrderedDescending which might well not be intended at all; I might expect NSOrderedSame here. This is at least a theoretical concern, one that is worth defending against in my opinion.Also worth considering is the possibility of a bad version input which can not reasonably be compared to. Apple supplies the three predefined constants NSOrderedAscending, NSOrderedSame and NSOrderedDescending but I can think of a use for some thing called NSOrderedUnordered in the event I can\'t compare two things and I want to return a value indicating this.What\'s more, it\'s not impossible that Apple will some day expand their three predefined constants to allow a variety of return values, making a comparison != NSOrderedAscending unwise.With this said, consider the following code.Where of course, NSFoundationVersionNumber_iOS_6_1 must be changed to by applicable for the iOS version you want to check. What I have now written will probably be used a lot when testing if a device is running iOS7 or a previous version.a bit late to the party but in light of iOS 8.0 out there this might be relevant:if you can avoid using [[UIDevice currentDevice] systemVersion]Instead check for existence of of a method/class/whatever else.I found it to be useful for location manager where I have to call requestWhenInUseAuthorization for iOS 8.0 but the method is not available for iOS < 8There are version like 7.0 or 6.0.3, so we can simply convert version into numerics to compare. if version is like 7.0, simply append another ".0" to it and then take its numeric value.For 6.0.0for 7.0Try the below code:Just for retrieving the OS version string value:Then add a if condition as follows:-As a variation of yasimturks solution, I defined one function and a few enum values instead of five macros. I find it more elegant, but that\'s a matter of taste.Usage:.h file:.m file:You should add your app\'s prefix to the names, especially to the Comparison type.I know this is an old question, but someone should have mentioned the compile-time macros in Availability.h. All of the other methods here are runtime solutions, and will not work in a header file, class category, or ivar definition. For these situations, use h/t this answerUsing the refered recommended way... if there is no definition in the header files, you can always get the versi\xc3\xb3n printing it on console with a device of the desired IOS versi\xc3\xb3n.A more generic version in Obj-C++ 11 (you could probably replace some of this stuff with the NSString/C functions, but this is less verbose.  This gives you two mechanisms.  splitSystemVersion gives you an array of all the parts which is useful if you just want to switch on the major version (e.g. switch([self splitSystemVersion][0]) {case 4: break; case 5: break; }).Try thisSwift example that actually works:Don\'t use NSProcessInfo cause it doesn\'t work under 8.0, so its pretty much useless until 2016Solution for checking iOS version in SwiftCon of this solution: it is simply bad practice to check against OS version numbers, whichever way you do it. One should never hard code dependencies in this way, always check for features, capabilities or the existence of a class. Consider this; Apple may release a backwards compatible version of a class, if they did then the code you suggest would never use it as your logic looks for an OS version number and NOT the existence of the class.(Source of this information)Solution for checking the class existence in SwiftDo not use if (NSClassFromString("UIAlertController") == nil) because it works correctly on the iOS simulator using iOS 7.1 and 8.2, but if you test on a real device using iOS 7.1, you will unfortunately notice that you will never pass through the else part of the code snippet.