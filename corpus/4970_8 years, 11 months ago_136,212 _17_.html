Say I have a C function which takes a variable number of arguments: How can I call another function which expects a variable number of arguments from inside of it, passing all the arguments that got into the first function?Example:To pass the ellipses on, you have to convert them to a va_list and use that va_list in your second function. Specifically;Variadic Functions can be dangerous. Here\'s a safer trick:There\'s no way of calling (eg) printf without knowing how many arguments you\'re passing to it, unless you want to get into naughty and non-portable tricks.The generally used solution is to always provide an alternate form of vararg functions, so printf has vprintf which takes a va_list in place of the .... The ... versions are just wrappers around the va_list versions.In magnificent C++0x you could use variadic templates:You can use inline assembly for the function call. (in this code I assume the arguments are characters).Ross\' solution cleaned-up a bit. Only works if all args are pointers. Also language implementation must support eliding of previous comma if __VA_ARGS__ is empty (both Visual Studio C++ and GCC do).You can try macro also.Let\'s say you have a typical variadic function you\'ve written. Because at least one argument is required before the variadic one ..., you have to always write an extra argument in usage.Or do you?If you wrap your variadic function in a macro, you need no preceding arg. Consider this example: This is obviously far more convenient, since you needn\'t specify the initial argument every time.I\'m unsure if this works for all compilers, but it has worked so far for me.You can add the ... to inner_func() if you want, but you don\'t need it.  It works because va_start uses the address of the given variable as the start point.  In this case, we are giving it a reference to a variable in func().  So it uses that address and reads the variables after that on the stack.  The inner_func() function is reading from the stack address of func().  So it only works if both functions use the same stack segment.The va_start and va_arg macros will generally work if you give them any var as a starting point.  So if you want you can pass pointers to other functions and use those too.  You can make your own macros easily enough.  All the macros do is typecast memory addresses.  However making them work for all the compilers and calling conventions is annoying.  So it\'s generally easier to use the ones that come with the compiler.