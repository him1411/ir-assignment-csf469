Given a function which produces a random integer in the range 1 to 5, write a function which produces a random integer in the range 1 to 7.This is equivalent to Adam Rosenfield\'s solution, but may be a bit more clear for some readers. It assumes rand5() is a function that returns a statistically random integer in the range 1 through 5 inclusive.How does it work? Think of it like this: imagine printing out this double-dimension array on paper, tacking it up to a dart board and randomly throwing darts at it. If you hit a non-zero value, it\'s a statistically random value between 1 and 7, since there are an equal number of non-zero values to choose from. If you hit a zero, just keep throwing the dart until you hit a non-zero. That\'s what this code is doing: the i and j indexes randomly select a location on the dart board, and if we don\'t get a good result, we keep throwing darts.Like Adam said, this can run forever in the worst case, but statistically the worst case never happens. :)There is no (exactly correct) solution which will run in a constant amount of time, since 1/7 is an infinite decimal in base 5.  One simple solution would be to use rejection sampling, e.g.:This has an expected runtime of 25/21 = 1.19 iterations of the loop, but there is an infinitesimally small probability of looping forever.I\'d like to add another answer, in addition to my first answer.  This answer attempts to minimize the number of calls to rand5() per call to rand7(), to maximize the usage of randomness.  That is, if you consider randomness to be a precious resource, we want to use as much of it as possible, without throwing away any random bits.  This answer also has some similarities with the logic presented in Ivan\'s answer.The entropy of a random variable is a well-defined quantity.  For a random variable which takes on N states with equal probabilities (a uniform distribution), the entropy is log2 N.  Thus, rand5() has approximately 2.32193 bits of entropy, and rand7() has about 2.80735 bits of entropy.  If we hope to maximize our use of randomness, we need to use all 2.32193 bits of entropy from each call to rand5(), and apply them to generating 2.80735 bits of entropy needed for each call to rand7().  The fundamental limit, then, is that we can do no better than log(7)/log(5) = 1.20906 calls to rand5() per call to rand7().Side notes: all logarithms in this answer will be base 2 unless specified otherwise.  rand5() will be assumed to return numbers in the range [0, 4], and rand7() will be assumed to return numbers in the range [0, 6].  Adjusting the ranges to [1, 5] and [1, 7] respectively is trivial.So how do we do it?  We generate an infinitely precise random real number between 0 and 1 (pretend for the moment that we could actually compute and store such an infinitely precise number -- we\'ll fix this later).  We can generate such a number by generating its digits in base 5: we pick the random number 0.a1a2a3..., where each digit ai is chosen by a call to rand5().  For example, if our RNG chose ai = 1 for all i, then ignoring the fact that that isn\'t very random, that would correspond to the real number 1/5 + 1/52 + 1/53 + ... = 1/4 (sum of a geometric series).Ok, so we\'ve picked a random real number between 0 and 1.  I now claim that such a random number is uniformly distributed.  Intuitively, this is easy to understand, since each digit was picked uniformly, and the number is infinitely precise.  However, a formal proof of this is somewhat more involved, since now we\'re dealing with a continuous distribution instead of a discrete distribution, so we need to prove that the probability that our number lies in an interval [a, b] equals the length of that interval, b - a.  The proof is left as an exercise for the reader =).Now that we have a random real number selected uniformly from the range [0, 1], we need to convert it to a series of uniformly random numbers in the range [0, 6] to generate the output of rand7().  How do we do this?  Just the reverse of what we just did -- we convert it to an infinitely precise decimal in base 7, and then each base 7 digit will correspond to one output of rand7().Taking the example from earlier, if our rand5() produces an infinite stream of 1\'s, then our random real number will be 1/4.  Converting 1/4 to base 7, we get the infinite decimal 0.15151515..., so we will produce as output 1, 5, 1, 5, 1, 5, etc.Ok, so we have the main idea, but we have two problems left: we can\'t actually compute or store an infinitely precise real number, so how do we deal with only a finite portion of it?  Secondly, how do we actually convert it to base 7?One way we can convert a number between 0 and 1 to base 7 is as follows:To deal with the problem of infinite precision, we compute a partial result, and we also store an upper bound on what the result could be.  That is, suppose we\'ve called rand5() twice and it returned 1 both times.  The number we\'ve generated so far is 0.11 (base 5).  Whatever the rest of the infinite series of calls to rand5() produce, the random real number we\'re generating will never be larger than 0.12: it is always true that 0.11 \xe2\x89\xa4 0.11xyz... < 0.12.So, keeping track of the current number so far, and the maximum value it could ever take, we convert both numbers to base 7.  If they agree on the first k digits, then we can safely output the next k digits -- regardless of what the infinite stream of base 5 digits are, they will never affect the next k digits of the base 7 representation!And that\'s the algorithm -- to generate the next output of rand7(), we generate only as many digits of rand5() as we need to ensure that we know with certainty the value of the next digit in the conversion of the random real number to base 7.  Here is a Python implementation, with a test harness:Note that rand7_gen() returns a generator, since it has internal state involving the conversion of the number to base 7.  The test harness calls next(r7) 10000 times to produce 10000 random numbers, and then it measures their distribution.  Only integer math is used, so the results are exactly correct.Also note that the numbers here get very big, very fast.  Powers of 5 and 7 grow quickly.  Hence, performance will start to degrade noticeably after generating lots of random numbers, due to bignum arithmetic.  But remember here, my goal was to maximize the usage of random bits, not to maximize performance (although that is a secondary goal).In one run of this, I made 12091 calls to rand5() for 10000 calls to rand7(), achieving the minimum of log(7)/log(5) calls on average to 4 significant figures, and the resulting output was uniform.In order to port this code to a language that doesn\'t have arbitrarily large integers built-in, you\'ll have to cap the values of pow5 and pow7 to the maximum value of your native integral type -- if they get too big, then reset everything and start over.  This will increase the average number of calls to rand5() per call to rand7() very slightly, but hopefully it shouldn\'t increase too much even for 32- or 64-bit integers. (I have stolen Adam Rosenfeld\'s answer and made it run about 7% faster.)Assume that rand5() returns one of {0,1,2,3,4} with equal distribution and the goal is return {0,1,2,3,4,5,6} with equal distribution.We\'re keeping track of the largest value that the loop can make in the variable max.  If the reult so far is between max%7 and max-1 then the result will be uniformly distrubuted in that range.  If not, we use the remainder, which is random between 0 and max%7-1, and another call to rand() to make a new number and a new max.  Then we start again.Edit: Expect number of times to call rand5() is x in this equation:Algorithm:7 can be represented in a sequence of 3 bitsUse rand(5) to randomly fill each bit with 0 or 1.\nFor e.g: call rand(5) and  if the result is 1 or 2, fill the bit with 0\nif the result is 4 or 5, fill the bit with 1\nif the result is 3 , then ignore and do it again (rejection)  This way we can fill 3 bits randomly with 0/1 and thus get a number from 1-7.EDIT:  This seems like the simplest and most efficient answer, so here\'s some code for it:Edit: That doesn\'t quite work. It\'s off by about 2 parts in 1000 (assuming a perfect rand5). The buckets get:By switching to a sum ofseems to gain an order of magnitude for every 2 addedBTW: the table of errors above was not generated via sampling but by the following recurrence relation:p[x,n] is the number ways output=x can happen given n calls to rand5.The following produces a uniform distribution on {1, 2, 3, 4, 5, 6, 7} using a random number generator producing a uniform distribution on {1, 2, 3, 4, 5}. The code is messy, but the logic is clear.If we consider the additional constraint of trying to give the most efficient answer i.e one that given an input stream, I,  of uniformly distributed integers of length m from 1-5 outputs a stream O,  of uniformly distributed integers from 1-7 of the longest length relative to m, say L(m).  The simplest way to analyse this is to treat the streams I and O as 5-ary and 7-ary numbers respectively.  This is achieved by the main answer\'s idea of taking the stream a1, a2, a3,... -> a1+5*a2+5^2*a3+.. and similarly for stream O.Then if we take a section of the input stream of length m choose n s.t. 5^m-7^n=c where c>0 and is as small as possible.  Then there is a uniform map from the input stream of length m to integers from 1 to 5^m and another uniform map from integers from 1 to 7^n to the output stream of length n where we may have to lose a few cases from the input stream when the mapped integer exceeds 7^n.So this gives a value for L(m) of around m (log5/log7) which is approximately .82m.The difficulty with the above analysis is the equation 5^m-7^n=c which is not easy to solve exactly and the case where the uniform value from 1 to 5^m exceeds 7^n and we lose efficiency.  The question is how close to the best possible value of m (log5/log7) can be attain. For example when this number approaches close to an integer can we find a way to achieve this exact integral number of output values? If 5^m-7^n=c then from the input stream we effectively generate a uniform random number from 0 to (5^m)-1 and don\'t use any values higher than 7^n.  However these values can be rescued and used again.  They effectively generate a uniform sequence of numbers from 1 to 5^m-7^n. So we can then try to use these and convert them into 7-ary numbers so that we can create more output values.  If we let T7(X) to be the average length of the output sequence of random(1-7) integers derived from a uniform input of size X, and assuming that 5^m=7^n0+7^n1+7^n2+...+7^nr+s, s<7.Then T7(5^m)=n0x7^n0/5^m + ((5^m-7^n0)/5^m) T7(5^m-7^n0) since we have a length no sequence with probability 7^n0/5^m with a residual of length 5^m-7^n0 with probability (5^m-7^n0)/5^m).If we just keep substituting we obtain:HenceAnother way of putting this is:The best possible case is my original one above where 5^m=7^n+s, where s<7.Then T7(5^m) = nx(7^n)/(7^n+s) = n+o(1) = m (Log5/Log7)+o(1) as before.The worst case is when we can only find k and s.t 5^m = kx7+s.Other cases are somewhere inbetween.  It would be interesting to see how well we can do for very large m, i.e. how good can we get the error term:It seems impossible to achieve e(m) = o(1) in general but hopefully we can prove e(m)=o(m).The whole thing then rests on the distribution of the 7-ary digits of 5^m for various values of m.I\'m sure there is a lot of theory out there that covers this I may have a look and report back at some point. Are homework problems allowed here?This function does crude "base 5" math to generate a number between 0 and 6.Here is a working Python implementation of Adam\'s answer.I like to throw algorithms I\'m looking at into Python so I can play around with them, thought I\'d post it here in the hopes that it is useful to someone out there, not that it took long to throw together.Why not do it simple?The chances of getting 1 and 7 in this solution is lower due to the modulo, however, if you just want a quick and readable solution, this is the way to go.Assuming that rand(n)  here means "random integer in a uniform distribution from 0 to n-1", here\'s a code sample using Python\'s randint, which has that effect. It uses only randint(5), and constants, to produce the effect of randint(7). A little silly, actuallyThe premise behind Adam Rosenfield\'s correct answer is:When n equals 2, you have 4 throw-away possibilities: y = {22, 23, 24, 25}. If you use n equals 6, you only have 1 throw-away: y = {15625}.5^6 = 15625\n7 * 2232 = 15624You call rand5 more times. However, you have a much lower chance of getting a throw-away value (or an infinite loop). If there is a way to get no possible throw-away value for y, I haven\'t found it yet.Here\'s my answer:It\'s a little more complicated than others, but I believe it minimises the calls to rand5. As with other solutions, there\'s a small probability that it could loop for a long time.As long as there aren\'t seven possibilities left to choose from, draw another random number, which multiplies the number of possibilities by five. In Perl:Simple and efficient:(Inspired by What's your favorite "programmer" cartoon?).I don\'t like ranges starting from 1, so I\'ll start from 0 :-)I know it has been answered, but is this seems to work ok, but I can not tell you if it has a bias. My \'testing\' suggests it is, at least, reasonable.Perhaps Adam Rosenfield would be kind enough to comment?My (naive?) idea is this:Accumulate rand5\'s until there is enough random bits to make a rand7. This takes at most 2 rand5\'s. To get the rand7 number I use the accumulated value mod 7.To avoid the accumulator overflowing, and since the accumulator is mod 7 then I take the mod 7 of the accumulator:The rand7() function follows:(I let the range of rand5 be 0-4 and rand7 is likewise 0-6.)Edit: Added results for 100 million trials.\'Real\' rand functions mod 5 or 7rand5   : avg=1.999802 0:20003944 1:19999889 2:20003690 3:19996938 4:19995539\nrand7   : avg=3.000111 0:14282851 1:14282879 2:14284554 3:14288546 4:14292388 5:14288736 6:14280046My rand7Average looks ok and number distributions look ok too.randt   : avg=3.000080 0:14288793 1:14280135 2:14287848 3:14285277 4:14286341 5:14278663 6:14292943There are elegant algorithms cited above, but here\'s one way to approach it, although it might be roundabout. I am assuming values generated from 0.R2 = random number generator giving values less than 2 (sample space = {0, 1})\nR8 = random number generator giving values less than 8 (sample space = {0, 1, 2, 3, 4, 5, 6, 7})In order to generate R8 from R2, you will run R2 thrice, and use the combined result of all 3 runs as a binary number with 3 digits. Here are the range of values when R2 is ran thrice:0 0 0 --> 0\n.\n.\n1 1 1 --> 7Now to generate R7 from R8, we simply run R7 again if it returns 7:The roundabout solution is to generate R2 from R5 (just like we generated R7 from R8), then R8 from R2 and then R7 from R8.There you go, uniform distribution and zero rand5 calls.Need to set seed beforehand.Here\'s a solution that fits entirely within integers and is within about 4% of optimal (i.e. uses 1.26 random numbers in {0..4} for every one in {0..6}).  The code\'s in Scala, but the math should be reasonably clear in any language: you take advantage of the fact that 7^9 + 7^8 is very close to 5^11.  So you pick an 11 digit number in base 5, and then interpret it as a 9 digit number in base 7 if it\'s in range (giving 9 base 7 numbers), or as an 8 digit number if it\'s over the 9 digit number, etc.:If you paste a test into the interpreter (REPL actually), you get:The distribution is nice and flat (within about 10k of 1/7 of 10^8 in each bin, as expected from an approximately-Gaussian distribution).Unlike the chosen solution, the algorithm will run in constant time. It does however make 2 more calls to rand5 than the average run time of the chosen solution.Note that this generator is not perfect (the number 0 has 0.0064% more chance than any other number), but for most practical purposes the guarantee of constant time probably outweighs this inaccuracy.ExplanationThis solution is derived from the fact that the number 15,624 is divisible by 7 and thus if we can randomly and uniformly generate numbers from 0 to 15,624 and then take mod 7 we can get a near-uniform rand7 generator. Numbers from 0 to 15,624 can be uniformly generated by rolling rand5 6 times and using them to form the digits of a base 5 number as follows:Properties of mod 7 however allow us to simplify the equation a bit:SobecomesTheoryThe number 15,624 was not chosen randomly, but can be discovered using fermat\'s little theorem, which states that if p is a prime number thenSo this gives us,(5^6)-1 is equal toThis is a number in base 5 form and thus we can see that this method can be used to go from any random number generator to any other random number generator. Though a small bias towards 0 is always introduced when using the exponent p-1.By using a rolling total, you can bothBoth these problems are an issue with the simplistic rand(5)+rand(5)...-type solutions. The following Python code shows how to implement it (most of this is proving the distribution).And this output shows the results:A simplistic rand(5)+rand(5), ignoring those cases where this returns more than 6 has a typical variation of 18%, 100 times that of the method shown above:And, on the advice of Nixuz, I\'ve cleaned the script up so you can just extract and use the rand7... stuff:This answer is more an experiment in obtaining the most entropy possible from the Rand5 function. t is therefore somewhat unclear and almost certainly a lot slower than other implementations.Assuming the uniform distribution from 0-4 and resulting uniform distribution from 0-6:The number of bits added to the buffer per call to Rand5 is currently 4/5 * 2 so 1.6.\nIf the 1/5 probability value is included that increases by 0.05 so 1.65 but see the comment in the code where I have had to disable this.Bits consumed by call to Rand7 = 3 + 1/8 * (3 + 1/8 * (3 + 1/8 * (...\nThis is 3 + 3/8 + 3/64 + 3/512 ... so approx 3.42By extracting information from the sevens I reclaim 1/8*1/7 bits per call so about 0.018This gives a net consumption 3.4 bits per call which means the ratio is 2.125 calls to Rand5 for every Rand7. The optimum should be 2.1.I would imagine this approach is significantly slower than many of the other ones here unless the cost of the call to Rand5 is extremely expensive (say calling out to some external source of entropy).in phploops to produce a random number between 16 and 127, divides by sixteen to create a float between 1 and 7.9375, then rounds down to get an int between 1 and 7. if I am not mistaken, there is a 16/112 chance of getting any one of the 7 outcomes.The function you need is rand1_7(), I wrote rand1_5() so that you can test it and plot it.just scale your output from your first function