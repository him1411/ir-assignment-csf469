Since the upgrade to iOS 6, we are seeing Safari\'s web view take the liberty of caching $.ajax calls. This is in the context of a PhoneGap application so it is using the Safari WebView. Our $.ajax calls are POST methods and we have cache set to false {cache:false}, but still this is happening. We tried manually adding a TimeStamp to the headers but it did not help.We did more research and found that Safari is only returning cached results for web services that have a function signature that is static and does not change from call to call.  For instance, imagine a function called something like:This function receives the same input parameters over and over again, but the data it returns should be different every time.Must be in Apple\'s haste to make iOS 6 zip along impressively they got too happy with the cache settings.  Has anyone else seen this behavior on iOS 6? If so, what exactly is causing it?The workaround that we found was to modify the function signature to be something like this:and then always pass in a TimeStamp parameter as well, and just discard that value on the server side.  This works around the issue.  I hope this helps some other poor soul who spends 15 hours on this issue like I did!After a bit of investigation, turns out that Safari on iOS6 will cache POSTs that have either no Cache-Control headers or even "Cache-Control: max-age=0".The only way I\'ve found of preventing this caching from happening at a global level rather than having to hack random querystrings onto the end of service calls is to set "Cache-Control: no-cache".So:I suspect that Apple is taking advantage of this from the HTTP spec in section 9.5 about POST:Responses to this method are not cacheable, unless the response\n     includes appropriate Cache-Control or Expires header fields. However,\n     the 303 (See Other) response can be used to direct the user agent to\n     retrieve a cacheable resource.So in theory you can cache POST responses...who knew. But no other browser maker has ever thought it would be a good idea until now. But that does NOT account for the caching when no Cache-Control or Expires headers are set, only when there are some set. So it must be a bug.Below is what I use in the right bit of my Apache config to target the whole of my API because as it happens I don\'t actually want to cache anything, even gets. What I don\'t know is how to set this just for POSTs.Update: Just noticed that I didn\'t point out that it is only when the POST is the same, so change any of the POST data or URL and you\'re fine. So you can as mentioned elsewhere just add some random data to the URL or a bit of POST data.Update: You can limit the "no-cache" just to POSTs if you wish like this in Apache:I hope this can be of use to other developers banging their head against the wall on this one.  I found that any of the following prevents Safari on iOS 6 from caching the POST response:My solution was the following in my Javascript (all my AJAX requests are POST).I also add the [pragma: no-cache] header to many of my server responses.If you use the above solution be aware that any $.ajax() calls you make that are set to global: false will NOT use the settings specified in $.ajaxSetup(), so you will need to add the headers in again.Simple solution for all your web service requests, assuming you\'re using jQuery:Read more about the jQuery prefilter call here.If you aren\'t using jQuery, check the docs for your library of choice.  They may have similar functionality.I had the same problem with a webapp getting data from ASP.NET webserviceThis worked for me:I just had this issue as well in a PhoneGap application. I solved it by using the JavaScript function getTime() in the following manner:I wasted a few hours figuring this out. It would have been nice of Apple to notify developers of this caching issue.Finally, I\'ve a solution to my uploading problem.In JavaScript:In PHP:From my own blog post iOS 6.0 caching Ajax POST requests:How to fix it: There are various methods to prevent caching of requests. The recommended method is adding a no-cache header. This is how it is done.Check for iOS 6.0 and set Ajax header like this:Check for iOS 6.0 and set the Ajax header like this:Make sure to add this at the top the page before any data is sent to the client.OrThis JavaScript snippet works great with jQuery and jQuery Mobile:Just place it somewhere in your JavaScript code (after jQuery is loaded, and best before you do AJAX requests) and it should help.A quick work-around for GWT-RPC services is to add this to all the remote methods:This is an update of Baz1nga\'s answer. Since options.data is not an object but a string I just resorted to concatenating the timestamp:You can also fix this issue by modifying the jQuery Ajax function by doing the following (as of 1.7.1) to the top of the Ajax function (function starts at line 7212). This change will activate the built-in anti-cache feature of jQuery for all POST requests.(The full script is available at http://dl.dropbox.com/u/58016866/jquery-1.7.1.js.)Insert below line 7221:Then modify the following (starting at line ~7497).To:In order to resolve this issue for WebApps added to the home screen, both of the top voted workarounds need to be followed. Caching needs to be turned off on the webserver to prevent new requests from being cached going forward and some random input needs to be added to every post request in order for requests that have already been cached to go through. Please refer to my post:iOS6 - Is there a way to clear cached ajax POST requests for webapp added to home screen?WARNING: to anyone who implemented a workaround by adding a timestamp to their requests without turning off caching on the server. If your app is added to the home screen, EVERY post response will now be cached, clearing safari cache doesn\'t clear it and it doesn\'t seem to expire. Unless someone has a way to clear it, this looks like a potential memory leak!That\'s the work around for GWT-RPCMy workaround in ASP.NET (pagemethods, webservice, etc.)Things that DID NOT WORK for me with an iPad 4/iOS 6:My request containing: Cache-Control:no-cacheAdding cache: false to my jQuery ajax callOnly this did the trick:While adding cache-buster parameters to make the request look different seems like a solid solution, I would advise against it, as it would hurt any application that relies on actual caching taking place. Making the APIs output the correct headers is the best possible solution, even if that\'s slightly more difficult than adding cache busters to the callers.For those that use Struts 1, here is how I fixed the issue.web.xmlcom.example.struts.filters.CacheControlFilter.jsI was able to fix my problem by using a combination of $.ajaxSetup and appending a timestamp to the url of my post (not to the post parameters/body). This based on the recommendations of previous answersI think you have already resolved your issue, but let me share an idea about web caching.It is true you can add many headers in each language you use, server side, client side, and you can use many other tricks to avoid web caching, but always think that you can never know from where the client are connecting to your server, you never know if he are using a Hotel \xe2\x80\x9cHot-Spot\xe2\x80\x9d connection that uses Squid or other caching products.If the users are using proxy to hide his real position, etc\xe2\x80\xa6 the real only way to avoid caching is the timestamp in the request also if is unused.For example:Then every cache manager you have to pass didnt find the same URL in the cache repository and go re-download the page content.I suggest a workaround to modify the function signature to be something like this:getNewRecordID(intRecordType, strTimestamp)\nand then always pass in a TimeStamp parameter as well, and just discard that value on the server side. This works around the issue.Depending on the app you can trouble shoot the issue now in iOS 6 using Safari>Advanced>Web Inspector so that is helpful with this situation. Connect the phone to Safari on a Mac an then use the developer menu to trouble shoot the web app. Clear the website data on the iPhone after update to iOS6, including specific to the app using a Web View. Only one app had an issue and this solved it during IOS6 Beta testing way back, since then no real problems. You may need to look at your app as well, check out NSURLCache if in a WebView in a custom app.https://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40003754I guess depending on the true nature of your problem, implementation, etc. ..  Ref:  $.ajax calls I found one workaround that makes me curious as to why it works.  Before reading Tadej\'s answer concerning ASP.NET web service, I was trying to come up with something that would work.  And I\'m not saying that it\'s a good solution, but I just wanted to document it here.main page:  includes a JavaScript function, checkStatus().  The method calls another method which uses a jQuery AJAX call to update the html content.  I used setInterval to call checkStatus().  Of course, I ran into the caching problem.Solution:  use another page to call the update.On the main page, I set a boolean variable, runUpdate, and added the following to the body tag:In the  of helper.html:So, if checkStatus() is called from the main page, I get the cached content.  If I call checkStatus from the child page, I get updated content.While my login and signup pages works like a charm in Firefox, IE and Chrome... I\'ve been struggling with this issue in Safari for IOS and OSX, few months ago I found a workaround on the SO.OR via javascriptThis is kinda ugly thing but works for a while.I don\'t know why, but returning null to the onunload event the page do not get cached in Safari.In Ruby\'s SinatraIt worked with ASP.NET only after adding the pragma:no-cache header in IIS. Cache-Control: no-cache was not enough.