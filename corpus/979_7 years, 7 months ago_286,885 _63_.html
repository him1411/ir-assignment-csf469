You see the Git documentation saying things likeThe branch must be fully merged in HEAD.But what is Git HEAD exactly?You can think of the HEAD as the "current branch". When you switch branches with git checkout, the HEAD revision changes to point to the tip of the new branch.You can see what HEAD points to by doing:In my case, the output is:It is possible for HEAD to refer to a specific revision that is not associated with a branch name. This situation is called a detached HEAD.To quote other people: A head is simply a reference to a\n  commit object. Each head has a name\n  (branch name or tag name, etc). By\n  default, there is a head in every\n  repository called master. A repository\n  can contain any number of heads. At\n  any given time, one head is selected\n  as the \xe2\x80\x9ccurrent head.\xe2\x80\x9d This head is\n  aliased to HEAD, always in capitals".Note this difference: a \xe2\x80\x9chead\xe2\x80\x9d\n  (lowercase) refers to any one of the\n  named heads in the repository; \xe2\x80\x9cHEAD\xe2\x80\x9d\n  (uppercase) refers exclusively to the\n  currently active head. This\n  distinction is used frequently in Git\n  documentation.Another good source that quickly covers the inner workings of git (and therefor a better understanding of heads/HEAD) can be found here.  References (ref:) or heads or branches can be considered like post-it notes stuck onto commits in the commit history.  Usually they point to the tip of series of commits, but they can be moved around with git checkout or git revert etc.I recommend this definition since it\'s given by a github developer(Scott Chacon).The whole video will give a fair introduction to the whole git system so I also recommend you to watch it all if have the time to.Hope it will help you.What happens if you create a new branch? Well, doing so creates a new pointer for you to move around. Let\xe2\x80\x99s say you create a new branch called testing. You do this with the git branch command: $ git branch testing This creates a new pointer at the same commit you\xe2\x80\x99re currently on How does Git know what branch you\xe2\x80\x99re currently on? It keeps a special pointer called HEAD. Note that this is a lot different than the concept of HEAD in other VCSs you may be used to, such as Subversion or CVS. In Git, this is a pointer to the local branch you\xe2\x80\x99re currently on. In this case, you\xe2\x80\x99re still on master. The git branch command only created a new branch \xe2\x80\x94 it didn\xe2\x80\x99t switch to that branch HEAD file pointing to the branch you\xe2\x80\x99re on.Assuming it is not a special case called "detached HEAD", then, as stated in the O\'Reilly Git book, 2nd edtion, p.69, HEAD means:HEAD always refers to the most recent commit on the current\n  branch. When you change branches, HEAD is updated to refer to the new\n  branch\xe2\x80\x99s latest commit.so HEAD is the "tip" of the current branch.Note that we can use HEAD to refer to the most recent commit, and use HEAD~ as the commit before the tip, and HEAD~~ or HEAD~2 as the commit even earlier, and so forth.HEAD refers to the current commit that your working copy points to, i.e. the commit you currently have checked-out.  From the official Linux Kernel documentation on specifying Git revisions:HEAD names the commit on which you based the changes in the working tree.Note, however, that in the upcoming version 1.8.4 of Git, @ can also be used as a shorthand for HEAD, as noted by Git contributor Junio C Hamano in his Git Blame blog:Instead of typing "HEAD", you can say "@" instead, e.g. "git log @".Stack Overflow user VonC also found some interesting information on why @ was chosen as a shorthand in his answer to another question.Also of interest, in some environments it\'s not necessary to capitalize HEAD, specifically in operating systems that use case-insensitive file systems, specifically Windows and OS X.Take a look at Creating and playing with branchesHEAD is actually a file whose contents determines where the HEAD variable refers:In this repository, the contents of the HEAD file refers to a second file named refs/heads/master. The file refs/heads/master contains the hash of the most recent commit on the master branch.The result is HEAD points to the master branch commit from the .git/refs/heads/master file.I\'d just like to detail a few things in Greg Hewgil\'s accepted answer.\nAccording to the Git Pocket GuideBranch:the branch itself is defined as all points reachable in the commit\n  graph from the named commit (the \xe2\x80\x9ctip\xe2\x80\x9d of the branch).HEAD: A special type of RefThe special ref HEAD determines what branch you are on...RefsGit defines two kinds of references, or named pointers, which it calls\n  \xe2\x80\x9crefs\xe2\x80\x9d:As Greg mentioned, HEAD can be in a "detached state". So HEAD can be either a simple ref (for a detached HEAD) or a symref. if HEAD is a symbolic ref for an existing branch, then you are \xe2\x80\x9con\xe2\x80\x9d\n  that branch. If, on the other hand, HEAD is a simple ref directly\n  naming a commit by its SHA-1 ID, then you are not \xe2\x80\x9con\xe2\x80\x9d any branch, but\n  rather in \xe2\x80\x9cdetached HEAD\xe2\x80\x9d mode, which happens when you check out some\n  earlier commit to examine.I think \'HEAD\' is current check out commit. In other words \'HEAD\' points to the commit that is currently checked out.If you have just cloned and not checked out I don\'t know what it points to, probably some invalid location.A great way to drive home the point made in the correct answers is to run\ngit reflog HEAD, you get a history of all of the places HEAD has pointed.After reading all of the previous answers, I still wanted more clarity. This blog at the official git website http://git-scm.com/blog gave me what I was looking for:The HEAD in Git is the pointer to the current branch reference, which is in turn a pointer to the last commit you made or the last commit that was checked out into your working directory. That also means it will be the parent of the next commit you do. It\'s generally simplest to think of it as HEAD is the snapshot of your last commit.Head points to the tip of the currently checked out branch.In your repository, there is a .git folder. Open the file in this location: .git\\refs\\heads. The (sha-1 hash) code in that file (master in most cases) will be the most recent commit, i.e the one seen in the output of the command git log. More info on the .git folder: http://gitready.com/advanced/2009/03/23/whats-inside-your-git-directory.htmlThese two may confusing you:headPointing to named references a branch recently submitted. Unless you use the package reference , heads typically stored in $ GIT_DIR/refs/heads/.HEADCurrent branch, or your working tree is usually generated from the tree HEAD is pointing to. HEAD must point to a head, except you are using a detached HEAD.Take a look at http://git-scm.com/book/en/Git-Branching-What-a-Branch-IsFigure 3-5. HEAD file pointing to the branch you\xe2\x80\x99re on.As a concept, the head is the latest revision in a branch. If you have more than one head per named branch you probably created it when doing local commits without merging, effectively creating an unnamed branch.To have a "clean" repository, you should have one head per named branch and always merge to a named branch after you worked locally.This is also true for Mercurial.