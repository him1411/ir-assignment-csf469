I have a repository in Git. I made a branch, then did some changes both to the master and to the branch.Then, tens of commits later, I realized the branch is in much better state than the master, so I want the branch to "become" the master and disregard the changes on master. I cannot merge it, because I don\'t want to keep the changes on master. What should I do?Extra: In this case, the \'old\' master has already been push-ed to another repository such as GitHub. How does this change things?The problem with the other two answers is that the new master doesn\'t have the old master as an ancestor, so when you push it, everyone else will get messed up. This is what you want to do:If you want your history to be a little clearer, I\'d recommend adding some information to the merge commit message to make it clear what you\'ve done. Change the second line to:Make sure everything is pushed up to your remote repository (GitHub):Overwrite "master" with "better_branch":Force the push to your remote repository:Edit: You didn\'t say you had pushed to a public repo! That makes a world of difference.There are two ways, the "dirty" way and the "clean" way.  Suppose your branch is named new-master.  This is the clean way:This will make the config files change to match the renamed branches.You can also do it the dirty way, which won\'t update the config files.  This is kind of what goes on under the hood of the above...Rename the branch to master by:The solutions given here (renaming the branch in \'master\') don\'t insist on the consequences for the remote (GitHub) repo:Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. This can cause the remote repository to lose commits; use it with care.If others have already pulled your repo, they won\'t be able to pull that new master history without replacing their own master with that new GitHub master branch (or dealing with lots of merges).\nThere are alternatives to a git push --force for public repos.\nJefromi\'s answer (merging the right changes back to the original master) is one of them.From what I understand, you can branch the current branch into an existing branch. In essence, this will overwrite master with whatever you have in the current branch:Once you\'ve done that, you can normally push your local master branch, possibly requiring the force parameter here as well:No merges, no long commands. Simply branch and push\xe2\x80\x94 but, yes, this will rewrite history of the master branch, so if you work in a team you gotta know what you\'re doing.Alternatively, I found that you can push any branch to the any remote branch, so:One can also checkout all files from the other branch into master:and then commit all changes.I found this simple method to work the best. It does not rewrite history and all pervious check-ins of branch will be appended to the master. Nothing is lost and you can clearly see what transpired in the commit logObjective: Make current state of "branch" the "master"working on branch, commit and push your changes to make sure your local and remote repos are up to dateAfter this your master will be the exact state of your last commit of branch and your master commit log will show all check-ins of branch.To add to Jefromi\'s answer, if you don\'t want to place a meaningless merge in the history of the source branch, you can create a temporary branch for the ours merge, then throw it away:That way the merge commit will only exist in the history of the target branch.Alternatively, if you don\'t want to create a merge at all, you can simply grab the contents of source and use them for a new commit on target:Use: