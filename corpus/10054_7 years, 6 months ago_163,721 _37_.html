I need to compare two Dates (e.g. date1 and date2) and come up with a boolean sameDay which is true of the two Dates share the same day, and false if they are not.How can I do this? There seems to be a whirlwind of confusion here... and I would like to avoid pulling in other dependencies beyond the JDK if at all possible.to clarify: if date1 and date2 share the same year, month, and day, then sameDay is true, otherwise it is false. I realize this requires knowledge of a timezone... it would be nice to pass in a timezone but I can live with either GMT or local time as long as I know what the behavior is.again, to clarify:Note that "same day" is not as simple a concept as it sounds when different time zones can be involved. The code above will for both dates compute the day relative to the time zone used by the computer it is running on. If this is not what you need, you have to pass the relevant time zone(s) to the Calendar.getInstance() calls, after you have decided what exactly you mean with "the same day".And yes, Joda Time\'s LocalDate would make the whole thing much cleaner and easier (though the same difficulties involving time zones would be present).How about:You can also set the timezone to the SimpleDateFormat, if needed.I use the "apache commons lang" package to do this (namely org.apache.commons.lang.time.DateUtils)You can avoid external dependencies and the performance hit of using Calendar by calculating the Julian Day Number for each of the dates and then comparing these:As for adding a dependency, I\'m afraid the java.util.Date & .Calendar really are so bad that the first thing I do to any new project is add the Joda-Time library. In Java 8 you can use the new java.time package, inspired by Joda-Time.The core of Joda-Time is the DateTime class. Unlike java.util.Date, it understands its assigned time zone (DateTimeZone). When converting from j.u.Date, assign a zone.One way to verify if two date-times land on the same date is to convert to LocalDate objects. That conversion depends on the assigned time zone. To compare LocalDate objects, they must have been converted with the same zone.Here is a little utility method.Better would be another argument, specifying the time zone rather than assuming the first DateTime object\xe2\x80\x99s time zone should be used.Another approach is to create a string representation of the date portion of each date-time, then compare strings.Again, the assigned time zone is crucial.The generalized solution is to define a span of time, then ask if the span contains your target. This example code is in Joda-Time 2.4. Note that the "midnight"-related classes are deprecated. Instead use the withTimeAtStartOfDay method. Joda-Time offers three classes to represent a span of time in various ways: Interval, Period, and Duration.Using the "Half-Open" approach where the beginning of the span is inclusive and the ending exclusive.The time zone of the target can be different than the time zone of the interval.Java 8 and later comes with the java.time framework. Inspired by Joda-Time, defined by JSR 310, and extended by the ThreeTen-Extra project. See Tutorial. The makers of Joda-Time have instructed us all to move to java.time as soon as is convenient. In the meantime Joda-Time continues as an actively maintained project. But expect future work to occur only in java.time and ThreeTen-Extra rather than Joda-Time.To summarize java.time in a nutshell\xe2\x80\xa6 An Instant is a moment on the timeline in UTC. Apply a time zone (ZoneId) to get a ZonedDateTime object. To move off the timeline, to get the vague indefinite idea of a date-time, use the "local" classes: LocalDateTime, LocalDate, LocalTime. The logic discussed in the Joda-Time section of this Answer applies to java.time.The old java.util.Date class has a new toInstant method for conversion to java.time. Determining a date requires a time zone. We apply that time zone object to the Instant to obtain a ZonedDateTime. From that we extract a date-only value (a LocalDate) as our goal is to compare dates (not hours, minutes, etc.). Do the same to the second java.util.Date object we need for comparison. I\xe2\x80\x99ll just use the current moment instead.Use the special isEqual method to test for the same date value.Convert dates to Java 8 java.time.LocalDate \nas seen here.Java 8If you are using Java 8 in your project and comparing java.sql.Timestamp, you could use the LocalDate class:If you are using java.util.Date, have a look at Istvan answer which is less ambiguous.in addition to Binil Thomas solutionusageyou can apply the same logic as the SimpleDateFormat solution without relying on SimpleDateFormat