I\'m working in JavaScript. I\'d like to store a list of unique, unordered string values, with the following properties:What I really want is a set. Any suggestions for the best way to mimic a set in JavaScript?This question recommends using an Object, with the keys storing properties, and the values all set to true: is that a sensible way?If you are programming in an ES6-capable environment (such as node.js, a specific browser with the ES6 capabilities you need or transpiling ES6 code for your environment), then you can use the Set object built into ES6.  It has very nice capabilities and can be used as is right in your environment.For many simple things in an ES5 environment, using an Object works very well.  If obj is your object and A is a variable that has the value you want to operate on in the set, then you can do these:Initialization code:Question 1: Is A in the list:Question 2: Delete \'A\' from the list if it\'s there:Question 3: Add \'A\' to the list if it wasn\'t already thereFor completeness, the test for whether A is in the list is a little safer with this:because of potential conflict between built-in methods and/or properties on the base Object like the constructor property.Sidebar on ES6: The current working version of ECMAScript 6 or somethings called ES 2015 has a built-in Set object.  It is implemented now in some browsers.  Since browser availability changes over time, you can look at the line for Set in this ES6 compatibility table to see the current status for browser availability.One advantage of the the built-in Set object is that it doesn\'t coerce all keys to a string like the Object does so you can have both 5 and "5" as separate keys.  And, you can even use Objects directly in the set without a string conversion.  Here\'s an article that describes some of the capabilities and MDN\'s documentation on the Set object.I have now written a polyfill for the ES6 set object so you could start using that now and it will automatically defer to the built-in set object if the browser supports it.  This has the advantage that you\'re writing ES6 compatible code that will work all the way back to IE7.  But, there are some downsides.  The ES6 set interface takes advantage of the ES6 iterators so you can do things like for (item of mySet) and it will automatically iterate through the set for you.  But, this type of language feature cannot be implemented via polyfill.  You can still iterate an ES6 set without using the new ES6 languages features, but frankly without the new language features, it isn\'t as convenient as the other set interface I include below.You can decide which one works best for you after looking at both.  The ES6 set polyfill is here: https://github.com/jfriend00/ES6-Set.FYI, in my own testing, I\'ve noticed that the Firefox v29 Set implementation is not fully up-to-date on the current draft of the spec.  For example, you can\'t chain .add() method calls like the spec describes and my polyfill supports.  This is probably a matter of a specification in motion as it is not yet finalized.Pre-Built Set objects: If you want an already built object that has methods for operating on a set that you can use in any browser, you can use a series of different pre-built objects that implement different types of sets.  There is a miniSet which is small code that implements the basics of a set object.  It also has a more feature rich set object and several derivations including a Dictionary (let\'s you store/retrieve a value for each key) and an ObjectSet (let\'s you keep a set of objects - either JS objects or DOM objects where you either supply the function that generates a unique key for each one or the ObjectSet will generate the key for you).Here\'s a copy of the code for the miniSet (most up-to-date code is here on github).You can create an Object with no properties likewhich can act as a set and eliminates the need to use hasOwnProperty.As of ECMAScript 6, the Set data-structure is a built-in feature. Compatibility with node.js versions can be found here.In ES6 version of Javascript you have built in type for set (check compatibility with your browser).To add an element to the set you simply use .add(), which runs in O(1) and either adds the element to set (if it does not exist) or does nothing if it is already there. You can add element of any type there (arrays, strings, numbers)To check the number of elements in the set, you can simply use .size. Also runs in O(1)To remove the element from the set use .delete(). It returns true if the value was there (and was removed), and false if the value did not exist. Also runs in O(1).To check whether the element exist in a set use .has(), which returns true if the element is in the set and false otherwise. Also runs in O(1).In addition to methods you wanted, there are few additional one:There is also a Weakset which allows to add only object-type values.I have started an implementation of Sets that currently works pretty well with numbers and strings. My main focus was the difference operation, so I tried to make it as efficient as I could. Forks and code reviews are welcome!https://github.com/mcrisc/SetJSI just noticed that d3.js library has implementation of sets, maps and other data structures.\nI can\'t argue about their efficiency but judging by the fact that it is a popular library it must be what you need.The documentation is hereFor convenience I copy from the link (the first 3 functions are those of interest)Constructs a new set. If array is specified, adds the given array of string values to the returned set.Returns true if and only if this set has an entry for the specified value string.Adds the specified value string to this set.If the set contains the specified value string, removes it and returns true. Otherwise, this method does nothing and returns false.Returns an array of the string values in this set. The order of the returned values is arbitrary. Can be used as a convenient way of computing the unique values for a set of strings. For example:d3.set(["foo", "bar", "foo", "baz"]).values(); // "foo", "bar", "baz"Calls the specified function for each value in this set, passing the value as an argument. The this context of the function is this set. Returns undefined. The iteration order is arbitrary.Returns true if and only if this set has zero values.Returns the number of values in this set.Yes, that\'s a sensible way--that\'s all an object is (well, for this use-case)--a bunch of keys/values with direct access.You\'d need to check to see if it\'s already there before adding it, or if you just need to indicate presence, "adding" it again doesn\'t actually change anything, it just sets it on the object again.