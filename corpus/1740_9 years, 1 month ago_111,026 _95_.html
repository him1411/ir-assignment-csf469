I have thus far avoided the nightmare that is testing multi-threaded code since it just seems like too much of a minefield.  I\'d like to ask how people have gone about testing code that relies on threads for successful execution, or just how people have gone about testing those kinds of issues that only show up when two threads interact in a given manner?This seems like a really key problem for programmers today, it would be useful to pool our knowledge on this one imho.Look, there\'s no easy way to do this.  I\'m working on a project that is inherently multithreaded.  Events come in from the operating system and I have to process them concurrently.  The simplest way to deal with testing complex, multithhreaded application code is this:  If its too complex to test, you\'re doing it wrong.  If you have a single instance that has multiple threads acting upon it, and you can\'t test situations where these threads step all over each other, then your design needs to be redone.  Its both as simple and as complex as this.There are many ways to program for multithreading that avoids threads running through instances at the same time.  The simplest is to make all your objects immutable.  Of course, that\'s not usually possible.  So you have to identify those places in your design where threads interract with the same instance and reduce the number of those places.  By doing this, you isolate a few classes where multithreading actually occurs, reducing the overall complexity of testing your system.  But you have to realize that even by doing this you still can\'t test every situation where two threads step on each other.  To do that, you\'d have to run two threads concurrently in the same test, then control exactly what lines they are executing at any given moment.  The best you can do is simulate this situation.  But this might require you to code specifically for testing, and that\'s at best a half step towards a true solution.Probably the best way to test code for threading issues is through static analysis of the code.  If your threaded code doesn\'t follow a finite set of thread safe patterns, then you might have a problem.  I believe Code Analysis in VS does contain some knowledge of threading, but probably not much. Look, as things stand currently (and probably will stand for a good time to come), the best way to test multithreaded apps is to reduce the complexity of threaded code as much as possible.  Minimize areas where threads interact, test as best as possible, and use code analysis to identify danger areas.It\'s been a while when this question was posted, but it\'s still not answered ...kleolb02\'s answer is a good one. I\'ll try going into more details.There is a way, which I practice for C# code. For unit tests you should be able to program reproducible tests, which is the biggest challenge in multithreaded code. So my answer aims toward forcing asynchronous code into a test harness, which works synchronously.It\'s an idea from Gerard Meszardos\'s book "xUnit Test Patterns" and is called "Humble Object" (p. 695): You have to separate core logic code and anything which smells like asynchronous code from each other. This would result to a class for the core logic, which works synchronously.This puts you into the position to test the core logic code in a synchronous way. You have absolute control over the timing of the calls you are doing on the core logic and thus can make reproducible tests. And this is your gain from separating core logic and asynchronous logic.This core logic needs be wrapped around by another class, which is responsible for receiving calls to the core logic asynchronously and delegates these calls to the core logic. Production code will only access the core logic via that class. Because this class should only delegate calls, it\'s a very "dumb" class without much logic. So you can keep your unit tests for this asychronous working class at a minimum.Anything above that (testing interaction between classes) are component tests. Also in this case, you should be able to have absolute control over timing, if you stick to the "Humble Object" pattern.Tough one indeed!  In my (C++) unit tests, I\'ve broken this down into several categories along the lines of the concurrency pattern used:Unit tests for classes that operate in a single thread and aren\'t thread aware -- easy, test as usual.Unit tests for Monitor objects (those that execute synchronized methods in the callers\' thread of control) that expose a synchronized public API -- instantiate multiple mock threads that exercise the API.  Construct scenarios that exercise internal conditions of the passive object.  Include one longer running test that basically beats the heck out of it from multiple threads for a long period of time.  This is unscientific I know but it does build confidence.Unit tests for Active objects (those that encapsulate their own thread or threads of control) -- similar to #2 above with variations depending on the class design.  Public API may be blocking or non-blocking, callers may obtain futures, data may arrive at queues or need to be dequeued.  There are many combinations possible here; white box away.  Still requires multiple mock threads to make calls to the object under test.As an aside:In internal developer training that I do, I teach the Pillars of Concurrency and these two patterns as the primary framework for thinking about and decomposing concurrency problems.  There\'s obviously more advanced concepts out there but I\'ve found that this set of basics helps keep engineers out of the soup.  It also leads to code that is more unit testable, as described above.I also had serious problems testing multi- threaded code. Then I found a really cool solution in "xUnit Test Patterns" by Gerard Meszaros. The pattern he describes is called Humble object. Basically it describes how you can extract the logic into a separate, easy-to-test component that is decoupled from its environment. After you tested this logic, you can test the complicated behaviour (multi- threading, asynchronous execution, etc...)I have faced this issue several times in recent years when writing thread handling code for several projects.  I\'m providing a late answer because most of the other answers, while providing alternatives, do not actually answer the question about testing.  My answer is addressed to the cases where there is no alternative to multithreaded code; I do cover code design issues for completeness, but also discuss unit testing.Writing testable multithreaded codeThe first thing to do is to separate your production thread handling code from all the code that does actual data processing.  That way, the data processing can be tested as singly threaded code, and the only thing the multithreaded code does is to coordinate threads.The second thing to remember is that bugs in multithreaded code are probabilistic; the bugs that manifest themselves least frequently are the bugs that will sneak through into production, will be difficult to reproduce even in production, and will thus cause the biggest problems.  For this reason, the standard coding approach of writing the code quickly and then debugging it until it works is a bad idea for multithreaded code; it will result in code where the easy bugs are fixed and the dangerous bugs are still there.Instead, when writing multithreaded code, you must write the code with the attitude that you are going to avoid writing the bugs in the first place.  If you have properly removed the data processing code, the thread handling code should be small enough - preferably a few lines, at worst a few dozen lines - that you have a chance of writing it without writing a bug, and certainly without writing many bugs, if you understand threading, take your time, and are careful.Writing unit tests for multithreaded codeOnce the multithreaded code is written as carefully as possible, it is still worthwhile writing tests for that code.  The primary purpose of the tests is not so much to test for highly timing dependent race condition bugs - it\'s impossible to test for such race conditions repeatably - but rather to test that your locking strategy for preventing such bugs allows for multiple threads to interact as intended.To properly test correct locking behavior, a test must start multiple threads.  To make the test repeatable, we want the interactions between the threads to happen in a predictable order.  We don\'t want to externally synchronize the threads in the test, because that will mask bugs that could happen in production where the threads are not externally synchronized.  That leaves the use of timing delays for thread synchronization, which is the technique that I have used successfully whenever I\'ve had to write tests of multithreaded code.If the delays are too short, then the test becomes fragile, because minor timing differences - say between different machines on which the tests may be run - may cause the timing to be off and the test to fail.  What I\'ve typically done is start with delays that cause test failures, increase the delays so that the test passes reliably on my development machine, and then double the delays beyond that so the test has a good chance of passing on other machines.  This does mean that the test will take a macroscopic amount of time, though in my experience, careful test design can limit that time to no more than a dozen seconds.  Since you shouldn\'t have very many places requiring thread coordination code in your application, that should be acceptable for your test suite.Finally, keep track of the number of bugs caught by your test.  If your test has 80% code coverage, it can be expected to catch about 80% of your bugs.  If your test is well designed but finds no bugs, there\'s a reasonable chance that you don\'t have additional bugs that will only show up in production.  If the test catches one or two bugs, you might still get lucky.  Beyond that, and you may want to consider a careful review of or even a complete rewrite of your thread handling code, since it is likely that code still contains hidden bugs that will be very difficult to find until the code is in production, and very difficult to fix then.There are a few tools around that are quite good. Here is a summary of some of the Java ones.Some good static analysis tools include FindBugs (gives some useful hints), JLint, Java Pathfinder (JPF & JPF2), and Bogor.MultithreadedTC is quite a good dynamic analysis tool (integrated into JUnit) where you have to set up your own test cases.ConTest from IBM Research is interesting. It instruments your code by inserting all kinds of thread modifying behaviours (e.g. sleep & yield) to try to uncover bugs randomly.SPIN is a really cool tool for modelling your Java (and other) components, but you need to have some useful framework. It is hard to use as is, but extremely powerful if you know how to use it. Quite a few tools use SPIN underneath the hood.MultithreadedTC is probably the most mainstream, but some of the static analysis tools listed above are definitely worth looking at.Awaitility can also be useful to help you write deterministic unit tests. It allows you to wait until some state somewhere in your system is updated. For example:orIt also has Scala and Groovy support. I\'ve done a lot of this, and yes it sucks.Some tips:Listing 1:Listing 2:Listing 3:Testing MT code for correctness is, as already stated, quite a hard problem. In the end it boils down to ensuring that there are no incorrectly synchronised data races in your code. The problem with this is that there are infinitely many possibilities of thread execution (interleavings) over which you do not have much control (be sure to read this article, though). In simple scenarios it might be possible to actually prove correctness by reasoning but this is usually not the case. Especially if you want to avoid/minimize synchronization and not go for the most obvious/easiest synchronization option.An approach that I follow is to write highly concurrent test code in order to make potentially undetected data races likely to occur. And then I run those tests for some time :) I once stumbled upon a talk where some computer scientist where showing off a tool that kind of does this (randomly devising test from specs and then running them wildly, concurrently, checking for the defined invariants to be broken).By the way, I think this aspect of testing MT code has not been mentioned here: identify invariants of the code that you can check for randomly. Unfortunately, finding those invariants is quite a hard problem, too. Also they might not hold all the time during execution, so you have to find/enforce executions points where you can expect them to be true. Bringing the code execution to such a state is also a hard problem (and might itself incur concurrency issues. Whew, it\'s damn hard!Some interesting links to read:Another way to (kinda) test threaded code, and very complex systems in general is through Fuzz Testing.\nIt\'s not great, and it won\'t find everything, but its likely to be useful and its simple to do.Quote:Fuzz testing or fuzzing is a software testing technique that provides random data("fuzz") to the inputs of a program. If the program fails (for example, by crashing, or by failing built-in code assertions), the defects can be noted. The great advantage of fuzz testing is that the test design is extremely simple, and free of preconceptions about system behavior. ...Fuzz testing is often used in large software development projects that employ black box testing. These projects usually have a budget to develop test tools, and fuzz testing is one of the techniques which offers a high benefit to cost ratio. ...However, fuzz testing is not a substitute for exhaustive testing or formal methods: it can only provide a random sample of the system\'s behavior, and in many cases passing a fuzz test may only demonstrate that a piece of software handles exceptions without crashing, rather than behaving correctly. Thus, fuzz testing can only be regarded as a bug-finding tool rather than an assurance of quality.Pete Goodliffe has a series on the unit testing of threaded code.It\'s hard. I take the easier way out and try to keep the threading code abstracted from the actual test. Pete does mention that the way I do it is wrong but I\'ve either got the separation right or I\'ve just been lucky. For Java, check out chapter 12 of JCIP.  There are some concrete examples of writing deterministic, multi-threaded unit tests to at least test the correctness and invariants of concurrent code."Proving" thread-safety with unit tests is much dicier.  My belief is that this is better served by automated integration testing on a variety of platforms/configurations.I handle unit tests of threaded components the same way I handle any unit test, that is with inversion of control and isolation frameworks. I develop in the .Net-arena and out of the box the threading (among other things) is very hard (I\'d say nearly impossible) to fully isolate.Therefore I\'ve written wrappers that looks something like this (simplified):From there I can easily inject the IThreadingManager into my components and use my isolation framework of choice to make the thread behave as I expect during the test.That has so far worked great for me, and I use the same approach for the thread pool, things in System.Environment, Sleep etc. etc.I like to write two or more test methods to execute on parallel threads, and each of them make calls into the object under test. I\'ve been using Sleep() calls to coordinate the order of the calls from the different threads, but that\'s not really reliable. It\'s also a lot slower because you have to sleep long enough that the timing usually works.I found the Multithreaded TC Java library from the same group that wrote FindBugs. It lets you specify the order of events without using Sleep(), and it\'s reliable. I haven\'t tried it yet.The biggest limitation to this approach is that it only lets you test the scenarios you suspect will cause trouble. As others have said, you really need to isolate your multithreaded code into a small number of simple classes to have any hope of thoroughly testing them.Once you\'ve carefully tested the scenarios you expect to cause trouble, an unscientific test that throws a bunch of simultaneous requests at the class for a while is a good way to look for unexpected trouble.Update: I\'ve played a bit with the Multithreaded TC Java library, and it works well. I\'ve also ported some of its features to a .NET version I call TickingTest.Have a look at my related answer atDesigning a Test class for a custom BarrierIt\'s biased towards Java but has a reasonable summary of the options. In summary though (IMO) its not the use of some fancy framework that will ensure correctness but how you go about designing you multithreaded code. Splitting the concerns (concurrency and functionality) goes a huge way towards raising confidence. Growing Object Orientated Software Guided By Tests explains some options better than I can.Static analysis and formal methods (see, Concurrency: State Models and Java Programs) is an option but I\'ve found them to be of limited use in commercial development.Don\'t forget that any load/soak style tests are rarely guaranteed to highlight problems.Good luck!I just recently discovered (for Java) a tool called Threadsafe. It is a static analysis tool much like findbugs but specifically to spot multi-threading issues. It is not a replacement for testing but I can recommend it as part of writing reliable multi-threaded Java.It even catches some very subtle potential issues around things like class subsumption, accessing unsafe objects through concurrent classes and spotting missing volatile modifiers when using the double checked locking paradigm.If you write multithreaded Java give it a shot.The following article suggests 2 solutions. Wrapping a semaphore (CountDownLatch) and adds functionality like  externalize data from internal thread. Another way of achieving this purpose is to use Thread Pool (see Points of Interest).Sprinkler - Advanced synchronization objectI spent most of last week at a university library studying debugging of concurrent code. The central problem is concurrent code is non-deterministic. Typically, academic debugging has fallen into one of three camps here:Now, as above commentators have noticed, you can design your concurrent system into a more deterministic state. However, if you don\'t do that properly, you\'re just back to designing a sequential system again. My suggestion would be to focus on having a very strict design protocol about what gets threaded and what doesn\'t get threaded. If you constrain your interface so that there is minimal dependancies between elements, it is much easier.Good luck, and keep working on the problem.In Java: The Package  java.util.concurrent contains some bad known Classes, that may help to write deterministic JUnit-Tests. Have a look atI have had the unfortunate task of testing threaded code and they are definitely the hardest tests I have ever written.When writing my tests, I used a combination of delegates and events.  Basically it is all about using PropertyNotifyChanged events with a WaitCallback or some kind of ConditionalWaiter that polls.I am not sure if this was the best approach, but it has worked out for me.Have a book at the book Clean Code CHAPTER 13 there is a whole section devoted there to testing multithreaded code and also to concurrency in general which might help you design better multithreaded code.You may use EasyMock.makeThreadSafe to make testing instance threadsafe(if possible) don\'t use threads, use actors / active objects. Easy to test.