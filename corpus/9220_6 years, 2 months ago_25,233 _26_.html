I have a hex color, e.g. #F4F8FB (or rgb(244, 248, 251)) that I want converted into an as-transparent-as-possible rgba color (when displayed over white).  Make sense?  I\'m looking for an algorithm, or at least idea of an algorithm for how to do so.For Example:Ideas?FYI solution based on Guffa\'s answer:Take the lowest color component, and convert that to an alpha value. Then scale the color components by subtracting the lowest, and dividing by the alpha value.Example:So, rgb(152, 177, 202) displays as rgba(0, 62, 123, .404).I have verified in Photoshop that the colors actually match perfectly.Let r, g, and b be the input values and r\', g\', b\', and a\' be the output values, all scaled (for now, as it makes the math prettier) between 1 and 0. Then, by the formula for overlaying colors:The 1 - a\' terms represent the background contribution, and the other terms represent the foreground. Do some algebra:Intuitively, it seems that the minimum color value will be the limiting factor in the problem, so bind this to m:Set the corresponding output value, m\', to zero, as we want to maximize transparency:So, in javascript (translating from 1 to 255 along the way):Note that I\'m assuming that a\' is opacity here. It is trivial to change it to transparency - just remove the "1 -" from the formula for a\'. Anothing thing to note is that this does not seem to produce exact results - it said that the opacity was 0.498 for the example you gave above (128, 128, 255). However, this is extremely close.I\'d look to RGB<->HSL conversion. I.e. luminosity == amount of white == amount of transparency. For your example rgb( 128, 128, 255 ), we need to shift RGB values to 0 first by maximum amount, i.e. to rgb( 0, 0, 128 ) - that would be our color with as few of white as possible. And after that, using formula for luminance, we calculate amount of white we need to add to our dark color to get original color - that would be our alpha:Hope that makes sense. :)For those of you using SASS/SCSS, I\'ve wrote a small SCSS function so you can easily use the algorithm described by @GuffaI\'m just describing an idea for the algorithm, no full solution:Basically, you have three numbers x, y, z and you are looking for three new numbers x\', y\', z\' and a multiplier a in the range [0,1] such that:This is written in units where the channels also take values in the range [0,1]. In 8bit discrete values, it\'d be something like this:Moreover, you want the largest possible value a. You can solve:Etc. In real values this has infinitely many solutions, just plug in any real number a, but the problem is to find a number for which the discretization error is minimal.This should do it:The top answer didn\'t work for me with low color components. For example it does not calculate correct alpha if color is #80000. Technically it should make it into #ff0000 with alpha 0.5. To resolve this, you need to use RGB -> HSL -> RGBA conversion. This is pseudo code to get the correct values:"newRgb" will contain the value of the new adjusted color and use "alpha" variable to control the transparency.