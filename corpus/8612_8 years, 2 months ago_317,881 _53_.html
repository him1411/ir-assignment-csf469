I want to remove all special characters from a string. Allowed characters are A-Z (uppercase or lowercase), numbers (0-9), underscore (_), or the dot sign (.).I have the following, it works but I suspect (I know!) it\'s not very efficient:What is the most efficient way to do this? What would a regular expression look like, and how does it compare with normal string manipulation?The strings that will be cleaned will be rather short, usually between 10 and 30 characters in length.Why do you think that your method is not efficient? It\'s actually one of the most efficient ways that you can do it.You should of course read the character into a local variable or use an enumerator to reduce the number of array accesses:One thing that makes a method like this efficient is that it scales well. The execution time will be relative to the length of the string. There is no nasty surprises if you would use it on a large string.Edit:\nI made a quick performance test, running each function a million times with a 24 character string. These are the results:Original function: 54.5 ms.\nMy suggested change: 47.1 ms.\nMine with setting StringBuilder capacity: 43.3 ms.\nRegular expression: 294.4 ms.Edit 2:\nI added the distinction between A-Z and a-z in the code above. (I reran the performance test, and there is no noticable difference.)Edit 3:\nI tested the lookup+char[] solution, and it runs in about 13 ms.The price to pay is, of course, the initialization of the huge lookup table and keeping it in memory. Well, it\'s not that much data, but it\'s much for such a trivial function...Well, unless you really need to squeeze the performance out of your function, just go with what is easiest to maintain and understand. A regular expression would look like this:For additional performance, you can either pre-compile it or just tell it to compile on first call (subsequent calls will be faster.)I suggest creating a simple lookup table, which you can initialize in the static constructor to set any combination of characters to valid.  This lets you do a quick, single check.editAlso, for speed, you\'ll want to initialize the capacity of your StringBuilder to the length of your input string.  This will avoid reallocations.  These two methods together will give you both speed and flexibility.another editI think the compiler might optimize it out, but as a matter of style as well as efficiency, I recommend foreach instead of for.A regular expression will look like:But if performance is highly important, I recommend you to do some benchmarks before selecting the "regex path"...If you\'re using a dynamic list of characters, LINQ may offer a much faster and graceful solution:I compared this approach against two of the previous "fast" approaches (release compilation):Note that the algorithm is slightly modified - the characters are passed in as an array rather than hard-coded, which could be impacting things slightly (ie/ the other solutions would have an inner foor loop to check the character array).If I switch to a hard-coded solution using a LINQ where clause, the results are:Might be worth looking at LINQ or a modified approach if you\'re planning on writing a more generic solution, rather than hard-coding the list of characters. LINQ definitely gives you concise, highly readable code - even more so than Regex.I\'m not convinced your algorithm is anything but efficient. It\'s O(n) and only looks at each character once. You\'re not gonna get any better than that unless you magically know values before checking them.I would however initialize the capacity of your StringBuilder to the initial size of the string. I\'m guessing your perceived performance problem comes from memory reallocation.Side note: Checking A-z is not safe. You\'re including [, \\, ], ^, _, and `...Side note 2: For that extra bit of efficiency, put the comparisons in an order to minimize the number of comparisons. (At worst, you\'re talking 8 comparisons tho, so don\'t think too hard.) This changes with your expected input, but one example could be:Side note 3: If for whatever reason you REALLY need this to be fast, a switch statement may be faster. The compiler should create a jump table for you, resulting in only a single comparison:I would use a String Replace with a Regular Expression searching for "special characters", replacing all characters found with an empty string. It seems good to me. The only improvement I would make is to initialize the StringBuilder with the length of the string.I agree with this code sample. The only different it I make it into Extension Method of string type. So that you can use it in a very simple line or code:Thank to Guffa for your experiment.I had to do something similar for work, but in my case I had to filter all that is not a letter, number or whitespace (but you could easily modify it to your needs).\nThe filtering is done client-side in JavaScript, but for security reasons I am also doing the filtering server-side. Since I can expect most of the strings to be clean, I would like to avoid copying the string unless I really need to. This let my to the implementation below, which should perform better for both clean and dirty strings.This doesn\'t seem inefficient at all. You may be able to improve on it but you may compromise readability / maintainability.Regards For S&G\'s, Linq-ified way:I don\'t think this is going to be the most efficient way, however.Use:And you\'ll get a clean string s.erase() will strip it of all the special characters and is highly customisable with the my_predicate() function.HashSet is O(1)\nNot sure if it is faster than the existing comparison  I tested and this in not faster than the accepted answer.\nI will leave it up as if you needed a configurable set of characters this would be a good solution.  I wonder if a Regex-based replacement (possibly compiled) is faster. Would have to test that Someone has found this to be ~5 times slower.Other than that, you should initialize the StringBuilder with an expected length, so that the intermediate string doesn\'t have to be copied around while it grows.A good number is the length of the original string, or something slightly lower (depending on the nature of the functions inputs).Finally, you can use a lookup table (in the range 0..127) to find out whether a character is to be accepted.The following code has the following output (conclusion is that we can also save some memory resources allocating array smaller size):You can also add the following code lines to support Russian locale (array size will be 1104):I\'m not sure it is the most efficient way, but It works for meIf you\'re worried about speed, use pointers to edit the existing string. You could pin the string and get a pointer to it, then run a for loop over each character, overwriting each invalid character with a replacement character.  It would be extremely efficient and would not require allocating any new string memory.  You would also need to compile your module with the unsafe option, and add the "unsafe" modifier to your method header in order to use pointers.