I have some trivial JavaScript to effect a style change:This works fine with the latest versions of FF, Opera and IE, but fails on the latest versions of Chrome and Safari.It affects two descendants, which happen to be siblings. The first sibling updates, but the second doesn\xe2\x80\x99t. A child of the second element also has focus and contains the <a> tag that contains the above code in an onclick attribute.In the Chrome \xe2\x80\x9cDeveloper Tools\xe2\x80\x9d window if I nudge (e.g. uncheck & check) any attribute of any element, the second sibling updates to the correct style.Is there a workaround to easily and programmatically \xe2\x80\x9cnudge\xe2\x80\x9d WebKit into doing the right thing?I found some complicated suggestions and many simple ones that didn\xe2\x80\x99t work, but a comment to one of them by Vasil Dinkov provided a simple solution to force a redraw/repaint that works just fine:I\xe2\x80\x99ll let someone else comment if it works for styles other than \xe2\x80\x9cblock\xe2\x80\x9d.Thanks, Vasil!We recently encountered this and discovered that promoting the affected element to a composite layer with translateZ in CSS fixed the issue without needing extra JavaScript.As these painting issues show up mostly in Webkit/Blink, and this fix mostly targets Webkit/Blink, it\'s preferable in some cases.  Especially since the accepted answer almost certainly causes a reflow and repaint, not just a repaint.Webkit and Blink have been working hard on rendering performance, and these kinds of glitches are the unfortunate side effect of optimizations that aim to reduce unnecessary flows and paints.  CSS will-change or another succeeding specification will be the future solution, most likely.There are other ways to achieve a composite layer, but this is the most common.danorton solution didn\'t work for me. I had some really weird problems where webkit wouldn\'t draw some elements at all; where text in inputs wasn\'t updated until onblur; and changing className would not result in a redraw.My solution, I accidentally discovered, was to add a empty style element to the body, after the script.That fixed it. How weird is that? Hope this is helpful for someone.Since the display + offset trigger didn\'t work for me, I found a solution here:http://mir.aculo.us/2009/09/25/force-redraw-dom-technique-for-webkit-based-browsers/i.e.I was suffering the same issue.  danorton\'s \'toggling display\' fix did work for me when added to the step function of my animation but I was concerned about performance and I looked for other options.In my circumstance the element which wasn\'t repainting was within an absolutely position element which did not, at the time, have a z-index.  Adding a z-index to this element changed the behaviour of Chrome and repaints happened as expected -> animations became smooth.I doubt that this is a panacea, I imagine it depends why Chrome has chosen not to redraw the element but I\'m posting this specific solution here in the help it hopes someone.Cheers,\nRobtl;dr >> Try adding a z-index to the element or a parent thereof.The following works. It only has to be set once in pure CSS. And it works more reliably than a JS function. Performance seems unaffected.For some reason I couldn\'t get danorton\'s answer to work, I could see what it was supposed to do so I tweaked it a little bit to this:and it worked for me.I stumbled upon this today: Element.redraw() for prototype.jsUsing: However, I\'ve noticed sometimes that you must call redraw() on the problematic element directly. Sometimes redrawing the parent element won\'t solve the problem the child is experiencing.Good article about the way browsers render elements: Rendering: repaint, reflow/relayout, restyleI came up here because I needed to redraw scrollbars in Chrome after changing its css.If someone\'s having the same problem, I solved it by calling this function:This method is not the best solution, but it may work with everything, hiding and showing the element that needs to be redraw may solve every problem.Here is the fiddle where I used it: http://jsfiddle.net/promatik/wZwJz/18/I had this problem with a a number of divs that were inserted in another div with position: absolute, the inserted divs had no position attribute. When I changed this to position:relative it worked fine. (was really hard to pinpoint the problem)In my case the elements where inserted by Angular with ng-repeat.Not that this question needs another answer, but I found simply changing the color by a single bit forced a repaint in my particular situation.The setTimeout proved critical to move the second style change outside the current event loop.I cannot believe this is still a problem in 2014. I just had this issue when refreshing a fixed position caption box on the lower-left hand of the page while scrolling, the caption would \'ghost\' its way up the screen. After trying everything above without success, I noticed a lot of things were either slow/causing issues due to creating very short DOM relayouts etc causing somewhat unnatural feeling scrolling etc...I ended up making a fixed position, full-size div with pointer-events: none and applying danorton\'s answer to that element, which seems to force a redraw on the whole screen without interfering with the DOM.HTML:CSS:JS:The only solution works for me is similar to sowasred2012\'s answer:I have a lot of problem blocks on page, so I change display property of root element.\nAnd I use display: table; instead of display: none;, because none will reset scrolling offset.Since everyone seems to have their own problems and solutions, I figured I\'d add something that works for me.  On Android 4.1 with current Chrome, trying to drag a canvas around inside a div with overflow:hidden, I couldn\'t get a redraw unless I added an element to the parent div (where it wouldn\'t do any harm).No screen flicker or real update, and cleaning up after myself.  No global or class scoped variables, just locals.  Doesn\'t seem to hurt anything on Mobile Safari/iPad or desktop browsers.This is fine for JSBut in Jquery, and particularly when you can only use $(document).ready and cannot bind to a the .load event of an object for any particular reason, the following will work.You need to get the OUTER(MOST) container of the objects/divs and then remove all its contents into a variable, then re-add it.\nIt will make ALL changes done within the outer container visible.I\'ve found this method to be useful when working with transitionsthe "display/offsetHeight" hack didn\'t work in my case, at least when it was applied to the element being animated.i had a dropdown menu that was being open/closed over the page content. the artifacts were being left on the page content after the menu had closed (only in webkit browsers). the only way the "display/offsetHeight" hack worked is if i applied it to the body, which seems nasty.however, i did find another solution:this is still pretty hacky (it uses a CSS3 property to force hardware rendering), but at least it only affects the element in question, and worked for me on both safari and chrome on PC and Mac.This seems related to this: jQuery style not being applied in SafariThe solution suggested in the first response has worked well for me in these scenarios, namely: apply and remove a dummy class to the body after making the styling changes:This forces safari to redraw.above suggestions didnt work for me. but the below one does.Want to change the text inside the anchor dynamically. The word "Search". Created an inner tag "font" with an id attribute. Managed the contents using javascript (below)script contents:I am working on ionic html5 app, on few screens i have absolute positioned element, when scroll up or down in IOS devices (iPhone 4,5,6, 6+)i had repaint bug.Tried many solution none of them was working except this one solve my problem.I have use css class .fixRepaint on those absolute positions elements This has fixed my problem, it may be help some one I was having an issue with an SVG that was disappearing on Chrome for Android when the orientation was changed in certain circumstances. The below code doesn\'t reproduce it, but is the setup we had.Day and half later after poking and prodding and not happy with the hacky solutions offered here, I discovered that the issue was caused by the fact it seemed to keep the element in memory while drawing a new one. The solution was to make the ID of the linearGradient on the SVG unique, even though it was only ever used once per page.This can be achieved many different ways, but for our angular app we used lodash uniqueId function to add a variable to the scope:Angular Directive (JS):HTML Updates:Line 5: <linearGradient ng-attr-id="{{indicatorColourPatternId}}" x1="0" x2="0" y1="0" y2="1">Line 11: <rect x="0" y="0" rx="5" ry="5" width="100%" height="100%" ng-attr-fill="url(#{{indicatorColourPatternId}})"/>I hope this answer saves someone else a days worth of face-smashing their keyboard.A simple solution with jquery:or Had an SVG that wasn\'t showing when it was added to the html.This can be added after the svg elements are on the screen.Better solution is to use:and with jQuery:this will render correctly on Chrome.