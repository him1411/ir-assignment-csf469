Is there an implementation of (or third-party implementation for) cross field validation in Hibernate Validator 4.x? If not, what is the cleanest way to implement a cross field validator?As an example, how can you use the API to validate two bean properties are equal (such as validating a password field matches the password verify field).In annotations, I\'d expect something like:Each field constraint should be handled by a distinct validator annotation, or in other words it\'s not suggested practice to have one field\'s validation annotation checking against other fields; cross-field validation should be done at the class level. Additionally, the JSR-303 Section 2.2 preferred way to express multiple validations of the same type is via a list of annotations. This allows the error message to be specified per match.For example, validating a common form:The Annotation:The Validator:I suggest you another possible solution. Perhaps less elegant, but easier!isValid() method is invoked by the validator automatically.I\'m surprised this isn\'t available out of the box. Anyway, here is a possible solution.I\'ve created a class level validator, not the field level as described in the original question.Here is the annotation code:And the validator itself:Note that I\'ve used MVEL to inspect the properties of the object being validated. This could be replaced with the standard reflection APIs or if it is a specific class you are validating, the accessor methods themselves.The @Matches annotation can then be used used on a bean as follows:As a disclaimer, I wrote this in the last 5 minutes, so I probably haven\'t ironed out all the bugs yet. I\'ll update the answer if anything goes wrong.With Hibernate Validator 4.1.0.Final I recommend using @ScriptAssert:Nothing wrong with a custom class level validator @Matches solution.Cross fields validations can be done by creating custom constraints. Example:- Compare password and confirmPassword fields of User instance.CompareStringsStringComparisonModeCompareStringsValidator ConstraintValidatorHelper UserTestOutput Message:- [Password, ConfirmPassword] must be equal.By using the CompareStrings validation constraint, we can also compare more than two properties and we can mix any of four string comparison methods.ColorChoiceTestOutput Message:- Please choose three different colors.Similarly, we can have CompareNumbers, CompareDates, etc cross-fields validation constraints.P.S. I have not tested this code under production environment (though I tested it under dev environment), so consider this code as Milestone Release. If you find a bug, please write a nice comment. :)I have tried Alberthoven\'s example (hibernate-validator 4.0.2.GA) and i get an ValidationException: \xe2\x80\x9eAnnotated methods must follow the JavaBeans naming convention. match() does not.\xe2\x80\x9c too. After I renamed the method from \xe2\x80\x9ematch\xe2\x80\x9c to "isValid" it works.Use @EqualProperties from this dedicated JSR-303 constraint library:If you\xe2\x80\x99re using the Spring Framework then you can use the Spring Expression Language (SpEL) for that. I\xe2\x80\x99ve wrote a small library that provides JSR-303 validator based on SpEL \xe2\x80\x93 it makes cross-field validations a breeze! Take a look at https://github.com/jirutka/validator-spring.This will validate length and equality of the password fields.You can also easily modify this to validate the password fields only when not both empty.I don\'t have the reputation for commenting on the first answer but wanted to add that I have added unit tests for the winning answer and have the following observations:@FieldMatch(first="invalidFieldName1", second="validFieldName2")private String stringField = "1";private Integer integerField = new Integer(1)private int intField = 1;Very nice solution bradhouse.  Is there any way to apply the @Matches annotation to more than one field?EDIT:\nHere\'s the solution I came up with to answer this question, I modified the Constraint to accept an array instead of a single value:The code for the annotation:And the implementation:You need to call it explicitly. In the example above, bradhouse has given you all the steps to write a custom constraint.Add this code in your caller class.in the above case it would be Why not try Oval: http://oval.sourceforge.net/I looks like it supports OGNL so maybe you could do it by a more natural I like the idea from Jakub Jirutka to use Spring Expression Language. If you don\'t want to add another library/dependency (assuming that you already use Spring), here is a simplified implementation of his idea.The constraint:The validator:Apply like this:You guys are awesome. Really amazing ideas. I like Alberthoven\'s and McGin\'s most, so I decided to combine both ideas. And develop some generic solution to cater all cases. Here is my proposed solution.Solution realated with question:\nHow to access a field which is described in annotation propertyAnd how to use it...? Like this: