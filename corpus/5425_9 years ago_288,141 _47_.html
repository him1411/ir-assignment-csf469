Is there a way to conveniently define a C-like structure in Python? I\'m tired of writing stuff like:Use a named tuple, which was added to the collections module in the standard library in Python 2.6. It\'s also possible to use Raymond Hettinger\'s named tuple recipe if you need to support Python 2.4.It\'s nice for your basic example, but also covers a bunch of edge cases you might run into later as well. Your fragment above would be written as:The newly created type can be used like this:You can also use named arguments:You can use a tuple for a lot of things where you would use a struct in C (something like x,y coordinates or RGB colors for example).For everything else you can use dictionary, or a utility class like this one:I think the "definitive" discussion is here, in the published version of the Python Cookbook.Perhaps you are looking for Structs without constructors:How about a dictionary?Something like this:Then you can use this to manipulate values:And the values don\'t have to be strings.  They can be pretty much any other object.dF: that\'s pretty cool... I didn\'t\n  know that I could access the fields in\n  a class using dict.Mark: the situations that I wish I had\n  this are precisely when I want a tuple\n  but nothing as "heavy" as a\n  dictionary.You can access the fields of a class using a dictionary because the fields of a class, its methods and all its properties are stored internally using dicts (at least in CPython)....Which leads us to your second comment. Believing that Python dicts are "heavy" is an extremely non-pythonistic concept. And reading such comments kills my Python Zen. That\'s not good.You see, when you declare a class you are actually creating a pretty complex wrapper around a dictionary - so, if anything, you are adding more overhead than by using a simple dictionary. An overhead which, by the way, is meaningless in any case. If you are working on performance critical applications, use C or something.You can also pass the init parameters to the instance variables by positionYou can subclass the C structure that is available in the standard library. The ctypes module provides a Structure class. The example from the docs:Whenever I need an "instant data object that also behaves like a dictionary" (I don\'t think of C structs!), I think of this cute hack:Now you can just say:Perfectly handy for those times when you need a "data bag that\'s NOT a class", and for when namedtuples are incomprehensible...You access C-Style struct in python in following way.Note:\ninstead of \'cstruct\' name, please use your struct name\ninstead of var_i, var_f, var_str, please define your structure\'s member variable. I wrote a decorator which you can use on any method to make it so that all of the arguments passed in, or any defaults, are assigned to the instance.A quick demonstration. Note that I use a positional argument a, use the default value for b, and a named argument c. I then print all 3 referencing self, to show that they\'ve been properly assigned before the method is entered.Note that my decorator should work with any method, not just __init__.This might be a bit late but I made a solution using Python Meta-Classes (decorator version below too).When __init__ is called during run time, it grabs each of the arguments and their value and assigns them as instance variables to your class. This way you can make a struct-like class without having to assign every value manually.My example has no error checking so it is easier to follow.Here it is in action.I posted it on reddit and /u/matchu posted a decorator version which is cleaner. I\'d encourage you to use it unless you want to expand the metaclass version.Since Python 3.5 it became quite simple and beautiful (IMHO):Declare it like this: (Notice, this allows for type annotations as well)Use it like this:Or like this:I don\'t see this answer here, so I figure I\'ll add it since I\'m leaning Python right now and just discovered it. The Python tutorial (Python 2 in this case) gives the following simple and effective example:That is, an empty class object is created, then instantiated, and the fields are added dynamically.The up-side to this is its really simple. The downside is it isn\'t particularly self-documenting (the intended members aren\'t listed anywhere in the class "definition"), and unset fields can cause problems when accessed. Those two problems can be solved by:Now at a glance you can at least see what fields the program will be expecting.Both are prone to typos, john.slarly = 1000 will succeed. Still, it works.I think Python structure dictionary is suitable for this requirement.Some the answers here are massively elaborate. The simplest option I\'ve found is (from: http://norvig.com/python-iaq.html):Initialising:adding more:edit: Sorry didn\'t see this example already further down.