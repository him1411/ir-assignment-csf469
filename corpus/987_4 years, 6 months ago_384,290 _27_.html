I have been exploring different methods of editing/updating a record within Entity Framework 5 in an ASP.NET MVC3 environment, but so far none of them tick all of the boxes I need. I\'ll explain why.I have found three methods to which I\'ll mention the pros and cons:Method 1 - Load original record, update each propertyProsConsMethod 2 - Load original record, set changed valuesProsConsMethod 3 - Attach updated record and set state to EntityState.ModifiedProsConsQuestionMy question to you guys; is there a clean way that I can achieve this set of goals?I understand this is quite a minor thing to point out but I may be missing a simple solution to this. If not method one will prevail ;-)You are looking for:I really like the accepted answer.  I believe there is yet another way to approach this as well.  Let\'s say you have a very short list of properties that you wouldn\'t want to ever include in a View, so when updating the entity, those would be omitted.  Let\'s say that those two fields are Password and SSN.  This example allows you to essentially leave your business logic alone after adding a new field to your Users table and to your View.I have added an extra update method onto my repository base class that\'s similar to the update method generated by Scaffolding. Instead of setting the entire object to "modified", it sets a set of individual properties. (T is a class generic parameter.)And then to call, for example:I like one trip to the database. Its probably better to do this with view models, though, in order to avoid repeating sets of properties. I haven\'t done that yet because I don\'t know how to avoid bringing the validation messages on my view model validators into my domain project.Just to add to the list of options. You can also grab the object from the database, and use an auto mapping tool like Auto Mapper  to update the parts of the record you want to change..Depending on your use case, all the above solutions apply. This is how i usually do it however :For server side code (e.g. a batch process) I usually load the entities and work with dynamic proxies. Usually in batch processes you need to load the data anyways at the time the service runs. I try to batch load the data instead of using the find method to save some time. Depending on the process I use optimistic or pessimistic concurrency control (I always use optimistic except for parallel execution scenarios where I need to lock some records with plain sql statements, this is rare though). Depending on the code and scenario the impact can be reduced to almost zero.For client side scenarios, you have a few options Use view models. The models should have a property UpdateStatus(unmodified-inserted-updated-deleted). It is the responsibility of the client to set the correct value to this column depending on the user actions (insert-update-delete). The server can either query the db for the original values or the client should send the original values to the server along with the changed rows. The server should attach the original values and use the UpdateStatus column for each row to decide how to handle the new values. In this scenario I always use optimistic concurrency. This will only do the insert - update - delete statements and not any selects, but it might need some clever code to walk the graph and update the entities (depends on your scenario - application). A mapper can help but does not handle the CRUD logicUse a library like breeze.js that hides most of this complexity (as described in 1) and try to fit it to your use case. Hope it helps