I want users on the site to be able to download files whose paths are obscured so they cannot be directly downloaded.For instance, I\'d like the URL to be something like this, "http://example.com/download/?f=somefile.txtAnd on the server, I know that all downloadable files reside in a folder "/home/user/files/".Is there a way to make Django serve that file for download as opposed to trying to find a URL and View to display it?For the "best of both worlds" you could combine S.Lott\'s solution with the xsendfile module: django generates the path to the file (or the file itself), but the actual file serving is handled by Apache/Lighttpd. Once you\'ve set up mod_xsendfile, integrating with your view takes a few lines of code:Of course, this will only work if you have control over your server, or your hosting company has mod_xsendfile already set up.EDIT:mimetype is replaced by content_type for django 1.7EDIT:\n For nginx check this, it uses X-Accel-Redirect instead of apache X-Sendfile header.A "download" is simply an HTTP header change.See http://docs.djangoproject.com/en/dev/ref/request-response/#telling-the-browser-to-treat-the-response-as-a-file-attachment for how to respond with a download.You only need one URL definition for "/download".The request\'s GET or POST dictionary will have the "f=somefile.txt" information.Your view function will simply merge the base path with the "f" value, open the file, create and return a response object.  It should be less than 12 lines of code.S.Lott has the "good"/simple solution, and elo80ka has the "best"/efficient solution.  Here is a "better"/middle solution - no server setup, but more efficient for large files than the naive fix:http://djangosnippets.org/snippets/365/Basically, Django still handles serving the file but does not load the whole thing into memory at once.  This allows your server to (slowly) serve a big file without ramping up the memory usage.Again, S.Lott\'s X-SendFile is still better for larger files.  But if you can\'t or don\'t want to bother with that, then this middle solution will gain you better efficiency without the hassle.For a very simple but not efficient or scalable solution, you can just use the built in django serve view. This is excellent for quick prototypes or one-off work, but as has been mentioned throughout this question, you should use something like apache or nginx in production.It was mentioned above that the mod_xsendfile method does not allow for non-ASCII characters in filenames.For this reason, I have a patch available for mod_xsendfile that will allow any file to be sent, as long as the name is url encoded, and the additional header:Is sent as well.http://ben.timby.com/?p=149Tried @Rocketmonkeys solution but downloaded files were being stored as *.bin and given random names. That\'s not fine of course. Adding another line from @elo80ka solved the problem.\nHere is the code I\'m using now:You can now store files in a private directory (not inside /media nor /public_html) and expose them via django to certain users or under certain circumstances.\nHope it helps. \nThanks to @elo80ka, @S.Lott and @Rocketmonkeys for the answers, got the perfect solution combining all of them =)Try: https://pypi.python.org/pypi/django-sendfile/"Abstraction to offload file uploads to web-server (e.g. Apache with mod_xsendfile) once Django has checked permissions etc."Just mentioning the FileResponse object available in Django 1.10You should use sendfile apis given by popular servers like apache or nginx\nin production. Many years i was using sendfile api of these servers for protecting files. Then created a simple middleware based django app for this purpose suitable for both development & production purpose.You can access the source code here.\nUPDATE: in new version python provider uses django FileResponse if available and also adds support for many server implementations from lighthttp, caddy to hiawathaUsagein your classbased or function views set response header X-File value to absolute path to the file. For example,  django-fileprovider impemented in a way that your code will need only minimum modification.Nginx configuration To protect file from direct access you can set the configuration asHere nginx sets a location url /files/ only access internaly, if you are using above configuration you can set X-File as,  By doing this with nginx configuration, the file will be protected & also you can control the file from django viewsDjango recommend that you use another server to serve static media (another server running on the same machine is fine.) They recommend the use of such servers as lighttp. This is very simple to set up. However. if \'somefile.txt\' is generated on request (content is dynamic) then you may want django to serve it.Django Docs - Static FilesAnother project to have a look at: http://readthedocs.org/docs/django-private-files/en/latest/usage.html\nLooks promissing, haven\'t tested it myself yet tho.Basically the project abstracts the mod_xsendfile configuration and allows you to do things like:I have faced the same problem more then once and so implemented using xsendfile module and auth view decorators the django-filelibrary. Feel free to use it as inspiration for your own solution. https://github.com/danielsokolowski/django-filelibraryProviding protected access to static html folder using https://github.com/johnsensible/django-sendfile: https://gist.github.com/iutinvg/9907731