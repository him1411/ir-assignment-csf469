I almost never see a for loop like this:Is there a technical reason to use > or < instead of != when incrementing by 1 in a for loop? Or this is more of a convention?It is 6:31pm... Damn, now my next chance to go home is tomorrow! :)This to show that the stronger restriction mitigates risks and is probably more intuitive to understand.There is no technical reason. But there is mitigation of risk, maintainability and better understanding of code.< or > are stronger restrictions than != and fulfill the exacts same purpose in most cases (I\'d even say in all practical cases).There is duplicate question here; and one interesting answer.There are already answers, but there is another case, where the difference matters. If you have a loop like this:this loop will work as expected for any values of a and b while if you used != you would have to check for a <= b before running the loop. So again it boils down to: In most cases there is no difference, but in some cases the small difference matters a lot. If you want to have all your loops look the same (and not for each loop have to consider which version is better) then just use < and not !=.In some special cases you might need != and not <, but these are really special cases and then it makes sense that they look different than the usual loops.When I first answered this question I considered only plain old loops with an int counter. Once iterators enter the game, the situation is different. Loops with iterators usually look like this:The reason is* that it is a much weaker constraint to implement an != operator. Almost any two object can be tested for inequality, but not for all types a < operator makes sense. Especially when the containers elements are not ordered the iterators cannot implement it. Thus the more generic way of writing such a loop is with !=. However, my point from above is still valid: There might be cases with an int counter where you have to use !=. They are rare and when they occur you want them to be easily identifiable. Thus it is common to write most int-counter loops with <.* = Comes without warranty. Please someone correct me if I am wrong ;)  You can have something likeIf your loop variable is written by the inner code, the i!=5 might not break that loop. This is safer to check for inequality.Edit about readability.\nThe inequality form is way more frequently used. Therefore, this is very fast to read as there is nothing special to understand (brain load is reduced because the task is common). So it\'s cool for the readers to make use of these habits.And last but not least, this is called defensive programming, meaning to always take the strongest case to avoid current and future errors influencing the program.The only case where defensive programming is not needed is where states have been proven by pre- and post-conditions (but then, proving this is the most defensive of all programming).I would argue that an expression likeis more expressive of intent than isThe former clearly calls out that the condition is a test for an exclusive upper bound on a range; the latter is a binary test of an exit condition. And if the body of the loop is non-trivial, it may not apparent that the index is only modified in the for statement itself.Iterators are an important case when you most often use the != notation:Granted: in practice I would write the same relying on a range-for:but the point remains: one normally compares iterators using == or !=.The loop condition is an enforced loop invariant.Suppose you don\'t look at the body of the loop:in this case, you know at the start of the loop iteration that i does not equal 5.in this case, you know at the start of the loop iteration that i is less than 5.The second is much, much more information than the first, no?  Now, the programmer intent is (almost certainly) the same, but if you are looking for bugs, having confidence from reading a line of code is a good thing.  And the second enforces that invariant, which means some bugs that would bite you in the first case just cannot happen (or don\'t cause memory corruption, say) in the second case.You know more about the state of the program, from reading less code, with < than with !=.  And on modern CPUs, they take the same amount of time as no difference.If your i was not manipulated in the loop body, and it was always increased by 1, and it started less than 5, there would be no difference.  But in order to know if it was manipulated, you\'d have to confirm each of these facts.Some of these facts are relatively easy, but you can get wrong.  Checking the entire body of the loop is, however, a pain.In C++ you can write an indexes type such that:does the same thing as either of the two above for loops, even down to the compiler optimizing it down to the same code.  Here, however, you know that i cannot be manipulated in the body of the loop, as it is declared const, without the code corrupting memory.The more information you can get out of a line of code without having to understand the context, the easier it is to track down what is going wrong.  < in the case of integer loops gives you more information about the state of the code at that line than != does.It may happen, that the variable i is set to some large value and if you just use the != operator you will end up in an endless loop.As already said by Ian Newson, you can\'t reliably loop over a floating variable and exit with !=. For instance,will actually loop forever, because 0.1 can\'t exactly be represented in floating point, hence the counter narrowly misses 1. With < it terminates.(Note however that it\'s basically undefined behaviour whether you get 0.9999... as the last accepted number – which kind of violates the less-than assumption – or already exit at 1.0000000000000001.)As you can see from the other numerous answers, there are reasons to use < instead of != which will help in edge cases, initial conditions, unintended loop counter modification, etc...Honestly though, I don\'t think you can stress the importance of convention enough. For this example it will be easy enough for other programmers to see what you are trying to do, but it will cause a double-take. One of the jobs while programming is making it as readable and familiar to everyone as possible, so inevitably when someone has to update/change your code, it doesn\'t take a lot of effort to figure out what you were doing in different code blocks. If I saw someone use !=, I\'d assume there was a reason they used it instead of < and if it was a large loop I\'d look through the whole thing trying to figure out what you did that made that necessary... and that\'s wasted time.There are several ways to write any kind of code (usually), there just happens to be two ways in this case (three if you count <= and >=).In this case, people prefer > and < to make sure that even if something unexpected happens in the loop (like a bug), it won\'t loop infinitely (BAD). Consider the following code, for example.If we used (i < 3), we would be safe from an infinite loop because it placed a bigger restriction.Its really your choice whether you want a mistake in your program to shut the whole thing down or keep functioning with the bug there.Hope this helped!Yes; OpenMP doesn\'t parallelize loops with the != conditoin.I take the adjectival "technical" to mean language behavior/quirks and compiler side effects such as performance of generated code.To this end, the answer is: no(*). The (*) is "please consult your processor manual". If you are working with some edge-case RISC or FPGA system, you may need to check what instructions are generated and what they cost. But if you\'re using pretty much any conventional modern architecture, then there is no significant processor level difference in cost between lt, eq, ne and gt.If you are using an edge case you could find that != requires three operations (cmp, not, beq) vs two (cmp, blt xtr myo). Again, RTM in that case.For the most part, the reasons are defensive/hardening, especially when working with pointers or complex loops. ConsiderA less contrived example would be where you are using return values to perform increments, accepting data from a user:Try this and input the values 1, 2, 10, 999.You could prevent this:But what you probably wanted wasThere is also something of a convention bias towards <, because ordering in standard containers often relies on operator<, for instance hashing in several STL containers determines equality by sayingIf lhs and rhs are a user defined class writing this code asThe implementor has to provide two comparison functions. So < has become the favored operator.The most common reason to use < is convention.  More programmers think of loops like this as "while the index is in range" rather than "until the index reaches the end."  There\'s value is sticking to convention when you can.On the other hand, many answers here are claiming that using the < form helps avoid bugs.  I\'d argue that in many cases this just helps hide bugs.  If the loop index is supposed to reach the end value, and, instead, it actually goes beyond it, then there\'s something happening you didn\'t expect which may cause a malfunction (or be a side effect of another bug).  The < will likely delay discovery of the bug.  The != is more likely to lead to a stall, hang, or even a crash, which will help you spot the bug sooner.  The sooner a bug is found, the cheaper it is to fix.Note that this convention is peculiar to array and vector indexing.  When traversing nearly any other type of data structure, you\'d use an iterator (or pointer) and check directly for an end value.  In those cases you have to be sure the iterator will reach and not overshoot the actual end value.For example, if you\'re stepping through a plain C string, it\'s generally more common to write:thanFor one thing, if the string is very long, the second form will be slower because the strlen is another pass through the string.With a C++ std::string, you\'d use a range-based for loop, a standard algorithm, or iterators, even if though the length is readily available.  If you\'re using iterators, the convention is to use != rather than <, as in:Similarly, iterating a tree or a list or a deque usually involves watching for a null pointer or other sentinel rather than checking if an index remains within a range.One reason not to use this construct is floating point numbers. != is a very dangerous comparison to use with floats as it\'ll rarely evaluate to true even if the numbers look the same. < or > removes this risk.There are two related reasons for following this practice that both have to do with the fact that a programming language is, after all, a language that will be read by humans (among others).(1) A bit of redundancy. In natural language we usually provide more information than is strictly necessary, much like an error correcting code. Here the extra information is that the loop variable i (see how I used redundancy here? If you didn\'t know what \'loop variable\' means, or if you forgot the name of the variable, after reading "loop variable i" you have the full information) is less than 5 during the loop, not just different from 5. Redundancy enhances readability.(2) Convention. Languages have specific standard ways of expressing certain situations. If you don\'t follow the established way of saying something, you will still be understood, but the effort for the recipient of your message is greater because certain optimisations won\'t work. Example:Don\'t talk around the hot mash. Just illuminate the difficulty!The first sentence is a literal translation of a German idiom. The second is a common English idiom with the main words replaced by synonyms. The result is comprehensible but takes a lot longer to understand than this:Don\'t beat around the bush. Just explain the problem!This is true even in case the synonyms used in the first version happen to fit the situation better than the conventional words in the English idiom. Similar forces are in effect when programmers read code. This is also why 5 != i and 5 > i are weird ways of putting it unless you are working in an environment in which it is standard to swap the more normal i != 5 and i < 5 in this way. Such dialect communities do exist, probably because consistency makes it easier to remember to write 5 == i instead of the natural but error prone i == 5.Using relational comparisons in such cases is more of a popular habit than anything else. It gained its popularity back in the times when such conceptual considerations as iterator categories and their comparability were not considered high priority.I\'d say that one should prefer to use equality comparisons instead of relational comparisons whenever possible, since equality comparisons impose less requirements on the values being compared. Being EqualityComparable is a lesser requirement than being LessThanComparable.Another example that demonstrates the wider applicability of equality comparison in such contexts is the popular conundrum with implementing unsigned iteration down to 0. It can be done asNote that the above is equally applicable to both signed and unsigned iteration, while the relational version breaks down with unsigned types.Besides the examples, where the loop variable will (unintentional) change inside the body, there are other reasions to use the smaller-than or greater-than operators:In addition to the various people who have mentioned that it mitigates risk, it also reduces the number of function overloads necessary to interact with various standard library components.   As an example, if you want your type to be storable in a std::set, or used as a key for std::map, or used with some of the searching and sorting algorithms, the standard library usually uses std::less to compare objects as most algorithms only need a strict weak ordering.  Thus it becomes a good habit to use the < comparisons instead of != comparisons (where it makes sense, of course).There is no problem from a syntax perspective, but the logic behind that expression 5!=i is not sound.In my opinion, using != to set the bounds of a for loop is not logically sound because a for loop either increments or decrements the iteration index, so setting the loop to iterate until the iteration index becomes out of bounds (!= to something) is not a proper implementation.It will work, but it is prone to misbehavior since the boundary data handling is lost when using != for an incremental problem (meaning that you know from the start if it increments or decrements), that\'s why instead of != the <>>==> are used.