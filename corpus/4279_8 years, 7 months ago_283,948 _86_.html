Is there an isnan() function?PS.: I\'m in MinGW (if that makes a difference).I had this solved by using isnan() from <math.h>, which doesn\'t exist in <cmath>, which I was #includeing at first.According to the IEEE standard, NaN values have the odd property that comparisons involving them are always false. That is, for a float f, f != f will be true only if f is NaN. Note that, as some comments below have pointed out, not all compilers respect this when optimizing code. For any compiler which claims to use IEEE floating point, this trick should work. But I can\'t guarantee that it will work in practice. Check with your compiler, if in doubt.There is no isnan() function available in current C++ Standard Library. It was introduced in C99 and defined as a macro not a function. Elements of standard library defined by C99 are not part of current C++ standard ISO/IEC 14882:1998 neither its update ISO/IEC 14882:2003.In 2005 Technical Report 1 was proposed. The TR1 brings compatibility with C99 to C++. In spite of the fact it has never been officially adopted to become C++ standard, many (GCC 4.0+ or Visual C++ 9.0+ C++ implementations do provide TR1 features, all of them or only some (Visual C++ 9.0 does not provide C99 math functions).If TR1 is available, then cmath includes C99 elements like isnan(), isfinite(), etc. but they are defined as functions, not macros, usually in std::tr1:: namespace, though many implementations (i.e. GCC 4+ on Linux or in XCode on Mac OS X 10.5+) inject them directly to std::, so std::isnan is well defined.Moreover, some implementations of C++ still make C99 isnan() macro available for C++ (included through cmath or math.h), what may cause more confusions and developers may assume it\'s a standard behaviour.A note about Viusal C++, as mentioned above, it does not provide std::isnan neither std::tr1::isnan, but it provides an extension function defined as _isnan() which has been available since Visual C++ 6.0On XCode, there is even more fun. As mentioned, GCC 4+ defines std::isnan. For older versions of compiler and library form XCode, it seems (here is relevant discussion), haven\'t had chance to check myself) two functions are defined, __inline_isnand() on Intel and __isnand() on Power PC.Since this was asked there were a bit of new developments: it is important to know that std::isnan() is part of C++11Defined in header <cmath>Determines if the given floating point number arg is not-a-number (NaN).Parametersarg: floating point valueReturn valuetrue if arg is NaN, false otherwiseReferencehttp://en.cppreference.com/w/cpp/numeric/math/isnanPlease note that this is incompatible with -fast-math if you use g++, see below for other suggestions.For C99, in C, this is implemented as a macro isnan(c)that returns an int value. The type of x shall be float, double or long double.Various vendors may or may not include or not a function isnan().The supposedly portable way to check for NaN is to use the IEEE 754 property that NaN is not equal to itself: i.e. x == x will be false for x being NaN.However the last option may not work with every compiler and some settings (particularly optimisation settings), so in last resort, you can always check the bit pattern ...There is also a header-only library present in Boost that have neat tools to deal with floating point datatypesYou get the following functions:If you have time then have a look at whole Math toolkit from Boost, it has many useful tools and is growing quickly.Also when dealing with floating and non-floating points it might be a good idea to look at the Numeric Conversions.There are three "official" ways: posix isnan macro, c++0x isnan function template, or visual c++ _isnan function.Unfortunately it\'s rather impractical to detect which of those to use.And unfortunately, there\'s no reliable way to detect whether you have IEEE 754 representation with NaNs. The standard library offers an official such way (numeric_limits<double>::is_iec559). But in practice compilers such as g++ screw that up.In theory one could use simply x != x, but compilers such as g++ and visual c++ screw that up.So in the end, test for the specific NaN bitpatterns, assuming (and hopefully enforcing, at some point!) a particular representation such as IEEE 754.EDIT: as an example of "compilers such as g++ … screw that up", considerCompiling with g++ (TDM-2 mingw32) 4.4.1:There is an std::isnan if you compiler supports c99 extensions, but I\'m not sure if mingw does.Here is a small function which should work if your compiler doesn\'t have the standard function:You can use numeric_limits<float>::quiet_NaN( ) defined in the limits standard library to test with.  There\'s a separate constant defined for double.I don\'t know if this works on all platforms, as I only tested with g++ on Linux.You can use the isnan() function, but you need to include the C math library.As this function is part of C99, it is not available everywhere. If your vendor does not supply the function, you can also define your own variant for compatibility.The following code uses the definition of NAN (all exponent bits set, at least one fractional bit set) and assumes that sizeof(int) = sizeof(float) = 4.  You can look up NAN in Wikipedia for the details.bool IsNan( float value )\n{\n    return ((*(UINT*)&value) & 0x7fffffff) > 0x7f800000;\n}\nMy answer to this question is don\'t use retroactive checks for nan.  Use preventive checks for divisions of the form 0.0/0.0 instead.nan results from the operation 0.f/0.f, or 0.0/0.0.  nan is a terrible nemesis to the stability of your code that must be detected and prevented very carefully1.  The properties of nan that are different from normal numbers:The last 2 properties listed are counter-logical and will result in odd behavior of code that relies on comparisons with a nan number (the 3rd last property is odd too but you\'re probably not ever going to see x != x ? in your code (unless you are checking for nan (unreliably))).In my own code, I noticed that nan values tend to produce difficult to find bugs. (Note how this is not the case for inf or -inf.  (-inf < 0) returns TRUE, ( 0 < inf ) returns TRUE, and even (-inf < inf) returns TRUE. So, in my experience, the behavior of the code is often still as desired).What you want to happen under 0.0/0.0 must be handled as a special case, but what you do must depend on the numbers you expect to come out of the code.In the example above, the result of (0.f/FLT_MIN) will be 0, basically.  You may want 0.0/0.0 to generate HUGE instead.  So,So in the above, if x were 0.f, inf would result (which has pretty good/nondestructive behavior as mentioned above actually).Remember, integer division by 0 causes a runtime exception.  So you must always check for integer division by 0.  Just because 0.0/0.0 quietly evaluates to nan doesn\'t mean you can be lazy and not check for 0.0/0.0 before it happens.1 Checks for nan via x != x are sometimes unreliable (x != x being stripped out by some optimizing compilers that break IEEE compliance, specifically when the -ffast-math switch is enabled).This works if sizeof(int) is 4 and sizeof(long long) is 8.During run time it is only comparison, castings do not take any time. It just changes comparison flags configuration to check equality.A possible solution that would not depend on the specific IEEE representation for NaN used would be the following:As for me the solution could be a macro to make it explicitly inline and thus fast enough.\nIt also works for any float type. It bases on the fact that the only case when a value is not equals itself is when the value is not a number.After reading the other answers I wanted something that would pass through the floating-point comparison warning and would not break under fast math. The following code appears to work:Considering that (x != x) is not always guaranteed for NaN (such as if using the -ffast-math option), I\'ve been using:Numbers can\'t be both < 0 and >= 0, so really this check only passes if the number is neither less than, nor greater than or equal to zero.  Which is basically no number at all, or NaN.You could also use this if you prefer:I\'m not sure how this is affected by -ffast-math though, so your mileage may vary.As of C++14 there are a number of ways to test if a floating point number value is a NaN.Of these ways, only checking of the bits of the number\'s representation,\nworks reliably, as noted in my original answer. In particular, std::isnan and the often proposed check v != v, do not work reliably and should not be used, lest your code stops working correctly when someone decides that floating point optimization is needed, and asks the compiler to do that. This situation can change, compilers can get more conforming, but for this issue that hasn\'t happened in the 6 years since the original answer.For about 6 years my original answer was the selected solution for this question, which was OK. But recently a highly upvoted answer recommending the unreliable v != v test has been selected. Hence this additional more up-to-date answer (we now have the C++11 and C++14 standards, and C++17 on the horizon).The main ways to check for NaN-ness, as of C++14, are:std::isnan(value) )\nis the intended standard library way since C++11. isnan apparently conflicts with the\nPosix macro of the same name, but in practice that isn\'t a problem. The main problem is\nthat when floating point arithmetic optimization is requested, then with at least one main compiler, namely g++, std::isnan returns false for NaN argument.(fpclassify(value) == FP_NAN) )\nSuffers from the same problem as std::isnan, i.e., is not reliable.(value != value) )\nRecommended in many SO answers. Suffers from the same problem as std::isnan, i.e.,\nis not reliable.(value == Fp_info::quiet_NaN()) )\nThis is a test that with standard behavior should not detect NaNs, but that with the\noptimized behavior maybe could detect NaNs (due to optimized code just comparing the\nbitlevel representations directly), and perhaps combined with another way to\ncover the standard un-optimized behavior, could reliably detect NaN. Unfortunately\nit turned out to not work reliably.(ilogb(value) == FP_ILOGBNAN) )\nSuffers from the same problem as std::isnan, i.e., is not reliable.isunordered(1.2345, value) )\nSuffers from the same problem as std::isnan, i.e., is not reliable.is_ieee754_nan( value ) )\nThis isn\'t a standard function. It\'s checking of the bits according to the IEEE 754\nstandard. It\'s completely reliable but the code is somewhat system-dependent.In the following complete test code “success” is whether an expression reports Nan-ness of the value. For most expressions this measure of success, the goal of detecting NaNs and only NaNs, corresponds to their standard semantics. For the (value == Fp_info::quiet_NaN()) ) expression, however, the standard behavior is that it doesn\'t work as a NaN-detector.Results with g++ (note again that the standard behavior of (value == Fp_info::quiet_NaN()) is that it doesn\'t work as a NaN-detector, it\'s just very much of practical interest here):Results with Visual C++:Summing up the above results, only direct testing of the bit-level representation, using the is_ieee754_nan function defined in this test program, worked reliably in all cases with both g++ and Visual C++.Addendum:\nAfter posting the above I became aware of yet another possible to test for NaN, mentioned in another answer here, namely ((value < 0) == (value >= 0)). That turned out to work fine with Visual C++ but failed with g++\'s -ffast-math option. Only direct bitpattern testing works reliably.This works:output: isnanThe IEEE standard says\nwhen exponent is all 1s\nand\nmantissa is not zero,\nthe number is a NaN.\nDouble is 1 sign bit, 11 exponent bits and 52 mantissa bits.\nDo a bit check.It seems to me that the best truly cross-platform approach would be to use a union and to test the bit pattern of the double to check for NaNs. I have not thoroughly tested this solution, and there may be a more efficient way of working with the bit patterns, but I think that it should work.As comments above state a != a will not work in g++ and some other compilers, but this trick should. It may not be as efficient, but it\'s still a way:Basically, in g++ (I am not sure about others though) printf prints \'nan\' on %d or %.f formats if variable is not a valid integer/float. Therefore this code is checking for the first character of string to be \'n\' (as in "nan")