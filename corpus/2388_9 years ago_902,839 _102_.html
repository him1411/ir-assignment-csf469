I\'m not a SQL expert, and I\'m reminded of the fact every time I need to do something beyond the basics. I have a test database that is not large in size, but the transaction log definitely is. How do I clear out the transaction log?Making a log file smaller should really be reserved for scenarios where it encountered unexpected growth which you do not expect to happen again. If the log file will grow to the same size again, not very much is accomplished by shrinking it temporarily. Now, depending on the recovery goals of your database, these are the actions you should take.Never make any changes to your database without ensuring you can restore it should something go wrong.(And by point-in-time recovery, I mean you care about being able to restore to anything other than a full or differential backup.)Presumably your database is in FULL recovery mode. If not, then make sure it is:Even if you are taking regular full backups, the log file will grow and grow until you perform a log backup - this is for your protection, not to needlessly eat away at your disk space. You should be performing these log backups quite frequently, according to your recovery objectives. For example, if you have a business rule that states you can afford to lose no more than 15 minutes of data in the event of a disaster, you should have a job that backs up the log every 15 minutes. Here is a script that will generate timestamped file names based on the current time (but you can also do this with maintenance plans etc., just don\'t choose any of the shrink options in maintenance plans, they\'re awful).Note that \\\\backup_share\\ should be on a different machine that represents a different underlying storage device. Backing these up to the same machine (or to a different machine that uses the same underlying disks, or a different VM that\'s on the same physical host) does not really help you, since if the machine blows up, you\'ve lost your database and its backups. Depending on your network infrastructure it may make more sense to backup locally and then transfer them to a different location behind the scenes; in either case, you want to get them off the primary database machine as quickly as possible.Now, once you have regular log backups running, it should be reasonable to shrink the log file to something more reasonable than whatever it\'s blown up to now. This does not mean running SHRINKFILE over and over again until the log file is 1 MB - even if you are backing up the log frequently, it still needs to accommodate the sum of any concurrent transactions that can occur. Log file autogrow events are expensive, since SQL Server has to zero out the files (unlike data files when instant file initialization is enabled), and user transactions have to wait while this happens. You want to do this grow-shrink-grow-shrink routine as little as possible, and you certainly don\'t want to make your users pay for it.Note that you may need to back up the log twice before a shrink is possible (thanks Robert).So, you need to come up with a practical size for your log file. Nobody here can tell you what that is without knowing a lot more about your system, but if you\'ve been frequently shrinking the log file and it has been growing again, a good watermark is probably 10-50% higher than the largest it\'s been. Let\'s say that comes to 200 MB, and you want any subsequent autogrowth events to be 50 MB, then you can adjust the log file size this way:Note that if the log file is currently > 200 MB, you may need to run this first:If this is a test database, and you don\'t care about point-in-time recovery, then you should make sure that your database is in SIMPLE recovery mode.Putting the database in SIMPLE recovery mode will make sure that SQL Server re-uses portions of the log file (essentially phasing out inactive transactions) instead of growing to keep a record of all transactions (like FULL recovery does until you back up the log). CHECKPOINT events will help control the log and make sure that it doesn\'t need to grow unless you generate a lot of t-log activity between CHECKPOINTs.Next, you should make absolute sure that this log growth was truly due to an abnormal event (say, an annual spring cleaning or rebuilding your biggest indexes), and not due to normal, everyday usage. If you shrink the log file to a ridiculously small size, and SQL Server just has to grow it again to accommodate your normal activity, what did you gain? Were you able to make use of that disk space you freed up only temporarily? If you need an immediate fix, then you can run the following:Otherwise, set an appropriate size and growth rate. As per the example in the point-in-time recovery case, you can use the same code and logic to determine what file size is appropriate and set reasonable autogrowth parameters. Back up the log with TRUNCATE_ONLY option and then SHRINKFILE. For one, this TRUNCATE_ONLY option has been deprecated and is no longer available in current versions of SQL Server. Second, if you are in FULL recovery model, this will destroy your log chain and require a new, full backup.Detach the database, delete the log file, and re-attach. I can\'t emphasize how dangerous this can be. Your database may not come back up, it may come up as suspect, you may have to revert to a backup (if you have one), etc. etc.Use the "shrink database" option. DBCC SHRINKDATABASE and the maintenance plan option to do the same are bad ideas, especially if you really only need to resolve a log problem issue. Target the file you want to adjust and adjust it independently, using DBCC SHRINKFILE or ALTER DATABASE ... MODIFY FILE (examples above).Shrink the log file to 1 MB. This looks tempting because, hey, SQL Server will let me do it in certain scenarios, and look at all the space it frees! Unless your database is read only (and it is, you should mark it as such using ALTER DATABASE), this will absolutely just lead to many unnecessary growth events, as the log has to accommodate current transactions regardless of the recovery model. What is the point of freeing up that space temporarily, just so SQL Server can take it back slowly and painfully?Create a second log file. This will provide temporarily relief for the drive that has filled your disk, but this is like trying to fix a punctured lung with a band-aid. You should deal with the problematic log file directly instead of just adding another potential problem. Other than redirecting some transaction log activity to a different drive, a second log file really does nothing for you (unlike a second data file), since only one of the files can ever be used at a time. Paul Randal also explains why multiple log files can bite you later.Instead of shrinking your log file to some small amount and letting it constantly autogrow at a small rate on its own, set it to some reasonably large size (one that will accommodate the sum of your largest set of concurrent transactions) and set a reasonable autogrow setting as a fallback, so that it doesn\'t have to grow multiple times to satisfy single transactions and so that it will be relatively rare for it to ever have to grow during normal business operations.The worst possible settings here are 1 MB growth or 10% growth. Funny enough, these are the defaults for SQL Server (which I\'ve complained about and asked for changes to no avail) - 1 MB for data files, and 10% for log files. The former is much too small in this day and age, and the latter leads to longer and longer events every time (say, your log file is 500 MB, first growth is 50 MB, next growth is 55 MB, next growth is 60.5 MB, etc. etc. - and on slow I/O, believe me, you will really notice this curve).Please don\'t stop here; while much of the advice you see out there about shrinking log files is inherently bad and even potentially disastrous, there are some people who care more about data integrity than freeing up disk space.A blog post I wrote four years ago, when I saw a few "here\'s how to shrink the log file" posts spring up.A blog post Brent Ozar wrote four years ago, pointing to multiple resources, in response to a SQL Server Magazine article that should not have been published.A blog post by Paul Randal explaining why t-log maintenance is important and why you shouldn\'t shrink your data files, either.Mike Walsh has a great answer covering some of these aspects too, including reasons why you might not be able to shrink your log file immediately.DISCLAIMER: Please read comments below carefully, and I assume you\'ve already read the accepted answer. As I said nearly 5 years ago :if anyone has any comments to add for situations when this is NOT an\n  adequate or optimal solution then please comment belowRight click on the database name. Select Tasks -> Shrink -> DatabaseThen click OK!I usually open the Windows Explorer directory containing the database files so I can immediately see the effect.I was actually quite surprised this worked! Normally I\'ve used DBCC before, but I just tried that and it didn\'t shrink anything so I tried the GUI (2005) and it worked great - freeing up 17Gb in 10 secondsEdit: In Full recovery mode this might not work, so you have to either back up the log first, or change to Simple recovery, then shrink the file.  [thanks @onupdatecascade for this]--ps: I appreciate what some have commented regarding the dangers of this, but in my environment have had no issues doing this myself especially since I always do a full backup first. So please take into consideration what your environment is, and how this affects your backup strategy and job security before continuing. All I was doing was pointing people to a feature provided by Microsoft!from : http://msdn.microsoft.com/en-us/library/ms189493.aspxyou may want to backup first[answer ads more details than requested but I hope it\xe2\x80\x99s useful]Below is a script to shrink transaction log but I\xe2\x80\x99d definitely recommend backing up transaction log before shrinking it.If you just shrink file you are going to lose a ton of data that may come as a live saver in case of disaster. Transaction log contains a lot of useful data that can be read using 3rd party transaction log reader (it can be read manually but with extreme effort though).\nTransaction log is also a must when it comes to point in time recovery so don\xe2\x80\x99t just throw it away but make sure you back it up beforehand. Here are several posts where people used data stored in transaction log to accomplish recovery How to view transaction logs in sql server 2008Read the log file (*.LDF) in sql server 2008You may get error that looks like this when executing commands aboveThis means that TLOG is in use. In this case try executing this several times in a row or find a way to reduce database activities.If you do not use the transaction logs for restores (i.e. You only ever do full backups), you can set Recovery Mode to "Simple", and the transaction log will very shortly shrink and never fill up again. If you are using SQL 7 or 2000, you can enable "truncate log on checkpoint" in the database options tab. This has the same effect.This is not recomended in production environments obviously, since you will not be able to restore to a point in time.Here is a simple and very inelegant & potentially dangerous  way. I\'m guessing that you are not doing log backups. (Which truncate the log). My advice is to change recovery model from full to simple. This will prevent log bloat.This technique that John recommends is not recommended as there is no guarantee that the database will attach without the log file. Change the database from full to simple, force a checkpoint and wait a few minutes. The SQL Server will clear the log, which you can then shrink using DBCC SHRINKFILE.Most answers here so far are assuming you do not actually need the Transaction Log file, however if your database is using the FULL recovery model, and you want to keep your backups in case you need to restore the database, then do not truncate or delete the log file the way many of these answers suggest.Eliminating the log file (through truncating it, discarding it, erasing it, etc) will break your backup chain, and will prevent you from restoring to any point in time since your last full, differential, or transaction log backup, until the next full or differential backup is made.From the Microsoft article onBACKUPWe recommend that you never use NO_LOG or TRUNCATE_ONLY to manually\n  truncate the transaction log, because this breaks the log chain. Until\n  the next full or differential database backup, the database is not\n  protected from media failure. Use manual log truncation in only very\n  special circumstances, and create backups of the data immediately.To avoid that, backup your log file to disk before shrinking it. The syntax would look something like this:The SQL Server transaction log needs to be properly maintained in order to prevent its unwanted growth. This means running transaction log backups often enough.\nBy not doing that, you risk transaction log to become full and start to grow.Beside the answers mentioned in this thread I recommend reading and understanding the transaction log common myths. These readings may help understanding the transaction log and deciding what techniques to use to "clear" it:http://www.sqlshack.com/10-important-sql-server-transaction-log-myths/ Myth: My SQL Server is too busy, I don\xe2\x80\x99t want to make SQL Server transaction log backupsOne of the biggest performance intensive operations in SQL Server is an auto-grow event of the online transaction log file. By not making transaction log backups often enough, the online transaction log will become full and will have to grow. The default growth size is 10%. The busier the database is, the quicker the online transaction log will grow if transaction log backups are not created\n  Creating a SQL Server transaction log backup doesn\xe2\x80\x99t block the online transaction log, but an auto-growth event does. It can block all activity in the online transaction log http://blog.sqlxdetails.com/transaction-log-myths/Myth: Regular log shrinking is a good maintenance practiceFALSE. Log growth is very expensive because the new chunk must be zeroed-out. All write activity stops on that database until zeroing is finished, and if your disk write is slow or autogrowth size is big, that pause can be huge and users will notice. That\xe2\x80\x99s one reason why you want to avoid growth. If you shrink the log, it will grow again and you are just wasting disk operation on needless shrink-and-grow-again game <<First check the database Recovery model. By default SQL Server Epxress edition create database in Simple recovery\nmodel (if iam not mistaken).   Backup Log DatabaseName With Truncate_OnlyDBCC ShrinkFile(yourLogical_LogFileName, 50)SP_helpfile will give you the logical log file nameRefer :http://support.microsoft.com/kb/873235.If your database is in Full Recovery Model and if you are not taking TL backup , then change it to SIMPLE.Use the DBCC ShrinkFile ({logicalLogName}, TRUNCATEONLY) command.  If this is a Test database and you are trying to save/reclaim space this will help.  Remember though that TX logs do have a sort of minimum/steady state size that they will grow up to.   Depending upon your recovery model you may not be able to shrink the log - If in FULL and you aren\'t issuing TX log backups the log can\'t be shrunk - it will grow forever.   If you don\'t need tx log backups switch your recovery model to Simple.  And remember, never ever under any circumstances Delete the log (LDF) file!!!  You will pretty much have instant database corruption.  Cooked!  Done! Lost Data!  If left "unrepaired" the main MDF could become corrupt permanently.Never ever delete the transaction log - you will lose data!  Part of your data is in the TX Log (regardless of recovery model)... if you detach and "rename" the TX log file that effectively Deletes part of your database.   For those that have deleted the TX Log you may want to run a few checkdb commands and fix the corruption before you lose more data.Check out Paul Randal\'s blog on this very topic.  http://sqlskills.com/BLOGS/PAUL/category/Bad-Advice.aspx#p4Also in general do not use shrinkfile on the MDF\'s as it can severely fragment your data.  Check out his Bad Advice section for more info ("Why you should not shrink your data files")Check out Paul\'s website - he covers these very questions.  Last month he walked through many of these issues in his Myth A Day series.To Truncate the log file:To Shrink the log file:Shrink the database by either:Using Enterprise manager :-\nRight click on the database, All tasks, Shrink database, Files, Select log file, OK.Using T-SQL :-\nDbcc Shrinkfile ([Log_Logical_Name])You can find the logical name of the log file by running sp_helpdb or by looking in the properties of the database in Enterprise Manager.To my experience on most SQL Servers there is no backup of the transaction log.\nFull backups or differential backups are common practice, but transaction log backups are really seldom.\nSo the transaction log file grows forever (until the disk is full).\nIn this case the recovery model should be set to "simple".\nDon\'t forget to modify the system databases "model" and "tempdb", too.A backup of the database "tempdb" makes no sense, so the recovery model of this db should always be "simple".(system will create a new log file.) delete or move renamed log file.Try this:Database->right click Properties-->file--> add another log file with different name and set path same as old log file with different file name.\nDatabase automatically picks up newly created log file.This will work but it is suggested to take backup of your database first.Example:-DBCC SQLPERF(LOGSPACE) BACKUP LOG Comapny WITH TRUNCATE_ONLYDBCC SHRINKFILE (Company_log, 500) DBCC SQLPERF(LOGSPACE) DB Transaction Log Shrink to min size:I made tests on several number of DBs: this sequence works. It usually shrinks to 2MB.OR by a script: