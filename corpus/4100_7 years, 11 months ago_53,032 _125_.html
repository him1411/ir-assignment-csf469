Battleship!Back in 2003 (when I was 17), I competed in a Battleship AI coding competition.  Even though I lost that tournament, I had a lot of fun and learned a lot from it.Now, I would like to resurrect this competition, in the search of the best battleship AI.Here is the framework, now hosted on Bitbucket.The winner will be awarded +450 reputation! The competition will be held starting on the 17th of November, 2009.  No entries or edits later than zero-hour on the 17th will be accepted.  (Central Standard Time)\nSubmit your entries early, so you don\'t miss your opportunity!To keep this OBJECTIVE, please follow the spirit of the competition.Rules of the game:Rules of the competition:Scoring:Good luck! Have fun!EDIT 1:\nThanks to Freed, who has found an error in the Ship.IsValid function.  It has been fixed.  Please download the updated version of the framework.EDIT 2:\nSince there has been significant interest in persisting stats to disk and such, I have added a few non-timed set-up and tear-down events that should provide the required functionality.  This is a semi-breaking change.  That is to say: the interface has been modified to add functions, but no body is required for them.  Please download the updated version of the framework.EDIT 3:\nBug Fix 1: GameWon and GameLost were only getting called in the case of a time out.\nBug Fix 2: If an engine was timing out every game, the competition would never end.\nPlease download the updated version of the framework.EDIT 4:\nTournament Results:I second the motion to do a lot more games per match.  Doing 50 games is just flipping a coin.  I needed to do 1000 games to get any reasonable distinction between test algorithms.Download Dreadnought 1.2.Strategies:keep track of all possible positions for ships that have >0 hits.  The list never gets bigger than ~30K so it can be kept exactly, unlike the list of all possible positions for all ships (which is very large).The GetShot algorithm has two parts, one which generates random shots and the other which\ntries to finish sinking an already hit ship.  We do random shots if there is a possible position (from the list above) in which all hit ships are sunk.  Otherwise, we try to finish sinking a ship by picking a location to shoot at which eliminates the most possible positions (weighted).For random shots, compute best location to shoot based on the likelihood of one of the unsunk ships overlapping the location.adaptive algorithm which places ships in locations where the opponent is statistically less likely to shoot.adaptive algorithm which prefers to shoot at locations where the opponent is statistically more likely to place his ships.place ships mostly not touching each other.Here is my entry! (The most naive solution possible)"Random 1.1"Here\'s an opponent for people to play against:Instead of using a fixed geometry-inspired strategy, I thought it would be interesting to attempt to estimate the underlying probabilities that any particular unexplored space holds a ship.To do this right, you\'d explore all possible configurations of ships that fit your current view of the world, and then compute probabilities based on those configurations.  You could think of it like exploring a tree:an expansion of possible battleship states http://natekohl.net/media/battleship-tree.pngAfter considering all leaves of that tree that jive with what you know about the world (e.g. ships can\'t overlap, all hit squares must be ships, etc.) you can count how often ships occur at each unexplored position to estimate the likelihood that a ship is sitting there.  This can be visualized as a heat map, where hot spots are more likely to contain ships:a heat map of probabilities for each unexplored position http://natekohl.net/media/battleship-probs.pngOne thing I like about this Battleship competition is that the tree above is almost small enough to brute-force this kind of algorithm.  If there are ~150 possible positions for each of the 5 ships, that\'s 1505 = 75 billion possibilities.  And that number only gets smaller, especially if you can eliminate whole ships.The opponent that I linked to above doesn\'t explore the whole tree; 75 billion is still to big to get in under a second.  It does attempt to estimate these probabilities, though, with the help of a few heuristics. Not a fully fledged answer but there seems little point cluttering the real answers with code that is common.\nI thus present some extensions/general classes in the spirit of open source.\nIf you use these then please change the namespace or trying to compile everything into one dll isn\'t going to work.BoardView lets you easily work with an annotated board.Some extensions, some of this duplicates functionality in the main framework but should really be done by you.Something I end up using a lot.Randomization.\nSecure but testable, useful for testing. I don\'t have the time right now to write a full-fledged algorithm, but here\'s a thought: if your opponent placed ships randomly, wouldn\'t the placement probabilities be a simple distribution centered at (5.5,5.5)? For example, the placement possibilities for the battleship (5 units long) in the x dimension are here:The same calculations would be valid for y. The other ships would not have as steep of distributions, but your best guess is still the center. After that, the mathematical approach would be slowly radiating diagonals (perhaps with the length of the average ship, 17/5) out of the center. Ex:Obviously some randomness would need to be added to the idea, but I think that purely mathematically that\'s the way to go.Nothing that sophisticated but heres what I came up with. It beats the random opponent 99.9% of the time. Would be interested if anyone has any other little challenges like this, it was good fun.Slightly condensed to take up minimal space on here and still be readable. Some comments about the Competition Engine:NewGame parameters:If IBattleshipOpponent::NewGame is intended for pre-game setup and takes a boardsize, it should also take a list of ships and their respective sizes.  It makes no sense to allow for variable board-size without allowing for variable ship configurations.Ships are sealed:I don\'t see any reason why class Ship is sealed.  Among other basic things, I would like Ships to have a Name, so I can output messages like ("You sunk my {0}", ship.Name);.  I have other extensions in mind too, so I think Ship should be inheritable.Time Limits:While the time limit of 1 second makes sense for a tournament rule, it totally messes with debugging.  BattleshipCompetition should have an easy setting to ignore time-violations to aid with development/debugging.  I would also suggest investigating System.Diagnostics.Process::UserProcessorTime / Privileged ProcessorTime / TotalProcessorTime for a more accurate view of how much time is being used.Sunk Ships:The current API informs you when you\'ve sunk an oppenent\'s ship:but not which ship you sunk!  I consider it part of the human-Battleship rules that you are required to declare "You sunk my Battleship!" (or destroyer, or sub, etc).This is especially critical when an AI is trying to flush out ships that butt-up against each other.   I\'d like to request an API change to:If ship is non-null, it implies that the shot was a sinking-shot, and you know which ship you sunk, and how long it was.  If the shot was a non-sinking shot, then ship is null, and you have no further information.CrossFire updated.\nI know it can\'t compete with Farnsworth or Dreadnought but it is a lot faster than the latter and simple to play with in case anyone wants to try.\nThis relies on the current state of my libraries,included here to make it easy to use.}This is about the best that I could put together in my free time, which is about non-existent. There is some game and match tallying stats going on, as I set up the main function to loop and continuously run the BattleshipCompetition until I pressed a key.This logic is the closest that I had to beating Dreadnought, winning about 41% of the individual games. (It actually did win one match by a count of 52 to 49.) Oddly enough, this class does not do as well against FarnsworthOpponent as an earlier version that was much less advanced.My computer is being repaired by dell right now, but this is where i was at last week:If you are brute forcing your analysis then you may find the mechanics of the supplied RandomOpponent highly inefficient. It allows itself to reselect already targeted locations and lets the framework force it to repeat till it hits one it hasn\'t touched yet or the timelimit per move expires.This opponent has similar behaviour (the effective placement distribution is the same) it just does the sanity checking itself and only consumes one random number generation per call (amortized)).This uses the classes in my extensions/library answer and I only supply the key methods/state.Shuffle is lifted from Jon Skeet\'s answer hereI\'m not going to be able to participate, but here\'s the algorithm I\'d implement if I had time:First, when I detect a hit I do not pursue the rest of the ship immediately - I build a table of ship locations and figure out whether I\'ve hit all five at least once before starting to fully sink them. (Note that this is a bad policy for the multiple shot variant - see comments)Continue in that pattern (should end up with diagonal lines separated by 3 spaces filling the board)  This should hit all 4 and 5 length boats, and a statistically large number of 3 and 2 boats.Start randomly hitting spots inbetween the diagonals, this will catch the 2 and 3 length boats that haven\'t already been noticed.Once I have detected 5 hits, I\'d determine if the 5 hits are on separate boats.  This is relatively easy by making a few more shots near locations where two hits are on the same horizontal or vertical line and are within 5 locations of each other (might be two hits on the same boat).  If they are separate boats then continue to sink all the ships.  If they are found to be the same boat, continue the filling patterns above until all 5 boats are located.This algorithm is a simple filling algorithm.  The key features are that it does not waste time sinking ships it knows about when there are still ships it\'s unaware of, and it doesn\'t use an inefficient filling pattern (ie, a fully random pattern would be wasteful).Final notes:A) "Center" is a random starting point on the board.  This eliminates the primary weakness of this algorithm.\nB) While the description indicates drawing diagonals immediately from the start, ideally the algorithm merely shoots at \'random\' locations that are along those diagonals.  This helps prevent the competitor from timing how long until their ships are hit by predictable patterns.This describes a \'perfect\' algorithm in that it\'ll get all the ships in under (9x9)/2+10 shots.However, it can be improved significantly:Once a ship is hit, identify its size before doing the \'internal\' diagonal lines.  You may have found the 2 ship, in which case the internal diagonals can be simplified to find the 3 size ships more quickly.Identify stages in the game and act accordingly.  This algorithm may be good up to a certain point in the game, but other algorithms may yield better benefits as part of the endgame.  Also, if the other player is very close to defeating you, another algorithm might work better - for instance a high risk algorithm might fail more often, but when it works it works quickly and you may beat your opponent who is closer to winning than you.Identify the play style of the competitor - it may give you clues as to how they plan ship placement (ie, chances are good that their own algorithm most quickly identifies how they place their own ships - if the only tool you have is a hammer, everything looks like a nail)-AdamMy entry.Nothing terribly special, and I didn\'t get time to add all the good ideas I had.But it seems to play fairly well.  We\'ll see how it does in competition:(put this in file Missouri.cs and added to project.)This is not minimax. Actually after placing the ships, can\'t each player play on its own, resulting in a number of turns it took him to sink every opponent ship? The one that took less turns wins. I don\'t think that there are any good general strategies beyond sinking hit ships and trying to minimize the number of shots to cover the remaining possible places where ships might hide.Of course there might be counter-strategies for anything that\'s not random. But I don\'t think that there are strategies that are good against all possible players.Actually, I think the biggest problem with the puzzle is that its essentially two moves.  One move is placing your ships, the other is finding the enemy ships (however segmented that second part might be, aside from trying to beat a clock with a random factor, its just \'run your algorithm\').  There\'s no mechanism to try to determine and then counter an enemy strategy, which is what makes similar competitions based around successive rounds of "rock paper scissors" pretty interesting.  Also, I think it would be cooler if you specified the game as a network protocol and then provided the framework to implement that protocol in C#, rather than dictate that all solutions should be C#, but that\'s just my opinion.EDIT: I rescind my initial point, since I didn\'t read the competition rules carefully enough.  I always liked starting in the middle and spiraling away from that one point leaving no more than 1 blank space between any other points to account for that goddam sub... the space between shots was dependent on which ships were sunk.  if the B-ship was last, the shots only had to leave 4 spaces in between to minimize wasted shotsThere was a similar competition run by Dr James Heather of The University of Surrey on behalf of the British Computer Society.Limitations were placed on resources - namely maximum processor time per turn, no state could be stored between moves, maximum heap size imposed. To limit time the AI could submit a move at any point within the time slot and would be asked for a move upon termination of the turn.Very interesting - see more at: http://www.bcsstudentcontest.com/Might give you some more ideas.As it is, the solution opens and runs with no modification in monodevelop in ubuntu 9.10 linuxYou wrote:please define "against the spirit of the competition" and "interfering with an opponent"?Also - to simplify, I recommend that you:PS - a question for the CS post-docs lurking here: isn\'t this game solvable (i.e. is there a single, best strategy?). yes, the board size and number of steps makes minimax et al mandatory, but still I have to wonder... it\'s far from Go and chess in complexity.I predict that the person who manages to reverse engineer their opponents random seed and call pattern will win.Not sure how likely that is though.It would also, presumably, be possible to run a series of these with variations on the game.Adding in things like a 3d plane or being able to move a single ship instead of shoot for a turn would probably change the game a fair bit.The one second total game time is machine specific.  Once second worth of CPU operations will be different on my machine compared to the tournament machine.  If I optimize the Battle Ship algorithm to utilize the most CPU time within 1 second, then it is run on a possible slower tournament machine, it will always lose.  I am not sure how to get around this limitation of the framework, but it should be addressed.... One idea is to do what was done in this competition http://www.bcsstudentcontest.com/And have a maximum time per turn as opposed to maximum total game time.  This way I could limit the algorithms to fit within a know turn time.  A game might last 50 to 600+ turns, if the my algorithm manages its total game time, it might not give the enough time to do its best job or it could give too much time and lose.  It is very hard to manage the total game time within the Battleship algorithm.  I would suggest changing the rules to limit the turn time not the total game time.EditIf I wrote an algorithm that enumerates all possible shots and then ranks them, then takes the highest ranking shot.  It would take too long to generate all possible shots, so I would let the algorithm run for a certain amount of time then stop it.  If there was a turn based limit, I could let the algorithm run for 0.9 seconds and return the highest ranking shot, and be well withing the turn time limit.  If I am limited to total game time of one second, it will be difficult to determine how long the algorithm should run for each turn.  I will want to maximum my CPU time.  If a game lasted 500 round I could limit each turn to 0.002 seconds, but if a game lasted 100 rounds I could give each turn 0.01 seconds of CPU time.  It would be impractical for a algorithm to use an semi-exhaustive search of the shot space to find the best shot with the current limitation.  The 1 second total game time is limiting the type of algorithms that can be effectively used to compete in the game.  I\'m copping out here by not putting actual code in - but I will hazard some general observations:![Probability Density][1]enter image description her![enter image description here][2]I experimented with comparing the results of randon shooting vs a dumb hunt/target and finally a sophisticated search.The best solution appears to be to create a probability density function for the how likely any individual square is used by the remaining ships, and aim with the square with the highest value.You can see my results here enter link description here"Battleship" is what\'s known as a classic computer science NP-complete problem.http://en.wikipedia.org/wiki/List_of_NP-complete_problems (look for Battleship - it\'s there, under games and puzzles)