I need to retrieve all rows from a table where 2 columns combined are all different. So I want all the sales that do not have any other sales that happened on the same day for the same price. The sales that are unique based on day and price will get updated to an active status.So I\'m thinking:But my brain hurts going any farther than that.is roughly equivalent to:  It\'s a good idea to get used to the GROUP BY syntax, as it\'s more powerful.  For your query, I\'d do it like this:If you put together the answers so far, clean up and improve, you would arrive at this superior query:Which is much faster than either of them. Nukes the performance of the currently accepted answer by factor 10 - 15 (in my tests on PostgreSQL 8.4 and 9.1).But this is still far from optimal. Use a NOT EXISTS (anti-)semi-join for even better performance. EXISTS is standard SQL, has been around forever (at least since PostgreSQL 7.2, long before this question was asked) and fits the presented requirements perfectly:SQL Fiddle.If you don\'t have a primary or unique key for the table (id in the example), you can substitute with the system column ctid for the purpose of this query:Every table should have a primary key. Add one if you didn\'t have one, yet. I suggest a serial.The subquery in the EXISTS (anti-)semi-join can stop evaluating as soon as the first dupe is found (no point in looking further). For a base table with few duplicates this is only mildly more efficient. With lots of duplicates this becomes way more efficient.If some or many rows already have status = \'ACTIVE\', your update would not change anything, but still insert a new row version at full cost (minor exceptions apply). Normally, you do not want this. Add another WHERE condition like demonstrated above to make this even faster:If status is defined NOT NULL, you can simplify to:The problem with your query is that when using a GROUP BY clause (which you essentially do by using distinct) you can only use columns that you group by or aggregate functions. You cannot use the column id because there are potentially different values. In your case there is always only one value because of the HAVING clause, but most RDBMS are not smart enough to recognize that.This should work however (and doesn\'t need a join):You could also use MAX or AVG instead of MIN, it is only important to use a function that returns the value of the column if there is only one matching row.