What\'s the difference between constexpr and const?Both keywords can be used in the declaration of objects as well as functions. The basic difference when applied to objects is this:const declares an object as constant. This implies a guarantee that, once initialized, the value of that object won\'t change, and the compiler can make use of this fact for optimizations. It also helps prevent the programmer from writing code that modifies objects that were not meant to be modified after initialization.constexpr declares an object as fit for use in what the Standard calls constant expressions. But note that constexpr is not the only way to do this.When applied to functions the basic difference is this:const can only be used for non-static member functions, not functions in general. It gives a guarantee that the member function does not modify any of the non-static data members.constexpr can be used with both member and non-member functions, as well as constructors. It declares the function fit for use in constant expressions. The compiler will only accept it if the function meets certain criteria (7.1.5/3,4), most importantly (†):As said above, constexpr declares both objects as well as functions as fit for use in constant expressions. A constant expression is more than merely constant:It can be used in places that require compile-time evaluation, for example, template parameters and array-size specifiers:But note:Declaring something as constexpr does not necessarily guarantee that it will be evaluated at compile time. It can be used for such, but it can be used in other places that are evaluated at run-time, as well.An object may be fit for use in constant expressions without being declared constexpr. Example:This is possible because N, being constant and initialized at declaration time with a literal, satisfies the criteria for a constant expression, even if it isn\'t declared constexpr.So when do I actually have to use constexpr?An object like N above can be used as constant expression without being declared constexpr. This is true for all objects that are:[This is due to \xc2\xa75.19/2: A constant expression must not include a subexpressions that involves "an lvalue-to-rvalue modification unless [\xe2\x80\xa6] a glvalue of integral or enumeration type [\xe2\x80\xa6]" Thanks to Richard Smith for correcting my earlier claim that this was true for all literal types.]For a function to be fit for use in constant expressions, it must be explicitly declared constexpr; it is not sufficient for it merely to satisfy the criteria for constant-expression functions. Example:When can I / should I use both, const and constexpr together?A. In object declarations. This is never necessary when both keywords refer to the same object to be declared. constexpr implies const.is the same asHowever, note that there may be situations when the keywords each refer to different parts of the declaration:Here, NP is declared as an address constant-expression, i.e. an pointer that is itself a constant expression. (This is possible when the address is generated by applying the address operator to a static/global constant expression.) Here, both constexpr and const are required: constexpr always refers to the expression being declared (here NP), while const refers to int (it declares a pointer-to-const). Removing the const would render the expression illegal (because (a) a pointer to a non-const object cannot be a constant expression, and (b) &N is in-fact a pointer-to-constant).B. In member function declarations. In C++11, constexpr implies const also for member functions. However, this is likely to change in C++14. According to the current drafts, constexpr will imply const only for objects, not for member functions, due to a proposed change to \xc2\xa77.1.5/8. Hence, a member function declared under C++11 aswill have to be declared asunder C++14 in order to still be usable as a const function. Best mark your constexpr member functions as const even now so as to avoid having to change a lot of code later on.(†) The conditions for acceptable constexpr functions will probably be relaxed for C++14. A proposal by Richard Smith has recently been adopted into the C++14 draft.const applies for variables, and prevents them from being modified in your code. constexpr tells the compiler that this expression results in a compile time constant value, so it can be used in places like array lengths, assigning to const variables, etc. The link given by Oli has a lot of excellent examples. Basically they are 2 different concepts altogether, and can (and should) be used together.const guarantees that a program does not change an object\xe2\x80\x99s value. However, const does not guarantee which type of initialization the object undergoes. Consider:The function max() merely returns a literal value. However, because the initializer is a function call, mx undergoes runtime initialization. Therefore, you cannot use it as a constant expression:constexpr is a new C++11 keyword that rids you of the need to create macros and hardcoded literals. It also guarantees, under certain conditions, that objects undergo static initialization. It controls the evaluation time of an expression. By enforcing compile-time evaluation of its expression, constexpr lets you define true constant expressions that are crucial for time-critical applications, system programming, templates, and generally speaking, in any code that relies on compile-time constants.A constant-expression function is a function declared constexpr. Its body must be non-virtual and consist of a single return statement only, apart from typedefs and static asserts. Its arguments and return value must have literal types. It can be used with non-constant-expression arguments, but when that is done the result is not a constant expression.A constant-expression function is meant to replace macros and hardcoded literals without sacrificing performance or type safety.A constant-expression object is an object declared constexpr. It must be initialized with a constant expression or an rvalue constructed by a constant-expression constructor with constant-expression arguments.A constant-expression object behaves as if it was declared const, except that it requires initialization before use and its initializer must be a constant expression. Consequently, a constant-expression object can always be used as part of another constant expression.A constant-expression constructor is a constructor declared constexpr. It can have a member initialization list but its body must be empty, apart from typedefs and static asserts. Its arguments must have literal types.A constant-expression constructor allows the compiler to initialize the object at compile-time, provided that the constructor\xe2\x80\x99s arguments are all constant expressions.Tips from the book Effective Modern C++ by Scott Meyers about constexpr:Source:\nUsing constexpr to Improve Security, Performance and Encapsulation in C++.According to book of "The C++ Programming Language 4th Editon" by Bjarne Stroustrup\n\xe2\x80\xa2 const: meaning roughly \xe2\x80\x98\xe2\x80\x98I promise not to change this value\xe2\x80\x99\xe2\x80\x99 (\xc2\xa77.5). This is used primarily\nto specify interfaces, so that data can be passed to functions without fear of it being modified.\nThe compiler enforces the promise made by const.\n\xe2\x80\xa2 constexpr: meaning roughly \xe2\x80\x98\xe2\x80\x98to be evaluated at compile time\xe2\x80\x99\xe2\x80\x99 (\xc2\xa710.4). This is used primarily to specify constants, to allow \nFor example:For a function to be usable in a constant expression, that is, in an expression that will be evaluated\nby the compiler, it must be defined constexpr. For example:\nTo be constexpr, a function must be rather simple: just a return-statement computing a value. A\nconstexpr function can be used for non-constant arguments, but when that is done the result is not a\nconstant expression. We allow a constexpr function to be called with non-constant-expression arguments\nin contexts that do not require constant expressions, so that we don\xe2\x80\x99t hav e to define essentially\nthe same function twice: once for constant expressions and once for variables.\nIn a few places, constant expressions are required by language rules (e.g., array bounds (\xc2\xa72.2.5,\n\xc2\xa77.3), case labels (\xc2\xa72.2.4, \xc2\xa79.4.2), some template arguments (\xc2\xa725.2), and constants declared using\nconstexpr). In other cases, compile-time evaluation is important for performance. Independently of\nperformance issues, the notion of immutability (of an object with an unchangeable state) is an\nimportant design concern (\xc2\xa710.4).As @0x499602d2 already pointed out, const only ensures that a value cannot be changed after initialization where as constexpr (introduced in C++11) guarantees the variable is a compile time constant.\nConsider the following example(from LearnCpp.com):