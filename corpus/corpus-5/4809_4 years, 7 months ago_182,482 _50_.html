There is an array of objects in my scope, I want to watch all the values of each object.This is my code:But when I modify the values, e.g. I change TITLE to TITLE2, the alert(\'columns changed\') never popped.How to deep watch the objects inside an array?There is a live demo: http://jsfiddle.net/SYx9b/You can set the 3rd argument of $watch to true:See http://docs.angularjs.org/api/ng.$rootScope.Scope#$watchSince Angular 1.1.x you can also use $watchCollection to watch shallow watch (just the "first level" of) the collection.See https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watchCollectionThere are performance consequences to deep-diving an object in your $watch.  Sometimes (for example, when changes are only pushes and pops), you might want to $watch an easily calculated value, such as array.length.If you\'re going to watch only one array, you can simply use this bit of code:exampleBut this will not work with multiple arrays:exampleTo handle this situation, I usually convert the multiple arrays I want to watch into JSON:exampleAs @jssebastian pointed out in the comments, JSON.stringify may be preferable to angular.toJson as it can handle members that start with \'$\' and possible other cases as well.It\'s worth noting that in Angular 1.1.x and above, you can now use $watchCollection rather than $watch. Although the $watchCollection appears to create shallow watches so it won\'t work with arrays of objects like you expect. It can detect additions and deletions to the array, but not the properties of objects inside arrays.$watchCollection accomplishes what you want to do. Below is an example copied from angularjs website http://docs.angularjs.org/api/ng/type/$rootScope.Scope\nWhile it\'s convenient, the performance needs to be taken into consideration especially when you watch a large collection.Here is a comparison of the 3 ways you can watch a scope variable with examples:$watch() is triggered by:$watchCollection() is triggered by everything above AND:$watch(..., true) is triggered by EVERYTHING above AND:JUST ONE MORE THING...$watch() is the only one that triggers when an array is replaced with another array even if that other array has the same exact content. For example where $watch() would fire and $watchCollection() would not:Below is a link to an example JSFiddle that uses all the different watch combinations and outputs log messages to indicate which "watches" were triggered: http://jsfiddle.net/luisperezphd/2zj9k872/This solution worked very well for me, i\'m doing this in a directive:scope.$watch(attrs.testWatch, function() {.....}, true);the true works pretty well and react for all the chnages (add, delete, or modify a field).Here is a working plunker for play with it.Deeply Watching an Array in AngularJSI hope this can be useful for you.\nIf you have any questions, feel free for ask, I\'ll try to help :)In my case, I needed to watch a service, which contains an address object also watched by several other controllers. I was stuck in a loop until I added the \'true\' parameter, which seems to be the key to success when watching objects.Setting the objectEquality parameter (third parameter) of the $watch function is definitely the correct way to watch ALL properties of the array.Piran answers this well enough and mentions $watchCollection as well.More DetailThe reason I\'m answering an already answered question is because I want to point out that wizardwerdna\'s answer is not a good one and should not be used.The problem is that the digests do not happen immediately.  They have to wait until the current block of code has completed before executing.  Thus, watch the length of an array may actually miss some important changes that $watchCollection will catch.Assume this configuration:At first glance, it may seem like these would fire at the same time, such as in this case:That works well enough, but consider this:Notice that the resulting length was the same even though the array has a new element and lost an element, so as watch as the $watch is concerned, length hasn\'t changed.  $watchCollection picked up on it, though.The same result happens with a push and pop in the same block.ConclusionTo watch every property in the array, use a $watch on the array iteself with the third parameter (objectEquality) included and set to true.  Yes, this is expensive but sometimes necessary.To watch when object enter/exit the array, use a $watchCollection.Do NOT use a $watch on the length property of the array.  There is almost no good reason I can think of to do so.