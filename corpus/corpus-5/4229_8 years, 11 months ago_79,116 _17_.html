The Mutex class is very misunderstood, and Global mutexes even more so.What is good, safe pattern to use when creating Global mutexes?One that will workI want to make sure this is out there, because it\'s so hard to get right:Using the accepted answer I create a helper class so you could use it in a similar way you would use the Lock statement. Just thought I\'d share. Use: And the helper class:Neither Mutex nor WinApi CreateMutex() works for me.An alternate solution:And the SingleApplicationDetector:Reason to use Semaphore instead of Mutex:The Mutex class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the Semaphore class does not enforce thread identity.<< System.Threading.MutexRef: Semaphore.OpenExisting()There is a race condition in the accepted answer when 2 processes running under 2 different users trying to initialize the mutex at the same time.\nAfter the first process initializes the mutex, if the second process tries to initialize the mutex before the first process sets the access rule to everyone, an unauthorized exception will be thrown by the second process.See below for corrected answer:This example will exit after 5 seconds if another instance is already running.