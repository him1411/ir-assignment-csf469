I noticed that there are different bean scopes like:What is the purpose of each? How do I choose a proper scope for my bean?It represents the scope (the lifetime) of the bean. This is easier to understand if you are familiar with "under the covers" working of a basic servlet web application: How do servlets work? Instantiation, sessions, shared variables and multithreading.A @RequestScoped bean lives as long as a single HTTP request-response cycle (note that an Ajax request counts as a single HTTP request too). A @ViewScoped bean lives as long as you\'re interacting with the same JSF view by postbacks which call action methods returning null/void without any navigation/redirect. A @FlowScoped bean lives as long as you\'re navigating through the specified collection of views registered in the flow configuration file. A @SessionScoped bean lives as long as the established HTTP session. An @ApplicationScoped bean lives as long as the web application runs. Note that the CDI @Model is basically a stereotype for @Named @RequestScoped, so same rules apply.Which scope to choose depends solely on the data (the state) the bean holds and represents. Use @RequestScoped for simple and non-ajax forms/presentations. Use @ViewScoped for rich ajax-enabled dynamic views (ajaxbased validation, rendering, dialogs, etc). Use @FlowScoped for the "wizard" ("questionnaire") pattern of collecting input data spread over multiple pages. Use @SessionScoped for client specific data, such as the logged-in user and user preferences (language, etc). Use @ApplicationScoped for application wide data/constants, such as dropdown lists which are the same for everyone, or managed beans without any instance variables and having only methods.Abusing an @ApplicationScoped bean for session/view/request scoped data would make it to be shared among all users, so anyone else can see each other\'s data which is just plain wrong. Abusing a @SessionScoped bean for view/request scoped data would make it to be shared among all tabs/windows in a single browser session, so the enduser may experience inconsitenties when interacting with every view after switching between tabs which is bad for user experience. Abusing a @RequestScoped bean for view scoped data would make view scoped data to be reinitialized to default on every single (ajax) postback, causing possibly non-working forms (see also points 4 and 5 here). Abusing a @ViewScoped bean for request, session or application scoped data, and abusing a @SessionScoped bean for application scoped data doesn\'t affect the client, but it unnecessarily occupies server memory and is plain inefficient.Note that the scope should rather not be chosen based on performance implications, unless you really have a low memory footprint and want to go completely stateless; you\'d need to use exclusively @RequestScoped beans and fiddle with request parameters to maintain the client\'s state. Also note that when you have a single JSF page with differently scoped data, then it\'s perfectly valid to put them in separate backing beans in a scope matching the data\'s scope. The beans can just access each other via @ManagedProperty in case of JSF managed beans or @Inject in case of CDI managed beans.It\'s not mentioned in your question, but (legacy) JSF also supports @CustomScoped and @NoneScoped, which are rarely used in real world. The @CustomScoped must refer a custom Map<K, Bean> implementation in some broader scope which has overridden Map#put() and/or Map#get() in order to have more fine grained control over bean creation and/or destroy. The JSF @NoneScoped and CDI @Dependent basically lives as long as a single EL-evaluation on the bean. Imagine a login form with two input fields referring a bean property and a command button referring a bean action, thus with in total three EL expressions, then effectively three instances will be created. One with the username set, one with the password set and one on which the action is invoked. You normally want to use this scope only on beans which should live as long as the bean where it\'s being injected. So if a @NoneScoped or @Dependent is injected in a @SessionScoped, then it will live as long as the @SessionScoped bean.As last, JSF also supports the flash scope. It is backed by a short living cookie which is associated with a data entry in the session scope. Before the redirect, a cookie will be set on the HTTP response with a value which is uniquely associated with the data entry in the session scope. After the redirect, the presence of the flash scope cookie will be checked and the data entry associated with the cookie will be removed from the session scope and be put in the request scope of the redirected request. Finally the cookie will be removed from the HTTP response. This way the redirected request has access to request scoped data which was been prepared in the initial request.This is actually not available as a managed bean scope, i.e. there\'s no such thing as @FlashScoped. The flash scope is only available as a map via ExternalContext#getFlash() in managed beans and #{flash} in EL.As of JSF 2.x there are 4 Bean Scopes:    Session Scope:    The session scope persists from the time that a session is established until session termination. A session terminates\n  if the web application invokes the invalidate method on the\n  HttpSession object, or if it times out.RequestScope:   The request scope is short-lived. It starts when an HTTP request is submitted and ends after the response is sent back\n  to the client. If you place a managed bean into request scope, a new\n  instance is created with each request. It is worth considering request\n  scope if you are concerned about the cost of session scope storage.ApplicationScope:    The application scope persists for the entire duration of the web application. That scope is shared among all\n  requests and all sessions. You place managed beans into the\n  application scope if a single bean should be shared among all\n  instances of a web application. The bean is constructed when it is\n  first requested by any user of the application, and it stays alive\n  until the web application is removed from the application server.ViewScope:      View scope was added in JSF 2.0. A bean in view scope persists while the same JSF page is redisplayed. (The JSF\n  specification uses the term view for a JSF page.) As soon as the user\n  navigates to a different page, the bean goes out of scope.Choose the scope you based on your requirement.Source: Core Java Server Faces 3rd Edition by David Geary & Cay Horstmann [Page no. 51 - 54]\n