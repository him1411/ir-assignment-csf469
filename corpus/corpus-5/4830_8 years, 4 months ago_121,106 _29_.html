I have a Bash shell script that invokes a number of commands.\nI would like to have the shell script automatically exit with a return value of 1 if any of the commands return a non-zero value.Is this possible without explicitly checking the result of each command?e.g. Add this to the beginning of the script:This will cause the shell to exit immediately if a simple command exits with a nonzero exit value.  A simple command is any command not part of an if, while, or until test, or part of an && or || list.See the bash(1) man page on the "set" internal command for more details.I personally start almost all shell scripts with "set -e".  It\'s really annoying to have a script stubbornly continue when something fails in the middle and breaks assumptions for the rest of the script.To add to the accepted answer: Bear in mind that set -e sometimes is not enough, specially if you have pipes. For example, suppose you have this script... which works as expected: an error in configure aborts the execution.Tomorrow you make a seemingly trivial change:... and now it does not work. This is explained here, and a workaround (Bash only) is provided:The if statements in your example are unnecessary.  Just do it like this:If you take Ville Laurikari\'s advice and use set -e then for some commands you may need to use this:The || true will make the command pipeline have a true return value even if the command fails so the the -e option will not kill the script.If you have cleanup you need to do on exit, you can also use \'trap\' with the pseudo-signal ERR. This works the same way as trapping INT or any other signal; bash throws ERR if any command exits with a nonzero value:Or, especially if you\'re using "set -e", you could trap EXIT; your trap will then be executed when the script exits for any reason, including a normal end, interrupts, an exit caused by the -e option, etc.Run it with -e or set -e at the top.Also look at set -u.The $? variable is rarely needed.  The pseudo-idiom command; if [ $? -eq 0 ]; then X; fi should always be written as if command; then X; fi.The cases where $? is required is when it needs to be checked against multiple values:or when $? needs to be reused or otherwise manipulated:An expression likewill stop processing when one of the commands returns with a non-zero value. For example, the following command will never print "done":should suffice.just throwing in another one for reference since there was an additional question to Mark Edgars input and here is an additional example and touches on the topic overall:which is the same as cmd || exit errcode as someone showed.eg. I want to make sure a partition is unmounted if mounted: