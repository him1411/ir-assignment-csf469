I have heard the term "coalgebras" several times in functional programming and PLT circles, especially when the discussion is about objects, comonads, lenses, and such. Googling this term gives pages that give mathematical description of these structures which is pretty much incomprehensible to me. Can anyone please explain what coalgebras mean in the context of programming, what is their significance, and how they relate to objects and comonads?I think the place to start would be to understand the idea of an algebra. This is just a generalization of algebraic structures like groups, rings, monoids and so on. Most of the time, these things are introduced in terms of sets, but since we\'re among friends, I\'ll talk about Haskell types instead. (I can\'t resist using some Greek letters though\xe2\x80\x94they make everything look cooler!)An algebra, then, is just a type \xcf\x84 with some functions and identities. These functions take differing numbers of arguments of type \xcf\x84 and produce a \xcf\x84: uncurried, they all look like (\xcf\x84, \xcf\x84,\xe2\x80\xa6, \xcf\x84) \xe2\x86\x92 \xcf\x84. They can also have "identities"\xe2\x80\x94elements of \xcf\x84 that have special behavior with some of the functions.The simplest example of this is the monoid. A monoid is any type \xcf\x84 with a function mappend \xe2\x88\xb7 (\xcf\x84, \xcf\x84) \xe2\x86\x92 \xcf\x84 and an identity mzero \xe2\x88\xb7 \xcf\x84. Other examples include things like groups (which are just like monoids except with an extra invert \xe2\x88\xb7 \xcf\x84 \xe2\x86\x92 \xcf\x84 function), rings, lattices and so on.All the functions operate on \xcf\x84 but can have different arities. We can write these out as \xcf\x84\xe2\x81\xbf \xe2\x86\x92 \xcf\x84, where \xcf\x84\xe2\x81\xbf maps to a tuple of n \xcf\x84. This way, it makes sense to think of identities as \xcf\x84\xe2\x81\xb0 \xe2\x86\x92 \xcf\x84 where \xcf\x84\xe2\x81\xb0 is just the empty tuple (). So we can actually simplify the idea of an algebra now: it\'s just some type with some number of functions on it.An algebra is just a common pattern in mathematics that\'s been "factored out", just like we do with code. People noticed that a whole bunch of interesting things\xe2\x80\x94the aforementioned monoids, groups, lattices and so on\xe2\x80\x94all follow a similar pattern, so they abstracted it out. The advantage of doing this is the same as in programming: it creates reusable proofs and makes certain kinds of reasoning easier.However, we\'re not quite done with factoring. So far, we have a bunch of functions \xcf\x84\xe2\x81\xbf \xe2\x86\x92 \xcf\x84. We can actually do a neat trick to combine them all into one function. In particular, let\'s look at monoids: we have mappend \xe2\x88\xb7 (\xcf\x84, \xcf\x84) \xe2\x86\x92 \xcf\x84 and mempty \xe2\x88\xb7 () \xe2\x86\x92 \xcf\x84. We can turn these into a single function using a sum type\xe2\x80\x94Either. It would look like this:We can actually use this transformation repeatedly to combine all the \xcf\x84\xe2\x81\xbf \xe2\x86\x92 \xcf\x84 functions into a single one, for any algebra. (In fact, we can do this for any number of functions a \xe2\x86\x92 \xcf\x84, b \xe2\x86\x92 \xcf\x84 and so on for any a, b,\xe2\x80\xa6.)This lets us talk about algebras as a type \xcf\x84 with a single function from some mess of Eithers to a single \xcf\x84. For monoids, this mess is: Either (\xcf\x84, \xcf\x84) (); for groups (which have an extra \xcf\x84 \xe2\x86\x92 \xcf\x84 operation), it\'s: Either (Either (\xcf\x84, \xcf\x84) \xcf\x84) (). It\'s a different type for every different structure. So what do all these types have in common? The most obvious thing is that they are all just sums of products\xe2\x80\x94algebraic data types. For example, for monoids, we could create a monoid argument type that works for any monoid \xcf\x84:We can do the same thing for groups and rings and lattices and all the other possible structures.What else is special about all these types? Well, they\'re all Functors! E.g.: So we can generalize our idea of an algebra even more. It\'s just some type \xcf\x84 with a function f \xcf\x84 \xe2\x86\x92 \xcf\x84 for some functor f. In fact, we could write this out as a typeclass:This is often called an "F-algebra" because it\'s determined by the functor F. If we could partially apply typeclasses, we could define something like class Monoid = Algebra MonoidArgument. Now, hopefully you have a good grasp of what an algebra is and how it\'s just a generalization of normal algebraic structures. So what is an F-coalgebra? Well, the co implies that it\'s the "dual" of an algebra\xe2\x80\x94that is, we take an algebra and flip some arrows. I only see one arrow in the above definition, so I\'ll just flip that:And that\'s all it is! Now, this conclusion may seem a little flippant (heh). It tells you what a coalgebra is, but does not really give any insight on how it\'s useful or why we care. I\'ll get to that in a bit, once I find or come up with a good example or two :P.After reading around a bit, I think I have a good idea of how to use coalgebras to represent classes and objects. We have a type C that contains all the possible internal states of objects in the class; the class itself is a coalgebra over C which specifies the methods and properties of the objects.As shown in the algebra example, if we have a bunch of functions like a \xe2\x86\x92 \xcf\x84 and b \xe2\x86\x92 \xcf\x84 for any a, b,\xe2\x80\xa6, we can combine them all into a single function using Either, a sum type. The dual "notion" would be combining a bunch of functions of type \xcf\x84 \xe2\x86\x92 a, \xcf\x84 \xe2\x86\x92 b and so on. We can do this using the dual of a sum type\xe2\x80\x94a product type. So given the two functions above (called f and g), we can create a single one like so:The type (a, a) is a functor in the straightforward way, so it certainly fits with our notion of an F-coalgebra. This particular trick lets us package up a bunch of different functions\xe2\x80\x94or, for OOP, methods\xe2\x80\x94into a single function of type \xcf\x84 \xe2\x86\x92 f \xcf\x84.The elements of our type C represent the internal state of the object. If the object has some readable properties, they have to be able to depend on the state. The most obvious way to do this is to make them a function of C. So if we want a length property (e.g. object.length), we would have a function C \xe2\x86\x92 Int. We want methods that can take an argument and modify state. To do this, we need to take all the arguments and produce a new C. Let\'s imagine a setPosition method which takes an x and a y coordinate: object.setPosition(1, 2). It would look like this: C \xe2\x86\x92 ((Int, Int) \xe2\x86\x92 C).The important pattern here is that the "methods" and "properties" of the object take the object itself as their first argument. This is just like the self parameter in Python and like the implicit this of many other languages. A coalgebra essentially just encapsulates the behavior of taking a self parameter: that\'s what the first C in C \xe2\x86\x92 F C is.So let\'s put it all together. Let\'s imagine a class with a position property, a name property and setPosition function:We need two parts to represent this class. First, we need to represent the internal state of the object; in this case it just holds two Ints and a String. (This is our type C.) Then we need to come up with the coalgebra representing the class.We have two properties to write. They\'re pretty trivial:Now we just need to be able to update the position:This is just like a Python class with its explicit self variables. Now that we have a bunch of self \xe2\x86\x92 functions, we need to combine them into a single function for the coalgebra. We can do this with a simple tuple:The type ((Int, Int), String, (Int, Int) \xe2\x86\x92 c)\xe2\x80\x94for any c\xe2\x80\x94is a functor, so coop does have the form we want: Functor f \xe2\x87\x92 C \xe2\x86\x92 f C.Given this, C along with coop form a coalgebra which specifies the class I gave above. You can see how we can use this same technique to specify any number of methods and properties for our objects to have.This lets us use coalgebraic reasoning to deal with classes. For example, we can bring in the notion of an "F-coalgebra homomorphism" to represent transformations between classes. This is a scary sounding term that just means a transformation between coalgebras that preserves structure. This makes it much easier to think about mapping classes onto other classes.In short, an F-coalgebra represents a class by having a bunch of properties and methods that all depend on a self parameter containing each object\'s internal state.So far, we\'ve talked about algebras and coalgebras as Haskell types. An algebra is just a type \xcf\x84 with a function f \xcf\x84 \xe2\x86\x92 \xcf\x84 and a coalgebra is just a type \xcf\x84 with a function \xcf\x84 \xe2\x86\x92 f \xcf\x84. However, nothing really ties these ideas to Haskell per se. In fact, they\'re usually introduced in terms of sets and mathematical functions rather than types and Haskell functions. Indeed,we can generalize these concepts to any categories!We can define an F-algebra for some category C. First, we need a functor F : C \xe2\x86\x92 C\xe2\x80\x94that is, an endofunctor. (All Haskell Functors are actually endofunctors from Hask \xe2\x86\x92 Hask.) Then, an algebra is just an object A from C with a morphism F A \xe2\x86\x92 A. A coalgebra is the same except with A \xe2\x86\x92 F A.What do we gain by considering other categories? Well, we can use the same ideas in different contexts. Like monads. In Haskell, a monad is some type M \xe2\x88\xb7 \xe2\x98\x85 \xe2\x86\x92 \xe2\x98\x85 with three operations:The map function is just a proof of the fact that M is a Functor. So we can say that a monad is just a functor with two operations: return and join.Functors form a category themselves, with morphisms between them being so-called "natural transformations". A natural transformation is just a way to transform one functor into another while preserving its structure. Here\'s a nice article helping explain the idea. It talks about concat, which is just join for lists.With Haskell functors, the composition of two functors is a functor itself. In pseudocode, we could write this:This helps us think about join as a mapping from f \xe2\x88\x98 f \xe2\x86\x92 f. The type of join is \xe2\x88\x80\xce\xb1. f (f \xce\xb1) \xe2\x86\x92 f \xce\xb1. Intuitively, we can see how a function valid for all types \xce\xb1 can be thought of as a transformation of f.return is a similar transformation. Its type is \xe2\x88\x80\xce\xb1. \xce\xb1 \xe2\x86\x92 f \xce\xb1. This looks different\xe2\x80\x94the first \xce\xb1 is not "in" a functor! Happily, we can fix this by adding an identity functor there: \xe2\x88\x80\xce\xb1. Identity \xce\xb1 \xe2\x86\x92 f \xce\xb1. So return is a transformation Identity \xe2\x86\x92 f.Now we can think about a monad as just an algebra based around some functor f with operations f \xe2\x88\x98 f \xe2\x86\x92 f and Identity \xe2\x86\x92 f. Doesn\'t this look familiar? It\'s very similar to a monoid, which was just some type \xcf\x84 with operations \xcf\x84 \xc3\x97 \xcf\x84 \xe2\x86\x92 \xcf\x84 and () \xe2\x86\x92 \xcf\x84.So a monad is just like a monoid, except instead of having a type we have a functor. It\'s the same sort of algebra, just in a different category. (This is where the phrase "A monad is just a monoid in the category of endofunctors" comes from as far as I know.)Now, we have these two operations: f \xe2\x88\x98 f \xe2\x86\x92 f and Identity \xe2\x86\x92 f. To get the corresponding coalgebra, we just flip the arrows. This gives us two new operations: f \xe2\x86\x92 f \xe2\x88\x98 f and f \xe2\x86\x92 Identity. We can turn them into Haskell types by adding type variables as above, giving us \xe2\x88\x80\xce\xb1. f \xce\xb1 \xe2\x86\x92 f (f \xce\xb1) and \xe2\x88\x80\xce\xb1. f \xce\xb1 \xe2\x86\x92 \xce\xb1. This looks just like the definition of a comonad:So a comonad is then a coalgebra in a category of endofunctors.F-algebras and F-coalgebras are mathematical structures which are instrumental in reasoning about inductive types (or recursive types).We\'ll start first with F-algebras. I will try to be as simple as possible.I guess you know what is a recursive type. For example, this is a type for a list of integers:It is obvious that it is recursive - indeed, its definition refers to itself. Its definition consists of two data constructors, which have the following types:Note that I have written type of Nil as () -> IntList, not simply IntList. These are in fact equivalent types from the theoretical point of view, because () type has only one inhabitant.If we write signatures of these functions in a more set-theoretical way, we will getwhere 1 is a unit set (set with one element) and A \xc3\x97 B operation is a cross product of two sets A and B (that is, set of pairs (a, b) where a goes through all elements of A and b goes through all elements of B).Disjoint union of two sets A and B is a set A | B which is a union of sets {(a, 1) : a in A} and {(b, 2) : b in B}. Essentially it is a set of all elements from both A and B, but with each of this elements \'marked\' as belonging to either A or B, so when we pick any element from A | B we will immediately know whether this element came from A or from B.We can \'join\' Nil and Cons functions, so they will form a single function working on a set 1 | (Int \xc3\x97 IntList):Indeed, if Nil|Cons function is applied to () value (which, obviously, belongs to 1 | (Int \xc3\x97 IntList) set), then it behaves as if it was Nil; if Nil|Cons is applied to any value of type (Int, IntList) (such values are also in the set 1 | (Int \xc3\x97 IntList), it behaves as Cons.Now consider another datatype:It has the following constructors:which also can be joined into one function:It can be seen that both of this joined functions have similar type: they both look likewhere F is a kind of transformation which takes our type and gives more complex type, which consists of x and | operations, usages of T and possibly other types. For example, for IntList and IntTree F looks as follows:We can immediately notice that any algebraic type can be written in this way. Indeed, that is why they are called \'algebraic\': they consist of a number of \'sums\' (unions) and \'products\' (cross products) of other types.Now we can define F-algebra. F-algebra is just a pair (T, f), where T is some type and f is a function of type f :: F T -> T. In our examples F-algebras are (IntList, Nil|Cons) and (IntTree, Leaf|Branch). Note, however, that despite that type of f function is the same for each F, T and f themselves can be arbitrary. For example, (String, g :: 1 | (Int x String) -> String) or (Double, h :: Int | (Double, Double) -> Double) for some g and h are also F-algebras for corresponding F.Afterwards we can introduce F-algebra homomorphisms and then initial F-algebras, which have very useful properties. In fact, (IntList, Nil|Cons) is an initial F1-algebra, and (IntTree, Leaf|Branch) is an initial F2-algebra. I will not present exact definitions of these terms and properties since they are more complex and abstract than needed.Nonetheless, the fact that, say, (IntList, Nil|Cons) is F-algebra allows us to define fold-like function on this type. As you know, fold is a kind of operation which transforms some recursive datatype in one finite value. For example, we can fold a list of integer into a single value which is a sum of all elements in the list:It is possible to generalize such operation on any recursive datatype.The following is a signature of foldr function:Note that I have used braces to separate first two arguments from the last one. This is not real foldr function, but it is isomorphic to it (that is, you can easily get one from the other and vice versa). Partially applied foldr will have the following signature:We can see that this is a function which takes a list of integers and returns a single integer. Let\'s define such function in terms of our IntList type.We see that this function consists of two parts: first part defines this function\'s behavior on Nil part of IntList, and second part defines function\'s behavior on Cons part.Now suppose that we are programming not in Haskell but in some language which allows usage of algebraic types directly in type signatures (well, technically Haskell allows usage of algebraic types via tuples and Either a b datatype, but this will lead to unnecessary verbosity). Consider a function:It can be seen that reductor is a function of type F1 Int -> Int, just as in definition of F-algebra! Indeed, the pair (Int, reductor) is an F1-algebra.Because IntList is an initial F1-algebra, for each type T and for each function r :: F1 T -> T there exist a function, called catamorphism for r, which converts IntList to T, and such function is unique. Indeed, in our example a catamorphism for reductor is sumFold. Note how reductor and sumFold are similar: they have almost the same structure! In reductor definition s parameter usage (type of which corresponds to T) corresponds to usage of the result of computation of sumFold xs in sumFold definition.Just to make it more clear and help you see the pattern, here is another example, and we again begin from the resulting folding function. Consider append function which appends its first argument to second one:This how it looks on our IntList:Again, let\'s try to write out the reductor:appendFold is a catamorphism for appendReductor which transforms IntList into IntList.So, essentially, F-algebras allow us to define \'folds\' on recursive datastructures, that is, operations which reduce our structures to some value.F-coalgebras are so-called \'dual\' term for F-algebras. They allow us to define unfolds for recursive datatypes, that is, a way to construct recursive structures from some value.Suppose you have the following type:This is an infinite stream of integers. Its only constructor has the following type:Or, in terms of setsHaskell allows you to pattern match on data constructors, so you can define the following functions working on IntStreams:You can naturally \'join\' these functions into single function of type IntStream -> Int \xc3\x97 IntStream:Notice how the result of the function coincides with algebraic representation of our IntStream type. Similar thing can also be done for other recursive data types. Maybe you already have noticed the pattern. I\'m referring to a family of functions of typewhere T is some type. From now on we will defineNow, F-coalgebra is a pair (T, g), where T is a type and g is a function of type g :: T -> F T. For example, (IntStream, head&tail) is an F1-coalgebra. Again, just as in F-algebras, g and T can be arbitrary, for example,(String, h :: String -> Int x String) is also an F1-coalgebra for some h.Among all F-coalgebras there are so-called terminal F-coalgebras, which are dual to initial F-algebras. For example, IntStream is a terminal F-coalgebra. This means that for every type T and for every function p :: T -> F1 T there exist a function, called anamorphism, which converts T to IntStream, and such function is unique.Consider the following function, which generates a stream of successive integers starting from the given one:Now let\'s inspect a function natsBuilder :: Int -> F1 Int, that is, natsBuilder :: Int -> Int \xc3\x97 Int:Again, we can see some similarity between nats and natsBuilder. It is very similar to the connection we have observed with reductors and folds earlier. nats is an anamorphism for natsBuilder.Another example, a function which takes a value and a function and returns a stream of successive applications of the function to the value:Its builder function is the following one:Then iterate is an anamorphism for iterateBuilder.So, in short, F-algebras allow to define folds, that is, operations which reduce recursive structure down into a single value, and F-coalgebras allow to do the opposite: construct a [potentially] infinite structure from a single value.In fact in Haskell F-algebras and F-coalgebras coincide. This is a very nice property which is a consequence of presence of \'bottom\' value in each type. So in Haskell both folds and unfolds can be created for every recursive type. However, theoretical model behind this is more complex than the one I have presented above, so I deliberately have avoided it.Hope this helps.Going through the tutorial paper A tutorial on (co)algebras and (co)induction should give you some insight about co-algebra in computer science.Below is a citation of it to convince you,In general terms, a program in some programming language manipulates data. During the\n  development of computer science over the past few decades it became clear that an abstract\n  description of these data is desirable, for example to ensure that one\'s program does not depend on the particular representation of the data on which it operates. Also, such abstractness facilitates correctness proofs.\n  This desire led to the use of algebraic methods in computer science, in a branch called algebraic specification or abstract data type theory. The object of study are data types in themselves, using notions of techniques which are familiar from algebra. The data types used by computer scientists are often generated from a given collection of (constructor) operations,and it is for this reason that "initiality" of algebras plays such an important role.\n  Standard algebraic techniques have proved useful in capturing various essential aspects of data structures used in computer science. But it turned out to be difficult to algebraically describe some of the inherently dynamical structures occurring in computing. Such structures usually involve a notion of state, which can be transformed in various ways. Formal approaches to such state-based dynamical systems generally make use of automata or transition systems, as classical early references.\n  During the last decade the insight gradually grew that such state-based systems should not be described as algebras, but as so-called co-algebras. These are the formal dual of algebras, in a way which will be made precise in this tutorial. The dual property of "initiality" for algebras, namely finality turned out to be crucial for such co-algebras. And the logical reasoning principle that is needed for such final co-algebras is not induction but co-induction.Prelude, about Category theory.\nCategory theory should be rename theory of functors.\nAs categories are what one must define in order to define functors.\n(Moreover, functors are what one must define in order to define natural transformations.)What\'s a functor?\nIt\'s a transformation from one set to another which preserving their structure.\n(For more detail there is a lot of good description on the net).What\'s is an F-algebra?\nIt\'s the algebra of functor.\nIt\'s just the study of the universal propriety of functor.How can it be link to computer science ?\nProgram can be view  as a structured set of information.\nProgram\'s execution correspond to modification of this structured set of information.\nIt sound good that execution should preserve the program structure.\nThen execution can be view as the application of a functor over this set of information.\n(The one defining the program).Why F-co-algebra ?\nProgram are dual by essence as they are describe by information and they act on it.\nThen mainly the information which compose program and make them changed can be view in two way.Then at this stage, I\'d like to say that,During the life of a program, data and state co-exist, and they complete each other.\nThey are dual.I\'ll start with stuff that is obviously programming-related and then add on some mathematics stuff, to keep it as concrete and down-to-earth as I can.http://www.cs.umd.edu/~micinski/posts/2012-09-04-on-understanding-coinduction.htmlThe typical example of infinite data is the type of a lazy list (a\n  stream). For example, lets say that we have the following object in\n  memory:The computer can\xe2\x80\x99t hold all of \xcf\x80, because it only has a finite amount\n  of memory! But what it can do is hold a finite program, which will\n  produce any arbitrarily long expansion of \xcf\x80 that you desire. As long\n  as you only use finite pieces of the list, you can compute with that\n  infinite list as much as you need.However, consider the following program:This program should print the\n  third digit of pi. But in some languages, any argument to a function is evaluated before being passed\n  into a function (strict, not lazy, evaluation). If we use this\n  reduction order, then our above program will run forever computing the\n  digits of pi before it can be passed to our printer function (which\n  never happens). Since the machine does not have infinite memory, the\n  program will eventually run out of memory and crash. This might not be the best evaluation order.http://adam.chlipala.net/cpdt/html/Coinductive.htmlIn lazy functional programming languages like Haskell, infinite data structures\n  are everywhere. Infinite lists and more exotic datatypes provide convenient\n  abstractions for communication between parts of a program. Achieving similar\n  convenience without infinite lazy structures would, in many cases, require\n  acrobatic inversions of control flow.http://www.alexandrasilva.org/#/talks.html\nAlgebraic structures generally look like:This should sound like objects with 1. properties and 2. methods. Or even better, it should sound like type signatures.Standard mathematical examples include monoid \xe2\x8a\x83 group \xe2\x8a\x83 vector-space \xe2\x8a\x83 "an algebra". Monoids are like automata: sequences of verbs (eg, f.g.h.h.nothing.f.g.f). A git log that always adds history and never deletes it would be a monoid but not a group. If you add inverses (eg negative numbers, fractions, roots, deleting accumulated history, un-shattering a broken mirror) you get a group.Groups contain things that can be added or subtracted together. For example Durations can be added together. (But Dates cannot.) Durations live in a vector-space (not just a group) because they can also be scaled by outside numbers. (A type signature of scaling :: (Number,Duration) \xe2\x86\x92 Duration.)Algebras \xe2\x8a\x82 vector-spaces can do yet another thing: there\xe2\x80\x99s some m :: (T,T) \xe2\x86\x92 T. Call this "multiplication" or don\'t, because once you leave Integers it\xe2\x80\x99s less obvious what "multiplication" (or "exponentiation") should be.(This is why people look to (category-theoretic) universal properties: to tell them what multiplication should do or be like:\n )Comultiplication is easier to define in a way that feels non-arbitrary, than is multiplication, because to go from T \xe2\x86\x92 (T,T) you can just repeat the same element. ("diagonal map" \xe2\x80\x93 like diagonal matrices/operators in spectral theory)Counit is usually the trace (sum of diagonal entries), although again what\'s important is what your counit does; trace is just a good answer for matrices.The reason to look at a dual space, in general, is because it\'s easier to think in that space. For example it\'s sometimes easier to think about a normal vector than about the plane it\'s normal to, but you can control planes (including hyperplanes) with vectors (and now I\'m speaking of the familiar geometric vector, like in a ray-tracer).Mathematicians might be modelling something fun like TQFT\'s, whereas programmers have to wrestle withComputer scientists, when talking about coalgebras, usually have set-ish operations in mind, like Cartesian product. I believe this is what people mean when they say like "Algebras are coalgebras in Haskell". But to the extent that programmers have to model complex data-types like Place, Date/Time, and Customer\xe2\x80\x94and make those models look as much like the real world (or at least the end-user\'s view of the real world) as possible\xe2\x80\x94I believe duals, could be useful beyond only set-world.