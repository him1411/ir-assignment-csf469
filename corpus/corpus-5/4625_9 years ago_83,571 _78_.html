I have a method that\'s about ten lines of code.  I want to create more methods that do exactly the same thing, except for a small calculation that\'s going to change one line of code.  This is a perfect application for passing in a function pointer to replace that one line, but Java doesn\'t have function pointers.  What\'s my best alternative?Anonymous inner classSay you want to have a function passed in with a String param that returns an int.\nFirst you have to define an interface with the function as its only member, if you can\'t reuse an existing one.A method that takes the pointer would just accept StringFunction instance like so:And would be called like so:EDIT: In Java 8, you could call it with a lambda expression:For each "function pointer", I\'d create a small functor class that implements your calculation.\nDefine an interface that all the classes will implement, and pass instances of those objects into your larger function. This is a combination of the "command pattern", and "strategy pattern".@sblundy\'s example is good.When there is a predefined number of different calculations you can do in that one line, using an enum is a quick, yet clear way to implement a strategy pattern.Obviously, the strategy method declaration, as well as exactly one instance of each implementation are all defined in a single class/file.You need to create an interface that provides the function(s) that you want to pass around.  eg:Then, when you need to pass a function, you can implement that interface:Finally, the map function uses the passed in Function1 as follows:You can often use Runnable instead of your own interface if you don\'t need to pass in parameters, or you can use various other techniques to make the param count less "fixed" but it\'s usually a trade-off with type safety.  (Or you can override the constructor for your function object to pass in the params that way.. there are lots of approaches, and some work better in certain circumstances.)You can also do this (which in some RARE occasions makes sense).  The issue (and it is a big issue) is that you lose all the typesafety of using a class/interface and you have to deal with the case where the method does not exist. It does have the "benefit" that you can ignore access restrictions and call private methods (not shown in the example, but you can call methods that the compiler would normally not let you call).  Again, it is a rare case that this makes sense, but on those occasions it is a nice tool to have.If you have just one line which is different you could add a parameter such as a flag and a if(flag) statement which calls one line or the other.You can use method references in method arguments where the method accepts a functional interface. A functional interface is any interface that contains only one abstract method. (A functional interface may contain one or more default methods or static methods.)IntBinaryOperator is a functional interface. Its abstract method, applyAsInt, accepts two ints as its parameters and returns an int. Math.max also accepts two ints and returns an int. In this example, A.method(Math::max); makes parameter.applyAsInt send its two input values to Math.max and return the result of that Math.max.In general, you can use:instead of:which is short for:For more information, see :: (double colon) operator in Java 8 and Java Language Specification \xc2\xa715.13.You may also be interested to hear about work going on for Java 7 involving closures:What\xe2\x80\x99s the current state of closures in Java?http://gafter.blogspot.com/2006/08/closures-for-java.html\nhttp://tech.puredanger.com/java7/#closures@sblundy\'s answer is great, but anonymous inner classes have two small flaws, the primary being that they tend not to be reusable and the secondary is a bulky syntax.The nice thing is that his pattern expands into full classes without any change in the main class (the one performing the calculations).When you instantiate a new class you can pass parameters into that class which can act as constants in your equation--so if one of your inner classes look like this:but sometimes you need one that is:and maybe a third that is:rather than making two anonymous inner classes or adding a "passthrough" parameter, you can make a single ACTUAL class that you instantiate as:It would simply store the constant in the class and use it in the method specified in the interface.In fact, if KNOW that your function won\'t be stored/reused, you could do this:But immutable classes are safer--I can\'t come up with a justification to make a class like this mutable.I really only post this because I cringe whenever I hear anonymous inner class--I\'ve seen a lot of redundant code that was "Required" because the first thing the programmer did was go anonymous when he should have used an actual class and never rethought his decision.New Java 8 Functional Interfaces and Method References using the :: operator.Java 8 is able to maintain method references ( MyClass::new ) with "@ Functional Interface" pointers. There are no need for same method name, only same method signature required.Example:So, what we have here?YOU SHOULD USE FUNCTIONAL INTERFACES FOR LISTENERS ONLY AND ONLY FOR THAT!Because all other such function pointers are really bad for code readability and for ability to understand. However, direct method references sometimes come handy, with foreach for example.There are several predefined Functional Interfaces:For earlier Java versions you should try Guava Libraries, which has similar functionality, and syntax, as Adrian Petrescu has mentioned above.For additional research look at Java 8 Cheatsheetand thanks to The Guy with The Hat for the Java Language Specification \xc2\xa715.13 link.The Google Guava libraries, which are becoming very popular, have a generic Function and Predicate object that they have worked into many parts of their API.To do the same thing without interfaces for an array of functions:Sounds like a strategy pattern to me. Check out fluffycat.com Java patterns.One of the things I really miss when programming in Java is function callbacks. One situation where the need for these kept presenting itself was in recursively processing hierarchies where you want to perform some specific action for each item. Like walking a directory tree, or processing a data structure. The minimalist inside me hates having to define an interface and then an implementation for each specific case.One day I found myself wondering why not? We have method pointers - the Method object. With optimizing JIT compilers, reflective invocation really doesn\'t carry a huge performance penalty anymore. And besides next to, say, copying a file from one location to another, the cost of the reflected method invocation pales into insignificance.As I thought more about it, I realized that a callback in the OOP paradigm requires binding an object and a method together - enter the Callback object.Check out my reflection based solution for Callbacks in Java.  Free for any use.oK, this thread is already old enough, so very probably my answer is not helpful for the question. But since this thread helped me to find my solution, I\'ll put it out here anyway.I needed to use a variable static method with known input and known output (both double). So then, knowing the method package and name, I could work as follows:for a function that accepts one double as a parameter.So, in my concrete situation I initialized it withand invoked it later in a more complex situation withwhere activity is an arbitrary double value. I am thinking of maybe doing this a bit more abstract and generalizing it, as SoftwareMonkey has done, but currently I am happy enough with the way it is. Three lines of code, no classes and interfaces necessary, that\'s not too bad.Check out lambdaj http://code.google.com/p/lambdaj/and in particular its new closure featurehttp://code.google.com/p/lambdaj/wiki/Closuresand you will find a very readable way to define closure or function pointer without creating meaningless interface or use ugly inner classesWow, why not just create a Delegate class which is not all that hard given that I already did for java and use it to pass in parameter where T is return type. I am sorry but as a C++/C# programmer in general just learning java, I need function pointers because they are very handy. If you are familiar with any class which deals with Method Information you can do it. In java libraries that would be java.lang.reflect.method.If you always use an interface, you always have to implement it. In eventhandling there really isn\'t a better way around registering/unregistering from the list of handlers but for delegates where you need to pass in functions and not the value type, making a delegate class to handle it for outclasses an interface.If anyone is struggling to pass a function that takes one set of parameters to define its behavior but another set of parameters on which to execute, like Scheme\'s:see Pass Function with Parameter-Defined Behavior in JavaSince Java8, you can use lambdas, which also have libraries in the official SE 8 API.Usage:\nYou need to use a interface with only one abstract method.\nMake an instance of it (you may want to use the one java SE 8 already provided) like this:For more information checkout the documentation: https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.htmlPrior to Java 8, nearest substitute for function-pointer-like functionality was an anonymous class. For example:But now in Java 8 we have a very neat alternative known as lambda expression, which can be used as:where isBiggerThan is a method in CustomClass. We can also use method references here:None of the Java 8 answers have given a full, cohesive example, so here it comes.Declare the method that accepts the "function pointer" as follows:Call it by providing the function with a lambda expression: