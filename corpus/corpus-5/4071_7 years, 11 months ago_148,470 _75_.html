Someone asked me the other day when they should use the parameter keyword out instead of ref. While I (I think) understand the difference between the ref and out keywords (that has been asked before) and the best explanation seems to be that ref == in and out, what are some (hypothetical or code) examples where I should always use out and not ref. Since ref is more general, why do you ever want to use out? Is it just syntactic sugar?You should use out unless you need ref.It makes a big difference when the data needs to be marshalled e.g. to another process, which can be costly. So you want to avoid marshalling the initial value when the method doesn\'t make use of it.Beyond that, it also shows the reader of the declaration or the call whether the initial value is relevant (and potentially preserved), or thrown away.As a minor difference, an out parameter needs not be initialized.Example for out:where GetBothNames is a method to retrieve two values atomically, the method won\'t change behavior whatever a and b are. If the call goes to a server in Hawaii, copying the initial values from here to Hawaii is a waste of bandwidth. A similar snippet using ref:could confuse readers, because it looks like the initial values of a and b are relevant (though the method name would indicate they are not).Example for ref:Here the initial value is relevant to the method.Use out to denote that the parameter is not being used, only set.  This helps the caller understand that you\'re always initializing the parameter.Also, ref and out are not just for value types.  They also let you reset the object that a reference type is referencing from within a method.You\'re correct in that, semantically, ref provides both "in" and "out" functionality, whereas out only provides "out" functionality. There are some things to consider:Also, as an aside, it\'s important to note that while reference types and value types differ in the nature of their value, every variable in your application points to a location of memory that holds a value, even for reference types. It just happens that, with reference types, the value contained in that location of memory is another memory location. When you pass values to a function (or do any other variable assignment), the value of that variable is copied into the other variable. For value types, that means that the entire content of the type is copied. For reference types, that means that the memory location is copied. Either way, it does create a copy of the data contained in the variable. The only real relevance that this holds deals with assignment semantics; when assigning a variable or passing by value (the default), when a new assignment is made to the original (or new) variable, it does not affect the other variable. In the case of reference types, yes, changes made to the instance are available on both sides, but that\'s because the actual variable is just a pointer to another memory location; the content of the variable--the memory location--didn\'t actually change.Passing with the ref keyword says that both the original variable and the function parameter will actually point to the same memory location. This, again, affects only assignment semantics. If a new value is assigned to one of the variables, then because the other points to the same memory location the new value will be reflected on the other side.It depends on the compile context (See Example below). out and ref both denote variable passing by reference, yet ref requires the variable to be initialized before being passed, which can be an important difference in the context of Marshaling (Interop: UmanagedToManagedTransition or vice versa) MSDN warns:\nDo not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the same. A method parameter can be modified by ref regardless of whether it is a value type or a reference type. There is no boxing of a value type when it is passed by reference.From the official MSDN Docs:\nThe out keyword causes arguments to be passed by reference. This is similar to the ref keyword, except that ref requires that the variable be initialized before being passed\n\nThe ref keyword causes an argument to be passed by reference, not by value. The effect of passing by reference is that any change to the parameter in the method is reflected in the underlying argument variable in the calling method. The value of a reference parameter is always the same as the value of the underlying argument variable.\nWe can verify that the out and ref are indeed the same when the argument gets assigned:CIL Example:Consider the following examplein CIL, the instructions of myfuncOut and myfuncRef are identical as expected.nop: no operation, ldloc: load local, stloc: stack local, ldarg: load argument, bs.s: branch to target....(See: List of CIL instructions )You need to use ref if you plan to read and write to the parameter. You need to use out if you only plan to write. In effect, out is for when you\'d need more than one return value, or when you don\'t want to use the normal return mechanism for output (but this should be rare).There are language mechanics that assist these use cases. Ref parameters must have been initialized before they are passed to a method (putting emphasis on the fact that they are read-write), and out parameters cannot be read before they are assigned a value, and are guaranteed to have been written to at the end of the method (putting emphasis on the fact that they are write only). Contravening to these principles results in a compile-time error.For instance, int.TryParse returns a bool and accepts an out int parameter:This is a clear example of a situation where you need to output two values: the numeric result and whether the conversion was successful or not. The authors of the CLR decided to opt for out here since they don\'t care about what the int could have been before.For ref, you can look at Interlocked.Increment:Interlocked.Increment atomically increments the value of x. Since you need to read x to increment it, this is a situation where ref is more appropriate. You totally care about what x was before it was passed to Increment.In the next version of C#, it will even be possible to declare variable in out parameters, adding even more emphasis on their output-only nature:Below are some notes which i pulled from this codeproject article on C# Out Vs RefIf you are a visual person then please see this yourtube video which demonstrates the difference practically https://www.youtube.com/watch?v=lYdcY5zulXABelow image shows the differences more visuallyout is more constraint version of ref.In a method body, you need to assign to all out parameters before leaving the method.\nAlso an values assigned to an out parameter is ignored, whereas ref requires them to be assigned.So out allows you to do:where ref would require a and b to be assigned.How it sounds:\n\nout = only initialize/fill a parameter (the parameter must be empty) return it out plain\n\nref = reference, standard parameter (maybe with value), but the function can modifiy it. Just to clarify on OP\'s comment that the use on ref and out is a "reference to a value type or struct declared outside the method", which has already been established in incorrect. Consider the use of ref on a StringBuilder, which is a reference type:As apposed to this:An argument passed as ref must be initialized before passing to the method whereas out parameter needs not to be initialized before passing to a method.You can use the out contextual keyword in two contexts (each is a link to detailed information), as a parameter modifier or in generic type parameter declarations in interfaces and delegates. This topic discusses the parameter modifier, but you can see this other topic for information on the generic type parameter declarations.The out keyword causes arguments to be passed by reference. This is like the ref keyword, except that ref requires that the variable be initialized before it is passed. To use an out parameter, both the method definition and the calling method must explicitly use the out keyword. For example:\nC#Although variables passed as out arguments do not have to be initialized before being passed, the called method is required to assign a value before the method returns.Although the ref and out keywords cause different run-time behavior, they are not considered part of the method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one method takes a ref argument and the other takes an out argument. The following code, for example, will not compile:\nC#Overloading can be done, however, if one method takes a ref or out argument and the other uses neither, like this:\nC#Properties are not variables and therefore cannot be passed as out parameters.For information about passing arrays, see Passing Arrays Using ref and out (C# Programming Guide).You can\'t use the ref and out keywords for the following kinds of methods:ExampleDeclaring an out method is useful when you want a method to return multiple values. The following example uses out to return three variables with a single method call. Note that the third argument is assigned to null. This enables methods to return values optionally.\nC#why do you ever want to use out?To let others know that the variable will be initialized when it returns from the called method! As mentioned above:\n"for an out parameter, the calling method is required to assign a value before the method returns."example:Basically both ref and out for passing object/value between methodsThe out keyword causes arguments to be passed by reference. This is like the ref keyword, except that ref requires that the variable be initialized before it is passed.out : Argument is not initialized and it must be initialized in the methodref : Argument is already initialized and it can be read and updated in the method.What is the use of \xe2\x80\x9cref\xe2\x80\x9d for reference-types ?You can change the given reference to a different instance.Did you know?Although the ref and out keywords cause different run-time behavior, they are not considered part of the method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one method takes a ref argument and the other takes an out argument.You can\'t use the ref and out keywords for the following kinds of methods:Properties are not variables and therefore cannot be passed as out parameters.Extra notes regarding C# 7:\nIn C# 7 there\'s no need to predeclare variables using out. So a code like this:Can be written like this:Source:  What\'s new in C# 7.