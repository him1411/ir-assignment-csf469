Having trouble with what I thought was a relatively simple jQuery plugin...The plugin should fetch data from a php script via ajax to add options to a <select>.  The ajax request is pretty generic:This seems to work fine in Safari.  In Firefox 3.5, the REQUEST_TYPE on the server is always \'OPTIONS\', and the $_POST data does not appear.  Apache logs the request as type \'OPTIONS\':Why would this ajax call work in Safari, but not Firefox, and how do I fix it for Firefox?Here is a picture of the Firebug output:The reason for the error is the same origin policy. It only allows you to do XMLHTTPRequests to your own domain. See if you can use a JSONP callback instead:I used the following code on Django side to interpret the OPTIONS request and to set the required Access-Control headers. After this my cross domain requests from Firefox started working. As said before, the browser first sends the OPTIONS request and then immediately after that the POST/GETEdit: it seems to be that at least in some cases you also need to add the same Access-Control headers to the actual response. This can be a little bit confusing, since the request seems to succeed, but Firefox does not pass the contents of the response to the Javascript.This  mozilla developer center article describes various cross-domain request scenarios. The article seems to indicate that a POST request with content type of \'application/x-www-form-urlencoded\' should be sent as a \'simple request\' (with no \'preflight\' OPTIONS request). I found , however, that Firefox sent the OPTIONS request, even though my POST was sent with that content type.I was able to make this work by creating an options request handler on the server, that set the \'Access-Control-Allow-Origin\' response header to \'*\'. You can be more restrictive by setting it to something specific, like \'http://someurl.com\'. Also, I have read that, supposedly, you can specify a comma-separated list of multiple origins, but I couldn\'t get this to work.Once Firefox receives the response to the OPTIONS request with an acceptable \'Access-Control-Allow-Origin\' value, it sends the POST request.I\'ve fixed this issue using an entirely-Apache based solution.  In my vhost / htaccess I put the following block:You may not need the latter part, depending on what happens when Apache executes your target script.  Credit goes to the friendly ServerFault folk for the latter part.This PHP at the top of the responding script seems to work.  (With Firefox 3.6.11.  I have not yet done a lot of testing.)I had same problem with sending requests to google maps, and solution is quite simple with jQuery 1.5 - for dataType use dataType: "jsonp"I was looking through source 1.3.2, when using JSONP, the request is made by building a SCRIPT element dynamically, which gets past the browsers Same-domain policy. Naturally, you can\'t make a POST request using a SCRIPT element, the browser would fetch the result using GET. As you are requesting a JSONP call, the SCRIPT element is not generated, because it only does this when the Type of AJAX call is set to GET.http://dev.jquery.com/ticket/4690We had a problem like this with ASP.Net. Our IIS was returning an Internal Server Error when trying to execute a jQuery $.post to get some html content due to PageHandlerFactory was restricted to respond only GET,HEAD,POST,DEBUG Verbs. So you can change that restriction adding the verb "OPTIONS" to the list or selecting "All Verbs"You can modify that in your IIS Manager, selecting your website, then selecting Handler Mappings, double click in your PageHandlerFactory for *.apx files as you need (We use Integrated application pool with framework 4.0). Click on Request Restrictions, then go to Verbs Tabn and apply your modification.Now our $.post request is working as expected :)Check if your form\'s action URL includes the www part of the domain, while the original page you have opened is viewed without www.Typically done for Canonical Urls..I struggled for hours before stumbling upon this article and found the hint of Cross Domain.I seems that if o.url = \'index.php\' and this file exists is ok and returning a success message in the console. It returns an error if I use url:http://www.google.comIf doing a post request why not using directly the $.post method:It is so much simpler.Culprit is preflight request using OPTIONS methodFor HTTP request methods that can cause side-effects on user data (in particular, for HTTP methods other than GET, or for POST usage with certain MIME types), the specification mandates that browsers "preflight" the request, soliciting supported methods from the server with an HTTP OPTIONS request method, and then, upon "approval" from the server, sending the actual request with the actual HTTP request method.Web specification refer to: https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORSI resolved the problem by adding following lines in Nginx conf.I have posted a clear example of how to solve this if control the server code of the domain you are POSTing to.  This answer is touched on in this thread, but this more clearly explains it IMO.How do I send a cross-domain POST request via JavaScript?Solution to this is:this worked on calling Facebook API and with Firefox. Firebug is using GET instead of OPTIONS with the above conditions (both of them).Another possibility to circumvent the problem is to use a proxy script. That method is described for example hereCan you try this without contentType:application/x-www-form-urlencodedTry adding the option:dataType: "json"I had a similar problem with trying to use the Facebook API. The only contentType which didn\'t send the Preflighted request seemed to be just text/plain... not the rest of the parameters mentioned at mozilla hereFYI: The aforementioned Moz doc suggests X-Lori headers should trigger a Preflighted request ... it doesn\'t.You need to do some work on server side. I see you are using PHP on server side, but solution for .NET web application is here:\nCannot set content-type to 'application/json' in jQuery.ajaxDo the same in PHP script and it will work. Simply: At first request browser is asking server if is allowed to send such data with such type and second request is the proper/allowed.Try to add the following:I used a proxy url to solve a similar problem when I want to post data to my apache solr hosted in another server. (This may not be the perfect answer but it solves my problem.)Follow this URL: Using Mode-Rewrite for proxying, I add this line to my httpd.conf:Therefore, I can just post data to /solr instead of posting data to http://ip:8983/solr/*. Then it will be posting data in the same origin.I already have this code handling well my cors situation in php:And it was working fine locally and remotely, but not for uploads when remote.Something happen with apache/php OR my code, I didn\'t bother to search it, when you request OPTIONS it returns my header with cors rules but with 302 result. Therefore my browser doesn\'t recognise as an acceptable situation.What I did, based on @Mark McDonald answer, is just put this code after my header:Now, when requesting OPTIONS it will just send the header and 202 result.Please be advised:JSONP supports only the GET request method.*Send request by firefox:*Above request send by OPTIONS(while ==>type: \'POST\')!!!!But above request send by GET(while ==>type: \'POST\')!!!!When you are in "cross-domain communication" , pay attention and be careful. 