I have the following simple code to connect to a SSL webpageExcept it gives an error if the cert is a self signed one Error Domain=NSURLErrorDomain Code=-1202 UserInfo=0xd29930 "untrusted server certificate". Is there a way to set it to accept connections anyway (just like in a browser you can press accept) or a way to bypass it?There is a supported API for accomplishing this! Add something like this to your NSURLConnection delegate:Note that connection:didReceiveAuthenticationChallenge: can send its message to challenge.sender (much) later, after presenting a dialog box to the user if necessary, etc.If you\'re unwilling (or unable) to use private APIs, there\'s an open source (BSD license) library called ASIHTTPRequest that provides a wrapper around the lower-level CFNetwork APIs. They recently introduced the ability to allow HTTPS connections using self-signed or untrusted certificates with the -setValidatesSecureCertificate: API. If you don\'t want to pull in the whole library, you could use the source as a reference for implementing the same functionality yourself.Ideally, there should only be two scenarios of when an iOS application would need to accept an un-trusted certificate.Scenario A: You are connected to a test environment which is using a self-signed certificate.Scenario B: You are Proxying HTTPS traffic using a MITM Proxy like Burp Suite, Fiddler, OWASP ZAP, etc. The Proxies will return a certificate signed by a self-signed CA so that the proxy is able to capture HTTPS traffic. Production hosts should never use un-trusted certificates for obvious reasons. If you need to have the iOS simulator accept an un-trusted certificate for testing purposes it is highly recommended that you do not change application logic in order disable the built in certificate validation provided by the NSURLConnection APIs. If the application is released to the public without removing this logic, it will be susceptible to man-in-the-middle attacks. The recommended way to accept un-trusted certificates for testing purposes is to import the Certificate Authority(CA) certificate which signed the certificate onto your iOS Simulator or iOS device. I wrote up a quick blog post which demonstrates how to do this which an iOS Simulator at:accepting untrusted certificates using the ios simulatorNSURLRequest has a private method called setAllowsAnyHTTPSCertificate:forHost:, which will do exactly what you\'d like. You could define the allowsAnyHTTPSCertificateForHost: method on NSURLRequest via a category, and set it to return YES for the host that you\'d like to override.To complement the accepted answer, for much better security, you could add your server certificate or your own root CA certificate to keychain( https://stackoverflow.com/a/9941559/1432048), however doing this alone won\'t make NSURLConnection authenticate your self-signed server automatically.  You still need to add the below code to your NSURLConnection delegate, it\'s copied from Apple sample code AdvancedURLConnections, and you need to add two files(Credentials.h, Credentials.m) from apple sample code to your projects.I can\'t take any credit for this, but this one I found worked really well for my needs. shouldAllowSelfSignedCert is my BOOL variable. Just add to your NSURLConnection delegate and you should be rockin for a quick bypass on a per connection basis.In iOS 9, SSL connections will fail for all invalid or self-signed certificates. This is the default behavior of the new App Transport Security feature in iOS 9.0 or later, and on OS X 10.11 and later.You can override this behavior in the Info.plist, by setting NSAllowsArbitraryLoads to YES in the NSAppTransportSecurity dictionary. However, I recommend overriding this setting for testing purposes only.For information see App Transport Technote here.The category workaround posted by Nathan de Vries will pass the AppStore private API checks, and is useful in cases where you do not have control of the NSUrlConnection object.\nOne example is NSXMLParser which will open the URL you supply, but does not expose the NSURLRequest or NSURLConnection.In iOS 4 the workaround still seems to work, but only on the device, the Simulator does not invoke the allowsAnyHTTPSCertificateForHost: method anymore.You have to use NSURLConnectionDelegate to allow HTTPS connections and there are new callbacks with iOS8.Deprecated:Instead those, you need to declare:connectionShouldUseCredentialStorage: - Sent to determine whether the URL loader should use the credential storage for authenticating the connection.connection:willSendRequestForAuthenticationChallenge: - Tells the delegate that the connection will send a request for an authentication challenge.With willSendRequestForAuthenticationChallenge you can use challenge like you did with the deprecated methods, for example:I posted some gist code (based on someone else\'s work which I note) that lets you properly authenticate against a self generated certificate (and how to get a free certificate - see comments bottom of Cocoanetics)My code is here githubIf you want to keep using sendSynchronousRequest i work in this solution:you can see it here: Objective-C SSL Synchronous ConnectionWith AFNetworking I have successfully consumed https webservice with below code,You can use this CodeUse -connection:willSendRequestForAuthenticationChallenge: instead of these Deprecated MethodsDeprecated: