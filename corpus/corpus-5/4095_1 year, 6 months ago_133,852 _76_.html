Angular 2 provides life cycle hook ngOnInit by default. Could anyone tell me about the usage of ngOnInit if we already have a constructor?The Constructor is a default method of the class that is executed when the class is instantiated and ensures proper initialization of fields in the class and its subclasses. Angular or better DI analyzes the constructor parameters and when it creates a new instance by calling new MyClass() it tries to find providers that match the types of the constructor parameters, resolves them and passes them to the constructor likengOnInit is a life cycle hook called by Angular2 to indicate that Angular is done creating the component.We have to import OnInit in order to use like this (actually implementing OnInit is not mandatory but considered good practice):then to use the method of OnInit we have to implement in the class like this.Implement this interface to execute custom initialization logic after your directive\'s data-bound properties have been initialized.\n  ngOnInit is called right after the directive\'s data-bound properties have been checked for the first time, \n  and before any of its children have been checked. \n  It is invoked only once when the directive is instantiated.Mostly we use ngOnInit for all the initialization/declaration and avoid stuff to work in the constructor. The constructor should only be used to initialize class members but shouldn\'t do actual "work".So you should use constructor() to setup Dependency Injection and not much else. ngOnInit() is better place to "start" - it\'s where/when components\' bindings are resolved.For more information refer here:https://angular.io/api/core/OnInitAngular 2 Component Constructor Vs OnInitI think the best example would be using services.  Let\'s say that I want to grab data from my server when my component gets \'Activated\'.  Let\'s say that I also want to do some additional things to the data after I get it from the server, maybe I get an error and want to log it differently.It is really easy with ngOnInit over a constructor, it also limits how many callback layers I need to add to my application.For Example:with my constructor I could just call my _userService and populate my user_list, but maybe I want to do some extra things with it.  Like make sure everything is upper_case, I am not entirely sure how my data is coming through.So it makes it much easier to use ngOnInit.It makes it much easier to see, and so I just call my function within my component when I initialize instead of having to dig for it somewhere else.  Really it\'s just another tool you can use to make it easier to read and use in the future.  Also I find it really bad practice to put function calls within a constructor!The first one (constructor) is related to the class instantiation and has nothing to do with Angular2. I mean a constructor can be used on any class. You can put in it some initialization processing for the newly created instance.The second one corresponds to a lifecycle hook of Angular2 components:Quoted from official angular\'s website:So you should use ngOnInit if initialization processing relies on bindings of the component (for example component parameters defined with @Input), otherwise the constructor would be enough...The article The essential difference between Constructor and ngOnInit in Angular explores the difference from multiple perspectives. This answer provides the most important difference explanation related to the component initialization process which also shows the different in usage.Angular bootstrap process consists of the two major stages:The constructor of the component is called when Angular constructs components tree. All lifecycle hooks are called as part of running change detection. When Angular constructs components tree the root module injector is already configured so you can inject any global dependencies. Also, when Angular instantiates a child component class the injector for the parent component is also already set up so you can inject providers defined on the parent component including the parent component itself. Component constructors is the only method that is called in the context of the injector so if you need any dependency that\'s the only place to get those dependencies.When Angular starts change detection the components tree is constructed and the constructors for all components in the tree have been called. Also every component\'s template nodes are added to the DOM. The @Input communication mechanism is processed during change detection so you cannot expect to have the properties available in the constructor. It will be available on after ngOnInit.Let\'s see a quick example. Suppose you have the following template:So Angular starts bootstrapping the application. As I said it first creates classes for each component. So it calls MyAppComponent constructor. It also creates a DOM node which is the host element of the my-app component. Then it proceeds to creating a host element for the child-comp and calling ChildComponent constructor. At this stage it\'s not really concerned with the i input binding and any lifecycle hooks. So when this process is finished Angular ends up with the following tree of component views:Only then runs change detection and updates bindings for the my-app and calls ngOnInit on the MyAppComponent class. Then it proceeds to updating the bindings for the child-comp and calls ngOnInit on the ChildComponent class.You can do your initialization logic in either constructor or ngOnInit depending on what you need available. For example the article Here is how to get ViewContainerRef before @ViewChild query is evaluated shows what type of initialization logic can be required to be performed in the constructor.Here are some articles that will help you understand the topic better:Short and simple answer would be,Constructor : constructor is a default method runs (by deafult) when component is being constructed. When you create an instance of a class that time also constructor(default method) would be called. So in other words, when component is being constructed or/and an instance is  created constructor(default method) is called and relevant code written within is called. Basically and generally in Angular2 it used to inject things like services when component is being constructed for the further use.OnInit: ngOnInit is component\'s life cycle hook which runs first after constructor(default method) when component is being initialized. So, Your constructor will be called first and Oninit will be called later after constructor method.boot.tsResources: LifeCycle hookYou can check this small demo which shows implementation of both things.OK, first of all ngOnInit is part of Angular lifecycle, while constructor is part of ES6 class, so the major difference starts from here...Look at the below chart I created which showing the lifecycle of Angular.In Angular2 and above we use constructor to do the DI(Dependency Injection) for us, while in Angular 1 it was happening through calling to String method and checking which dependency was injected. As you see in the above diagram, ngOnInit is happening after constructor is ready and ngOnChnages and get fired after component is ready for us. All initialisation can happen in this stage, a simple sample is injecting a Service and initials it on init.OK, I also share a sample code for you to look, see how we get use of ngOnInit and constructor in the code below:To test this, I wrote this code, borrowing from the NativeScript Tutorial:user.tslogin.component.tsConsole outputThe above answers don\'t really answer this aspect of the original question: What is a lifecycle hook?  It took me a while to understand what that means until I thought of it this way.1)  Say your component is a human.  Humans have lives that include many stages of living, and then we expire.  2)  Our human component could have the following lifecycle script: Born, Baby, Grade School, Young Adult, Mid-age Adult, Senior Adult, Dead, Disposed of.3)  Say you want to have a function to create children.  To keep this from getting complicated, and rather humorous, you want your function to only be called during the Young Adult stage of the human component life. So you develop a component that is only active when the parent component is in the Young Adult stage.  Hooks help you do that by signaling that stage of life and letting your component act on it.Fun stuff.  If you let your imagination go to actually coding something like this it gets complicated, and funny.Like a lot of other languages, you can initialize variables at the class level, the constructor, or a method. It is up to the developer to decide what is best in their particular case. But below are a list of best practices when it comes to deciding.Usually, you will declare all your variables here that will be used in the rest of you component. You can initialize them if the value doesn\'t depend on anything else, or use const keyword to create constants if they will not change.Normally it\'s best practice to not do anything in the constructor and just use it for classes that will be injected. Most of the time your constructor should look like this:this will automatically create the class level variables, so you will have access to customService.myMethod() without having to do it manually.NgOnit is a lifecycle hook provided by the Angular 2 framework. Your component must implement OnInit in order to use it. This lifecycle hook gets called after the constructor is called and all the variables are initialized. The bulk of your initialization should go here. You will have the certainty that Angular has initialized your component correctly and you can start doing any logic you need in OnInit versus doing things when your component hasn\'t finished loading properly. Here is an image detailing the order of what gets called:https://angular.io/docs/ts/latest/guide/lifecycle-hooks.htmlIf you are using Angular 2 framework and need to interact with certain lifecycle events, use the methods provided by the framework for this to avoid problems.The constructor is a method in JavaScript and is considered as a feature of the class in es6 .When the class is instantiated it immediately runs the constructor whether it is used in Angular framework or not.So it is called by JavaScript engine and Angular has no control on that. The "ConstructorTest" class is instantiated below;So it internally calls the \nconstructor(All these happens by JavaScript(es6) no Angular).That is why there is ngOnInit lifecycle hook in Angular.ngOnInit renders when Angular has finished initialising the component.First we instantiate the class as below which happen to immediate runs of constructor method.ngOnInit is called by Angular when necessary as below:But you may ask why we are using constructor in Angular?The answer is dependencies injections.As it is mentioned before, constructor calls by JavaScript engine immediately when the class is instantiated (before calling ngOnInit by Angular), so typescript helps us to get the type of the dependencies are defined in the constructor and finally tells Angular what type of dependencies we want to use in that specific component.Two things to observe here:Both have different usability.Both methods have different goals/responsibilities. The task of the constructor (which is a language supported feature) is to make sure that the representation invariant holds. Otherwise stated to make sure that the instance is valid by giving correct values to the members. It is up to the developer to decide what \'correct\' means.The task of the onInit() method (which is an angular concept) is to allow method invocations on a correct object (representation invariant). Each method should in turn make sure that the representation invariant holds when the method terminates.The constructor should be used to create \'correct\' objects, the onInit method gives you the opportunity to invoke method calls at a well defined instance.constructor() is used to do dependency injection.ngOnInit(), ngOnChanges() and ngOnDestroy() etc. are lifecycle methods. ngOnChanges() will be the first to be called, before ngOnInit(), when the value of a bound property changes, it will NOT be called if there is no change. ngOnDestroy() is called when the component is removed. To use it, OnDestroy needs to be implemented by the class.