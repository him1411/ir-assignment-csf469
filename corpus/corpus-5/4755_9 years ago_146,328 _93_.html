I see a lot of talk on here about functional languages and stuff.  Why would you use one over a "traditional" language?  What do they do better?  What are they worse at?  What\'s the ideal functional programming application?Functional languages use a different paradigm than imperative and object oriented languages. They use side effect free functions as a basic building block in the language. This enables lots of things and makes a lot of things more difficult (or in most cases different from what people are used to)One of the biggest advantages with functional programming is that the order of execution of side effect free functions is not important. For example in erlang this is used to enable concurrency in a very transparent way. \nAnd because functions in functional languages behave very similar to mathematical functions it\'s easy to translate those into functional languages. In some cases this can make code more readable.Traditionally one of the big disadvantages of functional programming was also the lack of side effects. It\'s very difficult to write useful software without IO, but IO is hard to implement without side-effects in functions. So most people never got more out of functional programming than calculating a single output from a single input. In modern mixed paradigm languages like F# or scala this is easier.Lots of modern languages have elements from functional programming languages. C# 3.0 has a lot functional programming features and you can do functional programming in python too. I think the reasons for the popularity of functional programming is mostly because of two reasons. Concurrency is getting a real problem in normal programming because we\'re getting more and more multiprocessor computers. And the languages are getting more accessible.I don\'t think that there\'s any question about the functional approach to programming "catching on", because it\'s been in use (as a style of programming) for about 40 years. Whenever an OO programmer writes clean code that favors immutable objects, that code is borrowing functional concepts.However, languages that enforce a functional style are getting lots of virtual ink these days, and whether those languages will become dominant in the future is an open question. My own suspicion is that hybrid, multi-paradigm languages such as Scala or OCaml\nwill likely dominate over "purist" functional languages in the same way that pure OO language (Smalltalk, Beta, etc.) have influenced mainstream programming but haven\'t ended up as the most widely-used notations.Finally, I can\'t resist pointing out that your comments re FP are highly parallel to the remarks I heard from procedural programmers not that many years ago:Just as graphical user interfaces and "code as a model of the business" were concepts that helped OO become more widely appreciated, I believe that increased use of immutability and simpler (massive) parallelism will help more programmers see the benefits that the functional approach offers. But as much as we\'ve learned in the past 50 or so years that make up the entire history of digital computer programming, I think we still have much to learn. Twenty years from now, programmers will look back in amazement at the primitive nature of the tools we\'re currently using, including the now-popular OO and FP languages.The main plus for me is its inherent parallelism, especially as we are now moving away from more MHz and towards more and more cores.I don\'t think it will become the next programming paradigm and completely replace OO type methods, but I do think we will get to the point that we need to either write some of our code in a functional language, or our general purpose languages will grow to include more functional constructs.Even if you never work in a functional language professionally, understanding functional programming will make you a better developer. It will give you a new perspective on your code and programming in general. I say there\'s no reason to not learn it.I think the languages that do a good job of mixing functional and imperative style are the most interesting and are the most likely to succeed. I\'m always skeptical about the Next Big Thing.  Lots of times the Next Big Thing is pure accident of history, being there in the right place at the right time no matter whether the technology is good or not.  Examples: C++, Tcl/Tk, Perl.  All flawed technologies, all wildly successful because they were perceived either to solve the problems of the day or to be nearly identical to entrenched standards, or both.  Functional programming may indeed be great, but that doesn\'t mean it will be adopted.But I can tell you why people are excited about functional programming: many, many programmers have had a kind of "conversion experience" in which they discover that using a functional language makes them twice as productive (or maybe ten times as productive) while producing code that is more resilient to change and has fewer bugs.  These people think of functional programming as a secret weapon; a good example of this mindset is Paul Graham\'s Beating the Averages.  Oh, and his application?  E-commerce web apps.Since early 2006 there has also been some buzz about functional programming and parallelism.  Since people like Simon Peyton Jones have been worrying about parallelism off and on since at least 1984, I\'m not holding my breath until functional languages solve the multicore problem.  But it does explain some of the additional buzz right about now.In general, American universities are doing a poor job teaching functional programming.  There\'s a strong core of support for teaching intro programming using Scheme, and Haskell also enjoys some support there, but there\'s very little in the way of teaching advanced technique for functional programmer.  I\'ve taught such a course at Harvard and will do so again this spring at Tufts.  Benjamin Pierce has taught such a course at Penn.  I don\'t know if Paul Hudak has done anything at Yale.  The European universities are doing a much better job; for example, functional programming is emphasized in important places in Denmark, the Netherlands, Sweden, and the UK.  I have less of a sense of what\'s happening in Australasia.I don\'t see anyone mentioning the elephant in the room here, so I think it\'s up to me :)JavaScript is a functional language. As more and more people do more advanced things with JS, especially leveraging the finer points of jQuery, Dojo, and other frameworks, FP will be introduced by the web-developer\'s back-door. In conjunction with closures, FP makes JS code really light, yet still readable. Cheers,\nPSMost applications are simple enough to be solved in normal OO waysOO ways have not always been "normal." This decade\'s standard was last decade\'s marginalized concept.Functional programming is math. Paul Graham on Lisp (substitute functional programming for Lisp):So the short explanation of why this\n  1950s language is not obsolete is that\n  it was not technology but math, and\n  math doesn\xe2\x80\x99t get stale. The right\n  thing to compare Lisp to is not 1950s\n  hardware, but, say, the Quicksort\n  algorithm, which was discovered in\n  1960 and is still the fastest\n  general-purpose sort.I bet you didn\'t know you were functional programming when you used:The average corporate programmer, e.g.\n  most of the people I work with, will\n  not understand it and most work\n  environments will not let you program\n  in itThat one is just a matter of time though. Your average corporate programmer learns whatever the current Big Thing is. 15 years ago, they didn\'t understand OOP.\nIF FP catches on, your "average corporate programmers" will follow.It\'s not really taught at universities\n  (or is it nowadays?)Varies a lot. At my university, SML is the very first language students are introduced to.\nI believe MIT teaches LISP as a first-year course. These two examples may not be representative, of course, but I believe most universities at the very least offer some optional courses on FP, even if they don\'t make it a mandatory part of the curriculum.Most applications are simple enough to\n  be solved in normal OO waysIt\'s not really a matter of "simple enough" though. Would a solution be simpler (or more readable, robust, elegant, performant) in FP? Many things are "simple enough to be solved in Java", but it still requires a godawful amount of code.In any case, keep in mind that FP proponents have claimed that it was the Next Big Thing for several decades now. Perhaps they\'re right, but keep in mind that they weren\'t when they made the same claim 5, 10 or 15 years ago.One thing that definitely counts in their favor, though, is that recently, C# has taken a sharp turn towards FP, to the extent that it\'s practically turning a generation of programmers into FP programmers, without them even noticing. That might just pave the way for the FP "revolution". Maybe. ;)Man cannot understand the perfection and imperfections of his chosen art if he cannot see the value in other arts. Following rules only permits development up to a point in technique and then the student and artist has to learn more and seek further. It makes sense to study other arts as well as those of strategy.Who has not learned something more about themselves by watching the activities of others? To learn the sword study the guitar. To learn the fist study commerce. To just study the sword will make you narrow-minded and will not permit you to grow outward.-- Miyamoto Musashi, "A Book of Five Rings"I don\'t think most realistic people think that functional programming will catch on (becomes the main paradigm like OO). After all, most business problems are not pretty math problems but hairy imperative rules to move data around and display them in various ways, which means it\'s not a good fit for pure functional programming paradigm (the learning curve of monad far exceeds OO.)OTOH, functional programming is what makes programming fun. It makes you appreciate the  inherent, timeless beauty of succinct expressions of the underlying math of the universe. People say that learning functional programming will make you a better programmer. This is of course highly subjective. I personally don\'t think that\'s completely true either.It makes you a better sentient being.One key feature in a functional language is the concept of first-class functions. The idea is that you can pass functions as parameters to other functions and return them as values.Functional programming involves writing code that does not change state. The primary reason for doing so is so that successive calls to a function will yield the same result. You can write functional code in any language that supports first-class functions, but there are some languages, like Haskell, which do not allow you to change state. In fact, you\'re not supposed to make any side effects (like printing out text) at all - which sounds like it could be completely useless.Haskell instead employs a different approach to IO: monads. These are objects that contain the desired IO operation to be executed by your interpreter\'s toplevel. At any other level they are simply objects in the system.What advantages does functional programming provide? Functional programming allows coding with fewer potentials for bugs because each component is completely isolated. Also, using recursion and first-class functions allows for simple proofs of correctness which typically mirror the structure of the code.F# could catch on because Microsoft is pushing it.Pro:Contra: So, I give 50:50 chance to F# to become important. Other functional languages are not going to make it in near future.I\'d point out that everything you\'ve said about functional languages, most people were saying about object-oriented langauges about 20 years ago.  Back then it was very common to hear about OO:Change has to come from somewhere.  A meaningful and important change will make itself happen regardless of whether people trained in earlier technologies take the opinion that change isn\'t necessary.  Do you think the change to OO was good despite all the people that were against it at the time?I must be dense, but I still don\'t get it.  Are there any actual examples of small app\'s written in a functional language like F# where you can look at the source code and see how and why it was better to use such an approach than, say, C#?Most application can be solved in [insert your favorite language, paradigm, etc. here].Although, this is true, different tools can be used to solve different problems. Functional just allows another high (higher?) level abstraction that allows to do our jobs more effectively when used correctly.I think one reason is that some people feel that the most important part of whether a language will be accepted is how good the language is.  Unfortunately, things are rarely so simple.  For example, I would argue that the biggest factor behind Python\'s acceptance isn\'t the language itself (although that is pretty important).  The biggest reason why Python is so popular is its huge standard library and the even bigger community of 3rd party libraries.Languages like Clojure or F# may be the exception to the rule on this considering that they\'re built upon the JVM/CLR.  As a result, I don\'t have an answer for them.It seems to me that those people who never learned Lisp or Scheme as an undergraduate are now discovering it.  As with a lot of things in this field there is a tendency to hype and create high expectations...It will pass.Functional programming is great.  However, it will not take over the world.  C, C++, Java, C#, etc will still be around.What will come of this I think is more cross-language ability - for example implementing things in a functional language and then giving access to that stuff in other languages.  When reading "The Next Mainstream Programming Language: A Game Developer\xe2\x80\x99s Perspective" by Tim Sweeney, Epic Games, my first thought was - I got to learn Haskell.PPTGoogle\'s HTML VersionThings have been moving in a functional direction for a while. The two cool new kids of the past few years, Ruby and Python, are both radically closer to functional languages than what came before them \xe2\x80\x94 so much so that some Lispers have started supporting one or the other as "close enough." And with the massively parallel hardware putting evolutionary pressure on everyone \xe2\x80\x94 and functional languages in the best place to deal with the changes \xe2\x80\x94 it\'s not as far a leap as it once was to think that Haskell or F# will be the next big thing.Have you been following the evolution of programming languages lately? Every new release of all mainstream programming languages seems to borrow more and more features from functional programming.Closures, anonymous functions, passing and returning functions as values used to be exotic features known only to Lisp and ML hackers. But gradually, C#, Delphi, Python, Perl, Javascript, have added support for closures. Its not possible for any up-and-coming language to be taken seriously without closures.Several languages, notably Python, C#, and Ruby have native support for list comprehensions and list generators.ML pioneered generic programming in 1973, but support for generics ("parametric polymorphism") has only become an industry standard in the last 5 years or so. If I remember correctly, Fortran supported generics in 2003, followed by Java 2004, C# in 2005, Delphi in 2008. (I know C++ has supported templates since 1979, but 90% of discussions on C++\'s STL start with "here there be demons".)What makes these features appealing to programmers? It should be plainly obvious: it helps programmers write shorter code. All languages in the future are going to support -- at a minimum -- closures if they want to stay competitive. In this respect, functional programming is already in the mainstream.Most applications are simple enough to\n  be solved in normal OO waysWho says can\'t use functional programming for simple things too? Not every functional program needs to be a compiler, theorem prover, or massively parallel telecommunications switch. I regularly use F# for ad hoc throwaway scripts in addition to my more complicated projects.It\'s catching on because it\'s the best tool around for controlling complexity. \nSee:\n  - slides 109-116 of Simon Peyton-Jones talk "A Taste of Haskell"\n  - "The Next Mainstream Programming Language: A Game Developer\'s Perspective" by Tim SweeneyCheckout Why Functional Programming MattersI agree with the first point, but times change.  Corporations will respond, even if they\'re late adopters, if they see that there\'s an advantage to be had.  Life is dynamic.They were teaching Haskell and ML at Stanford in the late 90s.  I\'m sure that places like Carnegie Mellon, MIT, Stanford, and other good schools are presenting it to students.I agree that most "expose relational databases on the web" apps will continue in that vein for a long time.  Java EE, .NET, RoR, and PHP have evolved some pretty good solutions to that problem.You\'ve hit on something important: It might be the problem that can\'t be solved easily by other means that will boost functional programming.  What would that be?Will massive multicore hardware and cloud computing push them along?Because FP has significant benefits in terms of productivity, reliability and maintainability. Many-core may be a killer app that finally gets big corporations to switch over despite large volumes of legacy code.Furthermore, even big commercial languages like C# are taking on a distinct functional flavour as a result of many-core concerns - side effects simply don\'t fit well with concurrency and parallelism.I do not agree that "normal" programmers won\'t understand it. They will, just like they eventually understood OOP (which is just as mysterious and weird, if not more so).Also, most universities do teach FP, many even teach it as the first programming course.Wow - this is an interesting discussion. My own thoughts on this:FP makes some tasks relatively simple (compared to none-FP languages).\nNone-FP languages are already starting to take ideas from FP, so I suspect that this trend will continue and we will see more of a merge which should help people make the leap to FP easier.I don\'t know whether it will catch on or not, but from my investigations, a functional language is almost certainly worth learning, and will make you a better programmer. Just understanding referential transparency makes a lot of design decisions so much easier- and the resulting programs much easier to reason about. Basically, if you run into a problem, then it tends to only be a problem with the output of a single function, rather than a problem with an inconsistant state, which could have been caused by any of the hundreds of classes/methods/functions in an imparative language with side effects.The stateless nature of FP maps more naturally to the stateless nature of the web, and thus functional languages lend themselves more easily to more elegant, RESTFUL webapps. Contrast with JAVA and .NET frameworks that need to resort to horribly ugly HACKS like VIEWSTATE and SESSION keys to maintain application state, and maintain the (occasionally quite leaky) abstraction of a stateful imperative language, on an essentially stateless functional platform like the web. And also, the more stateless your application, the more easily it can lend itself to parallel processing. Terribly important for the web, if your website happens to get popular. It\'s not always straightforward to just add more hardware to a site to get better performance.My view is that it will catch on now that Microsoft have pushed it much further into the mainstream. For me it\'s attractive because of what it can do for us, because it\'s a new challenge and because of the job opportunities it resents for the future.Once mastered it will be another tool to further help make us more productive as programmers.A point missed in the discussion is that the best type systems are found in contemporary FP languages. What\'s more, compilers can infer all (or at least most) types automatically.It is interesting that one spends half the time writing type names when programming Java, yet Java is by far not type safe. While you may never write types in a Haskell programm (except as a kind of compiler checked documentation) and the code is 100% type safe.In addition to the other answers, casting the solution in pure functional terms forces one to understand the problem better. Conversely, thinking in a functional style will develop better* problem solving skills.*Either because the functional paradigm is better or because it will afford an additional angle of attack.