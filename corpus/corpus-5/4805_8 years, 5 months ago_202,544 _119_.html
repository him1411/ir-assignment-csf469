I have to keep thousands of strings in memory to be accessed serially in Java. Should I store them in an array or should I use some kind of List ?Since arrays keep all the data in a contiguous chunk of memory (unlike Lists), would the use of an array to store thousands of strings cause problems ?Answer: The common consensus is that the performance difference is minor. List interface provides more flexibility. I suggest that you use a profiler to test which is faster.My personal opinion is that you should use Lists.I work on a large codebase and a previous group of developers used arrays everywhere. It made the code very inflexible. After changing large chunks of it to Lists we noticed no difference in speed.The Java way is that you should consider what data abstraction most suits your needs.  Remember that in Java a List is an abstract, not a concrete data type.  You should declare the strings as a List, and then initialize it using the ArrayList implementation.This separation of Abstract Data Type and specific implementation is one the key aspects of object oriented programming.An ArrayList implements the List Abstract Data Type using an array as its underlying implementation.  Access speed is virtually identical to an array, with the additional advantages of being able to add and subtract elements to a List (although this is an O(n) operation with an ArrayList) and that if you decide to change the underlying implementation later on you can.  For example, if you realize you need synchronized access, you can change the implementation to a Vector without rewriting all your code.In fact, the ArrayList was specifically designed to replace the low-level array construct in most contexts.  If Java was being designed today, it\'s entirely possible that arrays would have been left out altogether in favor of the ArrayList construct.Since arrays keep all the data in a contiguous chunk of memory (unlike Lists), would the use of an array to store thousands of strings cause problems ?In Java, all collections store only references to objects, not the objects themselves.   Both arrays and ArrayList will store a few thousand references in a contiguous array, so they are essentially identical.  You can consider that a contiguous block of a few thousand 32-bit references will always be readily available on modern hardware.  This does not guarantee that you will not run out of memory altogether, of course, just that the contiguous block of memory requirement is not difficult to fufil.You should prefer generic types over arrays. As mentioned by others, arrays are inflexible and do not have the expressive power of generic types. (They do however support runtime typechecking, but that mixes badly with generic types.)But, as always, when optimizing you should always follow these steps:Although the answers proposing to use ArrayList do make sense in most scenario, the actual question of relative performance has not really been answered.There are a few things you can do with an array:Although get and set operations are somewhat slower on an ArrayList (resp. 1 and 3 nanosecond per call on my machine), there is very little overhead of using an ArrayList vs. an array for any non-intensive use. There are however a few things to keep in mind:Here are the results I measured for those three operations using the jmh benchmarking library (times in nanoseconds) with JDK 7 on a standard x86 desktop machine. Note that ArrayList are never resized in the tests to make sure results are comparable. Benchmark code available here.I ran 4 tests, executing the following statements:Results (in nanoseconds per call, 95% confidence):Conclusion: no noticeable difference.I ran 2 tests, executing the following statements:Results (in nanoseconds per call, 95% confidence):Conclusion: getting from an array is about 25% faster than getting from an ArrayList, although the difference is only on the order of one nanosecond.I ran 2 tests, executing the following statements:Results (in nanoseconds per call):Conclusion: set operations on arrays are about 40% faster than on lists, but, as for get, each set operation takes a few nanoseconds - so for the difference to reach 1 second, one would need to set items in the list/array hundreds of millions of times!ArrayList\'s copy constructor delegates to Arrays.copyOf so performance is identical to array copy (copying an array via clone, Arrays.copyOf or System.arrayCopy makes no material difference performance-wise).I\'m guessing the original poster is coming from a C++/STL background which is causing some confusion. In C++ std::list is a doubly linked list.In Java [java.util.]List is an implementation-free interface (pure abstract class in C++ terms). List can be a doubly linked list - java.util.LinkedList is provided. However, 99 times out of 100 when you want a make a new List, you want to use java.util.ArrayList instead, which is the rough equivalent of C++ std::vector. There are other standard implementations, such as those returned by java.util.Collections.emptyList() and java.util.Arrays.asList().From a performance standpoint there is a very small hit from having to go through an interface and an extra object, however runtime inlining means this rarely has any significance. Also remember that String are typically an object plus array. So for each entry, you probably have two other objects. In C++ std::vector<std::string>, although copying by value without a pointer as such, the character arrays will form an object for string (and these will not usually be shared).If this particular code is really performance-sensitive, you could create a single char[] array (or even byte[]) for all the characters of all the strings, and then an array of offsets. IIRC, this is how javac is implemented.I wrote a little benchmark to compare ArrayLists with Arrays. On my old-ish laptop, the time to traverse through a 5000-element arraylist, 1000 times, was about 10 milliseconds slower than the equivalent array code. So, if you\'re doing nothing but iterating the list, and you\'re doing it a lot, then maybe it\'s worth the optimisation. Otherwise I\'d use the List, because it\'ll make it easier when you do need to optimise the code.n.b. I did notice that using for String s: stringsList was about 50% slower than using an old-style for-loop to access the list. Go figure... Here\'s the two functions I timed; the array and list were filled with 5000 random (different) strings.Well firstly it\'s worth clarifying do you mean "list" in the classical comp sci data structures sense (ie a linked list) or do you mean java.util.List? If you mean a java.util.List, it\'s an interface. If you want to use an array just use the ArrayList implementation and you\'ll get array-like behaviour and semantics. Problem solved.If you mean an array vs a linked list, it\'s a slightly different argument for which we go back to Big O (here is a plain English explanation if this is an unfamiliar term.Array;Linked List:So you choose whichever one best suits how you resize your array. If you resize, insert and delete a lot then maybe a linked list is a better choice. Same goes for if random access is rare. You mention serial access. If you\'re mainly doing serial access with very little modification then it probably doesn\'t matter which you choose.Linked lists have a slightly higher overhead since, like you say, you\'re dealing with potentially non-contiguous blocks of memory and (effectively) pointers to the next element. That\'s probably not an important factor unless you\'re dealing with millions of entries however.I agree that in most cases you should choose the flexibility and elegance of ArrayLists over arrays - and in most cases the impact to program performance will be negligible.However, if you\'re doing constant, heavy iteration with little structural change (no adds and removes) for, say, software graphics rendering or a custom virtual machine, my sequential access benchmarking tests show that ArrayLists are 1.5x slower than arrays on my system (Java 1.6 on my one year-old iMac).Some code:No, because technically, the array only stores the reference to the strings. The strings themselves are allocated in a different location. For a thousand items, I would say a list would be better, it is slower, but it offers more flexibility and it\'s easier to use, especially if you are going to resize them.If you have thousands, consider using a trie. A trie is a tree-like structure that merges the common prefixes of the stored string.For example, if the strings were The trie would store:The strings requires 57 characters (including the null terminator, \'\\0\') for storage, plus whatever the size of the String object that holds them. (In truth, we should  probably round all sizes up to multiples of 16, but...) Call it 57 + 5 = 62 bytes, roughly.The trie requires 29 (including the null terminator, \'\\0\') for storage, plus sizeof the trie nodes, which are a ref to an array and a list of child trie nodes.For this example, that probably comes out about the same; for thousands, it probably comes out less as long as you do have common prefixes.Now, when using the trie in other code, you\'ll have to convert to String, probably using a StringBuffer as an intermediary. If many of the strings are in use at once as Strings, outside the trie, it\'s a loss.But if you\'re only using a few at the time -- say, to look up things in a dictionary -- the trie can save you a lot of space. Definitely less space than storing them in a HashSet.You say you\'re accessing them "serially" -- if that means sequentially an alphabetically, the trie also obviously gives you alphabetical order for free, if you iterate it depth-first.UPDATE:As Mark noted there is no significant difference after JVM warm up (several test passes). Checked with re-created array or even new pass starting with new row of matrix. With great probability this signs simple array with index access is not to be used in favor of collections.Still first 1-2 passes simple array is 2-3 times faster.ORIGINAL POST:Too much words for the subject too simple to check. Without any question array is several times faster than any class container. I run on this question looking for alternatives for my performance critical section. Here is the prototype code I built to check real situation:And here is the answer:Based on array (line 16 is active):Based on list (line 17 is active):Any more comment on \'faster\'? This is quite understood. The question is when about 3 time faster is better for you than flexibility of List. But this is another question.\nBy the way I checked this too based on manually constructed ArrayList. Almost the same result.Since there are already a lot of good answers here, I would like to give you some other information of practical view, which is insertion and iteration performance comparison : primitive array vs Linked-list in Java.This is actual simple performance check. So, the result will depend on the machine performance.Source code used for this is below : Performance Result is below :If you know in advance how large the data is then an array will be faster.A List is more flexible.  You can use an ArrayList which is backed by an array.list is slower than arrays.If you need efficiency use arrays.If you need flexibility use list.Remember that an ArrayList encapsulates an array, so there is little difference compared to using a primitive array (except for the fact that a List is much easier to work with in java).The pretty much the only time it makes sense to prefer an array to an ArrayList is when you are storing primitives, i.e. byte, int, etc and you need the particular space-efficiency you get by using primitive arrays.Array vs. List choice is not so important (considering performance) in the case of storing string objects. Because both array and list will store string object references, not the actual objects.It you can live with a fixed size, arrays will will be faster and need less memory.If you need the flexibility of the List interface with adding and removing elements, the question remains which implementation you should choose. Often ArrayList is recommended and used for any case, but also ArrayList has its performance problems if elements at the beginning or in the middle of the list must be removed or inserted.You therefore may want to have a look at http://java.dzone.com/articles/gaplist-%E2%80%93-lightning-fast-list which introduces GapList. This new list implementation combines the strengths of both ArrayList and LinkedList resulting in very good performance for nearly all operations.Depending on the implementation. it\'s possible that an array of primitive types will be smaller and more efficient than ArrayList. This is because the array will store the values directly in a contiguous block of memory, while the simplest ArrayList implementation will store pointers to each value. On a 64-bit platform especially, this can make a huge difference.Of course, it\'s possible for the jvm implementation to have a special case for this situation, in which case the performance will be the same. List is the preferred way in java 1.5 and beyond as it can use generics. Arrays cannot have generics. Also Arrays have a pre defined length, which cannot grow dynamically. Initializing an array with a large size is not a good idea.\nArrayList is the the way to declare an array with generics and it can dynamically grow.\nBut if delete and insert is used more frequently, then linked list is the fastest data structure to be used.Arrays recommended everywhere you may use them instead of list, especially in case if you know items count and size would not be changing. See Oracle Java best practice: http://docs.oracle.com/cd/A97688_16/generic.903/bp/java.htm#1007056Of course, if you need add and remove objects from collection many times easy use lists.ArrayList stores its items in an Object[] array and use the untyped toArray method which is a lot faster (the blue bar) than the typed one. This is typesafe since the untyped array is wrapped in the generic type ArrayList<T> that is checked by the compiler.This chart shows a benchmark with n = 5 on Java 7. However, the picture does not change much with more items or another VM. The CPU overhead might not seem drastic, but it adds up. Chances are that consumers of an array have to convert it into a collection in order to do anything with it, then convert the result back to an array to feed it into another interface method etc.\nUsing a simple ArrayList instead of an array improves performance, without adding much footprint. ArrayList adds a constant overhead of 32 bytes to the wrapped array. For example, an array with ten objects requires 104 bytes, an ArrayList 136 bytes.This operation performs in constant time, so it\xe2\x80\x99s much faster than any of the above (yellow bar). This is not the same as a defensive copy. An unmodifiable collection will change when your internal data changes. If this happens, clients can run into a ConcurrentModificationException while iterating over the items. It can be considered bad design that an interface provides methods that throw an UnsupportedOperationException at runtime. However, at least for internal use, this method can be a high-performance alternative to a defensive copy \xe2\x80\x93 something that is not possible with arrays.None of the answers had information that I was interested in - repetitive scan of the same array many many times. Had to create a JMH test for this.Results (Java 1.8.0_66 x32, iterating plain array is at least 5 times quicker than ArrayList):Test"Thousands" is not a large number. A few thousand paragraph-length strings are on the order of a couple of megabytes in size. If all you want to do is access these serially, use an immutable singly-linked List.Don\'t get into the trap of optimizing without proper benchmarking. As others have suggested use a profiler before making any assumption.The different data structures that you have enumerated have different purposes. A list is very efficient at inserting elements in the beginning and at the end but suffers a lot when accessing random elements. An array has fixed storage but provides fast random access. Finally an ArrayList improves the interface to an array by allowing it to grow. Normally the data structure to be used should be dictated by how the data stored will be access or added.About memory consumption. You seem to be mixing some things. An array will only give you a continuous chunk of memory for the type of data that you have. Don\'t forget that java has a fixed data types: boolean, char, int, long, float and Object (this include all objects, even an array is an Object). It means that if you declare an array of String strings [1000] or MyObject myObjects [1000] you only get a 1000 memory boxes big enough to store the location (references or pointers) of the objects. You don\'t get a 1000 memory boxes big enough to fit the size of the objects. Don\'t forget that your objects are first created with "new". This is when the memory allocation is done and later a reference (their memory address) is stored in the array. The object doesn\'t get copied into the array only it\'s reference.I don\'t think it makes a real difference for Strings. What is contiguous in an array of strings is the references to the strings, the strings themselves are stored at random places in memory.Arrays vs. Lists can make a difference for primitive types, not for objects. IF you know in advance the number of elements, and don\'t need flexibility, an array of millions of integers or doubles will be more efficient in memory and marginally in speed than a list, because indeed they will be stored contiguously and accessed instantly. That\'s why Java still uses arrays of chars for strings, arrays of ints for image data, etc.Array is faster - all memory is pre-allocated in advance.A lot of microbenchmarks given here have found numbers of a few nanoseconds for things like array/ArrayList reads. This is quite reasonable if everything is in your L1 cache.A higher level cache or main memory access can have order of magnitude times of something like 10nS-100nS, vs more like 1nS for L1 cache. Accessing an ArrayList has an extra memory indirection, and in a real application you could pay this cost anything from almost never to every time, depending on what your code is doing between accesses. And, of course, if you have a lot of small ArrayLists this might add to your memory use and make it more likely you\'ll have cache misses.The original poster appears to be using just one and accessing a lot of contents in a short time, so it should be no great hardship. But it might be different for other people, and you should watch out when interpreting microbenchmarks.Java Strings, however, are appallingly wasteful, especially if you store lots of small ones (just look at them with a memory analyzer, it seems to be > 60 bytes for a string of a few characters). An array of strings has an indirection to the String object, and another from the String object to a char[] which contains the string itself. If anything\'s going to blow your L1 cache it\'s this, combined with thousands or tens of thousands of Strings. So, if you\'re serious - really serious - about scraping out as much performance as possible then you could look at doing it differently. You could, say, hold two arrays, a char[] with all the strings in it, one after another, and an int[] with offsets to the starts. This will be a PITA to do anything with, and you almost certainly don\'t need it. And if you do, you\'ve chosen the wrong language.It depends on how you have to access it.After storing, if you mainly want to do search operation, with little or no insert/delete, then go for Array (as search is done in O(1) in arrays, whereas add/delete may need re-ordering of the elements).After storing, if your main purpose is to add/delete strings, with little or no search operation, then go for List. ArrayList internally uses  array  object to add(or store) the\n  elements. In other words, ArrayList is backed by Array data\n  -structure.The array of ArrayList is resizable (or dynamic).Array is faster than Array because ArrayList internally use array. if we can directly add elements in Array and indirectly add element in \nArray through ArrayList always directly mechanism is faster than indirectly mechanism.There are two overloaded add() methods in ArrayList class:\n1.  add(Object)  : adds object to the end of the list.\n2.  add(int index , Object )  : inserts the specified object at the specified position in the list.How the size of ArrayList grows dynamically? Important point to note from above code is that we are checking the capacity of the ArrayList , before adding the element. ensureCapacity()  determines what is the current size of occupied elements and what is the maximum size of the array. If size of the  filled elements (including the new element to be added to the ArrayList class) is greater than the  maximum size of the array then increase the size of array. But the size of the array can not be increased dynamically. So what happens internally is new Array is created with capacityTill Java 6(Update) From Java 7also, data from the old array is copied into the new array.Having overhead methods in ArrayList that\'s why Array is faster than ArrayList.Arrays - It would always be better when we have to achieve faster fetching of resultsLists- Performs results on insertion and deletion since they can be done in O(1) and this also provides methods to add, fetch and delete data easily. Much easier to use.But always remember that the fetching of data would be fast when the index position in array where the data is stored - is known. This could be achieved well by sorting the array. Hence this increases the time to fetch the data (ie; storing the data + sorting the data + seek for the position where the data is found). Hence this increases additional latency to fetch the data from the array even they may be good at fetching the data sooner.Hence this could be solved with trie data structure or ternary data structure. As discussed above the trie data structure would be very efficient in searching for the data the search for a particularly word can be done in O(1) magnitude. When time matters ie; if you have to search and retrieve data quickly you may go with trie data structure. If you want your memory space to be consumed less and you wish to have a better performance then go with ternary data structure. Both these are suitable for storing huge number of strings (eg; like words contained in dictionary).