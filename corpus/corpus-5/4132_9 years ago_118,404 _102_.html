What "Hidden Features" of JavaScript do you think every programmer should know?After having seen the excellent quality of the answers to the following questions I thought it was time to ask it for JavaScript.Even though JavaScript is arguably the most important Client Side language right now (just ask Google) it\'s surprising how little most web developers appreciate how powerful it really is.You don\'t need to define any parameters for a function. You can just use the function\'s arguments array-like object.I could quote most of Douglas Crockford\'s excellent book\nJavaScript: The Good Parts.But I\'ll take just one for you, always use === and !== instead of == and !=== is not transitive. If you use === it would give false for \nall of these statements as expected.Functions are first class citizens in JavaScript:Functional programming techniques can be used to write elegant javascript.Particularly, functions can be passed as parameters, e.g. Array.filter() accepts a callback:You can also declare a "private" function that only exists within the scope of a specific function:You can use the in operator to check if a key exists in an object:If you find the object literals too ugly you can combine it with the parameterless function tip:Assigning default values to variablesYou can use the logical or operator || in an assignment expression to provide a default value:The a variable will get the value of c only if b is falsy (if is null, false, undefined, 0, empty string, or NaN), otherwise a will get the value of b.This is often useful in functions, when you want to give a default value to an argument in case isn\'t supplied:Example IE fallback in event handlers:The following language features have been with us for a long time, all JavaScript implementations support them, but they weren\'t part of the specification until ECMAScript 5th Edition:The debugger statementDescribed in: ยง 12.15 The debugger statementThis statement allows you to put breakpoints programmatically in your code just by:If a debugger is present or active, it will cause it to break immediately, right on that line.Otherwise, if the debugger is not present or active this statement has no observable effect.Multiline String literalsDescribed in: ยง 7.8.4 String LiteralsYou have to be careful because the character next to the \\ must be a line terminator, if you have a space after the \\ for example, the code will look exactly the same, but it will raise a SyntaxError.JavaScript does not have block scope (but it has closure so let\'s call it even?).You can access object properties with [] instead of .This allows you look up a property matching a variable.You can also use this to get/set object properties whose name is not a legal identifier.Some people don\'t know this and end up using eval() like this, which is a really bad idea:This is harder to read, harder to find errors in (can\'t use jslint), slower to execute, and can lead to XSS exploits.If you\'re Googling for a decent JavaScript reference on a given topic, include the "mdc" keyword in your query and your first results will be from the Mozilla Developer Center. I don\'t carry any offline references or books with me. I always use the "mdc" keyword trick to directly get to what I\'m looking for. For example:Google: javascript array sort mdc\n(in most cases you may omit "javascript")Update: Mozilla Developer Center has been renamed to Mozilla Developer Network. The "mdc" keyword trick still works, but soon enough we may have to start using "mdn" instead.Maybe a little obvious to some...Install Firebug and use console.log("hello"). So much better than using random alert();\'s which I remember doing a lot a few years ago.Private MethodsAn object can have private methods.Also mentioned in Crockford\'s "Javascript: The Good Parts":parseInt() is dangerous.  If you pass it a string without informing it of the proper base it may return unexpected numbers.  For example parseInt(\'010\') returns 8, not 10.  Passing a base to parseInt makes it work correctly:Functions are objects and therefore can have properties.I\'d have to say self-executing functions.Because Javascript doesn\'t have block scope, you can use a self-executing function if you want to define local variables:Here, myvar is does not interfere with or pollute the global scope, and disappears when the function terminates.Know how many parameters are expected by a functionKnow how many parameters are received by the functionHere are some interesting things:[updated a little in response to good comments; please see comments]I know I\'m late to the party, but I just can\'t believe the + operator\'s usefulness hasn\'t been mentioned beyond "convert anything to a number".  Maybe that\'s how well hidden a feature it is?Of course, you can do all this using Number() instead, but the + operator is so much prettier!You can also define a numeric return value for an object by overriding the prototype\'s valueOf() method.  Any number conversion performed on that object will not result in NaN, but the return value of the valueOf() method:"Extension methods in JavaScript" via the prototype property.This will add a contains method to all Array objects.  You can call this method using this syntax To properly remove a property from an object, you should delete the property instead of just setting it to undefined:The property prop2 will still be part of the iteration. If you want to completely get rid of prop2, you should instead do:The property prop2 will no longer will make an appearance when you\'re iterating through the properties.with. It\'s rarely used, and frankly, rarely useful... But, in limited circumstances, it does have its uses.For instance: object literals are quite handy for quickly setting up properties on a new object. But what if you need to change half of the properties on an existing object?Alan Storm points out that this can be somewhat dangerous: if the object used as context doesn\'t have one of the properties being assigned to, it will be resolved in the outer scope, possibly creating or overwriting a global variable. This is especially dangerous if you\'re used to writing code to work with objects where properties with default or empty values are left undefined:Therefore, it is probably a good idea to avoid the use of the with statement for such assignment. Methods (or functions) can be called on object that are not of the type they were designed to work with. This is great to call native (fast) methods on custom objects.This code crashes because listNodes is not an ArrayThis code works because listNodes defines enough array-like properties (length, [] operator) to be used by sort().Prototypal inheritance (popularized by Douglas Crockford) completely revolutionizes the way you think about loads of things in Javascript.It\'s a killer! Pity how almost no one uses it.It allows you to "beget" new instances of any object, extend them, while maintaining a (live) prototypical inheritance link to their other properties.  Example:Some would call this a matter of taste, but:The trinary operator can be chained to act like Scheme\'s (cond ...):can be written as...This is very "functional", as it branches your code without side effects. So instead of:You can write:Works nice with recursion, too :)Numbers are also objects. So you can do cool stuff like:How about closures in JavaScript (similar to anonymous methods in C# v2.0+). You can create a function that creates a function or "expression".Example of closures:You can also extend (inherit) classes and override properties/methods using the prototype chain spoon16 alluded to.In the following example we create a class Pet and define some properties. We also override the .toString() method inherited from Object.After this we create a Dog class which extends Pet and overrides the .toString() method again changing it\'s behavior (polymorphism). In addition we add some other properties to the child class.After this we check the inheritance chain to show off that Dog is still of type Dog, of type Pet, and of type Object.Both answers to this question were codes modified from a great MSDN article by Ray Djajadinata.You may catch exceptions depending on their type. Quoted from MDC:NOTE: Conditional catch clauses are a Netscape (and hence Mozilla/Firefox) extension that is not part of the ECMAScript specification and hence cannot be relied upon except on particular browsers.Off the top of my head...Functionsarguments.callee refers to the function that hosts the "arguments" variable, so it can be used to recurse anonymous functions:That\'s useful if you want to do something like this:ObjectsAn interesting thing about object members: they can have any string as their names:StringsString.split can take regular expressions as parameters:String.replace can take a regular expression as a search parameter and a function as a replacement parameter:You can use objects instead of switches most of the time.Update: if you\'re concerned about the cases evaluating in advance being inefficient (why are you worried about efficiency this early on in the design of the program??) then you can do something like this:This is more onerous to type (or read) than either a switch or an object, but it preserves the benefits of using an object instead of a switch, detailed in the comments section below. This style also makes it more straightforward to spin this out into a proper "class" once it grows up enough.update2: with proposed syntax extensions for ES.next, this becomesBe sure to use the hasOwnProperty method when iterating through an object\'s properties:This is done so that you will only access the direct properties of anObject, and not use the properties that are down the prototype chain.Private variables with a Public InterfaceIt uses a neat little trick with a self-calling function definition.\nEverything inside the object which is returned is available in the public interface, while everything else is private.