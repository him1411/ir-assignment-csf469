In C# 3.0 you can create anonymous class with the following syntaxIs there a way to add these anonymous class to a generic list?Example:Another Example:You could do:There are lots of ways of skinning this cat, but basically they\'ll all use type inference somewhere - which means you\'ve got to be calling a generic method (possibly as an extension method). Another example might be:You get the idea :)Here is the answer.Not exactly, but you can say List<object> and things will work. However, list[0].Id won\'t work. This will work at runtime in C# 4.0 by having a List<dynamic>, that is you won\'t get IntelliSense. There are many ways to do this, but some of the responses here are creating a list that contains garbage elements, which requires you to clear the list.   If you are looking for an empty list of the generic type, use a Select against a List of Tuples to make the empty list.   No elements will be instantiated.Here\'s the one-liner to create an empty list:Then you can add to it using your generic type:As an alternative, you can do something like below to create the empty list (But, I prefer the first example because you can use it for a populated collection of Tuples as well) :I guesswill work.You might also consider writing it like this:You can do this in your code.I usually use the following; mainly because you then "start" with a list that\'s empty.Lately, I\'ve been writing it like this instead:Using the repeat method would also allow you to do:..which gives you the initial list with the first item already added.Here is my attempt.I came up with this when I wrote something similar for making a Anonymous List for a custom type.Here is a another method of creating a List of anonymous types that allows you to start with an empty list, but still have access to IntelliSense.If you wanted to keep the first item, just put one letter in the string.I checked the IL on several answers.  This code efficiently provides an empty List:Instead of this:You could do this:However, you will get a compiletime error if you try to do something like this in another scope, although it works at runtime:The problem is that only the members of Object are available at runtime, although intellisense will show the properties id and name.In .net 4.0 a solution is to use the keyword dynamic istead of object in the code above.Another solution is to use reflection to get the propertiesFor your second example, where you have to initialize a new List<T>, one idea is to create an anonymous list, and then clear it.Or as an extension method, should be easier:Or probably even shorter,You can do it this way:It seems a little "hacky" to me, but it works - if you really need to have a list and can\'t just use the anonymous array.This is an old question, but I thought I\'d put in my C# 6 answer. I often have to set up test data that is easily entered in-code as a list of tuples. With a couple of extension functions, it is possible to have this nice, compact format, without repeating the names on each entry.This gives an IEnumerable - if you want a list that you can add to then just add ToList().The magic comes from custom extension Add methods for tuples, as described at https://stackoverflow.com/a/27455822/4536527.}The only thing I don\'t like is that the types are separated from the names, but if you really don\'t want to make a new class then this approach will still let you have readable data.In latest version 4.0, can use dynamic like belowTry with this:  