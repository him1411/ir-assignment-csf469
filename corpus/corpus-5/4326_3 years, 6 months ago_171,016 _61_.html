Currently in ES5 many of us are using the following pattern in frameworks to create classes and class variables, which is comfy:In ES6 you can create classes natively, but there is no option to have class variables:Sadly, the above won\'t work, as classes only can contain methods. I understand that I can this.myVar = true in constructor\xe2\x80\xa6but I don\'t want to \'junk\' my constructor, especially when I have 20-30+ params for a bigger class.I was thinking of many ways to handle this issue, but haven\'t yet found any good ones. (For example: create a ClassConfig handler, and pass a parameter object, which is declared separately from the class. Then the handler would attach to the class. I was thinking about WeakMaps also to integrate, somehow.)What kind of ideas would you have to handle this situation?The notes in the ES wiki for the proposal in ES6 (maximally minimal classes) note:There is (intentionally) no direct declarative way to define either prototype data properties (other than methods) class properties, or instance propertyClass properties and prototype data properties need be created outside the declaration.Properties specified in a class definition are assigned the same attributes as if they appeared in an object literal.This means that what you\'re asking for was considered, and explicitly decided against.Good question. The good people of TC39 want class declarations to declare and define the capabilities of a class. Not its members. An ES6 class declaration defines its contract for its user. Remember, a class definition defines prototype methods - defining variables on the prototype is generally not something you do.\nYou can, of course use:In the constructor like you suggested. Also see the summary of the consensus.A new proposal for ES7 is being worked on that allows more concise instance variables through class declarations and expressions - https://esdiscuss.org/topic/es7-property-initializersJust to add to Benjamin\'s answer \xe2\x80\x94 class variables are possible, but you wouldn\'t use prototype to set them.For a true class variable you\'d want to do something like the following:From within a class method that variable can be accessed as this.constructor.foo (or MyClass.foo). These class properties would not usually be accessible from to the class instance. i.e. MyClass.foo gives \'bar\' but new MyClass().foo is undefinedIf you want to also have access to your class variable from an instance, you\'ll have to additionally define a getter:I\'ve only tested this with Traceur, but I believe it will work the same in a standard implementation.JavaScript doesn\'t really have classes. Even with ES6 we\'re looking at an object- or prototype-based language rather than a class-based language.  In any function X () {}, X.prototype.constructor points back to X.\nWhen the new operator is used on X, a new object is created inheriting X.prototype. Any undefined properties in that new object (including constructor) are looked up from there. We can think of this as generating object and class properties.In your example:Because of MY_CONST is primitive https://developer.mozilla.org/en-US/docs/Glossary/Primitive we can just do:But if MY_CONST is reference type like static get MY_CONST() {return [\'string\'];} alert output is string, false. In such case delete operator can do the trick:And finally for class variable not const:Babel supports class variables in ESNext, check this example - http://esnextb.in/?gist=ad168ed095aeac5ce098What about the oldschool way? In constructor you mention only those vars which have to be computed. \nI like prototype inheritance for this feature -- it can help to save a lot of memory(in case if there are a lot of never-assigned vars).As Benjamin said in his answer, TC39 explicitly decided not to include this feature at least for ES2015.  However, the consensus seems to be that they will add it in ES2016.The syntax hasn\'t been decided yet, but there\'s a preliminary proposal for ES2016 that will allow you to declare static properties on a class.Thanks to the magic of babel, you can use this today.  Enable the class properties transform according to these instructions and you\'re good to go.  Here\'s an example of the syntax:This proposal is in a very early state, so be prepared to tweak your syntax as time goes on.Since your issue is mostly stylistic (not wanting to fill up the constructor with a bunch of declarations) it can be solved stylistically as well.The way I view it, many class based languages have the constructor be a function named after the class name itself. Stylistically we could use that that to make an ES6 class that stylistically still makes sense but does not group the typical actions taking place in the constructor with all the property declarations we\'re doing. We simply use the actual JS constructor as the "declaration area", then make a class named function that we otherwise treat as the "other constructor stuff" area, calling it at the end of the true constructor.Both will be called as the new instance is constructed.Sorta like having 2 constructors where you separate out the declarations and the other constructor actions you want to take, and stylistically makes it not too hard to understand that\'s what is going on too.I find it\'s a nice style to use when dealing with a lot of declarations and/or a lot of actions needing to happen on instantiation and wanting to keep the two ideas distinct from each other.NOTE: I very purposefully do not use the typical idiomatic ideas of "initializing" (like an init() or initialize() method) because those are often used differently. There is a sort of presumed difference between the idea of constructing and initializing. Working with constructors people know that they\'re called automatically as part of instantiation. Seeing an init method many people are going to assume without a second glance that they need to be doing something along the form of var mc = MyClass(); mc.init();, because that\'s how you typically initialize. I\'m not trying to add an initialization process for the user of the class, I\'m trying to add to the construction process of the class itself.While some people may do a double-take for a moment, that\'s actually the bit of the point: it communicates to them that the intent is part of construction, even if that makes them do a bit of a double take and go "that\'s not how ES6 constructors work" and take a second looking at the actual constructor to go "oh, they call it at the bottom, I see", that\'s far better than NOT communicating that intent (or incorrectly communicating it) and probably getting a lot of people using it wrong, trying to initialize it from the outside and junk. That\'s very much intentional to the pattern I suggest.For those that don\'t want to follow that pattern, the exact opposite can work too. Farm the declarations out to another function at the beginning. Maybe name it "properties" or "publicProperties" or something. Then put the rest of the stuff in the normal constructor.Note that this second method may look cleaner but it also has an inherent problem where properties gets overridden as one class using this method extends another. You\'d have to give more unique names to properties to avoid that. My first method does not have this problem because its fake half of the constructor is uniquely named after the class.You can mimic es6 classes behaviour... and use your class variables :)Look mum... no classes!I put it on GitHubCan you avoid the whole issue by using strong literals and a little library of templates logic run contained in a larger closure? ignoring the closure for now http://codepen.io/jfrazz/pen/BQJPBZ/THIS is the simplest example I can offer from repository,  The first 400 lines are a data library+ some basic utility functions. Plus a handful of utility constants.  After the boiler plate, which we are turning into a data uri--downloaded by app users--we have array templates, that have to be lifted and redeployed, but which can be composed to be anything from inputs, dropdowns, or 52 pages of questions and data.  That is this second example: Eat an object, get inputs of various types, all using const as the base variable of library, being constructed.http://codepen.io/jfrazz/pen/rWprVR/Not exactly what you asked, but a clear showing that constant can be pretty dynamic.  The way I solved this, which is another option (if you have jQuery available), was to Define the fields in an old-school object and then extend the class with that object. I also didn\'t want to pepper the constructor with assignments, this appeared to be a neat solution.-- Update Following Bergi\'s comment.No JQuery Version:You still do end up with \'fat\' constructor, but at least its all in one class and assigned in one hit.EDIT #2:\nI\'ve now gone full circle and am now assigning values in the constructor, e.g.Why? Simple really, using the above plus some JSdoc comments, PHPStorm was able to perform code completion on the properties. Assigning all the vars in one hit was nice, but the inability to code complete the properties, imo, isn\'t worth the (almost certainly minuscule) performance benefit.This is a bit hackish combo of static and get  works for meelsewhere used