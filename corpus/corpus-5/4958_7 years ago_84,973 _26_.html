In Git, is there a way to merge all changes from one branch into another, but squash to a single commit at the same time?  I often work on a new feature in a separate branch and will regularly commit/push - mainly for backup or to transfer what I\'m working on to another machine.  Mostly those commits say "Feature xxx WIP" or something redundant.Once that work is finished and I want to merge WIP branch back into master, I\'d like to discard all those intermediate commits, and just a have a single clean commit.Is there an easy way to do this? Alternatively, how about a command that squashes all commits on a branch since the point where it was branched?Another option is git merge --squash <feature branch> then finally do a git commit.From Git merge--squash--no-squash Produce the working tree and index state as if a real merge\n  happened (except for the merge\n  information), but do not actually make\n  a commit or move the HEAD, nor record\n  $GIT_DIR/MERGE_HEAD to cause the next\n  git commit command to create a merge\n  commit. This allows you to create a\n  single commit on top of the current\n  branch whose effect is the same as\n  merging another branch (or more in\n  case of an octopus).Found it!  Merge command has a --squash optionat this point everything is merged, possibly conflicted, but not committed.  So I can now:Try git rebase -i master on your feature branch.  You can then change all but one \'pick\' to \'squash\' to combine the commits.  See squashing commits with rebaseFinally, you can then do the merge from master branch.I wanted to squash all commits in my master into one. I tried this unsuccessfully:So I did this:which worked nicely.git merge --squash <feature branch> is a good option .The "git commit" tells you all feature branch commit message with your choice to keep it . For less commit merge . git merge \ndo x times --git reset HEAD^ --soft\nthen git commit . Risk - deleted files may come back .You can do this with the "rebase" command. Let\'s call the branches "main" and "feature":The rebase command will replay all of the commits on "feature" as one commit with a parent equal to "main".You might want to run git merge main before git rebase main if "main" has changed since "feature" was created (or since the most recent merge). That way, you still have your full history in case you had a merge conflict.After the rebase, you can merge your branch to main, which should result in a fast-forward merge:See the rebase page of Understanding Git Conceptually for a good overview