I\'m getting user reports from my app in the market, delivering the following exception:Apparently it has something to do with a FragmentManager, which I don\'t use. The stacktrace doesn\'t show any of my own classes, so I have no idea where this exception occurs and how to prevent it.For the record: I have a tabhost, and in each tab there is a ActivityGroup switching between Activities.Please check my answer here. Basically I just had to :Don\'t make the call to super() on the saveInstanceState method. This was messing things up...This is a known bug in the support package. If you need to save the instance and add something to your outState Bundle you can use the following:In the end the proper solution was (as seen in the comments) to use :when adding or performing the FragmentTransaction that was causing the Exception.There are many related problems with a similar error message. Check the second line of this particular stack trace. This exception is specifically related to the call to FragmentManagerImpl.popBackStackImmediate.This method call, like popBackStack, will always fail with IllegalArgumentException if the session state has already been saved. Check the source. There is nothing you can do to stop this exception being thrown. Here\'s how I observed the problem:Here\'s what I did to solve it:As it is not possible to avoid the IllegalStateException in the callback, catch & ignore it.This is enough to stop the app from crashing. But now the user will restore the app and see that the button they thought they\'d pressed hasn\'t been pressed at all (they think). The form fragment is still showing!To fix this, when the dialog is created, make some state to indicate the process has started.And save this state in the bundle.Don\'t forget to load it back again in onViewCreatedThen, when resuming, rollback the fragments if submit was previously attempted. This prevents the user from coming back to what seems like an un-submitted form.Check if the activity isFinishing() before showing the fragment and pay attention to commitAllowingStateLoss().Example:Here is a different solution to this problem.Using a private member variable you are able to set the returned data as an intent that can then be processed after super.onResume();Like so:Short And working Solution :Follow Simple StepsStepsStep 1 : Override onSaveInstanceState state in respective fragment. And remove super method from it. Step 2 : Use \nfragmentTransaction.commitAllowingStateLoss( ); instead of  fragmentTransaction.commit( );  while fragment operations. I found a dirty solution for this kind of problem. If you still want to keep your ActivityGroups for whatever reason (I had time limitation reasons), you just implementin your Activity and do some back code in there. even if there is no such Method on older Devices, this Method gets called by newer ones.BEWARE, using transaction.commitAllowingStateLoss() could result in a bad experience for the user. For more information on why this exception is thrown, see this post.I had a similar problem, the scenario was like this:The onCreate method of the activity was like this:The exception was thrown because the when configuration changes (device rotated), the activity is created, the main fragment is retrieved from the history of the fragment manager and at the same time the fragment already has an OLD reference to the destroyed activitychanging the implementation to this solved the problem:you need to set your listeners each time the activity is created to avoid the situation where the fragments have references to old destroyed instances of the activity.Do not use commitAllowingStateLoss(), it should only be used for cases where it is okay for the UI state to change unexpectedly on the user.https://developer.android.com/reference/android/app/FragmentTransaction.html#commitAllowingStateLoss()Instead, use if (fragment.isResume()) check outside the operation you met this IllegalStateException "Can not perform this action after onSaveInstanceState"I was getting this exception when i was pressing back button to cancel intent chooser on my map fragment activity.\nI resolved this by replacing the code of onResume(where i was initializing the fragment) to onstart() and the app is working fine.Hope it helps.I think using transaction.commitAllowingStateLoss(); is not best solution.\nThis exception will be thrown when activity\'s configuration changed and fragment onSavedInstanceState() is called and thereafter your async callback method tries to commit fragment.Simple solution could be check whether activity is changing configuration or note.g. check isChangingConfigurations()i.e.if(!isChangingConfigurations()) {\n    //commit transaction.\n} Checkout this link as wellWhenever you are trying to load a fragment in your activity make sure that activity is in resume and not going to pause state.In pause state you may end up losing commit operation that is done.You can use transaction.commitAllowingStateLoss() instead of transaction.commit() to load fragmentorCreate a boolean and check if activity is not going to onpausethen while loading fragment checkAdd this in your activityStarting from support library version 24.0.0 you can call FragmentTransaction.commitNow() method which commits this transaction synchronously instead of calling commit() followed by executePendingTransactions(). As documentation says this approach even better:Calling commitNow is preferable to calling commit() followed by executePendingTransactions() as the latter will have the side effect of attempting to commit all currently pending transactions whether that is the desired behavior or not.I have also experienced this issue and problem occurs every time when context of your FragmentActivity gets changed (e.g. Screen orientation is changed, etc.). So the best fix for it is to update context from your FragmentActivity.Possibly the smoothest and the simplest solution I found in my case was to avoid popping the offending fragment off the stack in response to activity result. So changing this call in my onActivityResult():to this:helped in my case.The exception is threw here (In FragmentActivity):In FragmentManager.popBackStatckImmediate()\xef\xbc\x8cFragmentManager.checkStateLoss() is called firstly. That\'s the cause of IllegalStateException. See the implementation below:I solve this problem simply by using a flag to mark Activity\'s current status. Here\'s my solution:}Simple and compact solution might be: