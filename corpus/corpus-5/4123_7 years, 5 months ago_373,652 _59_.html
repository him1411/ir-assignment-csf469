We are frequently using the following code pattern in our JavaScript codeIs there a less verbose way of checking that has the same effect?According to some forums and literature saying simply the following should have the same effect.Unfortunately, Firebug evaluates such a statement as error on runtime when some_variable is undefined, whereas the first one is just fine for it. Is this only an (unwanted) behavior of Firebug or is there really some difference between those two ways?You have to differentiate between two cases1) Undefined variables , like \'foo\'. You\'ll get an error if you access an undefined variable in any context other than typeof. So, for variables, the typeof check is a must. On the other side, it\'s only rarely needed - you usually know if your variables are defined or not.2) Undefined properties , like someExistingObj.someUndefProperty. An undefined property doesn\'t yield an error and simply returns "undefined", which, when converted to boolean, evaluates to false. So, if you don\'t care about \'0\' and \'false\', if(obj.undefProp) is ok. There\'s a common idiom based on this fact:which means "if obj has a prop, use that, otherwise default".Some people consider this behavior confusing, arguing that it leads to hard-to-find errors and recommend using in operator insteadI think the most efficient way to test for "value is null or undefined" is So these two lines are equivalent:Note 1As mentioned in the question, the short variant requires that some_variable has been declared, otherwise a ReferenceError will be thrown. However in many use cases you can assume that this is safe:check for optional arguments:check for properties on an existing objectOn the other hand typeof can deal with undeclared global variables (simply returns undefined). Yet these cases should be reduced to a minimum for good reasons, as Alsciende explained.Note 2This - even shorter - variant is not equivalent:soNote 3In general it is recommended to use === instead of ==.\nThe proposed solution is an exception to this rule. The JSHint syntax checker even provides the eqnull option for this reason.From the jQuery style guide:Strict equality checks (===) should be used in favor of ==. The only\n  exception is when checking for undefined and null by way of null.If you try and reference an undeclared variable, an error will be thrown in all JavaScript implementations.Properties of objects aren\'t subject to the same conditions. If an object property hasn\'t been defined, an error won\'t be thrown if you try and access it. So in this situation you could shorten:toWith this in mind, and the fact that global variables are accessible as properties of the global object (window in the case of a browser), you can use the following for global variables:In local scopes, it always useful to make sure variables are declared at the top of your code block, this will save on recurring uses of typeof.Checking null with normal equality will also return true for undefined.if (window.variable == null) alert(\'variable is null or undefined\');In newer JavaScript standards like ES5 and ES6 you can just sayall returns false, which is similar to Python\'s check of empty variables.\nSo if you want to write conditional logic around a variable, just sayhere "null" or "empty string" or "undefined" will be handled efficiently.Firstly you have to be very clear about what you test. JavaScript has all sorts of implicit conversions to trip you up, and two different types of equality comparator: == and ===.A function, test(val) that tests for null or undefined should have the following characteristics:Let\'s see which of the ideas here actually pass our test.These work:These do not work:I created a jsperf entry to compare the correctness and performance of these approaches. Results are inconclusive for the time being as there haven\'t been enough runs across different browsers/platforms. Please take a minute to run the test on your computer!At present, it seems that the simple val == null test gives the best performance. It\'s also pretty much the shortest. The test may be negated to val != null if you want the complement.Since there is no single complete and correct answer, I will try to summarize:In general, the expression:cannot be simplified, because the variable might be undeclared so omitting the typeof(variable) != "undefined" would result in ReferenceError. But, you can simplify the expression according to the context:If the variable is global, you can simplify to:If it is local, you can probably avoid situations when this variable is undeclared, and also simplify to:If it is object property, you don\'t have to worry about ReferenceError:You can just check if the variable has a value or not. Meaning,If you do not know whether a variable exists (that means, if it was declared) you should check with the typeof operator. e.g.As mentioned in one of the answers, you can be in luck if you are talking about a variable that has a global scope. As you might know, the variables that you define globally tend to get added to the windows object. You can take advantage of this fact so lets say you are accessing a variable called bleh, just use the double inverted operator (!!) This would return a false while bleh has not been declared AND assigned a value.Testing nullity (if (value == null)) or non-nullity (if (value != null)) is less verbose than testing the definition status of a variable.Moreover, testing if (value) (or  if( obj.property)) to ensure the existence of your variable (or object property) fails if it is defined with a boolean false value. Caveat emptor :)Both values can be easily distinguished by using the strict comparison operator:Working example at:http://www.thesstech.com/tryme?filename=nullandundefinedSample Code:You must define a function of this form: