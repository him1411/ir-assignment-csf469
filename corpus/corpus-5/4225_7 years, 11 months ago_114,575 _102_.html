I have a repository with branches master and A and lots of merge activity between the two. How can I find the commit in my repository when branch A was created based on master?My repository basically looks like this:I\'m looking for revision A, which is not what git merge-base (--all) finds.I was looking for the same thing, and I found this question.  Thank you for asking it!However, I found that the answers I see here don\'t seem to quite give the answer you asked for (or that I was looking for) -- they seem to give the G commit, instead of the A commit.So, I\'ve created the following tree (letters assigned in chronological order), so I could test things out:This looks a little different than yours, because I wanted to make sure that I got (referring to this graph, not yours) B, but not A (and not D or E).  Here are the letters attached to SHA prefixes and commit messages (my repo can be cloned from here, if that\'s interesting to anyone):So, the goal: find B.  Here are three ways that I found, after a bit of tinkering:You should visually see a tree like this (as viewed from master):or here (as viewed from topic):in both cases, I\'ve selected the commit that is B in my graph.  Once you click on it, its full SHA is presented in a text input field just below the graph.git log --graph --oneline --allwhich shows (assuming git config --global color.ui auto):Or, in straight text:in either case, we see the 6aafd7f commit as the lowest common point, i.e. B in my graph, or A in yours.You don\'t specify in your question whether you wanted something like the above, or a single command that\'ll just get you the one revision, and nothing else.  Well, here\'s the latter:Which you can also put into your ~/.gitconfig as (note: trailing dash is important; thanks Brian for bringing attention to that):Which could be done via the following (convoluted with quoting) command-line:Note: zsh could just as easily have been bash, but sh will not work -- the <() syntax doesn\'t exist in vanilla sh.  (Thank you again, @conny, for making me aware of it in a comment on another answer on this page!)Thanks to liori for pointing out that the above could fall down when comparing identical branches, and coming up with an alternate diff form which removes the sed form from the mix, and makes this "safer" (i.e. it returns a result (namely, the most recent commit) even when you compare master to master):As a .git-config line:From the shell:So, in my test tree (which was unavailable for a while, sorry; it\'s back), that now works on both master and topic (giving commits G and B, respectively).  Thanks again, liori, for the alternate form.So, that\'s what I [and liori] came up with.  It seems to work for me.  It also allows an additional couple of aliases that might prove handy:Happy git-ing!You may be looking for git merge-base:git merge-base finds best common ancestor(s) between two commits to use in a three-way merge. One common ancestor is better than another common ancestor if the latter is an ancestor of the former. A common ancestor that does not have any better common ancestor is a best common ancestor, i.e. a merge base. Note that there can be more than one merge base for a pair of commits.I\'ve used git rev-list for this sort of thing. For example, (note the 3 dots)will spit out the branch point. Now, it\'s not perfect; since you\'ve merged master into branch A a couple of times, that\'ll split out a couple possible branch points (basically, the original branch point and then each point at which you merged master into branch A). However, it should at least narrow down the possibilities.I\'ve added that command to my aliases in ~/.gitconfig as:so I can call it as:If you like terse commands,Here\'s an explanation.The following command gives you the list of all commits in master that occurred after branch_name was createdSince you only care about the earliest of those commits you want the last line of the output:The parent of the earliest commit that\'s not an ancestor of "branch_name" is, by definition, in "branch_name," and is in "master" since it\'s an ancestor of something in "master." So you\'ve got the earliest commit that\'s in both branches.The commandis just a way to show the parent commit reference. You could useor whatever.PS: I disagree with the argument that ancestor order is irrelevant. It depends on what you want. For example, in this caseit makes perfect sense to output C2 as the "branching" commit. This is when the developer branched out from "master." When he branched, branch "B" wasn\'t even merged in his branch! This is what the solution in this post gives.If what you want is the last commit C such that all paths from origin to the last commit on branch "A" go through C, then you want to ignore ancestry order. That\'s purely topological and gives you an idea of since when you have two versions of the code going at the same time. That\'s when you\'d go with merge-base based approaches, and it will return C1 in my example.Given that so many of the answers in this thread do not give the answer the question was asking for, here is a summary of the results of each solution, along with the script I used to replicate the repository given in the question.Creating a repository with the structure given, we get the git log of:My only addition, is the tag which makes it explicit about the point at which we created the branch and thus the commit we wish to find.The only solution which works is the one provided by lindes correctly returns A:As Charles Bailey points out though, this solution is very brittle.If you branch_A into master and then merge master into branch_A without intervening commits then lindes\' solution only gives you the most recent first divergance. That means that for my workflow, I think I\'m going to have to stick with tagging the branch point of long running branches, since I can\'t guarantee that they can be reliably be found later.This really all boils down to gits lack of what hg calls named branches. The blogger jhw calls these lineages vs. families in his article Why I Like Mercurial More Than Git and his follow-up article More On Mercurial vs. Git (with Graphs!). I would recommend people read them to see why some mercurial converts miss not having named branches in git.The solution provided by mipadi returns two answers, I and C:The solution provided by Greg Hewgill return IThe solution provided by Karl returns X:I doubt the git version makes much difference to this, but:Thanks to Charles Bailey for showing me a more compact way to script the example repository.In general, this is not possible. In a branch history a branch-and-merge before a named branch was branched off and an intermediate branch of two named branches look the same.In git, branches are just the current names of the tips of sections of history. They don\'t really have a strong identity.This isn\'t usually a big issue as the merge-base (see Greg Hewgill\'s answer) of two commits is usually much more useful, giving the most recent commit which the two branches shared.A solution relying on the order of parents of a commit obviously won\'t work in situations where a branch has been fully integrated at some point in the branch\'s history.This technique also falls down if an integration merge has been made with the parents reversed (e.g. a temporary branch was used to perform a test merge into master and then fast-forwarded into the feature branch to build on further).How about something like I recently needed to solve this problem as well and ended up writing a Ruby script for this: https://github.com/vaneyckt/git-find-branching-pointsurely I\'m missing something, but IMO, all the problems above are caused because we are always trying to find the branch point going back in the history, and that causes all sort of problems because of the merging combinations available.Instead, I\'ve followed a different approach, based in the fact that both branches share a lot of history, exactly all the history before branching is 100% the same, so instead of going back, my proposal is about going forward (from 1st commit), looking for the 1st difference in both branches. The branch point will be, simply, the parent of the first difference found.In practice:And it\'s solving all my usual cases. Sure there are border ones not covered but... ciao :-)Here\'s an improved version of my previous answer previous answer. It relies on the commit messages from merges to find where the branch was first created.It works on all the repositories mentioned here, and I\'ve even addressed some tricky ones that spawned on the mailing list. I also wrote tests for this.After a lot of research and discussions, it\'s clear there\'s no magic bullet that would work in all situations, at least not in the current version of Git.That\'s why I wrote a couple of patches that add the concept of a tail branch. Each time a branch is created, a pointer to the original point is created too, the tail ref. This ref gets updated every time the branch is rebased.To find out the branch point of the devel branch, all you have to do is use devel@{tail}, that\'s it.https://github.com/felipec/git/commits/fc/tailTo find commits from the branching point, you could use this.The following command will reveal the SHA1 of Commit Agit merge-base --fork-point AI seem to be getting some joy withThe last line you get is the first commit on the branch, so then it\'s a matter of getting the parent of that. SoSeems to work for me and doesn\'t need diffs and so on (which is helpful as we don\'t have that version of diff)Correction: This doesn\'t work if you are on the master branch, but I\'m doing this in a script so that\'s less of an issueThe problem appears to be to find the most recent, single-commit cut between both branches on one side, and the earliest common ancestor on the other (probably the initial commit of the repo). This matches my intuition of what the "branching off" point is.That in mind, this is not at all easy to compute with normal git shell commands, since git rev-list -- our most powerful tool -- doesn\'t let us restrict the path by which a commit is reached.  The closest we have is git rev-list --boundary, which can give us a set of all the commits that "blocked our way". (Note: git rev-list --ancestry-path is interesting but I don\'t how to make it useful here.)Here is the script: https://gist.github.com/abortz/d464c88923c520b79e3d. It\'s relatively simple, but due to a loop it\'s complicated enough to warrant a gist.Note that most other solutions proposed here can\'t possibly work in all situations for a simple reason: git rev-list --first-parent isn\'t reliable in linearizing history because there can be merges with either ordering.git rev-list --topo-order, on the other hand, is very useful -- for walking commits in topographic order -- but doing diffs is brittle: there are multiple possible topographic orderings for a given graph, so you are depending on a certain stability of the orderings. That said, strongk7\'s solution probably works damn well most of the time. However it\'s slower that mine as a result of having to walk the entire history of the repo... twice. :-)The following implements git equivalent of svn log --stop-on-copy and can also be used to find branch origin.ApproachLike all rivers run to the sea, all branches run to master and therefore we find merge-base between seemingly unrelated branches.  As we walk back from branch head through ancestors, we can stop at the first potential merge base since in theory it should be origin point of this branch.Notesdetails: https://stackoverflow.com/a/35353202/9950 You could use the following command to return the oldest commit in branch_a, which is not reachable from master:Perhaps with an additional sanity check that the parent of that commit is actually reachable from master...You can examine the reflog of branch A to find from which commit it was created, as well as the full history of which commits that branch pointed to. Reflogs are in .git/logs.I believe I\'ve found a way that deals with all the corner-cases mentioned here:Charles Bailey is quite right that solutions based on the order of ancestors have only limited value; at the end of the day you need some sort of record of "this commit came from branch X", but such record already exists; by default \'git merge\' would use a commit message such as "Merge branch \'branch_A\' into master", this tells you that all the commits from the second parent (commit^2) came from \'branch_A\' and was merged to the first parent (commit^1), which is \'master\'.Armed with this information you can find the first merge of \'branch_A\' (which is when \'branch_A\' really came into existence), and find the merge-base, which would be the branch point :)I\'ve tried with the repositories of Mark Booth and Charles Bailey and the solution works; how couldn\'t it? The only way this wouldn\'t work is if you have manually changed the default commit message for merges so that the branch information is truly lost.For usefulness:Then you can do \'git branch-point branch_A\'.Enjoy ;)