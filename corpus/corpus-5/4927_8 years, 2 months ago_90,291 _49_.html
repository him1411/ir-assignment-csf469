An application I\'ve been working with is failing when I try to serialize types.A statement likeproduces:I don\'t define any special serializers for my class.How can I fix this problem?Believe it or not, this is normal behaviour. An exception is thrown but handled by the XmlSerializer, so if you just ignore it everything should continue on fine.I have found this very anoying, and there have been many complaints about this if you search around a bit, but from what I\'ve read Microsoft don\'t plan on doing anything about it.You can avoid getting Exception popups all the time while debugging if you switch off first chance exceptions for that specific exception. In Visual Studio, go to Debug -> Exceptions (or press Ctrl + Alt + E), Common Language Runtime Exceptions -> System.IO -> System.IO.FileNotFoundException.You can find information about another way around it in the blog post C# XmlSerializer FileNotFound exception (Chris Sells\' tool XmlSerializerPreCompiler).Like Martin Sherburn said, this is normal behavior. The constructor of the XmlSerializer first tries to find an assembly named [YourAssembly].XmlSerializers.dll which should contain the generated class for serialization of your type. Since such a DLL has not been generated yet (they are not by default), a FileNotFoundException is thrown. When that happenes, XmlSerializer\'s constructor catches that exception, and the DLL is generated automatically at runtime by the XmlSerializer\'s constructor (this is done by generating C# source files in the %temp% directory of your computer, then compiling them using the C# compiler). Additional constructions of an XmlSerializer for the same type will just use the already generated DLL.UPDATE: Starting from .NET 4.5, XmlSerializer no longer performs code generation nor does it perform compilation with the C# compiler in order to create a serializer assembly at runtime, unless explicitly forced to by setting a configuration file setting (useLegacySerializerGeneration). This change removes the dependency on csc.exe and improves startup performance. Source: .NET Framework 4.5 Readme, section 1.3.8.1.The exception is handled by XmlSerializer\'s constructor. There is no need to do anything yourself, you can just click \'Continue\' (F5) to continue executing your program and everything will be fine. If you\'re bothered by the exceptions stopping the execution of your program and popping up an exception helper, you either have \'Just My Code\' turned off, or you have the FileNotFoundException set to break execution when thrown, instead of when \'User-unhandled\'.To enable \'Just My Code\', go to Tools >> Options >> Debugging >> General >> Enable Just My Code. To turn off breaking of execution when FileNotFound is thrown, go to Debug >> Exceptions >> Find >> enter \'FileNotFoundException\' >> untick the \'Thrown\' checkbox from System.IO.FileNotFoundException.In Visual Studio project properties ("Build" page, if I recall it right) there is an option saying "generate serialization assembly". Try turning it on for a project that generates [Containing Assembly of MyType].There is a workaround for that. If you useit should avoid that exception. This worked for me.WARNING: Do not use multiple times, or you will have a memory leakYou will leak memory like crazy if you use this method to create instances of XmlSerializer for the same type more than once! This is because this method bypasses the built-in caching provided the XmlSerializer(type) and XmlSerializer(type, defaultNameSpace) constructors (all other constructors also bypass the cache). If you use any method to create an XmlSerializer that is not via these two constructors, you must implement your own caching or you\'ll hemorrhage memory. To avoid the exception you need to do two things:Add the System.Xml.Serialization.XmlSerializerAssembly attribute to your class.\nReplace \'MyAssembly\' with the name of the assembly where MyClass is in.Generate the serialization file using the sgen.exe utility and deploy it with the class\xe2\x80\x99s assembly.\xe2\x80\x98sgen.exe MyAssembly.dll\xe2\x80\x99 will generate the file MyAssembly.XmlSerializers.dllThese two changes will cause the .net to directly find the assembly.\nI checked it and it works on .NET framework 3.5 with Visual Studio 2008My solution is to go straight to reflection to create the serializer. This bypasses the strange file loading that causes the exception. I packaged this in a helper function that also takes care of caching the serializer.This exception can also be trapped by a managed debugging assistant (MDA) called BindingFailure.  This MDA is useful if your application is designed to ship with pre-build serialization assemblies. We do this to increase performance for our application. It allows us to make sure that the pre-built serialization assemblies are being properly built by our build process, and loaded by the application without being re-built on the fly.It\'s really not useful except in this scenario, because as other posters have said, when a binding error is trapped by the Serializer constructor, the serialization assembly is re-built at runtime. So you can usually turn it off.I ran into this exact issue and couldn\'t get around it by any of the solutions mentioned.Then I finally found a solution.\nIt appears that the serializer needs not only the type, but the nested types as well.\nChanging this:\nXmlSerializer xmlSerializer = new XmlSerializer(typeof(T));\nTo this:\nXmlSerializer xmlSerializer = new XmlSerializer(typeof(T).GetNestedTypes());\nFixed the issue for me. \nNo more exceptions or anything.Function XmlSerializer.FromTypes does not throw the exception, but it leaks the memory. Thats why you need to cache such serializer for every type to avoid memory leaking for every instance created.Create your own XmlSerializer factory and use it simply:The factory looks likes:Troubleshooting compilation errors on the other hand is very complicated. These problems manifest themselves in a FileNotFoundException with the message:You may wonder what a file not found exception has to do with instantiating a serializer object, but remember: the constructor writes C# files and tries to compile them. The call stack of this exception provides some good information to support that suspicion. The exception occurred while the XmlSerializer attempted to load an assembly generated by CodeDOM calling the System.Reflection.Assembly.Load method. The exception does not provide an explanation as to why the assembly that the XmlSerializer was supposed to create was not present. In general, the assembly is not present because the compilation failed, which may happen because, under rare circumstances, the serialization attributes produce code that the C# compiler fails to compile.Note\nThis error also occurs when the XmlSerializer runs under an account or a security environment that is not able to access the temp directory.Source:\nhttp://msdn.microsoft.com/en-us/library/aa302290.aspxIn Visual Studio project properties there is an option saying "generate serialization assembly". Try turning it on for a project that generates [Containing Assembly of MyType].A custom class to serialise:I have attached the code snippet. Maybe this can help you out.I was having a similar problem, and ignoring the exception did not work for me. My code was calling NServiceBus\' configuration Configure.With(...).XmlSerializer()...What fixed it for me was to change the platform for my project.Your type may reference other assemblies which cannot be found neither in the GAC nor in your local bin folder ==> ... "or one of its dependencies. The system\n  cannot find the file specified"Can you give an example of the type you want to serialize?Note: Ensure that your type implements Serializable.I was getting the same error, and it was due to the type I was trying to deserialize not having a default parameterless constructor. I added a constructor, and it started working.I had the same problem until I used a 3rd Party tool to generate the Class from the XSD and it worked!  I discovered that the tool was adding some extra code at the top of my class.  When I added this same code to the top of my original class it worked.  Here\'s what I added...