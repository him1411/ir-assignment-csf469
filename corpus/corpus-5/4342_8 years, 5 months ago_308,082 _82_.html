My Java standalone application gets a URL (which points to a file) from the user and I need to hit it and download it. The problem I am facing is that I am not able to encode the HTTP URL address properly...Example: returns me:But, what I want is(space replaced by %20)I guess URLEncoder is not designed to encode HTTP URLs... The JavaDoc says "Utility class for HTML form encoding"... Is there any other way to do this?The java.net.URI class can help; in the documentation of URL you findNote, the URI class does perform escaping of its component fields in certain circumstances. The recommended way to manage the encoding and decoding of URLs is to use an URIUse one of the constructors with more than one argument, like:(the single-argument constructor of URI does NOT escape illegal characters) EDIT: added fully qualified class name to avoid confusion with other URI classes (like apaches httpclient)EDIT 2:\nOnly illegal characters get escaped by above code - it does NOT escape non-ASCII characters (see fatih\'s comment).\nThe toASCIIString method can be used to get a String only with US-ASCII characters:  EDIT 3:\nFor an URL with a query like http://www.google.com/ig/api?weather=S\xc3\xa3o Paulo, use the 5-parameter version of the constructor:  Please be warned that most of the answers above are INCORRECT.The URLEncoder class, despite is name, is NOT what needs to be here.  It\'s unfortunate that Sun named this class so annoyingly.  URLEncoder is meant for passing data as parameters, not for encoding the URL itself.In other words, "http://search.barnesandnoble.com/booksearch/first book.pdf" is the URL. Parameters would be, for example, "http://search.barnesandnoble.com/booksearch/first book.pdf?parameter1=this&param2=that".  The parameters are what you would use URLEncoder for.The following two examples highlights the differences between the two.The following produces the wrong parameters, according to the HTTP standard. Note the ampersand (&) and plus (+) are encoded incorrectly.The following will produce the correct parameters, with the query properly encoded. Note the spaces, ampersands, and plus marks.-MattI\'m going to add one suggestion here aimed at Android users.  You can do this which avoids having to get any external libraries.  Also, all the search/replace characters solutions suggested in some of the answers above are perilous and should be avoided.  Give this a try:You can see that in this particular URL, I need to have those spaces encoded so that I can use it for a request.  This takes advantage of a couple features available to you in Android classes.  First, the URL class can break a url into its proper components so there is no need for you to do any string search/replace work.  Secondly, this approach takes advantage of the URI class feature of properly escaping components when you construct a URI via components rather than from a single string.The beauty of this approach is that you can take any valid url string and have it work without needing any special knowledge of it yourself.  a solution i developed and much more stable than any other:If you have a URL, you can pass url.toString() into this method.  First decode, to avoid double encoding (for example, encoding a space results in %20 and encoding a percent sign results in %25, so double encoding will turn a space into %2520).  Then, use the URI as explained above, adding in all the parts of the URL (so that you don\'t drop the query parameters).Yeah URL encoding is going to encode that string so that it would be passed properly in a url to a final destination.  For example you could not have http://stackoverflow.com?url=http://yyy.com.  UrlEncoding the parameter would fix that parameter value.So i have two choices for you:Do you have access to the path separate from the domain?  If so you may be able to simply UrlEncode the path. However, if this is not the case then option 2 may be for you.Get commons-httpclient-3.1.  This has a class URIUtil:System.out.println(URIUtil.encodePath("http://example.com/x y", "ISO-8859-1"));This will output exactly what you are looking for, as it will only encode the path part of the URI.FYI, you\'ll need commons-codec and commons-logging for this method to work at runtime.Nitpicking: a string containing a whitespace character by definition is not a URI. So what you\'re looking for is code that implements the URI escaping defined in Section 2.1 of RFC 3986.Unfortunately, org.apache.commons.httpclient.util.URIUtil is deprecated, and the replacement org.apache.commons.codec.net.URLCodec does coding suitable for form posts, not in actual URL\'s. So I had to write my own function, which does a single component (not suitable for entire query strings that have ?\'s and &\'s)URLEncoding can encode HTTP URLs just fine, as you\'ve unfortunately discovered.  The string you passed in, "http://search.barnesandnoble.com/booksearch/first book.pdf", was correctly and completely encoded into a URL-encoded form.  You could pass that entire long string of gobbledigook that you got back as a parameter in a URL, and it could be decoded back into exactly the string you passed in.It sounds like you want to do something a little different than passing the entire URL as a parameter.  From what I gather, you\'re trying to create a search URL that looks like "http://search.barnesandnoble.com/booksearch/whateverTheUserPassesIn".  The only thing that you need to encode is the "whateverTheUserPassesIn" bit, so perhaps all you need to do is something like this:That should produce something rather more valid for you.There is still a problem if you have got an encoded "/" (%2F) in your URL.RFC 3986 - Section 2.2 says: "If data for a URI component would conflict with a reserved character\'s purpose as a delimiter, then the conflicting data must be percent-encoded before the URI is formed." (RFC 3986 - Section 2.2)But there is an Issue with Tomcat: http://tomcat.apache.org/security-6.html - Fixed in Apache Tomcat 6.0.10important: Directory traversal CVE-2007-0450Tomcat permits \'\\\', \'%2F\' and \'%5C\'\n  [...] . The following Java system properties\n  have been added to Tomcat to provide\n  additional control of the handling of\n  path delimiters in URLs (both options\n  default to false):Due to the impossibility to guarantee\n  that all URLs are handled by Tomcat as\n  they are in proxy servers, Tomcat\n  should always be secured as if no\n  proxy restricting context access was\n  used.Affects: 6.0.0-6.0.9So if you have got an URL with the %2F character, Tomcat returns: "400 Invalid URI: noSlash"You can switch of the bugfix in the Tomcat startup script:I read the previous answers to write my own method because I could not have something properly working using the solution of the previous answers, it looks good for me but if you can find URL that does not work with this, please let me know.I agree with Matt. Indeed, I\'ve never seen it well explained in tutorials, but one matter is how to encode the URL path, and a very different one is how to encode the parameters which are appended to the URL (the query part, behind the "?" symbol). They use similar encoding, but not the same.Specially for the encoding of the white space character. The URL path needs it to be encoded as %20, whereas the query part allows %20 and also the "+" sign. The best idea is to test it by ourselves against our Web server, using a Web browser.For both cases, I ALWAYS would encode COMPONENT BY COMPONENT, never the whole string. Indeed URLEncoder allows that for the query part. For the path part you can use the class URI, although in this case it asks for the entire string, not a single component.Anyway, I believe that the best way to avoid these problems is to use a personal non-conflictive design. How? For example, I never would name directories or parameters using other characters than a-Z, A-Z, 0-9 and _ . That way, the only need is to encode the value of every parameter, since it may come from an user input and the used characters are unknown.If anybody doesn\'t want to add a dependency to their project, these functions may be helpful.We pass the \'path\' part of our URL into here.  You probably don\'t want to pass the full URL in as a parameter (query strings need different escapes, etc).And tests:In addition to the Carlos Heuberger\'s reply:\nif a different than the default (80) is needed, the 7 param constructor should be used:Maybe can try UriUtils in org.springframework.web.utilYou can also use GUAVA and path escaper:\nUrlEscapers.urlFragmentEscaper().escape(relativePath)I had the same problem. Solved this by unsing: It encodes the string but skips ":" and "/".I\'ve created a new project to help construct HTTP URLs. The library will automatically URL encode path segments and query parameters.You can view the source and download a binary at https://github.com/Widen/urlbuilderThe example URL in this question:produceshttp://search.barnesandnoble.com/booksearch/first%20book.pdfI develop a library that serves this purpose: galimatias. It parses URL the same way web browsers do. That is, if a URL works in a browser, it will be correctly parsed by galimatias.In this case:Will give you: http://search.barnesandnoble.com/booksearch/first%20book.pdf. Of course this is the simplest case, but it\'ll work with anything, way beyond java.net.URI.You can check it out at: https://github.com/smola/galimatiasYou can use a function like this. Complete and modify it to your need :Example of use :The result is : http://www.growup.com/folder/int%C3%A9rieur-%C3%A0_vendre?o=4String url=""http://search.barnesandnoble.com/booksearch/;This will be constant i guess and only filename changes dyamically so get filenameString filename;\n// get the file nameString urlEnc=url+fileName.replace(" ","%20");How about:public String UrlEncode(String in_) {}