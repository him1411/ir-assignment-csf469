When I do git fetch origin and origin has a deleted branch, it doesn\'t seem to update it in my repository. When I do git branch -r it still shows origin/DELETED_BRANCH.How can I fix this?You need to do the followingThis will update the local database of remote branches.From http://www.gitguys.com/topics/adding-and-removing-remote-branches/After someone deletes a branch from a remote repository, git will not\n  automatically delete  the local repository branches when a user does a\n  git pull or git fetch. However, if the user would like to have all\n  tracking branches removed from their local repository that have been\n  deleted in a remote repository, they can type:git remote prune originAs a note, the -p param from git fetch -p actually means "prune". \nEither way you chose, the non-existing remote branches will be deleted from your local repository.You need to do the followingin order to synchronize your branch list. The git manual says-p, --prune\n  After fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning.I personally like to use git fetch origin -p --progress because it shows a progress indicator.This worked for me.Regarding git fetch -p, its behavior changed in Git 1.9, and only Git 2.9.x/2.10 reflects that.See commit 9e70233 (13 Jun 2016) by Jeff King (peff).\n(Merged by Junio C Hamano -- gitster -- in commit 1c22105, 06 Jul 2016) This was changed in 10a6cc8 (fetch --prune: Run prune before fetching, 2014-01-02), but it seems that nobody in that discussion realized we were advertising the "after" explicitly.So the documentation now states:Before fetching, remove any remote-tracking references that no longer exist on the remoteThat is because:When we have a remote-tracking branch named "frotz/nitfol" from a previous fetch, and the upstream now has a branch named "frotz", fetch would fail to remove "frotz/nitfol" with a "git fetch --prune" from the upstream. git would inform the user to use "git remote prune" to fix the problem.Change the way "fetch --prune" works by moving the pruning operation before the fetching operation. This way, instead of warning the user of a conflict, it automatically fixes it.Here is how you update repo info