I have data in different columns but I don\'t know how to extract it to save it in another variable.How do I select \'b\', \'c\' and save it in to df1?I tried None seem to work. Any ideas would help thanks.The column names (which are strings) cannot be sliced in the manner you tried.Here you have a couple of options. If you know from context which variables you want to slice out, you can just return a view of only those columns by passing a list into the __getitem__ syntax (the []\'s).Alternatively, if it matters to index them numerically and not by their name (say your code should automatically do this without knowing the names of the first two columns) then you can do this instead:Additionally, you should familiarize yourself with the idea of a view into a Pandas object vs. a copy of that object. The first of the above methods will return a new copy in memory of the desired sub-object (the desired slices). Sometimes, however, there are indexing conventions in Pandas that don\'t do this and instead give you a new variable that just refers to the same chunk of memory as the sub-object or slice in the original object. This will happen with the second way of indexing, so you can modify it with the copy() function to get a regular copy. When this happens, changing what you think is the sliced object can sometimes alter the original object. Always good to be on the look out for this.Assuming your column names (df.columns) are [\'index\',\'a\',\'b\',\'c\'], then the data you want is in the \n3rd & 4th columns. If you don\'t know their names when your script runs, you can do thisAs EMS points out in his answer, df.ix slices columns a bit more concisely, but the .columns slicing interface might be more natural because it uses the vanilla 1-D python list indexing/slicing syntax.WARN: \'index\' is a bad name for a DataFrame column. That same label is also used for the real df.index attribute, a Index array. So your column is returned by df[\'index\'] and the real DataFrame index is returned by df.index. An Index is a special kind of Series optimized for lookup of it\'s elements\' values. For df.index it\'s for looking up rows by their label. That df.columns attribute is also a pd.Index array, for looking up columns by their labels.As of version 0.11.0, columns can be sliced in the manner you tried using the .loc indexer: returns columns C through E.A demo on a randomly generated DataFrame:To get the columns from C to E (note that unlike integer slicing, \'E\' is included in the columns):Same works for selecting rows based on labels. Get the rows \'R6\' to \'R10\' from those columns:.loc also accepts a boolean array so you can select the columns whose corresponding entry in the array is True. For example, df.columns.isin(list(\'BCD\')) returns array([False,  True,  True,  True, False, False], dtype=bool) - True if the column name is in the list [\'B\', \'C\', \'D\']; False, otherwise.I realize this question is quite old, but in the latest version of pandas there is an easy way to do exactly this. Column names (which are strings) can be sliced in whatever manner you like.You could provide a list of columns to be dropped and return back the DataFrame with only the columns needed using the drop() function on a Pandas DataFrame.Just sayingwould return a DataFrame with just the columns b and c.The drop method is documented here.I found this method to be very useful:surveys_df.iloc [0:3, 1:4]More details can be found here