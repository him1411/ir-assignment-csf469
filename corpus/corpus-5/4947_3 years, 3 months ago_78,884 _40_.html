In WWDC 2014 session 403 Intermediate Swift and transcript, there was the following slideThe speaker said in that case, if we don\'t use [unowned self] there, it will be a memory leak. Does it mean we should always use [unowned self] inside closure? On line 64 of ViewController.swift of the Swift Weather app, I don\'t use [unowned self]. But I update the UI by using some @IBOutlets like self.temperature and self.loadingIndicator. It may be OK because all @IBOutlets I defined are weak. But for safety, should we always use [unowned self]?No, there are definitely times where you would not want to use [unowned self]. Sometimes you want the closure to capture self in order to make sure that it is still around by the time the closure is called.If you are making an asynchronous network request you do want the closure to retain self for when the request finishes. That object may have otherwise been deallocated but you still want to be able to handle the request finishing.The only time where you really want to use [unowned self] or [weak self] is when you would create a strong reference cycle. A strong reference cycle is when there is a loop of ownership where objects end up owning each other (maybe through a third party) and therefore they will never be deallocated because they are both ensuring that each other stick around.In the specific case of a closure, you just need to realize that any variable that is referenced inside of it, gets "owned" by the closure. As long as the closure is around, those objects are guaranteed to be around. The only way to stop that ownership, is to do the [unowned self] or [weak self]. So if a class owns a closure, and that closure captures a strong reference to that class, then you have a strong reference cycle between the closure and the class. This also includes if the class owns something that owns the closure.In the example on the slide, TempNotifier owns the closure through the onChange member variable. If they did not declare self as unowned, the closure would also own self creating a strong reference cycle.The difference between unowned and weak is that weak is declared as an Optional while unowned is not. By declaring it weak you get to handle the case that it might be nil inside the closure at some point. If you try to access an unowned variable that happens to be nil, it will crash the whole program. So only use unowned when you are positive that variable will always be around while the closure is aroundI wrote an article on this extending this answer (looking into SIL to understand what ARC does), check it out here.The previous answers don\'t really give straightforward rules on when to use one over the other and why, so let me add a few things.The unowned or weak discussion boils down to a question of lifetime of the variable and the closure that references it.You can have two possible scenarios:The closure have the same lifetime of the variable, so the closure will be reachable only until the variable is reachable. The variable and the closure have the same lifetime. In this case you should declare the reference as unowned. A common example is the [unowned self] used in many example of small closures that do something in the context of their parent and that not being referenced anywhere else do not outlive their parents.The closure lifetime is independent from the one of the variable, the closure could still be referenced when the variable is not reachable anymore. In this case you should declare the reference as weak and verify it\'s not nil before using it (don\'t force unwrap). A common example of this is the [weak delegate] you can see in some examples of closure referencing a completely unrelated (lifetime-wise) delegate object.So, which will/should you actually use most of the times?Quoting Joe Groff from twitter:Unowned is faster and allows for immutability and nonoptionality.If you don\'t need weak, don\'t use it.You\'ll find more about unowned* inner workings here.* Usually also referred to as unowned(safe) to indicate that runtime checks (that lead to a crash for invalid references) are performed before accessing the unowned reference.If self could be nil in the closure use [weak self].If self will never be nil in the closure use [unowned self].The Apple Swift documentation has a great section with images explaining the difference between using strong, weak, and unowned in closures:https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.htmlHere is brilliant quotes from Apple Developer Forums described delicious details:unowned(safe) is a non-owning reference that asserts on access that\n  the object is still alive. It\'s sort of like a weak optional reference\n  that\'s implicitly unwrapped with x! every time it\'s accessed.\n  unowned(unsafe) is like __unsafe_unretained in ARC\xe2\x80\x94it\'s a non-owning\n  reference, but there\'s no runtime check that the object is still alive\n  on access, so dangling references will reach into garbage memory.\n  unowned is always a synonym for unowned(safe) currently, but the\n  intent is that it will be optimized to unowned(unsafe) in -Ofast\n  builds when runtime checks are disabled.unowned actually uses a much simpler implementation than weak.\n  Native Swift objects carry two reference counts, and unowned\n  references bump the unowned reference count instead of the strong\n  reference count. The object is deinitialized when its strong reference\n  count reaches zero, but it isn\'t actually deallocated until the\n  unowned reference count also hits zero. This causes the memory to be\n  held onto slightly longer when there are unowned references, but that\n  isn\'t usually a problem when unowned is used because the related\n  objects should have near-equal lifetimes anyway, and it\'s much simpler\n  and lower-overhead than the side-table based implementation used for\n  zeroing weak references.Update: In modern Swift weak internally uses the same mechanism as unowned does. So this comparison is incorrect because it compares Objective-C weak with Swift unonwed.What is the purpose of keeping the memory alive after owning references reach 0? What happens if code attempts to do something with\n  the object using an unowned reference after it is deinitialized?The\n  memory is kept alive so that its retain counts are still available.\n  This way, when someone attempts to retain a strong reference to the\n  unowned object, the runtime can check that the strong reference count\n  is greater than zero in order to ensure that it is safe to retain the\n  object.What happens to owning or unowned references held by the object?  Is their lifetime decoupled from the object when it is deinitialized or\n  is their memory also retained until the object is deallocated after\n  the last unowned reference is released?All resources owned by the object are released as soon as the object\'s\n  last strong reference is released, and its deinit is run. Unowned\n  references only keep the memory alive\xe2\x80\x94aside from the header with the\n  reference counts, its contents is junk.Excited, huh?According to Apple-doc Weak references are always of an optional type, and automatically\n  become nil when the instance they reference is deallocated.If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak referenceExample - 