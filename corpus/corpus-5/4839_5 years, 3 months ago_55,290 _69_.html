I\'m fairly familiar with the new standard library\'s std::thread, std::async and std::future components (e.g. see this answer), which are straight-forward.However, I cannot quite grasp what std::promise is, what it does and in which situations it is best used. The standard document itself doesn\'t contain a whole lot of information beyond its class synopsis, and neither does just::thread.Could someone please give a brief, succinct example of a situation where an std::promise is needed and where it is the most idiomatic solution?In the words of [futures.state] a std::future is an asynchronous return object ("an object that reads results from a shared state") and a std::promise is an asynchronous provider ("an object that provides a result to a shared state") i.e. a promise is the thing that you set a result on, so that you can get it from the associated future.The asynchronous provider is what initially creates the shared state that a future refers to. std::promise is one type of asynchronous provider, std::packaged_task is another, and the internal detail of std::async is another.  Each of those can create a shared state and give you a std::future that shares that state, and can make the state ready.std::async is a higher-level convenience utility that gives you an asynchronous result object and internally takes care of creating the asynchronous provider and making the shared state ready when the task completes. You could emulate it with a std::packaged_task (or std::bind and a std::promise) and a std::thread but it\'s safer and easier to use std::async.std::promise is a bit lower-level, for when you want to pass an asynchronous result to the future, but the code that makes the result ready cannot be wrapped up in a single function suitable for passing to std::async.  For example, you might have an array of several promises and associated futures and have a single thread which does several calculations and sets a result on each promise. async would only allow you to return a single result, to return several you would need to call async several times, which might waste resources.I understand the situation a bit better now (in no small amount due to the answers here!), so I thought I add a little write-up of my own.There are two distinct, though related, concepts in C++11: Asynchronous computation (a function that is called somewhere else), and concurrent execution (a thread, something that does work concurrently). The two are somewhat orthogonal concepts. Asynchronous computation is just a different flavour of func­tion call, while a thread is an execution context. Threads are useful in their own right, but for the pur­pose of this discussion, I will treat them as an implementation detail.There is a hierarchy of abstraction for asynchronous computation. For example\'s sake, suppose we have a function that takes some arguments:First off, we have the template std::future<T>, which represents a future value of type T. The val­ue can be retrieved via the member function get(), which effectively synchronizes the program by wait­ing for the result. Alternatively, a future supports wait_for(), which can be used to probe whether or not the result is already available. Futures should be thought of as the asynchronous drop-in re­place­ment for ordinary return types. For our example function, we expect a std::future<int>.Now, on to the hierarchy, from highest to lowest level:std::async: The most convenient and straight-forward way to perform an asynchronous com­pu­ta­tion is via the async function template, which returns the matching future immediately:We have very little control over the details. In particular, we don\'t even know if the function is exe­cu­ted concurrently, serially upon get(), or by some other black magic. However, the result is easily ob­tained when needed:We can now consider how to implement something like async, but in a fashion that we control. For example, we may insist that the function be executed in a separate thread. We already know that we can provide a separate thread by means of the std::thread class.The next lower level of abstraction does exactly that: std::packaged_task. This is a template that wraps a function and provides a future for the functions return value, but the object itself is call­able, and calling it is at the user\'s discretion. We can set it up like this:The future becomes ready once we call the task and the call completes. This is the ideal job for a se­pa­rate thread. We just have to make sure to move the task into the thread:The thread starts running immediately. We can either detach it, or have join it at the end of the scope, or whenever (e.g. using Anthony Williams\'s scoped_thread wrapper, which really should be in the standard library). The details of using std::thread don\'t concern us here, though; just be sure to join or detach thr eventually. What matters is that whenever the function call finishes, our result is ready:Now we\'re down to the lowest level: How would we implement the packaged task? This is where the std::promise comes in. The promise is the building block for communicating with a future. The principal steps are these:The calling thread makes a promise.The calling thread obtains a future from the promise.The promise, along with function arguments, are moved into a separate thread.The new thread executes the function and populates fulfills the promise.The original thread retrieves the result.As an example, here\'s our very own "packaged task":Usage of this template is essentially the same as that of std::packaged_task. Note that moving the entire task subsumes moving the promise. In more ad-hoc situations, one could also move a promise object explicitly into the new thread and make it a function argument of the thread function, but a task wrapper like the one above seems like a more flexible and less intrusive solution.Promises are intimately related to exceptions. The interface of a promise alone is not enough to convey its state completely, so exceptions are thrown whenever an operation on a promise does not make sense. All exceptions are of type std::future_error, which derives from std::logic_error. First off, a description of some constraints:A default-constructed promise is inactive. Inactive promises can die without consequence.A promise becomes active when a future is obtained via get_future(). However, only one future may be obtained!A promise must either be satisfied via set_value() or have an exception set via set_exception() before its lifetime ends if its future is to be consumed. A satisfied promise can die without consequence, and get() becomes available on the future. A promise with an exception will raise the stored exception upon call of get() on the future. If the promise dies with neither value nor exception, calling get() on the future will raise a "broken promise" exception.Here is a little test series to demonstrate these various exceptional behaviours. First, the harness:Now on to the tests.Case 1: Inactive promiseCase 2: Active promise, unusedCase 3: Too many futuresCase 4: Satisfied promiseCase 5: Too much satisfactionThe same exception is thrown if there is more than one of either of set_value or set_exception.Case 6: ExceptionCase 7: Broken promiseBartosz Milewski provides a good writeup. C++ splits the implementation of futures into a set \n  of small blocksstd::promise is one of these parts. A promise is a vehicle for passing the return value (or an \n  exception) from the thread executing a function to the thread \n  that cashes in on the function future. ...A future is the synchronization object constructed around the \n  receiving end of the promise channel.So, if you want to use a future, you end up with a promise that you use to get the result of the asynchronous processing. An example from the page is:In a rough approximation you can consider std::promise as the other end of a std::future (this is false, but for illustration you can think as if it was). The consumer end of the communication channel would use a std::future to consume the datum from the shared state, while the producer thread would use a std::promise to write to the shared state.std::promise is the channel or pathway for information to be returned from the async function. std::future is the synchronization mechanism thats makes the caller wait until the return value carried in the std::promise is ready(meaning its value is set inside the function).There are really 3 core entities in asynchronous processing. C++11 currently focuses on 2 of them.The core things you need to run some logic asynchronously are:C++11 calls the things I speak of in (1) std::promise, and those in (3) std::future.\nstd::thread is the only thing provided publicly for (2). This is unfortunate because real programs need to manage thread & memory resources, and most will want tasks to run on thread pools instead of creating & destroying a thread for every little task (which almost always causes unnecessary performance hits by itself and can easily create resource starvation that is even worse).According to Herb Sutter and others in the C++11 brain trust, there are tentative plans to add a std::executor that- much like in Java- will be the basis for thread pools and logically similar setups for (2). Maybe we\'ll see it in C++2014, but my bet is more like C++17 (and God help us if they botch the standard for these). A std::promise is created as an end point for a promise/future pair and the std::future (created from the std::promise using the get_future() method) is the other end point. This is a simple, one shot method of providing a way for two threads to synchronize as one thread provides data to another thread through a message.You can think of it as one thread creates a promise to provide data and the other thread collects the promise in the future. This mechanism can only be used once.The promise/future mechanism is only one direction, from the thread which uses the set_value() method of a std::promise to the thread which uses the get() of a std::future to receive the data. An exception is generated if the get() method of a future is called more than once.If the thread with the std::promise has not used set_value() to fulfill its promise then when the second thread calls get() of the std::future to collect the promise, the second thread will go into a wait state until the promise is fulfilled by the first thread with the std::promise when it uses the set_value() method to send the data.The following example code, a simple Visual Studio 2013 Windows console application, shows using a few of the C++11 concurrency classes/templates and other functionality. It illustrates a use for promise/future which works well, autonomous threads which will do some task and stop, and a use where more synchronous behavior is required and due to the need for multiple notifications the promise/future pair does not work.One note about this example is the delays added in various places. These delays were added only to make sure that the various messages printed to the console using std::cout would be clear and that text from the several threads would not be intermingled.The first part of the main() is creating three additional threads and using std::promise and std::future to send data between the threads. An interesting point is where the main thread starts up a thread, T2, which will wait for data from the main thread, do something, and then send data to the third thread, T3, which will then do something and send data back to the main thread.The second part of the main() creates two threads and a set of queues to allow multiple messages from the main thread to each of the two created threads. We can not use std::promise and std::future for this because the promise/future duo are one shot and can not be use repeatedly.The source for the class Sync_queue is from Stroustrup\'s The C++ Programming Language: 4th Edition.This simple application creates the following output.The promise is the other end of the wire.Imagine you need to retrieve the value of a future being computed by an async. However, you don\'t want it to be computed in the same thread, and you don\'t even spawn a thread "now" - maybe your software was designed to pick a thread from a pool, so you don\'t know who will perform che computation in the end.Now, what do you pass to this (yet unknown) thread/class/entity? You don\'t pass the future, since this is the result. You want to pass something that is connected to the future and that represents the other end of the wire, so you will just query the future with no knowledge about who will actually compute/write something.This is the promise. It is a handle connected to your future. If the future is a speaker, and with get() you start listening until some sound comes out, the promise is a microphone; but not just any microphone, it is the microphone connected with a single wire to the speaker you hold. You might know who\'s at the other end but you don\'t need to know it - you just give it and wait until the other party says something.