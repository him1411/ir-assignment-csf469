Using C# .NET 2.0, I have a composite data class that does have the [Serializable] attribute on it.  I am creating an XMLSerializer class and passing that into the constructor:I am getting an exception saying: There was an error reflecting type.Inside the data class there is another composite object.  Does this also need to have the [Serializable] attribute, or by having it on the top object, does it recursively apply it to all objects inside?Look at the inner exception that you are getting.  It will tell you which field/property it is having trouble serializing.  You can exclude fields/properties from xml serialization by decorating them with the [XmlIgnore] attribute.  I don\'t think that XmlSerializer uses the [Serializable] attribute, so I doubt that is the problem.Remember that serialized classes must have default (i.e. parameterless) constructors. If you have no constructor at all, that\'s fine; but if you have a constructor with a parameter, you\'ll need to add the default one too.I had a similar problem, and it turned out that the serializer could not distinguish between 2 classes I had with the same name (one was a subclass of the other).  The inner exception looked like this: \'Types BaseNamespace.Class1\' and \'BaseNamespace.SubNamespace.Class1\' both use the XML type name, \'Class1\', from namespace \'\'. Use XML attributes to specify a unique XML name and/or namespace for the type. Where BaseNamespace.SubNamespace.Class1 is a subclass of BaseNamespace.Class1.  What I needed to do was add an attribute to one of the classes (I added to the base class):Note: If you have more layers of classes you need to add an attribute to them as well.Also be aware that XmlSerializer cannot serialize abstract properties.. See my question here (which I have added the solution code to)..XML Serialization and Inherited TypesAll the objects in the serialization graph have to be serializable.Since XMLSerializer is a blackbox, check these links if you want to debug further into the serialization process..Changing where XmlSerializer Outputs Temporary Assemblies HOW TO: Debug into a .NET XmlSerializer Generated Assembly I\'ve discovered that the Dictionary class in .Net 2.0 is not serializable using XML, but serializes well when binary serialization is used.  I found a work around here. If you need to handle specific attributes (i.e. Dictionary, or any class), you can implement the IXmlSerialiable interface, which will allow you more freedom at the cost of more verbose coding.There is an interesting article, which show an elegant way to implements a sophisticated way to "extend" the XmlSerializer.The article say:IXmlSerializable is covered in the official documentation, but the documentation states it\'s not intended for public use and provides no information beyond that. This indicates that the development team wanted to reserve the right to modify, disable, or even completely remove this extensibility hook down the road. However, as long as you\'re willing to accept this uncertainty and deal with possible changes in the future, there\'s no reason whatsoever you can\'t take advantage of it.Because this, I suggest to implement you\'re own IXmlSerializable classes, in order to avoid too much complicated implementations....it could be straightforward to implements our custom XmlSerializer class using reflection.I recently got this in a web reference partial class when adding a new property. The auto generated class was adding the following attributes.I needed to add a similar attribute with an order one higher than the last in the auto generated sequence and this fixed it for me.I too thought that the Serializable attribute had to be on the object but unless I\'m being a complete noob (I am in the middle of a late night coding session) the following works from the SnippetCompiler:I would imagine that the XmlSerializer is using reflection over the public properties.Most common reasons by me:I had a situation where the Order was the same for two elements in a row.... some code ...When I changed the code to increment the order by one for each new Property in the class, the error went away.I just got the same error and discovered that a property of type IEnumerable<SomeClass> was the problem. It appears that IEnumerable cannot be serialized directly.Also note that you cannot serialize user interface controls and that any object you want to pass onto the clipboard must be serializable otherwise it cannot be passed across to other processes.I have been using the NetDataSerialiser class to serialise \nmy domain classes. NetDataContractSerializer Class.The domain classes are shared between client and server.[System.Xml.Serialization.XmlElementAttribute("strFieldName", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]//Or[XmlIgnore]\nstring [] strFielsName {get;set;}I had the same issue and in my case the object had a ReadOnlyCollection. A collection must implement Add method to be serializable. 