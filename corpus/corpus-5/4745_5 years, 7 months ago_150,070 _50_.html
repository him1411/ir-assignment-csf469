I am trying to implement a "Digit Recognition OCR" in OpenCV-Python (cv2). It is just for learning purposes. I would like to learn both KNearest and SVM features in OpenCV. I have 100 samples (i.e. images) of each digit. I would like to train with them.There is a sample letter_recog.py that comes with OpenCV sample. But i still couldn\'t figure out on how to use it. I don\'t understand what are the samples, responses etc. Also, it loads a txt file at first, which i didn\'t understand first.Later on searching a little bit, i could find a letter_recognition.data in cpp samples. I used it and made a code for cv2.KNearest in the model of letter_recog.py (just for testing):It gave me an array of size 20000, i don\'t understand what it is.Questions:1) What is letter_recognition.data file ? How to build that file from my own data set?2) What does results.reval() denote? 3) How we can write a simple digit recognition tool using letter_recognition.data file (either KNearest or SVM)?Well, I decided to workout myself on my question to solve above problem. What I wanted is to implement a simpl OCR using KNearest or SVM features in OpenCV. And below is what I did and how. ( it is just for learning how to use KNearest for simple OCR purposes).1) My first question was about letter_recognition.data file that comes with OpenCV samples. I wanted to know what is inside that file.It contains a letter, along with 16 features of that letter.And this SOF helped me to find it. These 16 features are explained in the paperLetter Recognition Using Holland-Style Adaptive Classifiers.\n( Although I didn\'t understand some of the features at end)2) Since I knew, without understanding all those features, it is difficult to do that method. I tried some other papers, but all were a little difficult for a beginner.So I just decided to take all the pixel values as my features. (I was not worried about accuracy or performance, I just wanted it to work, at least with the least accuracy)I took below image for my training data:( I know the amount of training data is less. But, since all letters are of same font and size, I decided to try on this).To prepare the data for training, I made a small code in OpenCV. It does following things:A) It loads the image.B) Selects the digits ( obviously by contour finding and applying constraints on area and height of letters to avoid false detections).C) Draws the bounding rectangle around one letter and wait for key press manually. This time we press the digit key ourselves corresponding to the letter in box.D) Once corresponding digit key is pressed, it resizes this box to 10x10 and saves 100 pixel values in an array (here, samples) and corresponding manually entered digit in another array(here, responses).E) Then save both the arrays in separate txt files.At the end of manual classification of digits, all the digits in the train data( train.png) are labeled manually by ourselves, image will look like below:Below is the code I used for above purpose ( of course, not so clean):Now we enter in to training and testing part.For testing part I used below image, which has same type of letters I used to train.For training we do as follows:A) Load the txt files we already saved earlierB) create a instance of classifier we are using ( here, it is KNearest)C) Then we use KNearest.train function to train the dataFor testing purposes, we do as follows:A) We load the image used for testingB) process the image as earlier and extract each digit using contour methodsC) Draw bounding box for it, then resize to 10x10, and store its pixel values in an array as done earlier. D) Then we use KNearest.find_nearest() function to find the nearest item to the one we gave. ( If lucky, it recognises the correct digit.)I included last two steps ( training and testing) in single code below:And it worked, below is the result I got:Here it worked with 100% accuracy. I assume this is because all the digits are of same kind and same size.But any way, this is a good start to go for beginners ( I hope so).For those who interested in C++ code can refer below code. \nThanks Abid Rahman for the nice explanation.The procedure is same as above but, the contour finding uses only first hierarchy level contour, so that the algorithm uses only outer contour for each digit.In the result the dot in the first line is detected as 8 and we haven\xe2\x80\x99t trained for dot. Also I am considering every contour in first hierarchy level as the sample input, user can avoid it by computing the area.  If you are interested in the state of the art in Machine Learning, you should look into Deep Learning. You should have a CUDA supporting GPU or alternatively use the GPU on Amazon Web Services.Google Udacity has a nice tutorial on this using Tensor Flow. This tutorial will teach you how to train your own classifier on hand written digits. I got an accuracy of over 97% on the test set using Convolutional Networks.