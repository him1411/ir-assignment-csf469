In javascript, when would you want to use this:over this:Its all about variable scoping.  Variables declared in the self executing function are, by default, only available to code within the self executing function.  This allows code to be written without concern of how variables are named in other blocks of javascript code.Simplistic. So very normal looking, its almost comforting:However. What if I include a really handy javascript library to my page that translates advanced characters into their base level representations?Wait... what? I mean. If someone types in a character with some kind of accent on it (such as a french or spanish character) but I only want \'english\' characters? A-z in my program? Well... The spanish \'n~\' and french \'e/\' characters (I\'ve used two characters each for those, but you can probably make the mental leap into the character that represents the accents), those characters can be translated into base characters of \'n\' and \'e\'. So someone nice person has written a comprehensive character converter out there that I can include in my site... I include it.One problem: it has a function in it called \'name\' same as my function.This is what\'s called collision. We\'ve got two functions declared in the same scope with the same name. We want to avoid this. So we need to scope our code somehow. The only way to scope code in javascript is to wrap it in a function:That might solve our problem. Everything is now enclosed and can only be accessed from within our opening and closing braces.We have a function in a function... which is weird to look at, but totally legal.Only one problem. Our code doesn\'t work.\nOur userName variable is never echoed into the console! We can solve this issue by adding a call to our function after our existing code block...Or before!A secondary concern: What are the chances that the name \'main\' hasn\'t been used yet? ...so very, very slim.We need MORE scoping. And some way to automatically execute our main() function.Now we come to auto-execution functions (or self-executing, self-running, whatever).((){})();The syntax is awkward as sin. However, it works. When you wrap a function definition in parentheses, and include a parameter list (another set or parentheses!) it acts as a function call.So lets look at our code again, with some self-executing syntax:So, in most tutorials you read, you will now be bombard with the term \'anonymous self-executing\' or something similar. After many years of professional development, I strongly urge you to name every function you write for debugging purposes.When something goes wrong (and it will), you will be checking the backtrace in your browser. It is always easier to narrow your code issues when the entries in the stack trace have names!Hugely long-winded and I hope it helps!Self-invocation (also known as\n  auto-invocation) is when a function\n  executes immediately upon its\n  definition. This is a core pattern and\n  serves as the foundation for many\n  other patterns of JavaScript\n  development.I am a great fan :) of it because:Enormously \xe2\x80\x93 (Why you should say its good?)More here.Namespacing. JavaScript\'s scopes are function-level.I can\'t believe none of the answers mention implied globals.The (function(){})() construct does not protect against implied globals, which to me is the bigger concern, see http://yuiblog.com/blog/2006/06/01/global-domination/Basically the function block makes sure all the dependent "global vars" you defined are confined to your program, it does not protect you against defining implicit globals. JSHint or the like can provide recommendations on how to defend against this behavior.The more concise var App = {} syntax provides a similar level of protection, and may be wrapped in the function block when on \'public\' pages. (see Ember.js or SproutCore for real world examples of libraries that use this construct)As far as private properties go, they are kind of overrated unless you are creating a public framework or library, but if you need to implement them, Douglas Crockford has some good ideas.Scope isolation, maybe.  So that the variables inside the function declaration don\'t pollute the outer namespace.Of course, on half the JS implementations out there, they will anyway.This is an awesome article explaining all about it and why it\'s a good programming practice:\nhttp://markdalgleish.com/2011/03/self-executing-anonymous-functions/Is there a parameter and the "Bunch of code" returns a function?Closure. The value of something gets used by the function assigned to a. something could have some varying value (for loop) and every time a has a new function.Here\'s a solid example of how a self invoking anonymous function could be useful.Output: 10, 10, 10, 10, 10...Output: 0, 1, 2, 3, 4...One difference is that the variables that you declare in the function are local, so they goes away when you exit the function and the don\'t conflict with other variables in other code.Since functions in Javascript are first-class object, by defining it that way, it effectively defines a "class" much like C++ or C#.That function can define local variables, and have functions within it.  The internal functions (effectively instance methods) will have access to the local variables (effectively instance variables), but they will be isolated from the rest of the script.Self invoked function in javascript:A self-invoking expression is invoked (started) automatically, without being called. A self-invoking expression is invoked right after its created. This is basically used for avoiding naming conflict as well as for achieving encapsulation. The variables or declared objects are not accessible outside this function. For avoiding the problems of minimization(filename.min) always use self executed function.\n(function(){\n    var foo = {\n        name: \'bob\'\n    };\n    console.log(foo.name); // bob\n})();\nconsole.log(foo.name); // Reference error\nActually, the above function will be treated as function expression without a name.The main purpose of wrapping a function with close and open parenthesis is to avoid polluting the global space. The variables and functions inside the function expression became private (i.e) they will not be available outside of the function.It looks like this question has been answered all ready, but I\'ll post my input anyway.I know when I like to use self-executing functions.The function allows me to use some extra code to define the childObjects attributes and properties for cleaner code, such as setting commonly used variables or executing mathematic equations; Oh! or error checking. as opposed to being limited to nested object instantiation syntax of...Coding in general has a lot of obscure ways of doing a lot of the same things, making you wonder, "Why bother?" But new situations keep popping up where you can no longer rely on basic/core principals alone.IIRC it allows you to create private properties and methods.