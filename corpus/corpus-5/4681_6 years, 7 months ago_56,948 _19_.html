I noticed that with the optional parameters in C# 4 if you specify a parameter as optional on an interface you DON\'T have to make that parameter optional on any implementing class:and therefore:Does anyone know why optional parameters are designed to work this way?On one hand I suppose the ability to override any default values specified on the interfaces is useful though to be honest I\'m not sure if you should even be able to specify default values on the interface as that should be an implementation decision.On the other hand, this disconnect means you can\'t always use the concrete class and the interface interchangeably. This of course, wouldn\'t be a problem if the default value is specified on the implementation, but then if you\'re exposing your concrete class as the interface (using some IOC framework to inject the concrete class for instance) then really there\'s no point having the default value as the caller will have to always provide it anyway.UPDATE: This question was the subject of my blog on May 12th 2011. Thanks for the great question!Suppose you have an interface as you describe, and a hundred classes that implement it. Then you decide to make one of the parameters of one of the interface\'s methods optional. Are you suggesting that the right thing to do is for the compiler to force the developer to find every implementation of that interface method, and make the parameter optional as well?Suppose we did that. Now suppose the developer did not have the source code for the implementation:How is the author of D supposed to make this work? Are they required in your world to call up the author of B on the phone and ask them to please ship them a new version of B that makes the method have an optional parameter?  That\'s not going to fly. What if two people call up the author of B, and one of them wants the default to be true and one of them wants it to be false? What if the author of B simply refuses to play along?Perhaps in that case they would be required to say:The proposed feature seems to add a lot of inconvenience for the programmer with no corresponding increase in representative power. What\'s the compelling benefit of this feature which justifies the increased cost to the user?An optional parameter is just tagged with an attribute. This attribute tells the compiler to insert the default value for that parameter at the call-site.The call obj2.TestMethod(); is replaced by obj2.TestMethod(false); when the C# code gets compiled to IL, and not at JIT-time.So in a way it\'s always the caller providing the default value with optional parameters. This also has consequences on binary versioning: If you change the default value but don\'t recompile the calling code it will continue to use the old default value.On the other hand, this disconnect means you can\'t always use the concrete class and the interface interchangeably.You already can\'t do that if the interface method was implemented explicitly.Because default parameters are resolved at compile time, not runtime.\nSo the default values does not belong to the object being called, but to the reference type that it is being called through.Optional parameters are kind of like a macro substitution from what I understand. They are not really optional from the method\'s point of view. An artifact of that is the behavior you see where you get different results if you cast to an interface.