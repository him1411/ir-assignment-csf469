What is the advantage of using an abstract class instead of a trait (apart from performance)? It seems like abstract classes can be replaced by traits in most cases.I can think of two differencesThere\'s a section in Programming in Scala called "To trait, or not to trait?" which addresses this question. Since the 1st ed is available online, I\'m hoping it\'s ok to quote the whole thing here. (Any serious Scala programmer should buy the book):Whenever you implement a reusable collection of behavior, you will\n  have to decide whether you want to use a trait or an abstract class.\n  There is no firm rule, but this section contains a few guidelines to\n  consider.If the behavior will not be reused, then make it a concrete class. It\n  is not reusable behavior after all.If it might be reused in multiple, unrelated classes, make it a trait.\n  Only traits can be mixed into different parts of the class hierarchy.If you want to inherit from it in Java code, use an abstract class.\n  Since traits with code do not have a close Java analog, it tends to be\n  awkward to inherit from a trait in a Java class. Inheriting from a\n  Scala class, meanwhile, is exactly like inheriting from a Java class.\n  As one exception, a Scala trait with only abstract members translates\n  directly to a Java interface, so you should feel free to define such\n  traits even if you expect Java code to inherit from it. See Chapter 29\n  for more information on working with Java and Scala together.If you plan to distribute it in compiled form, and you expect outside\n  groups to write classes inheriting from it, you might lean towards\n  using an abstract class. The issue is that when a trait gains or loses\n  a member, any classes that inherit from it must be recompiled, even if\n  they have not changed. If outside clients will only call into the\n  behavior, instead of inheriting from it, then using a trait is fine.If efficiency is very important, lean towards using a class. Most Java\n  runtimes make a virtual method invocation of a class member a faster\n  operation than an interface method invocation. Traits get compiled to\n  interfaces and therefore may pay a slight performance overhead.\n  However, you should make this choice only if you know that the trait\n  in question constitutes a performance bottleneck and have evidence\n  that using a class instead actually solves the problem.If you still do not know, after considering the above, then start by\n  making it as a trait. You can always change it later, and in general\n  using a trait keeps more options open.As @Mushtaq Ahmed mentioned, a trait cannot have any parameters passed to the primary constructor of a class. Another difference is the treatment of super.The other difference between classes and traits is that whereas in classes, super calls are statically bound, in traits, they are dynamically bound. If you write super.toString in a class, you know exactly which method implementation will be invoked. When you write the same thing in a trait, however, the method implementation to invoke for the super call is undefined when you define the trait.See the rest of Chapter 12 for more details.Edit:There is a subtle difference in the way abstract classes behaves compared to traits. One of the linearization rules is that it preserves the inheritance hierarchy of the classes, which tends to push abstract classes later in the chain while traits can happily be mixed in. In certain circumstances, it\'s actually preferable to be in latter position of the class linearization, so abstract classes could be used for that. See constraining class linearization (mixin order) in Scala.For whatever it is worth, Odersky et al\'s Programming in Scala recommends that, when you doubt, you use traits. You can always change them into abstract classes later on if needed.Other than the fact that you cannot directly extend multiple abstract classes, but you can mixin multiple traits into a class, it\'s worth mentioning that traits are stackable, since super calls in a trait are dynamically bound (it is referring a class or trait mixed before current one).From Thomas\'s answer in Difference between Abstract Class and Trait:When extending an abstract class, this shows that the subclass is of a similar kind. This is not neccessarily the case when using traits, I think.Abstract classes can contain behaviour - They can parameterized with constructor args (which traits can\'t) and represent a working entity. Traits instead just represent a single feature, an interface of one functionality.In Programming Scala the authors say that abstract classes make a classical object oriented "is-a" relationship while traits are a scala-way of composition.