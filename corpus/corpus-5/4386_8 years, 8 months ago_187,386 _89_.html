It\'s very annoying to have this limitation on my development box, when there won\'t ever be any users other than me.I\'m aware of the standard workarounds, but none of them do exactly what I want:Is there some simple sysctl variable to allow non-root processes to bind to "privileged" ports (ports less than 1024) on Linux, or am I just out of luck?EDIT: In some cases, you can use capabilities to do this.Okay, thanks to the people who pointed out the capabilities system and CAP_NET_BIND_SERVICE capability. If you have a recent kernel, it is indeed possible to use this to start a service as non-root but bind low ports. The short answer is that you do:And then anytime program is executed thereafter it will have the CAP_NET_BIND_SERVICE capability. setcap is in the debian package libcap2-bin.Now for the caveats:Resources:Note: RHEL first added this in v6. The standard way is to make them "setuid" so that they start up as root, and then they throw away that root privilege as soon as they\'ve bound to the port but before they start accepting connections to it.  You can see good examples of that in the source code for Apache and INN.  I\'m told that Lighttpd is another good example.Another example is Postfix, which uses multiple daemons that communicate through pipes, and only one or two of them (which do very little except accept or emit bytes) run as root and the rest run at a lower privilege.You can do a port redirect.  This is what I do for a Silverlight policy server running on a Linux boxFile capabilities are not ideal, because they can break after a package update.The ideal solution, IMHO, should be an ability to create a shell with inheritable CAP_NET_BIND_SERVICE set.Here\'s a somewhat convoluted way to do this:capsh utility can be found in libcap2-bin package in Debian/Ubuntu distributions. Here\'s what goes on:The result is a process with specified user and group, and cap_net_bind_service privileges.As an example, a line from ejabberd startup script:Two other simple possibilities:There is an old (unfashionable) solution to the "a daemon that binds on a low port and hands control to your daemon". It\'s called inetd (or xinetd). The cons are:Pros:Another alternative: a hacked-up proxy (netcat or even something more robust) from the privileged port to some arbitrary high-numbered port where you can run your target daemon. (Netcat is obviously not a production solution, but "just my dev box", right?). This way you could continue to use a network-capable version of your server, would only need root/sudo to start proxy (at boot), wouldn\'t be relying on complex/potentially fragile capabilities.My "standard workaround" uses socat as the user-space redirector:Beware that this won\'t scale, forking is expensive but it\'s the way socat works.You can setup a local SSH tunnel, eg if you want port 80 to hit your app bound to 3000:This has the advantage of working with script servers, and being very simple.Or patch your kernel and remove the check.(Option of last resort, not recommended).TLDR: For "the answer" (as I see it), jump down to the >>TLDR<< part in this answer.OK, I\'ve figured it out (for real this time), the answer to this question, and this answer of mine is also a way of apologizing for promoting another answer (both here and on twitter) that I thought was "the best", but after trying it, discovered that I was mistaken about that. Learn from my mistake kids: don\'t promote something until you\'ve actually tried it yourself!Again, I reviewed all the answers here. I\'ve tried some of them (and chose not to try others because I simply didn\'t like the solutions). I thought that the solution was to use systemd with its Capabilities= and CapabilitiesBindingSet= settings. After wrestling with this for some time, I discovered that this is not the solution because:Capabilities are intended to restrict root processes!As the OP wisely stated, it is always best to avoid that (for all your daemons if possible!).You cannot use the Capabilities related options with User= and Group= in systemd unit files, because capabilities are ALWAYS reset when execev (or whatever the function is) is called. In other words, when systemd forks and drops its perms, the capabilities are reset. There is no way around this, and all that binding logic in the kernel is basic around uid=0, not capabilities. This means that it is unlikely that Capabilities will ever be the right answer to this question (at least any time soon). Incidentally, setcap, as others have mentioned, is not a solution. It didn\'t work for me, it doesn\'t work nicely with scripts, and those are reset anyways whenever the file changes.In my meager defense, I did state (in the comment I\'ve now deleted), that James\' iptables suggestion (which the OP also mentions), was the "2nd best solution". :-P>>TLDR<<The solution is to combine systemd with on-the-fly iptables commands, like this (taken from DNSChain):Here we accomplish the following:iptables is still, unfortunately, quite an ugly and difficult-to-use utility. If the daemon is listening on eth0:0 instead of eth0, for example, the commands are slightly different.Linux supports capabilities to support more fine-grained permissions than just "this application is run as root". One of those capabilities is CAP_NET_BIND_SERVICE which is about binding to a privileged port (<1024).Unfortunately I don\'t know how to exploit that to run an application as non-root while still giving it CAP_NET_BIND_SERVICE (probably using setcap, but there\'s bound to be an existing solution for this).I know this is an old question, but now with recent (>= 4.3) kernels there is finally a good answer to this - ambient capabilities.The quick answer is to grab a copy of the latest (as-yet-unreleased) version of libcap from git and compile it. Copy the resulting progs/capsh binary somewhere (/usr/local/bin is a good choice). Then, as root, start your program withIn order, we areThere\'s a lot going on under the hood here.Firstly, we are running as root, so by default, we get a full set of capabilities. Included in this is the ability to switch uid & gid with the setuid and setgid syscalls. However, ordinarily when a program does this, it loses its set of capabilities - this is so that the old way of dropping root with setuid still works. The --keep=1 flag tells capsh to issue the prctl(PR_SET_KEEPCAPS) syscall, which disables the dropping of capabilities when changing user. The actual changing of users by capsh happens with the --user flag, which runs setuid and setgid.The next problem we need to solve is how to set capabilities in a way that carries on after we exec our children. The capabilities system has always had an \'inherited\' set of capabilities, which is " a set of capabilities preserved across an execve(2)" [capabilities(7)]. Whilst this sounds like it solves our problem (just set the cap_net_bind_service capability to inherited, right?), this actually only applies for privileged processes - and our process is not privileged anymore, because we already changed user (with the --user flag). The new ambient capability set works around this problem - it is "a set of capabilities that are preserved across an execve(2) of a program that is not privileged." By putting cap_net_bind_service in the ambient set, when capsh exec\'s our server program, our program will inherit this capability and be able to bind listeners to low ports.If you\'re interested to learn more, the capabilities manual page explains this in great detail. Running capsh through strace is also very informative!systemd is a sysvinit replacement which has an option to launch a daemon with specific capabilities. Options Capabilities=, CapabilityBoundingSet= in systemd.exec(5) manpage.Port redirect made the most sense for us, but we ran into an issue where our application would resolve a url locally that also needed to be re-routed; (that means you shindig). This will also allow you to be redirected when accessing the url on the local machine.At startup:Then  you can bind to the port you forward to.As a follow-up to Joshua\'s fabulous (=not recommended unless you know what you do) recommendation to hack the kernel:I\'ve first posted it here.Simple. With a normal or old kernel, you don\'t. \nAs pointed out by others, iptables can forward a port. \nAs also pointed out by others, CAP_NET_BIND_SERVICE can also do the job.  \nOf course CAP_NET_BIND_SERVICE will fail if you launch your program from a script, unless you set the cap on the shell interpreter, which is pointless, you could just as well run your service as root...  \ne.g. for Java, you have to apply it to the JAVA JVMObviously, that then means any Java program can bind system ports.\nDito for mono/.NET.I\'m also pretty sure xinetd isn\'t the best of ideas. \nBut since both methods are hacks, why not just lift the limit by lifting the restriction ? \nNobody said you have to run a normal kernel, so you can just run your own. You just download the source for the latest kernel (or the same you currently have).\nAfterwards, you go to:There you look for this lineand change it to if you don\'t want to have an insecure ssh situation, you alter it to this:\n    #define PROT_SOCK 24Generally, I\'d use the lowest setting that you need, e.g 79 for http, or 24 when using SMTP on port 25.That\'s already all. \nCompile the kernel, and install it. \nReboot.\nFinished - that stupid limit is GONE, and that also works for scripts.Here\'s how you compile a kernel:https://help.ubuntu.com/community/Kernel/CompileIn a nutshell, use iptables if you want to stay secure, compile the kernel if you want to be sure this restriction never bothers you again.  With systemd, you just need to slightly modify your service to accept preactivated sockets.You can later use systemd socket activate.No capabilities, iptables or other tricks are needed.This is content of relevant systemd files from this example of simple python http serverFile httpd-true.serviceFile httpd-true.socketThere is also the \'djb way\'.  You can use this method to start your process as root running on any port under tcpserver, then it will hand control of the process to the user you specify immediately after the process starts.  For more info, see: http://thedjbway.b0llix.net/daemontools/uidgid.htmlSince the OP is just development/testing, less than sleek solutions may be helpful:setcap can be used on a script\'s interpreter to grant capabilities to scripts.  If setcaps on the global interpreter binary is not acceptable, make a local copy of the binary (any user can) and get root to setcap on this copy.  Python2 (at least) works properly with a local copy of the interpreter in your script development tree.  No suid is needed so the root user can control to what capabilities users have access.If you need to track system-wide updates to the interpreter, use a shell script like the following to run your script:Use the privbind utility: it allows  an  unprivileged  application to bind to reserved ports.I tried the iptables PREROUTING REDIRECT method. In older kernels it seems this type of rule wasn\'t supported for IPv6. But apparently it is now supported in ip6tables v1.4.18 and Linux kernel v3.8.I also found that PREROUTING REDIRECT doesn\'t work for connections initiated within the machine. To work for conections from the local machine, add an OUTPUT rule also \xe2\x80\x94 see iptables port redirect not working for localhost. E.g. something like:I also found that PREROUTING REDIRECT also affects forwarded packets. That is, if the machine is also forwarding packets between interfaces (e.g. if it\'s acting as a Wi-Fi access point connected to an Ethernet network), then the iptables rule will also catch connected clients\' connections to Internet destinations, and redirect them to the machine. That\'s not what I wanted\xe2\x80\x94I only wanted to redirect connections that were directed to the machine itself. I found I can make it only affect packets addressed to the box, by adding -m addrtype --dst-type LOCAL. E.g. something like:One other possibility is to use TCP port forwarding. E.g. using socat:However one disadvantage with that method is, the application that is listening on port 8080 then doesn\'t know the source address of incoming connections (e.g. for logging or other identification purposes).Answer at 2015/Sep:ip6tables now supports IPV6 NAT: http://www.netfilter.org/projects/iptables/files/changes-iptables-1.4.17.txtYou will need kernel 3.7+Proof: