What is the best way (performance wise) to paginate results in SQL Server 2000, 2005, 2008, 2012 if you also want to get the total number of results (before paginating)?Getting the total number of results and paginating are two different operations. For the sake of this example, let\'s assume that the query you\'re dealing with isIn this case, you would determine the total number of results using:...which may seem inefficient, but is actually pretty performant, assuming all indexes etc. are properly set up.Next, to get actual results back in a paged fashion, the following query would be most efficient:This will return rows 1-19 of the original query. The cool thing here, especially for web apps, is that you don\'t have to keep any state, except the row numbers to be returned.I was  also very curious about why Microsoft doesn\'t support simple queries with offset/limit like in MySQL or PostgreSQL. Finally, released Microsoft SQL Server 2012, I really like its simplicity for pagination, you don\'t have to use complex queries like answered here. For getting the next 10 rows just run this query:http://technet.microsoft.com/en-us/library/gg699618.aspx\n  Key points to consider when using it:Incredibly, no other answer has mentioned the fastest way to do pagination in all SQL Server versions. Offsets can be terribly slow for large page numbers as is benchmarked here. There is an entirely different, much faster way to perform pagination in SQL. This is often called the "seek method" or "keyset pagination" as described in this blog post here.The @previousScore and @previousPlayerId values are the respective values of the last record from the previous page. This allows you to fetch the "next" page. If the ORDER BY direction is ASC, simply use > instead.With the above method, you cannot immediately jump to page 4 without having first fetched the previous 40 records. But often, you do not want to jump that far anyway. Instead, you get a much faster query that might be able to fetch data in constant time, depending on your indexing. Plus, your pages remain "stable", no matter if the underlying data changes (e.g. on page 1, while you\'re on page 4).This is the best way to implement pagination when lazy loading more data in web applications, for instance.Note, the "seek method" is also called keyset pagination.The COUNT(*) OVER() window function will help you count the number of total records "before pagination". If you\'re using SQL Server 2000, you will have to resort to two queries for the COUNT(*).There is a good overview of different paging techniques at http://www.codeproject.com/KB/aspnet/PagingLarge.aspxI\'ve used ROWCOUNT method quite often mostly with SQL Server 2000 (will work with 2005 & 2008 too, just measure performance compared to ROW_NUMBER), it\'s lightning fast, but you need to make sure that the sorted column(s) have  (mostly) unique values.MSDN: ROW_NUMBER (Transact-SQL)Returns the sequential number of a row within a partition of a result set, starting at 1 for the first row in each partition.The following example returns rows with numbers 50 to 60 inclusive in the order of the OrderDate.From SQL Server 2012, we can use OFFSET and FETCH NEXT Clause to achieve the pagination. Try this, for SQL Server:In the SQL Server 2012 a new feature was added in the ORDER BY clause,\n  to query optimization of a set data, making work easier with data\n  paging for anyone who writes in T-SQL as well for the entire Execution\n  Plan in SQL Server.Below the T-SQL script with the same logic used in the previous\n  example.TechNet: Paging a Query with SQL ServerFor SQL Server 2000 you can simulate ROW_NUMBER() using a table variable with an IDENTITY column:This approach can be extended to tables with multi-column keys, and it doesn\'t incur the performance overhead of using OR (which skips index usage).  The downside is the amount of temporary space used up if the data set is very large and one is near the last page.  I did not test cursor performance in that case, but it might be better.Note that this approach could be optimized for the first page of data.  Also, ROWCOUNT was used since TOP does not accept a variable in SQL Server 2000.Try this approach:Use case wise following seem to be easy to use and fast just set the page number.also with CTEWell I have used the following sample query in my SQL 2000 database, it works well for SQL 2005 too. The power it gives you is dynamically order by using multiple columns. \nI tell you ... this is powerful :) The best part is sp_executesql caches later calls, provided you pass same parameters i.e generate same sql text.will restart idx when it comes to different init_idThese are my solutions for paging the result of query in SQL server side.\nthese approaches are different between SQL Server 2008 and 2012.\nAlso, I have added the concept of filtering and order by with one column. It is very efficient when you are paging and filtering and ordering in your Gridview.Before testing, you have to create one sample table and insert some row in this table : (In real world you have to change Where clause considering your table fields and maybe you have some join and subquery in main part of select)In all of these sample, I want to query 200 rows per page and I am fetching the row for page number 1200.In SQL server 2008, you can use the CTE concept. Because of that, I have written two type of query for SQL server 2008+-- SQL Server 2008+And second solution with CTE in SQL server 2008+-- SQL Server 2012+For the ROW_NUMBER technique, if you do not have a sorting column to use, you can use the CURRENT_TIMESTAMP as follows:This has worked well for me for searches over table sizes of even up to 700,000. This fetches records 11 to 30.You didn\'t specify the language nor which driver you are using. Therefore I\'m describing it abstractly.