I was writing code that does something that looks like:Someone told me this is called the "deferred antipattern" or the "Promise constructor antipattern" respectively, what\'s bad about this code and why is this called an antipattern?The deferred antipattern (now explicit-construction anti-pattern) coined by Esailija is a common anti-pattern people who are new to promises make, I\'ve made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.Promises can chain with .then and you can return promises directly. Your code in getStuffDone can be rewritten as:Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.You should only use deferred objects when you are converting an API to promises and can\'t do it automatically, or when you\'re writing aggregation functions that are easier expressed this way. Quoting Esailija:This is the most common anti-pattern. It is easy to fall into this when you don\'t really understand promises and think of them as glorified event emitters or callback utility. Let\'s recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.But the pattern works!Lucky you. Unfortunately, it probably doesn\'t, as you likely forgot some edge case. In more than half of the occurrences I\'ve seen, the author has forgotten to take care of the error handler:If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.The same thing happens in the case that your callback code causes an error - e.g. when result doesn\'t have a property and an exception is thrown. That would go unhandled and leave the new promise unresolved. In contrast, using .then() does automatically take care of both these scenarios, and rejects the new promise when an error happens:The deferred antipattern is not only cumbersome, but also error-prone. Using .then() for chaining is much safer.But I\'ve handled everything!Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won\'t want to rewrite your code for that.The libraries\' methods (then) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.So whenever you find yourself manually creating a Promise or Deferred and already existing promises are involved, check the library API first. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but promises are more than callbacks: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don\'t want to deal with.If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.