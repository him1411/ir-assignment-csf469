Is it possible to have blocks as properties using the standard property syntax?Are there any changes for ARC?If you are going to be repeating the same block in several places use a type defHere\'s an example of how you would accomplish such a task:Now, the only thing that would need to change if you needed to change the type of compare would be the typedef int (^IntBlock)(). If you need to pass two objects to it, change it to this: typedef int (^IntBlock)(id, id), and change your block to: I hope this helps.EDIT March 12, 2012:For ARC, there are no specific changes required, as ARC will manage the blocks for you as long as they are defined as copy. You do not need to set the property to nil in your destructor, either. For more reading, please check out this document:\nhttp://clang.llvm.org/docs/AutomaticReferenceCounting.htmlFor Swift, just use closures: example.In Objective-C,It\'s that simple.Apple doco.In your .h file:Here\'s your .m file:With modern (2014+) systems, do what is shown here. It is that simple. Hope it helps someone. Merry Christmas 2013!For posterity / completeness\'s sake\xe2\x80\xa6 Here are two FULL examples of how to implement this ridiculously versatile "way of doing things". @Robert\'s answer is blissfully concise and correct, but here I want to also show ways to actually "define" the blocks. Silly? Yes.  Useful? Hells yeah.  Here is a different, "more atomic" way of setting the property.. and a class that is ridiculously useful\xe2\x80\xa6This illustrates setting the block property via the accessor (albeit inside init, a debatably dicey practice..) vs the first example\'s "nonatomic" "getter" mechanism.  In either case\xe2\x80\xa6 the "hardcoded" implementations can always be overwritten, per instance.. a l\xc3\xa1..Also.. if you want to add a block property in a category... say you want to use a Block instead of some old-school target / action "action"...  You can just use associated values to, well.. associate the blocks.Now, when you make a button, you don\'t have to set up some IBAction drama..  Just associate the work to be done at creation...  This pattern can be applied OVER and OVER to Cocoa API\'s.  Use properties to bring the relevant parts of your code closer together, eliminate convoluted delegation paradigms, and leverage the power of objects beyond that of just acting as dumb "containers".Of course you could use blocks as properties. But make sure they are declared as @property(copy).   For example:  In MRC, blocks capturing context variables are allocated in stack; they will be released when the stack frame is destroyed. If they are copied, a new block will be allocated in heap, which can be executed later on after the stack frame is poped.This is not intended to be "the good answer", as this question ask explicitly for ObjectiveC. As Apple introduced Swift at the WWDC14, I\'d like to share the different ways to use block (or closures) in Swift.You have many ways offered to pass a block equivalent to function in Swift. I found three.To understand this I suggest you to test in playground this little piece of code.As Swift is optimized for asynchronous development, Apple worked more on closures.\nThe first is that function signature can be inferred so you don\'t have to rewrite it. This special case works only if the block is the last argument, it\'s called trailing closureHere is an example (merged with inferred signature to show Swift power)Finally:Using all this power what I\'d do is mixing trailing closure and type inference (with naming for readability)Hello, SwiftComplementing what @Francescu answered.Adding extra parameters:You can follow the format below and can use the testingObjectiveCBlock property in the class.For more info have a look here