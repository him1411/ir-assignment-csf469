I want to know what a "virtual base class" is and what it means.Let me show an example:Virtual base classes, used in virtual inheritance, is a way of preventing multiple "instances" of a given class appearing in an inheritance hierarchy when using multiple inheritance.Consider the following scenario:The above class hierarchy results in the "dreaded diamond" which looks like this:An instance of D will be made up of B, which includes A, and C which also includes A. So you have two "instances" (for want of a better expression) of A.When you have this scenario, you have the possibility of ambiguity. What happens when you do this:Virtual inheritance is there to solve this problem. When you specify virtual when inheriting your classes, you\'re telling the compiler that you only want a single instance.This means that there is only one "instance" of A included in the hierarchy. HenceHope that helps as a mini summary. For more information, have a read of this and this. A good example is also available here.As a side note, the problem with the Dreaded Diamond is that the base class is present multiple times. So with regular inheritance, you believe you have:But in the memory layout, you have:This explain why when call D::foo(), you have an ambiguity problem. But the real problem comes when you want to use a member variable of A. For example, let\'s say we have:When you\'ll try to access m_iValue from D, the compiler will protest, because in the hierarchy, it\'ll see two m_iValue, not one. And if you modify one, say, B::m_iValue (that is the A::m_iValue parent of B), C::m_iValue won\'t be modified (that is the A::m_iValue parent of C).This is where virtual inheritance comes handy, as with it, you\'ll get back to a true diamond layout, with not only one foo() method only, but also one and only one m_iValue.Imagine:With normal inheritance, modifying m_iValue from D is ambiguous and this must be resolved. Even if it is, there are two m_iValues inside D, so you\'d better remember that and update the two at the same time.With virtual inheritance, modifying m_iValue from D is ok... But... Let\'s say that you have D. Through its C interface, you attached an observer. And through its B interface, you update the cool array, with has the side effect of directly changing m_iValue...As the change of m_iValue is done directly (without using a virtual accessor method), the observer "listening" through C won\'t be called, because the code implementing the listening is in C, and B doesn\'t know about it...If you\'re having a diamond in your hierarchy, it means that you have 95% to have done something wrong with said hierarchy.Explaining multiple-inheritance with virtual bases requires a knowledge of the C++ object model. And explaining the topic clearly is best done in an article and not in a comment box.The best, readable explanation I found that solved all my doubts on this subject was this article: http://www.phpcompiler.org/articles/virtualinheritance.htmlYou really won\'t need to read anything else on the topic (unless you are a compiler writer) after reading that...A virtual base class is a class that\n  cannot be instantiated : you cannot\n  create direct object out of it.I think you are confusing two very different things.  Virtual inheritance is not the same thing as an abstract class.  Virtual inheritance modifies the behaviour of function calls;  sometimes it resolves function calls that otherwise would be ambiguous, sometimes it defers function call handling to a class other than that one would expect in a non-virtual inheritance.I\'d like to add to OJ\'s kind clarifications.Virtual inheritance doesn\'t come without a price.  Like with all things virtual, you get a performance hit.  There is a way around this performance hit that is possibly less elegant.Instead of breaking the diamond by deriving virtually, you can add another layer to the diamond, to get something like this:None of the classes inherit virtually, all inherit publicly.  Classes D21 and D22 will then hide virtual function f() which is ambiguous for DD, perhaps by declaring the function private.  They\'d each define a wrapper function, f1() and f2() respectively, each calling class-local (private) f(), thus resolving conflicts.  Class DD calls f1() if it wants D11::f() and f2() if it wants D12::f().  If you define the wrappers inline you\'ll probably get about zero overhead.Of course, if you can change D11 and D12 then you can do the same trick inside these classes, but often that is not the case.In addition to what has already been said about multiple and virtual inheritance(s), there is a very interesting article on Dr Dobb\'s Journal: Multiple Inheritance Considered UsefulIt means a call to a virtual function will be forwarded to the "right" class.C++ FAQ Lite FTW.In short, it is often used in multiple-inheritance scenarios, where a "diamond" hierarchy is formed.  Virtual inheritance will then break the ambiguity created in the bottom class, when you call function in that class and the function needs to be resolved to either class D1 or D2 above that bottom class.  See the FAQ item for a diagram and details.It is also used in sister delegation, a powerful feature (though not for the faint of heart).  See this FAQ.Also see Item 40 in Effective C++ 3rd edition (43 in 2nd edition).You\'re being a little confusing. I dont\' know if you\'re mixing up some concepts.You don\'t have a virtual base class in your OP. You just have a base class. You did virtual inheritance. This is usually used in multiple inheritance so that multiple derived classes use the members of the base class without reproducing them.A base class with a pure virtual function is not be instantiated. this requires the syntax that Paul gets at. It is typically used so that derived classes must define those functions. I don\'t want to explain any more about this because I don\'t totally get what you\'re asking. Diamond inheritance runnable usage exampleThis example shows how to use a virtual base class in the typical scenario: to solve diamond inheritance.Virtual classes are not the same as virtual inheritance. Virtual classes you cannot instantiate, virtual inheritance is something else entirely.Wikipedia describes it better than I can. http://en.wikipedia.org/wiki/Virtual_inheritanceThis is one of my interview questions; almost everyone thinks \xe2\x80\x9cvirtual base class\xe2\x80\x9d means \xe2\x80\x9cclass with pure virtual specifiers\xe2\x80\x9d, like one of the answers here. That is not correct.\nIn OO design, you often see concrete classes with multiple interfaces. There is a concept called \xe2\x80\x9cpolicy based implementations\xe2\x80\x9d that implement some or all of an interface , you can just plug into an implementation and reuse. You don\xe2\x80\x99t hear about policy based implementation in the context of OO programming, because Java and C# doesn\'t support it. But Python and C++ actually do.It looks like this\nInterfaces:Stock implementations:And some implementations reusing the stock classesThe use of protected here suppresses implicit conversions to the implementation classes, i.e. implementation do not model the \xe2\x80\x9cis-a\xe2\x80\x9d relationship. Only the interfaces do that. (The public one is the last, mostly because of C++ ordering of inheritance rules, the right most inheritance is \xe2\x80\x9cdominant\xe2\x80\x9d)The interfaces often have multiple functions, I can in fact do thisI have use this style for a lot of projects. The \xe2\x80\x9cfinal\xe2\x80\x9d specifiers here aid the optimizer in resolving where it can safely devirtualize. Devirtualization in C++, part 1 resulting in a class that performs much the same as if everything were templates.However, the \xe2\x80\x9cpure interface\xe2\x80\x9d method does have the obvious advantages of modularization, which is why people use it. Of course, through a module boundary, there is not much opportunity for the compiler to devirtualize. I have made optimizations by making several dynamic casts \xe2\x80\x9cbehind the scenes\xe2\x80\x9d to see if I can discover often used implementing classes. This works like a champ.In C++ \xe2\x80\x9cpolicy based implementation\xe2\x80\x9d is typically done using templates, and not interfaces with virtual functions, and templates introduces a lot of coupling on various parts of the system. Microsofts ATL is an excellent example using virtual functions, but not virtual bases, because the COM mechanism was implemented separately from the dynamic type resolution in the MSVC compiler (it actually predates the C++ standard here).