Has anyone here ever used C++\'s "placement new"? If so, what for? It looks to me like it would only be useful on memory-mapped hardware.You may want to do this for optimizations (it is faster not to re-allocate all the time) but you need to re-construct an object multiple times.  If you need to keep re-allocating it might be more efficient to allocate more than you need, even though you don\'t want to use it yet.  Devex gives a good example:Standard C++ also supports placement\n  new operator, which constructs an\n  object on a pre-allocated buffer. This\n  is useful when building a memory pool,\n  a garbage collector or simply when\n  performance and exception safety are\n  paramount (there\'s no danger of\n  allocation failure since the memory\n  has already been allocated, and\n  constructing an object on a\n  pre-allocated buffer takes less time):You may also want to be sure there can be no allocation failure at a certain part of critical code (maybe you work on a pacemaker for example).  In that case you would want to use placement new. You should not deallocate every object that is using the memory buffer.  Instead you should delete[] only the original buffer.  You would have to then call the destructors directly of your classes manually.  For a good suggestion on this please see Stroustrup\'s FAQ on: Is there a "placement delete"?We use it with custom memory pools. Just a sketch:Now you can cluster objects together in a single memory arena, select an allocator which is very fast but does no deallocation, use memory mapping, and any other semantic you wish to impose by choosing the pool and passing it as an argument to an object\'s placement new operator.It\'s useful if you want to separate allocation from initialization. STL uses placement new to create container elements.I\'ve used it to construct objects allocated on the stack via alloca().shameless plug: I blogged about it here.I\'ve used it in real-time programming. We typically don\'t want to perform any dynamic allocation (or deallocation) after the system starts up, because there\'s no guarantee how long that is going to take. What I can do is preallocate a large chunk of memory (large enough to hold any amount of whatever that the class may require). Then, once I figure out at runtime how to construct the things, placement new can be used to construct objects right where I want them. One situation I know I used it in was to help create a heterogeneous circular buffer.It\'s certainly not for the feint of heart, but that\'s why they make the syntax for it kinda  gnarly.Head Geek: BINGO!  You got it totally - that\'s exactly what it\'s perfect for.  In many embedded environments, external constraints and/or the overall use scenario forces the programmer to separate the allocation of an object from its initialization.  Lumped together, C++ calls this "instantiation"; but whenever the constructor\'s action must be explicitly invoked WITHOUT dynamic or automatic allocation, placement new is the way to do it.  It\'s also the perfect way to locate a global C++ object that is pinned to the address of a hardware component (memory-mapped I/O), or for any static object that, for whatever reason, must reside at a fixed address.I\'ve used it to create a Variant class (i.e. an object that can represent a single value that can be one of a number of different types).If all of the value-types supported by the Variant class are POD types (e.g. int, float, double, bool) then a tagged C-style union is sufficient, but if you want some of the value-types to be C++ objects (e.g. std::string), the C union feature won\'t do, as non-POD datatypes may not be declared as part of a union.So instead I allocate a byte array that is big enough (e.g. sizeof(the_largest_data_type_I_support)) and use placement new to initialize the appropriate C++ object in that area when the Variant is set to hold a value of that type.   (And placement delete beforehand when switching away from a different non-POD data type, of course)It\'s also useful when you want to re-initialize global or statically allocated structures. The old C way was using memset() to set all elements to 0. You cannot do that in C++ due to vtables and custom object constructors.So I sometimes use the followingPlacement new is also very useful when serialising (say with boost::serialization). In 10 years of c++ this is only the second case I\'ve needed placement new for (third if you include interviews :) ).It is useful if you are building a kernel - where do you place the kernel code you read from disk or the pagetable? You need to know where to jump to.Or in other, very rare circumstances such as when you have loads of allocated room and want to place a few structures behind each other. They can be packed this way without the need for the offsetof() operator. There are other tricks for that too, though.I also believe some STL implementations make use of placement new, like std::vector. They allocate room for 2^n elements that way and don\'t need to always realloc.I\'ve used it to create objects based on memory containing messages received from the network.I\'ve seen it used as a slight performance hack for a "dynamic type" pointer (in the section "Under the Hood"):But here is the tricky trick I used to get fast performance for small types: if the value being held can fit inside of a void*, I don\'t actually bother allocating a new object, I force it into the pointer itself using placement new.It\'s used by std::vector<> because std::vector<> typically allocates more memory than there are objects in the vector<>.I\'ve used it for storing objects with memory mapped files.\nThe specific example was an image database which processed vey large numbers of large images (more than could fit in memory).Generally, placement new is used to get rid of allocation cost of a \'normal new\'.  Another scenario where I used it is a place where I wanted to have access to the pointer to an object that was still to be constructed, to implement a per-document singleton.The one place I\'ve run across it is in containers which allocate a contiguous buffer and then fill it with objects as required. As mentioned, std::vector might do this, and I know some versions of MFC CArray and/or CList did this (because that\'s where I first ran across it). The buffer over-allocation method is a very useful optimization, and placement new is pretty much the only way to construct objects in that scenario. It is also used sometimes to construct objects in memory blocks allocated outside of your direct code.I have used it in a similar capacity, although it doesn\'t come up often. It\'s a useful tool for the C++ toolbox, though.Script engines can use it in the native interface to allocate native objects from scripts. See Angelscript (www.angelcode.com/angelscript) for examples.It may be handy when using shared memory, among other uses... For example: http://www.boost.org/doc/libs/1_51_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.conditions.conditions_anonymous_exampleI think this has not been highlighted by any answer, but another good example and usage for the new placement is to reduce the memory fragmentation (by using memory pools). This is specially useful in embedded and high availability systems. In this last case it\'s specially important because for a system that has to run 24/365 days it\'s very important to have no fragmentation. This problem has nothing to do with memory leakage. Even when a very good malloc implementation is used (or similar memory management function) it\'s very difficult to deal with fragmentation for a long time. At some point if you don\'t manage cleverly the memory reservation/release calls you could end up with a lot of small gaps that are difficult to reuse (assign to new reservations). So, one of the solutions that are used in this case is to use a memory pool to allocate before hand the memory for the application objects. After-wards each time you need memory for some object you just use the new placement to create a new object on the already reserved memory. This way, once your application starts you already have all the needed memory reserved. All the new memory reservation/release goes to the allocated pools (you may have several pools, one for each different object class). No memory fragmentation happens in this case since there will no gaps and your system can run for very long periods (years) without suffering from fragmentation. I saw this in practice specially for the VxWorks RTOS since its default memory allocation system suffers a lot from fragmentation. So allocating memory through the standard new/malloc method was basically prohibited in the project. All the memory reservations should go to a dedicated memory pool.See the fp.h file in the xll project at http://xll.codeplex.com It solves the "unwarranted chumminess with the compiler" issue for arrays that like to carry their dimensions around with them.