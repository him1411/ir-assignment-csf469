This is a somewhat bizarre question. My objectives are to understand the language design decision and to identify the possibilities of reflection in C++.Why C++ language committee did not go towards implementing reflection in the language? Is reflection too difficult in a language that does not run on a virtual machine (like java)?If one were to implement reflection for C++, what will be the challenges?I guess the uses of reflection are well-known: editors can be more easily written, program code will be smaller, mocks can be generated for unit tests and so on. But it would be great if you could comment on uses of reflection too.There are several problems with reflection in C++.It\'s a lot of work to add, and the C++ committee is fairly conservative, and don\'t spend time    on radical new features unless they\'re sure it\'ll pay off. (A suggestion for adding a module system similar to .NET assemblies has been made, and while I think there\'s general consensus that it\'d be nice to have, it\'s not their top priority at the moment, and has been pushed back until well after C++0x. The motivation for this feature is to get rid of the #include system, but it would also enable at least some metadata).You don\'t pay for what you don\'t\nuse. That\'s one of the must basic\ndesign philosophies underlying C++.\nWhy should my code carry around\nmetadata if I may never need it?\nMoreover, the addition of metadata\nmay inhibit the compiler from\noptimizing. Why should I pay that\ncost in my code if I may never need\nthat metadata?Which leads us to another big point:\nC++ makes very few guarantees\nabout the compiled code. The\ncompiler is allowed to do pretty\nmuch anything it likes, as long as\nthe resulting functionality is what\nis expected. For example, your\nclasses aren\'t required to actually\nbe there. The compiler can optimize them away, inline\neverything they do, and it\nfrequently does just that, because\neven simple template code tends to\ncreate quite a few template\ninstantiations. The C++ standard\nlibrary relies on this aggressive\noptimization. Functors are only\nperformant if the overhead of\ninstantiating and destructing the\nobject can be optimized away.\noperator[] on a vector is only comparable to raw\narray indexing in performance\nbecause the entire operator can be\ninlined and thus removed entirely\nfrom the compiled code. C# and Java\nmake a lot of guarantees about the\noutput of the compiler. If I define\na class in C#, then that class will\nexist in the resulting assembly.\nEven if I never use it. Even if all\ncalls to its member functions could\nbe inlined. The class has to be\nthere, so that reflection can find\nit. Part of this is alleviated by C#\ncompiling to bytecode, which means\nthat the JIT compiler can remove\nclass definitions and inline\nfunctions if it likes, even if the\ninitial C# compiler can\'t. In C++,\nyou only have one compiler, and it\nhas to output efficient code. If you\nwere allowed to inspect the metadata\nof a C++ executable, you\'d expect to\nsee every class it defined, which\nmeans that the compiler would have\nto preserve all the defined classes,\neven if they\'re not necessary.And then there are templates.\nTemplates in C++ are nothing like\ngenerics in other languages. Every\ntemplate instantiation creates a\nnew type. std::vector<int> is a completely separate class from\nstd::vector<float>. That adds up to\na lot of different types in a entire\nprogram. What should our reflection\nsee? The template std::vector? But\nhow can it, since that\'s a\nsource-code construct, which has no\nmeaning at runtime? It\'d have to see\nthe separate classes\nstd::vector<int> and\nstd::vector<float>. And\nstd::vector<int>::iterator and\nstd::vector<float>::iterator, same\nfor const_iterator and so on. And\nonce you step into template\nmetaprogramming, you quickly end up\ninstantiating hundreds of templates,\nall of which get inlined and removed\nagain by the compiler. They have no\nmeaning, except as part of a\ncompile-time metaprogram. Should all\nthese hundreds of classes be visible\nto reflection? They\'d have to,\nbecause otherwise our reflection\nwould be useless, if it doesn\'t even guarantee that the classes I defined will actually be there. And a side problem is that the template class doesn\'t exist until it is instantiated. Imagine a program which uses std::vector<int>. Should our reflection system be able to see std::vector<int>::iterator? On one hand, you\'d certainly expect so. It\'s an important class, and it\'s defined in terms of std::vector<int>, which does exist in the metadata. On the other hand, if the program never actually uses this iterator class template, its type will never have been instantiated, and so the compiler won\'t have generated the class in the first place. And it\'s too late to create it at runtime, since it requires access to the source code.Edit:\nIn response to comments:cdleary:\nYes, debug symbols do something similar, in that they store metadata about the types used in the executable. But they also suffer from the problems I described. If you\'ve ever tried debugging a release build, you\'ll know what I mean. There are large logical gaps where you created a class in the source code, which has gotten inlined away in the final code. If you were to use reflection for anything useful, you\'d need it to be more reliable and consistent. As it is, types would be vanishing and disappearing almost every time you compile. You change a tiny little detail, and the compiler decides to change which types get inlined and which ones don\'t, as a response. How do you extract anything useful from that, when you\'re not even guaranteed that the most relevant types will be represented in your metadata? The type you were looking for may have been there in the last build, but now it\'s gone. And tomorrow, someone will check in a small innocent change to a small innocent function, which makes the type just big enough that it won\'t get completely inlined, so it\'ll be back again. That\'s still useful for debug symbols, but not much more than that. I\'d hate trying to generate serialization code for a class under those terms.Evan Teran: Of course these issues could be resolved. But that falls back to my point #1. It\'d take a lot of work, and the C++ committee has plenty of things they feel is more important. Is the benefit of getting some limited reflection (and it would be limited) in C++ really big enough to justify focusing on that at the expense of other features? Is there really a huge benefit in adding features the core language which can already (mostly) be done through libraries and preprocessors like QT\'s? Perhaps, but the need is a lot less urgent than if such libraries didn\'t exist.\nFor your specific suggestions though, I believe disallowing it on templates would make it completely useless. You\'d be unable to use reflection on the standard library, for example. What kind of reflection wouldn\'t let you see a std::vector? Templates are a huge part of C++. A feature that doesn\'t work on templates is basically useless.But you\'re right, some form of reflection could be implemented. But it\'d be a major change in the language. As it is now, types are exclusively a compile-time construct. They exist for the benefit of the compiler, and nothing else. Once the code has been compiled, there are no classes. If you stretch yourself, you could argue that functions still exist, but really, all there is is a bunch of jump assembler instructions, and a lot of stack push/pop\'s. There\'s not much to go on, when adding such metadata.But like I said, there is a proposal for changes to the compilation model, adding self-contained modules, storing metadata for select types, allowing other modules to reference them without having to mess with #includes. That\'s a good start, and to be honest, I\'m surprised the standard committee didn\'t just throw the proposal out for being too big a change. So perhaps in 5-10 years? :)Reflection requires some metadata about types to be stored somewhere that can be queried. Since C++ compiles to native machine code and undergoes heavy changes due to optimization, high level view of the application is pretty much lost in the process of compilation, consequently, it won\'t be possible to query them at run time. Java and .NET use a very high level representation in the binary code for virtual machines making this level of reflection possible. In some C++ implementations, however, there is something called Run Time Type Information (RTTI) which can be considered a stripped down version of reflection.All languages should not try to incorporate every feature of every other language.  C++ is essentially a very, very sophisticated macro assembler.  It is NOT (in a traditional sense) a high-level language like C#, Java, Objective-C, Smalltalk, etc.It is good to have different tools for different jobs.  If we only have hammers, all things are going to look like nails, etc.  Having script languages is useful for some jobs, and reflective OO-languages (Java, Obj-C, C#) are useful for another class of jobs, and super-efficient bare-bones close-to-the-machine languages are useful for yet another class of jobs (C++, C, Assembler).C++ does an amazing job of extending Assembler technology to incredible levels of complexity management, and abstractions to make programming larger, more complex tasks vastly more possible for human beings.  But it is not necessarily a language that is the best suited for those who are approaching their problem from a strictly high-level perspective (Lisp, Smalltalk, Java, C#).  If you need a language with those features to best implement a solution to your problems, then thank those who\'ve created such languages for all of us to use!But C++ is for those who, for whatever reason(s), need to have a strong correlation between their code and the underlying machine\'s operation.  Whether its efficiency, or programming device drivers, or interaction with the lower-level OS services, or whatever, C++ is better suited to those tasks.  C#, Java, Objective-C all require a much larger, richer runtime system to support their execution.  That runtime has to be delivered to the system in question - preinstalled to support the operation of your software.  And that layer has to be maintained for various target systems, customized by SOME OTHER LANGUAGE to make it work on that platform.  And that middle layer - that adaptive layer between the host OS and the your code - the runtime, is almost always written in a language like C or C++ where efficiency is #1, where understanding predictably the exact interaction between software and hardware can be well understood, and manipulated to maximum gain.I love Smalltalk, Objective-C, and having a rich runtime system with reflection, meta-data, garbage collection, etc.  Amazing code can be written to take advantage of these facilities!  But that\'s simply a higher layer on the stack, a layer that must rest on lower layers, that themselves must ultimately sit upon the OS and the hardware.  And we will always need a language that is best suited for building that layer: C++/C/Assembler.Addendum: C++11/14 are continuing to expand C++ ability to support higher-level abstractions and systems.  Threading, synchronization, precise memory models, more precise abstract machine definitions are enabling C++ developers to achieve many of the high-level abstractions that some of these high-level only languages used to have exclusive domain over, while continuing to provide close-to-metal performance and excellent predictability (i.e minimal runtime subsystems).  Perhaps reflection facilities will be selectively enabled in a future revision of C++, for those who want it - or perhaps a library will provide such runtime services (maybe there is one now, or the beginnings of one in boost?). If you really want to understand the design decisions surrounding C++, find a copy of the The Annotated C++ Reference Manual by Ellis and Stroustrup. It\'s NOT up to date with the latest standard, but it goes through the original standard and explains how things work and often, how they got that way.Reflection can be and has been implemented in c++ before.It is not a native c++ feature because it have an heavy cost (memory and speed) that should\'nt be set by default by the language - the language is "maximum performance by default" oriented.As you shouldn\'t pay for what you don\'t need, and as yous say yourself it\'s needed more in editors than in other applications, then it should be implemented only where you need it, and not "forced" to all the code (you don\'t need reflection on all the data you\'ll work with in a editor or other similar application).Reflection for languages that have it is about how much of the source code the compiler is willing to leave in your object code to enable reflection, and how much analysis machinery is available to interpret that reflected information.  Unless the compiler keeps all the source code around, reflection will be limited in its ability to analyze the available facts about the source code.  The C++ compiler doesn\'t keep anything around (well, ignoring RTTI), so you don\'t get reflection in the language.  (Java and C# compilers only keep class, method names and return types around, so you get a little bit of reflection data, but you can\'t inspect expressions or program structure, and that means even in those "reflection-enabled" languages the information you can get is pretty sparse and consequently you really can\'t do much analysis).But you can step outside the language and get full reflection capabilities.  The answer to another stack overflow discussion on reflection in C discusses this.The reason C++ doesn\'t have reflection is that this would require the compilers to add symbol information to the object files, like what members a class type has, information about the members, about the functions and everything. This essentially would render include files useless, as information shipped by declarations would then be read from those object files (modules then). In C++, a type definition can occur multiple times in a program by including the respective headers (provided that all those definitions are the same), so it would have to be decided where to put the information about that type, just as to name one complication here. The aggressive optimization done by a C++ compiler, which can optimize out dozens of class template instantiations, is another strong point. It\'s possible, but as C++ is compatible to C, this would become an awkward combination. There are tons of cases for using reflection in C++ that cannot be adequately addressed using compile time constructs like template meta-programming.N3340 proposes rich pointers as a way to introduce reflection in C++. Among other things it addresses the issue of not paying for a feature unless you use it.Reflection  could be optional, like a  preprocessor directive. Something like#pragma enable reflection That way we can have the best of both worlds,  with out this pragma  libraries would be created without reflection (without any overheads  as discussed), then it would be up the individual  developer whether they want speed or ease of use.  According to Alistair Cockburn, subtyping can\'t be guaranteed in a reflective environment.Reflection is more relevant to latent typing systems.  In C++, you know what type you\'ve got and you know what you can do with it.If C++ could have:That would be enough to create very easy to use libraries at the crux of the typeless data processing that is so prevalent in today\'s web and database applications\n(all the orms, messaging mechanisms, xml/json parsers, data serialization, etc).For example, the basic information supported by the Q_PROPERTY macro (part of Qt Framework)\nhttp://qt.nokia.com/doc/4.5/properties.html expanded to cover class methods and e) - would be extraordinary beneficial to C++ and to the software community in general.Certainly the reflection I am referring to would not cover the semantic meaning or more complex issues (like comments source code line numbers, data flow analysis, etc) - but neither do I think those are needed to be part of a language standard.some good links on reflection in C++ I just found:Working Paper of C++ Standard: Aspects of Reflection in C++A simple example of reflection using templatesReflection in C++ , I believe is crucially important if C++ is to be used as a language for Database Access, Web session handling/http and GUI development.  The lack of reflection prevents ORMs (like Hibernate or LINQ),   XML and JSON parsers that instancinate classes,  Data serialization and many other thigns (where initially typeless data has to be used to create an instance of a class).A compile time switch available to a software developer during the build process can be used\nto eliminate this \'you pay for what you use\' concern.I a firmwaredeveloper does not need the reflection to read data from a serial port -- then fine do not use the switch.  But as a database developer who wants to keep using C++ I am constantly phased with a horrible, difficult to maintain code that maps Data between data members and database constructs.Neither Boost serialization nor other mechanism are really solving the reflection -- it must be done by the compiler -- and once it is done C++ will be again tought in schools and used in software that are dealing with data processingTo me this issue #1  (and naitive threading primitives is issue #2).It is basically because it is an "optional extra". Many people choose C++ over languages like Java and C# so that they have more control over the compiler output, e.g. a smaller, and/or faster program.If you choose to add reflection there are various solutions available.