I\'m looking for any manner of accessing the "parent" scope within a directive.  Any combination of scope, transclude, require, passing in variables (or the scope itself) from above, etc.  I\'m totally willing to bend over backwards, but I want to avoid something totally hacky or unmaintainable.  For example, I know I could do it right now by taking the $scope from the preLink parameters and iterating over it\'s $sibling scopes to find the conceptual "parent".What I really want is to be able to $watch an expression in the parent scope.  If I can do that, then I can accomplish what I\'m trying to do over here: \nAngularJS - How to render a partial with variables?An important note is that the directive must be re-usable within the same parent scope.  Therefore the default behavior (scope: false) doesn\'t work for me.  I need an individual scope per instance of the directive, and then I need to $watch a variable that lives in the parent scope.A code sample is worth 1000 words, so:See What are the nuances of scope prototypal / prototypical inheritance in AngularJS?To summarize: the way a directive accesses its parent ($parent) scope depends on the type of scope the directive creates:default (scope: false) - the directive does not create a new scope, so there is no inheritance here.  The directive\'s scope is the same scope as the parent/container.  In the link function, use the first parameter (typically scope).scope: true - the directive creates a new child scope that prototypically inherits from the parent scope.  Properties that are defined on the parent scope are available to the directive scope (because of prototypal inheritance).  Just beware of writing to a primitive scope property -- that will create a new property on the directive scope (that hides/shadows the parent scope property of the same name).scope: { ... } - the directive creates a new isolate/isolated scope.  It does not prototypically inherit the parent scope.  You can still access the parent scope using $parent, but this is not normally recommended.  Instead, you should specify which parent scope properties (and/or function) the directive needs via additional attributes on the same element where the directive is used, using the =, @, and & notation.transclude: true - the directive creates a new "transcluded" child scope, which prototypically inherits from the parent scope.  If the directive also creates an isolate scope, the transcluded and the isolate scopes are siblings.  The $parent property of each scope references the same parent scope.Angular v1.3 update: If the directive also creates an isolate scope, the transcluded scope is now a child of the isolate scope.  The transcluded and isolate scopes are no longer siblings.  The $parent property of the transcluded scope now references the isolate scope.The above link has examples and pictures of all 4 types.You cannot access the scope in the directive\'s compile function (as mentioned here: https://github.com/angular/angular.js/wiki/Understanding-Directives).  You can access the directive\'s scope in the link function.Watching:For 1. and 2. above: normally you specify which parent property the directive needs via an attribute, then $watch it:If you are watching an object property, you\'ll need to use $parse:For 3. above (isolate scope), watch the name you give the directive property using the @ or = notation:Accessing controller method means accessing a method on parent scope from directive controller/link/scope.If the directive is sharing/inheriting the parent scope then it is quite straight forward to just invoke a parent scope method.Little more work is required when you want to access parent scope method from Isolated directive scope.There are few options (may be more than listed below) to invoke a parent scope method from isolated directives scope or watch parent scope variables (option#6 specially).Note that I used link function in these examples but you can use a directive controller as well based on requirement.Option#1. Through Object literal and from directive html templateindex.htmlitemfilterTemplate.htmlapp.jsworking plnkr: http://plnkr.co/edit/rgKUsYGDo9O3tewL6xgr?p=previewOption#2. Through Object literal and from directive link/scopeindex.htmlitemfilterTemplate.htmlapp.jsworking plnkr: http://plnkr.co/edit/BRvYm2SpSpBK9uxNIcTa?p=previewOption#3. Through Function reference and from directive html templateindex.htmlitemfilterTemplate.htmlapp.jsworking plnkr: http://plnkr.co/edit/Jo6FcYfVXCCg3vH42BIz?p=previewOption#4. Through Function reference and from directive link/scopeindex.htmlitemfilterTemplate.htmlapp.jsworking plnkr: http://plnkr.co/edit/BSqx2J1yCY86IJwAnQF1?p=previewOption#5: Through ng-model and two way binding, you can update parent scope variables.. So, you may not require to invoke parent scope functions in some cases.index.htmlitemfilterTemplate.htmlapp.jsworking plnkr: http://plnkr.co/edit/hNui3xgzdTnfcdzljihY?p=previewOption#6: Through $watch and $watchCollection \nIt is two way binding for items in all above examples, if items are modified in parent scope, items in directive would also reflect the changes.If you want to watch other attributes or objects from parent scope, you can do that using $watch and $watchCollection as given belowhtmlscript app.jsvar app = angular.module(\'plunker\', []);You can always refer AngularJs documentation for detailed explanations about directives.and you will have the same scope(with parent element)There are a lot of ways how to access parent scope depending on this two options scope& transclude. Here\'s a trick I used once: create a "dummy" directive to hold the parent scope and place it somewhere outside the desired directive. Something like:and thenMaybe not the most graceful solution, but it got the job done.If you are using ES6 Classes and ControllerAs syntax, you need to do something slightly different.See the snippet below and note that vm is the ControllerAs value of the parent Controller as used in the parent HTMLHaving tried everything, I finally came up with a solution.Just place the following in your template:{{currentDirective.attr = parentDirective.attr; \'\'}}It just writes the parent scope attribute/variable you want to access to the current scope. Also notice the ; \'\' at the end of the statement, it\'s to make sure there\'s no output in your template. (Angular evaluates every statement, but only outputs the last one).It\'s a bit hacky, but after a few hours of trial and error, it does the job.