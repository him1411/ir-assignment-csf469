What is the proper way to use **kwargs in Python when it comes to default values?kwargs returns a dictionary, but what is the best way to set default values, or is there one?  Should I just access it as a dictionary?  Use get function?  A simple question, but one that I can\'t find good resources on.  People do it different ways in code that I\'ve seen and it\'s hard to know what to use.You can pass a default value to get() for keys that are not in the dictionary:However, if you plan on using a particular argument with a particular default value, why not use named arguments in the first place?While most answers are saying that, e.g.,is "the same as"this is not true.  In the latter case, f can be called as f(23, 42), while the former case accepts named arguments only -- no positional calls.  Often you want to allow the caller maximum flexibility and therefore the second form, as most answers assert, is preferable: but that is not always the case.  When you accept many optional parameters of which typically only a few are passed, it may be an excellent idea (avoiding accidents and unreadable code at your call sites!) to force the use of named arguments -- threading.Thread is an example.  The first form is how you implement that in Python 2.The idiom is so important that in Python 3 it now has special supporting syntax: every argument after a single * in the def signature is keyword-only, that is, cannot be passed as a positional argument, but only as a named one. So in Python 3 you could code the above as:Indeed, in Python 3 you can even have keyword-only arguments that aren\'t optional (ones without a default value).However, Python 2 still has long years of productive life ahead, so it\'s better to not forget the techniques and idioms that let you implement in Python 2 important design ideas that are directly supported in the language in Python 3!I suggest something like thisAnd then use the values any way you wantdictionaryA.update(dictionaryB) adds the contents of dictionaryB to dictionaryA overwriting any duplicate keys.You\'d doorIf you use pop, then you can check if there are any spurious values sent, and take the appropriate action (if any).Using **kwargs and default values is easy.  Sometimes, however, you shouldn\'t be using **kwargs in the first place.In this case, we\'re not really making best use of **kwargs.The above is a "why bother?" declaration.  It is the same asWhen you\'re using **kwargs, you mean that a keyword is not just optional, but conditional.  There are more complex rules than simple default values.When you\'re using **kwargs, you usually mean something more like the following, where simple defaults don\'t apply.Since **kwargs is used when the number of arguments is unknown, why not doing this?Here\'s another approach:You could do something like thisFollowing up on @srhegde suggestion of using setattr:This variant is useful when the class is expected to have all of the items in our acceptable list.I think the proper way to use **kwargs in Python when it comes to default values is to use the dictionary method setdefault, as given below:In this way, if a user passes \'val\' or \'val2\' in the keyword args, they will be used; otherwise, the default values that have been set will be used.If you want to combine this with *args you have to keep *args and **kwargs at the end of the definition.So:@AbhinavGupta and @Steef suggested using update(), which I found very helpful for processing large argument lists:What if we want to check that the user hasn\'t passed any spurious/unsupported arguments? @VinaySajip pointed out that pop() can be used to iteratively process the list of arguments. Then, any leftover arguments are spurious. Nice.Here\'s another possible way to do this, which keeps the simple syntax of using update():unknown_args is a set containing the names of arguments that don\'t occur in the defaults.