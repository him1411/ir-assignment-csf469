What\'s the simplest, library-free code for implementing array intersections in javascript? I want to writeand getDestructive seems simplest, especially if we can assume the input is sorted:Non-destructive has to be a hair more complicated, since we\xe2\x80\x99ve got to track indices:.filter the first array for elements that are also included in the second!If your environment supports ECMAScript 6 Set, one simple and supposedly efficient (see specification link) way:Shorter, but less readable (also without creating the additional intersection Set):Note that the set implementation will only allow unique values, thus new Set[1,2,3,3].size evaluates to 3.Using  Underscore.js How about just using associative arrays?edit:I wish to add here this method also The performance of @atk\'s implementation for sorted arrays of primitives can be improved by using .pop rather than .shift.I created a benchmark using jsPerf: http://bit.ly/P9FrZK.  It\'s about three times faster to use .pop.Something like this, Not tested well though.PS:The algorithm only intended for Numbers and Normal Strings, intersection of arbitary object arrays may not work. My contribution in ES6 terms. In general it finds the intersection of an array with indefinite number of arrays provided as arguments.For arrays containing only strings or numbers you can do something with sorting, as per some of the other answers. For the general case of arrays of arbitrary objects I don\'t think you can avoid doing it the long way. The following will give you the intersection of any number of arrays provided as parameters to arrayIntersection:A tiny tweak to the smallest one here (the filter/indexOf solution), namely creating an index of the values in one of the arrays using a JavaScript object, will reduce it from O(N*M) to "probably" linear time. source1 source2This isn\'t the very simplest solution (it\'s more code than filter+indexOf), nor is it the very fastest (probably slower by a constant factor than intersect_safe()), but seems like a pretty good balance. It is on the very simple side, while providing good performance, and it doesn\'t require pre-sorted inputs.It\'s pretty short using ES2015 and Sets. Accepts Array-like values like a String and removes duplicates.With some restrictions on your data, you can do it in linear time!For positive integers: use an array mapping the values to a "seen/not seen" boolean.There is a similar technique for objects: take a dummy key, set it to "true" for each element in array1, then look for this key in elements of array2. Clean up when you\'re done.Of course you need to be sure the key didn\'t appear before, otherwise you\'ll be destroying your data... Another indexed approach able to process any number of arrays at once:It works only for values that can be evaluated as strings and you should pass them as an array like:...but it transparently accepts objects as parameter or as any of the elements to be intersected (always returning array of common values). Examples:EDIT: I just noticed that this is, in a way, slightly buggy.That is: I coded it thinking that input arrays cannot itself contain repetitions (as provided example doesn\'t).But if input arrays happen to contain repetitions, that would produce wrong results. Example (using below implementation):Fortunately this is easy to fix by simply adding second level indexing. That is:Change:by:...and:by:Complete example:I recommend above succinct solution which outperforms other implementations on large inputs. If performance on small inputs matters, check the alternatives below.Alternatives and performance comparison:See the following snippet for alternative implementations and check https://jsperf.com/array-intersection-comparison for performance comparisons.Results in Firefox 53:Ops/sec on large arrays (10,000 elements):Ops/sec on small arrays (100 elements):I\'ll contribute with what has been working out best for me:"indexOf" for IE 9.0, chrome, firefox, opera, For simplicity:Benefits:Drawbacks:You wouldn\'t want to use this for 3D engine or kernel work, but if you have problems getting this to run in an event-based app, your design has bigger problems.Here is underscore.js implementation:Source: http://underscorejs.org/docs/underscore.html#section-62A functional approach must consider using only pure functions without side effects, each of which is only concerned with a single job.These restrictions enhance the composability and reusability of the functions involved.Please note that the native Set type is used, which has an advantageous\nlookup performance.Obviously repeatedly occurring items from the first Array are preserved, while the second Array is de-duplicated. This may be or may be not the desired behavior. If you need a unique result just apply dedupe to the first argument:If you want to compute the intersection of an arbitrarily number of Arrays just compose intersect with foldl. Here is a convenience function:Here\'s a very naive implementation I\'m using. It\'s non-destructive and also makes sure not to duplicate entires.intersection of N arrays in coffeescriptI extended tarulen\'s answer to work with any number of arrays. It also should work with non-integer values.Building on Anon\'s excellent answer, this one returns the intersection of two or more arrays.Hope this Helps for all versions..reduce to build a map, and .filter to find the intersection. delete within the .filter allows us to treat the second array as though it\'s a unique set.I find this approach pretty easy to reason about. It performs in constant time.not about efficiency, but easy to follow, here is an example of unions and intersections of sets, it handles arrays of sets and sets of sets.http://jsfiddle.net/zhulien/NF68T/