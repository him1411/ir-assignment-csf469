What is a StackOverflowError, what causes it, and how should I deal with them?Parameters and local variables are allocated on the stack (with reference types the object lives on the heap and a variable references that object). The stack typically lives at the upper end of your address space and as it is used up it heads towards the bottom of the address space (i.e. towards zero).Your process also has a heap, which lives at the bottom end of your process. As you allocate memory, this heap can grow towards the upper end of your address space. As you can see, there is a potential for the heap to "collide" with the stack (a bit like tectonic plates!!!).The common cause for a stack overflow is a bad recursive call. Typically, this is caused when your recursive functions doesn\'t have the correct termination condition, so it ends up calling itself forever. However, with GUI programming, it\'s possible to generate indirect recursion. For example, your app may be handling paint messages, and, whilst processing them, it may call a function that causes the system to send another paint message. Here you\'ve not explicitly called yourself, but the OS/VM has done it for you.To deal with them you\'ll need to examine your code. If you\'ve got functions that call themselves then check that you\'ve got a terminating condition. If you have then check than when calling the function you have at least modified one of the arguments, otherwise there\'ll be no visible change for the recursively called function and the terminating condition is useless.If you\'ve got no obvious recursive functions then check to see if you\'re calling any library functions that indirectly will cause your function to be called (like the implicit case above).If you have a function like:Then foo() will keep calling itself, getting deeper and deeper, and when the space used to keep track of what functions you\'re in is filled up, you get the stack overflow error.To describe this, first Let us understand how local variable and object are stored,\nLocal variable are stored in stack\nif you look at the image you should be able to understand how things are working.When a function call is invoked by a Java application, a stack frame is allocated on the call stack. The stack frame contains the parameters of the invoked method, its local parameters, and the return address of the method. The return address denotes the execution point from which, the program execution shall continue after the invoked method returns. If there is no space for a new stack frame then, the StackOverflowError is thrown by the Java Virtual Machine (JVM).\nThe most common case that can possibly exhaust a Java application\xe2\x80\x99s stack is recursion. In recursion, a method invokes itself during its execution. Recursion is considered as a powerful general-purpose programming technique, but must be used with caution, in order for the StackOverflowError to be avoided.\nAn example that throws a StackOverflowError is shown below:StackOverflowErrorExample.java:In this example, we define a recursive method, called recursivePrint that prints an integer and then, calls itself, with the next successive integer as an argument. The recursion ends once we invoke the method, passing 0 as a parameter. However, in our example, we start printing numbers from 1 and thus, the recursion will never terminate.\nA sample execution, using the -Xss1M flag that specifies the size of the thread stack to equal to 1MB, is shown below:Depending on the JVM\xe2\x80\x99s initial configuration, the results may differ, but eventually the StackOverflowError shall be thrown. This example is a very good example of how recursion can cause problems, if not implemented with caution.How to deal with the StackOverflowErrorThe simplest solution is to carefully inspect the stack trace and\ndetect the repeating pattern of line numbers. These line numbers\nindicate the code being recursively called. Once you detect these\nlines, you must carefully inspect your code and understand why the\nrecursion never terminates. If you have verified that the recursion\n    is implemented correctly, you can increase the stack\xe2\x80\x99s size, in\n    order to allow a larger number of invocations. Depending on the Java\n    Virtual Machine (JVM) installed, the default thread stack size may\n    equal to either 512KB, or 1MB. You can increase the thread stack\n    size using the -Xss flag. This flag can be specified either via the\n    project\xe2\x80\x99s configuration, or via the command line. The format of the\n    -Xss argument is:\n    -Xss[g|G|m|M|k|K]Stack overflow means exactly that: a stack overflows. Usually there\'s a one stack in the program that contains local-scope variables and addresses where to return when execution of a routine ends. That stack tends to be a fixed memory range somewhere in the memory, therefore it\'s limited how much it can contain values.If the stack is empty you can\'t pop, if you do you\'ll get stack underflow error.If the stack is full you can\'t push, if you do you\'ll get stack overflow error.So stack overflow appears where you allocate too much into the stack. For instance, in the mentioned recursion.Some implementations optimize out some forms of recursions. Tail recursion in particular. Tail recursive routines are form of routines where the recursive call appears as a final thing what the routine does. Such routine call gets simply reduced into a jump.Some implementations go so far as implement their own stacks for recursion, therefore they allow the recursion to continue until the system runs out of memory.Easiest thing you could try would be to increase your stack size if you can. If you can\'t do that though, the second best thing would be to look whether there\'s something that clearly causes the stack overflow. Try it by printing something before and after the call into routine. This helps you to find out the failing routine.A stack overflow is usually called by nesting function calls too deeply (especially easy when using recursion, i.e. a function that calls itself) or allocating a large amount of memory on the stack where using the heap would be more appropriate.Like you say, you need to show some code. :-)A stack overflow error usually happens when your function calls nest too deeply. See the Stack Overflow Code Golf thread for some examples of how this happens (though in the case of that question, the answers intentionally cause stack overflow).The most common cause of stack overflows is excessively deep or infinite recursion. If this is your problem, this tutorial about Java Recursion could help understand the problem.Following would give StackOverflowError:Here is an example of a recursive algorithm for reversing a singly linked list. On a laptop  with the following spec (4G memory, Intel Core i5 2.3GHz CPU, 64 bit Windows 7), this function will run into StackOverflow error for a linked list of size close to 10,000. My point is that we should use recursion judiciously, always taking into account of the scale of the system.\nOften recursion can be converted to iterative program, which scales better. (One iterative version of the same algorithm is given at the bottom of the page, it reverses a singly linked list of size 1 million in 9 milliseconds.)Iterative Version of the Same Algorithm:The term "stack overrun (overflow)" is often used but a misnomer; attacks do not overflow the stack but buffers on the stack.StackOverflowError in a runtime error in java. It is thrown when an application recurses too deeply. Whenever the method execution happens a call stack with limited amount of memory location is assigned. This amount of memory is allocated by JVM. Based upon the number of the method execution the size of the call stack grows and srinks. In most of the cases StackOverError is thrown when call stack exceeds because of excessive deep or infinite recursion. Durning which the need to store the local variable in the method exceeds the allocated stack size. In such a StackOverFlowError occurs. It is shown in the program below: Here we had implemented factorial using recursion in java. The code works fine when the positive number is passed as argument to "factorial" method. But the problem occurs when the we provide negative number as argument. In such a case the recursion will never go to the exit condition resulting in stack overflow and it will throw this exception.In the above case it can be avoided doing programmatic changes. \nBut if the program logic it correct and still it occurs then you stack size needs to be increase You can increase the stack size by using -Xss4m.Here\'s an exampleA StackOverflowError basically is when you try to do something, that most likely calls itself, and goes on for infinity (or until it gives a StackOverflowError).add5(a) will call itself, and then call itself again, and so on.