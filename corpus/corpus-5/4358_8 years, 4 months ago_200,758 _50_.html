Using Linq on collections, what is the difference between the following lines of code?andUpdate 1When I disassemble .Exists it looks like there is no code.Update 2Anyone know why there is not code there for this one?See documentationList.Exists (Object method - MSDN)Determines whether the List(T) contains elements that match the conditions defined by the specified predicate.This exists since .NET 2.0, so before LINQ. Meant to be used with the Predicate delegate, but lambda expressions are backward compatible. Also, just List has this (not even IList)IEnumerable.Any (Extension method - MSDN)\nIEnumerable.Any (Extension method - StackÂ Overflow Docs)  Determines whether any element of a sequence satisfies a condition.This is new in .NET 3.5 and uses Func(TSource, bool) as argument, so this was intended to be used with lambda expressions and LINQ.In behaviour, these are identical.The difference is that Any is an extension method for any IEnumerable<T> defined on System.Linq.Enumerable.  It can be used on any IEnumerable<T> instance.  Exists does not appear to be an extension method.  My guess is that coll is of type List<T>.  If so Exists is an instance method which functions very similar to Any.  In short, the methods are essentially the same.  One is more general than the other.TLDR; Performance-wise Any seems to be slower (if I have set this up properly to evaluate both values at almost same time)testing list generator:With 10M records" Any: 00:00:00.3770377 Exists: 00:00:00.2490249"With 5M records" Any: 00:00:00.0940094 Exists: 00:00:00.1420142"With 1M records" Any: 00:00:00.0180018 Exists: 00:00:00.0090009"With 500k, (I also flipped around order in which they get evaluated to see if there is no additional operation associated with whichever runs first.)" Exists: 00:00:00.0050005 Any: 00:00:00.0100010"With 100k records" Exists: 00:00:00.0010001 Any: 00:00:00.0020002"It would seem Any to be slower by magnitude of 2.Edit: For 5 and 10M records I changed the way it generates the list and Exists suddenly became slower than Any which implies there\'s something wrong in the way I am testing.New testing mechanism:Edit2: Ok so to eliminate any influence from generating test data I wrote it all to file and now read it from there.10M " Any: 00:00:00.1640164 Exists: 00:00:00.0750075" 5M" Any: 00:00:00.0810081 Exists: 00:00:00.0360036"1M" Any: 00:00:00.0190019 Exists: 00:00:00.0070007"500k" Any: 00:00:00.0120012 Exists: 00:00:00.0040004"Additionally, this will only work if Value is of type bool. Normally this is used with predicates. Any predicate would be generally used find whether there is any element satisfying a given condition. Here you\'re just doing a map from your element i to a bool property. It will search for an "i" whose Value property is true. Once done, the method will return true.As a continuation on Matas\' answer on benchmarking.TL/DR: Exists() and Any() are equally fast.First off: Benchmarking using Stopwatch is not precise (see series0ne\'s answer on a different, but similiar, topic), but it is far more precise than DateTime.The way to get really precise readings is by using Performance Profiling. But one way to get a sense of how the two methods\' performance measure up to each other is by executing both methods loads of times and then comparing the fastest execution time of each. That way, it really doesn\'t matter that JITing and other noise gives us bad readings (and it does), because both executions are "equally misguiding" in a sense.After executing the above code 4 times (which in turn do 1 000 Exists() and Any() on a list with 1 000 000 elements), it\'s not hard to see that the methods are pretty much equally fast.There is a slight difference, but it\'s too small a difference to not be explained by background noise. My guess would be that if one would do 10 000 or 100 000 Exists() and Any() instead, that slight difference would disappear more or less.When you correct the measurements - as mentioned above: Any and Exists, and adding average - we\'ll get following output: 