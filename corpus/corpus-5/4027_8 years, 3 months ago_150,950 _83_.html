If I want to create a URL using a variable I have two choices to encode the string. urlencode() and rawurlencode().What exactly are the differences and which is preferred?It will depend on your purpose. If interoperability with other systems is important then it seems rawurlencode is the way to go. The one exception is legacy systems which expect the query string to follow form-encoding style of spaces encoded as + instead of %20 (in which case you need urlencode).rawurlencode follows RFC 1738 prior to PHP 5.3.0 and RFC 3986 afterwards (see http://us2.php.net/manual/en/function.rawurlencode.php)Returns a string in which all non-alphanumeric characters except -_.~ have been replaced with a percent (%) sign followed by two hex digits. This is the encoding described in \xc2\xbb RFC 3986 for protecting literal characters from being interpreted as special URL delimiters, and for protecting URLs from being mangled by transmission media with character conversions (like some email systems). Note on RFC 3986 vs 1738. rawurlencode prior to php 5.3 encoded the tilde character (~) according to RFC 1738. As of PHP 5.3, however, rawurlencode follows RFC 3986 which does not require encoding tilde characters.urlencode encodes spaces as plus signs (not as %20 as done in rawurlencode)(see http://us2.php.net/manual/en/function.urlencode.php)Returns a string in which all non-alphanumeric characters except -_. have been replaced with a percent (%) sign followed by two hex digits and spaces encoded as plus (+) signs. It is encoded the same way that the posted data from a WWW form is encoded, that is the same way as in application/x-www-form-urlencoded media type. This differs from the \xc2\xbb RFC 3986 encoding (see rawurlencode()) in that for historical reasons, spaces are encoded as plus (+) signs. This corresponds to the definition for application/x-www-form-urlencoded in RFC 1866.Additional Reading:You may also want to see the discussion at http://bytes.com/groups/php/5624-urlencode-vs-rawurlencode.Also, RFC 2396 is worth a look. RFC 2396 defines valid URI syntax. The main part we\'re interested in is from 3.4 Query Component: Within a query component, the characters ";", "/", "?", ":", "@",\n      "&", "=", "+", ",", and "$" are reserved.As you can see, the + is a reserved character in the query string and thus would need to be encoded as per RFC 3986 (as in rawurlencode).Proof is in the source code of PHP.I\'ll take you through a quick process of how to find out this sort of thing on your own in the future any time you want. Bear with me, there\'ll be a lot of C source code you can skim over (I explain it). If you want to brush up on some C, a good place to start is our SO wiki.Download the source (or use http://lxr.php.net/ to browse it online), grep all the files for the function name, you\'ll find something such as this:PHP 5.3.6 (most recent at time of writing) describes the two functions in their native C code in the file url.c.RawUrlEncode()UrlEncode()Okay, so what\'s different here?They both are in essence calling two different internal functions respectively: php_raw_url_encode and php_url_encodeSo go look for those functions!One quick bit of knowledge before I move forward, EBCDIC is another character set, similar to ASCII, but a total competitor. PHP attempts to deal with both. But basically, this means byte EBCDIC 0x4c byte isn\'t the L in ASCII, it\'s actually a <. I\'m sure you see the confusion here.Both of these functions manage EBCDIC if the web server has defined it.Also, they both use an array of chars (think string type) hexchars look-up to get some values, the array is described as such:Beyond that, the functions are really different, and I\'m going to explain them in ASCII and EBCDIC.URLENCODE:RAWURLENCODE:Note: Many programmers have probably never seen a for loop iterate this way, it\'s somewhat hackish and not the standard convention used with most for-loops, pay attention, it assigns x and y, checks for exit on len reaching 0, and increments both x and y. I know, it\'s not what you\'d expect, but it\'s valid code.Differences:They basically iterate differently, one assigns a + sign in the event of ASCII 20.URLENCODE:RAWURLENCODE:Disclaimer: I haven\'t touched C in years, and I haven\'t looked at EBCDIC in a really really long time. If I\'m wrong somewhere, let me know.Based on all of this, rawurlencode is the way to go most of the time. As you see in Jonathan Fingland\'s answer, stick with it in most cases. It deals with the modern scheme for URI components, where as urlencode does things the old school way, where + meant "space."If you\'re trying to convert between the old format and new formats, be sure that your code doesn\'t goof up and turn something that\'s a decoded + sign into a space by accidentally double-encoding, or similar "oops" scenarios around this space/20%/+ issue.If you\'re working on an older system with older software that doesn\'t prefer the new format, stick with urlencode, however, I believe %20 will actually be backwards compatible, as under the old standard %20 worked, just wasn\'t preferred. Give it a shot if you\'re up for playing around, let us know how it worked out for you.Basically, you should stick with raw, unless your EBCDIC system really hates you. Most programmers will never run into EBCDIC on any system made after the year 2000, maybe even 1990 (that\'s pushing, but still likely in my opinion).yieldswhileyieldsThe difference being the asd%20asd vs asd+asdurlencode differs from RFC 1738 by encoding spaces as + instead of %20One practical reason to choose one over the other is if you\'re going to use the result in another environment, for example JavaScript.In PHP urlencode(\'test 1\') returns \'test+1\' while rawurlencode(\'test 1\') returns \'test%201\' as result.But if you need to "decode" this in JavaScript using decodeURI() function then decodeURI("test+1") will give you "test+1" while decodeURI("test%201") will give you "test 1" as result.In other words the space (" ") encoded by urlencode to plus ("+") in PHP will not be properly decoded by decodeURI in JavaScript.In such cases the rawurlencode PHP function should be used.I believe spaces must be encoded as:The following example shows the correct use of rawurlencode and urlencode:Output:What happens if you encode path and query string components the other way round? For the following example:The difference is in the return values, i.e:urlencode():Returns a string in which all\n  non-alphanumeric characters except -_.\n  have been replaced with a percent (%)\n  sign followed by two hex digits and\n  spaces encoded as plus (+) signs. It\n  is encoded the same way that the\n  posted data from a WWW form is\n  encoded, that is the same way as in\n  application/x-www-form-urlencoded\n  media type. This differs from the \xc2\xbb\n  RFC 1738 encoding (see rawurlencode())\n  in that for historical reasons, spaces\n  are encoded as plus (+) signs.rawurlencode():Returns a string in which all\n  non-alphanumeric characters except -_.\n  have been replaced with a percent (%)\n  sign followed by two hex digits. This\n  is the encoding described in \xc2\xbb RFC\n  1738 for protecting literal characters\n  from being interpreted as special URL\n  delimiters, and for protecting URLs\n  from being mangled by transmission\n  media with character conversions (like\n  some email systems).The two are very similar, but the latter (rawurlencode) will replace spaces with a \'%\' and two hex digits, which is suitable for encoding passwords or such, where a \'+\' is not e.g.:The only difference is in the way spaces are treated:urlencode - based on legacy implementation converts spaces to +rawurlencode - based on RFC 1738 translates spaces to %20The reason for the difference is because + is reserved and valid (unencoded) in urls.  I\'d really like to see some reasons for choosing one over the other ... I want to be able to just pick one and use it forever with the least fuss.Fair enough, I have a simple strategy that I follow when making these decisions which I will share with you in the hope that it may help.I think it was the HTTP/1.1 specification RFC 2616 which called for "Tolerant applications" Clients SHOULD be tolerant in parsing the Status-Line and servers\n     tolerant when parsing the Request-Line.When faced with questions like these the best strategy is always to consume as much as possible and produce what is standards compliant.So my advice is to use rawurlencode to produce standards compliant RFC 1738 encoded strings and use urldecode to be backward compatible and accomodate anything you may come across to consume.Now you could just take my word for it but lets prove it shall we...It would appear that PHP had exactly this in mind, even though I\'ve never come across anyone refusing either of the two formats, I cant think of a better strategy to adopt as your defacto strategy, can you? nJoy!urlencode: This differs from the\n  \xc2\xbb RFC 1738 encoding (see\n  rawurlencode()) in that for historical\n  reasons, spaces are encoded as plus\n  (+) signs.I believe urlencode is for query parameters, whereas the rawurlencode is for the path segments. This is mainly due to %20 for path segments vs + for query parameters. See this answer which talks about the spaces: When to encode space to plus (+) or %20?However %20 now works in query parameters as well, which is why rawurlencode is always safer. However the plus sign tends to be used where user experience of editing and readability of query parameters matter.Note that this means rawurldecode does not decode + into spaces (http://au2.php.net/manual/en/function.rawurldecode.php). This is why the $_GET is always automatically passed through urldecode, which means that + and %20 are both decoded into spaces.If you want the encoding and decoding to be consistent between inputs and outputs and you have selected to always use + and not %20 for query parameters, then urlencode is fine for query parameters (key and value).The conclusion is:Path Segments - always use rawurlencode/rawurldecodeQuery Parameters - for decoding always use urldecode (done automatically), for encoding, both rawurlencode or urlencode is fine, just choose one to be consistent, especially when comparing URLs.The biggest reason I\'ve seen to use rawurlencode() in most cases is because urlencode encodes text spaces as + (plus signs) where rawurlencode encodes them as the commonly-seen %20:I have specifically seen certain API endpoints that accept encoded text queries expect to see %20 for a space and as a result, fail if a plus sign is used instead. Obviously this is going to differ between API implementations and your mileage may vary.simple \n* rawurlencode the path \n- path is the part before the "?"\n- spaces must be encoded as %20 \n* urlencode the query string \n- Query string is the part after the "?"\n-spaces are better encoded as "+"\n= rawurlencode is more compatible generally 