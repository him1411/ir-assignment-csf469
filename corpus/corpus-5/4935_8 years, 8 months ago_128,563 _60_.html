I\'m curious to see if you can overload controller methods in ASP.NET MVC.  Whenever I try, I get the error below.  The two methods accept different arguments.  Is this something that cannot be done?The current request for action \'MyMethod\' on controller type \'MyController\' is ambiguous between the following action methods:You can use the attribute if you want your code to do overloading.But, you\'ll have to use a different action name for the same http method (as others have said). So it\'s just semantics at that point. Would you rather have the name in your code or your attribute?Phil has an article related to this: http://haacked.com/archive/2008/08/29/how-a-method-becomes-an-action.aspxYes.  I\'ve been able to do this by setting the HttpGet/HttpPost (or equivalent AcceptVerbs attribute) for each controller method to something distinct, i.e., HttpGet or HttpPost, but not both.  That way it can tell based on the type of request which method to use.One suggestion I have is that, for a case like this, would be to have a private implementation that both of your public Action methods rely on to avoid duplicating code.Here\'s something else you could do... you want a method that is able to have a parameter and not.Why not try this...This has worked for me... and in this one method, you can actually test to see if you have the incoming parameter.To overcome this problem you can write an ActionMethodSelectorAttribute that examines the MethodInfo for each action and compares it to the posted Form values and then rejects any method for which the form values don\'t match (excluding the button name, of course).Here\'s an example:-  http://blog.abodit.com/2010/02/asp-net-mvc-ambiguous-match/BUT, this isn\'t a good idea.No,No and No. Go and try the controller code below where we have the "LoadCustomer" overloaded.If you try to invoke the "LoadCustomer" action you will get error as shown in the below  figure.Polymorphism is a part of C# programming while HTTP is a protocol. HTTP does not understand polymorphism. HTTP  works on the concept\'s or URL and URL can only have unique name\'s. So HTTP does not implement polymorphism.In order to fix the same we need to use "ActionName" attribute.So now if you make a call to URL "Customer/LoadCustomer" the "LoadCustomer" action  will be invoked and with URL structure "Customer/LoadCustomerByName" the "LoadCustomer(string str)" will be invoked. The above answer i have taken from this codeproject  article --> MVC Action overloadingAs far as I know you can only have the same method when using different http methods.i.e.I have achieved this with the help of Attribute Routing in MVC5. Admittedly I am new to MVC coming from a decade of web development using WebForms, but the following has worked for me. Unlike the accepted answer this allows all the overloaded actions to be rendered by the same view file.First enable Attribute Routing in App_Start/RouteConfig.cs.Optionally decorate your controller class with a default route prefix.Then decorate your controller actions that overload each other with a common route and parameters to suit. Using type constrained parameters you can use the same URI format with IDs of different types.Hope this helps and is not leading somebody down the wrong path. :-)You could use a single ActionResult to deal with both Post and Get:Useful if your Get and Post methods have matching signatures.I\'ve just come across this question and, even though it\'s quite old now, it\'s still very relevant. Ironically, the one correct comment in this thread was posted by a self-confessed beginner in MVC when he wrote the post. Even the ASP.NET docs are not entirely correct. I have a large project and I successfully overload action methods. If one understands routing, beyond the simple {controller}/{action}/{id} default route pattern, it might be obvious that controller actions can be mapped using any unique pattern. Someone here talked about polymorphism and said: "HTTP does not understand polymorphism", but routing has nothing to do with HTTP. It is, simply put, a mechanism for string pattern matching.The best way to make this work is to use the routing attributes, for example:These actions will take care of urls like /cars/usa/new-york and /cars/usa/texas/dallas, which will map to the first and second Index actions respectively.Examining this example controller it\'s evident that it goes beyond the default route pattern mentioned above. The default works well if your url structure exactly matches your code naming conventions, but this is not always the case. Code should be descriptive of the domain, but urls often need to go further because their content should be based on other criteria, such as SEO requirements.The benefit of the default routing pattern is that it automatically creates unique routes. This is enforced by the compiler since urls will match unique controller types and members. Rolling your own route patterns will require careful thought to ensure uniqueness and that they work.Important note The one drawback is that using routing to generate urls for overloaded actions does not work when based on an action name, e.g., when using UrlHelper.Action. But it does work if one uses named routes, e.g., UrlHelper.RouteUrl. And using named routes is, according to well respected sources, the way to go anyhow (http://haacked.com/archive/2010/11/21/named-routes-to-the-rescue.aspx/).Good luck!I needed an overload for:There were few enough arguments where I ended up doing this:It\'s not a perfect solution, especially if you have a lot of arguments, but it works well for me.Create the base method as virtualCreate the overridden method as overrideEdit: This obviously applies only if the override method is in a derived class which appears not to have been the OP\'s intention.I like this answer posted in another threadThis is mainly used if you inherit from another controller and want to override an acction from the base controllerASP.NET MVC - Overriding an action with differing parametersI have faced same issue in my application too. Without Modifiyig any Method information, I have provided [ActionName("SomeMeaningfulName")] on Action head. issue resolvedYou can use [ActionName("NewActionName")] to use the same method with a different name.public class HomeController : Controller\n    {  You can\'t - there is only one public signature allowed for your controller method. If you try to overload it, it will compile but you\'re getting the runtime error you\'ve experienced.Either you provide a method with a different name to differentiate, or you can do it like I am going to describe below:I once came into a situation where I had to maintain backwards compatibility. The original method expected two parameters, but the new one had only one. Overloading the way I expected did not work because MVC didn\'t find the entry point any more. To solve that, I did the following: Created one new public method which contained "just" 2 string parameters. That one acted as a dispatcher, i.e.:Of course, this is a hack and should be refactored later. But for the time being, it worked for me.If this is an attempt to use one GET action for several views that POST to several actions with different models, then try add a GET action for each POST action that redirects to the first GET to prevent 404 on refresh.Long shot but common scenario.