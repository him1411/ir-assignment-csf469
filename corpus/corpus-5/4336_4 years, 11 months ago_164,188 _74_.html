So I was making an rss reader for my school and finished the code. I ran the test and it gave me that error. Here is the code it\'s referring to:here\'s the error in the output:2012-10-04 20:13:05.356 Reader[4390:c07] * Assertion failure in\n  -[UITableView dequeueReusableCellWithIdentifier:forIndexPath:], /SourceCache/UIKit_Sim/UIKit-2372/UITableView.m:4460 2012-10-04\n  20:13:05.357 Reader[4390:c07] * Terminating app due to uncaught\n  exception \'NSInternalInconsistencyException\', reason: \'unable to\n  dequeue a cell with identifier Cell - must register a nib or a class\n  for the identifier or connect a prototype cell in a storyboard\'\n  * First throw call stack: (0x1c91012 0x10cee7e 0x1c90e78 0xb64f35 0xc7d14 0x39ff 0xd0f4b 0xd101f 0xb980b 0xca19b 0x6692d 0x10e26b0\n  0x228dfc0 0x228233c 0x228deaf 0x1058cd 0x4e1a6 0x4ccbf 0x4cbd9 0x4be34\n  0x4bc6e 0x4ca29 0x4f922 0xf9fec 0x46bc4 0x47311 0x2cf3 0x137b7 0x13da7\n  0x14fab 0x26315 0x2724b 0x18cf8 0x1becdf9 0x1becad0 0x1c06bf5\n  0x1c06962 0x1c37bb6 0x1c36f44 0x1c36e1b 0x147da 0x1665c 0x2a02 0x2935)\n  libc++abi.dylib: terminate called throwing an exceptionand here\'s the code it shows in the error screen:please help!You\'re using the dequeueReusableCellWithIdentifier:forIndexPath: method.  The documentation for that method says this:Important: You must register a class or nib file using the registerNib:forCellReuseIdentifier: or registerClass:forCellReuseIdentifier: method before calling this method.You didn\'t register a nib or a class for the reuse identifier "Cell".Looking at your code, you seem to expect the dequeue method to return nil if it doesn\'t have a cell to give you.  You need to use the dequeueReusableCellWithIdentifier: for that behavior:Notice that dequeueReusableCellWithIdentifier: and dequeueReusableCellWithIdentifier:forIndexPath: are different methods. See doc for the former and the latter.If you want to understand why you\'d want to ever use dequeueReusableCellWithIdentifier:forIndexPath:, check out this Q&A.I think this error is about registering your nib or class for the identifier.So that you may keep what you are doing in your tableView:cellForRowAtIndexPath function and just add code below into your viewDidLoad:It\'s worked for me. Hope it may help.Although this question is fairly old, there is another possibility:\nIf you are using Storyboards, you simply have to set the CellIdentifier in the Storyboard.So if your CellIdentifier is "Cell", just set the "Identifier" property:\nMake sure to clean your build after doing so. XCode sometimes has some issues with Storyboard updatesi had the same problem replacing with solvedThe problem is most likely because you config custom UITableViewCell in storyboard but you do not use storyboard to instantiate your UITableViewController which uses this UITableViewCell. For example, in MainStoryboard, you have a UITableViewController subclass called MyTableViewController and have a custom dynamic UITableViewCell called MyTableViewCell with identifier id "MyCell". If you create your custom UITableViewController like this:It will not automatically register your custom tableviewcell for you. You have to manually register it.But if you use storyboard to instantiate MyTableViewController, like this:Nice thing happens! UITableViewController will automatically register your custom tableview cell that you define in storyboard for you.In your delegate method "cellForRowAtIndexPath", you can create you table view cell like this :dequeueReusableCellWithIdentifier will automatically create new cell for you if there is not reusable cell available in the recycling queue.Then you are done! I\'ll just add that Xcode 4.5 includes the new dequeueReusableCellWithIdentifier:forIndexPath:\nin its default template code - a potential gotcha for developers expecting the older dequeueReusableCellWithIdentifier: method.        In your storyboard you should set the \'Identifier\' of your prototype cell to be the same as your CellReuseIdentifier "Cell". Then you won\'t get that message or need to call that registerClass: function.You need to go into your Attribute Inspector and add a name for your cells Identifier:Then you need to make your identifier match with your dequeue like this:AlternativelyIf you\'re working with a nib you may need to register your class in your cellForRowAtIndexPath:Apples\'s UITableView Class Reference says:Prior to dequeueing any cells, call this method or the\n  registerNib:forCellReuseIdentifier: method to tell the table view how\n  to create new cells. If a cell of the specified type is not currently\n  in a reuse queue, the table view uses the provided information to\n  create a new cell object automatically.If you previously registered a class or nib file with the same reuse\n  identifier, the class you specify in the cellClass parameter replaces\n  the old entry. You may specify nil for cellClass if you want to\n  unregister the class from the specified reuse identifier.Here\'s the code from Apples Swift 2.0 framework:If you are going with Custom Static Cells just comment this method: and give the cells an identifier at "Attributes Inspector" in storyboard.I give you the answer in both Objective C and Swift.Before that I want to say If we use the dequeueReusableCellWithIdentifier:forIndexPath:,we must register a class or nib file using the registerNib:forCellReuseIdentifier: or registerClass:forCellReuseIdentifier: method before calling this method as \n  Apple Documnetation SaysSo we add registerNib:forCellReuseIdentifier: or registerClass:forCellReuseIdentifier: Once we registered a class for the specified identifier and a new cell must be created, this method initializes the cell by calling its initWithStyle:reuseIdentifier: method. For nib-based cells, this method loads the cell object from the provided nib file. If an existing cell was available for reuse, this method calls the cell\xe2\x80\x99s prepareForReuse method instead. in viewDidLoad method we should register the cellObjective COPTION 1:OPTION 2:in above code nibWithNibName:@"CustomCell" give your nib name instead of my nib name CustomCellSWIFT OPTION 1:OPTION 2:in above code nibName:"NameInput" give your nib name I spent hours last night working out why my programmatically generated table crashed on [myTable setDataSource:self]; It was OK commenting out and popping up an empty table, but crashed every time I tried to reach the datasource;I had the delegation set up in the h file: @interface myViewController : UIViewController  I had the data source code in my implementation and still BOOM!, crash every time! THANK YOU to "xxd" (nr 9): adding that line of code solved it for me!  In fact I am launching a table from a IBAction button, so here is my full code:By the way: the button must be linked up with as an IBAction and as a IBOutlet if you want to anchor the popover to it. UIPopoverController *popoverController3 is declared in the H file directly after @interface between {}FWIW, I got this same error when I forgot to set the cell identifier in the storyboard.  If this is your issue then in the storyboard click the table view cell and set the cell identifier in the attributes editor.  Make sure the cell identifier you set here is the same as I had the same issue, was having the same error and for me it worked like this:Maybe it will be usefull for someone else.I setup everything correctly in the Storyboard and did a clean build but kept getting the error " must register a nib or a class for the identifier or connect a prototype cell in a storyboard"Corrected the error but i\'m still at a loss. I\'m not using a \'custom cell\', just a view with a tableview embeded. I have declared the viewcontroller as delegate and datasource and made sure the cell identifier matches in file. whats going on here?Working with Swift 3.0:This might seem stupid to some people but it got me. I was getting this error and the problem for me was that I was trying to use static cells but then dynamically add more stuff. If you are calling this method your cells need to be dynamic prototypes. Select the cell in storyboard and under the Attributes inspector, the very first thing says \'Content\' and you should select dynamic prototypes not static. Just a supplement of the answers:\nThere may be a time you set all things right, but you may accidentally add some other UIs in you .xib, like a UIButton:\nJust delete the extra UI, it works.Make sure that the CellIdentifier == identifier of the cell in a storyboard, both names are same. Hope this works for uIn my case, the crash happened when I calleddeselectRowAtIndexPath:The line was [tableView deselectRowAtIndexPath:indexPath animated:YES];Changing it to [self.tableView deselectRowAtIndexPath:indexPath animated:YES]; FIXED MY PROBLEM! Hope this helps anyoneIn Swift this problem can be solved by adding the following code in your viewDidLoadmethod.