I\'m trying to understand rvalue references and move semantics of C++11.What is the difference between these examples, and which of them is going to do no vector copy?The first example returns a temporary which is caught by rval_ref. That temporary will have its life extended beyond the rval_ref definition and you can use it as if you had caught it by value.  This is very similar to the following:except that in my rewrite you obviously can\'t use rval_ref in a non-const manner.In the second example you have created a run time error.  rval_ref now holds a reference to the destructed tmp inside the function.  With any luck, this code would immediately crash.Your third example is roughly equivalent to your first.  The std::move on tmp is unnecessary and can actually be a performance pessimization as it will inhibit return value optimization.The best way to code what you\'re doing is:I.e. just as you would in C++03.  tmp is implicitly treated as an rvalue in the return statement.  It will either be returned via return-value-optimization (no copy, no move), or if the compiler decides it can not perform RVO, then it will use vector\'s move constructor to do the return.  Only if RVO is not performed, and if the returned type did not have a move constructor would the copy constructor be used for the return.None of them will copy, but the second will refer to a destroyed vector. Named rvalue references almost never exist in regular code. You write it just how you would have written a copy in C++03.Except now, the vector is moved. The user of a class doesn\'t deal with it\'s rvalue references in the vast majority of cases.The simple answer is you should write code for rvalue references like you would regular references code, and you should treat them the same mentally 99% of the time.  This includes all the old rules about returning references (i.e. never return a reference to a local variable).Unless you are writing a template container class that needs to take advantage of std::forward and be able to write a generic function that takes either lvalue or rvalue references, this is more or less true.One of the big advantages to the move constructor and move assignment, is that if you define them, the compiler can use them in cases were the RVO (return value optimization) and NRVO (named return value optimization) fail to be invoked.  This is pretty huge for returning expensive objects like containers & strings by value efficiently from methods.Now where things get interesting with rvalue references, is that you can also use them as arguments to normal functions.  This allows you to write containers that have overloads for both const reference (const foo& other) and rvalue reference (foo&& other).   Even if the argument is too unwieldy to pass with a mere constructor call it can still be done:The STL containers have been updated to have move overloads for nearly anything (hash key and values, vector insertion, etc), and is where you will see them the most.You can also use them to normal functions, and if you only provide an rvalue reference argument you can force the caller to create the object and let the function do the move.  This is more of an example than a real good use, but in my rendering library I have assign a string to all the loaded resources, so that it is easier to see what each object represents in the debugger.  The interface is something like this:It is a form of a \'leaky abstraction\' but allows me to take advantage of the fact I had to create the string already most of the time, and avoid making yet another copying of it.  This isn\'t exactly high performance code but is a good example of the possibilities as people get the hang of this feature.  This code actually requires that the variable either be a temporary to the call, or std::move invoked:ororbut this won\'t compile!Not an answer per se, but a guideline. Most of the time there is not much sense in declaring local T&& variable (as you did with std::vector<int>&& rval_ref). You will still have to std::move() them to use in foo(T&&) type methods. There is also the problem that was already mentioned that when you try to return such rval_ref from function you will get the standard reference-to-destroyed-temporary-fiasco.Most of the time I would go with following pattern:You don\'t hold any refs to returned temporary objects, thus you avoid (inexperienced) programmer\'s error who wish to use a moved object.Obviously there are (although rather rare) cases where a function truly returns a T&& which is a reference to a non-temporary object that you can move into your object.Regarding RVO: these mechanisms generally work and compiler can nicely avoid copying, but in cases where the return path is not obvious (exceptions, if conditionals determining the named object you will return, and probably couple others) rrefs are your saviors (even if potentially more expensive).None of those will do any extra copying.  Even if RVO isn\'t used, the new standard says that move construction is preferred to copy when doing returns I believe.I do believe that your second example causes undefined behavior though because you\'re returning a reference to a local variable.