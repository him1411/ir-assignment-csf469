I am looking for a better pattern for working with a list of elements which each need processed and then depending on the outcome are removed from the list. You can\'t use .Remove(element) inside a foreach (var element in X) (because it results in Collection was modified; enumeration operation may not execute. exception)... you also can\'t use for (int i = 0; i < elements.Count(); i++) and .RemoveAt(i) because it disrupts your current position in the collection relative to i.Is there an elegant way to do this?Iterate your list in reverse with a for loop:Example:Alternately, you can use the RemoveAll method with a predicate to test against:Here\'s a simplified example to demonstrate:A simple and straightforward solution:Use a standard for-loop running backwards on your collection and RemoveAt(i) to remove elements.Reverse iteration should be the first thing to come to mind when you want to remove elements from a Collection while iterating over it.Luckily, there is a more elegant solution than writing a for loop which involves needless typing and can be error prone.If you add ".ToList()" to your list (or the results of a LINQ query), you can remove "item" directly from "list" without the dreaded "Collection was modified; enumeration operation may not execute." error. The compiler makes a copy of "list", so that you can safely do the remove on the array. While this pattern is not super efficient, it has a natural feel and is flexible enough for almost any situation. Such as when you want to save each "item" to a DB and remove it from the list only when the DB save succeeds. Select the elements you do want rather than trying to remove the elements you don\'t want. This is so much easier (and generally more efficient too) than removing elements. I wanted to post this as a comment in response to the comment left by Michael Dillon below, but it\'s too long and probably useful to have in my answer anyway:Personally, I\'d never remove items one-by-one, if you do need removal, then call RemoveAll which takes a predicate and only rearranges the internal array once, whereas Remove does an Array.Copy operation for every element you remove. RemoveAll is vastly more efficient. And when you\'re backwards iterating over a list, you already have the index of the element you want to remove, so it would be far more efficient to call RemoveAt, because Remove first does a traversal of the list to find the index of the element you\'re trying to remove, but you already know that index. So all in all, I don\'t see any reason to ever call Remove in a for-loop. And ideally, if it is at all possible, use the above code to stream elements from the list as needed so no second data structure has to be created at all. Using the ToArray() on a generic list allows you to do a Remove(item) on your generic List:Using .ToList() will make a  copy of your list, as explained in this question:\nToList()-- Does it Create a New List?By using ToList(), you can remove from your original list, because you\'re actually iterating over a copy.As any remove is taken on a condition you can useIf the function that determines which items to delete has no side effects and doesn\'t mutate the item (it\'s a pure function), a simple and efficient (linear time) solution is:If there are side effects, I\'d use something like:This is still linear time, assuming the hash is good. But it has an increased memory use due to the hashset.Finally if your list is only an IList<T> instead of a List<T> I suggest my answer to How can I do this special foreach iterator?. This will have linear runtime given typical implementations of IList<T>, compared with quadratic runtime of many other answers.You can\'t use foreach, but you could iterate forwards and manage your loop index variable when you remove an item, like so:Note that in general all of these techniques rely on the behaviour of the collection being iterated. The technique shown here will work with the standard List(T). (It is quite possible to write your own collection class and iterator that does allow item removal during a foreach loop.)I wish the "pattern" was something like this:This would align the code with the process that goes on in the programmer\'s brain.I would reassign the list from a LINQ query that filtered out the elements you didn\'t want to keep.Unless the list is very large there should be no significant performance problems in doing this.Using Remove or RemoveAt on a list while iterating over that list has intentionally been made difficult, because it is almost always the wrong thing to do. You might be able to get it working with some clever trick, but it would be extremely slow. Every time you call Remove it has to scan through the entire list to find the element you want to remove. Every time you call RemoveAt it has to move subsequent elements 1 position to the left. As such, any solution using Remove or RemoveAt, would require quadratic time, O(n\xc2\xb2).Use RemoveAll if you can. Otherwise, the following pattern will filter the list in-place in linear time, O(n).By assuming that predicate is a Boolean property of an element, that if it is true, then the element should be removed:I found myself in a similar situation where I had to remove every nth element in a given List<T>.The cost of removing an item from the list is proportional to the number of items following the one to be removed.  In the case where the first half of the items qualify for removal, any approach which is based upon removing items individually will end up having to perform about N*N/4 item-copy operations, which can get very expensive if the list is large.A faster approach is to scan through the list to find the first item to be removed (if any), and then from that point forward copy each item which should be retained to the spot where it belongs.  Once this is done, if R items should be retained, the first R items in the list will be those R items, and all of the items requiring deletion will be at the end.  If those items are deleted in reverse order, the system won\'t end up having to copy any of them, so if the list had N items of which R items, including all of the first F, were retained,\nit will be necessary to copy R-F items, and shrink the list by one item N-R times.  All linear time.My approach is that I first create a list of indices, which should get deleted. Afterwards I loop over the indices and remove the items from the initial list. This looks like this: