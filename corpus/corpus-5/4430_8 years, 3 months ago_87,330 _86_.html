alloca() allocates memory from Stack rather than heap which is case in malloc(). So, when I return from the routine the memory is freed. So, actually this solves my problem of freeing up of dynamically allocated memory. Freeing of memory allocated through malloc() is a major headache and if somehow missed leads to all sorts memory problems.Why is the use of alloca() discouraged in spite of the above features?The answer is right there in the man page (at least on Linux):RETURN VALUE\n         The alloca() function returns a pointer to the beginning of the\n  allocated  space.   If  the \n  allocation  causes\n         stack overflow, program behaviour is undefined.Which isn\'t to say it should never be used.  One of the OSS projects I work on uses it extensively, and as long as you\'re not abusing it (alloca\'ing huge values), it\'s fine.  Once you go past the "few hundred bytes" mark, it\'s time to use malloc and friends, instead.  You may still get allocation failures, but at least you\'ll have some indication of the failure instead of just blowing out the stack.One of the most memorable bugs I had was to do with an inline function that used alloca. It manifested itself as a stack overflow (because it allocates on the stack) at random points of the program\'s execution.In the header file:In the implementation file:So what happened was the compiler inlined DoSomething function and all the stack allocations were happening inside Process() function and thus blowing the stack up. In my defence (and I wasn\'t the one who found the issue, i had to go and cry to one of the senior developers when i couldn\'t fix it), it wasn\'t straight alloca, it was one of ATL string conversion macros.So the lesson is - do not use alloca in functions that you think might be inlined.Old question but nobody mentioned that it should be replaced by variable length arrays.instead ofIt\'s in the standard C99 and existed as compiler extension in many compilers.alloca() is very useful if you can\'t use a standard local variable because its size would need to be determined at runtime and you can \n absolutely guarantee that the pointer you get from alloca() will NEVER be used after this function returns.\n\nYou can be fairly safe if youThe real danger comes from the chance that someone else will violate these conditions sometime later. With that in mind it\'s great for passing buffers to functions that format text into them :)As noted in this newsgroup posting, there are a few reasons why using alloca can be considered difficult and dangerous:One issue is that it isn\'t standard, although it\'s widely supported.  Other things being equal, I\'d always use a standard function rather than a common compiler extension.still alloca use is discouraged, why?I don\'t perceive such a consensus.  Lots of strong pros; a few cons:On many systems alloca() cannot be used inside the list of arguments of a function call, because the stack space reserved by alloca() would appear on the stack in the middle of the space for the function arguments.I know this question is tagged C, but as a C++ programmer I thought I\'d use C++ to illustrate the potential utility of alloca: the code below (and here at ideone) creates a vector tracking differently sized polymorphic types that are stack allocated (with lifetime tied to function return) rather than heap allocated.All of the other answers are correct. However, if the thing you want to alloc using alloca() is reasonably small, I think that it\'s a good technique that\'s faster and more convenient than using malloc() or otherwise.In other words, alloca( 0x00ffffff ) is dangerous and likely to cause overflow, exactly as much as char hugeArray[ 0x00ffffff ]; is. Be cautious and reasonable and you\'ll be fine.Everyone has already pointed out the big thing which is potential undefined behavior from a stack overflow but I should mention that the Windows environment has a great mechanism to catch this using structured exceptions (SEH) and guard pages. Since the stack only grows as needed, these guard pages reside in areas that are unallocated. If you allocate into them (by overflowing the stack) an exception is thrown.You can catch this SEH exception and call _resetstkoflw to reset the stack and continue on your merry way. Its not ideal but it\'s another mechanism to at least know something has gone wrong when the stuff hits the fan. *nix might have something similar that I\'m not aware of.I recommend capping your max allocation size by wrapping alloca and tracking it internally. If you were really hardcore about it you could throw some scope sentries at the top of your function to track any alloca allocations in the function scope and sanity check this against the max amount allowed for your project.Also, in addition to not allowing for memory leaks alloca does not cause memory fragmentation which is pretty important. I don\'t think alloca is bad practice if you use it intelligently, which is basically true for everything. :-)Here\'s why:Not that anyone would write this code, but the size argument you\'re passing to alloca almost certainly comes from some sort of input, which could maliciously aim to get your program to alloca something huge like that. After all, if the size isn\'t based on input or doesn\'t have the possibility to be large, why didn\'t you just declare a small, fixed-size local buffer?Virtually all code using alloca and/or C99 vlas has serious bugs which will lead to crashes (if you\'re lucky) or privilege compromise (if you\'re not so lucky).Lots of interesting answers to this "old" question, even some relatively new answers, but I didn\'t find any that mention this....When used properly and with care, consistent use of alloca()\n  (perhaps application-wide) to handle small variable-length allocations\n  (or C99 VLAs, where available) can lead to lower overall stack\n  growth than an otherwise equivalent implementation using oversized\n  local arrays of fixed length. So alloca() may be good for your stack if you use it carefully.I found that quote in.... OK, I made that quote up. But really, think about it....@j_random_hacker is very right in his comments under other answers: Avoiding the use of alloca() in favor of oversized local arrays does not make your program safer from stack overflows (unless your compiler is old enough to allow inlining of functions that use alloca() in which case you should upgrade, or unless you use alloca() inside loops, in which case you should... not use alloca() inside loops).I\'ve worked on desktop/server environments and embedded systems. A lot of embedded systems don\'t use a heap at all (they don\'t even link in support for it), for reasons that include the perception that dynamically allocated memory is evil due to the risks of memory leaks on an application that never ever reboots for years at a time, or the more reasonable justification that dynamic memory is dangerous because it can\'t be known for certain that an application will never fragment its heap to the point of false memory exhaustion. So embedded programmers are left with few alternatives.I\'ve seen time & time again where a programmer makes a stack-allocated buffer "big enough to handle any possible case". In a deeply nested call tree, repeated use of that (anti-?)pattern leads to exaggerated stack use. (Imagine a call tree 20 levels deep, where at each level for different reasons, the function blindly over-allocates a buffer of 1024 bytes "just to be safe" when generally it will only use 16 or less of them, and only in very rare cases may use more.) An alternative is to use alloca() or VLAs and allocate only as much stack space as your function needs, to avoid unnecessarily burdening the stack. Hopefully when one function in the call tree needs a larger-than-normal allocation, others in the call tree are still using their normal small allocations, and the overall application stack usage is significantly less than if every function blindly over-allocated a local buffer.Based on other answers on this page, it seems that VLAs should be safe (they don\'t compound stack allocations if called from within a loop), but if you\'re using alloca(), be careful not to use it inside a loop, and make sure your function can\'t be inlined if there\'s any chance it might be called within another function\'s loop.A place where alloca() is especially dangerous than malloc() is the kernel - kernel of a typical operating system has a fixed sized stack space hard-coded into one of its header; it is not as flexible as the stack of an application. Making a call to alloca() with an unwarranted size may cause the kernel to crash.\nCertain compilers warn usage of alloca() (and even VLAs for that matter) under certain options that ought to be turned on while compiling a kernel code - here, it is better to allocate memory in the heap that is not fixed by a hard-coded limit.alloca () is nice and efficient... but it is also deeply broken.In most cases you can replace it using local variables and majorant size. If it\'s used for large objects, putting them on the heap is usually a safer idea. If you really need it C you can use VLA (no vla in C++, too bad). They are much better than alloca() regarding scope behavior and consistency. As I see it VLA are a kind of alloca() made right. Of course a local structure or array using a majorant of the needed space is still better, and if you don\'t have such majorant heap allocation using plain malloc() is probably sane. \nI see no sane use case where you really really need either alloca() or VLA.Sadly the truly awesome alloca() is missing from the almost awesome tcc. Gcc does have alloca().It sows the seed of its own destruction. With return as the destructor.Like malloc() it returns an invalid pointer on fail which will segfault on modern systems with a MMU (and hopefully restart those without).Unlike auto variables you can specify the size at run time.It works well with recursion. You can use static variables to achieve something similar to tail recursion and use just a few others pass info to each iteration.If you push too deep you are assured of a segfault (if you have an MMU).Note that malloc() offers no more as it returns NULL (which will also segfault if assigned) when the system is out of memory. I.e. all you can do is bail or just try to assign it any way.To use malloc() I use globals and assign them NULL. If the pointer is not NULL I free it before I use malloc().You can also use realloc() as general case if want copy any existing data. You need to check pointer before to work out if you are going to copy or concatenate after the realloc().3.2.5.2 Advantages of allocaProcesses only have a limited amount of stack space available - far less than the amount of memory available to malloc().By using alloca() you dramatically increase your chances of getting a Stack Overflow error (if you\'re lucky, or an inexplicable crash if you\'re not).Not very pretty, but if performance really matter, you could preallocate some space on the stack.If you already now the max size of the memory block your need and you want to keep overflow checks, you could do something like :If you accidentally write beyond the block allocated with alloca (due to a buffer overflow for example), then you will overwrite the return address of your function, because that one is located "above" on the stack, i.e. after your allocated block.The consequence of this is two-fold:The program will crash spectacularly and it will be impossible to tell why or where it crashed (stack will most likely unwind to a random address due to the overwritten frame pointer).It makes buffer overflow many times more dangerous, since a malicious user can craft a special payload which would be put on the stack and can therefore end up executed.In contrast, if you write beyond a block on the heap you "just" get heap corruption. The program will probably terminate unexpectedly but will unwind the stack properly, thereby reducing the chance of malicious code execution.The alloca function is great and and all the naysayers are simply spreading FUD. Array and parray are EXACTLY the same with EXACTLY the same risks. Saying one is better than another is a syntactic choice, not a technical one.As for choosing stack variables vs heap variables, there are a LOT of advantages to long running programs using stack over heap for variables with in-scope lifetimes. You avoid heap fragmentation and you can avoid growing your process space with unused (unusable) heap space. You don\'t need to clean it up. You can control the stack allocation on the process. Why is this bad? I don\'t think anyone has mentioned this: Use of alloca in a function will hinder or disable some optimizations that could otherwise be applied in the function, since the compiler cannot know the size of the function\'s stack frame. I know of a RISC machine where functions using alloca need to use an extra pointer register (stack & frame) throughout the function, whereas normal functions need just one. This is one less register available for general use.Given the rarity of its use, and its shady status as a standard function, compiler designers quite possibly disable any optimization that might cause trouble with alloca, if would take more than a little effort to make it work with alloca.  IMHO, alloca is considered bad practice because everybody is afraid of exhausting the stack size limit.I learned much by reading this thread and some other links:I use alloca mainly to make my plain C files compilable on msvc and gcc without any change, C89 style, no #ifdef _MSC_VER, etc.Thank you ! This thread made me sign up to this site :)In my opinion, alloca(), where available, should be used only in a constrained manner.  Very much like the use of "goto", quite a large number of otherwise reasonable people have strong aversion not just to the use of, but also the existence of, alloca().For embedded use, where the stack size is known and limits can be imposed via convention and analysis on the size of the allocation, and where the compiler cannot be upgraded to support C99+, use of alloca() is fine, and I\'ve been known to use it.When available, VLAs may have some advantages over alloca(): The compiler can generate stack limit checks that will catch out-of-bounds access when array style access is used (I don\'t know if any compilers do this, but it can be done), and analysis of the code can determine whether the array access expressions are properly bounded.  Note that, in some programming environments, such as automotive, medical equipment, and avionics, this analysis has to be done even for fixed size arrays, both automatic (on the stack) and static allocation (global or local).On architectures that store both data and return addresses/frame pointers on the stack (from what I know, that\'s all of them), any stack allocated variable can be dangerous because the address of the variable can be taken, and unchecked input values might permit all sorts of mischief.Portability is less of a concern in the embedded space, however it is a good argument against use of alloca() outside of carefully controlled circumstances.Outside of the embedded space, I\'ve used alloca() mostly inside logging and formatting functions for efficiency, and in a non-recursive lexical scanner, where temporary structures (allocated using alloca() are created during tokenization and classification, then a persistent object (allocated via malloc()) is populated before the function returns.  The use of alloca() for the smaller temporary structures greatly reduces fragmentation when the persistent object is allocated.Actually, alloca is not guaranteed to use the stack.\nIndeed, the gcc-2.95 implementation of alloca allocates memory from the heap using malloc itself. Also that implementation is buggy, it may lead to a memory leak and to some unexpected behavior if you call it inside a block with a further use of goto. Not, to say that you should never use it, but some times alloca leads to more overhead than it releaves frome.Most answers here largely miss the point: there\'s a reason why using _alloca() is potentially worse than merely storing large objects in the stack.The main difference between automatic storage and _alloca() is that the latter suffers from an additional (serious) problem: the allocated block is not controlled by the compiler, so there\'s no way for the compiler to optimize or recycle it.Compare:with:The problem with the latter should be obvious.