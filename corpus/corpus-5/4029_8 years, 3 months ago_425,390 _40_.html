I need to implement 256 bit AES encryption, but all the examples I have found online use a "KeyGenerator" to generate a 256 bit key, but I would like to use my own passkey. How can I create my own key? I have tried padding it out to 256 bits, but then I get an error saying that the key is too long. I do have the unlimited jurisdiction patch installed, so thats not the problem :)Ie. The KeyGenerator looks like this ...Code taken from hereEDITI was actually padding the password out to 256 bytes, not bits, which is too long. The following is some code I am using now that I have some more experience with this.The "TODO" bits you need to do yourself :-)Share the password (a char[]) and salt (a byte[]—8 bytes selected by a SecureRandom makes a good salt—which doesn\'t need to be kept secret) with the recipient out-of-band. Then to derive a good key from this information:The magic numbers (which could be defined as constants somewhere) 65536 and 256 are the key derivation iteration count and the key size, respectively.The key derivation function is iterated to require significant computational effort, and that prevents attackers from quickly trying many different passwords. The iteration count can be changed depending on the computing resources available. The key size can be reduced to 128 bits, which is still considered "strong" encryption, but it doesn\'t give much of a safety margin if attacks are discovered that weaken AES.Used with a proper block-chaining mode, the same derived key can be used to encrypt many messages. In CBC, a random initialization vector (IV) is generated for each message, yielding different cipher text even if the plain text is identical. CBC may not be the most secure mode available to you (see AEAD below); there are many other modes with different security properties, but they all use a similar random input. In any case, the outputs of each encryption operation are the cipher text and the initialization vector:Store the ciphertext and the iv. On decryption, the SecretKey is regenerated in exactly the same way, using using the password with the same salt and iteration parameters. Initialize the cipher with this key and the initialization vector stored with the message:Java 7 included API support for AEAD cipher modes, and the "SunJCE" provider included with OpenJDK and Oracle distributions implements these beginning with Java 8. One of these modes is strongly recommended in place of CBC; it will protect the integrity of the data as well as their privacy.A java.security.InvalidKeyException with the message "Illegal key size or default parameters" means that the cryptography strength is limited; the unlimited strength jurisdiction policy files are not in the correct location. In a JDK, they should be placed under ${jdk}/jre/lib/security Based on the problem description, it sounds like the policy files are not correctly installed. Systems can easily have multiple Java runtimes; double-check to make sure that the correct location is being used.The Spring Security Crypto module provides support for symmetric encryption, key generation, and password encoding. The code is distributed as part of the core module but has no dependencies on any other Spring Security (or Spring) code.It\'s provides a simple abstraction for encryption and seems to match what\'s required here,The "standard" encryption method is 256-bit AES using PKCS #5\'s PBKDF2 (Password-Based Key Derivation Function #2). This method requires Java 6. The password used to generate the SecretKey should be kept in a secure place and not be shared. The salt is used to prevent dictionary attacks against the key in the event your encrypted data is compromised. A 16-byte random initialization vector is also applied so each encrypted message is unique.A look at the internals reveals a structure similar to erickson\'s answer. As noted in the question, this also requires the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy (else you\'ll encounter InvalidKeyException: Illegal Key Size).  It\'s downloadable for Java 6, Java 7 and Java 8. And sample output,After reading through erickson\'s suggestions, and gleaning what I could from a couple other postings and this example here, I\'ve attempted to update Doug\'s code with the recommended changes. Feel free to edit to make it better.Some notes: This uses a 128 bit encryption key - java apparently won\'t do 256 bit encryption out-of-the-box. Implementing 256 requires installing some extra files into the java install directory. Also, I\'m not a crypto person. Take heed.I\'ve implemented the erickson\'s answer in a really simple class:\nJava AES 256-bit Encryption/Decryption class\nIf you get the java.security.InvalidKeyException you have to install the Java Cryptography Extension (JCE) unlimited strength jurisdiction policy files:Just place the jars in your {JDK HOME}\\jre\\lib\\securityGenerating your own key from a byte array is easy:But creating a 256-bit key isn\'t enough. If the key generator cannot generate 256-bit keys for you, then the Cipher class probably doesn\'t support AES 256-bit either. You say you have the unlimited jurisdiction patch installed, so the AES-256 cipher should be supported (but then 256-bit keys should be too, so this might be a configuration problem).A workaround for lack of AES-256 support is to take some freely available implementation of AES-256, and use it as a custom provider. This involves creating your own Provider subclass and using it with Cipher.getInstance(String, Provider). But this can be an involved process.What I\'ve done in the past is hash the key via something like SHA256, then extract the bytes from the hash into the key byte[].After you have your byte[] you can simply do:Adding to @Wufoo\'s edits, the following version uses InputStreams rather than files to make working with a variety of files easier. It also stores the IV and Salt in the beginning of the file, making it so only the password needs to be tracked. Since the IV and Salt do not need to be secret, this makes life a little easier.Consider using Encryptor4jFirst make sure you have Unlimited Strength Jurisdiction Policy files installed before your proceed so that you can use 256-bit AES keys.Then do the following:You can now use the encryptor to encrypt your message. You can also perform streaming encryption if you\'d like. It automatically generates and prepends a secure IV for your convenience.If it\'s a file that you wish to compress take a look at this answer\nEncrypting a large file with AES using JAVA for an even simpler approach.Use this class for encryption. It works.}And these are ivBytes and a random key;