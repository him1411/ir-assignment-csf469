Can you explain the reasoning behind the syntax for encapsulated anonymous functions in JavaScript? Why does this work: (function(){})(); but this doesn\'t: function(){}();?In JavaScript, one creates a named function like this:You can also create an anonymous function and assign it to a variable:You can encapsulate a block of code by creating an anonymous function, then wrapping it in brackets and executing it immediately:This is useful when creating modularised scripts, to avoid cluttering up the current scope, or global scope, with potentially conflicting variables - as in the case of Greasemonkey scripts, jQuery plugins, etc.Now, I understand why this works. The brackets enclose the contents and expose only the outcome (I\'m sure there\'s a better way to describe that), such as with (2 + 2) === 4.But I don\'t understand why this does not work equally as well:Can you explain that to me?It doesn\'t work because it is being parsed as a FunctionDeclaration, and the name identifier of function declarations is mandatory.When you surround it with parentheses it is evaluated as a FunctionExpression, and function expressions can be named or not.The grammar of a FunctionDeclaration looks like this:And FunctionExpressions:As you can see the Identifier (Identifieropt) token in FunctionExpression is optional, therefore we can have a function expression without a name defined:Or named function expression:The Parentheses (formally called the Grouping Operator) can surround only expressions, and a function expression is evaluated.The two grammar productions can be ambiguous, and they can look exactly the same, for example:The parser knows if it\'s a FunctionDeclaration or a FunctionExpression, depending on the context where it appears.In the above example, the second one is an expression because the Comma operator can also handle only expressions.On the other hand, FunctionDeclarations could actually appear only in what\'s called "Program" code, meaning code outside in the global scope, and inside the FunctionBody of other functions.Functions inside blocks should be avoided, because they can lead an unpredictable behavior, e.g.:The above code should actually produce a SyntaxError, since a Block can only contain statements (and the ECMAScript Specification doesn\'t define any function statement), but most implementations are tolerant, and will simply take the second function, the one which alerts \'false!\'.The Mozilla implementations -Rhino, SpiderMonkey,- have a different behavior. Their grammar contains a non-standard Function Statement, meaning that the function will be evaluated at run-time, not at parse time, as it happens with FunctionDeclarations. In those implementations we will get the first function defined.Functions can be declared in different ways, compare the following:1- A function defined with the Function constructor assigned to the variable multiply:2- A function declaration of a function named multiply:3- A function expression assigned to the variable multiply:4- A named function expression func_name, assigned to the variable multiply:Even though this is an old question and answer, it discusses a topic that to this day throws many developers for a loop. I can\'t count the number of JavaScript developer candidates I\'ve interviewed who couldn\'t tell me the difference between a function declaration and a function expression and who had no clue what an immediately invoked function expression is.I\'d like to mention, though, one very important thing which is that Premasagar\'s code snippet wouldn\'t work even if he had given it a name identifier.The reason this wouldn\'t work is that the JavaScript engine interprets this as a function declaration followed by a completely unrelated grouping operator that contains no expression, and grouping operators must contain an expression. According to JavaScript, the above snippet of code is equivalent to the following one.Another thing I\'d like to point out that may be of some use to some people is that any name identifier you provide for a function expression is pretty much useless in the context of the code except from within the function definition itself.Of course, using name identifiers with your function definitions is always helpful when it comes to debugging code, but that\'s something else entirely... :-)Great answers have already being posted. But I want to note that function declarations return an empty completion record:14.1.20 - Runtime Semantics: EvaluationFunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }This fact is not easy to observe, because most ways of attempting to get the returned value will convert the function declaration to a function expression. However, eval shows it:Calling an empty completion record makes no sense. That\'s why function f(){}() can\'t work. In fact the JS engine does not even attempt to call it, the parentheses are considered part of another statement.But if you wrap the function in parentheses, it becomes a function expression:Function expressions return a function object. And therefore you can call it: (function f(){})().I have just another small remark. Your code will work with a small change:I use the above syntax instead of the more widely spread version:because I didn\'t manage to get the indentation to work correctly for javascript files in vim. It seems that vim doesn\'t like the curly braces inside open parenthesis. Above is valid syntax because anything passed inside parenthesis is consider as function expression.Above is not valid syntax. Because java script syntax parser looks for function name after function keyword since it doesn\'t find anything it throws an error.They can be used with parameters-arguments likewould result as 7In javascript, this is called Immediately-Invoked Function Expression (IIFE) .In order to make it a function expression you\'ve to:enclose it using () place a void operator before it assign it to a variable. Otherwise it will be treated as function definition and then you won\'t be able to call/invoke it at the same time by the following way:  The above will give you error. Because you can only invoke a function expression immediately. This can be achieved couple of ways:\n  Way 1:Way 2:Way 3:way 4:All above will immediately invoke the function expression. Perhaps the shorter answer would be thatis a function literal that defines an (anonymous) function. An additional ()-pair, which is interpreted as an expression, is not expected at toplevel, only literals. is in an expression statement that invokes an anonymous function.