I am creating all of the elements in my android project dynamically. I am trying to get the width and height of a button so that I can rotate that button around. I am just trying to learn how to work with the android language. However, it returns 0. I did some research and I saw that it needs to be done somewhere other than in the onCreate() method. If someone can give me an example of how to do it, that would be great. Here is my current code:Any help is appreciated.You are calling getWidth() too early. The UI has not been sized and laid out on the screen yet.I doubt you want to be doing what you are doing, anyway -- widgets being animated do not change their clickable areas, and so the button will still respond to clicks in the original orientation regardless of how it has rotated.That being said, you can use a dimension resource to define the button size, then reference that dimension resource from your layout file and your source code, to avoid this problem.The basic problem is, that you have to wait for the drawing phase for the actual measurements (especially with dynamic values like wrap_content or match_parent), but usually this phase hasn\'t been finished up to onResume(). So you need a workaround for waiting for this phase. There a are different possible solutions to this:A ViewTreeObserver gets fired for different drawing events. Usually the OnGlobalLayoutListener is what you want for getting the measurement, so the code in the listener will be called after the layout phase, so the measurements are ready:Note: The listener will be immediately removed because otherwise it will fire on every layout event. If you have to support apps SDK Lvl < 16 use this to unregister the listener:public void removeGlobalOnLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim)Not very well known and my favourite solution. Basically just use the View\'s post method with your own runnable. This basically queues your code after the view\'s measure, layout, etc. as stated by Romain Guy:The UI event queue will process events in order. After\n  setContentView() is invoked, the event queue will contain a message\n  asking for a relayout, so anything you post to the queue will happen\n  after the layout passExample:The advantage over ViewTreeObserver:References: This is only practical in certain situation when the logic can be encapsulated in the view itself, otherwise this is a quite verbose and cumbersome syntax.Also mind, that onLayout will be called many times, so be considerate what you do in the method, or disable your code after the first timeIf you have code that is executing multiple times while creating the ui you could use the following support v4 lib method:Returns true if view has been through at least one layout since it was\n  last attached to or detached from a window.If it suffices to just get the statically defined height/width, you can just do this with:But mind you, that this might be different to the actual width/height after drawing. The javadoc describes the difference perfectly:The size of a view is expressed with a width and a height. A view\n  actually possess two pairs of width and height values.The first pair is known as measured width and measured height. These\n  dimensions define how big a view wants to be within its parent (see\n  Layout for more details.) The measured dimensions can be obtained by\n  calling getMeasuredWidth() and getMeasuredHeight().The second pair is simply known as width and height, or sometimes\n  drawing width and drawing height. These dimensions define the actual\n  size of the view on screen, at drawing time and after layout. These\n  values may, but do not have to, be different from the measured width\n  and height. The width and height can be obtained by calling getWidth()\n  and getHeight().We can use I used this solution, which I think is better than onWindowFocusChanged(). If you open a DialogFragment, then rotate the phone, onWindowFocusChanged will be called only when the user closes the dialog):Edit : as removeGlobalOnLayoutListener is deprecated, you should now do :As Ian states in this Android Developers thread:Anyhow, the deal is that layout of the\n  contents of a window happens\n  after all the elements are constructed and added to their parent\n  views.  It has to be this way, because\n  until you know what components a View\n  contains, and what they contain, and\n  so on, there\'s no sensible way you can\n  lay it out.Bottom line, if you call getWidth()\n  etc. in a constructor, it will return\n  zero.  The procedure is to create all\n  your view elements in the constructor,\n  then wait for your View\'s\n  onSizeChanged() method to be called --\n  that\'s when you first find out your\n  real size, so that\'s when you set up\n  the sizes of your GUI elements.Be aware too that onSizeChanged() is\n  sometimes called with parameters of\n  zero -- check for this case, and\n  return immediately (so you don\'t get a\n  divide by zero when calculating your\n  layout, etc.).  Some time later it\n  will be called with the real values.If you need to get width of some widget before it is displayed on screen, you can use getMeasuredWidth() or getMeasuredHeight().I would rather use OnPreDrawListener() instead of addOnGlobalLayoutListener(), since it is called earlier. 