I read this question and thought that would easily be solved (not that it isn\'t solvable without) if one could write: I\'m not sure if it is useful in many cases, but I wonder why it isn\'t and if something like this exists in other languages.What do you guys think?EDIT:\nTo clarify: yes I know, that\'s impossible in Java and I don\'t really miss it. This is nothing I expected to work and was surprised getting a compiler error. I just had the idea and like to discuss it.It violates encapsulation. You shouldn\'t be able to bypass the parent class\'s behaviour. It makes sense to sometimes be able to bypass your own class\'s behaviour (particularly from within the same method) but not your parent\'s. For example, suppose we have a base "collection of items", a subclass representing "a collection of red items" and a subclass of that representing "a collection of big red items". It makes sense to have:That\'s fine - RedItems can always be confident that the items it contains are all red. Now suppose we were able to call super.super.add():Now we could add whatever we like, and the invariant in RedItems is broken.Does that make sense?I think Jon Skeet has the correct answer. I\'d just like to add that you can access shadowed variables from superclasses of superclasses by casting this:which produces the output:(example from the JLS)However, this doesn\'t work for method calls because method calls are determined based on the runtime type of the object.I think the following code allow to use super.super...super.method() in most case.\n(even if it\'s uggly to do that)In shortUsage :I don\'t have enough reputation to comment so I will add this to the other answers.Jon Skeet answers excellently, with a beautiful example. Matt B has a point: not all superclasses have supers. Your code would break if you called a super of a super that had no super. Object oriented programming (which Java is) is all about objects, not functions. If you want task oriented programming, choose C++ or something else. If your object doesn\'t fit in it\'s super class, then you need to add it to the "grandparent class", create a new class, or find another super it does fit into. Personally, I have found this limitation to be one of Java\'s greatest strengths. Code is somewhat rigid compared to other languages I\'ve used, but I always know what to expect. This helps with the "simple and familiar" goal of Java. In my mind, calling super.super is not simple or familiar. Perhaps the developers felt the same? In addition to the very good points that others have made, I think there\'s another reason: what if the superclass does not have a superclass?Since every class naturally extends (at least) Object, super.whatever() will always refer to a method in the superclass. But what if your class only extends Object - what would super.super refer to then? How should that behavior be handled - a compiler error, a NullPointer, etc?I think the primary reason why this is not allowed is that it violates encapsulation, but this might be a small reason too.There\'s some good reasons to do this. You might have a subclass which has a method which is implemented incorrectly, but the parent method is implemented correctly. Because it belongs to a third party library, you might be unable/unwilling to change the source. In this case, you want to create a subclass but override one method to call the super.super method.As shown by some other posters, it is possible to do this through reflection, but it should be possible to do something like(SuperSuperClass this).theMethod();I\'m dealing with this problem right now - the quick fix is to copy and paste the superclass method into the subsubclass method :)I think if you overwrite a method and want to all the super-class version of it (like, say for equals), then you virtually always want to call the direct superclass version first, which one will call its superclass version in turn if it wants. I think it only makes rarely sense (if at all. i can\'t think of a case where it does) to call some arbitrary superclass\' version of a method. I don\'t know if that is possible at all in Java. It can be done in C++:At a guess, because it\'s not used that often.  The only reason I could see using it is if your direct parent has overridden some functionality and you\'re trying to restore it back to the original.Which seems to me to be against OO principles, since the class\'s direct parent should be more closely related to your class than the grandparent is.I would put the super.super method body in another method, if possibleOr if you cannot change the super-super class, you can try this:In both cases, theresults to "I am super super"It would seem to be possible to at least get the class of the superclass\'s superclass, though not necessarily the instance of it, using reflection; if this might be useful, please consider the Javadoc at http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Class.html#getSuperclass()run:\nA\nBUILD SUCCESSFUL (total time: 0 seconds)I have had situations like these when the architecture is to build common functionality in a common CustomBaseClass which implements on behalf of several derived classes.\nHowever, we need to circumvent common logic for specific method for a specific derived class. In such cases, we must use a super.super.methodX implementation.We achieve this by introducing a boolean member in the CustomBaseClass, which can be used to selectively defer custom implementation and yield to default framework implementation where desirable.However, with good architecture principles followed in framework as well as app, we could avoid such situations easily, by using hasA approach, instead of isA approach. But at all times it is not very practical to expect well designed architecture in place, and hence the need to get away from solid design principles and introduce hacks like this.\nJust my 2 cents...@Jon Skeet Nice explanation. \nIMO if some one wants to call super.super method then one must be want to ignore the behavior of immediate parent, but want to access the grand parent behavior.\nThis can be achieved through instance Of. As below codeHere is driver class,Output of this will be Class B printClass behavior will be ignored in this case.\nI am not sure about is this a ideal or good practice to achieve super.super, but still it is working.If you think you are going to be needing the superclass, you could reference it in a variable for that class. For example:Should print out:IMO, it\'s a clean way to achieve super.super.sayYourName() behavior in Java.Output:Request to lie: d.sayYourName(true) returns Grandma Fedora\nRequest not to lie: d.sayYourName(false) returns Little girl MashaCalling of super.super.method() make sense when you can\'t change code of base class. This often happens when you are extending an existing library.Ask yourself first, why are you extending that class? If answer is "because I can\'t change it" then you can create exact package and class in your application, and rewrite naughty method or create delegate:For instance, you can create org.springframework.test.context.junit4.SpringJUnit4ClassRunner class in your application so this class should be loaded before the real one from jar. Then rewrite methods or constructors.Attention: This is absolute hack, and it is highly NOT recommended to use but it\'s WORKING! Using of this approach is dangerous because of possible issues with class loaders. Also this may cause issues each time you will update library that contains overwritten class.I think this is a problem that breaks the inheritance agreement. \nBy extending a class  you obey / agree  its behavior, features \nWhilst when calling super.super.method(), you want to break your own obedience  agreement.You just cannot cherry pick from the super class. However,  there  may happen situations when you feel the need to call super.super.method() -  usually a bad design sign,  in your code or in the code you inherit ! \nIf the super and super super classes cannot be refactored (some legacy code), then opt for composition over inheritance.\nEncapsulation breaking is when you @Override some methods by breaking the encapsulated code.\nThe methods  designed not to be overridden are marked\n final.In C# you can call a method of any ancestor like this:Also you can do this in Delphi: But in Java you can do such focus only by some gear. One possible way is:objC.DoIt() result output:It is simply easy to do. For instance:C subclass of B and B subclass of A. Both of three have method methodName() for example.public abstract class A {}public class B extends A {}public class C extends B {}Run class C Output will be:\nClass A\nClass CInstead of output:\nClass A\nClass B\nClass COutput: Printed in the GrandDad