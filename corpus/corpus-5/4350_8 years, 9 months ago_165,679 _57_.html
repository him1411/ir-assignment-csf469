I would like to keep my .bashrc and .bash_login files in version control so that I can use them between all the computers I use. The problem is I have some OS specific aliases so I was looking for a way to determine if the script is running on Mac OS X, Linux or Cygwin.What is the proper way to detect the operating system in a Bash script?For my .bashrc, I use the following code:Then I do somethings like:It\'s ugly, but it works. You may use case instead of if if you prefer.The bash manpage says that the variable OSTYPE stores the name of the operation system:OSTYPE Automatically set to a string that describes the operating system on which bash is executing.   The  default  is  system-\n                dependent.It is set to linux-gnu here.I think the following should work. I\'m not sure about win32 though.You can simply use pre-defined $OSTYPE variable ie.:Another method is to detect platform based on uname command.See the following script (ready to include in .bashrc):You can find some practical example in my .bashrc.Detecting operating system and CPU type is not so easy to do portably.  I have a sh script of about 100 lines that works across a very wide variety of Unix platforms: any system I have used since 1988.The key elements areuname -p is processor type but is usually unknown on modern Unix platforms.uname -m will give the "machine hardware name" on some Unix systems./bin/arch, if it exists, will usually give the type of processor.uname with no arguments will name the operating system.Eventually you will have to think about the distinctions between platforms and how fine you want to make them.  For example, just to keep things simple, I treat i386 through i686 , any "Pentium*" and any "AMD*Athlon*" all as x86.My ~/.profile runs an a script at startup which sets one variable to a string indicating the combination of CPU and operating system.  I have platform-specific bin, man, lib, and include directories that get set up based on that.  Then I set a boatload of environment variables.  So for example, a shell script to reformat mail can call, e.g., $LIB/mailfmt which is a platform-specific executable binary.If you want to cut corners, uname -m and plain uname will tell you what you want to know on many platforms.  Add other stuff when you need it.  (And use case, not nesteed if!)I recommend to use this complete bash codemore examples examples here: https://github.com/coto/server-easy-install/blob/master/lib/core.shIn bash, use $OSTYPE and $HOSTTYPE, as documented; this is what I do.  If that is not enough, and if even uname or uname -a (or other appropriate options) does not give enough information, there\xe2\x80\x99s always the config.guess script from the GNU project, made exactly for this purpose.Try using "uname". For example, in Linux: "uname -a".According to the manual page, uname conforms to SVr4 and POSIX, so it should be available on Mac OS X and Cygwin too, but I can\'t confirm that.BTW: $OSTYPE is also set to linux-gnu here :)or if you want more informationI wrote a personal Bash library and scripting framework that uses GNU shtool to do a rather accurate platform detection.GNU shtool is a very portable set of scripts that contains, among other useful things, the \'shtool platform\' command. Here is the output of:on a few different machines:This produces pretty satisfactory results, as you can see. GNU shtool is a little slow, so I actually store and update the platform identification in a file on the system that my scripts call. It\'s my framework, so that works for me, but your mileage may vary.Now, you\'ll have to find a way to package shtool with your scripts, but it\'s not a hard exercise. You can always fall back on uname output, also.EDIT:I missed the post by Teddy about config.guess (somehow). These are very similar scripts, but not the same. I personally use shtool for other uses as well, and it has been working quite well for me.I would suggest avoiding some of these answers. Don\'t forget that you can choose other forms of string comparison, which would clear up most of the variations, or ugly code offered.One such solution would be a simple check, such as:\nif [[ "$OSTYPE" =~ ^darwin ]]; then\nWhich has the added benefit of matching any version of Darwin, despite it\'s version suffix. This also works for any variations of Linux one may expect.You can see some additional examples within my dotfiles hereThis should be safe to use on all distros.This produces something like this.Extract/assign to variables as you wishNote: On some setups. This may also give you some errors that you can ignore.I wrote these sugars in my .bashrc:So I can do stuff like:Doing the following helped perform the check correctly for ubuntu:I tend to keep my .bashrc and .bash_alias on a file share that all platforms can access. This is how I conquer the problem in my .bash_alias:And I have for example a .bash_alias_Linux with:This way I keep platform specific and portable code separate, you can do the same for .bashrcYou can use following if clause and expand it as needed:Below it\'s an approach to detect Debian and RedHat based Linux OS making use of the /etc/lsb-release and /etc/os-release (depending on the Linux flavor you\'re using) and take a simple action based on it. Output example for Ubuntu Linux:I tried the above messages across a few Linux distros and found the following to work best for me.  It\xe2\x80\x99s a short, concise exact word answer that works for Bash on Windows as well.