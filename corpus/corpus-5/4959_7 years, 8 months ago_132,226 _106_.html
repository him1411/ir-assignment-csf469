This is the best algorithm I could come up.Can it be made even faster?This code has a flaw: Since numbers is an unordered set, there is no guarantee that numbers.pop() will remove the lowest number from the set. Nevertheless, it works (at least for me) for some input numbers:Warning: timeit results may vary due to differences in hardware or\nversion of Python.  Below is a script which compares a number of implementations: \nMany thanks to stephan for bringing sieve_wheel_30 to my attention.\nCredit goes to Robert William Hanks for primesfrom2to, primesfrom3to, rwh_primes, rwh_primes1, and rwh_primes2.Of the plain Python methods tested, with psyco, for n=1000000,\nrwh_primes1 was the fastest tested.Of the plain Python methods tested, without psyco, for n=1000000,\nrwh_primes2 was the fastest.Of all the methods tested, allowing numpy, for n=1000000,\nprimesfrom2to was the fastest tested.Timings were measured using the command:with {method} replaced by each of the method names.primes.py:Running the script tests that all implementations give the same result.Related question(dealing with primes generators & including benchmarks):\nSpeed up bitstring/bit operations in Python? Faster & more memory-wise pure Python code:or starting with half sieveFaster & more memory-wise numpy code:a faster variation starting with a third of a sieve:A (hard-to-code) pure-python version of the above code would be:Unfortunately pure-python don\'t adopt the simpler and faster numpy way of doing Assignment, and calling len() inside the loop as in [False]*len(sieve[((k*k)/3)::2*k]) is too slow. So i had to improvise to correct input (& avoid more math) and do some extreme (& painful) math-magic.\n  Personally i think it is a shame that numpy (which is so widely used) is not part of python standard library(2 years after python 3 release & no numpy compatibility), and that the improvements in syntax and speed seem to be completely overlooked by python developers.There\'s a pretty neat sample from the Python Cookbook here -- the fastest version proposed on that URL is:so that would giveMeasuring at the shell prompt (as I prefer to do) with this code in pri.py, I observe:so it looks like the Cookbook solution is over twice as fast.Using Sundaram\'s Sieve, I think I broke pure-Python\'s record:Comparasion:The algorithm is fast, but it has a serious flaw:You assume that numbers.pop() would return the smallest number in the set, but this is not guaranteed at all. Sets are unordered and pop() removes and returns an arbitrary element, so it cannot be used to select the next prime from the remaining numbers.For truly fastest solution with sufficiently large N would be to download a pre-calculated list of primes, store it as a tuple and do something like:If N > primes[-1] only then calculate more primes and save the new list in your code, so next time it is equally as fast.Always think outside the box.If you don\'t want to reinvent the wheel, you can install the symbolic maths library sympy (yes it\'s Python 3 compatible)And use the primerange functionIt\'s instructive to write your own prime finding code, but it\'s also useful to have a fast reliable library at hand. I wrote a wrapper around the C++ library primesieve, named it primesieve-pythonTry it pip install primesieveI\'d be curious to see the speed compared.If you accept itertools but not numpy, here is an adaptation of rwh_primes2 for Python 3 that runs about twice as fast on my machine.  The only substantial change is using a bytearray instead of a list for the boolean, and using compress instead of a list comprehension to build the final list.  (I\'d add this as a comment like moarningsun if I were able.)Comparisons:andIf you have control over N, the very fastest way to list all primes is to precompute them. Seriously. Precomputing is a way overlooked optimization.Here\'s the code I normally use to generate primes in Python:It can\'t compete with the faster solutions posted here, but at least it is pure python.Thanks for posting this question. I really learnt a lot today. For the fastest code, the numpy solution is the best. For purely academic reasons, though, I\'m posting my pure python version, which is a bit less than 50% faster than the cookbook version posted above. Since I make the entire list in memory, you need enough space to hold everything, but it seems to scale fairly well.And the results:A deterministic implementation of Miller-Rabin\'s Primality test on the assumption that N < 9,080,191According to the article on Wikipedia (http://en.wikipedia.org/wiki/Miller\xe2\x80\x93Rabin_primality_test) testing N < 9,080,191 for a = 2,3,37, and 73 is enough to decide whether N is composite or not.And I adapted the source code from the probabilistic implementation of original Miller-Rabin\'s test found here: http://en.literateprograms.org/Miller-Rabin_primality_test_(Python)A slightly different implementation of a half sieve using Numpy:http://rebrained.com/?p=458Can someone compare this with the other timings?  On my machine it seems pretty comparable to the other Numpy half-sieve.First time using python, so some of the methods I use in this might seem a bit cumbersome. I just straight converted my c++ code to python and this is what I have (albeit a tad bit slowww in python)pythonw Primes.pyFound 664579 primes in 12.799119 seconds!pythonw Primes2.pyFound 664579 primes in 10.230172 seconds!python Primes2.pyFound 664579 primes in 7.113776 seconds!I know the competition is closed for some years. \xe2\x80\xa6Nonetheless this is my suggestion for a pure python prime sieve, based on omitting the multiples of 2, 3 and 5 by using appropriate steps while processing the sieve forward. Nonetheless it is actually slower for N<10^9 than @Robert William Hanks superior solutions rwh_primes2 and rwh_primes1. By using a ctypes.c_ushort sieve array above 1.5* 10^8 it is somehow adaptive to memory limits.10^6$ python -mtimeit -s"import primeSieveSpeedComp" "primeSieveSpeedComp.primeSieveSeq(1000000)"\n10 loops, best of 3: 46.7 msec per loopto compare:$ python -mtimeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes1(1000000)" 10 loops, best of 3: 43.2\n  msec per loop\n  to compare: $ python -m timeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes2(1000000)" 10 loops, best of 3: 34.5\n  msec per loop10^7$ python -mtimeit -s"import primeSieveSpeedComp" "primeSieveSpeedComp.primeSieveSeq(10000000)"\n10 loops, best of 3: 530 msec per loopto compare:$ python -mtimeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes1(10000000)" 10 loops, best of 3: 494\n  msec per loop\n  to compare: $ python -m timeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes2(10000000)" 10 loops, best of 3: 375\n  msec per loop10^8$ python -mtimeit -s"import primeSieveSpeedComp" "primeSieveSpeedComp.primeSieveSeq(100000000)"\n10 loops, best of 3: 5.55 sec per loopto compare: $ python -mtimeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes1(100000000)" 10 loops, best of 3: 5.33\n  sec per loop\n  to compare: $ python -m timeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes2(100000000)" 10 loops, best of 3: 3.95\n  sec per loop10^9$ python -mtimeit -s"import primeSieveSpeedComp" "primeSieveSpeedComp.primeSieveSeq(1000000000)"\n10 loops, best of 3: 61.2 sec per loopto compare: $ python -mtimeit -n 3 -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes1(1000000000)" 3 loops, best of 3: 97.8\n  sec per loopto compare: $ python -m timeit -s"import primeSieveSpeedComp"\n  "primeSieveSpeedComp.rwh_primes2(1000000000)" 10 loops, best of 3:\n  41.9 sec per loopYou may copy the code below into ubuntus primeSieveSpeedComp to review this tests.It\'s all written and tested. So there is no need to reinvent the wheel.gives us a record breaking 12.2 msec!If this is not fast enough, you can try PyPy:which results in:The answer with 247 up-votes lists 15.9 ms for the best solution.\nCompare this!!!I tested  some unutbu\'s functions, i computed it with hungred millions numberThe winners are the functions that use numpy library, Note: It would also interesting make a memory utilization test :)Sample codeComplete code on my github repositoryIn general if you need fast number computation python is not the best choice. Today there are a lot of faster (and complex) algorithm. For example on my computer I got 2.2 second for your code, with Mathematica I got 0.088005.First of all: do you need set?The easiest optimization to implement is that if you want to check whether n is prime, you only have to check to see if n is divisible by a number up to square_root(n).\nIs this for Project Euler?My guess is that the fastest of all ways is to hard code the primes in your code.So why not just write a slow script that generates another source file that has all numbers hardwired in it, and then import that source file when you run your actual program.Of course, this works only if you know the upper bound of N at compile time, but thus is the case for (almost) all project Euler problems. Â PS: I might be wrong though iff parsing the source with hard-wired primes is slower than computing them in the first place, but as far I know Python runs from compiled .pyc files so reading a binary array with all primes up to N should be bloody fast in that case.Sorry to bother but erat2() has a serious flaw in the algorithm.While searching for the next composite, we need to test odd numbers only.\nq,p both are odd; then q+p is even and doesn\'t need to be tested, but q+2*p is always odd. This eliminates the "if even" test in the while loop condition and saves about 30% of the runtime.While we\'re at it: instead of the elegant \'D.pop(q,None)\' get and delete method use \'if q in D: p=D[q],del D[q]\' which is twice as fast! At least on my machine (P3-1Ghz).\nSo I suggest this implementation of this clever algorithm:The fastest method I\'ve tried so far is based on the Python cookbook erat2 function:See this answer for an explanation of the speeding-up.I may be late to the party but will have to add my own code for this. It uses approximately n/2 in space because we don\'t need to store even numbers and I also make use of the bitarray python module, further draStically cutting down on memory consumption and enabling computing all primes up to 1,000,000,000This was run on a 64bit 2.4GHZ MAC OSX 10.8.3I collected several prime number sieves over time. The fastest on my computer is this:I\'m slow responding to this question but it seemed like a fun exercise. I\'m using numpy which might be cheating and I doubt this method is the fastest but it should be clear. It sieves a Boolean array referring to its indices only and elicits prime numbers from the indices of all True values. No modulo needed.For Python 3This is an elegant and simpler solution to find primes using a stored list. Starts with a 4 variables, you only have to test odd primes for divisors, and you only have to test up to a half of what number you are testing as a prime (no point in testing whether 9, 11, 13 divide into 17). It tests previously stored primes as divisors.`This is the way you can compare with others.So simple...