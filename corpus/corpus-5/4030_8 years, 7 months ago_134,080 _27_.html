What\'s the difference between these two methods? They appear to do exactly the same thing to me (also goes for parseFloat(), parseDouble(), parseLong() etc, how are they different from Long.valueOf(string) ?Edit: Also, which of these is preferable and used more often by convention?Well, the API for Integer.valueOf(String) does indeed say that the String is interpreted exactly as if it were given to Integer.parseInt(String). However, valueOf(String) returns a new Integer() object whereas parseInt(String) returns a primitive int. If you want to enjoy the potential caching benefits of Integer.valueOf(int), you could also use this eyesore:Now, if what you want is the object and not the primitive, then using valueOf(String) may be more attractive than making a new object out of parseInt(String) because the former is consistently present across Integer, Long, Double, etc.From this forum:parseInt() returns primitive integer\n  type (int), whereby valueOf returns\n  java.lang.Integer, which is the object\n  representative of the integer. There\n  are circumstances where you might want\n  an Integer object, instead of\n  primitive type.Of course, another obvious difference\n  is that intValue is an instance method\n  whereby parseInt is a static method.is similar toThe difference is valueOf() returns an Integer, and parseInt() returns an int (a primitive type). Also note that valueOf() can return a cached Integer instance, which can cause confusing results where the result of == tests seem intermittently correct.  Before autoboxing there could be a difference in convenience, after java 1.5 it doesn\'t really matter.Moreover, Integer.parseInt(s) can take primitive datatype as well.Look at Java sources: valueOf is using parseInt :parseInt returns intInteger.parseInt can just return int as native type.Integer.valueOf may actually need to allocate an Integer object, unless that integer happens to be one of the preallocated ones. This costs more.If you need just native type, use parseInt. If you need an object, use valueOf.Also, because of this potential allocation, autoboxing isn\'t actually good thing in every way. It can slow down things.Because you might be using jdk1.5+ and there it is auto converting to int. So in your code its first returning Integer and then auto converted to int.your code is same as The parse* variations return primitive types and the valueOf versions return Objects. I believe the valueOf versions will also use an internal reference pool to return the SAME object for a given value, not just another instance with the same internal value.Since valueOf return a new Integer object why the code below is correct?If you check the Integer class you will find that valueof call parseInt method. The big difference is caching when you call valueof API . It cache if the value is between -128 to 127 Please find below the link for more informationhttp://docs.oracle.com/javase/7/docs/api/java/lang/Integer.htmlpublic static Integer valueOf(String s)The result is an Integer object that represents the integer value specified by the string.In other words, this method returns an Integer object equal to the value of:\nnew Integer(Integer.parseInt(s))We should use any one depending upon our need. In case of ValueOf as it is instantiating an object. it will consume more resources if we only need value of some text then we should use parseInt,parseFloat etc. 