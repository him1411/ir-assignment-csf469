What\'s the best way to merge 2 or more dictionaries (Dictionary<T1,T2>) in C#?\n(3.0 features like LINQ are fine).I\'m thinking of a method signature along the lines of:orEDIT: Got a cool solution from JaredPar and Jon Skeet, but I was thinking of something that handles duplicate keys. In case of collision, it doesn\'t matter which value is saved to the dict as long as it\'s consistent.This partly depends on what you want to happen if you run into duplicates. For instance, you could do:That will blow up if you get any duplicate keys.EDIT: If you use ToLookup then you\'ll get a lookup which can have multiple values per key. You could then convert that to a dictionary:It\'s a bit ugly - and inefficient - but it\'s the quickest way to do it in terms of code. (I haven\'t tested it, admittedly.)You could write your own ToDictionary2 extension method of course (with a better name, but I don\'t have time to think of one now) - it\'s not terribly hard to do, just overwriting (or ignoring) duplicate keys. The important bit (to my mind) is using SelectMany, and realising that a dictionary supports iteration over its key/value pairs.I would do it like this:Simple and easy. According to this blog post it\'s even faster than most loops as its underlying implementation accesses elements by index rather than enumerator (see this answer).It will of course throw an exception if there are duplicates, so you\'ll have to check before merging.Well, I\'m late to the party, but here is what I use. It doesn\'t explode if there are multiple keys ("righter" keys replace "lefter" keys), can merge a number of dictionaries (if desired) and preserves the type (with the restriction that it requires a meaningful default public constructor):The trivial solution would be:Try the followingThe following works for me. If there are duplicates, it will use dictA\'s value.Here is a helper function I use:Considering the performance of dictionary key lookups and deletes since they are hash operations, and considering the wording of the question was best way, I think that below is a perfectly valid approach, and the others are a bit over-complicated, IMHO. OR if you\'re working in a multithreaded application and your dictionary needs to be thread safe anyway, you should be doing this:You could then wrap this to make it handle an enumeration of dictionaries. Regardless, you\'re looking at about ~O(3n) (all conditions being perfect), since the .Add() will do an additional, unnecessary but practically free, Contains() behind the scenes. I don\'t think it gets much better.If you wanted to limit extra operations on large collections, you should sum up the Count of each dictionary you\'re about to merge and set the capacity of the the target dictionary to that, which avoids the later cost of resizing. So, end product is something like this...Note that I took in an IList<T> to this method... mostly because if you take in an IEnumerable<T>, you\'ve opened yourself up to multiple enumerations of the same set, which can be very costly if you got your collection of dictionaries from a deferred LINQ statement.How about adding a params overload?Also, you should type them as IDictionary for maximum flexibility.Based on the answers above, but adding a Func-parameter to let the caller handle the duplicates:The party\'s pretty much dead now, but here\'s an "improved" version of user166390 that made its way into my extension library.\nApart from some details, I added a delegate to calculate the merged value.I\'m very late to the party and perhaps missing something, but if either there are no duplicate keys or, as the OP says, "In case of collision, it doesn\'t matter which value is saved to the dict as long as it\'s consistent," what\'s wrong with this one (merging D2 into D1)?  It seems simple enough, maybe too simple, I wonder if I\'m missing something.  This is what I\'m using in some code where I know there are no duplicate keys.  I\'m still in testing, though, so I\'d love to know now if I\'m overlooking something, instead of finding out later.@Tim: Should be a comment, but comments don\'t allow for code editing.Note: I applied the modification by @ANeves to the solution by @Andrew Orsich, so the MergeLeft looks like this now:I know this is an old question, but since we now have LINQ you can do it in a single line like thisor Merging using an extension method. It does not throw exception when there are duplicate keys, but replaces those keys with keys from the second dictionary.Usage:Merging using an EqualityComparer that maps items for comparison to a different value/type. Here we will map from KeyValuePair (item type when enumerating a dictionary) to Key.Usage: