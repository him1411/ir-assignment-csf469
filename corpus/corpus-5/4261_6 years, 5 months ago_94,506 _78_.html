Here is a function I was working on to programmatically lighten or darken a hex color by a specific amount. Just pass in a string like "3F6D2A" for the color (col) and an base10 integer (amt) for the amount to lighten or darken. To darken, pass in a negative number (i.e. -20).The reason for me to do this was because of all the solutions I found, thus far, they seemed to over-complicate the issue. And I had a feeling it could be done with just a couple lines of code. Please let me know if you find any problems, or have any adjustments to make that would speed it up.For Development use here is an easier to read version:And finally a version to handle colors that may (or may not) have the "#" in the beginning. Plus adjusting for improper color values:OK, so now its not just a couple of lines, but it seems far simpler and if you\'re not using the "#" and don\'t need to check for colors out of range, it is only a couple of lines. If not using the "#", you can just add it in code like:I guess my main question is, am I correct here? Does this not encompass some (normal) situations?TL;DR? --Want simple lighten/darken(shading)? Skip down to Version 2, pick the one for RGB or Hex. --Want a full featured shader/blender/converter with errorcheck and alpha and 3 Digit hex? Use Version 3 near the bottom.Play with version 3: http://www.pimptrizkit.com/?t=20%20ShadesAfter some pondering... I decided to answer my own question. A year and a half later. This was truly an adventure with ideas from several helpful users, and I thank you all! This one is for the team! While its not necessarily the answer I was looking for.  Because if what James Khoury is saying is true, then there is no true hex math in javascript, I have to use decimals, this double conversion is necessary. If we make this assumption, then this is probably the fastest way I\'ve seen (or can think of) to lighten (add white) or darken (add black) an arbitrary RBG color by percentage. It also accounts for the issues Cool Acid mentioned on his answer to this question (it pads 0s). But this version calls toString only once. This also accounts for out of range (it will enforce 0 and 255 as limits).But beware, the color input has to be EXACTLY 7 characters, like #08a35c. (or 6 if using the top version)Thanks to Pablo for the inspiration and idea for using percentage. For this I will keep the function name the same! lol! However, this one is different, as it normalizes the percentage to 255 and thus adding the same amount to each color (more white). If you pass in 100 for percent it will make your color pure white. If you pass in 0 for percent, nothing will happen. If you pass in 1 for percent it will add 3 shades to all colors (2.55 shades per 1%, rounded). So your really passing in a percentage of white (or black, use negative). Therefore, this version allows you to lighten pure red (FF0000), for example.I also used insight from Keith Mashinter\'s answer to this question: How to convert decimal to hex in JavaScript?I removed some, seemly, unnecessary parenthesis. (like in the double ternary statement and in crafting G) Not sure if this will mess with the operator precedence in some environments. Tested good in FireFox.Or, if you want it to handle the "#":Hows that for two lines of code?EDIT: Fix B<->G swap goof. Thanks svachalek!--  UPDATE - Version 2 with Blending --A little over a year later, again, and its still going. But this time I think its done. Noting the problems mentioned about not using HSL to properly lighten the color. There is a technique that eliminates most of that inaccuracy without having to convert to HSL. The main problem is that a color channel will get fully saturated before the rest of the color. Causing a shift in the hue after that point. I found these questions here, here and here which got me on track. Mark Ransom\'s post showed me the difference, and Keith\'s post showed me the way. Lerp is the savior. It is the same as blending colors, so I created a blendColors function as well.TL;DR - For simple lighten/darken use this function shadeColor2 below. Or its RGB counterpart shadeRGBColor further below, and give me one vote. But, if you want any and/or all the goodies. Such as the ability to use both RGB and Hex colors, Error Checking, 3 Digit hex decoding, Blending, Alpha Channels, and RGB2Hex / Hex2RGB conversions. Then, skip down to Version 3 for shadeBlendConvert to get all the bells and whistles and give me two votes. You can then delete a few lines to remove some of these features, if desired. And  you get a vote if you remember that Version 1 shadeColor1 above is deprecated for all uses.So, without further ado:-Version 2 Hex-Further ado:There is no error checking, so values that get passed in which are out of range will cause unexpected results. As well, the color input has to be EXACTLY 7 characters, like #08a35c. But all the other goodies are still here like output range capping (00-FF outputs), padding (0A), handles #, and usable on solid colors, like #FF0000.This new version of shadeColor takes in a float for its second parameter. For shadeColor2 the valid range for the second (percent) parameter is -1.0 to 1.0.  And for blendColors the valid range for the third (percent) parameter is 0.0 to 1.0, negatives not allowed here.This new version is no longer taking in a percentage of pure white, like the old version. Its taking in a percentage of the DISTANCE from the color given to pure white. In the old version, it was easy to saturate the color, and as a result, many colors would compute to pure white when using a sizable percentage. This new way, it only computes to pure white if you pass in 1.0, or pure black, use -1.0.Calling blendColors(color, "#FFFFFF", 0.5) is the same as shadeColor2(color,0.5). As well as, blendColors(color,"#000000", 0.5) is the same as shadeColor2(color,-0.5). Just a touch slower.shadeColor2 is slower than shadeColor1, but not by a notable amount. (Wait, thats a self-contradicting statement!)The accuracy gained can be seen here:-- Version 2 RGB --Usages:-- Version 2 Universal A --Usage:-- Version 2 Universal B --Ok, fine! The popularity of this answer made me think I could do a much better Universal version of this. So here you go! This version is an All-In-One function copy/paste-able shader/blender for both RGB and Hex colors. This one is not really any different than the other Uni version provided above. Except that its much much smaller and just one function to paste and use. I think the size went from about 1,592 characters to 557 characters, if you compress it into one line. Of course, if you don\'t need to use it interchangeably between RGB and Hex, then you don\'t need a Universal version such as this anyhow, lol. Just use one of the much tinier and faster versions above; appropriate for your color scheme. Moving on... In some ways its a little faster, in some ways its a little slower. I didn\'t do any final speed test analysis. There are two usage differences: First, the percentage is now the first parameter of the function, instead of the last. Second, when blending, you can use negative numbers. They will just get converted to positive numbers.No more ado:Usage:Now it might be perfect!     ;) @ Mevin* V2 OTHER LANGUAGES *-- Swift Extension - RGB (by Matej Ukmar) ---- PHP Version - HEX (by Kevin M) ---- UPDATE -- Version 3 Universal --In a couple months it will have been yet another year since the last universal version. So... thanks to sricks\'s insightful comment. I have decided to take it to the next level, again. It\'s no longer the two line speed demon as it had started, lol. But, for what it does, it is quite fast and small. Its 1249 bytes if you compress it (all-in-one line, no whites, single character var names). If you additionally remove ErrorChecking and remove 3 digit decoding you can get it down to 955 bytes and its faster. This is a lot of power in under 1k.  Just imagine, you could load this onto a Commodore64 and still have space for 63 more of them! (Disregarding the fact that the JavaScript Engine is larger than 63k)Apparently there was more adoing to be doing:Play with version 3: http://www.pimptrizkit.com/?t=20%20ShadesThe core math of this version is the same as before. But, I did some major refactoring. This has allowed for much greater functionality and control. It now inherently converts RGB2Hex and Hex2RGB.All the old features from v2 above should still be here. I have tried to test it all, please post a comment if you find anything wrong. Anyhow, here are the new features:Usages:I now hesitate to call this done... again...PT--EDIT: Switched version 3 to use let, and an arrow function, and added this to sbcRip calls.I made a solution that works very nice for me:Example Lighten:Example Darken:I tried your function and there was a little bug: If some final \'r\' value is 1 digit only, the result comes up like: \'a0a0a\' when the right value is \'0a0a0a\', for example.\nI just quick-fixed it by adding this instead of your return:Maybe it\'s not so nice but it do the work. Great function, BTW. Just what I needed. :)have you thought about an rgb > hsl conversion? then just move the Luminosity up and down? thats the way I would go.A quick look for some algorithms got me the following sites.PHP:\nhttp://serennu.com/colour/rgbtohsl.php\nJavascript:\nhttp://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascriptEDIT the above link is no longer valid. You can view git hub for the page source or the gistAlternatively another StackOverflow question might be a good place to look.Even though this is not the right choice for the OP the following is an approximation of the code I was originally suggesting. (Assuming you have rgb/hsl conversion functions)This assumes:Although if we are discussing css there is a syntax for specifying hsl/hsla for IE9/Chrome/Firefox. C# Version...\nnote that I am getting color strings in this format #FF12AE34, and need to cut out the #FF.This is what I used based on your function. I prefer to use steps over percentage because it\'s more intuitive for me.For example, 20% of a 200 blue value is much different than 20% of a 40 blue value.Anyways, here\'s my modification, thanks for your original function.The following method will allow you to lighten or darken a Hexadecimal color string:Pass in a value between -1 and 1 (-1 is black, 0 is unchanged, 1 is white):How to simple shade color in PHP? I made a port of the excellent xcolor library to remove its jQuery dependency. There are a ton of functions in there including lightening and darkening colors. Really, converting hex to RGB is a completely separate function from lightening or darkening colors. Keep things DRY please. In any case, once you have an RGB color, you can just add the difference between the light level you want and the light level you have to each of the RGB values:See https://github.com/fresheneesz/xolor for more of the source.I\'ve long wanted to be able to produce tints/shades of colours, here is my JavaScript solution: 