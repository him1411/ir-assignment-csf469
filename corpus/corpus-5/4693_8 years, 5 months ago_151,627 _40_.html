I have an enum in a low level namespace. I\'d like to provide a class or enum in a mid level namespace that "inherits" the low level enum.I\'m hoping that this is possible, or perhaps some kind of class that can take the place of the enum consume which will provide a layer of abstraction for the enum, but still let an instance of that class access the enum.Thoughts?EDIT:\nOne of the reasons I haven\'t just switched this to consts in classes is that the low level enum is needed by a service that I must consume. I have been given the WSDLs and the XSDs, which define the structure as an enum. The service cannot be changed.This is not possible.  Enums cannot inherit from other enums. In fact all enums must actually inherit from System.Enum.  C# allows syntax to change the underlying representation of the enum values which looks like inheritance, but in actuality they still inherit from System.enum.See section 8.5.2 of the CLI spec for the full details.  Relevant information from the specYou can achieve what you want with classes:Now you can use these classes similar as when they were enums:Update (after your update of the question):If you assign the same int values to the constants as defined in the existing enum, then you can cast between the enum and the constants, e.g:The short answer is no.  You can play a bit, if you want:You can always do something like this:But, it doesn\'t work all that great because Base.A != Consume.AYou can always do something like this, though:In order to cross between Base and Consume... You could also cast the values of the enums as ints, and compare them as ints instead of enum, but that kind of sucks too.The extension method return should type cast it type T.The solutions above using classes with int constants lack type-safety. I.e. you could invent new values actually not defined in the class.\nFurthermore it is not possible for example to write a method taking one of these classes as input.You would need to writeHowever, there is a class based solution of the old days of Java, when there were no enums available. This provides an almost enum-like behaviour. The only caveat is that these constants cannot be used within a switch-statement.Ignoring the fact that base is a reserved word you cannot do inheritance of enum.The best thing you could do is something like that:Since they\'re all the same base type (ie: int) you could assign the value from an instance of one type to the other which a cast. Not ideal but it work.I know this answer is kind of late but this is what I ended up doing:Then I am able to do things like:This is what I did. What I\'ve done differently is use the same name and the new keyword on the "consuming" enum. Since the name of the enum is the same, you can just mindlessly use it and it will be right. Plus you get intellisense. You just have to manually take care when setting it up that the values are copied over from the base and keep them sync\'ed. You can help that along with code comments. This is another reason why in the database when storing enum values I always store the string, not the value. Because if you are using automatically assigned increasing integer values those can change over time.Enums are not actual classes, even if they look like it. Internally, they are treated just like their underlying type (by default Int32). Therefore, you can only do this by "copying" single values from one enum to another and casting them to their integer number to compare them for equality.Enums cannot be derrived from other enums, but only from int, uint, short, ushort, long, ulong, byte and sbyte. Like Pascal said, you can use other enum\'s values or constants to initialize an enum value, but that\'s about it. another possible solution:HTHThis is not possible (as @JaredPar already mentioned). Trying to put logic to work around this is a bad practice. In case you have a base class that have an enum, you should list of all possible enum-values there, and the implementation of class should work with the values that it knows.E.g. Supposed you have a base class BaseCatalog, and it has an enum ProductFormats (Digital, Physical). Then you can have a MusicCatalog or BookCatalog that could contains both Digital and Physical products, But if the class is ClothingCatalog, it should only contains Physical products.I also wanted to overload Enums and created a mix of the answer of \'Seven\' on this page and the answer of \'Merlyn Morgan-Graham\' on a duplicate post of this, plus a couple of improvements.\nMain advantages of my solution over the others:  This is an out-of-the-box solution and may be directly inserted into your project. It is designed to my needs, so if you don\'t like some parts of it, just replace them with your own code.First, there is the base class CEnum that all custom enums should inherit from. It has the basic functionality, similar to the .net Enum type:Secondly, here are 2 derived Enum classes. All derived classes need some basic methods in order to work as expected. It\'s always the same boilerplate code; I haven\'t found a way yet to outsource it to the base class. The code of the first level of inheritance differs slightly from all subsequent levels. The classes have been successfully tested with follwing code:  You can perform inheritance in enum, however it\'s limited to following types only . \nint, uint, byte, sbyte, short, ushort, long, ulong E.g.