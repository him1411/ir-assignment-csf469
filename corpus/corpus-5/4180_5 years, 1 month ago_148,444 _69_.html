I am wondering if there is a way (similar to Gmail) for AngularJS to delay showing a new route until after each model and its data has been fetched using its respective services.For example, if there were a ProjectsController that listed all Projects and project_index.html which was the template that showed these Projects, Project.query() would be fetched completely before showing the new page.Until then, the old page would still continue to show (for example, if I were browsing another page and then decided to see this Project index).$routeProvider resolve property allows delaying of route change until data is loaded.First define a route with resolve attribute like this.notice that the resolve property is defined on route.Notice that the controller definition contains a resolve object which declares things which should be available to the controller constructor. Here the phones is injected into the controller and it is defined in the resolve property.The resolve.phones function is responsible for returning a promise. All of the promises are collected and the route change is delayed until after all of the promises are resolved.Working demo: http://mhevery.github.com/angular-phonecat/app/#/phones\nSource: https://github.com/mhevery/angular-phonecat/commit/ba33d3ec2d01b70eb5d3d531619bf90153496831Here\'s a minimal working example which works for Angular 1.0.2Template:JavaScript:http://jsfiddle.net/dTJ9N/3/Streamlined version:Since $http() already returns a promise (aka deferred), we actually don\'t need to create our own. So we can simplify MyCtrl. resolve to:The result of $http() contains data, status, headers and config objects, so we need to change the body of MyCtrl to:http://jsfiddle.net/dTJ9N/5/I see some people asking how to do this using the angular.controller method with minification friendly dependency injection. Since I just got this working I felt obliged to come back and help. Here\'s my solution (adopted from the original question and Misko\'s answer):Since this code is derived from the question/most popular answer it is untested, but it should send you in the right direction if you already understand how to make minification friendly angular code. The one part that my own code didn\'t requires was an injection of "Phone" into the resolve function for \'phones\', nor did I use any \'delay\' object at all.I also recommend this youtube video http://www.youtube.com/watch?v=P6KITGRQujQ&list=UUKW92i7iQFuNILqQOUOCrFw&index=4&feature=plcp , which helped me quite a bitShould it interest you I\'ve decided to also paste my own code (Written in coffeescript) so you can see how I got it working.FYI, in advance I use a generic controller that helps me do CRUD on several models:This commit, which is part of version 1.1.5 and above, exposes the $promise object of $resource. Versions of ngResource including this commit allow resolving resources like this:$routeProvidercontrollerThis snippet is dependency injection friendly (I even use it in combination of ngmin and uglify) and it\'s a more elegant domain driven based solution.The example below registers a Phone resource and a constant phoneRoutes, which contains all your routing information for that (phone) domain. Something I didn\'t like in the provided answer was the location of the resolve logic -- the main module should not know anything or be bothered about the way the resource arguments are provided to the controller. This way the logic stays in the same domain.Note: if you\'re using ngmin (and if you\'re not: you should) you only have to write the resolve functions with the DI array convention.The next piece is injecting the routing data when the module is in the configure state and applying it to the $routeProvider.Testing the route configuration with this setup is also pretty easy:You can see it in full glory in my latest (upcoming) experiment.\nAlthough this method works fine for me, I really wonder why the $injector isn\'t delaying construction of anything when it detects injection of anything that is a promise object; it would make things soooOOOOOooOOOOO much easier.Edit: used Angular v1.2(rc2)Delaying showing the route is sure to lead to an asynchronous tangle... why not simply track the loading status of your main entity and use that in the view. For example in your controller you might use both the success and error callbacks on ngResource:Then in the view you could do whatever:I worked from Misko\'s code above and this is what I\'ve done with it. This is a more current solution since $defer has been changed to $timeout. Substituting $timeout however will wait for the timeout period (in Misko\'s code, 1 second), then return the data hoping it\'s resolved in time. With this way, it returns asap.Updating the \'phones\' function in Justen\'s answer using AngularJS 1.1.5 syntax.Original:Updated:Much shorter thanks to the Angular team and contributors. :)This is also the answer of Maximilian Hoffmann. Apparently that commit made it into 1.1.5.You can use $routeProvider resolve property to delay route change until data is loaded.Notice that the resolve property is defined on route.EntitiesCtrlResolve and EntityCtrlResolve is constant objects defined in same file as EntitiesCtrl and EntityCtrl controllers.I like darkporter\'s idea because it will be easy for a dev team new to AngularJS to understand and worked straight away.I created this adaptation which uses 2 divs, one for loader bar and another for actual content displayed after data is loaded. Error handling would be done elsewhere.Add a \'ready\' flag to $scope:In html view:See also: Boostrap progress bar docsI liked above answers and learned a lot from them but there is something that is missing in most of the above answers.I was stuck in a similar scenario where I was resolving url with some data that is fetched in the first request from the server. Problem I faced was what if the promise is rejected.I was using a custom provider which used to return a Promise which was resolved by the resolve of $routeProvider at the time of config phase.What I want to stress here is the concept of when it does something like this.It sees the url in url bar and then respective when block in called controller and view is referred so far so good.Lets say I have following config phase code.On root url in browser first block of run get called otherwise otherwise gets called.Let\'s imagine a scenario I hit rootUrl in address bar AuthServicePrivider.auth() function gets called.Lets say Promise returned is in reject state  what then???Nothing gets rendered at all.Otherwise block will not get executed as it is for any url which is not defined in the config block and is unknown to angularJs config phase.We will have to handle the event that gets fired when this promise is not resolved. On failure $routeChangeErorr gets fired on $rootScope.It can be captured as shown in code below.IMO It\'s generally a good idea to put event tracking code in run block of application. This code run just after the config phase of the application.This way we can handle promise failure at the time of config phase.I have had a complex multi-level sliding panel interface, with disabled screen layer. Creating directive on disable screen layer that would create click event to execute the state like were producing a flicking effect. history.back() instead of it worked ok, however its not always back in history in my case. SO what I find out is that if I simply create attribute href on my disable screen instead of state.go , worked like a charm.  Directive \'back\'app.js I just save previous stateOne possible solution might be to use the ng-cloak directive with the element where we are using the models e.g.I think this one takes least effort.