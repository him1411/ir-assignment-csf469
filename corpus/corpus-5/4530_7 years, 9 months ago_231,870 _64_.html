I want a function that returns -1 for negative numbers and +1 for positive numbers.\nhttp://en.wikipedia.org/wiki/Sign_function\nIt\'s easy enough to write my own, but it seems like something that ought to be in a standard library somewhere.Edit: Specifically, I was looking for a function working on floats.Surprised no one has posted the branchless, type-safe C++ version yet:Benefits:Caveats:The < 0 part of the check triggers GCC\'s -Wtype-limits warning when instantiated for an unsigned type. You can avoid this by using some overloads:(Which is a good example of the first caveat.)I don\'t know of a standard function for it. Here\'s an interesting way to write it though:Here\'s a more readable way to do it:If you like the ternary operator you can do this:There is a C99 math library function called copysign(), which takes the sign from one argument and the absolute value from the other:will give you a result of +/- 1.0, depending on the sign of value.  Note that floating point zeroes are signed: (+0) will yield +1, and (-0) will yield -1.Apparently, the answer to the original poster\'s question is no.  There is no standard C++ sgn function.It seems that most of the answers missed the original question.Is there a standard sign function (signum, sgn) in C/C++?Not in the standard library, but there is in boost, which might as well be part of the standard.http://www.boost.org/doc/libs/1_47_0/libs/math/doc/sf_and_dist/html/math_toolkit/utils/sign_functions.htmlFaster than the above solutions, including the highest rated one:There\'s a way to do it without branching, but it\'s not very pretty.http://graphics.stanford.edu/~seander/bithacks.htmlLots of other interesting, overly-clever stuff on that page, too...If all you want is to test the sign, use signbit (returns true if its argument has a negative sign).\nNot sure why you would particularly want -1 or +1 returned; copysign is more convenient\nfor that, but it sounds like it will return +1 for negative zero on some platforms with\nonly partial support for negative zero, where signbit presumably would return true.Is there a standard sign function (signum, sgn) in C/C++?Yes, depending on definition.C99 and later has the signbit() macro in <math.h>int signbit(real-floating x);\n  The signbit macro returns a nonzero value if and only if the sign of its argument value is negative.  C11 \xc2\xa77.12.3.6Yet OP wants something a little different.I want a function that returns -1 for negative numbers and +1 for positive numbers.  ...  a function working on floats.Deeper:The post is not specific in the following cases, x = 0.0, -0.0, +NaN, -NaN.A classic signum() returns +1 on x>0, -1 on x>0 and 0 on x==0.Many answers have already covered that, but do not address x = -0.0, +NaN, -NaN.  Many are geared for an integer point-of-view that usually lacks Not-a-Numbers (NaN) and -0.0.  Typical answers function like signnum_typical()  On -0.0, +NaN, -NaN, they return 0.0, 0.0, 0.0.Instead, propose this functionality: On -0.0, +NaN, -NaN, it returns -0.0, +NaN, -NaN.In general, there is no standard signum function in C/C++, and the lack of such a fundamental function tells you a lot about these languages.Apart from that, I believe both majority viewpoints about the right approach to define such a function are in a way correct, and the "controversy" about it is actually a non-argument once you take into account two important caveats:A signum function should always return the type of its operand, similarly to an abs() function, because signum is usually used for multiplication with an absolute value after the latter has been processed somehow. Therefore, the major use case of signum is not comparisons but arithmetic, and the latter shouldn\'t involve any expensive integer-to/from-floating-point conversions.Floating point types do not feature a single exact zero value: +0.0 can be interpreted as "infinitesimally above zero", and -0.0 as "infinitesimally below zero". That\'s the reason why comparisons involving zero must internally check against both values, and an expression like x == 0.0 can be dangerous.Regarding C, I think the best way forward with integral types is indeed to use the (x > 0) - (x < 0) expression, as it should be translated in a branch-free fashion, and requires only three basic operations. Best define inline functions that enforce a return type matching the argument type, and add a C11 define _Generic to map these functions to a common name.With floating point values, I think inline functions based on C11 copysignf(1.0f, x), copysign(1.0, x), and copysignl(1.0l, x) are the way to go, simply because they\'re also highly likely to be branch-free, and additionally do not require casting the result from integer back into a floating point value. You should probably comment prominently that your floating point implementations of signum will not return zero because of the peculiarities of floating point zero values, processing time considerations, and also because it is often very useful in floating point arithmetic to receive the correct -1/+1 sign, even for zero values.My copy of C in a Nutshell reveals the existence of a standard function called copysign which might be useful.  It looks as if copysign(1.0, -2.0) would return -1.0 and copysign(1.0, 2.0) would return +1.0.Pretty close huh?No, it doesn\'t exist in c++, like in matlab. I use a macro in my programs for this.The accepted Answer with the overload below does indeed not trigger -Wtype-limits however it triggers -Wunused-parameter on the is_signed argument.For C++11 an alternative could be.For me it does not trigger any warnings on GCC 5.3.1This function assumes:Bit off-topic, but I use this:and I found first function - the one with two arguments, to be much more useful from "standard" sgn(), because it is most often used in code like this:vs.there is no cast for unsigned types and no additional minus.in fact i have this piece of code using sgn()The above code may not serve your purpose (getting 1 or -1), but it certainly makes it way more easier to make out the sign of the data type  (int, float, double etc)While the integer solution in the accepted answer is quite elegant it bothered me that it wouldn\'t be able to return NAN for double types, so I modified it slightly.Note that returning a floating point NAN as opposed to a hard coded NAN causes the sign bit to be set in some implementations, so the output for val = -NAN and val = NAN are going to be identical no matter what (if you prefer a "nan" output over a -nan you can put an abs(val) before the return...)I ran into this just today. So fine, there\'s no standard way but...Since the OP just needed to magnify the output range and re-centre it on 0, (-1 to 1 not 0 to 1) why not just double it and subtract 1?I used this:(x<0)*2-1Or, forcing a bit shift:(x<0)<<1-1But the compiler will likely optimize that anyway.What about:it should work out pretty good.