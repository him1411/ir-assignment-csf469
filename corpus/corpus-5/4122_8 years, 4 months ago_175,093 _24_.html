I have a Person object with a Nullable DateOfBirth property.  Is there a way to use LINQ to query a list of Person objects for the one with the earliest/smallest DateOfBirth value.Here\'s what I started with:Null DateOfBirth values are set to DateTime.MaxValue in order to rule them out of the Min consideration (assuming at least one has a specified DOB).But all that does for me is to set firstBornDate to a DateTime value.  What I\'d like to get is the Person object that matches that.  Do I need to write a second query like so:Or is there a leaner way of doing it?Unfortunately there isn\'t a built-in method to do this.PM> Install-Package morelinqAlternatively, you can use the implementation we\'ve got in MoreLINQ, in MinBy.cs. (There\'s a corresponding MaxBy, of course.) Here are the guts of it:Note that this will throw an exception if the sequence is empty, and will return the first element with the minimal value if there\'s more than one.NOTE: I include this answer for completeness since the OP didn\'t mention what the data source is and we shouldn\'t make any assumptions.This query gives the correct answer, but could be slower since it might have to sort all the items in People, depending on what data structure People is:UPDATE: Actually I shouldn\'t call this solution "naive", but the user does need to know what he is querying against. This solution\'s "slowness" depends on the underlying data. If this is a array or List<T>, then LINQ to Objects has no choice but to sort the entire collection first before selecting the first item. In this case it will be slower than the other solution suggested. However, if this is a LINQ to SQL table and DateOfBirth is an indexed column, then SQL Server will use the index instead of sorting all the rows. Other custom IEnumerable<T> implementations could also make use of indexes (see i4o: Indexed LINQ, or the object database db4o) and make this solution faster than Aggregate() or MaxBy()/MinBy() which need to iterate the whole collection once. In fact, LINQ to Objects could have (in theory) made special cases in OrderBy() for sorted collections like SortedList<T>, but it doesn\'t, as far as I know.Would do the trickDid\'nt check, but this must to do expected thing:and min:Have only checked this for Entity framework 6.0.0 >: This can be done:The following is the more generic solution. It essentially does the same thing (in O(N) order) but on any IEnumberable types and can mixed with types whose property selectors could return null.Tests:EDIT again: Sorry.  Besides missing the nullable I was looking at the wrong function, Min<(Of <(TSource, TResult>)>)(IEnumerable<(Of <(TSource>)>), Func<(Of <(TSource, TResult>)>)) does return the result type as you said.  I would say one possible solution is to implement IComparable and use Min<(Of <(TSource>)>)(IEnumerable<(Of <(TSource>)>)), which really does return an element from the IEnumerable.  Of course, that doesn\'t help you if you can\'t modify the element.  I find MS\'s design a bit weird here.Of course, you can always do a for loop if you need to, or use the MoreLINQ implementation Jon Skeet gave.I was looking for something similar myself, preferably without using a library or sorting the entire list. My solution ended up similar to the question itself, just simplified a bit. 