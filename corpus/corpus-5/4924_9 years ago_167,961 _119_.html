If one Googles for "difference between notify() and notifyAll()" then a lot of explanations will pop up (leaving apart the javadoc paragraphs). It all boils down to the number of waiting threads being waken up: one in notify() and all in notifyAll().However (if I do understand the difference between these methods right), only one thread is always selected for further monitor acquisition; in the first case the one selected by the VM, in the second case the one selected by the system thread scheduler. The exact selection procedures for both of them (in the general case) are not known to the programmer.What\'s the useful difference between notify() and notifyAll() then? Am I missing something?Simply put, it depends on why your threads are waiting to be notified. Do you want to tell one of the waiting threads that something happened, or do you want to tell all of them at the same time?In some cases, all waiting threads can take useful action once the wait finishes. An example would be a set of threads waiting for a certain task to finish; once the task has finished, all waiting threads can continue with their business. In such a case you would use notifyAll() to wake up all waiting threads at the same time.Another case, for example mutually exclusive locking, only one of the waiting threads can do something useful after being notified (in this case acquire the lock). In such a case, you would rather use notify(). Properly implemented, you could use notifyAll() in this situation as well, but you would unnecessarily wake threads that can\'t do anything anyway.Clearly, notify wakes (any) one thread in the wait set, notifyAll wakes all threads in the waiting set. The following discussion should clear up any doubts. notifyAll should be used most of the time. If you are not sure which to use, then use notifyAll.Please see explanation that follows.Read very carefully and understand. Please send me an email if you have any questions.Look at producer/consumer (assumption is a ProducerConsumer class with two methods). IT IS BROKEN (because it uses notify) - yes it MAY work - even most of the time, but it may also cause deadlock - we will see why:FIRSTLY,Why do we need a while loop surrounding the wait?We need a while loop in case we get this situation:Consumer 1 (C1) enter the synchronized block and the buffer is empty, so C1 is put in the wait set (via the wait call). Consumer 2 (C2) is about to enter the synchronized method (at point Y above), but Producer P1 puts an object in the buffer, and subsequently calls notify. The only waiting thread is C1, so it is woken and now attempts to re-acquire the object lock at point X (above).Now C1 and C2 are attempting to acquire the synchronization lock. One of them (nondeterministically) is chosen and enters the method, the other is blocked (not waiting - but blocked, trying to acquire the lock on the method). Let\'s say C2 gets the lock first. C1 is still blocking (trying to acquire the lock at X). C2 completes the method and releases the lock. Now, C1 acquires the lock. Guess what, lucky we have a while loop, because, C1 performs the loop check (guard) and is prevented from removing a non-existent element from the buffer (C2 already got it!). If we didn\'t have a while, we would get an IndexArrayOutOfBoundsException as C1 tries to remove the first element from the buffer!NOW,Ok, now why do we need notifyAll?In the producer/consumer example above it looks like we can get away with notify. It seems this way, because we can prove that the guards on the wait loops for producer and consumer are mutually exclusive. That is, it looks like we cannot have a thread waiting in the put method as well as the get method, because, for that to be true, then the following would have to be true:buf.size() == 0 AND buf.size() == MAX_SIZE (assume MAX_SIZE is not 0)HOWEVER, this is not good enough, we NEED to use notifyAll. Let\'s see why ...Assume we have a buffer of size 1 (to make the example easy to follow). The following steps lead us to deadlock. Note that ANYTIME a thread is woken with notify, it can be non-deterministically selected by the JVM - that is any waiting thread can be woken. Also note that when multiple threads are blocking on entry to a method (i.e. trying to acquire a lock), the order of acquisition can be non-deterministic. Remember also that a thread can only be in one of the methods at any one time - the synchronized methods allow only one thread to be executing (i.e. holding the lock of) any (synchronized) methods in the class. If the following sequence of events occurs - deadlock results:STEP 1:\n- P1 puts 1 char into the bufferSTEP 2:\n- P2 attempts put - checks wait loop - already a char - waitsSTEP 3:\n- P3 attempts put - checks wait loop - already a char - waitsSTEP 4:\n- C1 attempts to get 1 char \n- C2 attempts to get 1 char - blocks on entry to the get method\n- C3 attempts to get 1 char - blocks on entry to the get methodSTEP 5:\n- C1 is executing the get method - gets the char, calls notify, exits method\n- The notify wakes up P2\n- BUT, C2 enters method before P2 can (P2 must reacquire the lock), so P2 blocks on entry to the put method\n- C2 checks wait loop, no more chars in buffer, so waits\n- C3 enters method after C2, but before P2, checks wait loop, no more chars in buffer, so waitsSTEP 6:\n- NOW: there is P3, C2, and C3 waiting!\n- Finally P2 acquires the lock, puts a char in the buffer, calls notify, exits methodSTEP 7:\n- P2\'s notification wakes P3 (remember any thread can be woken)\n- P3 checks the wait loop condition, there is already a char in the buffer, so waits.\n- NO MORE THREADS TO CALL NOTIFY and THREE THREADS PERMANENTLY SUSPENDED!SOLUTION: Replace notify with notifyAll in the producer/consumer code (above).Useful differences:Use notify() if all your waiting threads are interchangeable (the order they wake up doesn\'t matter), or if you only ever have one waiting thread. A common example is a thread pool used to execute jobs from a queue--when a job is added, one of threads is notified to wake up, execute the next job and go back to sleep.Use notifyAll() for other cases where the waiting threads may have different purposes and should be able to run concurrently. An example is a maintenance operation on a shared resource, where multiple threads are waiting for the operation to complete before accessing the resource.I think it depends on how resources are produced and consumed. If 5 work objects are available at once and you have 5 consumer objects, it would make sense to wake up all threads using notifyAll() so each one can process 1 work object.If you have just one work object available, what is the point in waking up all consumer objects to race for that one object? The first one checking for available work will get it and all other threads will check and find they have nothing to do.I found a great explanation here. In short: The notify() method is generally used\n  for resource pools, where there\n  are an arbitrary number of "consumers"\n  or "workers" that take resources, but\n  when a resource is added to the pool,\n  only one of the waiting consumers or\n  workers can deal with it. The\n  notifyAll() method is actually used in\n  most other cases. Strictly, it is\n  required to notify waiters of a\n  condition that could allow multiple\n  waiters to proceed. But this is often\n  difficult to know. So as a general\n  rule, if you have no particular\n  logic for using notify(), then you\n  should probably use notifyAll(),\n  because it is often difficult to know\n  exactly what threads will be waiting\n  on a particular object and why.From Joshua Bloch, the Java Guru himself in Effective Java 2nd edition:"Item 69: Prefer concurrency utilities to wait and notify".Note that with concurrency utilities you also have the choice between signal() and signalAll() as these methods are called there.  So the question remains valid even with java.util.concurrent.Doug Lea brings up an interesting point in his famous book: if a notify() and Thread.interrupt() happen at the same time, the notify might actually get lost.  If this can happen and has dramatic implications notifyAll() is a safer choice even though you pay the price of overhead (waking too many threads most of the time).Here is an example. Run it. Then change one of the notifyAll() to notify() and see what happens.ProducerConsumerExample classDropbox classConsumer classProducer classShort summary:Always prefer notifyAll() over notify() unless you have a massively parallel application where a large number of threads all do the same thing.Explanation:notify() [...] wakes up a single\n  thread. Because notify() doesn\'t allow you to specify the thread that is\n  woken up, it is useful only in massively parallel applications \xe2\x80\x94 that\n  is, programs with a large number of threads, all doing similar chores.\n  In such an application, you don\'t care which thread gets woken up.source: https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.htmlCompare notify() with notifyAll() in the above described situation: a massively parallel application where threads are doing the same thing. If you call notifyAll() in that case, notifyAll() will induce the waking up (i.e. scheduling) of a huge number of threads, many of them unnecessarily (since only one thread can actually proceed, namely the thread which will be granted the monitor for the object wait(), notify(), or notifyAll() was called on), therefore wasting computing resources.Thus, if you don\'t have an application where a huge number of threads do the same thing concurrently, prefer notifyAll() over notify(). Why? Because, as other users have already answered in this forum, notify() wakes up a single thread that is waiting on this object\'s monitor. [...] The\n  choice is arbitrary and occurs at the discretion of the\n  implementation.source: Java SE8 API (https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--)Imagine you have a producer consumer application where consumers are ready (i.e. wait() ing) to consume, producers are ready (i.e. wait() ing) to produce and the queue of items (to be produced / consumed) is empty. In that case, notify() might wake up only consumers and never producers because the choice who is waken up is arbitrary. The producer consumer cycle wouldn\'t make any progress although producers and consumers are ready to produce and consume, respectively. Instead, a consumer is woken up (i.e. leaving the wait() status), doesn\'t take an item out of the queue because it\'s empty, and notify() s another consumer to proceed.In contrast, notifyAll() awakens both producers and consumers. The choice who is scheduled depends on the scheduler. Of course, depending on the scheduler\'s implementation, the scheduler might also only schedule consumers (e.g. if you assign consumer threads a very high priority). However, the assumption here is that the danger of the scheduler scheduling only consumers is lower than the danger of the JVM only waking up consumers because any reasonably implemented scheduler doesn\'t make just arbitrary decisions. Rather, most scheduler implementations make at least some effort to prevent starvation.I am very surprised that no one mentioned the infamous "lost wakeup" problem (google it).Basically:THEN you should use notifyAll unless you have provable guarantees that lost wakeups are impossible.A common example is a concurrent FIFO queue where:\nmultiple enqueuers (1. and 3. above) can transition your queue from empty to non-empty \nmultiple dequeuers (2. above) can wait for the condition "the queue is not empty"\nempty -> non-empty should notify dequeuersYou can easily write an interleaving of operations in which, starting from an empty queue, 2 enqueuers and 2 dequeuers interact and 1 enqueuer will remain sleeping.This is a problem arguably comparable with the deadlock problem.I hope this will clear some doubts.notify() : The notify() method wakes up one thread waiting\nfor the lock (the first thread that called wait() on that lock).notifyAll() : The notifyAll() method wakes up all the threads waiting for the lock; the JVM selects one of the threads from the list of threads waiting for the lock and wakes\nthat thread up.In the case of a single thread waiting for a lock, there is no significant difference between notify() and notifyAll(). However, when there is more than one thread waiting for the lock, in both notify() and notifyAll(), the exact thread woken up is under the control of the JVM and you cannot programmatically control waking up a specific thread.At first glance, it appears that it is a good idea to just call notify() to wake up one thread; it might seem unnecessary to wake up all the threads. However, the problem with notify() is that the thread woken up might not be the suitable one to be woken up (the thread might be waiting for some other condition, or the condition is still not satisfied for that thread etc). In that case, the notify() might be lost and no other thread will wake up potentially leading to a type of deadlock (the notification is lost and all other threads are waiting for notification\xe2\x80\x94forever).To avoid this problem, it is always better to call notifyAll() when there is more than one thread waiting for a lock (or more than one condition on which waiting is done). The notifyAll() method wakes up all threads, so it is not very efficient. however, this performance loss is negligible in real world applications.All the above answers are correct, as far as I can tell, so I\'m going to tell you something else. For production code you really should use the classes in java.util.concurrent. There is very little they cannot do for you, in the area of concurrency in java.notify() lets you write more efficient code than notifyAll().Consider the following piece of code that\'s executed from multiple parallel threads:\nIt can be made more efficient by using notify():\nIn the case if you have a large number of threads, or if the wait loop condition is costly to evaluate, notify() will be significantly faster than notifyAll(). For example, if you have 1000 threads then 999 threads will be awakened and evaluated after the first notifyAll(), then 998, then 997, and so on. On the contrary, with the notify() solution, only one thread will be awakened. Use notifyAll() when you need to choose which thread will do the work next:\nFinally, it\'s important to understand that in case of notifyAll(), the code inside synchronized blocks that have been awakened will be executed sequentially, not all at once. Let\'s say there are three threads waiting in the above example, and the fourth thread calls notifyAll(). All three threads will be awakened but only one will start execution and check the condition of the while loop. If the condition is true, it will call wait() again, and only then the second thread will start executing and will check its while loop condition, and so on.notify() wakes up the first thread that called wait() on the same object.notifyAll() wakes up all the threads that called wait() on the same object.The highest priority thread will run first.Take a look at the code posted by @xagyg.  Suppose two different threads are waiting for two different conditions:\nThe first thread is waiting for buf.size() != MAX_SIZE, and the second thread is waiting for buf.size() != 0.  Suppose at some point buf.size() is not equal to 0. JVM calls notify() instead of notifyAll(), and the first thread is notified (not the second one).   The first thread is woken up, checks for buf.size() which might return MAX_SIZE, and goes back to waiting. The second thread is not woken up, continues to wait and does not call get().notify() will wake up one thread while notifyAll() will wake up all. As far as I know there is no middle ground. But if you are not sure what notify() will do to your threads, use notifyAll(). Works like a charm everytime.Here\'s a simpler explanation:You\'re correct that whether you use notify() or notifyAll(), the immediate result is that exactly one other thread will acquire the monitor and begin executing. (Assuming some threads were in fact blocked on wait() for this object, other unrelated threads aren\'t soaking up all available cores, etc.) The impact comes later.Suppose thread A, B, and C were waiting on this object, and thread A gets the monitor. The difference lies in what happens once A releases the monitor. If you used notify(), then B and C are still blocked in wait(): they are not waiting on the monitor, they are waiting to be notified. When A releases the monitor, B and C will still be sitting there, waiting for a notify().If you used notifyAll(), then B and C have both advanced past the "wait for notification" state and are both waiting to acquire the monitor. When A releases the monitor, either B or C will acquire it (assuming no other threads are competing for that monitor) and begin executing.I would like to mention what is explained in Java Concurrency in Practice:First point, whether Notify or NotifyAll?If two threads A and B are waiting on different condition predicates\n  of same condition queue and notify is called, then it is upto JVM to\n  which thread JVM will notify.Now if notify was meant for thread A and JVM notified thread B, then\n  thread B will wake up and see that this notification is not useful so\n  it will wait again. And Thread A will never come to know about this\n  missed signal and someone hijacked it\'s notification.So, calling notifyAll will resolve this issue, but again it will have\n  performance impact as it will notify all threads and all threads will\n  compete for same lock and it will involve context switch and hence\n  load on CPU. But we should care about performance only if it is\n  behaving correctly, if it\'s behavior itself is not correct then\n  performance is of no use.This problem can be solved with using Condition object of explicit locking Lock, provided in jdk 5, as it provides different wait for each condition predicate. Here it will behave correctly and there will not be performance issue as it will call signal and make sure that only one thread is waiting for that conditionnotify will notify only one thread which are in waiting state, while notify all will notify all the threads in the waiting state now all the notified threads and all the blocked threads are eligible for the lock, out of which only one will get the lock and all others (including those who are in waiting state earlier) will be in blocked state.notify() - Selects a random thread from the wait set of the object and puts it in the BLOCKED state. The rest of the threads in the wait set of the object are still in the WAITING state.notifyAll() - Moves all the threads from the wait set of the object to BLOCKED state. After you use notifyAll(), there are no threads remaining in the wait set of the shared object because all of them are now in BLOCKED state and not in WAITING state. BLOCKED - blocked for lock acquisition.\nWAITING - waiting for notify ( or blocked for join completion ).There are three states for a thread. Now, when a notify() is called, JVM picks one thread and move them to to the BLOCKED state and hence to the RUNNING State as there is no competition for the monitor object.When a notifyAll() is called, JVM picks all the threads and move all of them to BLOCKED State. All these threads will get the lock of the object on a priority basis.Thread which is able to acquire the monitor first will be able to go to the RUNNING state first and so on.All the answers that says that notifyAll() wakes up all the threads and then randomly selects a thread are WRONG.notifyAll() selects a thread with the highest priority and then let\'s them work according to their priority.To summarize the excellent detailed explanations above, and in the simplest way I can think of, this is due to the limitations of the JVM built-in monitor, which 1) is acquired on the entire synchronization unit (block or object) and 2) does not discriminate about the specific condition being waited/notified on/about. This means that if multiple threads are waiting on different conditions and notify() is used, the selected thread may not be the one which would make progress on the newly fulfilled condition - causing that thread (and other currently still waiting threads which would be able to fulfill the condition, etc..) not to be able to make progress, and eventually starvation or program hangup. In contrast, notifyAll() enables all waiting threads to eventually re-acquire the lock and check for their respective condition, thereby eventually allowing progress to be made. So notify() can be used safely only if any waiting thread is guaranteed to allow progress to be made should it be selected, which in general is satisfied when all threads within the same monitor check for only one and the same condition - a fairly rare case in real world applications. When you call the wait() of the "object"(expecting the object lock is acquired),intern this will release the lock on that object and help\'s the other threads to have lock on this "object", in this scenario there will be more than 1 thread waiting for the "resource/object"(considering the other threads also issued the wait on the same above object and down the way there will be a thread that fill the resource/object and invokes notify/notifyAll). Here when you issue the notify of the same object(from the same/other side of the process/code),this will release a blocked and waiting single thread (not all the waiting threads  -- this released thread will be picked by JVM Thread Scheduler and all the lock obtaining process on the object is same as regular).If you have Only one thread that will be sharing/working on this object , it is ok to use the notify() method alone in your wait-notify implementation.now i am looking how exactly the jvm is identifying and breaking the waiting thread when we issue notify() on a object ...While there are some solid answers above, I am surprised by the number of confusions and misunderstandings I have read. This probably proves the idea that one should use java.util.concurrent as much as possible instead of trying to write own broken concurrent code.\nBack to the question: to summarize, the best practice today is to AVOID notify() in ALL situations due to the lost wakeup problem. Anyone who doesn\'t understand this should not be allowed to write mission critical concurrency code. If you are worried about the herding problem, one safe way to achieve waking one thread up at a time is to:\n1. Build an explicit waiting queue for the waiting threads;\n2. Have each of the thread in the queue wait for it\'s predecessor;\n3. Have each thread call notifyAll() when done.\nOr you can use Java.util.concurrent.*, which have already implemented this.This answer is a graphical rewriting and simplification of the excellent answer by xagyg, including comments by eran.Why use notifyAll, even when each product is intended for a single consumer?Consider producers and consumers, simplified as follows.Producer:Consumer:Assume 2 producers and 2 consumers, sharing a buffer of size 1. The following picture depicts a scenario leading to a deadlock, which would be avoided if all threads used notifyAll.Each notify is labeled with the thread being woken up.Waking up all does not make much significance here. \nwait notify and notifyall, all these are put after owning the object\'s monitor. If a thread is in the waiting stage and notify is called, this thread will take up the lock and no other thread at that point can take up that lock. So concurrent access can not take place at all. As far as i know any call to wait notify and notifyall can be made only after taking the lock on the object. Correct me if i am wrong.