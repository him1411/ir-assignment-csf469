This question already has an answer here:I often test my module in the Python Interpreter, and when I see an error, I quickly update the .py file. But how do I make it reflect on the Interpreter ? So, far I have been exiting and reentering the Interpreter because re importing the file again is not working for me."Reload is no longer a function in Python 3. Use imp.reload() instead" copied from commentsUse the reload builtin function:https://docs.python.org/2/library/functions.html#reloadWhen reload(module) is executed:Example:All the answers above about reload() or imp.reload() are deprecated.reload() is no longer a builtin function in python 3 and imp.reload() is marked deprecated (see help(imp)).It\'s better to use importlib.reload() instead.So, far I have been exiting and reentering the Interpreter because re importing the file again is not working for me.Yes, just saying import again gives you the existing copy of the module from sys.modules.You can say reload(module) to update sys.modules and get a new copy of that single module, but if any other modules have a reference to the original module or any object from the original module, they will keep their old references and Very Confusing Things will happen.So if you\'ve got a module a, which depends on module b, and b changes, you have to \xe2\x80\x98reload b\xe2\x80\x99 followed by \xe2\x80\x98reload a\xe2\x80\x99. If you\'ve got two modules which depend on each other, which is extremely common when those modules are part of the same package, you can\'t reload them both: if you reload p.a it\'ll get a reference to the old p.b, and vice versa. The only way to do it is to unload them both at once by deleting their items from sys.modules, before importing them again. This is icky and has some practical pitfalls to do with modules entries being None as a failed-relative-import marker.And if you\'ve got a module which passes references to its objects to system modules\xe2\x80\x89\xe2\x80\x94\xe2\x80\x89for example it registers a codec, or adds a warnings handler\xe2\x80\x89\xe2\x80\x94\xe2\x80\x89you\'re stuck; you can\'t reload the system module without confusing the rest of the Python environment.In summary: for all but the simplest case of one self-contained module being loaded by one standalone script, reload() is very tricky to get right; if, as you imply, you are using a \xe2\x80\x98package\xe2\x80\x99, you will probably be better off continuing to cycle the interpreter.In Python 3, the behaviour changes.  ... do something with my_stuff, then later:and you get a brand new, reloaded my_stuff.No matter how many times you import a module, you\'ll get the same copy of the module from sys.modules - which was loaded at first import mymoduleI am answering this late, as each of the above/previous answer has a bit of the answer, so I am attempting to sum it all up in a single answer.Using built-in function:For Python 2.x - Use the built-in reload(mymodule) function.For Python 3.x - Use the imp.reload(mymodule).For Python 3.4 - In Python 3.4 imp has been deprecated in favor of importlib i.e. importlib.reload(mymodule)Few caveats: External packages:reimport - Reimport currently supports Python 2.4 through 2.7.xreload- This works by executing the module in a scratch namespace, and then\npatching classes, methods and functions in place.  This avoids the\nneed to patch instances.  New objects are copied into the target\nnamespace.livecoding - Code reloading allows a running application to change its behaviour in response to changes in the Python scripts it uses. When the library detects a Python script has been modified, it reloads that script and replaces the objects it had previously made available for use with newly reloaded versions. As a tool, it allows a programmer to avoid interruption to their workflow and a corresponding loss of focus. It enables them to remain in a state of flow. Where previously they might have needed to restart the application in order to put changed code into effect, those changes can be applied immediately.Short answer:try using reimport: a full featured reload for Python.Longer answer: It looks like this question was asked/answered prior to the release of reimport, which bills itself as a "full featured reload for Python":This module intends to be a full featured replacement for Python\'s reload function. It is targeted towards making a reload that works for Python plugins and extensions used by longer running applications.Reimport currently supports Python 2.4 through 2.6.By its very nature, this is not a completely solvable problem. The goal of this module is to make the most common sorts of updates work well. It also allows individual modules and package to assist in the process. A more detailed description of what happens is on the overview page.Note: Although the reimport explicitly supports Python 2.4 through 2.6, I\'ve been trying it on 2.7 and it seems to work just fine.Basically reload as in allyourcode\'s asnwer. But it won\'t change underlying the code of already instantiated object or referenced functions. Extending from his answer:Not sure if this does all expected things, but you can do just like that:See here for a good explanation of how your dependent modules won\'t be reloaded and the effects that can have:http://pyunit.sourceforge.net/notes/reloading.htmlThe way pyunit solved it was to track dependent modules by overriding __import__ then to delete each of them from sys.modules and re-import.  They probably could\'ve just reload\'ed them, though.dragonfly\'s answer worked for me (python 3.4.3).Here is a lower level solution :