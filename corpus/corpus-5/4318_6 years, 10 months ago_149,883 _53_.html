I want to trigger an ajax request when the user has finished typing in a text box. I don\'t want it to run the function on every time the user types a letter because that would result in A LOT of ajax requests, however I don\'t want them to have to hit the enter button either.Is there a way so I can detect when the user has finished typing and then do the ajax request?Using jQuery here!\nDaveSo, I\'m going to guess finish typing means you just stop for a while, say 5 seconds.  So with that in mind, lets start a timer when the user releases a key and clear it when they press one.  I decided the input in question will be #myInput.Making a few assumptions...The chosen answer above does not work.Because typingTimer is occassionaly set multiple times (keyup pressed twice before keydown is triggered for fast typers etc.) then it doesn\'t clear properly.The solution below solves this problem and will call X seconds after finished as the OP requested. It also no longer requires the redundant keydown function. I have also added a check so that your function call won\'t happen if your input is empty.It\'s just one line with underscore.js debounce function:This basically says doSomething 500 milliseconds after I stop typing.For more info: http://underscorejs.org/#debounceYes, you can set a timeout of say 2 seconds on each and every key up event which will fire an ajax request. You can also store the XHR method and abort it on subsequent key press events so that you save bandwith even more. Here\'s something I\'ve written for an autocomplete script of mine.Hope this helps,Markofull example here: http://jsfiddle.net/ZYXp4/8/I like Surreal Dream\'s answer but I found that my "doneTyping" function would fire for every keypress, i.e. if you type "Hello" really quickly; instead of firing just once when you stop typing, the function would fire 5 times.The problem was that the javascript setTimeout function doesn\'t appear to overwrite or kill the any old timeouts that have been set, but if you do it yourself it works! So I just added a clearTimeout call just before the setTimeout if the typingTimer is set. See below:N.B. I would have liked to have just added this as a comment to Surreal Dream\'s answer but I\'m a new user and don\'t have enough reputation. Sorry!Modifying the accepted answer to handle additional cases such as paste:Well, strictly speaking no, as the computer cannot guess when the user has finished typing. You could of course fire a timer on key up, and reset it on every subsequent key up. If the timer expires, the user hasn\'t typed for the timer duration - you could call that "finished typing".If you expect users to make pauses while typing, there\'s no way to know when they are done.(Unless of course you can tell from the data when they are done) I don\'t think keyDown event is necessary in this case (please tell me why if I\'m wrong). In my (non-jquery) script similar solution looks like that:It\'s my first reply on Stack Overflow, so I hope this helps someone, someday:)You can use the onblur event to detect when the textbox loses focus:\nhttps://developer.mozilla.org/en/DOM/element.onblurThat\'s not the same as "stops typing", if you care about the case where the user types a bunch of stuff and then sits there with the textbox still focused.For that I would suggest tying a setTimeout to the onclick event, and assuming that after x amount of time with no keystrokes, the user has stopped typing.This is the a simple JS code I wrote:I feel like the solution is somewhat a bit simpler with the input event:Once you detect focus on the text box, on key up do a timeout check, and reset it each time it\'s triggered.When the timeout completes, do your ajax request.If you are looking for a specific length (such as a zipcode field):Not sure if my needs are just kind of weird, but I needed something similar to this and this is what I ended up using:Which allows me to have elements like this in my application:Which get updated when the user is "done typing" (no action for 2 seconds) or goes to another field (blurs out of the element)SOLUTION:I was implementing the search at my listing and need it to be ajax based. That mean that on every key change searched results should be updated and displayed. This working results in so much ajax calls sent to server, which is not a good thing. After some working I made an approach to ping server when client stops typing.The solution worked for me is:You have noticed that there is no need of using any timer while implementing this.I am sure, this will help others.AtaIf you need wait until user is finished with typing use simple this:Complete Example with ajax call - this working for my pager - count of item per list:agree with the @going \'s answer. Another similar solution that worked for me is the one below. The only difference is that I am using .on("input"...) instead of keyup. This only captures changes in the input. other keys like Ctrl, Shift etc. are ignoredWhy not just use onfocusout?https://www.w3schools.com/jsreF/event_onfocusout.asp If it\'s a form, they will always leave focus of every input field in order to click the submit button so you know no input will miss out on getting its onfocusout event handler called. Wow, even 3 comments are pretty correct! Empty input is not a reason to skip function call, e.g. I remove waste parameter from url before redirect .on (\'input\', function() { ... }); should be used to trigger keyup, paste and change events definitely .val() or .value must be used You can use $(this) inside event function instead of #id to work with multiple inputs (my decision) I use anonymous function instead of doneTyping in setTimeout to easily access $(this) from n.4, but you need to save it first like var $currentInput = $(this);