Could someone please advise the current "best practice" around Date and Calendar types.When writing new code, is it best to always favour Calendar over Date, or are there circumstances where Date is the more appropriate datatype?Date is a simpler class and is mainly there for backward compatibility reasons. If you need to set particular dates or do date arithmetic, use a Calendar. Calendars also handle localization. The previous date manipulation functions of Date have since been deprecated.Personally I tend to use either time in milliseconds as a long (or Long, as appropriate) or Calendar when there is a choice.Both Date and Calendar are mutable, which tends to present issues when using either in an API.The best way for new code (if your policy allows third-party code) is to use the Joda Time library.Both, Date and Calendar, have so many design problems that neither are good solutions for new code.Date and Calendar are really the same fundamental concept (both represent an instant in time and are wrappers around an underlying long value). One could argue that Calendar is actually even more broken than Date is, as it seems to offer concrete facts about things like day of the week and time of day, whereas if you change its timeZone property, the concrete turns into blancmange! Neither objects are really useful as a store of year-month-day or time-of-day for this reason.Use Calendar only as a calculator which, when given Date and TimeZone objects, will do calculations for you. Avoid its use for property typing in an application.Use SimpleDateFormat together with TimeZone and Date to generate display Strings.If you\'re feeling adventurous use Joda-Time, although it is unnecessarily complicated IMHO and is soon to be superceded by the JSR-310 date API in any event.I have answered before that it is not difficult to roll your own YearMonthDay class, which uses Calendar under the hood for date calculations. I was downvoted for the suggestion but I still believe it is a valid one because Joda-Time (and JSR-310) are really so over-complicated for most use-cases.Date is best for storing a date object. It is the persisted one, the Serialized one ...Calendar is best for manipulating Dates.Note: we also sometimes favor java.lang.Long over Date, because Date is mutable and therefore not thread-safe. On a Date object, use setTime() and getTime() to switch between the two. For example, a constant Date in the application (examples: the zero 1970/01/01, or an applicative END_OF_TIME that you set to 2099/12/31 ; those are very useful to replace null values as start time and end time, especially when you persist them in the database, as SQL is so peculiar with nulls).Dates should be used as immutable points in time; Calendars are mutable, and can be passed around and modified if you need to collaborate with other classes to come up with a final date.  Consider them analogous to String and StringBuilder and you\'ll understand how I consider they should be used.(And yes, I know Date isn\'t actually technically immutable, but the intention is that it should not be mutable, and if nothing calls the deprecated methods then it is so.)I generally use Date if possible. Although it is mutable, the mutators are actually deprecated.  In the end it basically wraps a long that would represent the date/time.  Conversely, I would use Calendars if I have to manipulate the values.You can think of it this way: you only use StringBuffer only when you need to have Strings that you can easily manipulate and then convert them into Strings using toString() method.  In the same way, I only use Calendar if I need to manipulate temporal data.For best practice, I tend to use immutable objects as much as possible outside of the domain model.  It significantly reduces the chances of any side effects and it is done for you by the compiler, rather than a JUnit test.  You use this technique by creating private final fields in your class.And coming back to the StringBuffer analogy.  Here is some code that shows you how to convert between Calendar and DateWith Java 8, the new java.time package should be used.Objects are immutable, time zones and day light saving are taken into account.You can create a ZonedDateTime object from an old java.util.Date object like this:I always advocate Joda-time. Here\'s why.A little bit late at party, but Java has a new Date Time API in JDK 8. You may want to upgrade your JDK version and embrace the standard. No more messy date/calendar, no more 3rd party jars.advise the current "best practice" around Date and Calendaris it best to always favour Calendar over DateAvoid these legacy classes entirely. Use java.time classes instead.The Answer by Ortomala Lokni is right to suggest using the modern java.time classes rather than the troublesome old legacy date-time classes (Date, Calendar, etc.). But that Answer suggests the wrong class as equivalent (see my comment on that Answer). The java.time classes are a vast improvement over the legacy date-time classes, night-and-day difference. The old classes are poorly-designed, confusing, and troublesome. You should avoid the old classes whenever possible. But when you need to convert to/from the old/new, you can do so by calling new methods add to the old classes. For much more information on conversion, see my Answer and nifty diagram to another Question, Convert java.util.Date to what \xe2\x80\x9cjava.time\xe2\x80\x9d type?.Searching Stack Overflow gives many hundreds of example Questions and Answers on using java.time. But here is a quick synopsis.Get the current moment with an Instant. The Instant class represents a moment on the timeline in UTC with a resolution of nanoseconds (up to nine (9) digits of a decimal fraction). To see that same simultaneous moment through the lens of some particular region\xe2\x80\x99s wall-clock time, apply a time zone (ZoneId) to get a ZonedDateTime.Specify a proper time zone name in the format of continent/region, such as America/Montreal, Africa/Casablanca, or Pacific/Auckland. Never use the 3-4 letter abbreviation such as EST or IST as they are not true time zones, not standardized, and not even unique(!). A time zone is a region\xe2\x80\x99s history of changes in its offset-from-UTC. But sometimes you are given only an offset without the full zone. In that case, use the OffsetDateTime class.Use of a time zone is preferable over use of a mere offset.The \xe2\x80\x9cLocal\xe2\x80\x9d in the Local\xe2\x80\xa6 classes means any locality, not a particular locality. So the name can be counter-intuitive.LocalDateTime, LocalDate, and LocalTime purposely lack any information about offset or time zone. So they do not represent actual moments, they are not points on the timeline. When in doubt or in confusion, use ZonedDateTime rather than LocalDateTime. Search Stack Overflow for much more discussion.Do not conflate date-time objects with strings that represent their value. You can parse a string to get a date-time object, and you can generate a string from a date-time object. But the string is never the date-time itself. Learn about standard ISO 8601 formats, used by default in the java.time classes.Date should be re-developed. Instead of being a long interger, it should hold year, month, date, hour, minute, second, as separate fields. It might be even good to store the calendar and time zone this date is associated with.In our natural conversation, if setup an appointment at Nov. 1, 2013 1pm NY Time, this is a DateTime. It is NOT a Calendar. So we should be able to converse like this in Java as well.When Date is stored as a long integer (of mili seconds since Jan 1 1970 or something), calculating its current date depends on the calendar. Different calendars will give different date. This is from the prospective of giving an absolute time (eg 1 trillion seconds after Big Bang). But often we also need a convenient way of conversation, like an object encapsulating year, month etc.I wonder if there are new advances in Java to reconcile these 2 objectives. Maybe my java knowledge is too old.Btw "date" is usually tagged as "obsolete / deprecated" (I dont know exactly why) - something about it is wrote there \nJava: Why is the Date constructor deprecated, and what do I use instead?It looks like it\'s a problem of the constructor only- way via new Date(int year, int month, int day), recommended way is via Calendar and set params separately .. (Calendar cal = Calendar.getInstance();\n)