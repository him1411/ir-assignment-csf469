C# 2008I have been working on this for a while now, and I am still confused about some issues. My questions are belowI know that you only need a finalizer if you are disposing of unmanaged resources. However, if you are using managed resources that make calls to unmanaged resources, would you still need to implement a finalizer?However, if you develop a class that doesn\'t use any unmanaged resources, directly or indirectly, can you implement the IDisposable so that clients of your class can use the \'using statement\'? Would it be acceptable to implement the IDisposable just so that clients of your class can use the using statement?I have developed this simple code below to demonstrate the Finalize/dispose pattern:Question about the source code:Here I have not added the finalizer, and normally the finalizer will be called by the GC, and the finalizer will call the Dispose. As I don\'t have the finalizer, when do I call the Dispose method? Is it the client of the class that has to call it?So my class in the example is called NoGateway and the client could use and dispose of the class like this:  Would the Dispose method be automatically called when execution reaches the end of the using block, or does the client have to manually call the dispose method? i.e.I am using the webclient class in my NoGateway class. Because the webclient implements the IDisposable interface, does this mean that the webclient indirectly uses unmanaged resources? Is there a hard and fast rule to follow about this? How do I know that a class uses unmanaged resources?The recommended IDisposable pattern is here. When programming a class that uses IDisposable, generally you should use two patterns:When implementing a sealed class that doesn\'t use unmanaged resources, you simply implement a Dispose method as with normal interface implementations:When implementing an unsealed class, do it like this:Notice that I haven\'t declared a finalizer in B; you should only implement a finalizer if you have actual unmanaged resources to dispose. The CLR deals with finalizable objects differently to non-finalizable objects, even if SuppressFinalize is called.So, you shouldn\'t declare a finalizer unless you have to, but you give inheritors of your class a hook to call your Dispose and implement a finalizer themselves if they use unmanaged resources directly:If you\'re not using unmanaged resources directly (SafeHandle and friends doesn\'t count, as they declare their own finalizers), then don\'t implement a finalizer, as the GC deals with finalizable classes differently, even if you later suppress the finalizer. Also note that, even though B doesn\'t have a finalizer, it still calls SuppressFinalize to correctly deal with any subclasses that do implement a finalizer.When a class implements the IDisposable interface, it means that somewhere there are some unmanaged resources that should be got rid of when you\'ve finished using the class. The actual resources are encapsulated within the classes; you don\'t need to explicitly delete them. Simply calling Dispose() or wrapping the class in a using(...) {} will make sure any unmanaged resources are got rid of as necessary.The official pattern to implement IDisposable is hard to understand. I believe this one is better:An even better solution is to have a rule that you always have to create a wrapper class for any unmanaged resource that you need to handle:With SafeHandle and its derivatives, these classes should be very rare.The result for disposable classes that don\'t deal directly with unmanaged resources, even in the presence of inheritance, is powerful: they don\'t need to be concerned with unmanaged resources anymore. They\'ll be simple to implement and to understand:Note that any IDisposable implementation should follow the below pattern (IMHO).  I developed this pattern based on info from several excellent .NET "gods" the .NET Framework Design Guidelines (note that MSDN does not follow this for some reason!).  The .NET Framework Design Guidelines were written by Krzysztof Cwalina (CLR Architect at the time) and Brad Abrams (I believe the CLR Program Manager at the time) and Bill Wagner ([Effective C#] and [More Effective C#] (just take a look for these on Amazon.com:Note that you should NEVER implement a Finalizer unless your class directly contains (not inherits) UNmanaged resources.  Once you implement a Finalizer in a class, even if it is never called, it is guaranteed to live for an extra collection. It is automatically placed on the Finalization Queue (which runs on a single thread).  Also, one very important note...all code executed within a Finalizer (should you need to implement one) MUST be thread-safe AND exception-safe!  BAD things will happen otherwise...(i.e. undetermined behavior and in the case of an exception, a fatal unrecoverable application crash).The pattern I\'ve put together (and written a code snippet for) follows:Here is the code for implementing IDisposable in a derived class.  Note that you do not need to explicitly list inheritance from IDisposable in the definition of the derived class.I\'ve posted this implementation on my blog at: How to Properly Implement the Dispose PatternI agree with pm100 (and should have explicitly said this in my earlier post).You should never implement IDisposable in a class unless you need it.  To be very specific, there are about 5 times when you would ever need/should implement IDisposable:Your class explicitly contains (i.e. not via inheritance) any managed resources which implement IDisposable and should be cleaned up once your class is no longer used.  For example, if your class contains an instance of a Stream, DbCommand, DataTable, etc.Your class explicitly contains any managed resources which implement a Close() method - e.g. IDataReader, IDbConnection, etc.  Note that some of these classes do implement IDisposable by having Dispose() as well as a Close() method.Your class explicitly contains an unmanaged resource - e.g. a COM object, pointers (yes, you can use pointers in managed C# but they must be declared in \'unsafe\' blocks, etc.\nIn the case of unmanaged resources, you should also make sure to call System.Runtime.InteropServices.Marshal.ReleaseComObject() on the RCW.  Even though the RCW is, in theory, a managed wrapper, there is still reference counting going on under the covers.If your class subscribes to events using strong references. You need to unregister/detach yourself from the events. Always to make sure these are not null first before trying to unregister/detach them!.Your class contains any combination of the above...A recommended alternative to working with COM objects and having to use Marshal.ReleaseComObject() is to use the System.Runtime.InteropServices.SafeHandle class.The BCL (Base Class Library Team) has a good blog post about it here http://blogs.msdn.com/bclteam/archive/2005/03/16/396900.aspxOne very important note to make is that if you are working with WCF and cleaning up resources, you should ALMOST ALWAYS avoid the \'using\' block.  There are plenty of blog posts out there and some on MSDN about why this is a bad idea. I have also posted about it here - Don\'t use \'using()\' with a WCF proxyUsing lambdas instead of IDisposable.I have never been thrilled with the whole using/IDisposable idea. The problem is that it requires the caller to:My new preferred method is to use a factory method and a lambda insteadImagine I want to do something with a SqlConnection (something that should be wrapped in a using). Classically you would doNew wayIn the first case the caller could simply not use the using syntax. IN the second case the user has no choice. There is no method that creates a SqlConnection object, the caller must invoke DoWithConnection.DoWithConnection looks like thisMakeConnection is now privatenobody answered the question about whether you should implement IDisposable even though you dont need it.Short answer : NoLong answer:This would allow a consumer of your class to use \'using\'. The question I would ask is - why would they do it? Most devs will not use \'using\' unless they know that they must - and how do they know. EitherSo by implementing IDisposable you are telling devs (at least some) that this class wraps up something that must be released. They will use \'using\' - but there are other cases where using is not possible (the scope of object is not local); and they will have to start worrying about the lifetime of the objects in those other cases - I would worry for sure. But this is not necessaryYou implement Idisposable to enable them to use using, but they wont use using unless you tell them to.So dont do itIf you are using other managed objects that are using unmanaged resources, it is not your responsibility to ensure those are finalized. Your responsibility is to call Dispose on those objects when Dispose is called on your object, and it stops there.If your class doesn\'t use any scarce resources, I fail to see why you would make your class implement IDisposable. You should only do so if you\'re:Yes, the code that uses your code must call the Dispose method of your object. And yes, the code that uses your object can use using as you\'ve shown.(2 again?) It is likely that the WebClient uses either unmanaged resources, or other managed resources that implement IDisposable. The exact reason, however, is not important. What is important is that it implements IDisposable, and so it falls on you to act upon that knowledge by disposing of the object when you\'re done with it, even if it turns out WebClient uses no other resources at all.@Icey,Actually your response is slighty incorrect for 2 reasons:First,actually is equivalent to:This may sound ridiculous since the \'new\' operator should never return \'null\' unless you have an OutOfMemory exception.  But consider the following cases:\n1. You call a FactoryClass that returns an IDisposable resource or\n2. If you have a type that may or may not inherit from IDisposable depending on its implementation - remember that I\'ve seen the IDisposable pattern implemented incorrectly many times at many clients where developers just add a Dispose() method without inheriting from IDisposable (bad, bad, bad).  You could also have the case of an IDisposable resource being returned from a property or method (again bad, bad, bad - don\'t \'give away your IDisposable resources)If the \'as\' operator returns null (or property or method returning the resource), and your code in the \'using\' block protects against \'null\', your code will not blow up when trying to call Dispose on a null object because of the \'built-in\' null check.The second reason your reply is not accurate is because of the following stmt:A finalizer is called upon the GC destroying your objectFirst, Finalization (as well as GC itself) is non-deterministic.  THe CLR determines when it will call a finalizer.  i.e. the developer/code has no idea.  If the IDisposable pattern is implemented correctly (as I\'ve posted above) and GC.SuppressFinalize() has been called, the the Finalizer will NOT be called.  This is one of the big reasons to properly implement the pattern correctly.  Since there is only 1 Finalizer thread per managed process, regardless of the number of logical processors, you can easily degrade performance by backing up or even hanging the Finalizer thread by forgetting to call GC.SuppressFinalize().I\'ve posted a correct implementation of the Dispose Pattern on my blog: How to Properly Implement the Dispose PatternDispose pattern:Example of inheritance:is equivalent to A finalizer is called upon the GC destroying your object. This can be at a totally different time than when you leave your method. The Dispose of IDisposable is called immediately after you leave the using block. Hence the pattern is usually to use using to free ressources immediately after you don\'t need them anymore.1) WebClient is a managed type, so you don\'t need a finalizer.  The finalizer is needed in the case your users don\'t Dispose() of your NoGateway class and the native type (which is not collected by the GC) needs to be cleaned up after.  In this case, if the user doesn\'t call Dispose(), the contained WebClient will be disposed by the GC right after the NoGateway does.2) Indirectly yes, but you shouldn\'t have to worry about it.  Your code is correct as stands and you cannot prevent your users from forgetting to Dispose() very easily.Pattern from msdn From what I know, it\'s highly recommended NOT to use the Finalizer / Destructor:Mostly, this is due to not knowing when or IF it will be called. The dispose method is much better, especially if you us using or dispose directly.using is good. use it :)